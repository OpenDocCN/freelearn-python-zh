- en: Strings and Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串与序列化
- en: 'Before we get involved with higher-level design patterns, let''s take a deep
    dive into one of Python''s most common objects: the string. We''ll see that there
    is a lot more to the string than meets the eye, and also cover searching strings
    for patterns, and serializing data for storage or transmission.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究高级设计模式之前，让我们深入探讨Python中最常见的对象之一：字符串。我们会看到字符串远不止表面看起来那么简单，还会涵盖在字符串中搜索模式以及序列化数据以进行存储或传输。
- en: 'In particular, we''ll look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们将探讨以下主题：
- en: The complexities of strings, bytes, and byte arrays
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串、字节和字节数组的复杂性
- en: The ins and outs of string formatting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式化的来龙去脉
- en: A few ways to serialize data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种序列化数据的方法
- en: The mysterious regular expression
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神秘的正则表达式
- en: Strings
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are a basic primitive in Python; we've used them in nearly every example
    we've discussed so far. All they do is represent an immutable sequence of characters.
    However, though you may not have considered it before, *character* is a bit of
    an ambiguous word; can Python strings represent sequences of accented characters?
    Chinese characters? What about Greek, Cyrillic, or Farsi?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是Python中的一个基本原始类型；我们已经在迄今为止的几乎所有示例中都使用了它们。它们所做的只是表示一个不可变的字符序列。然而，尽管你可能之前没有考虑过，*字符*这个词有点模糊；Python字符串能否表示带重音的字符序列？中文字符？那么希腊文、西里尔文或波斯文呢？
- en: 'In Python 3, the answer is yes. Python strings are all represented in Unicode,
    a character definition standard that can represent virtually any character in
    any language on the planet (and some made-up languages and random characters as
    well). This is done seamlessly. So, let''s think of Python 3 strings as an immutable
    sequence of Unicode characters. We''ve touched on many of the ways strings can
    be manipulated in previous examples, but let''s quickly cover it all in one place:
    a crash course in string theory!'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，答案是肯定的。Python字符串全部以Unicode表示，这是一个字符定义标准，可以表示地球上任何语言的几乎所有字符（以及一些虚构语言和随机字符）。这是无缝完成的。因此，让我们将Python
    3字符串视为一个不可变的Unicode字符序列。我们在之前的示例中已经触及了许多字符串操作的方法，但让我们在这里快速总结一下：字符串理论的快速入门！
- en: String manipulation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'As you know, strings can be created in Python by wrapping a sequence of characters
    in single or double quotes. Multiline strings can easily be created using three
    quote characters, and multiple hardcoded strings can be concatenated together
    by placing them side by side. Here are some examples:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在Python中，可以通过将字符序列用单引号或双引号括起来来创建字符串。使用三个引号字符可以轻松创建多行字符串，并且可以通过将它们并排放置来连接多个硬编码的字符串。以下是一些示例：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That last string is automatically composed into a single string by the interpreter.
    It is also possible to concatenate strings using the `+` operator (as in `"hello
    " + "world"`). Of course, strings don't have to be hardcoded. They can also come
    from various outside sources, such as text files, user input, or can be encoded
    on the network.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那最后一个字符串会被解释器自动组合成一个单一的字符串。也可以使用`+`运算符来连接字符串（如`"hello " + "world"`）。当然，字符串不必是硬编码的。它们也可以来自各种外部来源，例如文本文件、用户输入，或者可以在网络上编码。
- en: The automatic concatenation of adjacent strings can make for some hilarious
    bugs when a comma is missed. It is, however, extremely useful when a long string
    needs to be placed inside a function call without exceeding the 79 - character
    line-length limit suggested by the Python style guide.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当遗漏逗号时，相邻字符串的自动连接可能会产生一些令人捧腹的错误。然而，当需要将长字符串放入函数调用中而不超过Python风格指南建议的79个字符行长度限制时，这却非常有用。
- en: Like other sequences, strings can be iterated over (character by character),
    indexed, sliced, or concatenated. The syntax is the same as for lists.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他序列一样，字符串可以逐个字符迭代（按字符索引），切片或连接。语法与列表相同。
- en: The `str` class has numerous methods on it to make manipulating strings easier.
    The `dir` and `help` commands in the Python interpreter can tell us how to use
    all of them; we'll consider some of the more common ones directly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`类上有许多方法来简化字符串操作。Python解释器中的`dir`和`help`命令可以告诉我们如何使用它们的所有方法；我们将直接考虑一些更常见的方法。'
- en: Several Boolean convenience methods help us identify whether or not the characters
    in a string match a certain pattern. Here is a summary of these methods. Most
    of these, such as `isalpha`, `isupper`/`islower`, and `startswith`/`endswith`,
    have obvious interpretations. The `isspace` method is also fairly obvious, but
    remember that all whitespace characters (including tab and newline) are considered,
    not just the space character.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 几个布尔便利方法帮助我们确定字符串中的字符是否匹配某种模式。以下是这些方法的总结。其中大多数，如 `isalpha`、`isupper`/`islower`、`startswith`/`endswith`，都有明显的解释。`isspace`
    方法也很明显，但请记住，所有空白字符（包括制表符和换行符）都被考虑在内，而不仅仅是空格字符。
- en: The `istitle` method returns `True` if the first character of each word is capitalized
    and all other characters are lowercase. Note that it does not strictly enforce
    the English grammatical definition of title formatting. For example, Leigh Hunt's
    poem *The Glove and the Lions* should be a valid title, even though not all words
    are capitalized. Robert Service's *The Cremation of Sam McGee* should also be
    a valid title, even though there is an uppercase letter in the middle of the last
    word.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`istitle` 方法返回 `True`，如果每个单词的首字母都大写且所有其他字母都小写。请注意，它并不严格遵循英语语法对标题格式的定义。例如，利·亨特的诗作《手套与狮子》应该是一个有效的标题，即使不是所有单词都大写。罗伯特·塞尔的《萨姆·麦基的火化》也应该是一个有效的标题，即使最后一个单词的中间有一个大写字母。'
- en: 'Be careful with the `isdigit`, `isdecimal`, and `isnumeric` methods, as they
    are more nuanced than we would expect. Many Unicode characters are considered
    numbers besides the 10 digits we are used to. Worse, the period character that
    we use to construct floats from strings is not considered a decimal character,
    so `''45.2''.isdecimal()` returns `False`. The real decimal character is represented
    by Unicode value 0660, as in 45.2 (or `45\u06602`). Further, these methods do
    not verify whether the strings are valid numbers; `127.0.0.1` returns `True` for
    all three methods. We might think we should use that decimal character instead
    of a period for all numeric quantities, but passing that character into the `float()`
    or `int()` constructor converts that decimal character to a zero:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `isdigit`、`isdecimal` 和 `isnumeric` 方法时要小心，因为它们比我们预期的要复杂。除了我们习惯的10个数字之外，许多Unicode字符也被认为是数字。更糟糕的是，我们用来从字符串构造浮点数的点字符不被认为是十进制字符，所以
    `'45.2'.isdecimal()` 返回 `False`。真正的十进制字符由Unicode值 0660 表示，如 45.2（或 `45\u06602`）。此外，这些方法不验证字符串是否是有效的数字；`127.0.0.1`
    对所有三种方法都返回 `True`。我们可能会认为我们应该用那个十进制字符而不是点来表示所有的数值，但将那个字符传递给 `float()` 或 `int()`
    构造函数会将那个十进制字符转换为零：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result of all these inconsistencies is that the Boolean numeric checks are
    not very useful at all. We're usually much better off using a regular expression
    (discussed later in this chapter) to confirm whether the string matches a specific
    numeric pattern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不一致的结果是，布尔数值检查几乎没有任何用处。我们通常使用正则表达式（本章后面将讨论）来确认字符串是否匹配特定的数值模式会更好。
- en: 'Other methods useful for pattern-matching do not return Booleans. The `count`
    method tells us how many times a given substring shows up in the string, while
    `find`, `index`, `rfind`, and `rindex` tell us the position of a given substring
    within the original string. The two `r` (for *right* or *reverse*) methods start
    searching from the end of the string. The `find` methods return `-1` if the substring
    can''t be found, while `index` raises `ValueError` in this situation. Have a look
    at some of these methods in action:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 其他用于模式匹配的方法不返回布尔值。`count` 方法告诉我们给定子字符串在字符串中出现的次数，而 `find`、`index`、`rfind` 和
    `rindex` 告诉我们在原始字符串中给定子字符串的位置。两个 `r`（代表 *right* 或 *reverse*）方法从字符串的末尾开始搜索。`find`
    方法在找不到子字符串时返回 `-1`，而 `index` 在这种情况下会引发 `ValueError`。看看这些方法在实际中的应用：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most of the remaining string methods return transformations of the string. The
    `upper`, `lower`, `capitalize`, and `title` methods create new strings with all
    alphabetical characters in the given format. The `translate` method can use a
    dictionary to map arbitrary input characters to specified output characters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数剩余的字符串方法返回字符串的转换。`upper`、`lower`、`capitalize` 和 `title` 方法创建具有给定格式的新字符串，其中包含所有字母字符。`translate`
    方法可以使用字典将任意输入字符映射到指定的输出字符。
- en: For all of these methods, note that the input string remains unmodified; a brand
    new `str` instance is returned instead. If we need to manipulate the resultant
    string, we should assign it to a new variable, as in `new_value``=``value.capitalize()`.
    Often, once we've performed the transformation, we don't need the old value anymore,
    so a common idiom is to assign it to the same variable, as in `value``=``value.title()`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些方法，请注意输入字符串保持不变；而是返回一个新的`str`实例。如果我们需要操作结果字符串，我们应该将其分配给一个新的变量，例如`new_value
    = value.capitalize()`。通常，一旦我们完成了转换，我们就不再需要旧值了，所以一个常见的习惯是将它分配给同一个变量，例如`value =
    value.title()`。
- en: 'Finally, a couple of string methods return or operate on lists. The `split`
    method accepts a substring and splits the string into a list of strings wherever
    that substring occurs. You can pass a number as a second parameter to limit the
    number of resultant strings. The `rsplit`method behaves identically to `split`
    if you don''t limit the number of strings, but if you do supply a limit, it starts
    splitting from the end of the string. The `partition` and `rpartition `methods
    split the string at only the first or last occurrence of the substring, and return
    a tuple of three values: characters before the substring, the substring itself,
    and the characters after the substring.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一些字符串方法返回或操作列表。`split`方法接受一个子字符串，并将字符串分割成一个字符串列表，其中该子字符串出现的位置。你可以传递一个数字作为第二个参数来限制结果字符串的数量。`rsplit`方法在没有限制字符串数量时与`split`行为相同，但如果你提供了限制，它将从字符串的末尾开始分割。`partition`和`rpartition`方法仅在子字符串的第一个或最后一个出现处分割字符串，并返回一个包含三个值的元组：子字符串之前的字符、子字符串本身以及子字符串之后的字符。
- en: 'As the inverse of `split`, the `join` method accepts a list of strings, and
    returns all of those strings combined together by placing the original string
    between them. The `replace` method accepts two arguments, and returns a string
    where each instance of the first argument has been replaced with the second. Here
    are some of these methods in action:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`split`的逆操作，`join`方法接受一个字符串列表，并返回所有这些字符串通过在它们之间放置原始字符串组合在一起。`replace`方法接受两个参数，并返回一个字符串，其中每个第一个参数的实例都被第二个参数替换。以下是一些这些方法在实际中的应用：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There you have it, a whirlwind tour of the most common methods on the `str`
    class! Now, let's look at Python 3's method for composing strings and variables
    to create new strings.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们快速浏览了`str`类中最常见的方法！现在，让我们看看Python 3的字符串和变量组合方法来创建新的字符串。
- en: String formatting
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: Python 3 has powerful string formatting and templating mechanisms that allow
    us to construct strings comprised of hardcoded text and interspersed variables.
    We've used it in many previous examples, but it is much more versatile than the
    simple formatting specifiers we've used.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3拥有强大的字符串格式化和模板机制，允许我们构建由硬编码文本和穿插变量组成的字符串。我们已经在许多之前的例子中使用过它，但它比我们使用的简单格式化说明符要灵活得多。
- en: 'A string can be turned into a format string (also called an **f-string**) by
    prefixing the opening quotation mark with an f, as in `f"hello world"`. If such
    a string contains the special characters  `{` and `}`, variables from the surrounding
    scope can be used to replace them as in this example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串可以通过在开引号前加上f来转换成一个格式字符串（也称为**f-string**），例如`f"hello world"`。如果这样的字符串包含特殊字符`{`和`}`，可以使用周围作用域中的变量来替换它们，如下例所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we run these statements, it replaces the braces with variables, in order:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这些语句，它会按照以下顺序替换花括号中的变量：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Escaping braces
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转义花括号
- en: 'Brace characters are often useful in strings, aside from formatting. We need
    a way to escape them in situations where we want them to be displayed as themselves,
    rather than being replaced. This can be done by doubling the braces. For example,
    we can use Python to format a basic Java program:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号字符在字符串中除了格式化之外通常很有用。我们需要一种方法来在它们需要作为自身显示而不是被替换的情况下进行转义。这可以通过加倍花括号来实现。例如，我们可以使用Python格式化一个基本的Java程序：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Where we see the `{{` or `}}` sequence in the template—that is, the braces
    enclosing the Java class and method definition—we know the f-string will replace
    them with single braces, rather than some argument in the surrounding methods.
    Here''s the output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中我们看到`{{`或`}}`序列——即包围Java类和方法定义的花括号——我们知道f-string将用单个花括号替换它们，而不是周围方法中的某个参数。以下是输出：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The class name and contents of the output have been replaced with two parameters,
    while the double braces have been replaced with single braces, giving us a valid
    Java file. Turns out, this is about the simplest possible Python program to print
    the simplest possible Java program that can print the simplest possible Python
    program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输出类的名称和内容已被两个参数替换，而双花括号已被单花括号替换，从而生成一个有效的 Java 文件。结果证明，这是打印最简单的 Java 程序（该程序可以打印最简单的
    Python 程序）的 Python 程序中最简单的一种。
- en: f-strings can contain Python code
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: f-string 可以包含 Python 代码
- en: We aren't restricted to passing simple string variables into an f-string method.
    Any primitives, such as integers or floats, can be formatted. More interestingly,
    complex objects, including lists, tuples, dictionaries, and arbitrary objects
    can be used, and we can access indexes and variables or call functions on those
    objects from within the `format` string.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以将简单的字符串变量传递给 f-string 方法。任何原始数据类型，如整数或浮点数，都可以进行格式化。更有趣的是，包括列表、元组、字典和任意对象在内的复杂对象也可以使用，并且我们可以在
    `format` 字符串中访问这些对象的索引和变量或调用这些对象上的函数。
- en: 'For example, if our email message had grouped the `From` and `To` email addresses
    into a tuple, and placed the subject and message in a dictionary, for some reason
    (perhaps because that''s the input required for an existing `send_mail` function
    we want to use), we can format it like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的电子邮件消息将 `From` 和 `To` 电子邮件地址组合成一个元组，并将主题和消息放入一个字典中，出于某种原因（可能是因为我们需要使用现有的
    `send_mail` 函数作为输入），我们可以这样格式化：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The variables inside the braces in the template string look a little weird,
    so let's look at what they're doing. The two email addresses are looked up by
    `emails[x]`, where `x` is either `0` or `1`.  The square brackets with a number
    inside are the same kind of index lookup we see in regular Python code, so `emails[0]` 
    refers to the first item in the `emails` tuple. The indexing syntax works with
    any indexable object, so we see similar behavior when we access `message[subject]`,
    except this time we are looking up a string key in a dictionary. Notice that,
    unlike in Python code, we do not need to put quotes around the string in the dictionary
    lookup.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串中花括号内的变量看起来有点奇怪，让我们看看它们在做什么。两个电子邮件地址是通过 `emails[x]` 查找的，其中 `x` 要么是 `0`
    要么是 `1`。方括号内带有数字的索引查找与我们在常规 Python 代码中看到的是同一类型的，所以 `emails[0]` 指的是 `emails` 元组中的第一个元素。索引语法适用于任何可索引的对象，因此当我们访问
    `message[subject]` 时，我们看到类似的行为，只不过这次我们在字典中查找一个字符串键。请注意，与 Python 代码不同，在字典查找中我们不需要在字符串周围加上引号。
- en: 'We can even do multiple levels of lookup if we have nested data structures.
    If we modify the above code to put the `emails` tuple inside the `message` dictionary,
    we can use an indexed lookup as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有嵌套的数据结构，我们甚至可以进行多级查找。如果我们修改上面的代码，将 `emails` 元组放入 `message` 字典中，我们可以使用以下索引查找：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I would recommend against doing this often, as template strings rapidly become
    difficult to understand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议经常这样做，因为模板字符串很快就会变得难以理解。
- en: 'Alternatively, if you have an object or class, you can execute object lookups
    or even call methods inside the f-string. Let''s change our email message data
    once again, this time to a class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您有一个对象或类，您可以在 f-string 中执行对象查找或甚至调用方法。让我们再次更改我们的电子邮件消息数据，这次到一个类：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The template in this example may be more readable than the previous examples,
    but the overhead of creating an `email` class adds complexity to the Python code.
    It would be foolish to create a class for the express purpose of including the
    object in a template. Typically, we'd use this sort of lookup if the object we
    are trying to format already exists.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例相比，这个示例中的模板可能更容易阅读，但创建一个 `email` 类的开销增加了 Python 代码的复杂性。为了将对象包含在模板中而创建一个类是愚蠢的。通常，我们会使用这种查找，如果我们试图格式化的对象已经存在。
- en: 'Pretty much any Python code that you would expect to return a string (or a
    value that can convert to a string with the `str()` function) can be executed
    inside an f-string.  As an example of how powerful it can get, you can even use
    a list comprehension or ternary operator in a format string parameter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何你期望返回字符串（或可以由 `str()` 函数转换为字符串的值）的 Python 代码都可以在 f-string 中执行。作为一个例子，看看它有多强大，你甚至可以在格式字符串参数中使用列表推导式或三元运算符：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Making it look right
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使其看起来正确
- en: 'It''s nice to be able to include variables in template strings, but sometimes
    the variables need a bit of coercion to make them look the way we want them to
    in the output. For example, if we are performing calculations with currency, we
    may end up with a long decimal that we don''t want to show up in our template:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在模板字符串中包含变量是件好事，但有时变量需要一点强制才能在输出中看起来像我们想要的那样。例如，如果我们正在执行货币计算，我们可能会得到一个我们不希望在模板中显示的长小数：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we run this formatting code, the output doesn''t quite look like proper
    currency:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段格式化代码，输出结果并不完全像正确的货币格式：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Technically, we should never use floating-point numbers in currency calculations
    like this; we should construct `decimal.Decimal()` objects instead. Floats are
    dangerous because their calculations are inherently inaccurate beyond a specific
    level of precision. But we're looking at strings, not floats, and currency is
    a great example for formatting!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们永远不应该在这种货币计算中使用浮点数；我们应该构建`decimal.Decimal()`对象。浮点数是危险的，因为它们的计算在特定精度水平以上是不准确的。但我们正在看字符串，而不是浮点数，货币是一个很好的格式化例子！
- en: 'To fix the preceding `format` string, we can include some additional information
    inside the curly braces to adjust the formatting of the parameters. There are
    tons of things we can customize, but the basic syntax inside the braces is the
    same. After providing the template value, we include a colon, and then some specific
    syntax for the formatting. Here''s an improved version:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复前面的`format`字符串，我们可以在大括号内包含一些额外的信息来调整参数的格式。我们可以自定义很多东西，但大括号内的基本语法是相同的。在提供模板值后，我们包括一个冒号，然后是一些特定的格式化语法。这是一个改进的版本：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `0.2f` format specifier after the colons basically says the following,
    from left to right:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号后面的`0.2f`格式说明符基本上是这样说的，从左到右：
- en: '`0`: for values lower than one, make sure a zero is displayed on the left-hand
    of the decimal point'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：对于小于一的值，确保在十进制点的左侧显示零'
- en: '`.`: show a decimal point'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`：显示小数点'
- en: '`2`: show two places after the decimal'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：显示两位小数'
- en: '`f`: format the input value as a float'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`：将输入值格式化为浮点数'
- en: 'We can also specify that each number should take up a particular number of
    characters on the screen by placing a value before the period. This can be useful
    for outputting tabular data, for example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定每个数字应该在屏幕上占用特定数量的字符，通过在点号之前放置一个值。这可以用于输出表格数据，例如：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'OK, that''s a pretty scary-looking format string, so let''s see how it works
    before we break it down into understandable parts:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个格式字符串看起来相当吓人，所以在我们将其分解成可理解的部分之前，让我们先看看它是如何工作的：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Nifty! So, how is this actually happening? We have four variables we are formatting,
    in each line of the `for` loop. The first variable is a string that is formatted
    with `{product:10s}`. This one is easier to read from right to left:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！那么，这实际上是如何发生的呢？我们有四个变量需要格式化，在`for`循环的每一行中。第一个变量是一个使用`{product:10s}`格式化的字符串。从右到左读起来更容易：
- en: '`s` means it is a string variable.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` 表示这是一个字符串变量。'
- en: '`10` means it should take up 10 characters. By default, with strings, if the
    string is shorter than the specified number of characters, it appends spaces to
    the right-hand side of the string to make it long enough (beware, however: if
    the original string is too long, it won''t be truncated!).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10` 表示它应该占用10个字符。默认情况下，对于字符串，如果字符串的长度小于指定的字符数，它会在字符串的右侧添加空格，使其足够长（但是请注意：如果原始字符串太长，它不会被截断！）。'
- en: '`product:`, of course, is the name of the variable or Python expression being
    formatted.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product:`, 当然，是正在格式化的变量或Python表达式的名称。'
- en: 'The formatter for the `quantity` value is`{quantity: ^9d}`. You can interpret
    this format from right to left as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`quantity`值的格式化器是`{quantity: ^9d}`。你可以从右到左这样解释这个格式：'
- en: '`d` represents an integer value.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d` 代表一个整数值。'
- en: '`9` tells us the value should take up nine characters on the screen.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`9` 告诉我们值应该在屏幕上占用九个字符。'
- en: '`^` tells us that the number should be aligned in the center of this available
    padding; this makes the column look a bit more professional.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` 告诉我们数字应该在这个可用填充区的中心对齐；这使得列看起来更专业。'
- en: (space) tells the formatter to use a space as the padding character. With integers,
    instead of spaces, the extra characters are zeros, by default.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （空格）告诉格式化器使用空格作为填充字符。对于整数，默认情况下，额外的字符是零。
- en: '`quantity:` is the variable being formatted.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity:` 是正在格式化的变量。'
- en: 'All these specifiers have to be in the right order, although all are optional:
    fill first, then align, then the size, and finally, the type.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些指定符都必须按照正确的顺序排列，尽管它们都是可选的：首先填充，然后对齐，接着是大小，最后是类型。
- en: We do similar things with the specifiers for `price` and `subtotal`. For `price`,
    we use `{2:``<8.2f}`; and for `subtotal`, `{3:``>7.2f}`. In both cases, we're
    specifying a space as the fill character, but we use the `<` and `>` symbols,
    respectively, to represent that the numbers should be aligned to the left or right
    within a minimum space of eight or seven characters. Further, each float should
    be formatted to two decimal places.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`price`和`subtotal`的指定符做类似处理。对于`price`，我们使用`{2:<8.2f}`；对于`subtotal`，我们使用`{3:>7.2f}`。在这两种情况下，我们指定空格作为填充字符，但分别使用`<`和`>`符号来表示数字应在至少八或七个字符的最小空间内左对齐或右对齐。此外，每个浮点数应格式化为两位小数。
- en: The *type* character for different types can affect formatting output as well.
    We've seen the `s`, `d`, and `f` types, for strings, integers, and floats. Most
    of the other format specifiers are alternative versions of these; for example,
    `o` represents octal format and `X` represents hexadecimal if formatting integers.
    The `n` type specifier can be useful for formatting integer separators in the
    current locale's format. For floating-point numbers, the `%` type will multiply
    by 100 and format a float as a percentage.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同类型的*类型*字符可以影响格式化输出。我们已经看到了`s`、`d`和`f`类型，分别用于字符串、整数和浮点数。大多数其他格式指定符都是这些类型的替代版本；例如，`o`代表八进制格式，`X`代表十六进制格式，如果格式化整数。`n`类型指定符可以用于在当前区域设置的格式中格式化整数分隔符。对于浮点数，`%`类型将乘以100并将浮点数格式化为百分比。
- en: Custom formatters
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义格式化程序
- en: 'While these standard formatters apply to most built-in objects, it is also
    possible for other objects to define nonstandard specifiers. For example, if we
    pass a `datetime` object into `format`, we can use the specifiers used in the
    `datetime.strftime` function, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些标准格式化程序适用于大多数内置对象，但其他对象也可以定义非标准指定符。例如，如果我们将一个`datetime`对象传递给`format`，我们可以使用`datetime.strftime`函数中使用的指定符，如下所示：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is even possible to write custom formatters for objects we create ourselves,
    but that is beyond the scope of this book. Look into overriding the `__format__`
    special method if you need to do this in your code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以为我们自己创建的对象编写自定义格式化程序，但这超出了本书的范围。如果你需要在代码中这样做，请查看是否需要重写`__format__`特殊方法。
- en: The Python formatting syntax is quite flexible but it is a difficult mini-language
    to remember. I use it every day and still occasionally have to look up forgotten
    concepts in the documentation. It also isn't powerful enough for serious templating
    needs, such as generating web pages. There are several third-party templating
    libraries you can look into if you need to do more than basic formatting of a
    few strings.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python的格式化语法非常灵活，但它是一个难以记住的小型语言。我每天都在使用它，仍然偶尔需要查阅文档中忘记的概念。它也不够强大，无法满足严肃的模板需求，例如生成网页。如果你需要做更多基本的字符串格式化之外的事情，可以查看几个第三方模板库。
- en: The format method
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化方法
- en: 'There are a few cases where you won''t be able to use f-strings. First, you
    can''t reuse a single template string with different variables. Second, f-strings
    were introduced in Python 3.6\. If you''re stuck on an older version of Python
    or need to reuse template strings, you can use the older `str.format` method instead.
    It uses the same formatting specifiers as f-strings, but can be called multiple
    times on one string. Here''s an example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下你将无法使用f-string。首先，你不能用不同的变量重用单个模板字符串。其次，f-string是在Python 3.6中引入的。如果你卡在Python的旧版本上或需要重用模板字符串，可以使用较旧的`str.format`方法。它使用与f-string相同的格式指定符，但可以在一个字符串上多次调用。以下是一个示例：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `format` method behaves similarly to f-strings, but there are a couple
    of differences:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`format`方法的行为与f-string类似，但有一些区别：'
- en: It is restricted in what it can look up. You can access attributes on objects
    or look up an index in a list or dict, but you can't call a function inside the
    template string.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在可以查找的内容上有限制。你可以访问对象上的属性或在列表或字典中查找索引，但不能在模板字符串内部调用函数。
- en: 'You can use integers to access positional arguments passed to the format method:
    `"{0} world".format(''bonjour'')`. The indexes are optional if you specify the
    variables in order: `"{} {}".format(''hello'', ''world'')`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用整数来访问传递给格式化方法的定位参数：`"{0} world".format('bonjour')`。如果你按顺序指定变量，索引是可选的：`"{}
    {}".format('hello', 'world')`。
- en: Strings are Unicode
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串是Unicode编码
- en: At the beginning of this section, we defined strings as collections of immutable
    Unicode characters. This actually makes things very complicated at times, because
    Unicode isn't really a storage format. If you get a string of bytes from a file
    or a socket, for example, they won't be in Unicode. They will, in fact, be the
    built-in type `bytes`. Bytes are immutable sequences of... well, bytes. Bytes
    are the basic storage format in computing. They represent 8 bits, usually described
    as an integer between 0 and 255, or a hexadecimal equivalent between 0 and FF.
    Bytes don't represent anything specific; a sequence of bytes may store characters
    of an encoded string, or pixels in an image.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，我们将字符串定义为不可变Unicode字符的集合。这实际上在某些时候使事情变得非常复杂，因为Unicode并不是真正的存储格式。例如，如果你从一个文件或套接字中获取一个字节字符串，它们不会是Unicode。实际上，它们将是内置类型`bytes`。字节是...字节的不可变序列。字节是计算中的基本存储格式。它们代表8位，通常描述为介于0和255之间的整数，或介于0和FF之间的十六进制等效值。字节不表示任何特定内容；字节序列可能存储编码字符串的字符，或图像中的像素。
- en: If we print a byte object, any bytes that map to ASCII representations will
    be printed as their original character, while non-ASCII bytes (whether they are
    binary data or other characters) are printed as hex codes escaped by the `\x`
    escape sequence. You may find it odd that a byte, represented as an integer, can
    map to an ASCII character. But ASCII is really just code where each letter is
    represented by a different byte pattern, and therefore, a different integer. The
    character *a* is represented by the same byte as the integer 97, which is the
    hexadecimal number 0x61\. Specifically, all of these are an interpretation of
    the binary pattern 01100001.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印一个字节对象，任何映射到ASCII表示的字节将被打印为其原始字符，而非ASCII字节（无论是二进制数据还是其他字符）将被打印为`\x`转义序列逃逸的十六进制代码。你可能觉得奇怪，一个表示为整数的字节可以映射到一个ASCII字符。但ASCII实际上是一种代码，其中每个字母都由不同的字节模式表示，因此，不同的整数。字符*a*由与整数97相同的字节表示，这是十六进制数0x61。具体来说，这些都是对二进制模式01100001的解释。
- en: Many I/O operations only know how to deal with `bytes`, even if the `bytes`
    object refers to textual data. It is therefore vital to know how to convert between
    `bytes` and Unicode.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 许多I/O操作只知道如何处理`字节`，即使`字节`对象引用的是文本数据。因此，了解如何在`字节`和Unicode之间进行转换至关重要。
- en: The problem is that there are many ways to map `bytes` to Unicode text. Bytes
    are machine-readable values, while text is a human-readable format. Sitting in
    between is an encoding that maps a given sequence of bytes to a given sequence
    of text characters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于有许多方法可以将`字节`映射到Unicode文本。字节是机器可读的值，而文本是供人类阅读的格式。介于两者之间的是一种编码，它将给定的字节序列映射到给定的文本字符序列。
- en: However, there are multiple such encodings (ASCII is only one of them). The
    same sequence of bytes represents completely different text characters when mapped
    using different encodings! So, `bytes` must be decoded using the same character
    set with which they were encoded. It's not possible to get text from bytes without
    knowing how the bytes should be decoded. If we receive unknown bytes without a
    specified encoding, the best we can do is guess what format they are encoded in,
    and we may be wrong.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在多种这样的编码（ASCII只是其中之一）。当使用不同的编码映射时，相同的字节序列会表示完全不同的文本字符！因此，`字节`必须使用与它们编码时相同的字符集进行解码。如果不了解字节应该如何解码，就无法从字节中获取文本。如果我们收到未指定编码的未知字节，我们最好的做法是猜测它们编码的格式，我们可能会出错。
- en: Converting bytes to text
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字节转换为文本
- en: If we have an array of `bytes` from somewhere, we can convert it to Unicode
    using the `.decode` method on the `bytes` class. This method accepts a string
    for the name of the character encoding. There are many such names; common ones
    for Western languages include ASCII, UTF-8, and latin-1.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从某个地方有一个`字节`数组，我们可以使用`bytes`类的`.decode`方法将其转换为Unicode。此方法接受一个字符串作为字符编码的名称。有许多这样的名称；用于西方语言的常见名称包括ASCII、UTF-8和latin-1。
- en: 'The sequence of bytes (in hex), 63 6c 69 63 68 e9, actually represents the
    characters of the word cliché in latin-1 encoding. The following example will
    encode this sequence of bytes and convert it to a Unicode string using latin-1
    encoding:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 字节序列（以十六进制表示），63 6c 69 63 68 e9，实际上代表了拉丁-1编码中单词cliché的字符。以下示例将使用latin-1编码对这个字节序列进行编码，并将其转换为Unicode字符串：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line creates a `bytes` object. Analogous to an f-string, the `b` character
    immediately before the string tells us that we are defining a `bytes` object instead
    of a normal Unicode string. Within the string, each byte is specified using—in
    this case—a hexadecimal number. The `\x` character escapes within the byte string,
    and each say, *the next two characters represent a byte using hexadecimal digits*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个`bytes`对象。类似于f-string，字符串前面的`b`字符告诉我们我们正在定义一个`bytes`对象，而不是普通的Unicode字符串。在字符串中，每个字节都使用——在这种情况下——十六进制数指定。`\x`字符在字节字符串中转义，每个表示——在这种情况下——使用十六进制数字表示一个字节。
- en: 'Provided we are using a shell that understands latin-1 encoding, the two `print`
    calls will output the following strings:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们使用的shell支持latin-1编码，两个`print`调用将输出以下字符串：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first `print` statement renders the bytes for ASCII characters as themselves.
    The unknown (unknown to ASCII, that is) character stays in its escaped hex format.
    The output includes a `b` character at the beginning of the line to remind us
    that it is a `bytes` representation, not a string.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`print`语句将ASCII字符的字节渲染为其自身。未知（对ASCII而言）的字符保持其转义十六进制格式。输出包括行首的`b`字符，以提醒我们这是一个`bytes`表示，而不是字符串。
- en: The next call decodes the string using latin-1 encoding. The `decode` method
    returns a normal (Unicode) string with the correct characters. However, if we
    had decoded this same string using the Cyrillic `iso8859-5` encoding, we'd have
    ended up with the `'clichщ'` string! This is because the `\xe9` byte maps to different
    characters in the two encodings.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '下一个调用使用latin-1编码解码字符串。`decode`方法返回一个带有正确字符的正常（Unicode）字符串。然而，如果我们使用西里尔文`iso8859-5`编码解码这个相同的字符串，我们最终会得到`''clichщ''`字符串！这是因为`\xe9`字节在这两种编码中映射到不同的字符。 '
- en: Converting text to bytes
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文本转换为字节
- en: 'If we need to convert incoming bytes into Unicode, we''re clearly also going
    to have situations where we convert outgoing Unicode into byte sequences. This
    is done with the `encode` method on the `str` class, which, like the `decode`
    method, requires a character set. The following code creates a Unicode string
    and encodes it in different character sets:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将传入的字节转换为Unicode，我们显然也会遇到将输出的Unicode转换为字节序列的情况。这是通过`str`类的`encode`方法完成的，它，就像`decode`方法一样，需要一个字符集。以下代码创建了一个Unicode字符串，并在不同的字符集中对其进行编码：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first three encodings create a different set of bytes for the accented
    character. The fourth one can''t even handle that byte:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前三种编码为带音标的字符创建了一组不同的字节。第四种甚至无法处理该字节：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now you should understand the importance of encodings! The accented character
    is represented as a different byte for each encoding; if we use the wrong one
    when we are decoding bytes to text, we get the wrong character.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该理解编码的重要性了！带音标的字符在每种编码中表示为不同的字节；如果我们解码字节到文本时使用错误的编码，我们会得到错误的字符。
- en: 'The exception in the last case is not always the desired behavior; there may
    be cases where we want the unknown characters to be handled in a different way.
    The `encode` method takes an optional string argument named `errors` that can
    define how such characters should be handled. This string can be one of the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况下的异常并不总是我们期望的行为；可能存在我们希望以不同方式处理未知字符的情况。`encode`方法接受一个可选的字符串参数`errors`，可以定义如何处理此类字符。此字符串可以是以下之一：
- en: '`strict`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strict`'
- en: '`replace`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`'
- en: '`ignore`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore`'
- en: '`xmlcharrefreplace`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xmlcharrefreplace`'
- en: 'The `strict` replacement strategy is the default we just saw. When a byte sequence
    is encountered that does not have a valid representation in the requested encoding,
    an exception is raised. When the `replace` strategy is used, the character is
    replaced with a different character; in ASCII, it is a question mark; other encodings
    may use different symbols, such as an empty box. The `ignore` strategy simply
    discards any bytes it doesn''t understand, while the `xmlcharrefreplace` strategy
    creates an `xml` entity representing the Unicode character. This can be useful
    when converting unknown strings for use in an XML document. Here''s how each of
    the strategies affects our sample word:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`strict`替换策略是我们刚刚看到的默认策略。当遇到一个在请求的编码中没有有效表示的字节序列时，会引发异常。当使用`replace`策略时，字符会被替换为不同的字符；在ASCII中，它是一个问号；其他编码可能使用不同的符号，例如一个空框。`ignore`策略简单地丢弃它不理解的任何字节，而`xmlcharrefreplace`策略创建一个表示Unicode字符的`xml`实体。这在将未知字符串转换为用于XML文档时可能很有用。以下是每种策略如何影响我们的示例单词：'
- en: '| **Strategy** | **Result of applying** `"cliché".encode("ascii", strategy)`
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **策略** | **应用 `"cliché".encode("ascii", strategy)` 的结果** |'
- en: '| `replace` | `b''clich?''` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `replace` | `b''clich?''` |'
- en: '| `ignore` | `b''clich''` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `ignore` | `b''clich''` |'
- en: '| `xmlcharrefreplace` | `b''cliché''` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `xmlcharrefreplace` | `b''cliché''` |'
- en: It is possible to call the `str.encode` and `bytes.decode` methods without passing
    an encoding name. The encoding will be set to the default encoding for the current
    platform. This will depend on the current operating system and locale or regional
    settings; you can look it up using the `sys.getdefaultencoding()` function. It
    is usually a good idea to specify the encoding explicitly, though, since the default
    encoding for a platform may change, or the program may one day be extended to
    work on text from a wider variety of sources.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用 `str.encode` 和 `bytes.decode` 方法而不传递编码名称。编码将被设置为当前平台的默认编码。这取决于当前的操作系统和区域设置；你可以使用
    `sys.getdefaultencoding()` 函数来查找它。尽管如此，通常最好明确指定编码，因为平台的默认编码可能会更改，或者程序可能有一天会被扩展以处理来自更广泛来源的文本。
- en: If you are encoding text and don't know which encoding to use, it is best to
    use UTF-8 encoding. UTF-8 is able to represent any Unicode character. In modern
    software, it is a de facto standard encoding to ensure documents in any language—or
    even multiple languages —can be exchanged. The various other possible encodings
    are useful for legacy documents or in regions that still use different character
    sets by default.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编码文本，但不知道要使用哪种编码，最好使用 UTF-8 编码。UTF-8 能够表示任何 Unicode 字符。在现代软件中，它是事实上的标准编码，以确保任何语言（甚至多种语言）的文档可以交换。其他可能的编码对于旧文档或在默认使用不同字符集的区域是有用的。
- en: The UTF-8 encoding uses one byte to represent ASCII and other common characters,
    and up to four bytes for more complex characters. UTF-8 is special because it
    is backwards-compatible with ASCII; any ASCII document encoded using UTF-8 will
    be identical to the original ASCII document.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 编码使用一个字节来表示 ASCII 和其他常见字符，对于更复杂的字符则使用最多四个字节。UTF-8 是特殊的，因为它与 ASCII 兼容；任何使用
    UTF-8 编码的 ASCII 文档都将与原始 ASCII 文档相同。
- en: I can never remember whether to use `encode` or `decode` to convert from binary
    bytes to Unicode. I always wished these methods were named `to_binary` and `from_binary` instead.
    If you have the same problem, try mentally replacing the word *code* with *binary*;
    *enbinary* and *debinary* are pretty close to *to_binary* and *from_binary*. I
    have saved a lot of time by not looking up the method help files since devising
    this mnemonic.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是记不清是使用 `encode` 还是 `decode` 将二进制字节转换为 Unicode。我总是希望这些方法被命名为 `to_binary` 和
    `from_binary`。如果你也有同样的问题，试着在心中将单词 *code* 替换为 *binary*；*enbinary* 和 *debinary*
    与 *to_binary* 和 *from_binary* 非常接近。自从想出这个助记符以来，我没有查阅方法帮助文件就节省了很多时间。
- en: Mutable byte strings
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变字节字符串
- en: The `bytes` type, like `str`, is immutable. We can use index and slice notation
    on a `bytes` object and search for a particular sequence of bytes, but we can't
    extend or modify them. This can be very inconvenient when dealing with I/O, as
    it is often necessary to buffer incoming or outgoing bytes until they are ready
    to be sent. For example, if we are receiving data from a socket, it may take several
    `recv` calls before we have received an entire message.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes` 类型，像 `str` 一样，是不可变的。我们可以在 `bytes` 对象上使用索引和切片表示法来搜索特定的字节序列，但我们不能扩展或修改它们。在处理
    I/O 时，这可能会非常不方便，因为通常需要缓冲传入或传出的字节，直到它们准备好发送。例如，如果我们从套接字接收数据，可能需要多次 `recv` 调用才能接收到整个消息。'
- en: This is where the `bytearray` built-in comes in. This type behaves something
    like a list, except it only holds bytes. The constructor for the class can accept
    a `bytes` object to initialize it. The `extend` method can be used to append another
    `bytes` object to the existing array (for example, when more data comes from a
    socket or other I/O channel).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是内置的 `bytearray` 类型发挥作用的地方。这种类型的行为类似于列表，但它只包含字节。该类的构造函数可以接受一个 `bytes` 对象来初始化它。可以使用
    `extend` 方法将另一个 `bytes` 对象追加到现有数组中（例如，当从套接字或其他 I/O 通道接收更多数据时）。
- en: 'Slice notation can be used on `bytearray` to modify the item inline. For example,
    this code constructs a `bytearray` from a `bytes` object and then replaces two
    bytes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 `bytearray` 上使用切片表示法来修改项。例如，此代码从一个 `bytes` 对象构建一个 `bytearray`，然后替换两个字节：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we want to manipulate a single element in `bytearray`, we must pass an integer
    between 0 and 255 (inclusive) as the value. This integer represents a specific
    `bytes` pattern. If we try to pass a character or `bytes` object, it will raise
    an exception.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在 `bytearray` 中操作单个元素，我们必须传递一个介于 0 和 255（包含）之间的整数作为值。这个整数代表一个特定的 `bytes`
    模式。如果我们尝试传递一个字符或 `bytes` 对象，它将引发异常。
- en: 'A single byte character can be converted to an integer using the `ord` (short
    for ordinal) function. This function returns the integer representation of a single
    character:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `ord`（意为序数）函数将单个字节字符转换为整数。此函数返回单个字符的整数表示：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After constructing the array, we replace the character at index `3` (the fourth
    character, as indexing starts at `0`, as with lists) with byte `103`. This integer
    was returned by the `ord` function and is the ASCII character for the lowercase
    `g`. For illustration, we also replaced the next character up with byte number
    `68`, which maps to the ASCII character for the uppercase `D`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建数组后，我们将索引 `3`（第四个字符，因为索引从 `0` 开始，就像列表一样）处的字符替换为字节 `103`。这个整数是由 `ord` 函数返回的，是小写
    `g` 的 ASCII 字符。为了说明，我们还用字节编号 `68` 替换了下一个字符，它映射到大写 `D` 的 ASCII 字符。
- en: The `bytearray` type has methods that allow it to behave like a list (we can
    append integer bytes to it, for example), but also like a `bytes` object; we can
    use methods such as `count` and `find` the same way they would behave on a `bytes`
    or `str` object. The difference is that `bytearray` is a mutable type, which can
    be useful for building up complex sequences of bytes from a specific input source.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytearray` 类型有允许其表现得像列表（例如，我们可以向其中追加整数字节）的方法，但也可以像 `bytes` 对象一样使用；我们可以使用 `count`
    和 `find` 等方法，就像它们在 `bytes` 或 `str` 对象上表现一样。区别在于 `bytearray` 是一个可变类型，这对于从特定输入源构建复杂的字节序列非常有用。'
- en: Regular expressions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: You know what's really hard to do using object-oriented principles? Parsing
    strings to match arbitrary patterns, that's what. There have been a fair number
    of academic papers written in which object-oriented design is used to set up string-parsing,
    but the result is always very verbose and hard to read, and they are not widely
    used in practice.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道使用面向对象原则真正难以做什么吗？解析字符串以匹配任意模式，就是这样。已经有许多学术论文被撰写，其中使用面向对象设计来设置字符串解析，但结果总是非常冗长且难以阅读，并且在实践中并不广泛使用。
- en: In the real world, string-parsing in most programming languages is handled by
    regular expressions. These are not verbose, but, wow, are they ever hard to read,
    at least until you learn the syntax. Even though regular expressions are not object-oriented,
    the Python regular expression library provides a few classes and objects that
    you can use to construct and run regular expressions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，大多数编程语言的字符串解析都是由正则表达式处理的。这些表达式并不冗长，但哇，它们确实很难读，至少在你学会语法之前是这样。尽管正则表达式不是面向对象的，但
    Python 正则表达式库提供了一些类和对象，你可以使用它们来构建和运行正则表达式。
- en: 'Regular expressions are used to solve a common problem: Given a string, determine
    whether that string matches a given pattern and, optionally, collect substrings
    that contain relevant information. They can be used to answer questions such as
    the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式用于解决一个常见问题：给定一个字符串，确定该字符串是否与给定的模式匹配，并且可选地收集包含相关信息子串。它们可以用来回答以下问题：
- en: Is this string a valid URL?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个字符串是否是一个有效的 URL？
- en: What is the date and time of all warning messages in a log file?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件中所有警告消息的日期和时间是什么？
- en: Which users in `/etc/passwd` are in a given group?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/passwd` 中的哪些用户属于给定的组？'
- en: What username and document were requested by the URL a visitor typed?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者输入的 URL 请求了哪个用户名和文档？
- en: There are many similar scenarios where regular expressions are the correct answer.
    Many programmers have made the mistake of implementing complicated and fragile
    string-parsing libraries because they didn't know or wouldn't learn regular expressions.
    In this section, we'll gain enough knowledge of regular expressions to not make
    such mistakes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类似的场景，其中正则表达式是正确的答案。许多程序员因为不知道或不学习正则表达式而错误地实现了复杂且脆弱的字符串解析库。在本节中，我们将获得足够的正则表达式知识，以避免犯这样的错误。
- en: Matching patterns
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配模式
- en: 'Regular expressions are a complicated mini-language. They rely on special characters
    to match unknown strings, but let''s start with literal characters, such as letters,
    numbers, and the space character, which always match themselves. Let''s see a
    basic example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一个复杂的迷你语言。它们依赖于特殊字符来匹配未知字符串，但让我们从字面字符开始，例如字母、数字和空格字符，这些字符总是匹配自身。让我们看一个基本示例：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Python Standard Library module for regular expressions is called `re`. We
    import it and set up a search string and pattern to search for; in this case,
    they are the same string. Since the search string matches the given pattern, the
    conditional passes and the `print` statement executes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中的正则表达式模块被称为 `re`。我们导入它并设置一个搜索字符串和搜索模式；在这种情况下，它们是相同的字符串。由于搜索字符串与给定的模式匹配，条件通过并且执行了
    `print` 语句。
- en: 'Bear in mind that the `match` function matches the pattern to the beginning
    of the string. Thus, if the pattern were `"ello world"`, no match would be found.
    With confusing asymmetry, the parser stops searching as soon as it finds a match,
    so the pattern `"hello wo"` matches successfully. Let''s build a small example
    program to demonstrate these differences and help us learn other regular expression
    syntax:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`match` 函数会将模式与字符串的开始部分进行匹配。因此，如果模式是 `"ello world"`，则不会找到匹配项。由于令人困惑的不对称性，解析器一旦找到匹配项就会停止搜索，所以模式
    `"hello wo"` 可以成功匹配。让我们构建一个小型示例程序来展示这些差异，并帮助我们学习其他正则表达式语法：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is just a generic version of the earlier example that accepts the pattern
    and search string from the command line. We can see how the start of the pattern
    must match, but a value is returned as soon as a match is found in the following
    command-line interaction:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是之前示例的通用版本，它从命令行接受模式和搜索字符串。我们可以看到模式的开始必须匹配，但一旦在以下命令行交互中找到匹配项，就会返回一个值：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We'll be using this script throughout the next few sections. While the script
    is always invoked with the `python regex_generic.py "<pattern>" "<string>"` command,
    we'll only see the output in the following examples, to conserve space.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几节中使用这个脚本。虽然脚本总是使用 `python regex_generic.py "<pattern>" "<string>"`
    命令来调用，但我们将只看到以下示例中的输出，以节省空间。
- en: 'If you need control over whether items happen at the beginning or end of a
    line (or if there are no newlines in the string, or at the beginning and end of
    the string), you can use the `^` and `$` characters to represent the start and
    end of the string respectively. If you want a pattern to match an entire string,
    it''s a good idea to include both of these:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要控制项目是否出现在行首或行尾（或者字符串中没有换行符，或者在字符串的开始和结束处），你可以使用 `^` 和 `$` 字符分别表示字符串的开始和结束。如果你想使模式匹配整个字符串，包含这两个字符是个好主意：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Matching a selection of characters
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配一组字符
- en: 'Let''s start with matching an arbitrary character. The period character, when
    used in a regular expression pattern, can match any single character. Using a
    period in the string means you don''t care what the character is, just that there
    is a character there. Here are some examples:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从匹配任意字符开始。在正则表达式模式中使用点字符可以匹配任何单个字符。在字符串中使用点意味着你不在乎字符是什么，只要那里有一个字符即可。以下是一些示例：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how the last example does not match because there is no character at
    the period's position in the pattern.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到最后一个示例没有匹配，因为在模式的点位置上没有字符。
- en: 'That''s all well and good, but what if we only want a few specific characters
    to match? We can put a set of characters inside square brackets to match any one
    of those characters. So, if we encounter the string `[abc]`  in a regular expression
    pattern, we know that those five (including the two square brackets) characters
    will only match one character in the string being searched, and further, that
    this one character will be either an `a`, a `b`, or a `c`. Let''s see a few examples:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一切都很好，但如果我们只想匹配几个特定的字符怎么办？我们可以在方括号内放置一组字符来匹配这些字符中的任何一个。所以，如果我们在一个正则表达式模式中遇到字符串
    `[abc]`，我们知道这五个字符（包括两个方括号）将只匹配正在搜索的字符串中的一个字符，并且进一步地，这个字符将是 `a`、`b` 或 `c` 中的一个。让我们看几个示例：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'These square bracket sets should be named character sets, but they are more
    often referred to as **character classes**. Often, we want to include a large
    range of characters inside these sets, and typing them all out can be monotonous
    and error-prone. Fortunately, the regular expression designers thought of this
    and gave us a shortcut. The dash character, in a character set, will create a
    range. This is especially useful if you want to match *all lowercase letters*,
    *all letters*, or *all numbers,* as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方括号集合应该被称为字符集，但它们更常被称为**字符类**。通常，我们希望在集合内包含大量字符，输入它们可能会很单调且容易出错。幸运的是，正则表达式的设计者想到了这一点，并给了我们一个快捷方式。在字符集中，破折号字符将创建一个范围。如果你想要匹配所有小写字母、所有字母或所有数字，这特别有用，如下所示：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are other ways to match or exclude individual characters, but you'll need
    to find a more comprehensive tutorial via a web search if you want to find out
    what they are!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以匹配或排除单个字符，但如果你想知道它们是什么，你需要通过网络搜索找到更全面的教程！
- en: Escaping characters
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转义字符
- en: 'If putting a period character in a pattern matches any arbitrary character,
    how do we match just a period in a string? One way might be to put the period
    inside square brackets to make a character class, but a more generic method is
    to use backslashes to escape it. Here''s a regular expression to match two-digit
    decimal numbers between 0.00 and 0.99:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在模式中放置一个点字符可以匹配任何任意字符，那么我们如何匹配字符串中的单个点呢？一种可能的方法是将点放在方括号内以创建一个字符类，但一个更通用的方法是使用反斜杠来转义它。以下是一个匹配0.00到0.99之间两位小数的正则表达式：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For this pattern, the two characters `\.` match the single `.` character. If
    the period character is missing or is a different character, it will not match.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模式，两个字符`\.`匹配单个`.`字符。如果点字符缺失或是一个不同的字符，它将不会匹配。
- en: This backslash escape sequence is used for a variety of special characters in
    regular expressions. You can use `\[` to insert a square bracket without starting
    a character class, and `\(` to insert a parenthesis, which we'll later see is
    also a special character.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个反斜杠转义序列用于正则表达式中的各种特殊字符。你可以使用`\[`来插入一个方括号而不开始一个字符类，并且使用`\(`来插入一个括号，我们稍后会看到它也是一个特殊字符。
- en: 'More interestingly, we can also use the escape symbol followed by a character
    to represent special characters such as newlines (`\n`) and tabs (`\t`). Further,
    some character classes can be represented more succinctly using escape strings:
    `\s` represents whitespace characters; `\w` represents letters, numbers, and underscore;
    and `\d` represents a digit:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，我们还可以使用转义符号后跟一个字符来表示特殊字符，如换行符（`\n`）和制表符（`\t`）。此外，一些字符类可以使用转义字符串更简洁地表示：`\s`表示空白字符；`\w`表示字母、数字和下划线；`\d`表示数字：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Matching multiple characters
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配多个字符
- en: With this information, we can match most strings of a known length, but most
    of the time, we don't know how many characters to match inside a pattern. Regular
    expressions can take care of this, too. We can modify a pattern by appending one
    of several hard-to-remember punctuation symbols to match multiple characters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，我们可以匹配大多数已知长度的字符串，但大多数时候，我们不知道在模式内要匹配多少个字符。正则表达式也可以处理这个问题。我们可以通过在模式后附加几个难以记住的标点符号之一来修改模式，以匹配多个字符。
- en: 'The asterisk (`*`) character says that the previous pattern can be matched
    zero or more times. This probably sounds silly, but it''s one of the most useful
    repetition characters. Before we explore why, consider some silly examples to
    make sure we understand what it does:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 星号（`*`）字符表示前面的模式可以匹配零次或多次。这听起来可能有些荒谬，但它是最有用的重复字符之一。在我们探索为什么之前，考虑一些荒谬的例子以确保我们理解它的作用：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, the `*` character in the pattern says that the previous pattern (the `l`
    character) is optional, and if present, can be repeated as many times as possible
    to match the pattern. The rest of the characters (`h`, `e`, and `o`) have to appear
    exactly once.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模式中的`*`字符表示前面的模式（`l`字符）是可选的，如果存在，可以尽可能多地重复以匹配模式。其余的字符（`h`、`e`和`o`）必须恰好出现一次。
- en: 'It''s pretty rare to want to match a single letter multiple times, but it gets
    more interesting if we combine the asterisk with patterns that match multiple
    characters. So, `.*`, for example, will match any string, whereas `[a-z]*` matches
    any collection of lowercase words, including the empty string. Here are a few
    examples:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们并不需要多次匹配单个字母，但如果我们将星号与匹配多个字符的模式结合起来，情况就变得更有趣了。例如，`.*` 将匹配任何字符串，而 `[a-z]*`
    则匹配任何由小写字母组成的单词集合，包括空字符串。以下是一些示例：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The plus (`+`) sign in a pattern behaves similarly to an asterisk; it states
    that the previous pattern can be repeated one or more times, but, unlike the asterisk,
    is not optional. The question mark (`?`) ensures a pattern shows up exactly zero
    or one times, but not more. Let''s explore some of these by playing with numbers
    (remember that `\d` matches the same character class as `[0-9]`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 模式中的加号（`+`）与星号的行为类似；它表示前面的模式可以重复一次或多次，但与星号不同的是，它不是可选的。问号（`?`）确保模式恰好出现零次或一次，但不超过一次。让我们通过玩数字来探索一些这些模式（记住
    `\d` 匹配与 `[0-9]` 相同的字符类）：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Grouping patterns together
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模式分组
- en: 'So far, we''ve seen how we can repeat a pattern multiple times, but we are
    restricted in what patterns we can repeat. If we want to repeat individual characters,
    we''re covered, but what if we want a repeating sequence of characters? Enclosing
    any set of patterns in parentheses allows them to be treated as a single pattern
    when applying repetition operations. Compare these patterns:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们可以多次重复一个模式，但我们受到可以重复的模式类型的限制。如果我们想重复单个字符，我们没问题，但如果我们想重复字符序列呢？将任何一组模式括起来，在应用重复操作时，可以将它们视为一个单独的模式。比较以下模式：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Combined with complex patterns, this grouping feature greatly expands our pattern-matching
    repertoire. Here''s a regular expression that matches simple English sentences:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 结合复杂的模式，这种分组功能极大地扩展了我们的模式匹配能力。以下是一个匹配简单英语句子的正则表达式：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first word starts with a capital, followed by zero or more lowercase letters.
    Then, we enter a parenthetical that matches a single space followed by a word
    of one or more lowercase letters. This entire parenthetical is repeated zero or
    more times, and the pattern is terminated with a period. There cannot be any other
    characters after the period, as indicated by the `$` matching the end of string.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单词以大写字母开头，后面跟着零个或多个小写字母。然后，我们进入一个匹配单个空格后跟一个由一个或多个小写字母组成的单词的括号表达式。这个括号表达式可以重复零次或多次，并且模式以句号结束。句号之后不能有其他字符，正如
    `$` 匹配字符串的结尾所示。
- en: We've seen many of the most basic patterns, but the regular expression language
    supports many more. I spent my first few years using regular expressions looking
    up the syntax every time I needed to do something. It is worth bookmarking Python's
    documentation for the `re` module and reviewing it frequently. There are very
    few things that regular expressions cannot match, and they should be the first
    tool you reach for when parsing strings.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多最基本模式，但正则表达式语言支持许多其他模式。我在使用正则表达式的最初几年里，每次需要做某事时都会查找语法。值得将Python的 `re`
    模块文档添加到书签并经常查阅。正则表达式几乎可以匹配任何内容，它们应该是解析字符串时首先考虑的工具。
- en: Getting information from regular expressions
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从正则表达式获取信息
- en: Let's now focus on the Python side of things. The regular expression syntax
    is the furthest thing from object-oriented programming. However, Python's `re`
    module provides an object-oriented interface to enter the regular expression engine.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注Python方面的事情。正则表达式语法与面向对象编程相差甚远。然而，Python的 `re` 模块提供了一个面向对象的接口来访问正则表达式引擎。
- en: We've been checking whether the `re.match` function returns a valid object or
    not. If a pattern does not match, that function returns `None`. If it does match,
    however, it returns a useful object that we can introspect for information about
    the pattern.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在检查 `re.match` 函数是否返回一个有效的对象。如果模式不匹配，该函数返回 `None`。如果它匹配，则返回一个有用的对象，我们可以用它来获取有关模式的信息。
- en: 'So far, our regular expressions have answered questions such as, *does this
    string match this pattern?* Matching patterns is useful, but in many cases, a
    more interesting question is, *if this string matches this pattern, what is the
    value of a relevant substring?* If you use groups to identify parts of the pattern
    that you want to reference later, you can get them out of the match return value,
    as illustrated in the next example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的正则表达式已经回答了诸如“这个字符串是否与这个模式匹配？”等问题。匹配模式很有用，但在许多情况下，一个更有趣的问题是，“如果这个字符串与这个模式匹配，相关子串的值是什么？”如果你使用组来标识稍后想要引用的模式部分，你可以从匹配返回值中获取它们，如下一个示例所示：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The specification describing valid email addresses is extremely complicated,
    and the regular expression that accurately matches all possibilities is obscenely
    long. So, we cheated and made a simple regular expression that matches some common
    email addresses; the point is that we want to access the domain name (after the
    `@` sign) so we can connect to that address. This is done easily by wrapping that
    part of the pattern in parentheses and calling the `groups()` method on the object
    returned by `match`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 描述有效电子邮件地址的规范极其复杂，能够准确匹配所有可能性的正则表达式非常长。因此，我们采取了欺骗手段，创建了一个简单的正则表达式来匹配一些常见的电子邮件地址；目的是我们想要访问域名（在`@`符号之后），以便我们可以连接到该地址。通过将模式中这部分内容用括号括起来，并在`match`方法返回的对象上调用`groups()`方法，可以轻松实现这一点。
- en: The `groups` method returns a tuple of all the groups matched inside the pattern,
    which you can index to access a specific value. The groups are ordered from left
    to right. However, bear in mind that groups can be nested, meaning you can have
    one or more groups inside another group. In this case, the groups are returned
    in the order of their leftmost brackets, so the outermost group will be returned
    before its inner matching groups.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`groups`方法返回一个包含模式内部所有匹配组的元组，你可以通过索引来访问特定的值。组是从左到右排序的。然而，请注意，组可以嵌套，这意味着你可以在另一个组内部有一个或多个组。在这种情况下，组是按照它们的左括号顺序返回的，所以最外层的组将先于其内部匹配组返回。'
- en: In addition to the `match` function, the `re` module provides a couple of other
    useful functions, `search` and `findall`. The `search` function finds the first
    instance of a matching pattern, relaxing the restriction that the pattern should
    start at the first letter of the string. Note that you can get a similar effect
    by using `match` and putting a  `^.*` character at the front of the pattern to
    match any characters between the start of the string and the pattern you are looking
    for.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`match`函数外，`re`模块还提供了一些其他有用的函数，`search`和`findall`。`search`函数找到匹配模式的第一个实例，放宽了模式应该从字符串的第一个字母开始的限制。请注意，你可以通过使用`match`并在模式前面加上`^.*`字符来达到类似的效果，以匹配字符串开始和你要查找的模式之间的任何字符。
- en: The `findall` function behaves similarly to search, except that it finds all
    non-overlapping instances of the matching pattern, not just the first one. Basically,
    it finds the first match, then it resets the search to the end of that matching
    string and finds the next one.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`findall`函数的行为与搜索类似，但它找到的是匹配模式的全部非重叠实例，而不仅仅是第一个。基本上，它会找到第一个匹配项，然后重置搜索到匹配字符串的末尾，并找到下一个匹配项。'
- en: 'Instead of returning a list of match objects, as you would expect, it returns
    a list of matching strings, or tuples. Sometimes it''s strings, sometimes it''s
    tuples. It''s not a very good API at all! As with all bad APIs, you''ll have to
    memorize the differences and not rely on intuition. The type of the return value
    depends on the number of bracketed groups inside the regular expression:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与你预期的返回匹配对象列表不同，它返回一个匹配字符串或元组的列表。有时是字符串，有时是元组。这根本不是一个很好的API！与所有糟糕的API一样，你必须记住差异，不要依赖直觉。返回值的类型取决于正则表达式内部括号组的数量：
- en: If there are no groups in the pattern, `re.findall` will return a list of strings,
    where each value is a complete substring from the source string that matches the
    pattern
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模式中没有组，`re.findall`将返回一个字符串列表，其中每个值都是从源字符串中匹配模式的完整子串。
- en: If there is exactly one group in the pattern, `re.findall` will return a list
    of strings where each value is the contents of that group
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模式中恰好有一个组，`re.findall`将返回一个字符串列表，其中每个值是那个组的全部内容。
- en: If there are multiple groups in the pattern, `re.findall` will return a list
    of tuples where each tuple contains a value from a matching group, in order
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模式中有多个组，`re.findall`将返回一个元组列表，其中每个元组包含匹配组中的一个值，按顺序排列。
- en: When you are designing function calls in your own Python libraries, try to make
    the function always return a consistent data structure. It is often good to design
    functions that can take arbitrary inputs and process them, but the return value
    should not switch from a single value to a list, or a list of values to a list
    of tuples depending on the input. Let `re.findall` be a lesson!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在自己的 Python 库中设计函数调用时，尽量让函数总是返回一致的数据结构。设计能够接受任意输入并处理它们的函数通常是个好主意，但返回值不应该根据输入从单个值切换到列表，或者从值列表切换到元组列表。`re.findall`
    就是一个教训！
- en: 'The examples in the following interactive session will hopefully clarify the
    differences:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的交互式会话中的示例有望阐明这些差异：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Making repeated regular expressions efficient
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使重复的正则表达式更高效
- en: Whenever you call one of the regular expression methods, the engine has to convert
    the pattern string into an internal structure that makes searching strings fast.
    This conversion takes a non-trivial amount of time. If a regular expression pattern
    is going to be reused multiple times (for example, inside a `for` or `while` loop),
    it would be better if this conversion step could be done only once.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用正则表达式的一个方法时，引擎都必须将模式字符串转换为一种内部结构，这使得字符串搜索变得快速。这种转换需要相当多的时间。如果一个正则表达式模式将被多次使用（例如，在
    `for` 或 `while` 循环中），那么这个转换步骤只做一次会更好。
- en: This is possible with the `re.compile` method. It returns an object-oriented
    version of the regular expression that has been compiled down and has the methods
    we've explored (`match`, `search`, and `findall`) already, among others. We'll
    see examples of this in the case study.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过 `re.compile` 方法实现。它返回一个面向对象的正则表达式版本，该版本已被编译并具有我们已探索的方法（如 `match`、`search`
    和 `findall` 等）。我们将在案例研究中看到这方面的例子。
- en: 'This has definitely been a condensed introduction to regular expressions. At
    this point, we have a good feel for the basics and will recognize when we need
    to do further research. If we have a string pattern-matching problem, regular
    expressions will almost certainly be able to solve them for us. However, we may
    need to look up new syntaxes in a more comprehensive coverage of the topic. But
    now we know what to look for! Let''s move on to a completely different topic:
    filesystem paths.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定是对正则表达式的一个浓缩介绍。到目前为止，我们对基础知识有了很好的感觉，并且会在需要进一步研究时识别出来。如果我们有一个字符串模式匹配问题，正则表达式几乎肯定能够为我们解决这些问题。然而，我们可能需要在一个更全面的正则表达式主题覆盖中查找新的语法。但现在我们知道该寻找什么了！让我们继续到一个完全不同的主题：文件系统路径。
- en: Filesystem paths
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统路径
- en: All operating systems provide a *filesystem*, a way of mapping a logical abstraction
    of *folders* (or *directories*) and *files* to the bits and bytes stored on a
    hard drive or other storage device. As humans, we typically interact with the
    filesystem using a drag-and-drop interface of folders and files of different types,
    or with command-line programs such as `cp`, `mv`, and `mkdir`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作系统都提供了一个 *文件系统*，一种将 *文件夹*（或 *目录*）和 *文件* 的逻辑抽象映射到硬盘或其它存储设备上存储的位和字节的方法。作为人类，我们通常通过文件夹和不同类型的文件的拖放界面，或者通过
    `cp`、`mv` 和 `mkdir` 等命令行程序与文件系统交互。
- en: 'As programmers, we have to interact with the filesystem with a series of system
    calls. You can think of these as library functions supplied by the operating system
    so that programs can call them. They have a clunky interface with integer file
    handles and buffered reads and writes, and that interface is different depending
    on which operating system you are using. Python provides an OS-independent abstraction
    over these system calls in the `os.path` module. It''s a little easier to work
    with than accessing the operating system directly, but it''s not very intuitive.
    It requires a lot of string concatenation and you have to be conscious of whether
    to use a forward slash or a backslash between directories, depending on the operating
    system. There is a `os.sep` file representing the path separator, but using it
    requires code that looks like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们必须通过一系列系统调用来与文件系统交互。你可以把它们看作是操作系统提供的库函数，以便程序可以调用它们。它们有一个笨拙的接口，包括整数文件句柄和缓冲读取和写入，而且这个接口取决于你使用的操作系统。Python
    在 `os.path` 模块中提供了对这些系统调用的操作系统无关的抽象。与直接访问操作系统相比，这要容易一些，但并不直观。它需要大量的字符串连接，并且你必须意识到在目录之间使用正斜杠还是反斜杠，这取决于操作系统。有一个
    `os.sep` 文件表示路径分隔符，但使用它需要像这样的代码：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Working with filesystem paths is easily one of the most irritating uses of strings
    inside the entire standard library. Paths that are easy to type on the command
    line become illegible in Python code. When you have to manipulate and access multiple
    paths (for example, when processing images in a data pipeline for a machine learning
    computer vision problem), just managing those directories becomes a bit of an
    ordeal.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个标准库中，与文件系统路径一起工作可能是最令人烦恼的字符串使用之一。在命令行上容易输入的路径在 Python 代码中变得难以辨认。当你必须操作和访问多个路径时（例如，在处理机器学习计算机视觉问题的数据管道中的图像时），仅仅管理这些目录就变成了一项艰巨的任务。
- en: 'So, the Python language designers included a module called `pathlib` in the
    standard library. It''s an object-oriented representation of paths and files that
    is much more pleasant to work with. The preceding path, using `pathlib`, would
    look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python 语言设计者将一个名为 `pathlib` 的模块包含在标准库中。它是对路径和文件的面向对象表示，与它一起工作要愉快得多。使用 `pathlib`
    的前一个路径看起来像这样：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, it's quite a bit easier to see what's going on. Notice the unique
    use of the division operator as a path separator so you don't have to do anything
    with `os.sep`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它要容易得多，可以清楚地看到发生了什么。注意除法运算符作为路径分隔符的独特使用，这样你就不需要做任何与 `os.sep` 相关的事情。
- en: 'In a more real-world example, consider some code that counts the number of
    lines of code excluding whitespace and comments in all Python files in the current
    directory and subdirectories:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更实际的例子中，考虑一些代码，它计算当前目录及其子目录中所有 Python 文件的代码行数（不包括空白和注释）：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In typical `pathlib` usage, we rarely have to construct more than one or two
    paths. Usually, other files or directories are relative to a general path. This
    example demonstrates that. We only ever construct one path, from the current directory
    using `pathlib.Path(".")`. Then, other paths are created based on that path.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 `pathlib` 使用中，我们很少需要构建超过一个或两个路径。通常，其他文件或目录相对于一个通用路径。这个例子演示了这一点。我们只构建一个路径，即使用
    `pathlib.Path(".")` 从当前目录开始。然后，其他路径基于这个路径创建。
- en: The `count_sloc` function first initializes the **sloc** (**source lines of
    code**) counter to zero. Then, it iterates over all the files and directories
    in the path that was passed into the function using the `dir_path.iterdir` generator
    (we'll discuss generators in detail in the next chapter; for now, think of it
    as a sort of dynamic list). Each of the paths returned to the `for` loop by `iterdir`
    is itself another path. We first test whether this path starts with a `.`, which
    represents a hidden directory on most OSes (this will keep it from counting any
    files in the `.git` directory if you are using version control). Then, we check
    whether it is a directory using the `isdir()`  method. If it is, we recursively
    call `count_sloc` to count the lines of code in modules in the child package.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`count_sloc` 函数首先将 **sloc**（**源代码行数**）计数器初始化为零。然后，它使用 `dir_path.iterdir` 生成器遍历函数传入路径中的所有文件和目录（我们将在下一章详细讨论生成器；现在，可以将其视为一种动态列表）。`iterdir`
    返回给 `for` 循环的每个路径本身也是一个路径。我们首先测试这个路径是否以 `.` 开头，这在大多数操作系统上代表一个隐藏目录（如果你使用版本控制，这将防止它计算
    `.git` 目录中的任何文件）。然后，我们使用 `isdir()` 方法检查它是否是目录。如果是，我们递归调用 `count_sloc` 来计算子包中模块的代码行数。'
- en: If it's not a directory, we assume it is a normal file, and skip any files that
    don't end with the `.py` extension, using the `suffix` property. Now, knowing
    we have a path to a Python file, we open the file using the `open()` method, which
    returns a context manager. We wrap this in a `with` block so the file is automatically
    closed when we are done with it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不是一个目录，我们假设它是一个普通文件，并使用 `suffix` 属性跳过任何不以 `.py` 扩展名结尾的文件。现在，我们知道我们有一个指向 Python
    文件的路径，我们使用 `open()` 方法打开文件，该方法返回一个上下文管理器。我们将其包裹在一个 `with` 块中，这样当我们完成时文件会自动关闭。
- en: The `Path.open` method takes similar arguments to the `open` built-in function,
    but it uses a more object-oriented syntax. If you prefer the function version,
    you can pass a `Path` object into it as the first parameter (in other words, `with
    open(Path('./README.md')):`) just as you would a string. But I personally think
    `Path('./README.md').open()` is more legible if the path already exists.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path.open` 方法与内置的 `open` 函数具有类似的参数，但它使用更面向对象的语法。如果你更喜欢函数版本，你可以将一个 `Path` 对象作为第一个参数传递给它（换句话说，`with
    open(Path(''./README.md'')):`），就像传递一个字符串一样。但我觉得如果路径已经存在，`Path(''./README.md'').open()`
    的可读性更好。'
- en: We then iterate over each line in the file and add it to the count. We skip
    whitespace and comment lines, since these don't represent actual source code.
    The total count is returned to the calling function, which may be the original
    call or the recursive parent.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Path` class in the `pathlib` module has a method or property to cover
    pretty much everything you might want to do with a path. In addition to those
    we covered in the example, here are a few of my favorites:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '`.absolute()` returns the full path from the root of the filesystem. I usually
    call this on every path I construct in due to a bit of paranoia that I might forget
    where relative paths came from.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.parent` returns a path to the parent directory.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.exists()` checks whether the file or directory exists.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.mkdir()` creates a directory at the current path. It takes Boolean `parents`
    and `exist_ok` arguments to indicate that it should recursively create the directories
    if necessary and that it shouldn''t raise an exception if the directory already
    exists.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the standard library documentation at [https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)
    for more exotic uses.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Most standard library modules that accept a string path can also accept a `pathlib.Path`
    object. For example, you can open a ZIP file by passing a path into it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This doesn't always work, especially if you are using a third-party library
    that is implemented as a C extension. In those cases, you'll have to cast the
    path to a string using `str(pathname)`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Serializing objects
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, we take the ability to write data to a file and retrieve it at an
    arbitrary later date for granted. As convenient as this is (imagine the state
    of computing if we couldn't store anything!), we often find ourselves converting
    data we have stored in a nice object or design pattern in memory into some kind
    of clunky text or binary format for storage, transfer over the network, or remote
    invocation on a distant server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The Python `pickle` module is an object-oriented way to store objects directly
    in a special storage format. It essentially converts an object (and all the objects
    it holds as attributes) into a sequence of bytes that can be stored or transported
    however we see fit.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'For basic tasks, the `pickle` module has an extremely simple interface. It
    comprises four basic functions for storing and loading data: two for manipulating
    file-like objects, and two for manipulating `bytes` objects (the latter are just
    shortcuts to the file-like interface, so we don''t have to create a `BytesIO`
    file-like object ourselves).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The `dump` method accepts an object to be written and a file-like object to
    write the serialized bytes to. This object must have a `write` method (or it wouldn't
    be file-like), and that method must know how to handle a `bytes` argument (so,
    a file opened for text output wouldn't work).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The `load` method does exactly the opposite; it reads a serialized object from
    a file-like object. This object must have the proper file-like `read` and `readline`
    arguments, each of which must, of course, return `bytes`. The `pickle` module
    will load the object from these bytes and the `load` method will return the fully
    reconstructed object. Here''s an example that stores and then loads some data
    in a list object:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This code works as advertised: the objects are stored in the file and then
    loaded from the same file. In each case, we open the file using a `with` statement
    so that it is automatically closed. The file is first opened for writing and then
    a second time for reading, depending on whether we are storing or loading data.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The `assert` statement at the end would raise an error if the newly loaded object
    was not equal to the original object. Equality does not imply that they are the
    same object. Indeed, if we print the `id()` of both objects, we would discover
    they are different. However, because they are both lists whose contents are equal,
    the two lists are also considered equal.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The `dumps` and `loads` functions behave much like their file-like counterparts,
    except they return or accept `bytes` instead of file-like objects. The `dumps`
    function requires only one argument, the object to be stored, and it returns a
    serialized `bytes` object. The `loads` function requires a `bytes` object and
    returns the restored object. The `'s'` character in the method names is short
    for string; it's a legacy name from ancient versions of Python, where `str` objects
    were used instead of `bytes`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to call `dump` or `load` on a single open file more than once.
    Each call to `dump` will store a single object (plus any objects it is composed
    of or contains), while a call to `load` will load and return just one object.
    So, for a single file, each separate call to `dump` when storing the object should
    have an associated call to `load` when restoring at a later date.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Customizing pickles
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With most common Python objects, pickling *just works*. Basic primitives such
    as integers, floats, and strings can be pickled, as can any container objects,
    such as lists or dictionaries, provided the contents of those containers are also
    picklable. Further, and importantly, any object can be pickled, so long as all
    of its attributes are also picklable.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: So, what makes an attribute unpicklable? Usually, it has something to do with
    time-sensitive attributes that it would not make sense to load in the future.
    For example, if we have an open network socket, open file, running thread, or
    database connection stored as an attribute on an object, it would not make sense
    to pickle these objects; a lot of operating system state would simply be gone
    when we attempted to reload them later. We can't just pretend a thread or socket
    connection exists and make it appear! No, we need to somehow customize how such
    transient data is stored and restored.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a class that loads the contents of a web page every hour to ensure
    that they stay up to date. It uses the `threading.Timer` class to schedule the
    next update:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`url`, `contents`, and `last_updated` are all pickleable, but if we try to
    pickle an instance of this class, things go a little nutty on the `self.timer`
    instance:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That's not a very useful error, but it looks like we're trying to pickle something
    we shouldn't be. That would be the `Timer` instance; we're storing a reference
    to `self.timer` in the schedule method, and that attribute cannot be serialized.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: When `pickle` tries to serialize an object, it simply tries to store the object's
    `__dict__` attribute; `__dict__` is a dictionary mapping all the attribute names
    on the object to their values. Luckily, before checking `__dict__`, `pickle` checks
    to see whether a `__getstate__` method exists. If it does, it will store the return
    value of that method instead of the `__dict__`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `__getstate__` method to our `UpdatedURL` class that simply returns
    a copy of the `__dict__` without a timer:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If we pickle the object now, it will no longer fail. And we can even successfully
    restore that object using `loads`. However, the restored object doesn't have a
    timer attribute, so it will not be refreshing the content like it is designed
    to do. We need to somehow create a new timer (to replace the missing one) when
    the object is unpickled.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'As we might expect, there is a complementary `__setstate__` method that can
    be implemented to customize unpickling. This method accepts a single argument,
    which is the object returned by `__getstate__`. If we implement both methods,
    `__getstate__` is not required to return a dictionary, since `__setstate__` will
    know what to do with whatever object `__getstate__` chooses to return. In our
    case, we simply want to restore the `__dict__`, and then create a new timer:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `pickle` module is very flexible and provides other tools to further customize
    the pickling process if you need them. However, these are beyond the scope of
    this book. The tools we've covered are sufficient for many basic pickling tasks.
    Objects to be pickled are normally relatively simple data objects; we likely would
    not pickle an entire running program or complicated design pattern, for example.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Serializing web objects
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not a good idea to load a pickled object from an unknown or untrusted
    source. It is possible to inject arbitrary code into a pickled file to maliciously
    attack a computer via the pickle. Another disadvantage of pickles is that they
    can only be loaded by other Python programs, and cannot be easily shared with
    services written in other languages.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: There are many formats that have been used for this purpose over the years.
    **Extensible Markup Language** (**XML**) used to be very popular, especially with
    Java developers. **Yet Another Markup Language** (**YAML**) is another format
    that you may see referenced occasionally. Tabular data is frequently exchanged
    in the **Comma-Separated Value** (**CSV**) format. Many of these are fading into
    obscurity and there are many more that you will encounter over time. Python has
    solid standard or third-party libraries for all of them.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Before using such libraries on untrusted data, make sure to investigate security
    concerns with each of them. XML and YAML, for example, both have obscure features
    that, used maliciously, can allow arbitrary commands to be executed on the host
    machine. These features may not be turned off by default. Do your research.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is a human-readable format for exchanging
    primitive data. JSON is a standard format that can be interpreted by a wide array
    of heterogeneous client systems. Hence, JSON is extremely useful for transmitting
    data between completely decoupled systems. Further, JSON does not have any support
    for executable code, only data can be serialized; thus, it is more difficult to
    inject malicious statements into it.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Because JSON can be easily interpreted by JavaScript engines, it is often used
    for transmitting data from a web server to a JavaScript-capable web browser. If
    the web application serving the data is written in Python, it needs a way to convert
    internal data into the JSON format.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: There is a module to do this, predictably named `json`. This module provides
    a similar interface to the `pickle` module, with `dump`, `load`, `dumps`, and
    `loads` functions. The default calls to these functions are nearly identical to
    those in `pickle`, so let's not repeat the details. There are a couple of differences;
    obviously, the output of these calls is valid JSON notation, rather than a pickled
    object. In addition, the `json` functions operate on `str` objects, rather than
    `bytes`. Therefore, when dumping to or loading from a file, we need to create
    text files rather than binary ones.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The JSON serializer is not as robust as the `pickle` module; it can only serialize
    basic types such as integers, floats, and strings, and simple containers such
    as dictionaries and lists. Each of these has a direct mapping to a JSON representation,
    but JSON is unable to represent classes, methods, or functions. It is not possible
    to transmit complete objects in this format. Because the receiver of an object
    we have dumped to JSON format is normally not a Python object, it would not be
    able to understand classes or methods in the same way that Python does, anyway.
    In spite of the O for Object in its name, JSON is a **data** notation; objects,
    as you recall, are composed of both data and behaviors.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: If we do have objects for which we want to serialize only the data, we can always
    serialize the object's `__dict__` attribute. Or we can semi-automate this task
    by supplying custom code to create or parse a JSON serializable dictionary from
    certain types of objects.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: In the `json` module, both the object storing and loading functions accept optional
    arguments to customize the behavior. The `dump` and `dumps` methods accept a poorly
    named `cls` (short for class, which is a reserved keyword) keyword argument. If
    passed, this should be a subclass of the `JSONEncoder` class, with the `default`
    method overridden. This method accepts an arbitrary object and converts it to
    a dictionary that `json` can digest. If it doesn't know how to process the object,
    we should call the `super()` method, so that it can take care of serializing basic
    types in the normal way.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The `load` and `loads` methods also accept such a `cls` argument that can be
    a subclass of the inverse class, `JSONDecoder`. However, it is normally sufficient
    to pass a function into these methods using the `object_hook` keyword argument.
    This function accepts a dictionary and returns an object; if it doesn't know what
    to do with the input dictionary, it can return it unmodified.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. Imagine we have the following simple contact class
    that we want to serialize:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We could just serialize the `__dict__` attribute:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'But accessing special (double-underscore) attributes in this fashion is kind
    of crude. Also, what if the receiving code (perhaps some JavaScript on a web page)
    wanted that `full_name` property to be supplied? Of course, we could construct
    the dictionary by hand, but let''s create a custom encoder instead:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `default` method basically checks to see what kind of object we're trying
    to serialize. If it's a contact, we convert it to a dictionary manually. Otherwise,
    we let the parent class handle serialization (by assuming that it is a basic type,
    which `json` knows how to handle). Notice that we pass an extra attribute to identify
    this object as a contact, since there would be no way to tell upon loading it.
    This is just a convention; for a more generic serialization mechanism, it might
    make more sense to store a string type in the dictionary, or possibly even the
    full class name, including package and module. Remember that the format of the
    dictionary depends on the code at the receiving end; there has to be an agreement
    as to how the data is going to be specified.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this class to encode a contact by passing the class (not an instantiated
    object) to the `dump` or `dumps` function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For decoding, we can write a function that accepts a dictionary and checks
    the existence of the `is_contact` variable to decide whether to convert it to
    a contact:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can pass this function to the `load` or `loads` function using the `object_hook`
    keyword argument:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Case study
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build a basic regular expression-powered templating engine in Python.
    This engine will parse a text file (such as an HTML page) and replace certain
    directives with text calculated from the input to those directives. This is about
    the most complicated task we would want to do with regular expressions; indeed,
    a full-fledged version of this would likely utilize a proper language-parsing
    mechanism.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following input file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This file contains *tags* of the form `/** <directive> <data> **/` where the
    data is an optional single word and the directives are as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '`include`: Copy the contents of another file here'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variable`: Insert the contents of a variable here'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loopover`: Repeat the contents of the loop for a variable that is a list'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endloop`: Signal the end of looped text'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loopvar`: Insert a single value from the list being looped over'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This template will render a different page depending which variables are passed
    into it. These variables will be passed in from a so-called context file. This
    will be encoded as a `json` object with keys representing the variables in question.
    My context file might look like this, but you would derive your own:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Before we get into the actual string processing, let''s throw together some
    object-oriented boilerplate code for processing files and grabbing data from the
    command line:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is all pretty basic, we create a class and initialize it with some variables
    passed in on the command line.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we try to make the regular expression a little bit more readable
    by breaking it across two lines? We use raw strings (the r prefix), so we don't
    have to double escape all our backslashes. This is common in regular expressions,
    but it's still a mess. (Regular expressions always are, but they're often worth
    it.)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The `pos` indicates the current character in the content that we are processing;
    we'll see a lot more of it in a moment.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Now all that's left is to implement the process method. There are a few ways
    to do this. Let's do it in a fairly explicit way.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The process method has to find each directive that matches the regular expression
    and do the appropriate work with it. However, it also has to take care of outputting
    the normal text before, after, and between each directive to the output file,
    unmodified.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'One good feature of the compiled version of regular expressions is that we
    can tell the `search` method to start searching at a specific position by passing
    the `pos` keyword argument. If we temporarily define doing the appropriate work
    with a directive as *ignore the directive and delete it from the output file*,
    our process loop looks quite simple:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In English, this function finds the first string in the text that matches the
    regular expression, outputs everything from the current position to the start
    of that match, and then advances the position to the end of the aforesaid match.
    Once it's out of matches, it outputs everything since the last position.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, ignoring the directive is pretty useless in a templating engine,
    so let''s replace that position advancing line with code that delegates to a different
    method on the class depending on the directive:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: So, we grab the directive and the single argument from the regular expression.
    The directive becomes a method name and we dynamically look up that method name
    on the `self` object (a little error processing here, in case the template writer
    provides an invalid directive, would be better). We pass the `match` object and
    argument into that method and assume that method will deal with everything appropriately,
    including moving the `pos` pointer.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve got our object-oriented architecture this far, it''s actually
    pretty simple to implement the methods that are delegated to. The `include` and
    `variable` directives are totally straightforward:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first simply looks up the included file and inserts the file contents, while
    the second looks up the variable name in the context dictionary (which was loaded
    from `json` in the `__init__` method), defaulting to an empty string if it doesn't
    exist.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'The three methods that deal with looping are a bit more intense, as they have
    to share state between the three of them. For simplicity (I''m sure you''re eager
    to see the end of this long chapter—we''re almost there!), we''ll handle this
    case using instance variables on the class itself. As an exercise, you might want
    to consider better ways to architect this, especially after reading the next three
    chapters:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When we encounter the `loopover` directive, we don't have to output anything,
    but we do have to set the initial state on three variables. The `loop_list` variable
    is assumed to be a list pulled from the context dictionary. The `loop_index` variable
    indicates which position in that list should be output in this iteration of the
    loop, while `loop_pos` is stored so we know where to jump back to when we get
    to the end of the loop.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The `loopvar` directive outputs the value at the current position in the `loop_list`
    variable and skips to the end of the directive. Note that it doesn't increment
    the loop index, because the `loopvar` directive could be called multiple times
    inside a loop.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The `endloop` directive is more complicated. It determines whether there are
    more elements in the `loop_list`; if there are, it just jumps back to the start
    of the loop, incrementing the index. Otherwise, it resets all the variables that
    were being used to process the loop and jumps to the end of the directive so the
    engine can carry on with the next match.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this particular looping mechanism is very fragile; if a template
    designer were to try nesting loops or to forget an `endloop` call, it would go
    poorly for them. We would need a lot more error checking and would probably want
    to store more loop state to make this a production platform. But I promised that
    the end of the chapter was nigh, so let''s just head to the exercises, after seeing
    how our sample template is rendered with its context:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: There are some weird newline effects due to the way we planned our template,
    but it works as expected.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a wide variety of topics in this chapter, from strings to regular
    expressions, to object serialization, and back again. Now it's time to consider
    how these ideas can be applied to your own code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Python strings are very flexible, and Python is an extremely powerful tool for
    string-based manipulations. If you don't do a lot of string processing in your
    daily work, try designing a tool that is exclusively intended for manipulating
    strings. Try to come up with something innovative, but if you're stuck, consider
    writing a web log analyzer (how many requests per hour? How many people visit
    more than five pages?) or a template tool that replaces certain variable names
    with the contents of other files.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Spend a lot of time toying with the string formatting operators until you've
    got the syntax memorized. Write a bunch of template strings and objects to pass
    into the format function, and see what kind of output you get. Try the exotic
    formatting operators, such as percentage or hexadecimal notation. Try out the
    fill and alignment operators, and see how they behave differently for integers,
    strings, and floats. Consider writing a class of your own that has a `__format__`
    method; we didn't discuss this in detail, but explore just how much you can customize
    formatting.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you understand the difference between `bytes` and `str` objects. The
    distinction is very complicated in older versions of Python (there was no `bytes`,
    and `str` acted like both `bytes` and `str` unless we needed non-ASCII characters,
    in which case there was a separate `unicode` object, which was similar to Python
    3's `str` class. It's even more confusing than it sounds!). It's clearer nowadays;
    `bytes` is for binary data, and `str` is for character data. The only tricky part
    is knowing how and when to convert between the two. For practice, try writing
    text data to a file opened for writing `bytes` (you'll have to encode the text
    yourself), and then reading from the same file.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Do some experimenting with `bytearray`. See how it can act both like a `bytes`
    object and a list or container object at the same time. Try writing to a buffer
    that holds data in the bytes array until it is a certain length before returning
    it. You can simulate the code that puts data into the buffer by using `time.sleep`
    calls to ensure data doesn't arrive too quickly.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Study regular expressions online. Study them some more. Especially learn about
    named groups, greedy versus lazy matching, and regex flags, three features that
    we didn't cover in this chapter. Make conscious decisions about when not to use
    them. Many people have very strong opinions about regular expressions and either
    overuse them or refuse to use them at all. Try to convince yourself to use them
    only when appropriate, and figure out when that is.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve ever written an adapter to load small amounts of data from a file
    or database and convert it to an object, consider using a pickle instead. Pickles
    are not efficient for storing massive amounts of data, but they can be useful
    for loading configuration or other simple objects. Try coding it multiple ways:
    using a pickle, a text file, or a small database. Which do you find easiest to
    work with?'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Try experimenting with pickling data, then modifying the class that holds the
    data, and loading the pickle into the new class. What works? What doesn''t? Is
    there a way to make drastic changes to a class, such as renaming an attribute
    or splitting it into two new attributes and still get the data out of an older
    pickle? (Hint: try placing a private pickle version number on each object and
    update it each time you change the class; you can then put a migration path in
    `__setstate__`.)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: If you do any web development at all, do some experimenting with the JSON serializer.
    Personally, I prefer to serialize only standard JSON serializable objects, rather
    than writing custom encoders or `object_hooks`, but the desired effect really
    depends on the interaction between the frontend (JavaScript, typically) and backend
    code.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Create some new directives in the templating engine that take more than one
    or an arbitrary number of arguments. You might need to modify the regular expression
    or add new ones. Have a look at the Django project's online documentation, and
    see whether there are any other template tags you'd like to work with. Try mimicking
    their filter syntax instead of using the `variable` tag.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Revisit this chapter when you've studied iteration and coroutines and see whether
    you can come up with a more compact way of representing the state between related
    directives, such as the loop.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered string manipulation, regular expressions, and object serialization
    in this chapter. Hardcoded strings and program variables can be combined into
    outputtable strings using the powerful string formatting system. It is important
    to distinguish between binary and textual data, and `bytes` and `str` have specific
    purposes that must be understood. Both are immutable, but the `bytearray` type
    can be used when manipulating bytes.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are a complex topic, and we only scratched the surface.
    There are many ways to serialize Python data; pickles and JSON are two of the
    most popular.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll look at a design pattern that is so fundamental
    to Python programming that it has been given special syntax support: the iterator
    pattern.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
