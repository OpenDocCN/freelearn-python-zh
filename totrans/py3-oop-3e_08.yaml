- en: Strings and Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get involved with higher-level design patterns, let''s take a deep
    dive into one of Python''s most common objects: the string. We''ll see that there
    is a lot more to the string than meets the eye, and also cover searching strings
    for patterns, and serializing data for storage or transmission.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we''ll look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The complexities of strings, bytes, and byte arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ins and outs of string formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few ways to serialize data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mysterious regular expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings are a basic primitive in Python; we've used them in nearly every example
    we've discussed so far. All they do is represent an immutable sequence of characters.
    However, though you may not have considered it before, *character* is a bit of
    an ambiguous word; can Python strings represent sequences of accented characters?
    Chinese characters? What about Greek, Cyrillic, or Farsi?
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python 3, the answer is yes. Python strings are all represented in Unicode,
    a character definition standard that can represent virtually any character in
    any language on the planet (and some made-up languages and random characters as
    well). This is done seamlessly. So, let''s think of Python 3 strings as an immutable
    sequence of Unicode characters. We''ve touched on many of the ways strings can
    be manipulated in previous examples, but let''s quickly cover it all in one place:
    a crash course in string theory!'
  prefs: []
  type: TYPE_NORMAL
- en: String manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you know, strings can be created in Python by wrapping a sequence of characters
    in single or double quotes. Multiline strings can easily be created using three
    quote characters, and multiple hardcoded strings can be concatenated together
    by placing them side by side. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That last string is automatically composed into a single string by the interpreter.
    It is also possible to concatenate strings using the `+` operator (as in `"hello
    " + "world"`). Of course, strings don't have to be hardcoded. They can also come
    from various outside sources, such as text files, user input, or can be encoded
    on the network.
  prefs: []
  type: TYPE_NORMAL
- en: The automatic concatenation of adjacent strings can make for some hilarious
    bugs when a comma is missed. It is, however, extremely useful when a long string
    needs to be placed inside a function call without exceeding the 79 - character
    line-length limit suggested by the Python style guide.
  prefs: []
  type: TYPE_NORMAL
- en: Like other sequences, strings can be iterated over (character by character),
    indexed, sliced, or concatenated. The syntax is the same as for lists.
  prefs: []
  type: TYPE_NORMAL
- en: The `str` class has numerous methods on it to make manipulating strings easier.
    The `dir` and `help` commands in the Python interpreter can tell us how to use
    all of them; we'll consider some of the more common ones directly.
  prefs: []
  type: TYPE_NORMAL
- en: Several Boolean convenience methods help us identify whether or not the characters
    in a string match a certain pattern. Here is a summary of these methods. Most
    of these, such as `isalpha`, `isupper`/`islower`, and `startswith`/`endswith`,
    have obvious interpretations. The `isspace` method is also fairly obvious, but
    remember that all whitespace characters (including tab and newline) are considered,
    not just the space character.
  prefs: []
  type: TYPE_NORMAL
- en: The `istitle` method returns `True` if the first character of each word is capitalized
    and all other characters are lowercase. Note that it does not strictly enforce
    the English grammatical definition of title formatting. For example, Leigh Hunt's
    poem *The Glove and the Lions* should be a valid title, even though not all words
    are capitalized. Robert Service's *The Cremation of Sam McGee* should also be
    a valid title, even though there is an uppercase letter in the middle of the last
    word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful with the `isdigit`, `isdecimal`, and `isnumeric` methods, as they
    are more nuanced than we would expect. Many Unicode characters are considered
    numbers besides the 10 digits we are used to. Worse, the period character that
    we use to construct floats from strings is not considered a decimal character,
    so `''45.2''.isdecimal()` returns `False`. The real decimal character is represented
    by Unicode value 0660, as in 45.2 (or `45\u06602`). Further, these methods do
    not verify whether the strings are valid numbers; `127.0.0.1` returns `True` for
    all three methods. We might think we should use that decimal character instead
    of a period for all numeric quantities, but passing that character into the `float()`
    or `int()` constructor converts that decimal character to a zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result of all these inconsistencies is that the Boolean numeric checks are
    not very useful at all. We're usually much better off using a regular expression
    (discussed later in this chapter) to confirm whether the string matches a specific
    numeric pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other methods useful for pattern-matching do not return Booleans. The `count`
    method tells us how many times a given substring shows up in the string, while
    `find`, `index`, `rfind`, and `rindex` tell us the position of a given substring
    within the original string. The two `r` (for *right* or *reverse*) methods start
    searching from the end of the string. The `find` methods return `-1` if the substring
    can''t be found, while `index` raises `ValueError` in this situation. Have a look
    at some of these methods in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Most of the remaining string methods return transformations of the string. The
    `upper`, `lower`, `capitalize`, and `title` methods create new strings with all
    alphabetical characters in the given format. The `translate` method can use a
    dictionary to map arbitrary input characters to specified output characters.
  prefs: []
  type: TYPE_NORMAL
- en: For all of these methods, note that the input string remains unmodified; a brand
    new `str` instance is returned instead. If we need to manipulate the resultant
    string, we should assign it to a new variable, as in `new_value``=``value.capitalize()`.
    Often, once we've performed the transformation, we don't need the old value anymore,
    so a common idiom is to assign it to the same variable, as in `value``=``value.title()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a couple of string methods return or operate on lists. The `split`
    method accepts a substring and splits the string into a list of strings wherever
    that substring occurs. You can pass a number as a second parameter to limit the
    number of resultant strings. The `rsplit`method behaves identically to `split`
    if you don''t limit the number of strings, but if you do supply a limit, it starts
    splitting from the end of the string. The `partition` and `rpartition `methods
    split the string at only the first or last occurrence of the substring, and return
    a tuple of three values: characters before the substring, the substring itself,
    and the characters after the substring.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the inverse of `split`, the `join` method accepts a list of strings, and
    returns all of those strings combined together by placing the original string
    between them. The `replace` method accepts two arguments, and returns a string
    where each instance of the first argument has been replaced with the second. Here
    are some of these methods in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There you have it, a whirlwind tour of the most common methods on the `str`
    class! Now, let's look at Python 3's method for composing strings and variables
    to create new strings.
  prefs: []
  type: TYPE_NORMAL
- en: String formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 3 has powerful string formatting and templating mechanisms that allow
    us to construct strings comprised of hardcoded text and interspersed variables.
    We've used it in many previous examples, but it is much more versatile than the
    simple formatting specifiers we've used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A string can be turned into a format string (also called an **f-string**) by
    prefixing the opening quotation mark with an f, as in `f"hello world"`. If such
    a string contains the special characters  `{` and `}`, variables from the surrounding
    scope can be used to replace them as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run these statements, it replaces the braces with variables, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Escaping braces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Brace characters are often useful in strings, aside from formatting. We need
    a way to escape them in situations where we want them to be displayed as themselves,
    rather than being replaced. This can be done by doubling the braces. For example,
    we can use Python to format a basic Java program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Where we see the `{{` or `}}` sequence in the template—that is, the braces
    enclosing the Java class and method definition—we know the f-string will replace
    them with single braces, rather than some argument in the surrounding methods.
    Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The class name and contents of the output have been replaced with two parameters,
    while the double braces have been replaced with single braces, giving us a valid
    Java file. Turns out, this is about the simplest possible Python program to print
    the simplest possible Java program that can print the simplest possible Python
    program.
  prefs: []
  type: TYPE_NORMAL
- en: f-strings can contain Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We aren't restricted to passing simple string variables into an f-string method.
    Any primitives, such as integers or floats, can be formatted. More interestingly,
    complex objects, including lists, tuples, dictionaries, and arbitrary objects
    can be used, and we can access indexes and variables or call functions on those
    objects from within the `format` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if our email message had grouped the `From` and `To` email addresses
    into a tuple, and placed the subject and message in a dictionary, for some reason
    (perhaps because that''s the input required for an existing `send_mail` function
    we want to use), we can format it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The variables inside the braces in the template string look a little weird,
    so let's look at what they're doing. The two email addresses are looked up by
    `emails[x]`, where `x` is either `0` or `1`.  The square brackets with a number
    inside are the same kind of index lookup we see in regular Python code, so `emails[0]` 
    refers to the first item in the `emails` tuple. The indexing syntax works with
    any indexable object, so we see similar behavior when we access `message[subject]`,
    except this time we are looking up a string key in a dictionary. Notice that,
    unlike in Python code, we do not need to put quotes around the string in the dictionary
    lookup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even do multiple levels of lookup if we have nested data structures.
    If we modify the above code to put the `emails` tuple inside the `message` dictionary,
    we can use an indexed lookup as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I would recommend against doing this often, as template strings rapidly become
    difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you have an object or class, you can execute object lookups
    or even call methods inside the f-string. Let''s change our email message data
    once again, this time to a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The template in this example may be more readable than the previous examples,
    but the overhead of creating an `email` class adds complexity to the Python code.
    It would be foolish to create a class for the express purpose of including the
    object in a template. Typically, we'd use this sort of lookup if the object we
    are trying to format already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pretty much any Python code that you would expect to return a string (or a
    value that can convert to a string with the `str()` function) can be executed
    inside an f-string.  As an example of how powerful it can get, you can even use
    a list comprehension or ternary operator in a format string parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Making it look right
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s nice to be able to include variables in template strings, but sometimes
    the variables need a bit of coercion to make them look the way we want them to
    in the output. For example, if we are performing calculations with currency, we
    may end up with a long decimal that we don''t want to show up in our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this formatting code, the output doesn''t quite look like proper
    currency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Technically, we should never use floating-point numbers in currency calculations
    like this; we should construct `decimal.Decimal()` objects instead. Floats are
    dangerous because their calculations are inherently inaccurate beyond a specific
    level of precision. But we're looking at strings, not floats, and currency is
    a great example for formatting!
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the preceding `format` string, we can include some additional information
    inside the curly braces to adjust the formatting of the parameters. There are
    tons of things we can customize, but the basic syntax inside the braces is the
    same. After providing the template value, we include a colon, and then some specific
    syntax for the formatting. Here''s an improved version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `0.2f` format specifier after the colons basically says the following,
    from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: for values lower than one, make sure a zero is displayed on the left-hand
    of the decimal point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.`: show a decimal point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: show two places after the decimal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f`: format the input value as a float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also specify that each number should take up a particular number of
    characters on the screen by placing a value before the period. This can be useful
    for outputting tabular data, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, that''s a pretty scary-looking format string, so let''s see how it works
    before we break it down into understandable parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Nifty! So, how is this actually happening? We have four variables we are formatting,
    in each line of the `for` loop. The first variable is a string that is formatted
    with `{product:10s}`. This one is easier to read from right to left:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s` means it is a string variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10` means it should take up 10 characters. By default, with strings, if the
    string is shorter than the specified number of characters, it appends spaces to
    the right-hand side of the string to make it long enough (beware, however: if
    the original string is too long, it won''t be truncated!).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product:`, of course, is the name of the variable or Python expression being
    formatted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The formatter for the `quantity` value is`{quantity: ^9d}`. You can interpret
    this format from right to left as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d` represents an integer value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9` tells us the value should take up nine characters on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^` tells us that the number should be aligned in the center of this available
    padding; this makes the column look a bit more professional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (space) tells the formatter to use a space as the padding character. With integers,
    instead of spaces, the extra characters are zeros, by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quantity:` is the variable being formatted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these specifiers have to be in the right order, although all are optional:
    fill first, then align, then the size, and finally, the type.'
  prefs: []
  type: TYPE_NORMAL
- en: We do similar things with the specifiers for `price` and `subtotal`. For `price`,
    we use `{2:``<8.2f}`; and for `subtotal`, `{3:``>7.2f}`. In both cases, we're
    specifying a space as the fill character, but we use the `<` and `>` symbols,
    respectively, to represent that the numbers should be aligned to the left or right
    within a minimum space of eight or seven characters. Further, each float should
    be formatted to two decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: The *type* character for different types can affect formatting output as well.
    We've seen the `s`, `d`, and `f` types, for strings, integers, and floats. Most
    of the other format specifiers are alternative versions of these; for example,
    `o` represents octal format and `X` represents hexadecimal if formatting integers.
    The `n` type specifier can be useful for formatting integer separators in the
    current locale's format. For floating-point numbers, the `%` type will multiply
    by 100 and format a float as a percentage.
  prefs: []
  type: TYPE_NORMAL
- en: Custom formatters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While these standard formatters apply to most built-in objects, it is also
    possible for other objects to define nonstandard specifiers. For example, if we
    pass a `datetime` object into `format`, we can use the specifiers used in the
    `datetime.strftime` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is even possible to write custom formatters for objects we create ourselves,
    but that is beyond the scope of this book. Look into overriding the `__format__`
    special method if you need to do this in your code.
  prefs: []
  type: TYPE_NORMAL
- en: The Python formatting syntax is quite flexible but it is a difficult mini-language
    to remember. I use it every day and still occasionally have to look up forgotten
    concepts in the documentation. It also isn't powerful enough for serious templating
    needs, such as generating web pages. There are several third-party templating
    libraries you can look into if you need to do more than basic formatting of a
    few strings.
  prefs: []
  type: TYPE_NORMAL
- en: The format method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few cases where you won''t be able to use f-strings. First, you
    can''t reuse a single template string with different variables. Second, f-strings
    were introduced in Python 3.6\. If you''re stuck on an older version of Python
    or need to reuse template strings, you can use the older `str.format` method instead.
    It uses the same formatting specifiers as f-strings, but can be called multiple
    times on one string. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `format` method behaves similarly to f-strings, but there are a couple
    of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: It is restricted in what it can look up. You can access attributes on objects
    or look up an index in a list or dict, but you can't call a function inside the
    template string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use integers to access positional arguments passed to the format method:
    `"{0} world".format(''bonjour'')`. The indexes are optional if you specify the
    variables in order: `"{} {}".format(''hello'', ''world'')`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings are Unicode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this section, we defined strings as collections of immutable
    Unicode characters. This actually makes things very complicated at times, because
    Unicode isn't really a storage format. If you get a string of bytes from a file
    or a socket, for example, they won't be in Unicode. They will, in fact, be the
    built-in type `bytes`. Bytes are immutable sequences of... well, bytes. Bytes
    are the basic storage format in computing. They represent 8 bits, usually described
    as an integer between 0 and 255, or a hexadecimal equivalent between 0 and FF.
    Bytes don't represent anything specific; a sequence of bytes may store characters
    of an encoded string, or pixels in an image.
  prefs: []
  type: TYPE_NORMAL
- en: If we print a byte object, any bytes that map to ASCII representations will
    be printed as their original character, while non-ASCII bytes (whether they are
    binary data or other characters) are printed as hex codes escaped by the `\x`
    escape sequence. You may find it odd that a byte, represented as an integer, can
    map to an ASCII character. But ASCII is really just code where each letter is
    represented by a different byte pattern, and therefore, a different integer. The
    character *a* is represented by the same byte as the integer 97, which is the
    hexadecimal number 0x61\. Specifically, all of these are an interpretation of
    the binary pattern 01100001.
  prefs: []
  type: TYPE_NORMAL
- en: Many I/O operations only know how to deal with `bytes`, even if the `bytes`
    object refers to textual data. It is therefore vital to know how to convert between
    `bytes` and Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that there are many ways to map `bytes` to Unicode text. Bytes
    are machine-readable values, while text is a human-readable format. Sitting in
    between is an encoding that maps a given sequence of bytes to a given sequence
    of text characters.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are multiple such encodings (ASCII is only one of them). The
    same sequence of bytes represents completely different text characters when mapped
    using different encodings! So, `bytes` must be decoded using the same character
    set with which they were encoded. It's not possible to get text from bytes without
    knowing how the bytes should be decoded. If we receive unknown bytes without a
    specified encoding, the best we can do is guess what format they are encoded in,
    and we may be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Converting bytes to text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we have an array of `bytes` from somewhere, we can convert it to Unicode
    using the `.decode` method on the `bytes` class. This method accepts a string
    for the name of the character encoding. There are many such names; common ones
    for Western languages include ASCII, UTF-8, and latin-1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence of bytes (in hex), 63 6c 69 63 68 e9, actually represents the
    characters of the word cliché in latin-1 encoding. The following example will
    encode this sequence of bytes and convert it to a Unicode string using latin-1
    encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a `bytes` object. Analogous to an f-string, the `b` character
    immediately before the string tells us that we are defining a `bytes` object instead
    of a normal Unicode string. Within the string, each byte is specified using—in
    this case—a hexadecimal number. The `\x` character escapes within the byte string,
    and each say, *the next two characters represent a byte using hexadecimal digits*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Provided we are using a shell that understands latin-1 encoding, the two `print`
    calls will output the following strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first `print` statement renders the bytes for ASCII characters as themselves.
    The unknown (unknown to ASCII, that is) character stays in its escaped hex format.
    The output includes a `b` character at the beginning of the line to remind us
    that it is a `bytes` representation, not a string.
  prefs: []
  type: TYPE_NORMAL
- en: The next call decodes the string using latin-1 encoding. The `decode` method
    returns a normal (Unicode) string with the correct characters. However, if we
    had decoded this same string using the Cyrillic `iso8859-5` encoding, we'd have
    ended up with the `'clichщ'` string! This is because the `\xe9` byte maps to different
    characters in the two encodings.
  prefs: []
  type: TYPE_NORMAL
- en: Converting text to bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we need to convert incoming bytes into Unicode, we''re clearly also going
    to have situations where we convert outgoing Unicode into byte sequences. This
    is done with the `encode` method on the `str` class, which, like the `decode`
    method, requires a character set. The following code creates a Unicode string
    and encodes it in different character sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three encodings create a different set of bytes for the accented
    character. The fourth one can''t even handle that byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now you should understand the importance of encodings! The accented character
    is represented as a different byte for each encoding; if we use the wrong one
    when we are decoding bytes to text, we get the wrong character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception in the last case is not always the desired behavior; there may
    be cases where we want the unknown characters to be handled in a different way.
    The `encode` method takes an optional string argument named `errors` that can
    define how such characters should be handled. This string can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmlcharrefreplace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `strict` replacement strategy is the default we just saw. When a byte sequence
    is encountered that does not have a valid representation in the requested encoding,
    an exception is raised. When the `replace` strategy is used, the character is
    replaced with a different character; in ASCII, it is a question mark; other encodings
    may use different symbols, such as an empty box. The `ignore` strategy simply
    discards any bytes it doesn''t understand, while the `xmlcharrefreplace` strategy
    creates an `xml` entity representing the Unicode character. This can be useful
    when converting unknown strings for use in an XML document. Here''s how each of
    the strategies affects our sample word:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Strategy** | **Result of applying** `"cliché".encode("ascii", strategy)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `replace` | `b''clich?''` |'
  prefs: []
  type: TYPE_TB
- en: '| `ignore` | `b''clich''` |'
  prefs: []
  type: TYPE_TB
- en: '| `xmlcharrefreplace` | `b''cliché''` |'
  prefs: []
  type: TYPE_TB
- en: It is possible to call the `str.encode` and `bytes.decode` methods without passing
    an encoding name. The encoding will be set to the default encoding for the current
    platform. This will depend on the current operating system and locale or regional
    settings; you can look it up using the `sys.getdefaultencoding()` function. It
    is usually a good idea to specify the encoding explicitly, though, since the default
    encoding for a platform may change, or the program may one day be extended to
    work on text from a wider variety of sources.
  prefs: []
  type: TYPE_NORMAL
- en: If you are encoding text and don't know which encoding to use, it is best to
    use UTF-8 encoding. UTF-8 is able to represent any Unicode character. In modern
    software, it is a de facto standard encoding to ensure documents in any language—or
    even multiple languages —can be exchanged. The various other possible encodings
    are useful for legacy documents or in regions that still use different character
    sets by default.
  prefs: []
  type: TYPE_NORMAL
- en: The UTF-8 encoding uses one byte to represent ASCII and other common characters,
    and up to four bytes for more complex characters. UTF-8 is special because it
    is backwards-compatible with ASCII; any ASCII document encoded using UTF-8 will
    be identical to the original ASCII document.
  prefs: []
  type: TYPE_NORMAL
- en: I can never remember whether to use `encode` or `decode` to convert from binary
    bytes to Unicode. I always wished these methods were named `to_binary` and `from_binary` instead.
    If you have the same problem, try mentally replacing the word *code* with *binary*;
    *enbinary* and *debinary* are pretty close to *to_binary* and *from_binary*. I
    have saved a lot of time by not looking up the method help files since devising
    this mnemonic.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable byte strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `bytes` type, like `str`, is immutable. We can use index and slice notation
    on a `bytes` object and search for a particular sequence of bytes, but we can't
    extend or modify them. This can be very inconvenient when dealing with I/O, as
    it is often necessary to buffer incoming or outgoing bytes until they are ready
    to be sent. For example, if we are receiving data from a socket, it may take several
    `recv` calls before we have received an entire message.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `bytearray` built-in comes in. This type behaves something
    like a list, except it only holds bytes. The constructor for the class can accept
    a `bytes` object to initialize it. The `extend` method can be used to append another
    `bytes` object to the existing array (for example, when more data comes from a
    socket or other I/O channel).
  prefs: []
  type: TYPE_NORMAL
- en: 'Slice notation can be used on `bytearray` to modify the item inline. For example,
    this code constructs a `bytearray` from a `bytes` object and then replaces two
    bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we want to manipulate a single element in `bytearray`, we must pass an integer
    between 0 and 255 (inclusive) as the value. This integer represents a specific
    `bytes` pattern. If we try to pass a character or `bytes` object, it will raise
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single byte character can be converted to an integer using the `ord` (short
    for ordinal) function. This function returns the integer representation of a single
    character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After constructing the array, we replace the character at index `3` (the fourth
    character, as indexing starts at `0`, as with lists) with byte `103`. This integer
    was returned by the `ord` function and is the ASCII character for the lowercase
    `g`. For illustration, we also replaced the next character up with byte number
    `68`, which maps to the ASCII character for the uppercase `D`.
  prefs: []
  type: TYPE_NORMAL
- en: The `bytearray` type has methods that allow it to behave like a list (we can
    append integer bytes to it, for example), but also like a `bytes` object; we can
    use methods such as `count` and `find` the same way they would behave on a `bytes`
    or `str` object. The difference is that `bytearray` is a mutable type, which can
    be useful for building up complex sequences of bytes from a specific input source.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You know what's really hard to do using object-oriented principles? Parsing
    strings to match arbitrary patterns, that's what. There have been a fair number
    of academic papers written in which object-oriented design is used to set up string-parsing,
    but the result is always very verbose and hard to read, and they are not widely
    used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, string-parsing in most programming languages is handled by
    regular expressions. These are not verbose, but, wow, are they ever hard to read,
    at least until you learn the syntax. Even though regular expressions are not object-oriented,
    the Python regular expression library provides a few classes and objects that
    you can use to construct and run regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions are used to solve a common problem: Given a string, determine
    whether that string matches a given pattern and, optionally, collect substrings
    that contain relevant information. They can be used to answer questions such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Is this string a valid URL?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the date and time of all warning messages in a log file?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which users in `/etc/passwd` are in a given group?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What username and document were requested by the URL a visitor typed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many similar scenarios where regular expressions are the correct answer.
    Many programmers have made the mistake of implementing complicated and fragile
    string-parsing libraries because they didn't know or wouldn't learn regular expressions.
    In this section, we'll gain enough knowledge of regular expressions to not make
    such mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Matching patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions are a complicated mini-language. They rely on special characters
    to match unknown strings, but let''s start with literal characters, such as letters,
    numbers, and the space character, which always match themselves. Let''s see a
    basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The Python Standard Library module for regular expressions is called `re`. We
    import it and set up a search string and pattern to search for; in this case,
    they are the same string. Since the search string matches the given pattern, the
    conditional passes and the `print` statement executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that the `match` function matches the pattern to the beginning
    of the string. Thus, if the pattern were `"ello world"`, no match would be found.
    With confusing asymmetry, the parser stops searching as soon as it finds a match,
    so the pattern `"hello wo"` matches successfully. Let''s build a small example
    program to demonstrate these differences and help us learn other regular expression
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a generic version of the earlier example that accepts the pattern
    and search string from the command line. We can see how the start of the pattern
    must match, but a value is returned as soon as a match is found in the following
    command-line interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We'll be using this script throughout the next few sections. While the script
    is always invoked with the `python regex_generic.py "<pattern>" "<string>"` command,
    we'll only see the output in the following examples, to conserve space.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need control over whether items happen at the beginning or end of a
    line (or if there are no newlines in the string, or at the beginning and end of
    the string), you can use the `^` and `$` characters to represent the start and
    end of the string respectively. If you want a pattern to match an entire string,
    it''s a good idea to include both of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Matching a selection of characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with matching an arbitrary character. The period character, when
    used in a regular expression pattern, can match any single character. Using a
    period in the string means you don''t care what the character is, just that there
    is a character there. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the last example does not match because there is no character at
    the period's position in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all well and good, but what if we only want a few specific characters
    to match? We can put a set of characters inside square brackets to match any one
    of those characters. So, if we encounter the string `[abc]`  in a regular expression
    pattern, we know that those five (including the two square brackets) characters
    will only match one character in the string being searched, and further, that
    this one character will be either an `a`, a `b`, or a `c`. Let''s see a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'These square bracket sets should be named character sets, but they are more
    often referred to as **character classes**. Often, we want to include a large
    range of characters inside these sets, and typing them all out can be monotonous
    and error-prone. Fortunately, the regular expression designers thought of this
    and gave us a shortcut. The dash character, in a character set, will create a
    range. This is especially useful if you want to match *all lowercase letters*,
    *all letters*, or *all numbers,* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There are other ways to match or exclude individual characters, but you'll need
    to find a more comprehensive tutorial via a web search if you want to find out
    what they are!
  prefs: []
  type: TYPE_NORMAL
- en: Escaping characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If putting a period character in a pattern matches any arbitrary character,
    how do we match just a period in a string? One way might be to put the period
    inside square brackets to make a character class, but a more generic method is
    to use backslashes to escape it. Here''s a regular expression to match two-digit
    decimal numbers between 0.00 and 0.99:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For this pattern, the two characters `\.` match the single `.` character. If
    the period character is missing or is a different character, it will not match.
  prefs: []
  type: TYPE_NORMAL
- en: This backslash escape sequence is used for a variety of special characters in
    regular expressions. You can use `\[` to insert a square bracket without starting
    a character class, and `\(` to insert a parenthesis, which we'll later see is
    also a special character.
  prefs: []
  type: TYPE_NORMAL
- en: 'More interestingly, we can also use the escape symbol followed by a character
    to represent special characters such as newlines (`\n`) and tabs (`\t`). Further,
    some character classes can be represented more succinctly using escape strings:
    `\s` represents whitespace characters; `\w` represents letters, numbers, and underscore;
    and `\d` represents a digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Matching multiple characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this information, we can match most strings of a known length, but most
    of the time, we don't know how many characters to match inside a pattern. Regular
    expressions can take care of this, too. We can modify a pattern by appending one
    of several hard-to-remember punctuation symbols to match multiple characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The asterisk (`*`) character says that the previous pattern can be matched
    zero or more times. This probably sounds silly, but it''s one of the most useful
    repetition characters. Before we explore why, consider some silly examples to
    make sure we understand what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, the `*` character in the pattern says that the previous pattern (the `l`
    character) is optional, and if present, can be repeated as many times as possible
    to match the pattern. The rest of the characters (`h`, `e`, and `o`) have to appear
    exactly once.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s pretty rare to want to match a single letter multiple times, but it gets
    more interesting if we combine the asterisk with patterns that match multiple
    characters. So, `.*`, for example, will match any string, whereas `[a-z]*` matches
    any collection of lowercase words, including the empty string. Here are a few
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The plus (`+`) sign in a pattern behaves similarly to an asterisk; it states
    that the previous pattern can be repeated one or more times, but, unlike the asterisk,
    is not optional. The question mark (`?`) ensures a pattern shows up exactly zero
    or one times, but not more. Let''s explore some of these by playing with numbers
    (remember that `\d` matches the same character class as `[0-9]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Grouping patterns together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve seen how we can repeat a pattern multiple times, but we are
    restricted in what patterns we can repeat. If we want to repeat individual characters,
    we''re covered, but what if we want a repeating sequence of characters? Enclosing
    any set of patterns in parentheses allows them to be treated as a single pattern
    when applying repetition operations. Compare these patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Combined with complex patterns, this grouping feature greatly expands our pattern-matching
    repertoire. Here''s a regular expression that matches simple English sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first word starts with a capital, followed by zero or more lowercase letters.
    Then, we enter a parenthetical that matches a single space followed by a word
    of one or more lowercase letters. This entire parenthetical is repeated zero or
    more times, and the pattern is terminated with a period. There cannot be any other
    characters after the period, as indicated by the `$` matching the end of string.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen many of the most basic patterns, but the regular expression language
    supports many more. I spent my first few years using regular expressions looking
    up the syntax every time I needed to do something. It is worth bookmarking Python's
    documentation for the `re` module and reviewing it frequently. There are very
    few things that regular expressions cannot match, and they should be the first
    tool you reach for when parsing strings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information from regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now focus on the Python side of things. The regular expression syntax
    is the furthest thing from object-oriented programming. However, Python's `re`
    module provides an object-oriented interface to enter the regular expression engine.
  prefs: []
  type: TYPE_NORMAL
- en: We've been checking whether the `re.match` function returns a valid object or
    not. If a pattern does not match, that function returns `None`. If it does match,
    however, it returns a useful object that we can introspect for information about
    the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, our regular expressions have answered questions such as, *does this
    string match this pattern?* Matching patterns is useful, but in many cases, a
    more interesting question is, *if this string matches this pattern, what is the
    value of a relevant substring?* If you use groups to identify parts of the pattern
    that you want to reference later, you can get them out of the match return value,
    as illustrated in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The specification describing valid email addresses is extremely complicated,
    and the regular expression that accurately matches all possibilities is obscenely
    long. So, we cheated and made a simple regular expression that matches some common
    email addresses; the point is that we want to access the domain name (after the
    `@` sign) so we can connect to that address. This is done easily by wrapping that
    part of the pattern in parentheses and calling the `groups()` method on the object
    returned by `match`.
  prefs: []
  type: TYPE_NORMAL
- en: The `groups` method returns a tuple of all the groups matched inside the pattern,
    which you can index to access a specific value. The groups are ordered from left
    to right. However, bear in mind that groups can be nested, meaning you can have
    one or more groups inside another group. In this case, the groups are returned
    in the order of their leftmost brackets, so the outermost group will be returned
    before its inner matching groups.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `match` function, the `re` module provides a couple of other
    useful functions, `search` and `findall`. The `search` function finds the first
    instance of a matching pattern, relaxing the restriction that the pattern should
    start at the first letter of the string. Note that you can get a similar effect
    by using `match` and putting a  `^.*` character at the front of the pattern to
    match any characters between the start of the string and the pattern you are looking
    for.
  prefs: []
  type: TYPE_NORMAL
- en: The `findall` function behaves similarly to search, except that it finds all
    non-overlapping instances of the matching pattern, not just the first one. Basically,
    it finds the first match, then it resets the search to the end of that matching
    string and finds the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of returning a list of match objects, as you would expect, it returns
    a list of matching strings, or tuples. Sometimes it''s strings, sometimes it''s
    tuples. It''s not a very good API at all! As with all bad APIs, you''ll have to
    memorize the differences and not rely on intuition. The type of the return value
    depends on the number of bracketed groups inside the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are no groups in the pattern, `re.findall` will return a list of strings,
    where each value is a complete substring from the source string that matches the
    pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is exactly one group in the pattern, `re.findall` will return a list
    of strings where each value is the contents of that group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are multiple groups in the pattern, `re.findall` will return a list
    of tuples where each tuple contains a value from a matching group, in order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you are designing function calls in your own Python libraries, try to make
    the function always return a consistent data structure. It is often good to design
    functions that can take arbitrary inputs and process them, but the return value
    should not switch from a single value to a list, or a list of values to a list
    of tuples depending on the input. Let `re.findall` be a lesson!
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples in the following interactive session will hopefully clarify the
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Making repeated regular expressions efficient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you call one of the regular expression methods, the engine has to convert
    the pattern string into an internal structure that makes searching strings fast.
    This conversion takes a non-trivial amount of time. If a regular expression pattern
    is going to be reused multiple times (for example, inside a `for` or `while` loop),
    it would be better if this conversion step could be done only once.
  prefs: []
  type: TYPE_NORMAL
- en: This is possible with the `re.compile` method. It returns an object-oriented
    version of the regular expression that has been compiled down and has the methods
    we've explored (`match`, `search`, and `findall`) already, among others. We'll
    see examples of this in the case study.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has definitely been a condensed introduction to regular expressions. At
    this point, we have a good feel for the basics and will recognize when we need
    to do further research. If we have a string pattern-matching problem, regular
    expressions will almost certainly be able to solve them for us. However, we may
    need to look up new syntaxes in a more comprehensive coverage of the topic. But
    now we know what to look for! Let''s move on to a completely different topic:
    filesystem paths.'
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All operating systems provide a *filesystem*, a way of mapping a logical abstraction
    of *folders* (or *directories*) and *files* to the bits and bytes stored on a
    hard drive or other storage device. As humans, we typically interact with the
    filesystem using a drag-and-drop interface of folders and files of different types,
    or with command-line programs such as `cp`, `mv`, and `mkdir`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As programmers, we have to interact with the filesystem with a series of system
    calls. You can think of these as library functions supplied by the operating system
    so that programs can call them. They have a clunky interface with integer file
    handles and buffered reads and writes, and that interface is different depending
    on which operating system you are using. Python provides an OS-independent abstraction
    over these system calls in the `os.path` module. It''s a little easier to work
    with than accessing the operating system directly, but it''s not very intuitive.
    It requires a lot of string concatenation and you have to be conscious of whether
    to use a forward slash or a backslash between directories, depending on the operating
    system. There is a `os.sep` file representing the path separator, but using it
    requires code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Working with filesystem paths is easily one of the most irritating uses of strings
    inside the entire standard library. Paths that are easy to type on the command
    line become illegible in Python code. When you have to manipulate and access multiple
    paths (for example, when processing images in a data pipeline for a machine learning
    computer vision problem), just managing those directories becomes a bit of an
    ordeal.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the Python language designers included a module called `pathlib` in the
    standard library. It''s an object-oriented representation of paths and files that
    is much more pleasant to work with. The preceding path, using `pathlib`, would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's quite a bit easier to see what's going on. Notice the unique
    use of the division operator as a path separator so you don't have to do anything
    with `os.sep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a more real-world example, consider some code that counts the number of
    lines of code excluding whitespace and comments in all Python files in the current
    directory and subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In typical `pathlib` usage, we rarely have to construct more than one or two
    paths. Usually, other files or directories are relative to a general path. This
    example demonstrates that. We only ever construct one path, from the current directory
    using `pathlib.Path(".")`. Then, other paths are created based on that path.
  prefs: []
  type: TYPE_NORMAL
- en: The `count_sloc` function first initializes the **sloc** (**source lines of
    code**) counter to zero. Then, it iterates over all the files and directories
    in the path that was passed into the function using the `dir_path.iterdir` generator
    (we'll discuss generators in detail in the next chapter; for now, think of it
    as a sort of dynamic list). Each of the paths returned to the `for` loop by `iterdir`
    is itself another path. We first test whether this path starts with a `.`, which
    represents a hidden directory on most OSes (this will keep it from counting any
    files in the `.git` directory if you are using version control). Then, we check
    whether it is a directory using the `isdir()`  method. If it is, we recursively
    call `count_sloc` to count the lines of code in modules in the child package.
  prefs: []
  type: TYPE_NORMAL
- en: If it's not a directory, we assume it is a normal file, and skip any files that
    don't end with the `.py` extension, using the `suffix` property. Now, knowing
    we have a path to a Python file, we open the file using the `open()` method, which
    returns a context manager. We wrap this in a `with` block so the file is automatically
    closed when we are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: The `Path.open` method takes similar arguments to the `open` built-in function,
    but it uses a more object-oriented syntax. If you prefer the function version,
    you can pass a `Path` object into it as the first parameter (in other words, `with
    open(Path('./README.md')):`) just as you would a string. But I personally think
    `Path('./README.md').open()` is more legible if the path already exists.
  prefs: []
  type: TYPE_NORMAL
- en: We then iterate over each line in the file and add it to the count. We skip
    whitespace and comment lines, since these don't represent actual source code.
    The total count is returned to the calling function, which may be the original
    call or the recursive parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Path` class in the `pathlib` module has a method or property to cover
    pretty much everything you might want to do with a path. In addition to those
    we covered in the example, here are a few of my favorites:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.absolute()` returns the full path from the root of the filesystem. I usually
    call this on every path I construct in due to a bit of paranoia that I might forget
    where relative paths came from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.parent` returns a path to the parent directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.exists()` checks whether the file or directory exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.mkdir()` creates a directory at the current path. It takes Boolean `parents`
    and `exist_ok` arguments to indicate that it should recursively create the directories
    if necessary and that it shouldn''t raise an exception if the directory already
    exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the standard library documentation at [https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)
    for more exotic uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most standard library modules that accept a string path can also accept a `pathlib.Path`
    object. For example, you can open a ZIP file by passing a path into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't always work, especially if you are using a third-party library
    that is implemented as a C extension. In those cases, you'll have to cast the
    path to a string using `str(pathname)`.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, we take the ability to write data to a file and retrieve it at an
    arbitrary later date for granted. As convenient as this is (imagine the state
    of computing if we couldn't store anything!), we often find ourselves converting
    data we have stored in a nice object or design pattern in memory into some kind
    of clunky text or binary format for storage, transfer over the network, or remote
    invocation on a distant server.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `pickle` module is an object-oriented way to store objects directly
    in a special storage format. It essentially converts an object (and all the objects
    it holds as attributes) into a sequence of bytes that can be stored or transported
    however we see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For basic tasks, the `pickle` module has an extremely simple interface. It
    comprises four basic functions for storing and loading data: two for manipulating
    file-like objects, and two for manipulating `bytes` objects (the latter are just
    shortcuts to the file-like interface, so we don''t have to create a `BytesIO`
    file-like object ourselves).'
  prefs: []
  type: TYPE_NORMAL
- en: The `dump` method accepts an object to be written and a file-like object to
    write the serialized bytes to. This object must have a `write` method (or it wouldn't
    be file-like), and that method must know how to handle a `bytes` argument (so,
    a file opened for text output wouldn't work).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `load` method does exactly the opposite; it reads a serialized object from
    a file-like object. This object must have the proper file-like `read` and `readline`
    arguments, each of which must, of course, return `bytes`. The `pickle` module
    will load the object from these bytes and the `load` method will return the fully
    reconstructed object. Here''s an example that stores and then loads some data
    in a list object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works as advertised: the objects are stored in the file and then
    loaded from the same file. In each case, we open the file using a `with` statement
    so that it is automatically closed. The file is first opened for writing and then
    a second time for reading, depending on whether we are storing or loading data.'
  prefs: []
  type: TYPE_NORMAL
- en: The `assert` statement at the end would raise an error if the newly loaded object
    was not equal to the original object. Equality does not imply that they are the
    same object. Indeed, if we print the `id()` of both objects, we would discover
    they are different. However, because they are both lists whose contents are equal,
    the two lists are also considered equal.
  prefs: []
  type: TYPE_NORMAL
- en: The `dumps` and `loads` functions behave much like their file-like counterparts,
    except they return or accept `bytes` instead of file-like objects. The `dumps`
    function requires only one argument, the object to be stored, and it returns a
    serialized `bytes` object. The `loads` function requires a `bytes` object and
    returns the restored object. The `'s'` character in the method names is short
    for string; it's a legacy name from ancient versions of Python, where `str` objects
    were used instead of `bytes`.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to call `dump` or `load` on a single open file more than once.
    Each call to `dump` will store a single object (plus any objects it is composed
    of or contains), while a call to `load` will load and return just one object.
    So, for a single file, each separate call to `dump` when storing the object should
    have an associated call to `load` when restoring at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing pickles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With most common Python objects, pickling *just works*. Basic primitives such
    as integers, floats, and strings can be pickled, as can any container objects,
    such as lists or dictionaries, provided the contents of those containers are also
    picklable. Further, and importantly, any object can be pickled, so long as all
    of its attributes are also picklable.
  prefs: []
  type: TYPE_NORMAL
- en: So, what makes an attribute unpicklable? Usually, it has something to do with
    time-sensitive attributes that it would not make sense to load in the future.
    For example, if we have an open network socket, open file, running thread, or
    database connection stored as an attribute on an object, it would not make sense
    to pickle these objects; a lot of operating system state would simply be gone
    when we attempted to reload them later. We can't just pretend a thread or socket
    connection exists and make it appear! No, we need to somehow customize how such
    transient data is stored and restored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a class that loads the contents of a web page every hour to ensure
    that they stay up to date. It uses the `threading.Timer` class to schedule the
    next update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`url`, `contents`, and `last_updated` are all pickleable, but if we try to
    pickle an instance of this class, things go a little nutty on the `self.timer`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: That's not a very useful error, but it looks like we're trying to pickle something
    we shouldn't be. That would be the `Timer` instance; we're storing a reference
    to `self.timer` in the schedule method, and that attribute cannot be serialized.
  prefs: []
  type: TYPE_NORMAL
- en: When `pickle` tries to serialize an object, it simply tries to store the object's
    `__dict__` attribute; `__dict__` is a dictionary mapping all the attribute names
    on the object to their values. Luckily, before checking `__dict__`, `pickle` checks
    to see whether a `__getstate__` method exists. If it does, it will store the return
    value of that method instead of the `__dict__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `__getstate__` method to our `UpdatedURL` class that simply returns
    a copy of the `__dict__` without a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If we pickle the object now, it will no longer fail. And we can even successfully
    restore that object using `loads`. However, the restored object doesn't have a
    timer attribute, so it will not be refreshing the content like it is designed
    to do. We need to somehow create a new timer (to replace the missing one) when
    the object is unpickled.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we might expect, there is a complementary `__setstate__` method that can
    be implemented to customize unpickling. This method accepts a single argument,
    which is the object returned by `__getstate__`. If we implement both methods,
    `__getstate__` is not required to return a dictionary, since `__setstate__` will
    know what to do with whatever object `__getstate__` chooses to return. In our
    case, we simply want to restore the `__dict__`, and then create a new timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `pickle` module is very flexible and provides other tools to further customize
    the pickling process if you need them. However, these are beyond the scope of
    this book. The tools we've covered are sufficient for many basic pickling tasks.
    Objects to be pickled are normally relatively simple data objects; we likely would
    not pickle an entire running program or complicated design pattern, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing web objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not a good idea to load a pickled object from an unknown or untrusted
    source. It is possible to inject arbitrary code into a pickled file to maliciously
    attack a computer via the pickle. Another disadvantage of pickles is that they
    can only be loaded by other Python programs, and cannot be easily shared with
    services written in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: There are many formats that have been used for this purpose over the years.
    **Extensible Markup Language** (**XML**) used to be very popular, especially with
    Java developers. **Yet Another Markup Language** (**YAML**) is another format
    that you may see referenced occasionally. Tabular data is frequently exchanged
    in the **Comma-Separated Value** (**CSV**) format. Many of these are fading into
    obscurity and there are many more that you will encounter over time. Python has
    solid standard or third-party libraries for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Before using such libraries on untrusted data, make sure to investigate security
    concerns with each of them. XML and YAML, for example, both have obscure features
    that, used maliciously, can allow arbitrary commands to be executed on the host
    machine. These features may not be turned off by default. Do your research.
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is a human-readable format for exchanging
    primitive data. JSON is a standard format that can be interpreted by a wide array
    of heterogeneous client systems. Hence, JSON is extremely useful for transmitting
    data between completely decoupled systems. Further, JSON does not have any support
    for executable code, only data can be serialized; thus, it is more difficult to
    inject malicious statements into it.'
  prefs: []
  type: TYPE_NORMAL
- en: Because JSON can be easily interpreted by JavaScript engines, it is often used
    for transmitting data from a web server to a JavaScript-capable web browser. If
    the web application serving the data is written in Python, it needs a way to convert
    internal data into the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: There is a module to do this, predictably named `json`. This module provides
    a similar interface to the `pickle` module, with `dump`, `load`, `dumps`, and
    `loads` functions. The default calls to these functions are nearly identical to
    those in `pickle`, so let's not repeat the details. There are a couple of differences;
    obviously, the output of these calls is valid JSON notation, rather than a pickled
    object. In addition, the `json` functions operate on `str` objects, rather than
    `bytes`. Therefore, when dumping to or loading from a file, we need to create
    text files rather than binary ones.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON serializer is not as robust as the `pickle` module; it can only serialize
    basic types such as integers, floats, and strings, and simple containers such
    as dictionaries and lists. Each of these has a direct mapping to a JSON representation,
    but JSON is unable to represent classes, methods, or functions. It is not possible
    to transmit complete objects in this format. Because the receiver of an object
    we have dumped to JSON format is normally not a Python object, it would not be
    able to understand classes or methods in the same way that Python does, anyway.
    In spite of the O for Object in its name, JSON is a **data** notation; objects,
    as you recall, are composed of both data and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: If we do have objects for which we want to serialize only the data, we can always
    serialize the object's `__dict__` attribute. Or we can semi-automate this task
    by supplying custom code to create or parse a JSON serializable dictionary from
    certain types of objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the `json` module, both the object storing and loading functions accept optional
    arguments to customize the behavior. The `dump` and `dumps` methods accept a poorly
    named `cls` (short for class, which is a reserved keyword) keyword argument. If
    passed, this should be a subclass of the `JSONEncoder` class, with the `default`
    method overridden. This method accepts an arbitrary object and converts it to
    a dictionary that `json` can digest. If it doesn't know how to process the object,
    we should call the `super()` method, so that it can take care of serializing basic
    types in the normal way.
  prefs: []
  type: TYPE_NORMAL
- en: The `load` and `loads` methods also accept such a `cls` argument that can be
    a subclass of the inverse class, `JSONDecoder`. However, it is normally sufficient
    to pass a function into these methods using the `object_hook` keyword argument.
    This function accepts a dictionary and returns an object; if it doesn't know what
    to do with the input dictionary, it can return it unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. Imagine we have the following simple contact class
    that we want to serialize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We could just serialize the `__dict__` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'But accessing special (double-underscore) attributes in this fashion is kind
    of crude. Also, what if the receiving code (perhaps some JavaScript on a web page)
    wanted that `full_name` property to be supplied? Of course, we could construct
    the dictionary by hand, but let''s create a custom encoder instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `default` method basically checks to see what kind of object we're trying
    to serialize. If it's a contact, we convert it to a dictionary manually. Otherwise,
    we let the parent class handle serialization (by assuming that it is a basic type,
    which `json` knows how to handle). Notice that we pass an extra attribute to identify
    this object as a contact, since there would be no way to tell upon loading it.
    This is just a convention; for a more generic serialization mechanism, it might
    make more sense to store a string type in the dictionary, or possibly even the
    full class name, including package and module. Remember that the format of the
    dictionary depends on the code at the receiving end; there has to be an agreement
    as to how the data is going to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this class to encode a contact by passing the class (not an instantiated
    object) to the `dump` or `dumps` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For decoding, we can write a function that accepts a dictionary and checks
    the existence of the `is_contact` variable to decide whether to convert it to
    a contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass this function to the `load` or `loads` function using the `object_hook`
    keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build a basic regular expression-powered templating engine in Python.
    This engine will parse a text file (such as an HTML page) and replace certain
    directives with text calculated from the input to those directives. This is about
    the most complicated task we would want to do with regular expressions; indeed,
    a full-fledged version of this would likely utilize a proper language-parsing
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This file contains *tags* of the form `/** <directive> <data> **/` where the
    data is an optional single word and the directives are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`include`: Copy the contents of another file here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variable`: Insert the contents of a variable here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loopover`: Repeat the contents of the loop for a variable that is a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endloop`: Signal the end of looped text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loopvar`: Insert a single value from the list being looped over'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This template will render a different page depending which variables are passed
    into it. These variables will be passed in from a so-called context file. This
    will be encoded as a `json` object with keys representing the variables in question.
    My context file might look like this, but you would derive your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we get into the actual string processing, let''s throw together some
    object-oriented boilerplate code for processing files and grabbing data from the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is all pretty basic, we create a class and initialize it with some variables
    passed in on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we try to make the regular expression a little bit more readable
    by breaking it across two lines? We use raw strings (the r prefix), so we don't
    have to double escape all our backslashes. This is common in regular expressions,
    but it's still a mess. (Regular expressions always are, but they're often worth
    it.)
  prefs: []
  type: TYPE_NORMAL
- en: The `pos` indicates the current character in the content that we are processing;
    we'll see a lot more of it in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Now all that's left is to implement the process method. There are a few ways
    to do this. Let's do it in a fairly explicit way.
  prefs: []
  type: TYPE_NORMAL
- en: The process method has to find each directive that matches the regular expression
    and do the appropriate work with it. However, it also has to take care of outputting
    the normal text before, after, and between each directive to the output file,
    unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: 'One good feature of the compiled version of regular expressions is that we
    can tell the `search` method to start searching at a specific position by passing
    the `pos` keyword argument. If we temporarily define doing the appropriate work
    with a directive as *ignore the directive and delete it from the output file*,
    our process loop looks quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In English, this function finds the first string in the text that matches the
    regular expression, outputs everything from the current position to the start
    of that match, and then advances the position to the end of the aforesaid match.
    Once it's out of matches, it outputs everything since the last position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, ignoring the directive is pretty useless in a templating engine,
    so let''s replace that position advancing line with code that delegates to a different
    method on the class depending on the directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: So, we grab the directive and the single argument from the regular expression.
    The directive becomes a method name and we dynamically look up that method name
    on the `self` object (a little error processing here, in case the template writer
    provides an invalid directive, would be better). We pass the `match` object and
    argument into that method and assume that method will deal with everything appropriately,
    including moving the `pos` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve got our object-oriented architecture this far, it''s actually
    pretty simple to implement the methods that are delegated to. The `include` and
    `variable` directives are totally straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The first simply looks up the included file and inserts the file contents, while
    the second looks up the variable name in the context dictionary (which was loaded
    from `json` in the `__init__` method), defaulting to an empty string if it doesn't
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three methods that deal with looping are a bit more intense, as they have
    to share state between the three of them. For simplicity (I''m sure you''re eager
    to see the end of this long chapter—we''re almost there!), we''ll handle this
    case using instance variables on the class itself. As an exercise, you might want
    to consider better ways to architect this, especially after reading the next three
    chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: When we encounter the `loopover` directive, we don't have to output anything,
    but we do have to set the initial state on three variables. The `loop_list` variable
    is assumed to be a list pulled from the context dictionary. The `loop_index` variable
    indicates which position in that list should be output in this iteration of the
    loop, while `loop_pos` is stored so we know where to jump back to when we get
    to the end of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `loopvar` directive outputs the value at the current position in the `loop_list`
    variable and skips to the end of the directive. Note that it doesn't increment
    the loop index, because the `loopvar` directive could be called multiple times
    inside a loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `endloop` directive is more complicated. It determines whether there are
    more elements in the `loop_list`; if there are, it just jumps back to the start
    of the loop, incrementing the index. Otherwise, it resets all the variables that
    were being used to process the loop and jumps to the end of the directive so the
    engine can carry on with the next match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this particular looping mechanism is very fragile; if a template
    designer were to try nesting loops or to forget an `endloop` call, it would go
    poorly for them. We would need a lot more error checking and would probably want
    to store more loop state to make this a production platform. But I promised that
    the end of the chapter was nigh, so let''s just head to the exercises, after seeing
    how our sample template is rendered with its context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: There are some weird newline effects due to the way we planned our template,
    but it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a wide variety of topics in this chapter, from strings to regular
    expressions, to object serialization, and back again. Now it's time to consider
    how these ideas can be applied to your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Python strings are very flexible, and Python is an extremely powerful tool for
    string-based manipulations. If you don't do a lot of string processing in your
    daily work, try designing a tool that is exclusively intended for manipulating
    strings. Try to come up with something innovative, but if you're stuck, consider
    writing a web log analyzer (how many requests per hour? How many people visit
    more than five pages?) or a template tool that replaces certain variable names
    with the contents of other files.
  prefs: []
  type: TYPE_NORMAL
- en: Spend a lot of time toying with the string formatting operators until you've
    got the syntax memorized. Write a bunch of template strings and objects to pass
    into the format function, and see what kind of output you get. Try the exotic
    formatting operators, such as percentage or hexadecimal notation. Try out the
    fill and alignment operators, and see how they behave differently for integers,
    strings, and floats. Consider writing a class of your own that has a `__format__`
    method; we didn't discuss this in detail, but explore just how much you can customize
    formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you understand the difference between `bytes` and `str` objects. The
    distinction is very complicated in older versions of Python (there was no `bytes`,
    and `str` acted like both `bytes` and `str` unless we needed non-ASCII characters,
    in which case there was a separate `unicode` object, which was similar to Python
    3's `str` class. It's even more confusing than it sounds!). It's clearer nowadays;
    `bytes` is for binary data, and `str` is for character data. The only tricky part
    is knowing how and when to convert between the two. For practice, try writing
    text data to a file opened for writing `bytes` (you'll have to encode the text
    yourself), and then reading from the same file.
  prefs: []
  type: TYPE_NORMAL
- en: Do some experimenting with `bytearray`. See how it can act both like a `bytes`
    object and a list or container object at the same time. Try writing to a buffer
    that holds data in the bytes array until it is a certain length before returning
    it. You can simulate the code that puts data into the buffer by using `time.sleep`
    calls to ensure data doesn't arrive too quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Study regular expressions online. Study them some more. Especially learn about
    named groups, greedy versus lazy matching, and regex flags, three features that
    we didn't cover in this chapter. Make conscious decisions about when not to use
    them. Many people have very strong opinions about regular expressions and either
    overuse them or refuse to use them at all. Try to convince yourself to use them
    only when appropriate, and figure out when that is.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve ever written an adapter to load small amounts of data from a file
    or database and convert it to an object, consider using a pickle instead. Pickles
    are not efficient for storing massive amounts of data, but they can be useful
    for loading configuration or other simple objects. Try coding it multiple ways:
    using a pickle, a text file, or a small database. Which do you find easiest to
    work with?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try experimenting with pickling data, then modifying the class that holds the
    data, and loading the pickle into the new class. What works? What doesn''t? Is
    there a way to make drastic changes to a class, such as renaming an attribute
    or splitting it into two new attributes and still get the data out of an older
    pickle? (Hint: try placing a private pickle version number on each object and
    update it each time you change the class; you can then put a migration path in
    `__setstate__`.)'
  prefs: []
  type: TYPE_NORMAL
- en: If you do any web development at all, do some experimenting with the JSON serializer.
    Personally, I prefer to serialize only standard JSON serializable objects, rather
    than writing custom encoders or `object_hooks`, but the desired effect really
    depends on the interaction between the frontend (JavaScript, typically) and backend
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Create some new directives in the templating engine that take more than one
    or an arbitrary number of arguments. You might need to modify the regular expression
    or add new ones. Have a look at the Django project's online documentation, and
    see whether there are any other template tags you'd like to work with. Try mimicking
    their filter syntax instead of using the `variable` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Revisit this chapter when you've studied iteration and coroutines and see whether
    you can come up with a more compact way of representing the state between related
    directives, such as the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered string manipulation, regular expressions, and object serialization
    in this chapter. Hardcoded strings and program variables can be combined into
    outputtable strings using the powerful string formatting system. It is important
    to distinguish between binary and textual data, and `bytes` and `str` have specific
    purposes that must be understood. Both are immutable, but the `bytearray` type
    can be used when manipulating bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are a complex topic, and we only scratched the surface.
    There are many ways to serialize Python data; pickles and JSON are two of the
    most popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll look at a design pattern that is so fundamental
    to Python programming that it has been given special syntax support: the iterator
    pattern.'
  prefs: []
  type: TYPE_NORMAL
