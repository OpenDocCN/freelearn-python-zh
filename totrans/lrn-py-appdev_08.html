<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Improving Performance – Part One</h1></div></div></div><p>Let's recap what you learned in the previous chapter. We started with a program that appeared harmless until some parameters were tweaked. This change revealed performance issues. Hence, we performed a <em>search operation</em> (profiling) to catch the <em>culprits</em> (the bottlenecks). Now, let's see what we can do to speed up the application code. To be specific, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cutting down the runtime of the <em>Gold Hunt</em> application</li><li class="listitem" style="list-style-type: disc">Learning to improve the application performance using the following ways:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Making changes to the algorithm</li><li class="listitem" style="list-style-type: disc">Avoiding the function re-evaluation</li><li class="listitem" style="list-style-type: disc">Using the list and dictionary comprehensions</li><li class="listitem" style="list-style-type: disc">Using generator expressions</li><li class="listitem" style="list-style-type: disc">Using tricks to improve the performance of code involving loops</li><li class="listitem" style="list-style-type: disc">Choosing the right data structures</li><li class="listitem" style="list-style-type: disc">Discussing the <code class="literal">collections</code> and <code class="literal">itertools</code> modules briefly</li></ul></div></li></ul></div><p>In summary, this chapter will cover several (but not all) techniques to speed up the application. Some of these can be directly applied to alleviate the performance problems of the <em>Gold Hunt</em> scenario from the previous chapter. For the rest, we will use generic examples to illustrate the efficacy of those techniques.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Prerequisite for the chapter</h1></div></div></div><p>Have you already read <a class="link" href="ch07.html" title="Chapter 7. Performance – Identifying Bottlenecks">Chapter 7</a>, <em>Performance – Identifying Bottlenecks</em>? It teaches you how to identify the performance bottlenecks. A part of this chapter uses the same problem that was discussed in the previous chapter and gradually improves its performance. Also, in this chapter, it is assumed that you already know how to profile the code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec69"/>This is how the chapter is organized</h1></div></div></div><p>We will start with first part of the performance improvements for the <em>Gold Hunt</em> scenario. The aim is to provide you with a practical example of how to approach the problem and gradually cut down the runtime. The following chart shows a preview of what will be accomplished by the end of this chapter—this is the same chart shown in the previous chapter. The application runtime is about to be cut down by more than 50%!</p><div><img src="img/B05034_08_33.png.jpg" alt="This is how the chapter is organized"/></div><p>The second half of this book will show you many ways to improve the application speed. For this discussion, we will use generic examples, as not all techniques can be applied directly to the <em>Gold Hunt</em> scenario. The second half will serve as a handy reference for performance improvements.</p><div><div><h3 class="title"><a id="tip81"/>Tip</h3><p>The Python wiki has documented several performance improvement tips. Some of these will be covered here. Refer to <a class="ulink" href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips">https://wiki.python.org/moin/PythonSpeed/PerformanceTips</a> for further details.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Revisiting the Gold Hunt scenario</h1></div></div></div><p>At this point, you <a id="id600" class="indexterm"/>should go back to <a class="link" href="ch07.html" title="Chapter 7. Performance – Identifying Bottlenecks">Chapter 7</a>, <em>Performance – Identifying Bottlenecks</em>, and refresh your memory on the <em>Gold Hunt</em> scenario. To summarize the problem, a circular field has gold coins scattered all over and you need to pick as many coins as you can while traveling across the field. However, you can only pick the coins lying inside the small search circles. We wrote an application code and discussed how tweaking the <code class="literal">search_radius</code> and <code class="literal">field_coins</code> (total scattered coins) parameters impact the performance. In the upcoming discussion, we will gradually improve the performance of this code.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec143"/>Selecting a problem size</h2></div></div></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>In order to </em>
<a id="id601" class="indexterm"/>
<em>see a real difference in the timing after optimizing the code, let's increase the problem size further. In the previous chapter, <strong>The Great Dwarf</strong> wanted us to put one million coins on the field. <strong>Let's double the deal</strong>. Now, there are <strong>two million</strong> gold coins up for grabs! In short, </em><code class="literal">search_radius</code><em> and </em><code class="literal">field_coins</code><em> will be set to </em><code class="literal">0.1</code><em> and </em><code class="literal">2000000</code><em>, respectively.</em></p>
</td></tr></tbody></table></div><div><div><h3 class="title"><a id="tip82"/>Tip</h3><p>
<strong>Caution! Read this before running any example</strong>
</p><p>Running the examples in this chapter can consume a lot of computational resources (the sample output will be shown in this chapter so you don't have to run these). The <code class="literal">goldhunt_0.py</code> file, for instance, takes nearly two minutes to complete on a 64 bit Linux machine with an 8 GB RAM and a good processor with only a few running tasks. It also consumes quite a bit of memory during the execution. The performance is not that bad for this system configuration. In general, it will depend on the specifications of your machine. So, be careful! One strategy is to set <code class="literal">field_coins=5000</code> and <code class="literal">search_radius=1</code> and see how well the application runs. Then, progressively tweak these parameters to an acceptable configuration.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec144"/>Profiling the initial code</h2></div></div></div><p>We will start with the <a id="id602" class="indexterm"/>source <code class="literal">goldhunt_0.py</code> file (see the supporting code for the chapter). This is same as <code class="literal">goldhunt_inefficient.py</code> except for the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It profiles the game execution using <code class="literal">cProfile</code> and prints the statistics. Thus, it also includes the functions from the <code class="literal">profiling_goldhunt.py module</code>. Although combining these two modules is not the best practice, it will help simplify the upcoming illustrations.</li><li class="listitem" style="list-style-type: disc">The updated <code class="literal">play_game()</code> function <a id="id603" class="indexterm"/>is shown next. It uses the new parameter values, as shown:<div><img src="img/B05034_08_03.png.jpg" alt="Profiling the initial code"/></div></li></ul></div><p>The code can be run as follows—if necessary, tweak the input arguments to <code class="literal">GoldHunt()</code>:</p><div><pre class="programlisting">
<strong>$ python goldhunt_0.py</strong>
</pre></div><p>The following screenshot shows the profiling statistics for this run:</p><div><img src="img/B05034_08_04.png.jpg" alt="Profiling the initial code"/></div><p>Notice that <code class="literal">find_coins</code> eats up a significant amount of time. The next on the list is <code class="literal">generate_random_points</code>. Let's see what we can do to improve the performance.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Optimizing Gold Hunt – Part one</h1></div></div></div><p>It is time for some action. This section is organized in the following manner—you will learn some techniques to optimize the code and speedup the application. These techniques will be directly applied to improve the performance of the <em>Gold Hunt</em> game.</p><p>This is the first part of<a id="id604" class="indexterm"/> the optimization task. Here, the performance will be improved in three steps. We will call these <em>optimization pass one</em>, <em>pass two</em>, and <em>pass three</em>. After implementing each of these strategies, the code will be re-profiled to get an understanding of the speedup accomplished. Let's get started with <em>optimization pass one</em>.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec145"/>Tweaking the algorithm – The square root</h2></div></div></div><p>The profiling output (refer to the <em>Profiling the initial code</em> section) shows the <code class="literal">find_distance</code> method as the bottleneck. As a starter, let's make some changes to this algorithm so that it runs faster. Here is the original method that was presented in the <em>Reviewing the initial code</em> section in <a class="link" href="ch07.html" title="Chapter 7. Performance – Identifying Bottlenecks">Chapter 7</a>, <em>Performance – Identifying Bottlenecks</em>:</p><div><img src="img/B05034_08_05.png.jpg" alt="Tweaking the algorithm – The square root"/></div><p>The method computes the distance to each gold coin from the center of the search circle and determines whether or not the given gold coin lies inside the search circle. The computed distance, denoted by <code class="literal">dist</code>, is a square root.</p><p>Do we really need to compute a square root? The square root computation<a id="id605" class="indexterm"/> is time consuming and in this case unnecessary. All we are doing is just comparing two numbers. Can we avoid that by comparing the square of two numbers instead? Confused? Have a look at the following comparison:</p><div><img src="img/B05034_08_06.png.jpg" alt="Tweaking the algorithm – The square root"/></div><p>We have two positive <a id="id606" class="indexterm"/>numbers, <em>a=4</em> and <em>b=9</em>. Obviously, <em>a</em> is smaller than <em>b</em>. So, the comparison <em>a &lt; b</em> will always return <code class="literal">true</code>. This is applicable even for the comparison of their square roots. The same logic can be applied to our problem. The <code class="literal">dist</code> and <code class="literal">self.search_radius</code> variables can be considered as square roots of two numbers. We have got the following code:</p><div><pre class="programlisting">dist = math.sqrt(delta_x*delta_x + delta_y*delta_y)</pre></div><p>Or, we can say <code class="literal">dist</code> is the square root of some number, <code class="literal">dist_square</code>, given as follows:</p><div><pre class="programlisting">dist_square = delta_x*delta_x + delta_y*delta_y</pre></div><p>Next, we already know the value of <code class="literal">self.search_radius</code>. Now, imagine it as a square root of another number, <code class="literal">search_radius_square</code>. This number is not already available, and it needs to be computed as follows:</p><div><pre class="programlisting">search_radius_square = self.search_radius*self.search_radius</pre></div><p>As the last step, we will need to compare these two numbers instead of their square roots:</p><div><pre class="programlisting">if dist_square &lt;= search_radius_square: 
    # more code follows...</pre></div><div><img src="img/B05034_08_07.png.jpg" alt="Tweaking the algorithm – The square root"/></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>That's a good observation! It requires us to do an extra computation to find out the square of </em>
<code class="literal">self.search_radius</code><em>. But, we do not need to compute that for every iteration inside the </em>
<code class="literal">for</code><em> loop. The </em>
<code class="literal">self.search_radius</code> <em>does not change inside the loop. So, this computation can be done just once before the </em>
<code class="literal">for</code><em> loop.</em>
</p>
</td></tr></tbody></table></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec71"/>Gold Hunt optimization – Pass one</h3></div></div></div><p>Putting it all together, the updated <code class="literal">find_coins</code> method<a id="id607" class="indexterm"/> is shown next:</p><div><img src="img/B05034_08_08.png.jpg" alt="Gold Hunt optimization – Pass one"/></div><p>It is now time to profile this code again and see if we get any improvement in the performance. The supporting source file, <code class="literal">goldhunt_pass1.py</code>, has these changes incorporated. It can be run as follows:</p><div><pre class="programlisting">
<strong>$ python goldhunt_pass1.py </strong>
</pre></div><p>The following screenshot shows the profiling statistics for this run:</p><div><img src="img/B05034_08_09.png.jpg" alt="Gold Hunt optimization – Pass one"/></div><p>Compare the timings with that of the original code. There is a significant improvement in the application's<a id="id608" class="indexterm"/> runtime. Earlier, the total runtime was more than 100 seconds, but this optimization has brought it down to less than 60 seconds! You can also compare the first row in the output (<code class="literal">find_coins</code>) against the original timings. The timings noted by the profiler will depend on the machine specifications and the input values chosen.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>The timings will vary slightly even if you run the same program again. There are two reasons behind this; first, we are distributing the gold coins randomly on the field. As a result, for each run, there will be a variation in the total number of coins appended to the list. The second factor that influences this is the other running processes on your system. Ideally, you should run it under the same environment to reduce these variations (or <em>noise</em>). For example, close other running applications so that they don't interfere with the timing. During the performance benchmarking process, quite often, the same application is run multiple times and an average time is noted to reduce the effect of these variations.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec146"/>Skipping the dots</h2></div></div></div><p>The <strong>dot</strong> notation<a id="id609" class="indexterm"/> in Python enables access to the attributes of the given object. Take a look at the following code from the previous example. This is taken from the <code class="literal">for</code> loop of the <code class="literal">find_coins</code> method:</p><div><pre class="programlisting">for x, y in zip(x_list, y_list):
    # Some code follows...
    # ...
    if dist_square &lt;= search_radius_square: 
        collected_coins.append((x, y))</pre></div><p>In this loop, for every iteration, the <code class="literal">collected_coins.append</code> function is re-evaluated. Recall that in <a class="link" href="ch06.html" title="Chapter 6. Design Patterns">Chapter 6</a>, <em>Design Patterns</em>, you learned about the first-class functions. Let's represent <code class="literal">collected_coins.append</code> with a local function. This avoids the function re-evaluation (skips the dots) and will help speed up the loop.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec72"/>Gold Hunt optimization – Pass two</h3></div></div></div><p>In pass two, we will<a id="id610" class="indexterm"/> improve the code from the earlier pass (<em>optimization pass one</em>). The <code class="literal">goldhunt_pass2.py</code> file in the supporting code bundle incorporates all the changes to be discussed next. Here is the modified <code class="literal">find_coins</code> method:</p><div><img src="img/B05034_08_10.png.jpg" alt="Gold Hunt optimization – Pass two"/></div><p>Here, a local function called <code class="literal">append_coins_function</code> is assigned to the built-in <code class="literal">append</code> function of a Python <code class="literal">list</code>. This avoids the re-evaluation of the <code class="literal">append</code> function. Similarly, <code class="literal">self.xref</code> and <code class="literal">self.yref</code> are represented with local variables. Let's profile this new code and see if we get any improvements. The command is as follows:</p><div><pre class="programlisting">
<strong>$ python goldhunt_pass2.py </strong>
</pre></div><div><img src="img/B05034_08_11.png.jpg" alt="Gold Hunt optimization – Pass two"/></div><p>There is an improvement<a id="id611" class="indexterm"/> in the performance, but the results are not as impressive as the first pass of the optimization. It is still a reasonable improvement of about 10 seconds or more than 15%.</p><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>You can make similar changes elsewhere in the code, but before you jump the gun, Sir Foo has an important message for you.</em>
</p>
</td></tr></tbody></table></div><div><img src="img/B05034_08_12.png.jpg" alt="Gold Hunt optimization – Pass two"/></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>That is an excellent point! Care should be taken while adopting such techniques. You should document the code or define a project-specific coding convention so that the local functions clearly stand out. This will help other developers understand the purpose of such assignments. More generally, do not overdo it and see if there is a real benefit.</em>
</p>
</td></tr></tbody></table></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec147"/>Using local scope</h2></div></div></div><p>While looking for a <a id="id612" class="indexterm"/>variable or a function definition, Python first searches the following <strong>namespaces</strong>
<a id="id613" class="indexterm"/> in that order: <strong>local</strong>, <strong>global</strong>, and <strong>built-in</strong>. In simpler terms, it first looks for local variables or functions, then performs the search at the module level, and if nothing can be found, it looks for a built-in function or variable name. So, the look up for local variables or functions is the fastest. Using a local function in place of a global or built-in function may help improve the performance. The amount of speedup you get will depend on the problem.</p><p>Let's review the <code class="literal">generate_random_points</code> function. The original code is shown next. Refer to the <em>Reviewing the initial code</em> section in <a class="link" href="ch07.html" title="Chapter 7. Performance – Identifying Bottlenecks">Chapter 7</a>, <em>Performance – Identifying Bottlenecks</em>, where it was explained.</p><div><img src="img/B05034_08_13.png.jpg" alt="Using local scope"/></div><p>In the original function, we are calling various functions of the built-in modules, <code class="literal">random</code> and <code class="literal">math</code>. Let's update <code class="literal">generate_random_points</code> in the next optimization pass.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec73"/>Gold Hunt optimization – Pass three</h3></div></div></div><p>Let's go further into the <a id="id614" class="indexterm"/>optimization process. We will replace the built-in function calls in the <code class="literal">generate_random_points</code> function with local ones. The reworked code is shown next. Here, the <code class="literal">l_uniform</code> variable represents the <code class="literal">random.uniform</code> function. Likewise, you can see the other assignments in this code snippet.</p><div><img src="img/B05034_08_14.png.jpg" alt="Gold Hunt optimization – Pass three"/></div><div><div><h3 class="title"><a id="tip83"/>Tip</h3><p>The optimization accomplished after this step is a combination of using local scope and skipping the dots. As an exercise, you can try to separate these components. For example, to avoid using dots, at the top of the module, import <code class="literal">pi</code>, <code class="literal">cos</code> and other symbols, and directly use them in the function. Then compare the performance with and without the use of local functions.</p><p>Also, before implementing such a code, ask yourself a few questions: By using local scope, is the code quality getting compromised (is it harder to read and maintain)? Does the final performance improvement outweigh all other factors?</p></div></div><p>You can also <a id="id615" class="indexterm"/>find this code in <code class="literal">goldhunt_pass3.py</code>. The following is the <code class="literal">cProfile</code> output for this file. There is only a minor improvement in the overall timing. The real difference will be noticeable if you compare the second row of the list (<code class="literal">generate_random_points</code>) with the corresponding output of <em>optimization pass two</em>:</p><div><img src="img/B05034_08_15.png.jpg" alt="Gold Hunt optimization – Pass three"/></div><p>The total runtime has <a id="id616" class="indexterm"/>been reduced to ~2.6 seconds from an initial ~ 3.2 seconds. Increasing the problem size (number of coins) could make this difference further noticeable.</p><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>But it looks like someone is not quite impressed with the speedup...</em>
</p>
</td></tr></tbody></table></div><div><img src="img/B05034_08_16.png.jpg" alt="Gold Hunt optimization – Pass three"/></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>Absolutely! The task to improve the <strong>Gold Hunt</strong> game performance is far from over! Before we do that, let's discuss some other techniques that help speed up the application. We will use generic examples as many of these techniques are not relevant in the context of the previously mentioned game scenario.</em>
</p>
<p>
<em>In the next chapter, we will revisit the <strong>Gold Hunt</strong> problem and speed up the application further using NumPy and parallelization. It will be a drastic improvement in the performance. If you do not want to break the continuity, read the next chapter first and then come back here for the rest of the discussion.</em>
</p>
</td></tr></tbody></table></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Performance improvement goodies</h1></div></div></div><p>Let's spend some time <a id="id617" class="indexterm"/>discussing miscellaneous tips and <a id="id618" class="indexterm"/>tricks that help improve the runtime performance of the code. You can still apply a few of these techniques to the <em>Gold Hunt</em> problem, but let's just use generic examples to explain these concepts.</p><div><div><h3 class="title"><a id="tip84"/>Tip</h3><p>All the illustrations in this section can be found in the supporting file, <code class="literal">misc_performance.py</code>. To compare the performance, we will use the <code class="literal">timeit</code> module that was discussed in <a class="link" href="ch07.html" title="Chapter 7. Performance – Identifying Bottlenecks">Chapter 7</a>, <em>Performance – Identifying Bottlenecks</em> (refer to the <em>Measuring runtime of small code snippets</em> section). See also the<a id="id619" class="indexterm"/> <code class="literal">timeit</code> documentation, <a class="ulink" href="https://docs.python.org/3/library/timeit.html">https://docs.python.org/3/library/timeit.html</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec148"/>List comprehension</h2></div></div></div><p>
<strong>List comprehension</strong>
<a id="id620" class="indexterm"/> is a compact way <a id="id621" class="indexterm"/>of creating a Python <code class="literal">list</code>. It is often used to replace the nested <code class="literal">for</code> loops or the <code class="literal">map</code> and <code class="literal">filter</code> functionality. Besides being compact, it is also efficient compared to, for instance, an equivalent <code class="literal">for</code> loop. The basic syntax is as follows:</p><div><pre class="programlisting">a = [i*i for i in range(5)] </pre></div><p>This creates a list with elements: <code class="literal">[0, 1, 4, 9, 16]</code>
</p><p>The preceding syntax is equivalent to the following:</p><div><pre class="programlisting">mylist = []
for i in range(5):
    mylist.append(i*i)</pre></div><p>Let's wrap these code blocks in two functions. We will measure the performance of each function using the <code class="literal">timeit</code> module. The previously mentioned file, <code class="literal">misc_performance.py</code>, also has these functions. To get a better idea of the performance gain, we will select a larger problem size. As noted a few times earlier in this book, select a problem size depending on what your machine can comfortably handle. </p><p>The following code fragment shows these functions:</p><div><img src="img/B05034_08_17.png.jpg" alt="List comprehension"/></div><p>The <code class="literal">sample_size_1</code> variable <a id="id622" class="indexterm"/>is chosen sufficiently large to see a difference. The runtime is captured using the <code class="literal">timeit.timeit</code> method, whose first argument is a string representing the function name. The second argument is a <code class="literal">setup</code> parameter that tells us where to look for this function. The runtime performance can be compared by executing the script, as:</p><div><pre class="programlisting">
<strong>$ python misc_preformance.py</strong>
</pre></div><p>As can be seen from the following output, the list comprehension is faster compared to an equivalent <code class="literal">for</code> loop:</p><div><pre class="programlisting">Without list comprehension : 1.218718248004734 
With list comprehension    : 0.8486306999984663 </pre></div><div><div><h3 class="title"><a id="tip85"/>Tip</h3><p>As an exercise, try comparing the timings of a nested <code class="literal">for</code> loop and an equivalent list comprehension syntax. Refer to the <code class="literal">list_comprehension_ex2</code> function in the <code class="literal">misc_performance.py</code> file.</p></div></div><p>In the <em>Gold Hunt</em> problem, it is also possible to use list comprehension in the <code class="literal">generate_random_points</code> function. For example, you can optionally write <code class="literal">theta</code> as follows:</p><div><pre class="programlisting">theta = [random.uniform(0.0, 2*math.pi) 
         for i in range(total_points)] </pre></div><p>But before making<a id="id623" class="indexterm"/> such changes, read the next chapter, which shows how the NumPy package drastically improves the performance of this function.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec149"/>Recording execution time</h2></div></div></div><p>In the previous<a id="id624" class="indexterm"/> section, we used the <code class="literal">timeit.timeit</code> function to record and compare the performance of list comprehension against a classical <code class="literal">for</code> loop. Let's wrap the <code class="literal">timeit</code> code into a utility function so that we can reuse it for the rest of the discussion. The <code class="literal">run_timeit</code> function is shown next:</p><div><img src="img/B05034_08_18.png.jpg" alt="Recording execution time"/></div><p>Here, <code class="literal">func_1</code> and <code class="literal">func_2</code> are the function names (strings) whose execution time needs to be recorded. The <code class="literal">number</code> argument in the <code class="literal">timeit.timeit</code> function indicates the number of times the given function is executed. The callers of <code class="literal">run_timeit</code> can tune this number by using the optional <code class="literal">num</code> argument. See the documentation for further details.</p><div><div><h3 class="title"><a id="tip86"/>Tip</h3><p>This function does not do any error checking. As an exercise, you can add that capability. For example, add the <code class="literal">try…except</code> clause to catch errors if the function is not found.</p></div></div><p>In the upcoming discussion, we will use <code class="literal">run_timeit</code> to compare the performance of two functionally equivalent code blocks.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec150"/>Dictionary comprehension</h2></div></div></div><p>Just like the list comprehension, a <a id="id625" class="indexterm"/>
<strong>dictionary comprehension</strong> <a id="id626" class="indexterm"/>is the syntactic construct to create a Python dictionary object. The following functions show two ways to create a dictionary. The first one (<code class="literal">no_dict_comprehension</code>) uses a <code class="literal">for</code> loop to create a dictionary, whereas the second function shows the dictionary comprehension syntax.</p><div><img src="img/B05034_08_19.png.jpg" alt="Dictionary comprehension"/></div><p>As noted in the previous section, from now onwards, we will use the <code class="literal">run_timeit</code> utility function to record timings. The <code class="literal">timeit</code> output after executing this code is shown next:</p><div><pre class="programlisting">Function: no_dict_comprehension, time: 0.14393422298599035 
Function: dict_comprehension, time: 0.13295511799515225</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec151"/>Swapping conditional block and for loops</h2></div></div></div><p>Consider the <a id="id627" class="indexterm"/>following trivial code. There is a top-level <code class="literal">for</code> loop with an <code class="literal">if…else</code> condition block. Depending on the value of the <code class="literal">num</code> variable (assume it changes), either <code class="literal">if</code> or <code class="literal">else</code> condition is executed. As before, an appropriate integer for the <code class="literal">sample_size_1</code> variable should be chosen:</p><div><img src="img/B05034_08_20.png.jpg" alt="Swapping conditional block and for loops"/></div><p>We can write the same code by swapping the <code class="literal">for</code> loop and the <code class="literal">if…else</code> block. The new function has a top-level <code class="literal">if…else</code> block. Inside each condition statement, we have the same <code class="literal">for</code> loop. The following <code class="literal">if_condition_loop_opt</code> function shows this (its output remains the same):</p><div><img src="img/B05034_08_21.png.jpg" alt="Swapping conditional block and for loops"/></div><p>Let's find out the winner<a id="id628" class="indexterm"/> between these two functions:</p><div><pre class="programlisting">Function: no_if_condition_loop_opt, time: 0.1894498920009937 
Function: if_condition_loop_opt, time   : 0.15955313100130297 </pre></div><p>To summarize, the function with a top-level <code class="literal">if…else</code> block runs faster compared to the function with a top-level <code class="literal">for</code> loop.</p><div><div><h3 class="title"><a id="tip87"/>Tip</h3><p>This was a simple example where the swapping of the <code class="literal">for</code> loop and condition blocks was easy. However, in the real world, weigh in the advantages of making such modifications over the risk of introducing bugs. Does the profiling really show this code block as a major bottleneck? If you finally decide to go ahead with it, add enough automated tests to make sure that the function output remains the <a id="id629" class="indexterm"/>same! See <a class="link" href="ch05.html" title="Chapter 5. Unit Testing and Refactoring">Chapter 5</a>, <em>Unit Testing and Refactoring</em>, to learn how to write unit tests.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec152"/>'try' it out in a loop</h2></div></div></div><p>Remember the <strong>Easier to ask for forgiveness than permission</strong>
<a id="id630" class="indexterm"/> (<strong>EAFP</strong>) principle that encourages using the <code class="literal">try…except</code> clause? It was discussed briefly in <a class="link" href="ch02.html" title="Chapter 2. Dealing with Exceptions">Chapter 2</a>, <em>Dealing with Exceptions</em>. Let's see how a <code class="literal">try…except</code> clause<a id="id631" class="indexterm"/> can save some execution time. Consider the following function, which populates a list in a <code class="literal">for</code> loop based on the value of<code class="literal"> i</code>. Only for the first iteration of the <code class="literal">for</code> loop (<code class="literal">i=0</code>), the <code class="literal">if</code> statement is executed. For all other values of <code class="literal">i</code>, it executes the <code class="literal">else</code> block, <code class="literal">val /=i</code>.</p><div><img src="img/B05034_08_22.png.jpg" alt="'try' it out in a loop"/></div><p>Let's replace the <code class="literal">if…else</code> block with a <code class="literal">try…except</code> clause. The <code class="literal">try</code> clause will always try to execute the <code class="literal">val /= i</code> statement. When we have <code class="literal">i=0</code>, it raises the <code class="literal">ZeroDivisionError</code> exception, which is handled in the <code class="literal">except</code> clause.</p><div><img src="img/B05034_08_23.png.jpg" alt="'try' it out in a loop"/></div><p>Here, we need to catch the error only for the initial value, <code class="literal">i=0</code>. For the rest of the loop, the code should run smoothly. The <code class="literal">try…except</code> clause effectively gets rid of the extra checks imposed by the <code class="literal">if…else</code> condition block. In other words, we will no longer need to check <code class="literal">if i==0</code> for each value of <code class="literal">i</code>. As a result, the code runs faster. The execution time for these functions is shown<a id="id632" class="indexterm"/> next—clearly, the <code class="literal">using_try</code> function performs better:</p><div><pre class="programlisting">Function: not_using_try, time: 0.1821241550205741 
Function: using_try, time    : 0.09502803898067214</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec153"/>Choosing the right data structures</h2></div></div></div><p>This is fairly a broad topic. The<a id="id633" class="indexterm"/> choice of data structure largely depends on the problem you are trying to solve. In this section, we will limit our discussion to just one example that shows how the right choice of data structure improves the runtime performance. Observe the <code class="literal">data_struct_choice_list</code> function; it first creates a list object, <code class="literal">mylist</code>. Next, inside a <code class="literal">for</code> loop, the code checks if <code class="literal">j</code> is one of the elements of <code class="literal">mylist</code> and updates the <code class="literal">val</code> parameter accordingly.</p><div><img src="img/B05034_08_24.png.jpg" alt="Choosing the right data structures"/></div><p>Now look at the following <code class="literal">data_struct_choice_set</code> function. Instead of a <code class="literal">list</code> object, it creates a <code class="literal">set</code> object denoted by the <code class="literal">myset</code> variable. The syntax is similar to the <code class="literal">list</code> or dictionary comprehension syntax we saw earlier (the rest of the code remains the same and both the functions return the same value).</p><div><img src="img/B05034_08_25.png.jpg" alt="Choosing the right data structures"/></div><p>When it comes to checking the membership of an element, the Python <code class="literal">set</code> is faster compared to a <code class="literal">list</code>. In other words, the "<code class="literal">if (j in myset)</code>" operation is faster compared to "<code class="literal">if (j in mylist)</code>". As summarized in a table in <a class="link" href="ch07.html" title="Chapter 7. Performance – Identifying Bottlenecks">Chapter 7</a>, <em>Performance – Identifying Bottlenecks</em>, the average-case time complexity of this operation is <em>O(1)</em> for <code class="literal">set</code> and <em>O(n)</em> for <code class="literal">list</code>. </p><p>The <code class="literal">timeit</code> output for these two functions is shown next. Clearly, the function <a id="id634" class="indexterm"/>that implements <code class="literal">set</code> is much faster compared to the one that implements <code class="literal">list</code>:</p><div><pre class="programlisting">Function: data_struct_choice_list, time: 1.7527358299994376 
Function: data_struct_choice_set, time: 0.015494994004257023</pre></div><div><div><h3 class="title"><a id="tip88"/>Tip</h3><p>Have you noticed a problem in this example? The runtime reported by <code class="literal">timeit</code> includes the time required to create the <code class="literal">list</code> and <code class="literal">set</code> objects. For an accurate comparison, you should only compare the <code class="literal">for</code> loops in these functions. In other words, move the <code class="literal">list</code> and <code class="literal">set</code> creation part out of the function definition and then do the timing comparison.</p></div></div><p>Let's continue the discussion on the data structures and review Python's <code class="literal">collections</code> module next.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec154"/>The collections module</h2></div></div></div><p>The <code class="literal">collections</code> module offers <a id="id635" class="indexterm"/>a number of special purpose container data types. Let's review a few of the common ones. If you want to know about the other data structures in this module, see the Python documentation (<a class="ulink" href="https://docs.python.org/3/library/collections.html">https://docs.python.org/3/library/collections.html</a>).</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec74"/>The deque class</h3></div></div></div><p>The <code class="literal">deque</code> class enables<a id="id636" class="indexterm"/> appending or deleting elements from either side of the <code class="literal">deque</code> data structure. The <code class="literal">append</code> and <code class="literal">pop</code> operations in <code class="literal">deque</code> class are memory efficient and thread-safe with a complexity of <em>O(1)</em>. The following code shows a simple way to create <code class="literal">deque</code> and then remove the rightmost element:</p><div><pre class="programlisting">&gt;&gt;&gt; dq = deque(range(10)) 
&gt;&gt;&gt; dq 
deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 
&gt;&gt;&gt; dq.pop() 
9 
&gt;&gt;&gt; dq 
deque([0, 1, 2, 3, 4, 5, 6, 7, 8])</pre></div><p>Let's compare the performance of <code class="literal">deque</code> with an equivalent <code class="literal">list</code>. Observe the following two functions, where we call the <code class="literal">pop()</code> method of the <code class="literal">list</code> and <code class="literal">deque</code> classes—note that we are creating the <code class="literal">list</code> and <code class="literal">deque</code> objects outside of these functions to make sure that the reported timing is not influenced by the object creation:</p><div><img src="img/B05034_08_26.png.jpg" alt="The deque class"/></div><p>The following <code class="literal">timeit</code> output shows that the <code class="literal">pop()</code> operation on <code class="literal">deque</code> is faster compared to that of <code class="literal">list</code>:</p><div><pre class="programlisting">Function: list_example, time: 0.1243858500092756 
Function: deque_example, time: 0.0937135319982189</pre></div><p>So, when should we use <code class="literal">deque</code>? In general, if your code involves a lot of operations where the data needs to be appended or popped from one of the ends, <code class="literal">deque</code> is preferred over a <code class="literal">list</code>. But, if the code needs fast random access to the elements, <code class="literal">list</code> is a better choice of data structure.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec75"/>The defaultdict class</h3></div></div></div><p>The <code class="literal">defaultdict</code> class is derived from<a id="id637" class="indexterm"/> the built-in <code class="literal">dict</code> class. If you try to access a key that doesn't exist, a simple Python dictionary throws a <code class="literal">KeyError</code> exception. But, a <code class="literal">defaultdict</code> class creates a new key instead. This can be better explained with the following example:</p><div><pre class="programlisting">&gt;&gt;&gt; d1 = {} 
&gt;&gt;&gt; d1['a'] 
Traceback (most recent call last): 
  File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
KeyError: 'a' </pre></div><p>The standard dictionary object, <code class="literal">d1</code>, doesn't have an <code class="literal">'a'</code> key, so it throws an error. If you try to access this key with a <code class="literal">defaultdict</code> class, it simply creates it, as shown in the following example:</p><div><pre class="programlisting">&gt;&gt;&gt; from collections import defaultdict 
&gt;&gt;&gt; d2 = defaultdict(int)
&gt;&gt;&gt; d2['a'] 
0 
&gt;&gt;&gt; d32
defaultdict(&lt;class 'int'&gt;, {'a': 0})</pre></div><div><div><h3 class="title"><a id="tip89"/>Tip</h3><p>The built-in <code class="literal">setdefault()</code> method of the standard dictionary does a similar job. If the key you are trying to access does not exist, it inserts a new key in the dictionary, assigns a default value to it, and returns this default. However, using <code class="literal">defaultdict</code> is faster compared to the <code class="literal">setdefault</code> method. Refer to the documentation (<a class="ulink" href="https://docs.python.org/3/library/stdtypes.html#dict">https://docs.python.org/3/library/stdtypes.html#dict</a>) for more information.</p></div></div><p>This is just one of the features offered by <code class="literal">defaultdict</code>. It also provides an efficient means to count the number of times an element occurs in a container. Let's see this with an example. The following <code class="literal">dict_counter</code> function defines a <code class="literal">list</code> called <code class="literal">game_characters</code>. There are many repeating elements in this <code class="literal">list</code>. The function uses a standard dictionary to count how many times each element occurs, and then returns this dictionary.</p><div><img src="img/B05034_08_27.png.jpg" alt="The defaultdict class"/></div><p>For example, the output of this function will be a dictionary:</p><div><pre class="programlisting">{'orc': 2000000, 'knight': 3000000, 'elf': 1000000} </pre></div><p>The <code class="literal">sample_size_1</code> is just a<a id="id638" class="indexterm"/> multiplication factor to make this list big enough to see the difference in the execution time. In this example, it is chosen as <code class="literal">100000</code>. Now, let's write a function that uses a <code class="literal">defaultdict</code> class to do the same job. Take a look at how compact the resulting code is:</p><div><img src="img/B05034_08_28.png.jpg" alt="The defaultdict class"/></div><p>Let's compare the performance of these two functions. The following <code class="literal">timeit</code> output confirms that the function implementing <code class="literal">defaultdict</code> runs faster:</p><div><pre class="programlisting">Function: dict_counter, time: 0.6270602609729394 
Function: defaultdict_counter, time: 0.4926446119789034</pre></div><p>The counting operation<a id="id639" class="indexterm"/> can also be performed using the <code class="literal">collections.Counter</code> class. The syntax is simple and efficient compared to a <code class="literal">defaultdict</code> class (we will not discuss the <code class="literal">Counter</code> class in this book). As an exercise, read the documentation and write a function that uses the <code class="literal">Counter</code> class for the earlier example.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec155"/>Generators and generator expressions</h2></div></div></div><p>A <strong>generator</strong>
<a id="id640" class="indexterm"/> is basically an iterator. It is a powerful tool to<a id="id641" class="indexterm"/> handle a very large, or an infinite data set. A generator function is written just like a regular function, but is characterized by the use of the <code class="literal">yield</code> statement. It is similar to a <code class="literal">return</code> statement, in the sense that it returns a value. However, a generator function "freezes" the current environment after it yields. So, the next time you want a value, the generator function continues from where it left off and yields the next value. </p><p>In other words, a generator returns values (say from a list) one at a time, keeps track of the current state of the iteration (remembers all the values it has returned in the previous calls), and when called again, it picks up from the position where it left off. When you add a <code class="literal">yield</code> statement to a function, it automatically becomes a generator function. Let's write a trivial example to understand this concept better:</p><div><pre class="programlisting">&gt;&gt;&gt; def get_data(): 
...     for i in range(3): 
...         yield i*i 
... 
&gt;&gt;&gt; g = get_data() 
&gt;&gt;&gt; g 
&lt;generator object get_data at 0x7f704c55fb40&gt;</pre></div><p>The <code class="literal">get_data()</code> function returns a generator object, <code class="literal">g</code>. The <code class="literal">next()</code> function is just one way of getting the values from the generator:</p><div><pre class="programlisting">&gt;&gt;&gt; next(g) 
0 </pre></div><p>For the first iteration in the <code class="literal">get_data()</code> function, we have <code class="literal">i=0</code> . So, the value returned by the generator is <code class="literal">i*i=0</code>. Now comes the interesting part. Let's call the <code class="literal">next()</code> function again:</p><div><pre class="programlisting">&gt;&gt;&gt; next(g) 
1 </pre></div><p>It returned the value as <code class="literal">1</code>. This corresponds to the next value of the iterator in the <code class="literal">get_data()</code> function, <code class="literal">i=1</code>, which makes <code class="literal">i*i=1</code>. If we call <code class="literal">next()</code> one more time, it will return the result for <code class="literal">i=2</code>, as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; next(g) 
4 </pre></div><p>This will continue <a id="id642" class="indexterm"/>until the generator is exhausted with all the values. If we call <code class="literal">next()</code> again, it raises a <code class="literal">StopIteration</code> exception, as shown next:</p><div><pre class="programlisting">&gt;&gt;&gt; next(g) 
Traceback (most recent call last): 
  File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
StopIteration </pre></div><p>Using the <code class="literal">yield</code> statement is one way<a id="id643" class="indexterm"/> of creating a generator function, and hence a generator object. Let's learn about the generator expression, which provides another way to create a generator object.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec76"/>Generator expressions</h3></div></div></div><p>The generator<a id="id644" class="indexterm"/> expression is proposed as <em>PEP 289</em> and is summarized as a high performance memory efficient generalization of list comprehension and generators.</p><div><div><h3 class="title"><a id="tip90"/>Tip</h3><p>Refer<a id="id645" class="indexterm"/> to <a class="ulink" href="https://www.python.org/dev/peps/pep-0289">https://www.python.org/dev/peps/pep-0289</a> for further details on <em>PEP 289</em>.</p></div></div><p>The basic syntax for a generator expression is similar to that of a list comprehension. Instead of square brackets <code class="literal">[]</code>, it uses the round brackets <code class="literal">()</code> to create a generator object:</p><div><pre class="programlisting">&gt;&gt;&gt; g = (i*i for i in range(3)) 
&gt;&gt;&gt; g 
&lt;generator object &lt;genexpr&gt; at 0x7f0b71b0c8b8&gt;</pre></div><p>We already saw how to use the <code class="literal">next()</code> function to get values out of a generator object. You can also get the data from a generator using a <code class="literal">for</code> loop, as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; g = (i*i for i in range(3)) 
&gt;&gt;&gt; for data in g: 
...     print(data) 
... 
0 
1 
4 </pre></div><p>Let's see a simple example where a generator expression can be used. The built-in <code class="literal">sum</code> function accepts an iterable as an input. It sums all the elements of that iterable and returns the total sum as a single value:</p><div><pre class="programlisting">&gt;&gt;&gt; g = (i*i for i in range(3)) 
&gt;&gt;&gt; sum(g) 
5</pre></div><p>Note that you can<a id="id646" class="indexterm"/> even pass a <code class="literal">list</code> to the <code class="literal">sum()</code> method to get the same result. Next, we will compare the memory efficiency of a generator expression with that of a list comprehension.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec77"/>Comparing the memory efficiency</h3></div></div></div><p>For a moderately-sized <a id="id647" class="indexterm"/>problem, the runtime performance of a list comprehension is typically better compared to an equivalent generator expression. We won't make that comparison here. Instead, we will see how the generator expression and the list comprehension compare when it comes to memory consumption.</p><p>In the previous chapter, we saw how to use the <code class="literal">memory_profiler</code> package. Let's use it here to profile the memory usage. Create a <code class="literal">compare_memory.py</code> file or download it from the supporting code bundle for this chapter. The code is shown next:</p><div><img src="img/B05034_08_29.png.jpg" alt="Comparing the memory efficiency"/></div><p>The <code class="literal">list_comp_memory</code> function creates a <code class="literal">list</code> using the list comprehension syntax. The <code class="literal">generator_expr_memory</code> function creates a generator object using the generator expression syntax. The <code class="literal">@profile</code> decorator marks the function for profiling by the memory profiler. Let's run the <code class="literal">memory_profiler</code> function on this file:</p><div><pre class="programlisting">
<strong>$ python -m memory_profiler compare_memory.py</strong>
</pre></div><p>Here is the output of this run:</p><div><img src="img/B05034_08_30.png.jpg" alt="Comparing the memory efficiency"/></div><p>Let's review the<a id="id648" class="indexterm"/> output achieved from the profiling done on the <code class="literal">compare_memory.py</code> file:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Increment</code> column indicates that the list comprehension creates a <code class="literal">list</code> and puts it in the memory. In the present example, it consumes about 0.37 MiB.</li><li class="listitem" style="list-style-type: disc">The memory profiler reports the usage in MiB. For the generator expression, it reports 0.0 MiB or interprets it as only a few bytes in this example.</li><li class="listitem" style="list-style-type: disc">If you increase the <code class="literal">sample_size</code> variable further, the memory consumed by the list comprehension will increase accordingly.</li><li class="listitem" style="list-style-type: disc">For a very large <code class="literal">sample_size</code>, your computer may even choke while creating the <code class="literal">list</code> with the list comprehension.</li><li class="listitem" style="list-style-type: disc">With the generator expression, the memory consumed will remain constant, no matter how large the data size gets. This is an extremely useful feature when operating on a very large or an infinite data set.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec78"/>Generator expressions or list comprehensions?</h3></div></div></div><div><img src="img/B05034_08_31.png.jpg" alt="Generator expressions or list comprehensions?"/></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>Good question. How to decide between generator expressions and list comprehensions? The choice depends on the type of problem you are dealing with. The following points should help you make that decision:</em>
</p>
</td></tr></tbody></table></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use generator expressions when you are working with a very large (or infinite) data set, iterated over only once. The list comprehension puts the whole list in the memory, which works fine on small or mid-sized data sets. However, as the data size grows bigger, you will notice problems. The generator expression, on the other hand, uses constant memory. It returns data on the fly. Once the data is generated, the memory is freed.</li><li class="listitem" style="list-style-type: disc">This is really another way to put the first point. Do not use generator expressions if you want to loop over the whole data set several times. In such cases, use the list comprehension.</li><li class="listitem" style="list-style-type: disc">Generator expressions do not support list operations such as <a id="id649" class="indexterm"/><strong>slicing</strong>. So, if you want to perform such operations, use the list comprehension.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec156"/>The itertools module</h2></div></div></div><p>Now that we know how the <a id="id650" class="indexterm"/>generator <a id="id651" class="indexterm"/>expressions work, let's briefly review <code class="literal">itertools</code>, another important built-in module in Python. It provides functionality to create iterators for efficient looping. The <code class="literal">itertools</code> module offers several building blocks for iterators. Some of the frequently used iterators include <code class="literal">count()</code>, <code class="literal">repeat()</code>, <code class="literal">chain()</code>, <code class="literal">groupBy()</code>, <code class="literal">tee()</code>, <code class="literal">product()</code>, <code class="literal">permutation()</code>, <code class="literal">combination()</code>, and so on. This is just a partial list of the supported functionality. In this chapter, we will only review the <code class="literal">chain()</code> iterator.</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>Refer to <a class="ulink" href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a> for information on other <a id="id652" class="indexterm"/>iterators offered by the <code class="literal">itertools</code> module.</p></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec79"/>The itertools.chain iterator</h3></div></div></div><p>This iterator is used to chain <a id="id653" class="indexterm"/>multiple iterators together. It can take lists, tuples, generators, or even a combination of these iterators as an input. Let's review a simple example that shows how to create a <code class="literal">chain</code> object:</p><div><pre class="programlisting">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; mylist_1 = [1, 2, 3] 
&gt;&gt;&gt; mytuple = ('x', 'y') 
&gt;&gt;&gt; mylist_2 = [10, 20] 
&gt;&gt;&gt; mychain = chain(mylist_1, mytuple, mylist_2) 
&gt;&gt;&gt; mychain 
&lt;itertools.chain object at 0x7fc6fcc1c2e8&gt; </pre></div><p>The simplest way to view the contents of this <code class="literal">chain</code> object is to print it as a new <code class="literal">list</code> object:</p><div><pre class="programlisting">&gt;&gt;&gt; print(list(mychain)) 
[1, 2, 3, 'x', 'y', 10, 20]</pre></div><p>As can be seen, the <code class="literal">chain</code> iterator combined the two input lists and a tuple (or the iterators). Sometimes, you want to perform identical operations on more than one list or any other iterable data structures. The <code class="literal">chain</code> iterator enables this by combining or chaining these data structures. More importantly, it does not consume any significant amount of memory. Just like a generator, the memory consumed by a <code class="literal">chain</code> object remains constant even when the size of the data grows bigger. It is also important to note that, just like a generator, a <code class="literal">chain</code> object can be used to iterate over a given data set only once. This is illustrated by the following code:</p><div><pre class="programlisting">&gt;&gt;&gt; mychain = chain(mylist_1, mytuple, mylist_2) 
&gt;&gt;&gt; for item in mychain: 
...     print(item) 
... 
1 
2 
3 
x 
y 
10 
20 
&gt;&gt;&gt; next(chain) 
Traceback (most recent call last): 
  File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
TypeError: 'type' object is not an iterator</pre></div><p>You can compare the memory efficiency of a <code class="literal">chain</code> object with an equivalent code that combines the input lists. The code is shown next. The <code class="literal">for</code> loop in these functions is just to illustrate how the <code class="literal">chain</code> object can be used in a loop.</p><div><img src="img/B05034_08_32.png.jpg" alt="The itertools.chain iterator"/></div><p>You can also find this<a id="id654" class="indexterm"/> code in <code class="literal">compare_memory.py</code>. In this file, just add the <code class="literal">@profile</code> decorator. With this change, run the memory profiler as an exercise. The following can be observed from the memory profiler output (not shown here):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">chain</code> object consumes about 0.004 MiB memory and the consumption remains constant even after you increase the size of the input lists, <code class="literal">data_1</code>, <code class="literal">data_2</code> and <code class="literal">data_3</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">list_memory</code> function<a id="id655" class="indexterm"/> consumes nearly 0.383 MiB of memory to create the <code class="literal">mylist</code> object. The memory consumed by this function increases with the input data size.</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Exercises</h1></div></div></div><p>A few exercises were already suggested. Let's list a few of these. (Note that the solution are not provided for these exercises.):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Write a list comprehension syntax for a nested <code class="literal">for</code> loop. Compare the timings of a nested <code class="literal">for</code> loop and the list comprehension. Here is an example:<div><pre class="programlisting">x = [ i*j for i in range(4) for j in range(4)]</pre></div></li><li class="listitem" style="list-style-type: disc">Write a generator expression for the preceding list comprehension. You just need to change the outer square brackets <code class="literal">[]</code> to the round brackets <code class="literal">()</code>.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Summary</h1></div></div></div><p>In this chapter, you learned many techniques that help cut down the application's runtime. We started by improving the speed of the <em>Gold Hunt</em> application. The total time taken to run this application was improved by more than 50%—we accomplished this by changing the algorithm so that it does not need to compute the square root for distance comparison. Two more changes knocked off a few more seconds from the total execution time. We avoided the function re-evaluation (skipped the "dots") and preferred local scope for the variables over global scope. This was the end of <em>part one</em> of the performance improvement for the <em>Gold Hunt</em> program.</p><p>Moving on, the chapter taught you a number of ways that help speed up the code. It illustrated how a list comprehension does a better job compared to an equivalent <code class="literal">for</code> loop. We also saw how the choice of data structure affects the performance. The chapter further introduced us to the generator expressions that offer memory advantage over the list comprehensions. Additionally, we also briefly reviewed the functionality offered by the <code class="literal">itertools</code> and <code class="literal">collections</code> modules.</p><p>We promised <em>The Great Dwarf</em> further improvements to the application. In the next chapter, let's learn the things that will help us keep our promise!</p></div></body></html>