- en: Data Types and Object-Oriented Programming in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss data types and **object-oriented programming**
    (**OOP**) in Python. We will discuss data types including lists, dictionaries,
    tuples and sets in Python. We will also discuss OOP, it's necessity and how to
    write object-oriented code in Python for Raspberry Pi based projects (such as,
    using OOP to control appliances at home). We will discuss making use of OOP in
    a Raspberry Pi Zero project.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, a list is a data type (its documentation is available here, [https://docs.python.org/3.4/tutorial/datastructures.html#](https://docs.python.org/3.4/tutorial/datastructures.html#))
    that could be used to store elements in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics discussed in this chapter can be difficult to grasp unless used
    in practice. Any example that is represented using this notation: `>>>` indicates
    that it could be tested using the Python interpreter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list may consist of strings, objects (discussed in detail in this chapter)
    or numbers, and so on. For instance, the following are examples of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding set of examples, the `sequence` list consists of numbers between
    `1` and `6` while the `example_list` list consists of a combination of strings,
    integer, and floating-point numbers. A list is represented by square brackets
    (`[]`). Items can be added to a list separated by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since a list is an ordered sequence of elements, the elements of a list could
    be fetched by iterating through the list elements using a `for` loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since Python's loop can iterate through a sequence of elements, it fetches each
    element and assigns it to `item`. This item is printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Operations that could be performed on a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, the attributes of a data type can be retrieved using the `dir()` method.
    For example, the attributes available for the `sequence` list can be retrieved
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These attributes enable performing different operations on a list. Let's discuss
    each attribute in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Append element to list:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to add an element using the `append()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove element from list:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `remove()` method finds the first instance of the element (passed an argument)
    and removes it from the list. Let''s consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Example 2**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Example 3**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving the index of an element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `index()` method returns the position of an element in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the method returns the index of the element `5`. Since Python
    uses zero-based indexing that is the index is counted from 0 and hence the index
    of the element `5` is `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the method returns the position of the first instance of the
    element. The element `5` is located at the third position.
  prefs: []
  type: TYPE_NORMAL
- en: Popping an element from the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pop()` method enables removing an element from a specified position and
    return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `index_list` list consists of numbers between `1` and `7`.
    When the third element is popped by passing the index position `(3)` as an argument,
    the number `4` is removed from the list and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no arguments are provided for the index position, the last element is popped
    and returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the last element `(7)` was popped and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Counting the instances of an element:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `count()` method returns the number of times an element appears in a list.
    For example, the element appears twice in the list: `random_list`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Inserting element at a specific position:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `insert()` method enables adding an element at a specific position in the
    list. For example, let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the list, `Wednesday` is missing. It needs to be positioned between `Tuesday`
    and `Thursday` at position 2 (Python uses **zero based indexing** that is the
    positions/indexes of elements are counted as 0, 1, 2, and so on.). It could be
    added using insert as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Challenge to the reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding list, `Sunday` is missing. Use the `insert` attribute of lists
    to insert it at the correct position.
  prefs: []
  type: TYPE_NORMAL
- en: Extending a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two lists can be combined together using the `extend()` method. The `day_of_week`
    and `sequence` lists can be combined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists can also be combined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to add a list as an element to another list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Clearing the elements of a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the elements of a list could be deleted using the `clear()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Sorting the elements of a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The elements of a list could be sorted using the `sort()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When a list consists of a collection of strings, they are sorted in the alphabetical
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Reverse the order of elements in list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reverse()` method enables the reversing the order of the list elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Create copies of a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `copy()` method enables creating copies of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Accessing list elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The list elements could be accessed by specifying the index position of the
    `list_name[i]` element. For example, the zeroth list element of the `random_list`
    list could be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Accessing a set of elements within a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to access elements between specified indices. For example, it
    is possible to retrieve all elements between indices 2 and 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first six elements of a list could be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements of a list could be printed in the reverse order as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Every second element in the list could be fetched as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to fetch every second element after the second element
    after skipping the first two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: List membership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to check if a value is a member of a list using the `in` keyword.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this list, we could check if the number `6` is a member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let's build a simple game!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This exercise consists of two parts. In the first part, we will review building
    a list containing ten random numbers between `0` and `10`. The second part is
    a challenge to the reader. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is creating an empty list. Let''s create an empty list called
    `random_list`. An empty list can be created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be making use of Python''s `random` module ([https://docs.python.org/3/library/random.html](https://docs.python.org/3/library/random.html))
    to generate random numbers. In order to generate random numbers between `0` and
    `10`, we will make use of the `randint()` method from the `random` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s append the generated number to the list. This operation is repeated
    `10` times using a `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated list looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We discussed generating a list of random numbers. The next step is taking user
    input where we ask the user to make a guess for a number between `0` and `10`.
    If the number is a member of the list, the message `Your guess is correct` is
    printed to the screen, else, the message `Sorry! Your guess is incorrect` is printed.
    We leave the second part as a challenge to the reader. Get started with the `list_generator.py`
    code sample available for download with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A dictionary ([https://docs.python.org/3.4/tutorial/datastructures.html#dictionaries](https://docs.python.org/3.4/tutorial/datastructures.html#dictionaries))
    is a data type that is an unordered collection of key and value pairs. Each key
    in a dictionary has an associated value. An example of a dictionary is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A dictionary is created by using the braces `{}`. At the time of creation,
    new members are added to the dictionary in the following format: `key: value`
    (shown in the preceding example). In the previous example `1` and `2` are keys
    while `''Hello''` and `''World''` are the associated values. Each value added
    to a dictionary needs to have an associated key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of a dictionary do not have an order i.e. the elements cannot
    be retrieved in the order they were added. It is possible to retrieving the values
    of a dictionary by iterating through the keys. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways to print the keys or values of a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we iterate through the keys of the dictionary and
    retrieve the value using the key, `my_dict[key]`. It is also possible to retrieve
    the values using the `values()` method available with dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The keys of a dictionary can be an integer, string, or a tuple. The keys of
    a dictionary need to be unique and it is immutable, that is a key cannot be modified
    after creation. Duplicates of a key cannot be created. If a new value is added
    to an existing key, the latest value is stored in the dictionary. Let''s consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new key/value pair could be added to a dictionary as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try creating a duplicate of the key `9`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, when we try to create a duplicate, the value
    of the existing key is modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to have multiple values associated with a key. For example, as
    a list or a dictionary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries are useful in scenarios like parsing CSV files and associating
    each row with a unique key. Dictionaries are also used to encode and decode JSON data
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tuple (pronounced either like *two-ple* or *tuh-ple*) is an immutable data
    type that are ordered and separated by a comma. A tuple can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Since tuples are immutable, the value at a given index cannot be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'A tuple can consist of a number, string, or a list. Since lists are mutable,
    if a list is a member of a tuple, it can be modified. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples are especially useful in scenarios where the value cannot be modified.
    Tuples are also used to return values from a function. Let''s consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `items()` method returns a list of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A set ([https://docs.python.org/3/tutorial/datastructures.html#sets](https://docs.python.org/3/tutorial/datastructures.html#sets))
    is an unordered collection of immutable elements without duplicate entries. A
    set could be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a duplicate list to this set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Sets enable avoid duplication of entries and saving the unique entries. A single
    element can be added to a set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Sets are used to test memberships of an element among different sets. There
    are different methods that are related to membership tests. We recommend learning
    about each method using the documentation on sets (run `help(my_set)` to find
    the different methods available for membership tests).
  prefs: []
  type: TYPE_NORMAL
- en: OOP in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP is a concept that helps simplifying your code and eases application development.
    It is especially useful in reusing your code. Object-oriented code enables reusing
    your code for sensors that use the communications interface. For example, all
    sensors that are equipped with a UART port could be grouped together using object-oriented
    code.
  prefs: []
  type: TYPE_NORMAL
- en: One example of OOP is the **GPIO Zero library** ([https://www.raspberrypi.org/blog/gpio-zero-a-friendly-python-api-for-physical-computing/](https://www.raspberrypi.org/blog/gpio-zero-a-friendly-python-api-for-physical-computing/))
    used in previous chapters. In fact, everything is an object in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented code is especially helpful in collaboration with other people
    on a project. For example, you could implement a sensor driver using object-oriented
    code in Python and document its usage. This enables other developers to develop
    an application without paying attention to the nitty-gritty detail behind the
    sensor's interface. OOP provides modularity to an application that simplifies
    application development. We are going to review an example in this chapter that
    demonstrates the advantage of OOP. In this chapter, we will be making use of OOP
    to bring modularity to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the student ID card example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s revisit the ID card example from [Chapter 2](9e475135-4205-42c5-a109-cc59bfadad7d.xhtml),
    *Arithmetic Operations, Loops, and Blinky Lights* (`input_test.py`). We discussed
    writing a simple program that captures and prints the information belonging to
    a student. A student''s contact information could be retrieved and stored as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, consider a scenario where the information of 10 students has to be saved
    and retrieved at any point during program execution. We would need to come up
    with a nomenclature for the variables used to save the student information. It
    would be a clutter if we use 30 different variables to store information belonging
    to each student. This is where object oriented programming can be really helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Let's rewrite this example using OOP to simplify the problem. The first step
    in OOP is declaring a structure for the object. This is done by defining a class.
    The class determines the functions of an object. Let's write a Python class that
    defines the structure for a student object.
  prefs: []
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are going to save student information, the class is going to be called
    `Student`. A class is defined using the `class` keyword as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Thus, a class called `Student` has been defined. Whenever a new object is created,
    the method `__init__()` (the underscore indicate that the init method is a magic
    method, that is it is a function that is called by Python when an object is created)
    is called internally by Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is defined within the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the arguments to the `__init__` method include `name`, `age`
    and `address`. These arguments are called **attributes**. These attributes enable
    creating a unique object that belongs to the `Student` class. Hence, in this example,
    while creating an instance of the `Student` class, the attributes `name`, `age`,
    and `address` are required arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an object (also called an instance) belonging to the `Student`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created an object belonging to the `Student` class called
    `student1` where `John Doe` (name), `29` (age) and `123 Main Street, Newark, CA`(address)
    are attributes required to create an object. When we create an object that belongs
    to the `Student` class by passing the requisite arguments (declared earlier in
    the `__init__()` method of the `Student` class), the `__init__()` method is automatically
    called to initialize the object. Upon initialization, the information related
    to `student1` is stored under the object `student1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the information belonging to `student1` could be retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create another object called `student2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We created two objects called `student1` and `student2`. Each object's attributes
    are accessible as `student1.name`, `student2.name` and so on. In the absence of
    object oriented programming, we will have to create variables like `student1_name`,
    `student1_age`, `student1_address`, `student2_name`, `student2_age` and `student2_address`
    and so on. Thus, OOP enables modularizing the code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods to a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add some methods to our `Student` class that would help retrieve a student''s
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have added three methods namely `return_name()`, `return_age()`
    and `return_address()` that returns the attributes `name`, `age` and `address`
    respectively. These methods of a class are called **callable attributes**. Let's
    review a quick example where we make use of these callable attributes to print
    an object's information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we discussed methods that retrieves information about a student. Let''s
    include a method in our class that enables updating information belonging to a
    student. Now, let''s add another method to the class that enables updating address
    by a student:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare the `student1` object''s address before and after updating the
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This would print the following output to your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we have written our first object-oriented code that demonstrates the ability
    to modularize the code. The preceding code sample is available for download along
    with this chapter as `student_info.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Doc strings in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the object oriented example, you might have noticed a sentence enclosed
    in triple double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This is called a **doc string**. The doc string is used to document information
    about a class or a method. Doc strings are especially helpful while trying to
    store information related to the usage of a method or a class (this will be demonstrated
    later in this chapter). Doc strings are also used at the beginning of a file to
    store multi-line comments related to an application or a code sample. Doc strings
    are ignored by the Python interpreter and they are meant to provide documentation
    about a class to fellow programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the Python interpreter ignores any single line comment that starts
    with a `#` sign. Single line comments are generally used to make a specific note
    on a block of code. The practice of including well-structured comments makes your
    code readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code snippet informs the reader that a random number
    between `0` and `9` is generated and stored in the variable `rand_num`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'On the contrary, a comment that provides no context is going to confuse someone
    who is reviewing your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: It is quite possible that you may not be able to recall what needs fixing when
    you revisit the code later.
  prefs: []
  type: TYPE_NORMAL
- en: self
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our object-oriented example, the first argument to every method had an argument
    called `self`. `self` refers to the instance of the class in use and the `self`
    keyword is used as the first argument in methods that interact with the instances
    of the class. In the preceding example, `self` refers to the object `student1`.
    It is equivalent to initializing an object and accessing it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `self` keyword simplifies how we access an object's attributes in this case.
    Now, let's review some examples where we make use of OOP involving the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Speaker controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write a Python class (`tone_player.py` in downloads) that plays a musical
    tone indicating that the boot-up of your Raspberry Pi is complete. For this section,
    you will need a USB sound card and a speaker interfaced to the USB hub of the
    Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call our class `TonePlayer`. This class should be capable of controlling
    the speaker volume and playing any file passed as an argument while creating an
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the file that has to be played by the `TonePlayer` class has
    to be passed an argument. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to be able to set the volume level at which the tone has to be
    played. Let''s add a method to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the `set_volume` method, we make use of Python's `subprocess` module to run
    the Linux system command that adjusts the sound drive volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most essential method for this class is the `play` command. When the `play`
    method is called, we need to play the tone sound using Linux''s a `play` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Put it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Save the `TonePlayer` class to your Raspberry Pi (save it to a file called `tone_player.py`)
    and use a tone sound file from sources like *freesound* ([https://www.freesound.org/people/zippi1/sounds/18872/](https://www.freesound.org/people/zippi1/sounds/18872/)).
    Save it to a location of your choice and try running the code. It should play
    the tone sound at the desired volume!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, edit `/etc/rc.local` and add the following line to the end of the file
    (right before the `exit 0` line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This should play a tone whenever the Pi boots up!
  prefs: []
  type: TYPE_NORMAL
- en: Light control daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s review another example where we implement a simple daemon using OOP
    that turns on/off lights at specified times of the day. In order to be able to
    perform tasks at scheduled times, we will make use of the `schedule` library ([https://github.com/dbader/schedule](https://github.com/dbader/schedule)).
    It could be installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call our class, `LightScheduler`. It should be capable of accepting
    start and top times to turn on/off lights at given times. It should also provide
    override capabilities to let the user turn on/off lights as necessary. Let''s
    assume that the light is controlled using **PowerSwitch Tail II** ([http://www.powerswitchtail.com/Pages/default.aspx](http://www.powerswitchtail.com/Pages/default.aspx)).
    It is interfaced as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi Zero interfaced to the PowerSwitch Tail II
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `LightSchedular` class created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever an instance of `LightScheduler` is created, the GPIO pin is initialized
    to control the PowerSwitch Tail II. Now, let''s add methods to turn on/off lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the `init_schedule()` method, the start and stop times that were passed as
    arguments are used to initialize `schedule` to turn on/off the lights at the specified
    times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put it together, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the lights are scheduled to be turned on at 6:30 p.m.
    and turned off at 9:30 a.m. Once the jobs are scheduled, the program enters an
    infinite loop where it awaits task execution. This example could be run as a daemon
    by executing the file at start-up (add a line called `light_scheduler.py` to `/etc/rc.local`).
    After scheduling the job, it will continue to run as a daemon in the background.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a basic introduction to OOP and its applications (keeping the beginner
    in mind). Refer to this book's website for more examples on OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed lists and the advantages of OOP. We discussed
    OOP examples using the Raspberry Pi as the center of the examples. Since the book
    is targeted mostly towards beginners, we decided to stick to the basics of OOP
    while discussing examples. There are advanced aspects that are beyond the scope
    of the book. We leave it up to the reader to learn advanced concepts using other
    examples available on this book's site.
  prefs: []
  type: TYPE_NORMAL
