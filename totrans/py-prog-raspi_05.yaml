- en: Data Types and Object-Oriented Programming in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss data types and **object-oriented programming**
    (**OOP**) in Python. We will discuss data types including lists, dictionaries,
    tuples and sets in Python. We will also discuss OOP, it's necessity and how to
    write object-oriented code in Python for Raspberry Pi based projects (such as,
    using OOP to control appliances at home). We will discuss making use of OOP in
    a Raspberry Pi Zero project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, a list is a data type (its documentation is available here, [https://docs.python.org/3.4/tutorial/datastructures.html#](https://docs.python.org/3.4/tutorial/datastructures.html#))
    that could be used to store elements in a sequence.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics discussed in this chapter can be difficult to grasp unless used
    in practice. Any example that is represented using this notation: `>>>` indicates
    that it could be tested using the Python interpreter.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'A list may consist of strings, objects (discussed in detail in this chapter)
    or numbers, and so on. For instance, the following are examples of lists:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding set of examples, the `sequence` list consists of numbers between
    `1` and `6` while the `example_list` list consists of a combination of strings,
    integer, and floating-point numbers. A list is represented by square brackets
    (`[]`). Items can be added to a list separated by commas:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since a list is an ordered sequence of elements, the elements of a list could
    be fetched by iterating through the list elements using a `for` loop as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is something as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since Python's loop can iterate through a sequence of elements, it fetches each
    element and assigns it to `item`. This item is printed on the console.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Operations that could be performed on a list
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, the attributes of a data type can be retrieved using the `dir()` method.
    For example, the attributes available for the `sequence` list can be retrieved
    as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These attributes enable performing different operations on a list. Let's discuss
    each attribute in detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Append element to list:'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to add an element using the `append()` method:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Remove element from list:'
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `remove()` method finds the first instance of the element (passed an argument)
    and removes it from the list. Let''s consider the following examples:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1**:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Example 2**:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Example 3**:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Retrieving the index of an element
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `index()` method returns the position of an element in a list:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, the method returns the index of the element `5`. Since Python
    uses zero-based indexing that is the index is counted from 0 and hence the index
    of the element `5` is `4`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the method returns the position of the first instance of the
    element. The element `5` is located at the third position.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Popping an element from the list
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pop()` method enables removing an element from a specified position and
    return it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the `index_list` list consists of numbers between `1` and `7`.
    When the third element is popped by passing the index position `(3)` as an argument,
    the number `4` is removed from the list and returned.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'If no arguments are provided for the index position, the last element is popped
    and returned:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the last element `(7)` was popped and returned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Counting the instances of an element:'
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `count()` method returns the number of times an element appears in a list.
    For example, the element appears twice in the list: `random_list`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inserting element at a specific position:'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `insert()` method enables adding an element at a specific position in the
    list. For example, let''s consider the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the list, `Wednesday` is missing. It needs to be positioned between `Tuesday`
    and `Thursday` at position 2 (Python uses **zero based indexing** that is the
    positions/indexes of elements are counted as 0, 1, 2, and so on.). It could be
    added using insert as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Challenge to the reader
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding list, `Sunday` is missing. Use the `insert` attribute of lists
    to insert it at the correct position.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Extending a list
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two lists can be combined together using the `extend()` method. The `day_of_week`
    and `sequence` lists can be combined as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Lists can also be combined as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is also possible to add a list as an element to another list:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Clearing the elements of a list
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the elements of a list could be deleted using the `clear()` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Sorting the elements of a list
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The elements of a list could be sorted using the `sort()` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When a list consists of a collection of strings, they are sorted in the alphabetical
    order:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Reverse the order of elements in list
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reverse()` method enables the reversing the order of the list elements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Create copies of a list
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `copy()` method enables creating copies of a list:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Accessing list elements
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The list elements could be accessed by specifying the index position of the
    `list_name[i]` element. For example, the zeroth list element of the `random_list`
    list could be accessed as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Accessing a set of elements within a list
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to access elements between specified indices. For example, it
    is possible to retrieve all elements between indices 2 and 4:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first six elements of a list could be accessed as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The elements of a list could be printed in the reverse order as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Every second element in the list could be fetched as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It is also possible to fetch every second element after the second element
    after skipping the first two elements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: List membership
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to check if a value is a member of a list using the `in` keyword.
    For example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this list, we could check if the number `6` is a member:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's build a simple game!
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This exercise consists of two parts. In the first part, we will review building
    a list containing ten random numbers between `0` and `10`. The second part is
    a challenge to the reader. Perform the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is creating an empty list. Let''s create an empty list called
    `random_list`. An empty list can be created as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will be making use of Python''s `random` module ([https://docs.python.org/3/library/random.html](https://docs.python.org/3/library/random.html))
    to generate random numbers. In order to generate random numbers between `0` and
    `10`, we will make use of the `randint()` method from the `random` module:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s append the generated number to the list. This operation is repeated
    `10` times using a `for` loop:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The generated list looks something like this:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We discussed generating a list of random numbers. The next step is taking user
    input where we ask the user to make a guess for a number between `0` and `10`.
    If the number is a member of the list, the message `Your guess is correct` is
    printed to the screen, else, the message `Sorry! Your guess is incorrect` is printed.
    We leave the second part as a challenge to the reader. Get started with the `list_generator.py`
    code sample available for download with this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A dictionary ([https://docs.python.org/3.4/tutorial/datastructures.html#dictionaries](https://docs.python.org/3.4/tutorial/datastructures.html#dictionaries))
    is a data type that is an unordered collection of key and value pairs. Each key
    in a dictionary has an associated value. An example of a dictionary is:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A dictionary is created by using the braces `{}`. At the time of creation,
    new members are added to the dictionary in the following format: `key: value`
    (shown in the preceding example). In the previous example `1` and `2` are keys
    while `''Hello''` and `''World''` are the associated values. Each value added
    to a dictionary needs to have an associated key.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of a dictionary do not have an order i.e. the elements cannot
    be retrieved in the order they were added. It is possible to retrieving the values
    of a dictionary by iterating through the keys. Let''s consider the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are several ways to print the keys or values of a dictionary:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding example, we iterate through the keys of the dictionary and
    retrieve the value using the key, `my_dict[key]`. It is also possible to retrieve
    the values using the `values()` method available with dictionaries:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The keys of a dictionary can be an integer, string, or a tuple. The keys of
    a dictionary need to be unique and it is immutable, that is a key cannot be modified
    after creation. Duplicates of a key cannot be created. If a new value is added
    to an existing key, the latest value is stored in the dictionary. Let''s consider
    the following example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'A new key/value pair could be added to a dictionary as follows:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s try creating a duplicate of the key `9`:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As shown in the preceding example, when we try to create a duplicate, the value
    of the existing key is modified.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to have multiple values associated with a key. For example, as
    a list or a dictionary:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Dictionaries are useful in scenarios like parsing CSV files and associating
    each row with a unique key. Dictionaries are also used to encode and decode JSON data
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tuple (pronounced either like *two-ple* or *tuh-ple*) is an immutable data
    type that are ordered and separated by a comma. A tuple can be created as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Since tuples are immutable, the value at a given index cannot be modified:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A tuple can consist of a number, string, or a list. Since lists are mutable,
    if a list is a member of a tuple, it can be modified. For example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Tuples are especially useful in scenarios where the value cannot be modified.
    Tuples are also used to return values from a function. Let''s consider the following
    example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding example, the `items()` method returns a list of tuples.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A set ([https://docs.python.org/3/tutorial/datastructures.html#sets](https://docs.python.org/3/tutorial/datastructures.html#sets))
    is an unordered collection of immutable elements without duplicate entries. A
    set could be created as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s add a duplicate list to this set:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Sets enable avoid duplication of entries and saving the unique entries. A single
    element can be added to a set as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Sets are used to test memberships of an element among different sets. There
    are different methods that are related to membership tests. We recommend learning
    about each method using the documentation on sets (run `help(my_set)` to find
    the different methods available for membership tests).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: OOP in Python
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP is a concept that helps simplifying your code and eases application development.
    It is especially useful in reusing your code. Object-oriented code enables reusing
    your code for sensors that use the communications interface. For example, all
    sensors that are equipped with a UART port could be grouped together using object-oriented
    code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: One example of OOP is the **GPIO Zero library** ([https://www.raspberrypi.org/blog/gpio-zero-a-friendly-python-api-for-physical-computing/](https://www.raspberrypi.org/blog/gpio-zero-a-friendly-python-api-for-physical-computing/))
    used in previous chapters. In fact, everything is an object in Python.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented code is especially helpful in collaboration with other people
    on a project. For example, you could implement a sensor driver using object-oriented
    code in Python and document its usage. This enables other developers to develop
    an application without paying attention to the nitty-gritty detail behind the
    sensor's interface. OOP provides modularity to an application that simplifies
    application development. We are going to review an example in this chapter that
    demonstrates the advantage of OOP. In this chapter, we will be making use of OOP
    to bring modularity to our project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the student ID card example
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s revisit the ID card example from [Chapter 2](9e475135-4205-42c5-a109-cc59bfadad7d.xhtml),
    *Arithmetic Operations, Loops, and Blinky Lights* (`input_test.py`). We discussed
    writing a simple program that captures and prints the information belonging to
    a student. A student''s contact information could be retrieved and stored as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, consider a scenario where the information of 10 students has to be saved
    and retrieved at any point during program execution. We would need to come up
    with a nomenclature for the variables used to save the student information. It
    would be a clutter if we use 30 different variables to store information belonging
    to each student. This is where object oriented programming can be really helpful.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Let's rewrite this example using OOP to simplify the problem. The first step
    in OOP is declaring a structure for the object. This is done by defining a class.
    The class determines the functions of an object. Let's write a Python class that
    defines the structure for a student object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Class
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are going to save student information, the class is going to be called
    `Student`. A class is defined using the `class` keyword as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Thus, a class called `Student` has been defined. Whenever a new object is created,
    the method `__init__()` (the underscore indicate that the init method is a magic
    method, that is it is a function that is called by Python when an object is created)
    is called internally by Python.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is defined within the class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, the arguments to the `__init__` method include `name`, `age`
    and `address`. These arguments are called **attributes**. These attributes enable
    creating a unique object that belongs to the `Student` class. Hence, in this example,
    while creating an instance of the `Student` class, the attributes `name`, `age`,
    and `address` are required arguments.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an object (also called an instance) belonging to the `Student`
    class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, we created an object belonging to the `Student` class called
    `student1` where `John Doe` (name), `29` (age) and `123 Main Street, Newark, CA`(address)
    are attributes required to create an object. When we create an object that belongs
    to the `Student` class by passing the requisite arguments (declared earlier in
    the `__init__()` method of the `Student` class), the `__init__()` method is automatically
    called to initialize the object. Upon initialization, the information related
    to `student1` is stored under the object `student1`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the information belonging to `student1` could be retrieved as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s create another object called `student2`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We created two objects called `student1` and `student2`. Each object's attributes
    are accessible as `student1.name`, `student2.name` and so on. In the absence of
    object oriented programming, we will have to create variables like `student1_name`,
    `student1_age`, `student1_address`, `student2_name`, `student2_age` and `student2_address`
    and so on. Thus, OOP enables modularizing the code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods to a class
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add some methods to our `Student` class that would help retrieve a student''s
    information:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this example, we have added three methods namely `return_name()`, `return_age()`
    and `return_address()` that returns the attributes `name`, `age` and `address`
    respectively. These methods of a class are called **callable attributes**. Let's
    review a quick example where we make use of these callable attributes to print
    an object's information.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'So far, we discussed methods that retrieves information about a student. Let''s
    include a method in our class that enables updating information belonging to a
    student. Now, let''s add another method to the class that enables updating address
    by a student:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s compare the `student1` object''s address before and after updating the
    address:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This would print the following output to your screen:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Thus, we have written our first object-oriented code that demonstrates the ability
    to modularize the code. The preceding code sample is available for download along
    with this chapter as `student_info.py`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Doc strings in Python
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the object oriented example, you might have noticed a sentence enclosed
    in triple double quotes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is called a **doc string**. The doc string is used to document information
    about a class or a method. Doc strings are especially helpful while trying to
    store information related to the usage of a method or a class (this will be demonstrated
    later in this chapter). Doc strings are also used at the beginning of a file to
    store multi-line comments related to an application or a code sample. Doc strings
    are ignored by the Python interpreter and they are meant to provide documentation
    about a class to fellow programmers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the Python interpreter ignores any single line comment that starts
    with a `#` sign. Single line comments are generally used to make a specific note
    on a block of code. The practice of including well-structured comments makes your
    code readable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code snippet informs the reader that a random number
    between `0` and `9` is generated and stored in the variable `rand_num`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'On the contrary, a comment that provides no context is going to confuse someone
    who is reviewing your code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It is quite possible that you may not be able to recall what needs fixing when
    you revisit the code later.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: self
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our object-oriented example, the first argument to every method had an argument
    called `self`. `self` refers to the instance of the class in use and the `self`
    keyword is used as the first argument in methods that interact with the instances
    of the class. In the preceding example, `self` refers to the object `student1`.
    It is equivalent to initializing an object and accessing it as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `self` keyword simplifies how we access an object's attributes in this case.
    Now, let's review some examples where we make use of OOP involving the Raspberry
    Pi.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Speaker controller
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write a Python class (`tone_player.py` in downloads) that plays a musical
    tone indicating that the boot-up of your Raspberry Pi is complete. For this section,
    you will need a USB sound card and a speaker interfaced to the USB hub of the
    Raspberry Pi.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call our class `TonePlayer`. This class should be capable of controlling
    the speaker volume and playing any file passed as an argument while creating an
    object:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this case, the file that has to be played by the `TonePlayer` class has
    to be passed an argument. For example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We also need to be able to set the volume level at which the tone has to be
    played. Let''s add a method to do the same:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the `set_volume` method, we make use of Python's `subprocess` module to run
    the Linux system command that adjusts the sound drive volume.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The most essential method for this class is the `play` command. When the `play`
    method is called, we need to play the tone sound using Linux''s a `play` command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Put it all together:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Save the `TonePlayer` class to your Raspberry Pi (save it to a file called `tone_player.py`)
    and use a tone sound file from sources like *freesound* ([https://www.freesound.org/people/zippi1/sounds/18872/](https://www.freesound.org/people/zippi1/sounds/18872/)).
    Save it to a location of your choice and try running the code. It should play
    the tone sound at the desired volume!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, edit `/etc/rc.local` and add the following line to the end of the file
    (right before the `exit 0` line):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This should play a tone whenever the Pi boots up!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Light control daemon
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s review another example where we implement a simple daemon using OOP
    that turns on/off lights at specified times of the day. In order to be able to
    perform tasks at scheduled times, we will make use of the `schedule` library ([https://github.com/dbader/schedule](https://github.com/dbader/schedule)).
    It could be installed as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s call our class, `LightScheduler`. It should be capable of accepting
    start and top times to turn on/off lights at given times. It should also provide
    override capabilities to let the user turn on/off lights as necessary. Let''s
    assume that the light is controlled using **PowerSwitch Tail II** ([http://www.powerswitchtail.com/Pages/default.aspx](http://www.powerswitchtail.com/Pages/default.aspx)).
    It is interfaced as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_001.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi Zero interfaced to the PowerSwitch Tail II
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `LightSchedular` class created:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建的`LightSchedular`类：
- en: '[PRE72]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Whenever an instance of `LightScheduler` is created, the GPIO pin is initialized
    to control the PowerSwitch Tail II. Now, let''s add methods to turn on/off lights:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建`LightScheduler`的一个实例时，GPIO引脚被初始化以控制PowerSwitch Tail II。现在，让我们添加开启/关闭灯光的方法：
- en: '[PRE73]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the `init_schedule()` method, the start and stop times that were passed as
    arguments are used to initialize `schedule` to turn on/off the lights at the specified
    times.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init_schedule()`方法中，传入的起始和结束时间作为参数被用来初始化`schedule`，以便在指定的时间开启/关闭灯光。
- en: 'Put it together, we have:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们放在一起，我们有：
- en: '[PRE74]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding example, the lights are scheduled to be turned on at 6:30 p.m.
    and turned off at 9:30 a.m. Once the jobs are scheduled, the program enters an
    infinite loop where it awaits task execution. This example could be run as a daemon
    by executing the file at start-up (add a line called `light_scheduler.py` to `/etc/rc.local`).
    After scheduling the job, it will continue to run as a daemon in the background.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，灯光被安排在下午6:30开启，早上9:30关闭。一旦任务被安排，程序进入一个无限循环，等待任务执行。这个示例可以作为守护进程运行（在启动时执行文件，将名为`light_scheduler.py`的行添加到`/etc/rc.local`中）。在安排任务后，它将继续作为守护进程在后台运行。
- en: This is just a basic introduction to OOP and its applications (keeping the beginner
    in mind). Refer to this book's website for more examples on OOP.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个对面向对象编程及其应用的简单介绍（考虑到初学者的需求）。有关OOP的更多示例，请参阅本书的网站。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed lists and the advantages of OOP. We discussed
    OOP examples using the Raspberry Pi as the center of the examples. Since the book
    is targeted mostly towards beginners, we decided to stick to the basics of OOP
    while discussing examples. There are advanced aspects that are beyond the scope
    of the book. We leave it up to the reader to learn advanced concepts using other
    examples available on this book's site.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了列表和面向对象编程（OOP）的优势。我们以树莓派为中心，讨论了OOP的示例。由于本书主要面向初学者，我们决定在讨论示例时坚持OOP的基础知识。书中未涉及一些高级内容。我们留给读者使用本书网站上提供的其他示例来学习高级概念。
