["```py\n# squares.py\ndef square1(n):\n    return n**2  # squaring through the power operator\ndef square2(n):\n    return n * n  # squaring through multiplication \n```", "```py\n# list.iterable.txt\n>>> range(7)\n**range****(****0****,** **7****)**\n>>> list(range(7))  # put all elements in a list to view them\n[0, 1, 2, 3, 4, 5, 6] \n```", "```py\n# map.example.txt\n>>> map(lambda *a: a, range(3))  # 1 iterable\n<map object at 0x7f0db97adae0>  # Not useful! Let us use list\n>>> list(map(lambda *a: a, range(3)))  # 1 iterable\n[(0,), (1,), (2,)]\n>>> list(map(lambda *a: a, range(3), \"abc\"))  # 2 iterables\n[(0, 'a'), (1, 'b'), (2, 'c')]\n>>> list(map(lambda *a: a, range(3), \"abc\", range(4, 7)))  # 3\n[(0, 'a', 4), (1, 'b', 5), (2, 'c', 6)]\n>>> # map stops at the shortest iterator\n>>> list(map(lambda *a: a, (), \"abc\"))  # empty tuple is shortest\n[]\n>>> list(map(lambda *a: a, (1, 2), \"abc\"))  # (1, 2) shortest\n[(1, 'a'), (2, 'b')]\n>>> list(map(lambda *a: a, (1, 2, 3, 4), \"abc\"))  # \"abc\" shortest\n[(1, 'a'), (2, 'b'), (3, 'c')] \n```", "```py\n# decorate.sort.undecorate.py\nfrom pprint import pprint\nstudents = [\n    dict(id=0, credits=dict(math=9, physics=6, history=7)),\n    dict(id=1, credits=dict(math=6, physics=7, latin=10)),\n    dict(id=2, credits=dict(history=8, physics=9, chemistry=10)),\n    dict(id=3, credits=dict(math=5, physics=5, geography=7)),\n]\ndef decorate(student):\n    # create a 2-tuple (sum of credits, student) from student dict\n    return (**sum****(student[\"credits\"].values())**, student)\ndef undecorate(decorated_student):\n    # discard sum of credits, return original student dict\n    return decorated_student[1]\nprint(students[0])\nprint(decorate(students[0])\nstudents = sorted(**map****(decorate, students)**, reverse=True)\nstudents = list(**map****(undecorate, students)**)\npprint(students) \n```", "```py\n{'id': 0, 'credits': {'math': 9, 'physics': 6, 'history': 7}} \n```", "```py\n(22, {'id': 0, 'credits': {'math': 9, 'physics': 6, 'history': 7}}) \n```", "```py\n[{'credits': {'chemistry': 10, 'history': 8, 'physics': 9}, 'id': 2},\n {'credits': {'latin': 10, 'math': 6, 'physics': 7}, 'id': 1},\n {'credits': {'history': 7, 'math': 9, 'physics': 6}, 'id': 0},\n {'credits': {'geography': 7, 'math': 5, 'physics': 5}, 'id': 3}] \n```", "```py\n# zip.grades.txt\n>>> grades = [18, 23, 30, 27]\n>>> avgs = [22, 21, 29, 24]\n>>> list(zip(avgs, grades))\n[(22, 18), (21, 23), (29, 30), (24, 27)]\n>>> list(map(lambda *a: a, avgs, grades))  # equivalent to zip\n[(22, 18), (21, 23), (29, 30), (24, 27)] \n```", "```py\n# zip.strict.txt\n>>> students = [\"Sophie\", \"Alex\", \"Charlie\", \"Alice\"]\n>>> grades = [\"A\", \"C\", \"B\"]\n>>> dict(zip(students, grades))\n{'Sophie': 'A', 'Alex': 'C', 'Charlie': 'B'} \n```", "```py\n>>> dict(zip(students, grades, strict=True))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: zip() argument 2 is shorter than argument 1 \n```", "```py\n# filter.txt\n>>> test = [2, 5, 8, 0, 0, 1, 0]\n>>> list(filter(None, test))\n[2, 5, 8, 1]\n>>> list(filter(lambda x: x, test))  # equivalent to previous one\n[2, 5, 8, 1]\n>>> list(filter(lambda x: x > 4, test))  # keep only items > 4\n[5, 8] \n```", "```py\n# squares.for.txt\n>>> squares = []\n>>> for n in range(10):\n...     squares.append(n**2)\n...\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] \n```", "```py\n# squares.map.txt\n>>> squares = list(map(lambda n: n**2, range(10)))\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] \n```", "```py\n# squares.comprehension.txt\n>>> [n**2 for n in range(10)]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] \n```", "```py\n# even.squares.py\n# using map and filter\nsq1 = list(\n    map(lambda n: n**2, filter(lambda n: not n % 2, range(10)))\n)\n# equivalent, but using list comprehensions\nsq2 = [n**2 for n in range(10) if not n % 2]\nprint(sq1, sq1 == sq2)  # prints: [0, 4, 16, 36, 64] True \n```", "```py\n# pairs.for.loop.py\nitems = \"ABCD\"\npairs = []\nfor a in range(len(items)):\n    for b in range(a, len(items)):\n        pairs.append((items[a], items[b])) \n```", "```py\n$ python pairs.for.loop.py\n[('A', 'A'), ('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'B'), ('B', 'C'), ('B', 'D'), ('C', 'C'), ('C', 'D'), ('D', 'D')] \n```", "```py\n# pairs.list.comprehension.py\nitems = \"ABCD\"\npairs = [\n    (items[a], items[b])    \n    for a in range(len(items))\n    for b in range(a, len(items))\n] \n```", "```py\n# pythagorean.triple.py\nfrom math import sqrt\n# this will generate all possible pairs\nmx = 10\ntriples = [\n    (a, b, sqrt(a**2 + b**2))\n    for a in range(1, mx)\n    for b in range(a, mx)\n]\n# this will filter out all non-Pythagorean triples\ntriples = list(\n    filter(lambda triple: triple[2].is_integer(), triples)\n)\nprint(triples)  # prints: [(3, 4, 5.0), (6, 8, 10.0)] \n```", "```py\n# pythagorean.triple.int.py\nfrom math import sqrt\nmx = 10\ntriples = [\n    (a, b, sqrt(a**2 + b**2))\n    for a in range(1, mx)\n    for b in range(a, mx)\n]\ntriples = filter(lambda triple: triple[2].is_integer(), triples)\n# this will make the third number in the tuples integer\ntriples = list(\n    map(lambda triple: **triple[:****2****] + (****int****(triple[****2****]),)**, triples)\n)\nprint(triples)  # prints: [(3, 4, 5), (6, 8, 10)] \n```", "```py\n# pythagorean.triple.comprehension.py\nfrom math import sqrt\n# this step is the same as before\nmx = 10\ntriples = [\n    (a, b, sqrt(a**2 + b**2))\n    for a in range(1, mx)\n    for b in range(a, mx)\n]\n# here we combine filter and map in one CLEAN list comprehension\ntriples = [\n    (a, b, int(c)) for a, b, c in triples if c.is_integer()\n]\nprint(triples)  # prints: [(3, 4, 5), (6, 8, 10)] \n```", "```py\n# pythagorean.triple.walrus.py\nfrom math import sqrt\n# this step is the same as before\nmx = 10\n# We can combine generating and filtering in one comprehension\ntriples = [\n    (a, b, int(c))\n    for a in range(1, mx)\n    for b in range(a, mx)\n    if (**c := sqrt(a******2** **+ b******2****)**).is_integer()\n]\nprint(triples)  # prints: [(3, 4, 5), (6, 8, 10)] \n```", "```py\n# dictionary.comprehensions.py\nfrom string import ascii_lowercase\nlettermap = {c: k for k, c in enumerate(ascii_lowercase, 1)} \n```", "```py\n$ python dictionary.comprehensions.py\n{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8,\n'i': 9, 'j': 10, 'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15,\n'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, 'v': 22,\n'w': 23, 'x': 24, 'y': 25, 'z': 26} \n```", "```py\nlettermap = dict((c, k) for k, c in enumerate(ascii_lowercase, 1)) \n```", "```py\n# dictionary.comprehensions.duplicates.py\nword = \"Hello\"\nswaps = {c: c.swapcase() for c in word}\nprint(swaps)  # prints: {'H': 'h', 'e': 'E', 'l': 'L', 'o': 'O'} \n```", "```py\n# dictionary.comprehensions.positions.py\nword = \"Hello\"\npositions = {c: k for k, c in enumerate(word)}\nprint(positions)  # prints: {'H': 0, 'e': 1, 'l': 3, 'o': 4} \n```", "```py\n# set.comprehensions.py\nword = \"Hello\"\nletters1 = {c for c in word}\nletters2 = set(c for c in word)\nprint(letters1)  # prints: {'H', 'o', 'e', 'l'}\nprint(letters1 == letters2)  # prints: True \n```", "```py\n# first.n.squares.py\ndef get_squares(n): # classic function approach\n    return [x**2 for x in range(n)]\nprint(get_squares(10))\ndef get_squares_gen(n):  # generator approach\n    for x in range(n):\n        yield x**2  # we yield, we do not return\nprint(list(get_squares_gen(10))) \n```", "```py\n# first.n.squares.manual.py\ndef get_squares_gen(n):\n    for x in range(n):\n        yield x**2\nsquares = get_squares_gen(4)  # this creates a generator object\nprint(squares)  # <generator object get_squares_gen at 0x10dd...>\nprint(next(squares))  # prints: 0\nprint(next(squares))  # prints: 1\nprint(next(squares))  # prints: 4\nprint(next(squares))  # prints: 9\n# the following raises StopIteration, the generator is exhausted,\n# any further call to next will keep raising StopIteration\nprint(next(squares)) \n```", "```py\n# gen.yield.return.py\ndef geometric_progression(a, q):\n    k = 0\n    while True:\n        result = a * q**k\n        if result <= 100000:\n            yield result\n        else:\n            return\n        k += 1\nfor n in geometric_progression(2, 5):\n    print(n) \n```", "```py\n$ python gen.yield.return.py\n2\n10\n50\n250\n1250\n6250\n31250 \n```", "```py\n# gen.send.preparation.py\ndef counter(start=0):\n    n = start\n    while True:\n        yield n\n        n += 1\nc = counter()\nprint(next(c))  # prints: 0\nprint(next(c))  # prints: 1\nprint(next(c))  # prints: 2 \n```", "```py\n# gen.send.preparation.stop.py\nstop = False\ndef counter(start=0):\n    n = start\n    while not stop:\n        yield n\n        n += 1\nc = counter()\nprint(next(c))  # prints: 0\nprint(next(c))  # prints: 1\nstop = True\nprint(next(c))  # raises StopIteration \n```", "```py\n# gen.send.py\ndef counter(start=0):\n    n = start\n    while True:\n        result = yield n  # A\n        print(type(result), result)  # B\n        if result == \"Q\":\n            break\n        n += 1\nc = counter()\nprint(next(c))  # C\nprint(c.send(\"Wow!\"))  # D\nprint(next(c))  # E\nprint(c.send(\"Q\"))  # F \n```", "```py\n$ python gen.send.py\n0\n<class 'str'> Wow!\n1\n<class 'NoneType'> None\n2\n<class 'str'> Q\nTraceback (most recent call last):\n  File \"gen.send.py\", line 16, in <module>\n    print(c.send(\"Q\")) # F\n          ^^^^^^^^^^^\nStopIteration \n```", "```py\n# gen.yield.for.py\ndef print_squares(start, end):\n    for n in range(start, end):\n        yield n**2\nfor n in print_squares(2, 5):\n    print(n) \n```", "```py\n# gen.yield.from.py\ndef print_squares(start, end):\n    yield from (n**2 for n in range(start, end))\nfor n in print_squares(2, 5):\n    print(n) \n```", "```py\n# generator.expressions.txt\n>>> cubes = [k**3 for k in range(10)]  # regular list\n>>> cubes\n[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n>>> type(cubes)\n<class 'list'>\n>>> cubes_gen = (k**3 for k in range(10))  # create as generator\n>>> cubes_gen\n<generator object <genexpr> at 0x7f08b2004860>\n>>> type(cubes_gen)\n<class 'generator'>\n>>> list(cubes_gen)  # this will exhaust the generator\n[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n>>> list(cubes_gen)  # nothing more to give\n[] \n```", "```py\n# gen.map.py\ndef adder(*n):\n    return sum(n)\ns1 = sum(map(adder, range(100), range(1, 101)))\ns2 = sum(adder(*n) for n in zip(range(100), range(1, 101))) \n```", "```py\n# gen.filter.py\ncubes = [x**3 for x in range(10)]\nodd_cubes1 = filter(lambda cube: cube % 2, cubes)\nodd_cubes2 = (cube for cube in cubes if cube % 2) \n```", "```py\n# gen.map.filter.py\nN = 20\ncubes1 = map(\n    lambda n: (n, n**3),\n    filter(lambda n: n % 3 == 0 or n % 5 == 0, range(N)),\n)\ncubes2 = ((n, n**3) for n in range(N) if n % 3 == 0 or n % 5 == 0) \n```", "```py\n# sum.example.py\ns1 = sum([n**2 for n in range(10**6)])\ns2 = sum((n**2 for n in range(10**6)))\ns3 = sum(n**2 for n in range(10**6)) \n```", "```py\n# sum.example.2.py\ns = sum([n**2 for n in range(10**10)])  # this is killed\n# s = sum(n**2 for n in range(10**10))  # this succeeds\nprint(s)  # prints: 333333333283333333335000000000 \n```", "```py\n$ python sum.example.2.py\nKilled \n```", "```py\n$ python sum.example.2.py\n333333333283333333335000000000 \n```", "```py\n# performance.py\nfrom time import time\nmx = 5000\nt = time()  # start time for the for loop\nfloop = []\nfor a in range(1, mx):\n    for b in range(a, mx):\n        floop.append(divmod(a, b))\nprint(\"for loop: {:.4f} s\".format(time() - t))  # elapsed time\nt = time()  # start time for the list comprehension\ncompr = [divmod(a, b) for a in range(1, mx) for b in range(a, mx)]\nprint(\"list comprehension: {:.4f} s\".format(time() - t))\nt = time()  # start time for the generator expression\ngener = list(\n    divmod(a, b) for a in range(1, mx) for b in range(a, mx)\n)\nprint(\"generator expression: {:.4f} s\".format(time() - t)) \n```", "```py\n$ python performance.py\nfor loop: 2.3832 s\nlist comprehension: 1.6882 s\ngenerator expression: 1.6525 s \n```", "```py\n# performance.map.py\nfrom time import time\nmx = 2 * 10**7\nt = time()\nabsloop = []\nfor n in range(mx):\n    absloop.append(abs(n))\nprint(\"for loop: {:.4f} s\".format(time() - t))\nt = time()\nabslist = [abs(n) for n in range(mx)]\nprint(\"list comprehension: {:.4f} s\".format(time() - t))\nt = time()\nabsmap = list(map(abs, range(mx)))\nprint(\"map: {:.4f} s\".format(time() - t)) \n```", "```py\n$ python performance.map.py\nfor loop: 1.9009 s\nlist comprehension: 1.0973 s\nmap: 0.5862 s \n```", "```py\n>>> import this\n...\nExplicit is better than implicit.\nSimple is better than complex.\n...\nReadability counts.\n...\nIf the implementation is hard to explain, it's a bad idea.\n... \n```", "```py\n# functions.py\ndef gcd(a, b):\n    \"\"\"Calculate the Greatest Common Divisor of (a, b).\"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a \n```", "```py\n# pythagorean.triple.generation.py\nfrom functions import gcd\nN = 50\ntriples = sorted(  # 1\n    (\n        (a, b, c) for a, b, c in (  # 2\n            ((m**2 - n**2), (2 * m * n), (m**2 + n**2))  # 3\n            for m in range(1, int(N**.5) + 1)  # 4\n            for n in range(1, m)  # 5\n            if (m - n) % 2 and gcd(m, n) == 1  # 6\n        )\n        if c <= N  # 7\n    ),\n    key=sum  # 8\n) \n```", "```py\n# pythagorean.triple.generation.for.py\nfrom functions import gcd\ndef gen_triples(N):\n    for m in range(1, int(N**.5) + 1):  # 1\n        for n in range(1, m):  # 2\n            if (m - n) % 2 and gcd(m, n) == 1:  # 3\n                c = m**2 + n**2  # 4\n                if c <= N:  # 5\n                    a = m**2 - n**2  # 6\n                    b = 2 * m * n  # 7\n                    yield (a, b, c)  # 8\ntriples = sorted(gen_triples(50), key=sum)  # 9 \n```", "```py\n[(3, 4, 5), (5, 12, 13), (15, 8, 17), (7, 24, 25), (21, 20, 29), (35, 12, 37), (9, 40, 41)] \n```", "```py\n# scopes.py\nA = 100\nex1 = [A for A in range(5)]\nprint(A)  # prints: 100\nex2 = list(A for A in range(5))\nprint(A)  # prints: 100\nex3 = {A: 2 * A for A in range(5)}\nprint(A)  # prints: 100\nex4 = {A for A in range(5)}\nprint(A)  # prints: 100\ns = 0\nfor A in range(5):\n    s += A\nprint(A)  # prints: 4 \n```", "```py\n# scopes.noglobal.py\nex1 = [A for A in range(5)]\nprint(A)  # breaks: NameError: name 'A' is not defined \n```", "```py\n# scopes.for.py\ns = 0\nfor A in range(5):\n    s += A\nprint(A) # prints: 4\nprint(globals()) \n```", "```py\n$ python scopes.for.py\n4\n{'__name__': '__main__', '__doc__': None, ..., 's': 10, 'A': 4} \n```", "```py\n# fibonacci.first.py\ndef fibonacci(N):\n    \"\"\"Return all fibonacci numbers up to N.\"\"\"\n    result = [0]\n    next_n = 1\n    while next_n <= N:\n        result.append(next_n)\n        next_n = sum(result[-2:])\n    return result\nprint(fibonacci(0))  # [0]\nprint(fibonacci(1))  # [0, 1, 1]\nprint(fibonacci(50))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] \n```", "```py\n# fibonacci.second.py\ndef fibonacci(N):\n    \"\"\"Return all fibonacci numbers up to N.\"\"\"\n    yield 0\n    if N == 0:\n        return\n    a = 0\n    b = 1\n    while b <= N:\n        yield b\n        a, b = b, a + b\nprint(list(fibonacci(0)))  # [0]\nprint(list(fibonacci(1)))  # [0, 1, 1]\nprint(list(fibonacci(50)))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] \n```", "```py\n# fibonacci.elegant.py\ndef fibonacci(N):\n    \"\"\"Return all fibonacci numbers up to N.\"\"\"\n    a, b = 0, 1\n    while a <= N:\n        yield a\n        a, b = b, a + b \n```"]