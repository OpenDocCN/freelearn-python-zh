- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Design patterns are reusable programming solutions that have been used in various
    real-world contexts and have proved to produce expected results. They are shared
    among programmers and continue to be improved over time. This topic is popular
    thanks to the book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides,
    titled *Design Patterns: Elements of Reusable* *Object-Oriented Software*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quote about design patterns from the *Gang of* *Four* book:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A design pattern systematically names, motivates, and explains a general design
    that addresses a recurring design problem in object-oriented systems. It describes
    the problem, the solution, when to apply the solution, and its consequences. It
    also gives implementation hints and examples. The solution is a general arrangement
    of objects and classes that solve the problem. The solution is customized and
    implemented to solve the problem in a* *particular context.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several categories of design patterns used in **object-oriented programming**
    (**OOP**), depending on the type of problem they address and/or the types of solutions
    they help us build. In their book, the *Gang of Four* presents 23 design patterns,
    split into three categories: *creational*, *structural*, and *behavioral*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()` function, is not convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object pool pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a solid understanding of creational
    design patterns, whether they are useful or not in Python, and how to use them
    when they are useful.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with the first creational design pattern from the *Gang of Four*
    book: the factory design pattern. In the factory design pattern, a client (meaning
    client code) asks for an object without knowing where the object is coming from
    (that is, which class is used to generate it). The idea behind a factory is to
    simplify the object creation process. It is easier to track which objects are
    created if this is done through a central function, compared to letting a client
    create objects using a direct class instantiation. A factory reduces the complexity
    of maintaining an application by decoupling the code that creates an object from
    the code that uses it.'
  prefs: []
  type: TYPE_NORMAL
- en: Factories typically come in two forms—the factory method, which is a method
    (or simply a function for a Python developer) that returns a different object
    per input parameter, and the abstract factory, which is a group of factory methods
    used to create a family of related objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the two forms of *factory pattern*, starting with the factory
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The factory method is based on a single function written to handle our object
    creation task. We execute it, passing a parameter that provides information about
    what we want, and, as a result, the wanted object is created.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, when using the factory method, we are not required to know any
    details about how the resulting object is implemented and where it is coming from.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can find the factory method pattern used in real life in the context of a
    plastic toy construction kit. The molding material used to construct plastic toys
    is the same, but different toys (different figures or shapes) can be produced
    using the right plastic molds. This is like having a factory method in which the
    input is the name of the toy that we want (for example, a duck or car) and the
    output (after the molding) is the plastic toy that was requested.
  prefs: []
  type: TYPE_NORMAL
- en: In the software world, the Django web framework uses the factory method pattern
    for creating the fields of a web form. The `forms` module included in Django ([https://github.com/django/django/blob/main/django/forms/forms.py](https://github.com/django/django/blob/main/django/forms/forms.py))
    supports the creation of different kinds of fields (for example, `CharField`,
    `EmailField`, and so on). Parts of their behavior can be customized using attributes
    such as `max_length` and `required`.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the factory method pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you realize that you cannot track the objects created by your application
    because the code that creates them is in many different places instead of in a
    single function/method, you should consider using the factory method pattern.
    The factory method centralizes object creation and tracking your objects becomes
    much easier. Note that it is fine to create more than one factory method, and
    this is how it is typically done in practice. Each factory method logically groups
    the creation of objects that have similarities. For example, one factory method
    might be responsible for connecting you to different databases (MySQL, SQLite);
    another factory method might be responsible for creating the geometrical object
    that you request (circle, triangle); and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method is also useful when you want to decouple object creation
    from object usage. We are not coupled to a specific class when creating an object;
    we just provide partial information about what we want by calling a function.
    This means that introducing changes to the function is easy and does not require
    any changes to the code that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use case worth mentioning is related to improving the performance and
    memory usage of an application. A factory method can improve performance and memory
    usage by creating new objects only if it is necessary. When we create objects
    using a direct class instantiation, extra memory is allocated every time a new
    object is created (unless the class uses caching internally, which is usually
    not the case). We can see that in practice in the following code (`ch03/factory/id.py`),
    which creates two instances of the same class, `MyClass`, and uses the `id()`
    function to compare their memory addresses. The addresses are also printed in
    the output so that we can inspect them. The fact that the memory addresses are
    different means that two distinct objects are created. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the code (`ch03/factory/id.py`) on my computer results in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The addresses that you see if you execute the file, where the `id()` function
    is called, are not the same as the ones I see because they depend on the current
    memory layout and allocation. But the result must be the same—the two addresses
    should be different. There’s one exception that happens if you write and execute
    the code in the Python **Read-Eval-Print Loop** (**REPL**)—or, simply put, the
    interactive prompt—but that’s a REPL-specific optimization that does not happen
    normally.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the factory method pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Data comes in many forms. There are two main file categories for storing/retrieving
    data: human-readable files and binary files. Examples of human-readable files
    are XML, RSS/Atom, YAML, and JSON. Examples of binary files are the `.sq3` file
    format used by SQLite and the `.mp3` audio file format used to listen to music.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will focus on two popular human-readable formats—XML and
    JSON. Although human-readable files are generally slower to parse than binary
    files, they make data exchange, inspection, and modification much easier. For
    this reason, it is advised that you work with human-readable files unless there
    are other restrictions that do not allow it (mainly unacceptable performance or
    proprietary binary formats).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have some input data stored in an XML and a JSON file, and
    we want to parse them and retrieve some information. At the same time, we want
    to centralize the client’s connection to those (and all future) external services.
    We will use the factory method to solve this problem. The example focuses only
    on XML and JSON, but adding support for more services should be straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s look at the data files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON file, `movies.json`, is a sample of a dataset containing information
    about American movies (title, year, director name, genre, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The XML file, `person.xml`, contains information about individuals (`firstName`,
    `lastName`, `gender`, and so on), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the enclosing tag of the `persons` XML container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, an XML element representing a person’s data code is presented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An XML element representing another person’s data is shown by the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An XML element representing a third person’s data is shown by the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we close the XML container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use two libraries that are part of the Python distribution for working
    with JSON and XML: `json` and `xml.etree.ElementTree`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by importing what we need for the various manipulations (`json`, `ElementTree`,
    and `pathlib`), and we define a `JSONDataExtractor` class, loading the data from
    the file and using the `parsed_data` property to get it. That part of the code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define an `XMLDataExtractor` class, loading the data in the file via
    `ElementTree`’s parser, and using the `parsed_data` property to get the result,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we provide the factory function that helps select the right data extractor
    class depending on the target file’s extension (or raise an exception if it is
    not supported), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the main function of our program, `extract()`; in the first
    part of the function, the code handles the JSON case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the final part of the `extract()` function, working with the XML file
    using the factory method. XPath is used to find all person elements that have
    the last name `Liar`. For each matched person, the basic name and phone number
    information are shown. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add some testing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a summary of the implementation (in the `ch03/factory/factory_method.py`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: After importing the modules we need, we start by defining a JSON data extractor
    class (`JSONDataExtractor`) and an XML data extractor class (`XMLDataExtractor`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a factory function, `extract_factory()`, to get the right data extractor
    class to instantiate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also add our wrapper and main function, `extract()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add testing code, where we extract data from a JSON file and an
    XML file and parse the resulting text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test the example, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that although `JSONDataExtractor` and `XMLDataExtractor` have the same
    interfaces, what is returned by `parsed_data()` is not handled in a uniform way;
    in one case we have a list, and in the other, we have a tree. Different Python
    code must be used to work with each data extractor. Although it would be nice
    to be able to use the same code for all extractors, this is not realistic for
    the most part unless we use some kind of common mapping for the data, which is
    often provided by external data providers. Assuming that you can use the same
    code for handling the XML and JSON files, what changes are required to support
    a third format—for example, SQLite? Find an SQLite file or create your own and
    try it.
  prefs: []
  type: TYPE_NORMAL
- en: Should you use the factory method pattern?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main critique that veteran Python developers often express toward the factory
    method pattern is that it can be considered over-engineered or unnecessarily complex
    for many use cases. Python’s dynamic typing and first-class functions often allow
    for simpler, more straightforward solutions to problems that the factory method
    aims to solve. In Python, you can often use simple functions or class methods
    to create objects directly without needing to create separate factory classes
    or functions. This keeps the code more readable and Pythonic, adhering to the
    language’s philosophy of *Simple is better* *than complex*.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Python’s support for default arguments, keyword arguments, and other language
    features often makes it easier to extend constructors in a backward-compatible
    way, reducing the need for separate factory methods. So, while the factory method
    pattern is a well-established design pattern in statically typed languages such
    as Java or C++, it is often seen as too cumbersome or verbose for Python’s more
    flexible and dynamic nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show how one could deal with simple use cases without the factory method
    pattern, an alternative implementation has been provided in the `ch03/factory/factory_method_not_needed.py`
    file. As you can see, there is no more factory. And the following extract from
    the code shows what we mean when we say that in Python, you just create objects
    where you need them, without an intermediary function or class, which makes your
    code more Pythonic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The abstract factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract factory pattern is a generalization of the factory method idea.
    Basically, an abstract factory is a (logical) group of factory methods, where
    each factory method is responsible for generating a different kind of object.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to discuss some examples, use cases, and a possible implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The abstract factory is used in car manufacturing. The same machinery is used
    for stamping the parts (doors, panels, hoods, fenders, and mirrors) of different
    car models. The model that is assembled by the machinery is configurable and easy
    to change at any time.
  prefs: []
  type: TYPE_NORMAL
- en: In the software category, the `factory_boy` package ([https://github.com/FactoryBoy/factory_boy](https://github.com/FactoryBoy/factory_boy))
    provides an abstract factory implementation for creating Django models in tests.
    An alternative tool is `model_bakery` ([https://github.com/model-bakers/model_bakery](https://github.com/model-bakers/model_bakery)).
    Both packages are used for creating instances of models that support test-specific
    attributes. This is important because, this way, the readability of your tests
    is improved, and you avoid sharing unnecessary code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Django models are special classes used by the framework to help store and interact
    with data in the database (tab[les). See the Django documenta](https://docs.djangoproject.com)tion
    ([https://docs.djangoproject.com](https://docs.djangoproject.com)) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the abstract factory pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the abstract factory pattern is a generalization of the factory method
    pattern, it offers the same benefits: it makes tracking an object creation easier,
    it decouples object creation from object usage, and it gives us the potential
    to improve the memory usage and performance of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the abstract factory pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To demonstrate the abstract factory pattern, I will reuse one of my favorite
    examples, included in the book *Python 3 Patterns, Recipes and Idioms*, by Bruce
    Eckel. Imagine that we are creating a game or we want to include a mini-game as
    part of our application to entertain our users. We want to include at least two
    games, one for children and one for adults. We will decide which game to create
    and launch at runtime, based on user input. An abstract factory takes care of
    the game creation part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the kids’ game. It is called `interact_with()` method is used
    to describe the interaction of the frog with an obstacle (for example, a bug,
    puzzle, and other frogs) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There can be many kinds of obstacles, but for our example, an obstacle can
    only be a bug. When the frog encounters a bug, only one action is supported. It
    eats it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FrogWorld` class is an abstract factory. Its main responsibilities are
    creating the main character and the obstacle(s) in the game. Keeping the creation
    methods separate and their names generic (for example, `make_character()` and
    `make_obstacle()`) allows us to change the active factory (and, therefore, the
    active game) dynamically without any code changes. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The **WizardWorld** game is similar. The only difference is that the wizard
    battles against monsters such as orks instead of eating bugs!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the definition of the `Wizard` class, which is similar to the `Frog`
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the definition of the `Ork` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define a `WizardWorld` class, similar to the `FrogWorld` one
    that we have discussed; the obstacle, in this case, is an `Ork` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GameEnvironment` class is the main entry point of our game. It accepts
    the factory as an input and uses it to create the world of the game. The `play()`
    method initiates the interaction between the created hero and the obstacle, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `validate_age()` function prompts the user to give a valid age. If the
    age is not valid, it returns a tuple with the first element set to `False`. If
    the age is fine, the first element of the tuple is set to `True`, and that’s the
    case where we care about the second element of the tuple, which is the age given
    by the user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally comes the `main()` function definition, followed by calling it. It
    asks for the user’s name and age and decides which game should be played, given
    the age of the user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The summary for the implementation we just discussed (see the complete code
    in the `ch03/factory/abstract_factory.py` file) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We define `Frog` and `Bug` classes for the **FrogWorld** game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `FrogWorld` class, where we use our `Frog` and `Bug` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define `Wizard` and `Ork` classes for the **WizardWorld** game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `WizardWorld` class, where we use our `Wizard` and `Ork` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `GameEnvironment` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `validate_age()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we have the `main()` function, followed by the conventional trick
    for calling it. The following are the aspects of this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the user’s input for name and age.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We decide which game class to use based on the user’s age.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We instantiate the right game class, and then the `GameEnvironment` class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `.play()` on the `environment` object to play the game.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s call this program using the `python ch03/factory/abstract_factory.py`
    command and see some sample output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample output for a teenager is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample output for an adult is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Try extending the game to make it more complete. You can go as far as you want;
    create many obstacles, many enemies, and whatever else you like.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just covered the first two creational patterns, the factory method and the
    abstract factory, which both offer approaches to improve the way we create objects
    in nontrivial cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that we want to create an object that is composed of multiple parts,
    and the composition needs to be done step by step. The object is not complete
    unless all its parts are fully created. That’s where the builder design pattern
    can help us. The builder pattern separates the construction of a complex object
    from its representation. By keeping the construction separate from the representation,
    the same construction can be used to create several different representations.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our everyday life, the builder design pattern is used in fast-food restaurants.
    The same procedure is always used to prepare a burger and the packaging (box and
    paper bag), even if there are many kinds of burgers (classic, cheeseburger, and
    more) and different packages (small-sized box, medium-sized box, and so forth).
    The difference between a classic burger and a cheeseburger is in the representation
    and not in the construction procedure. In this case, the director is the cashier
    who gives instructions about what needs to be prepared to the crew, and the builder
    is the person from the crew who takes care of the specific order.
  prefs: []
  type: TYPE_NORMAL
- en: In so[ftware, we can think of the `django-query-builder` li](https://github.com/ambitioninc/django-query-builder)brary
    ([https://github.com/ambitioninc/django-query-builder](https://github.com/ambitioninc/django-query-builder)),
    a third-party Django library that relies on the builder pattern. This library
    can be used for building SQL queries dynamically, allowing you to control all
    aspects of a query and create a different range of queries, from simple to very
    complex ones.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with the factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, the distinction between the builder pattern and the factory pattern
    might not be very clear. The main difference is that a factory pattern creates
    an object in a single step, whereas a builder pattern creates an object in multiple
    steps and almost always uses a *director*.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that while the factory pattern returns a created object
    immediately, in the builder pattern, the client code explicitly asks the director
    to return the final object when it needs it.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the builder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The builder pattern is particularly useful when an object needs to be constructed
    with numerous possible configurations. A typical case is a situation where a class
    has multiple constructors with a varying number of parameters, often leading to
    confusion or error-prone code.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is also beneficial when the object’s construction process is more
    complex than simply setting initial values. For example, if an object’s full creation
    involves multiple steps, such as parameter validation, setting up data structures,
    or even making calls to external services, the builder pattern can encapsulate
    this complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the builder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see how we can use the builder design pattern to make a pizza-ordering
    application. This example is particularly interesting because a pizza is prepared
    in steps that should follow a specific order. To add the sauce, you first need
    to prepare the dough. To add the topping, you first need to add the sauce. And
    you can’t start baking the pizza unless both the sauce and the topping are placed
    on the dough. Moreover, each pizza usually requires a different baking time, depending
    on the thickness of its dough and the topping used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by importing the required modules and declaring a few `Enum` parameters
    plus a constant that is used many times in the application. The `STEP_DELAY` constant
    is used to add a time delay between the different steps of preparing a pizza (prepare
    the dough, add the sauce, and so on) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our end product is a pizza, which is described by the `Pizza` class. When using
    the builder pattern, the end product does not have many responsibilities, since
    it is not supposed to be instantiated directly. A builder creates an instance
    of the end product and makes sure that it is properly prepared. That’s why the
    `Pizza` class is so minimal. It basically initializes all data to sane default
    values. An exception is the `prepare_dough()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `prepare_dough()` method is defined in the `Pizza` class instead of a builder
    for two reasons. First, to clarify the fact that the end product is typically
    minimal, which does not mean that you should never assign it any responsibilities.
    Second, to promote code reuse through composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we define our `Pizza` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two builders: one for creating a margarita pizza (`MargaritaBuilder`)
    and another for creating a creamy bacon pizza (`CreamyBaconBuilder`). Each builder
    creates a `Pizza` instance and contains methods that follow the pizza-making procedure:
    `prepare_dough()`, `add_sauce()`, `add_topping()`, and `bake()`. To be precise,
    `prepare_dough()` is just a wrapper to the `prepare_dough()` method of the `Pizza`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how each builder takes care of all the pizza-specific details. For example,
    the topping of the margarita pizza is double mozzarella and oregano, while the
    topping of the creamy bacon pizza is mozzarella, bacon, ham, mushrooms, red onion,
    and oregano.
  prefs: []
  type: TYPE_NORMAL
- en: 'An extract of the code of the `MargaritaBuilder` class is as follows (see the
    `ch03/builder.py` file for the whole code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'An extract of the code of the `CreamyBaconBuilder` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The *director* in this example is the waiter. The core of the `Waiter` class
    is the `construct_pizza()` method, which accepts a builder as a parameter and
    executes all the pizza-preparation steps in the right order. Choosing the appropriate
    builder, which can even be done at runtime, gives us the ability to create different
    pizza styles without modifying any of the code of the director (`Waiter`). The
    `Waiter` class also contains the `pizza()` method, which returns the end product
    (prepared pizza) as a variable to the caller. The code for that class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `validate_style()` method is similar to the `validate_age()` function,
    as described in the section titled *The factory pattern* earlier in this chapter.
    It is used to make sure that the user gives valid input, which in this case is
    a character that is mapped to a pizza builder. The `m` character uses the `MargaritaBuilder`
    class, and the `c` character uses the `CreamyBaconBuilder` class. These mappings
    are in the `builder` parameter. A tuple is returned, with the first element set
    to `True` if the input is valid or `False` if it is invalid, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part is the `main()` function. The `main()` function contains code
    for instantiating a pizza builder. The pizza builder is then used by the `Waiter`
    director to prepare the pizza. The created pizza can be delivered to the client
    at any later point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a summary of the implementation (in the `ch03/builder.py` file):'
  prefs: []
  type: TYPE_NORMAL
- en: We start with a couple of imports we need, for the standard `Enum` class and
    `time` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We declare variables for a few constants: `PizzaProgress`, `PizzaDough`, `PizzaSauce`,
    `PizzaTopping`, and `STEP_DELAY`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define our `Pizza` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define classes for two builders, `MargaritaBuilder` and `CreamyBaconBuilder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define our `Waiter` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `validate_style()` function to improve things regarding exception handling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we have the `main()` function, followed by a snippet for calling it
    when the program is run. In the `main()` function, the following happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make it possible to choose the pizza builder based on the user’s input, after
    validation via the `validate_style()` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The pizza builder is used by the waiter for preparing the pizza.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The created pizza is then delivered.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the output produced by calling the `python ch03/builder.py` command
    to execute this example program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: That was a nice result.
  prefs: []
  type: TYPE_NORMAL
- en: But... supporting only two pizza types is a shame. Feel like getting a Hawaiian
    pizza builder? Consider using *inheritance* after thinking about the advantages
    and disadvantages. Or *composition*, which has its advantages, as we have seen
    in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017), *Foundational* *Design Principles*.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prototype pattern allows you to create new objects by copying existing ones,
    rather than creating them from scratch. This pattern is particularly useful when
    the cost of initializing an object is more expensive or complex than copying an
    existing one. In essence, the prototype pattern enables you to create a new instance
    of a class by duplicating an existing instance, thereby avoiding the overhead
    of initializing a new object.
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest version, this pattern is just a `clone()` function that accepts
    an object as an input parameter and returns a clone of it. In Python, this can
    be done using the `copy.deepcopy()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloning a plant by taking a cutting is a real-world example of the prototype
    pattern. Using this approach, you don’t grow the plant from a seed; you create
    a new plant that’s a copy of an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Many Python applications make use of the prototype pattern, but it is rarely
    referred to as *prototype* since cloning objects is a built-in feature of the
    Python language.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the prototype pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prototype pattern is useful when we have an existing object that needs to
    stay untouched and we want to create an exact copy of it, allowing changes in
    some parts of the copy.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the frequent need for duplicating an object that is populated
    from a database and has references to other database-based objects. It is costly
    (multiple queries to a database) to clone such a complex object, so a prototype
    is a convenient way to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the prototype pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nowadays, some organizations, even of small size, deal with many websites and
    apps via their infrastructure/DevOps teams, hosting providers, or **cloud service**
    **providers** (**CSPs**).
  prefs: []
  type: TYPE_NORMAL
- en: When you have to manage multiple websites, there is a point where it becomes
    difficult to follow. You need to access information quickly, such as IP addresses
    that are involved, domain names and their expiration dates, and maybe details
    about DNS parameters. So, you need a kind of inventory tool.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine how these teams deal with this type of data for daily activities,
    and touch on the implementation of a piece of software that helps consolidate
    and maintain the data (other than in Excel spreadsheets).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import Python’s standard `copy` module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: At the heart of this system, we will have a `Website` class for holding all
    useful information such as the name, the domain name, a description, the author
    of a website we are managing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `__init__()` method of the class, only some parameters are fixed: `name`,
    `domain`, and `description`. But we also want flexibility, and client code can
    pass more parameters in the form of keywords (`name=value`) using the `kwargs`
    variable-length collection (each pair becomes an item of the `kwargs` Python dictionary).'
  prefs: []
  type: TYPE_NORMAL
- en: Additional information
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a Python idiom that helps to set an arbitrary attribute named `attr`
    with a `val` value on an `obj` object, using the `setattr()` built-in function:
    `setattr(obj,` `attr, val)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So we are defining a `Website` class and initializing its objects, using the
    `setattr` technique for optional attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s not all. To improve the usability of the class, we also add its string
    representation method (`__str__()`). We extract the values of all instance attributes,
    using the `vars()` trick, and inject those values into the string that the method
    returns. Also, since we plan to clone objects, we include the object’s memory
    address using the `id()` function. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Additional information
  prefs: []
  type: TYPE_NORMAL
- en: The `vars()` function in Python returns the `__dict__` attribute of an object.
    The `__dict__` attribute is a dictionary containing the object’s attributes (both
    data attributes and methods). This function is useful for debugging, as it allows
    you to inspect the attributes and methods of an object or the local variables
    within a function. But note that not all objects have a `__dict__` attribute.
    For example, built-in types such as lists and dictionaries do not have this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add a `Prototype` class that implements the prototype design pattern.
    At the heart of this class, we have the `clone()` method, which is in charge of
    cloning the object using the `copy.deepcopy()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When we clone an object using `copy.deepcopy()`, the memory address of the clone
    must be different from the memory address of the original object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since cloning means that we allow setting values for optional attributes, notice
    how we use the `setattr` technique here with the `attrs` dictionary. Also, for
    more convenience, the `Prototype` class contains the `register()` and `unregister()`
    methods, which can be used to keep track of the cloned objects in a registry (a
    dictionary). The code of that class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function, which we define next, we complete the program: we
    clone a first `Website` instance, `site1`, to get a second object `site2`. Basically,
    we instantiate the `Prototype` class and we use its `.clone()` method. Then, we
    display the result. The code for that function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call the `main()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a summary of what we do in the code (`ch03/prototype.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the `copy` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `Website` class, with its initialization method (`__init__()`) and
    its string representation method (`__str__()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define our `Prototype` class as shown earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we have the `main()` function, where we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `keywords` list we need.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We create an instance of the `Website` class, called `site1` (we use the `keywords`
    list here).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a `Prototype` object and we use its `register()` method to register
    `site1` with its identifier (this helps us keep track of the cloned objects in
    a dictionary).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We clone the `site1` object to get `site2`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We display the result (both `Website` objects).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample output when I execute the `python ch03/prototype.py` command on my
    computer is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, `Prototype` works as expected. We can see information about the original
    `Website` object and its clone.
  prefs: []
  type: TYPE_NORMAL
- en: And looking at the ID value for each `Website` object, we can see that the two
    addresses are different.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the original design patterns for OOP, the singleton pattern restricts
    the instantiation of a class to *one* object, which is useful when you need one
    object to coordinate actions for the system.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is that only one instance of a particular class, doing a job,
    is created for the needs of the program. To ensure that this works, we need mechanisms
    that prevent the instantiation of the class more than once and also prevent cloning.
  prefs: []
  type: TYPE_NORMAL
- en: In the Python programmer community, the singleton pattern is actually considered
    an anti-pattern. Let’s explore the pattern first, and later we will discuss the
    alternative approaches we are encouraged to use in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a real-life scenario, we can think of the captain of a ship or a boat. On
    the ship, they are the ones in charge. They are responsible for important decisions,
    and a number of requests are directed to them because of this responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is the printer spooler, in an office environment, which ensures
    that print jobs are coordinated through a single point, avoiding conflicts and
    ensuring orderly printing.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The singleton design pattern is useful when you need to create only one object
    or you need some sort of object capable of maintaining a global state for your
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other possible use cases are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling concurrent access to a shared resource—for example, the class managing
    the connection to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service or resource that is transversal in the sense that it can be accessed
    from different parts of the application or by different users and do its work—for
    example, the class at the core of a logging system or utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed, the singleton pattern ensures that a class has only one instance
    and provides a global point to access it. In this example, we’ll create a `URLFetcher`
    class that fetches content from web pages. We want to ensure that only one instance
    of this class exists to keep track of all fetched URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have multiple fetchers in different parts of your program, but you
    want to keep track of all URLs that have been fetched. This is a classic case
    for a singleton pattern. By ensuring that all parts of your program use the same
    fetcher instance, you can easily keep track of all fetched URLs in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we create a naive version of the `URLFetcher` class. This class
    has a `fetch()` method that fetches the web page content and stores the URL in
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To check if our class is a `is` operator. If they are the same, then it’s a
    singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code (`ch03/singleton/before_singleton.py`), you’ll see that
    the output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This output shows that the class in this version does not yet respect the singleton
    pattern. To make it a singleton, we’ll use the **metaclass** technique.
  prefs: []
  type: TYPE_NORMAL
- en: Additional information
  prefs: []
  type: TYPE_NORMAL
- en: A metaclass in Python is a class of a class that defines how a class behaves.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create a `SingletonType` metaclass that ensures that only one instance
    of `URLFetcher` exists, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we modify our `URLFetcher` class to use this metaclass, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `main()` function and call it to test our singleton, with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a summary of what we do in the code (`ch03``/singleton/singleton.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: We start with our needed module imports (`urllib.request`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `SingletonType` class, with its special `__call__()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define `URLFetcher`, the class implementing the fetcher for the web pages,
    initializing it with the `urls` attribute; as discussed, we add its `fetch()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we add our `main()` function, and we add Python’s conventional snippet
    used to call it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test the implementation, run the `python ch03/singleton/singleton.py` command.
    You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In addition, you will find that a file called `content.html` has been created,
    with the HTML text that comes from the different URLs added to it.
  prefs: []
  type: TYPE_NORMAL
- en: So, the program did its job as expected. This is a demonstration of how the
    singleton pattern may be used.
  prefs: []
  type: TYPE_NORMAL
- en: Should you use the singleton pattern?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the singleton pattern has its merits, it may not always be the most Pythonic
    approach to managing global states or resources. Our implementation example worked,
    but if we stop a minute to analyze the code again, we notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The techniques used for the implementation are rather advanced and not easy
    to explain to a beginner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By reading the `SingletonType` class definition, it is not easy to immediately
    see that it provides a metaclass for a singleton if the name does not suggest
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Python, developers often prefer a simpler alternative to singleton: using
    a module-level global object.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Python modules act as natural namespaces that can contain variables, functions,
    and classes, making them ideal for organizing and sharing global resources.
  prefs: []
  type: TYPE_NORMAL
- en: By adopting the global object technique, as explained by Brandon Rhodes in what
    he calls the *Global Object Pattern* ([https://python-patterns.guide/python/module-globals/](https://python-patterns.guide/python/module-globals/)),
    you can achieve the same result as the singleton pattern without the need for
    complex instantiation processes or forcing a class to only have one instance.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you can re-write the implementation of our example using a global
    object. For reference, the equivalent code, defining a global object, is provided
    in the `ch03/singleton/instead_of_singleton/example.py` file; for its use, check
    the `ch03/singleton/instead_of_singleton/use_example.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: The object pool pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object pool pattern is a creational design pattern that allows you to reuse
    existing objects instead of creating new ones when they are needed. This pattern
    is particularly useful when the cost, in terms of system resources, time, and
    so on of initializing a new object is high.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider a car rental service. When a customer rents a car, the service doesn’t
    manufacture a new car for them. Instead, it provides one from a pool of available
    cars. Once the customer returns the car, it goes back into the pool, ready to
    be used by the next customer.
  prefs: []
  type: TYPE_NORMAL
- en: Another example would be a public swimming pool. Rather than filling the pool
    with water every time someone wants to swim, the water is treated and reused for
    multiple swimmers. This saves both time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the object pool pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object pool pattern is especially useful in scenarios where resource initialization
    is costly or time-consuming. This could be in terms of CPU cycles, memory usage,
    or even network bandwidth. For example, in a shooting video game, you might use
    this pattern to manage bullet objects. Creating a new bullet every time a gun
    is fired could be resource-intensive. Instead, you could have a pool of bullet
    objects that are reused.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the object pool pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s implement a pool of reusable `car` objects, for a car rental application,
    to avoid creating and destroying them repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define a `Car` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we start defining a `CarPool` class with its initialization, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to express what happens when a client acquires a car. For that, we
    define a method on the class doing the following: if no car is available, we instantiate
    one and add it to the list of available cars in the pool; else, we return an available
    `car` object, while doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `_in_use` attribute of the `car` object to `True`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the `car` object to the list of “in use” cars (stored in the `_in_use`
    attribute of the `pool` object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We add the code of that method to the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add a method that handles things when a client releases a car, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add some code for testing the result of the implementation, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a summary of what we do in the code (in file `ch03/object_pool.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: We define a `Car` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `CarPool` class with the `acquire_car()` and `release_car()` methods,
    as shown earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add code for testing the result of the implementation, as shown earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test the program, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Well done! This output shows that our object pool pattern implementation works
    as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen *creational design patterns*, which are essential
    for crafting flexible, maintainable, and modular code. We kicked off the chapter
    by examining two variations of the factory pattern, each offering unique advantages
    for object creation. Next, we navigated through the builder pattern, which provides
    a more readable and maintainable way to construct complex objects. The prototype
    pattern followed, introducing a method to clone objects efficiently. Finally,
    we rounded out the chapter by discussing the singleton and object pool patterns,
    both of which are geared toward optimizing resource management and ensuring consistent
    state across the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, equipped with these foundational patterns for object creation, we are well
    prepared for the next chapter, where we will discover *structural* *design patterns*.
  prefs: []
  type: TYPE_NORMAL
