- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Creational Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: 'Design patterns are reusable programming solutions that have been used in various
    real-world contexts and have proved to produce expected results. They are shared
    among programmers and continue to be improved over time. This topic is popular
    thanks to the book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides,
    titled *Design Patterns: Elements of Reusable* *Object-Oriented Software*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是可重用的编程解决方案，已在各种实际应用场景中使用，并已被证明能产生预期的结果。它们在程序员之间共享，并且随着时间的推移而不断改进。这个主题之所以受欢迎，多亏了Erich
    Gamma、Richard Helm、Ralph Johnson和John Vlissides合著的书籍，书名为《设计模式：可重用面向对象软件的元素》。
- en: 'Here is a quote about design patterns from the *Gang of* *Four* book:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自“四人帮”书中关于设计模式的一句话：
- en: '*A design pattern systematically names, motivates, and explains a general design
    that addresses a recurring design problem in object-oriented systems. It describes
    the problem, the solution, when to apply the solution, and its consequences. It
    also gives implementation hints and examples. The solution is a general arrangement
    of objects and classes that solve the problem. The solution is customized and
    implemented to solve the problem in a* *particular context.*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*设计模式系统地命名、阐述并解释了一种通用的设计，该设计解决了面向对象系统中反复出现的设计问题。它描述了问题、解决方案、何时应用解决方案及其后果。它还提供了实现提示和示例。解决方案是一组通用的对象和类安排，用于解决问题。解决方案是根据特定环境进行定制和实现的，以解决该问题。*'
- en: 'There are several categories of design patterns used in **object-oriented programming**
    (**OOP**), depending on the type of problem they address and/or the types of solutions
    they help us build. In their book, the *Gang of Four* presents 23 design patterns,
    split into three categories: *creational*, *structural*, and *behavioral*.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们解决的问题类型和/或它们帮助我们构建的解决方案类型，**面向对象编程**（**OOP**）中使用了几个设计模式类别。在他们的书中，“四人帮”提出了23个设计模式，分为三个类别：*创建型*、*结构型*和*行为型*。
- en: '`__init__()` function, is not convenient.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 函数，不方便。'
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The factory pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The builder pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建者模式
- en: The prototype pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式
- en: The singleton pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: The object pool pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象池模式
- en: By the end of the chapter, you will have a solid understanding of creational
    design patterns, whether they are useful or not in Python, and how to use them
    when they are useful.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将有一个稳固的理解，无论是它们在Python中是否有用，以及如何在它们有用时使用它们。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第1章](B21896_01.xhtml#_idTextAnchor017)中提出的需求。
- en: The factory pattern
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: 'We will start with the first creational design pattern from the *Gang of Four*
    book: the factory design pattern. In the factory design pattern, a client (meaning
    client code) asks for an object without knowing where the object is coming from
    (that is, which class is used to generate it). The idea behind a factory is to
    simplify the object creation process. It is easier to track which objects are
    created if this is done through a central function, compared to letting a client
    create objects using a direct class instantiation. A factory reduces the complexity
    of maintaining an application by decoupling the code that creates an object from
    the code that uses it.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从“四人帮”书中的第一个创建型设计模式开始：工厂设计模式。在工厂设计模式中，客户端（即客户端代码）请求一个对象，而不知道这个对象是从哪里来的（即，使用哪个类来生成它）。工厂背后的想法是简化对象创建过程。如果通过一个中心函数来完成，那么跟踪哪些对象被创建比让客户端使用直接类实例化来创建对象要容易得多。工厂通过将创建对象的代码与使用它的代码解耦，减少了维护应用程序的复杂性。
- en: Factories typically come in two forms—the factory method, which is a method
    (or simply a function for a Python developer) that returns a different object
    per input parameter, and the abstract factory, which is a group of factory methods
    used to create a family of related objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂通常有两种形式——工厂方法，它是一个方法（对于Python开发者来说，也可以是一个简单的函数），根据输入参数返回不同的对象，以及抽象工厂，它是一组用于创建相关对象族的工厂方法。
- en: Let’s discuss the two forms of *factory pattern*, starting with the factory
    method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论两种工厂模式的形式，从工厂方法开始。
- en: The factory method
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂方法
- en: The factory method is based on a single function written to handle our object
    creation task. We execute it, passing a parameter that provides information about
    what we want, and, as a result, the wanted object is created.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法基于一个编写来处理我们的对象创建任务的单一函数。我们执行它，传递一个参数，提供关于我们想要什么的信息，然后，作为结果，所需的对象被创建。
- en: Interestingly, when using the factory method, we are not required to know any
    details about how the resulting object is implemented and where it is coming from.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在使用工厂方法时，我们不需要了解任何关于结果对象是如何实现以及从哪里来的细节。
- en: Real-world examples
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现实世界中的例子
- en: We can find the factory method pattern used in real life in the context of a
    plastic toy construction kit. The molding material used to construct plastic toys
    is the same, but different toys (different figures or shapes) can be produced
    using the right plastic molds. This is like having a factory method in which the
    input is the name of the toy that we want (for example, a duck or car) and the
    output (after the molding) is the plastic toy that was requested.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在塑料玩具构建套件的背景下找到工厂方法模式在现实生活中的应用。用于构建塑料玩具的模具材料是相同的，但通过使用正确的塑料模具，可以生产出不同的玩具（不同的形状或图案）。这就像有一个工厂方法，其中输入是我们想要的玩具名称（例如，鸭子或汽车），输出（成型后）是我们请求的塑料玩具。
- en: In the software world, the Django web framework uses the factory method pattern
    for creating the fields of a web form. The `forms` module included in Django ([https://github.com/django/django/blob/main/django/forms/forms.py](https://github.com/django/django/blob/main/django/forms/forms.py))
    supports the creation of different kinds of fields (for example, `CharField`,
    `EmailField`, and so on). Parts of their behavior can be customized using attributes
    such as `max_length` and `required`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件世界中，Django Web 框架使用工厂方法模式来创建网页表单的字段。Django 包含的 `forms` 模块（[https://github.com/django/django/blob/main/django/forms/forms.py](https://github.com/django/django/blob/main/django/forms/forms.py)）支持创建不同类型的字段（例如，`CharField`、`EmailField`
    等）。它们的行为的一部分可以通过 `max_length` 和 `required` 等属性进行自定义。
- en: Use cases for the factory method pattern
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂方法模式的用例
- en: If you realize that you cannot track the objects created by your application
    because the code that creates them is in many different places instead of in a
    single function/method, you should consider using the factory method pattern.
    The factory method centralizes object creation and tracking your objects becomes
    much easier. Note that it is fine to create more than one factory method, and
    this is how it is typically done in practice. Each factory method logically groups
    the creation of objects that have similarities. For example, one factory method
    might be responsible for connecting you to different databases (MySQL, SQLite);
    another factory method might be responsible for creating the geometrical object
    that you request (circle, triangle); and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你意识到你无法追踪应用程序创建的对象，因为创建它们的代码分布在许多不同的地方而不是一个单独的函数/方法中，你应该考虑使用工厂方法模式。工厂方法集中了对象的创建，跟踪对象变得容易得多。请注意，创建多个工厂方法是完全可以接受的，这也是实践中通常的做法。每个工厂方法逻辑上分组创建具有相似性的对象。例如，一个工厂方法可能负责连接到不同的数据库（MySQL、SQLite）；另一个工厂方法可能负责创建你请求的几何对象（圆形、三角形）；等等。
- en: The factory method is also useful when you want to decouple object creation
    from object usage. We are not coupled to a specific class when creating an object;
    we just provide partial information about what we want by calling a function.
    This means that introducing changes to the function is easy and does not require
    any changes to the code that uses it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要将对象创建与对象使用解耦时，工厂方法也非常有用。在创建对象时，我们并不依赖于特定的类；我们只是通过调用一个函数来提供关于我们想要什么的部分信息。这意味着修改函数是容易的，并且不需要对其使用的代码进行任何更改。
- en: 'Another use case worth mentioning is related to improving the performance and
    memory usage of an application. A factory method can improve performance and memory
    usage by creating new objects only if it is necessary. When we create objects
    using a direct class instantiation, extra memory is allocated every time a new
    object is created (unless the class uses caching internally, which is usually
    not the case). We can see that in practice in the following code (`ch03/factory/id.py`),
    which creates two instances of the same class, `MyClass`, and uses the `id()`
    function to compare their memory addresses. The addresses are also printed in
    the output so that we can inspect them. The fact that the memory addresses are
    different means that two distinct objects are created. The code is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提及的使用案例与提高应用程序的性能和内存使用有关。工厂方法可以通过仅在必要时创建新对象来提高性能和内存使用。当我们使用直接类实例化创建对象时，每次创建新对象时都会分配额外的内存（除非类内部使用缓存，这通常不是情况）。我们可以在以下代码（`ch03/factory/id.py`）中看到这一点，该代码创建了`MyClass`类的两个实例，并使用`id()`函数比较它们的内存地址。地址也打印在输出中，以便我们可以检查它们。内存地址不同的事实意味着创建了两个不同的对象。代码如下：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Executing the code (`ch03/factory/id.py`) on my computer results in the following
    output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上执行代码（`ch03/factory/id.py`）的结果如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The addresses that you see if you execute the file, where the `id()` function
    is called, are not the same as the ones I see because they depend on the current
    memory layout and allocation. But the result must be the same—the two addresses
    should be different. There’s one exception that happens if you write and execute
    the code in the Python **Read-Eval-Print Loop** (**REPL**)—or, simply put, the
    interactive prompt—but that’s a REPL-specific optimization that does not happen
    normally.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行文件时看到的地址，其中调用了`id()`函数，与我看到的地址不同，因为它们依赖于当前的内存布局和分配。但结果必须相同——这两个地址应该是不同的。有一个例外，如果你在Python
    **读-求值-打印循环**（**REPL**）中编写和执行代码——或者简单地说，交互式提示符——那么那是一个REPL特定的优化，通常不会发生。
- en: Implementing the factory method pattern
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现工厂方法模式
- en: 'Data comes in many forms. There are two main file categories for storing/retrieving
    data: human-readable files and binary files. Examples of human-readable files
    are XML, RSS/Atom, YAML, and JSON. Examples of binary files are the `.sq3` file
    format used by SQLite and the `.mp3` audio file format used to listen to music.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以多种形式存在。存储/检索数据主要有两种文件类别：可读文件和二进制文件。可读文件的例子有XML、RSS/Atom、YAML和JSON。二进制文件的例子有SQLite使用的`.sq3`文件格式和用于听音乐的`.mp3`音频文件格式。
- en: In this example, we will focus on two popular human-readable formats—XML and
    JSON. Although human-readable files are generally slower to parse than binary
    files, they make data exchange, inspection, and modification much easier. For
    this reason, it is advised that you work with human-readable files unless there
    are other restrictions that do not allow it (mainly unacceptable performance or
    proprietary binary formats).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将关注两种流行的可读格式——XML和JSON。尽管可读文件通常比二进制文件解析速度慢，但它们使数据交换、检查和修改变得容易得多。因此，建议你在没有其他限制不允许的情况下（主要是不可接受的性能或专有二进制格式）与可读文件一起工作。
- en: In this case, we have some input data stored in an XML and a JSON file, and
    we want to parse them and retrieve some information. At the same time, we want
    to centralize the client’s connection to those (and all future) external services.
    We will use the factory method to solve this problem. The example focuses only
    on XML and JSON, but adding support for more services should be straightforward.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一些输入数据存储在XML和JSON文件中，我们想要解析它们并检索一些信息。同时，我们想要集中管理客户端对这些（以及所有未来的）外部服务的连接。我们将使用工厂方法来解决这个问题。示例仅关注XML和JSON，但添加对更多服务的支持应该是简单的。
- en: First, let’s look at the data files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看数据文件。
- en: 'The JSON file, `movies.json`, is a sample of a dataset containing information
    about American movies (title, year, director name, genre, and so on):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JSON文件，`movies.json`，是一个包含关于美国电影（标题、年份、导演姓名、类型等）信息的示例数据集：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The XML file, `person.xml`, contains information about individuals (`firstName`,
    `lastName`, `gender`, and so on), as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: XML文件，`person.xml`，包含有关个人（`firstName`、`lastName`、`gender`等）的信息，如下所示：
- en: 'We start with the enclosing tag of the `persons` XML container:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`persons` XML容器的封装标签开始：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, an XML element representing a person’s data code is presented as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一个表示个人数据代码的XML元素如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'An XML element representing another person’s data is shown by the following
    code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个表示另一个人数据的XML元素如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An XML element representing a third person’s data is shown by the following
    code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个表示第三个人数据的XML元素如下所示：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we close the XML container:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们关闭XML容器：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will use two libraries that are part of the Python distribution for working
    with JSON and XML: `json` and `xml.etree.ElementTree`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python发行版中用于处理JSON和XML的两个库：`json`和`xml.etree.ElementTree`。
- en: 'We start by importing what we need for the various manipulations (`json`, `ElementTree`,
    and `pathlib`), and we define a `JSONDataExtractor` class, loading the data from
    the file and using the `parsed_data` property to get it. That part of the code
    is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入所需的模块以进行各种操作（`json`、`ElementTree`和`pathlib`），并定义一个`JSONDataExtractor`类，从文件中加载数据，并使用`parsed_data`属性来获取它。这部分代码如下：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also define an `XMLDataExtractor` class, loading the data in the file via
    `ElementTree`’s parser, and using the `parsed_data` property to get the result,
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个`XMLDataExtractor`类，通过`ElementTree`的解析器加载文件中的数据，并使用`parsed_data`属性来获取结果，如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we provide the factory function that helps select the right data extractor
    class depending on the target file’s extension (or raise an exception if it is
    not supported), as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们提供工厂函数，该函数根据目标文件的扩展名选择正确的数据提取器类（如果不受支持，则抛出异常），如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we define the main function of our program, `extract()`; in the first
    part of the function, the code handles the JSON case, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们程序的主要函数，`extract()`；在函数的第一部分，代码处理JSON情况，如下所示：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We add the final part of the `extract()` function, working with the XML file
    using the factory method. XPath is used to find all person elements that have
    the last name `Liar`. For each matched person, the basic name and phone number
    information are shown. The code is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`extract()`函数的最后部分，使用工厂方法处理XML文件。使用XPath查找所有姓氏为`Liar`的个人元素。对于每个匹配的个人，显示基本姓名和电话号码信息。代码如下：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we add some testing code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一些测试代码：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is a summary of the implementation (in the `ch03/factory/factory_method.py`
    file):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现总结（在`ch03/factory/factory_method.py`文件中）：
- en: After importing the modules we need, we start by defining a JSON data extractor
    class (`JSONDataExtractor`) and an XML data extractor class (`XMLDataExtractor`).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入所需的模块后，我们首先定义一个JSON数据提取类（`JSONDataExtractor`）和一个XML数据提取类（`XMLDataExtractor`）。
- en: We add a factory function, `extract_factory()`, to get the right data extractor
    class to instantiate.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个工厂函数，`extract_factory()`，以获取正确的数据提取器类进行实例化。
- en: We also add our wrapper and main function, `extract()`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了我们的包装器和主函数，`extract()`。
- en: Finally, we add testing code, where we extract data from a JSON file and an
    XML file and parse the resulting text.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加测试代码，从JSON文件和XML文件中提取数据并解析结果文本。
- en: 'To test the example, run the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试示例，请运行以下命令：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should get the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that although `JSONDataExtractor` and `XMLDataExtractor` have the same
    interfaces, what is returned by `parsed_data()` is not handled in a uniform way;
    in one case we have a list, and in the other, we have a tree. Different Python
    code must be used to work with each data extractor. Although it would be nice
    to be able to use the same code for all extractors, this is not realistic for
    the most part unless we use some kind of common mapping for the data, which is
    often provided by external data providers. Assuming that you can use the same
    code for handling the XML and JSON files, what changes are required to support
    a third format—for example, SQLite? Find an SQLite file or create your own and
    try it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管`JSONDataExtractor`和`XMLDataExtractor`具有相同的接口，但`parsed_data()`返回的内容处理方式并不统一；在一种情况下我们有一个列表，在另一种情况下我们有一个树。必须使用不同的Python代码来处理每个数据提取器。虽然能够为所有提取器使用相同的代码会很理想，但在大多数情况下这是不现实的，除非我们使用某种类型的数据通用映射，这通常由外部数据提供者提供。假设你可以使用相同的代码来处理XML和JSON文件，那么为了支持第三种格式——例如SQLite，需要进行哪些更改？找到一个SQLite文件或创建自己的文件并尝试它。
- en: Should you use the factory method pattern?
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该使用工厂方法模式吗？
- en: The main critique that veteran Python developers often express toward the factory
    method pattern is that it can be considered over-engineered or unnecessarily complex
    for many use cases. Python’s dynamic typing and first-class functions often allow
    for simpler, more straightforward solutions to problems that the factory method
    aims to solve. In Python, you can often use simple functions or class methods
    to create objects directly without needing to create separate factory classes
    or functions. This keeps the code more readable and Pythonic, adhering to the
    language’s philosophy of *Simple is better* *than complex*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的 Python 开发者经常对工厂方法模式提出的主要批评是，它对于许多用例来说可能被认为是过度设计或过于复杂。Python 的动态类型和一等函数通常允许对工厂方法旨在解决的问题有更简单、更直接的方法。在
    Python 中，你通常可以直接使用简单函数或类方法来创建对象，而无需创建单独的工厂类或函数。这使代码更具可读性和 Python 风格，遵循语言“简单比复杂好”的哲学。
- en: Also, Python’s support for default arguments, keyword arguments, and other language
    features often makes it easier to extend constructors in a backward-compatible
    way, reducing the need for separate factory methods. So, while the factory method
    pattern is a well-established design pattern in statically typed languages such
    as Java or C++, it is often seen as too cumbersome or verbose for Python’s more
    flexible and dynamic nature.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python 对默认参数、关键字参数和其他语言特性的支持通常使得向后兼容地扩展构造函数变得更加容易，从而减少了单独工厂方法的需求。因此，虽然工厂方法模式是在静态类型语言（如
    Java 或 C++）中建立起来的一个良好的设计模式，但它通常被认为对于 Python 更灵活和动态的本质来说过于繁琐或冗长。
- en: 'To show how one could deal with simple use cases without the factory method
    pattern, an alternative implementation has been provided in the `ch03/factory/factory_method_not_needed.py`
    file. As you can see, there is no more factory. And the following extract from
    the code shows what we mean when we say that in Python, you just create objects
    where you need them, without an intermediary function or class, which makes your
    code more Pythonic:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示在没有工厂方法模式的情况下如何处理简单用例，已在 `ch03/factory/factory_method_not_needed.py` 文件中提供了一个替代实现。正如你所看到的，不再有工厂。以下代码摘录显示了当我们说在
    Python 中，你只需在需要的地方创建对象，而不需要一个中间函数或类，这使得你的代码更具 Python 风格的含义：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The abstract factory pattern
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The abstract factory pattern is a generalization of the factory method idea.
    Basically, an abstract factory is a (logical) group of factory methods, where
    each factory method is responsible for generating a different kind of object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式是工厂方法思想的泛化。基本上，抽象工厂是一组（逻辑）工厂方法，其中每个工厂方法负责生成不同类型的对象。
- en: We are going to discuss some examples, use cases, and a possible implementation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论一些示例、用例和可能的实现。
- en: Real-world examples
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: The abstract factory is used in car manufacturing. The same machinery is used
    for stamping the parts (doors, panels, hoods, fenders, and mirrors) of different
    car models. The model that is assembled by the machinery is configurable and easy
    to change at any time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂在汽车制造中得到了应用。相同的机器用于不同车型（车门、面板、引擎盖、挡泥板和镜子）的部件冲压。由机器组装的模型是可配置的，并且可以随时更改。
- en: In the software category, the `factory_boy` package ([https://github.com/FactoryBoy/factory_boy](https://github.com/FactoryBoy/factory_boy))
    provides an abstract factory implementation for creating Django models in tests.
    An alternative tool is `model_bakery` ([https://github.com/model-bakers/model_bakery](https://github.com/model-bakers/model_bakery)).
    Both packages are used for creating instances of models that support test-specific
    attributes. This is important because, this way, the readability of your tests
    is improved, and you avoid sharing unnecessary code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件类别中，`factory_boy` 包([https://github.com/FactoryBoy/factory_boy](https://github.com/FactoryBoy/factory_boy))为测试中创建
    Django 模型提供了一个抽象工厂实现。另一个工具是 `model_bakery` ([https://github.com/model-bakers/model_bakery](https://github.com/model-bakers/model_bakery))。这两个包都用于创建支持特定测试属性的模式实例。这很重要，因为这样，可以提高测试的可读性，并避免共享不必要的代码。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Django models are special classes used by the framework to help store and interact
    with data in the database (tab[les). See the Django documenta](https://docs.djangoproject.com)tion
    ([https://docs.djangoproject.com](https://docs.djangoproject.com)) for more details.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Django 模型是框架用来帮助存储和与数据库（表）中的数据交互的特殊类。有关更多详细信息，请参阅 Django 文档([https://docs.djangoproject.com](https://docs.djangoproject.com))。
- en: Use cases for the abstract factory pattern
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象工厂模式的使用案例
- en: 'Since the abstract factory pattern is a generalization of the factory method
    pattern, it offers the same benefits: it makes tracking an object creation easier,
    it decouples object creation from object usage, and it gives us the potential
    to improve the memory usage and performance of our application.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于抽象工厂模式是工厂方法模式的泛化，它提供了相同的优点：它使跟踪对象创建变得更容易，它将对象创建与对象使用解耦，并且它为我们提供了改进应用程序内存使用和性能的潜力。
- en: Implementing the abstract factory pattern
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现抽象工厂模式
- en: To demonstrate the abstract factory pattern, I will reuse one of my favorite
    examples, included in the book *Python 3 Patterns, Recipes and Idioms*, by Bruce
    Eckel. Imagine that we are creating a game or we want to include a mini-game as
    part of our application to entertain our users. We want to include at least two
    games, one for children and one for adults. We will decide which game to create
    and launch at runtime, based on user input. An abstract factory takes care of
    the game creation part.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示抽象工厂模式，我将重用我最喜欢的例子之一，它包含在Bruce Eckel所著的《Python 3 Patterns, Recipes and Idioms》一书中。想象一下，我们正在创建一个游戏，或者我们想在应用程序中包含一个迷你游戏来娱乐用户。我们希望包含至少两个游戏，一个供儿童玩，一个供成人玩。我们将根据用户输入在运行时决定创建和启动哪个游戏。抽象工厂负责游戏创建部分。
- en: 'Let’s start with the kids’ game. It is called `interact_with()` method is used
    to describe the interaction of the frog with an obstacle (for example, a bug,
    puzzle, and other frogs) as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从儿童游戏开始。它被称为`interact_with()`方法，用于描述青蛙与障碍（例如，虫子、谜题和其他青蛙）的交互，如下所示：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There can be many kinds of obstacles, but for our example, an obstacle can
    only be a bug. When the frog encounters a bug, only one action is supported. It
    eats it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有许多种障碍，但就我们的例子而言，障碍只能是一个虫子。当青蛙遇到虫子时，只支持一个动作。它会吃掉它：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `FrogWorld` class is an abstract factory. Its main responsibilities are
    creating the main character and the obstacle(s) in the game. Keeping the creation
    methods separate and their names generic (for example, `make_character()` and
    `make_obstacle()`) allows us to change the active factory (and, therefore, the
    active game) dynamically without any code changes. The code is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrogWorld`类是一个抽象工厂。其主要职责是创建游戏中的主要角色和障碍。将创建方法分开并使用通用的名称（例如，`make_character()`和`make_obstacle()`）允许我们动态地更改活动工厂（因此，活动游戏）而无需任何代码更改。代码如下：'
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The **WizardWorld** game is similar. The only difference is that the wizard
    battles against monsters such as orks instead of eating bugs!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**WizardWorld**游戏类似。唯一的区别是法师与食虫虫的怪物如兽人战斗，而不是吃虫子！'
- en: 'Here is the definition of the `Wizard` class, which is similar to the `Frog`
    one:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Wizard`类的定义，它与`Frog`类类似：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, the definition of the `Ork` class is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Ork`类的定义如下：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We also need to define a `WizardWorld` class, similar to the `FrogWorld` one
    that we have discussed; the obstacle, in this case, is an `Ork` instance:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义一个`WizardWorld`类，类似于我们讨论过的`FrogWorld`类；在这种情况下，障碍是一个`Ork`实例：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `GameEnvironment` class is the main entry point of our game. It accepts
    the factory as an input and uses it to create the world of the game. The `play()`
    method initiates the interaction between the created hero and the obstacle, as
    follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameEnvironment`类是我们游戏的主要入口点。它接受工厂作为输入，并使用它来创建游戏的世界。`play()`方法启动创建的英雄与障碍之间的交互，如下所示：'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `validate_age()` function prompts the user to give a valid age. If the
    age is not valid, it returns a tuple with the first element set to `False`. If
    the age is fine, the first element of the tuple is set to `True`, and that’s the
    case where we care about the second element of the tuple, which is the age given
    by the user, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_age()`函数提示用户输入有效的年龄。如果年龄无效，它返回一个元组，第一个元素设置为`False`。如果年龄有效，元组的第一个元素设置为`True`，这就是我们关注元组的第二个元素的情况，即用户输入的年龄，如下所示：'
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally comes the `main()` function definition, followed by calling it. It
    asks for the user’s name and age and decides which game should be played, given
    the age of the user, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是`main()`函数的定义，然后调用它。它询问用户的姓名和年龄，并根据用户的年龄决定应该玩哪个游戏，如下所示：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The summary for the implementation we just discussed (see the complete code
    in the `ch03/factory/abstract_factory.py` file) is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的实现总结（请参阅`ch03/factory/abstract_factory.py`文件中的完整代码）如下：
- en: We define `Frog` and `Bug` classes for the **FrogWorld** game.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为**FrogWorld**游戏定义了`Frog`和`Bug`类。
- en: We add a `FrogWorld` class, where we use our `Frog` and `Bug` classes.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个`FrogWorld`类，其中我们使用了我们的`Frog`和`Bug`类。
- en: We define `Wizard` and `Ork` classes for the **WizardWorld** game.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为**WizardWorld**游戏定义了`Wizard`和`Ork`类。
- en: We add a `WizardWorld` class, where we use our `Wizard` and `Ork` classes.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个`WizardWorld`类，其中我们使用了我们的`Wizard`和`Ork`类。
- en: We define a `GameEnvironment` class.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`GameEnvironment`类。
- en: We add a `validate_age()` function.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个`validate_age()`函数。
- en: 'Finally, we have the `main()` function, followed by the conventional trick
    for calling it. The following are the aspects of this function:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`main()`函数，接着是调用它的传统技巧。以下是这个函数的几个方面：
- en: We get the user’s input for name and age.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获取用户的姓名和年龄输入。
- en: We decide which game class to use based on the user’s age.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们根据用户的年龄决定使用哪个游戏类。
- en: We instantiate the right game class, and then the `GameEnvironment` class.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实例化正确的游戏类，然后是`GameEnvironment`类。
- en: We call `.play()` on the `environment` object to play the game.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`environment`对象上调用`.play()`来玩游戏。
- en: Let’s call this program using the `python ch03/factory/abstract_factory.py`
    command and see some sample output.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`python ch03/factory/abstract_factory.py`命令调用这个程序，并查看一些示例输出。
- en: 'The sample output for a teenager is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 青少年的示例输出如下：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The sample output for an adult is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 成人的示例输出如下：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Try extending the game to make it more complete. You can go as far as you want;
    create many obstacles, many enemies, and whatever else you like.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试扩展游戏使其更加完整。你可以做到你想做的程度；创建许多障碍、许多敌人，以及你喜欢的任何其他东西。
- en: The builder pattern
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建器模式
- en: We just covered the first two creational patterns, the factory method and the
    abstract factory, which both offer approaches to improve the way we create objects
    in nontrivial cases.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了前两种创建型模式，即工厂方法和抽象工厂方法，它们都提供了在非平凡情况下改进我们创建对象的方法。
- en: Now, imagine that we want to create an object that is composed of multiple parts,
    and the composition needs to be done step by step. The object is not complete
    unless all its parts are fully created. That’s where the builder design pattern
    can help us. The builder pattern separates the construction of a complex object
    from its representation. By keeping the construction separate from the representation,
    the same construction can be used to create several different representations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要创建一个由多个部分组成的对象，并且组合需要逐步完成。除非所有部分都完全创建，否则对象不是完整的。这就是构建器设计模式能帮助我们的地方。构建器设计模式将复杂对象的构建与其表示分离。通过将构建与表示分离，相同的构建可以用来创建几个不同的表示。
- en: Real-world examples
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: In our everyday life, the builder design pattern is used in fast-food restaurants.
    The same procedure is always used to prepare a burger and the packaging (box and
    paper bag), even if there are many kinds of burgers (classic, cheeseburger, and
    more) and different packages (small-sized box, medium-sized box, and so forth).
    The difference between a classic burger and a cheeseburger is in the representation
    and not in the construction procedure. In this case, the director is the cashier
    who gives instructions about what needs to be prepared to the crew, and the builder
    is the person from the crew who takes care of the specific order.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日常生活中，构建器设计模式在快餐店中被使用。制作汉堡和包装（盒子和平装袋）的相同程序总是被使用，即使有各种各样的汉堡（经典汉堡、芝士汉堡等等）和不同的包装（小号盒子、中号盒子等等）。经典汉堡和芝士汉堡之间的区别在于表示，而不是构建过程。在这种情况下，导演是收银员，他向工作人员下达需要准备的指令，而构建者是负责特定订单的工作人员。
- en: In so[ftware, we can think of the `django-query-builder` li](https://github.com/ambitioninc/django-query-builder)brary
    ([https://github.com/ambitioninc/django-query-builder](https://github.com/ambitioninc/django-query-builder)),
    a third-party Django library that relies on the builder pattern. This library
    can be used for building SQL queries dynamically, allowing you to control all
    aspects of a query and create a different range of queries, from simple to very
    complex ones.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在[软件](https://github.com/ambitioninc/django-query-builder)中，我们可以考虑`django-query-builder`库([https://github.com/ambitioninc/django-query-builder](https://github.com/ambitioninc/django-query-builder))，这是一个依赖构建器模式的第三方Django库。这个库可以用来动态构建SQL查询，允许你控制查询的所有方面，并创建从简单到非常复杂的各种查询。
- en: Comparison with the factory pattern
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与工厂模式的比较
- en: At this point, the distinction between the builder pattern and the factory pattern
    might not be very clear. The main difference is that a factory pattern creates
    an object in a single step, whereas a builder pattern creates an object in multiple
    steps and almost always uses a *director*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，构建器模式和工厂模式之间的区别可能不是很清楚。主要区别是，工厂模式在单步中创建对象，而构建器模式在多步中创建对象，并且几乎总是使用一个*导演*。
- en: Another difference is that while the factory pattern returns a created object
    immediately, in the builder pattern, the client code explicitly asks the director
    to return the final object when it needs it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，虽然工厂模式立即返回创建的对象，但在构建器模式中，客户端代码明确要求导演在需要时返回最终对象。
- en: Use cases for the builder pattern
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建器模式的用例
- en: The builder pattern is particularly useful when an object needs to be constructed
    with numerous possible configurations. A typical case is a situation where a class
    has multiple constructors with a varying number of parameters, often leading to
    confusion or error-prone code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象需要用许多可能的配置构建时，构建器模式特别有用。一个典型的情况是，一个类有多个构造函数，参数数量不同，这往往会导致混淆或容易出错的代码。
- en: The pattern is also beneficial when the object’s construction process is more
    complex than simply setting initial values. For example, if an object’s full creation
    involves multiple steps, such as parameter validation, setting up data structures,
    or even making calls to external services, the builder pattern can encapsulate
    this complexity.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象的构建过程比简单地设置初始值更复杂时，该模式也有益。例如，如果一个对象的完整创建涉及多个步骤，如参数验证、设置数据结构或甚至调用外部服务，构建器模式可以封装这种复杂性。
- en: Implementing the builder pattern
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现构建器模式
- en: Let’s see how we can use the builder design pattern to make a pizza-ordering
    application. This example is particularly interesting because a pizza is prepared
    in steps that should follow a specific order. To add the sauce, you first need
    to prepare the dough. To add the topping, you first need to add the sauce. And
    you can’t start baking the pizza unless both the sauce and the topping are placed
    on the dough. Moreover, each pizza usually requires a different baking time, depending
    on the thickness of its dough and the topping used.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用构建器设计模式来制作一个点餐应用程序。这个例子特别有趣，因为披萨的制备需要遵循特定的顺序。要加酱料，你首先需要准备面团。要加配料，你首先需要加酱料。除非酱料和配料都放在面团上，否则你不能开始烤披萨。此外，每块披萨通常需要不同的烘烤时间，这取决于面团的厚度和使用的配料。
- en: 'We start by importing the required modules and declaring a few `Enum` parameters
    plus a constant that is used many times in the application. The `STEP_DELAY` constant
    is used to add a time delay between the different steps of preparing a pizza (prepare
    the dough, add the sauce, and so on) as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入所需的模块，并声明一些`Enum`参数以及一个在应用程序中多次使用的常量。`STEP_DELAY`常量用于在准备披萨的不同步骤之间添加时间延迟，如下所示：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our end product is a pizza, which is described by the `Pizza` class. When using
    the builder pattern, the end product does not have many responsibilities, since
    it is not supposed to be instantiated directly. A builder creates an instance
    of the end product and makes sure that it is properly prepared. That’s why the
    `Pizza` class is so minimal. It basically initializes all data to sane default
    values. An exception is the `prepare_dough()` method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的产品是披萨，由`Pizza`类描述。当使用构建器模式时，最终产品没有很多责任，因为它不应该直接实例化。构建器创建最终产品的实例，并确保它被正确准备。这就是为什么`Pizza`类如此极简。它基本上将所有数据初始化为合理的默认值。一个例外是`prepare_dough()`方法。
- en: The `prepare_dough()` method is defined in the `Pizza` class instead of a builder
    for two reasons. First, to clarify the fact that the end product is typically
    minimal, which does not mean that you should never assign it any responsibilities.
    Second, to promote code reuse through composition.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepare_dough()`方法定义在`Pizza`类中而不是构建器中，有两个原因。首先，为了阐明最终产品通常是极简的，这并不意味着你永远不应该给它分配任何责任。其次，为了通过组合来促进代码重用。'
- en: 'So, we define our `Pizza` class as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义我们的`Pizza`类如下：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are two builders: one for creating a margarita pizza (`MargaritaBuilder`)
    and another for creating a creamy bacon pizza (`CreamyBaconBuilder`). Each builder
    creates a `Pizza` instance and contains methods that follow the pizza-making procedure:
    `prepare_dough()`, `add_sauce()`, `add_topping()`, and `bake()`. To be precise,
    `prepare_dough()` is just a wrapper to the `prepare_dough()` method of the `Pizza`
    class.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个构建器：一个用于创建玛格丽塔披萨（`MargaritaBuilder`）和另一个用于创建奶油培根披萨（`CreamyBaconBuilder`）。每个构建器创建一个
    `Pizza` 实例，并包含遵循披萨制作程序的各个方法：`prepare_dough()`、`add_sauce()`、`add_topping()` 和
    `bake()`。更准确地说，`prepare_dough()` 只是 `Pizza` 类中 `prepare_dough()` 方法的包装。
- en: Notice how each builder takes care of all the pizza-specific details. For example,
    the topping of the margarita pizza is double mozzarella and oregano, while the
    topping of the creamy bacon pizza is mozzarella, bacon, ham, mushrooms, red onion,
    and oregano.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个构建器如何处理所有与披萨相关的细节。例如，玛格丽塔披萨的配料是双份马苏里拉奶酪和牛至，而奶油培根披萨的配料是马苏里拉奶酪、培根、火腿、蘑菇、红洋葱和牛至。
- en: 'An extract of the code of the `MargaritaBuilder` class is as follows (see the
    `ch03/builder.py` file for the whole code):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`MargaritaBuilder` 类的代码片段如下（完整的代码请参阅 `ch03/builder.py` 文件）：'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An extract of the code of the `CreamyBaconBuilder` class is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreamyBaconBuilder` 类的代码片段如下：'
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The *director* in this example is the waiter. The core of the `Waiter` class
    is the `construct_pizza()` method, which accepts a builder as a parameter and
    executes all the pizza-preparation steps in the right order. Choosing the appropriate
    builder, which can even be done at runtime, gives us the ability to create different
    pizza styles without modifying any of the code of the director (`Waiter`). The
    `Waiter` class also contains the `pizza()` method, which returns the end product
    (prepared pizza) as a variable to the caller. The code for that class is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，*导演* 是服务员。`Waiter` 类的核心是 `construct_pizza()` 方法，它接受一个构建器作为参数并按正确顺序执行所有披萨准备步骤。选择合适的构建器，甚至可以在运行时完成，这使我们能够创建不同的披萨风格，而无需修改导演（`Waiter`）的任何代码。`Waiter`
    类还包含 `pizza()` 方法，该方法将最终产品（准备好的披萨）作为变量返回给调用者。该类的代码如下：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `validate_style()` method is similar to the `validate_age()` function,
    as described in the section titled *The factory pattern* earlier in this chapter.
    It is used to make sure that the user gives valid input, which in this case is
    a character that is mapped to a pizza builder. The `m` character uses the `MargaritaBuilder`
    class, and the `c` character uses the `CreamyBaconBuilder` class. These mappings
    are in the `builder` parameter. A tuple is returned, with the first element set
    to `True` if the input is valid or `False` if it is invalid, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_style()` 方法与本章前面标题为 *工厂模式* 的部分中描述的 `validate_age()` 函数类似。它用于确保用户输入有效，在这种情况下是一个映射到披萨构建器的字符。`m`
    字符使用 `MargaritaBuilder` 类，而 `c` 字符使用 `CreamyBaconBuilder` 类。这些映射在 `builder` 参数中。返回一个元组，第一个元素设置为
    `True` 如果输入有效或 `False` 如果无效，如下所示：'
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last part is the `main()` function. The `main()` function contains code
    for instantiating a pizza builder. The pizza builder is then used by the `Waiter`
    director to prepare the pizza. The created pizza can be delivered to the client
    at any later point:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是 `main()` 函数。`main()` 函数包含实例化披萨构建器的代码。然后，`Waiter` 导演使用披萨构建器准备披萨。创建的披萨可以在任何后续时间点交付给客户：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is a summary of the implementation (in the `ch03/builder.py` file):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现总结（在 `ch03/builder.py` 文件中）：
- en: We start with a couple of imports we need, for the standard `Enum` class and
    `time` module.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始于需要的一些导入，对于标准的 `Enum` 类和 `time` 模块。
- en: 'We declare variables for a few constants: `PizzaProgress`, `PizzaDough`, `PizzaSauce`,
    `PizzaTopping`, and `STEP_DELAY`.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一些常量的变量：`PizzaProgress`、`PizzaDough`、`PizzaSauce`、`PizzaTopping` 和 `STEP_DELAY`。
- en: We define our `Pizza` class.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了我们的 `Pizza` 类。
- en: We define classes for two builders, `MargaritaBuilder` and `CreamyBaconBuilder`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为两个构建器定义了类，`MargaritaBuilder` 和 `CreamyBaconBuilder`。
- en: We define our `Waiter` class.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了我们的 `Waiter` 类。
- en: We add a `validate_style()` function to improve things regarding exception handling.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个 `validate_style()` 函数来改进异常处理。
- en: 'Finally, we have the `main()` function, followed by a snippet for calling it
    when the program is run. In the `main()` function, the following happens:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有 `main()` 函数，随后是程序运行时调用它的代码片段。在 `main()` 函数中，以下操作发生：
- en: We make it possible to choose the pizza builder based on the user’s input, after
    validation via the `validate_style()` function.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过`validate_style()`函数进行验证后，使它能够根据用户的输入选择披萨构建器。
- en: The pizza builder is used by the waiter for preparing the pizza.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务员使用披萨构建器来准备披萨。
- en: The created pizza is then delivered.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后将制作的披萨送出。
- en: 'Here is the output produced by calling the `python ch03/builder.py` command
    to execute this example program:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是调用`python ch03/builder.py`命令执行此示例程序产生的输出：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That was a nice result.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的结果。
- en: But... supporting only two pizza types is a shame. Feel like getting a Hawaiian
    pizza builder? Consider using *inheritance* after thinking about the advantages
    and disadvantages. Or *composition*, which has its advantages, as we have seen
    in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017), *Foundational* *Design Principles*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是...只支持两种披萨类型是件遗憾的事。想要一个夏威夷披萨构建器吗？在考虑了优势和劣势之后，考虑使用*继承*。或者*组合*，正如我们在[*第一章*](B21896_01.xhtml#_idTextAnchor017)中看到的，它有其优势。
- en: The prototype pattern
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式
- en: The prototype pattern allows you to create new objects by copying existing ones,
    rather than creating them from scratch. This pattern is particularly useful when
    the cost of initializing an object is more expensive or complex than copying an
    existing one. In essence, the prototype pattern enables you to create a new instance
    of a class by duplicating an existing instance, thereby avoiding the overhead
    of initializing a new object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式允许您通过复制现有对象来创建新对象，而不是从头开始创建。当初始化对象的成本比复制现有对象更昂贵或更复杂时，此模式特别有用。本质上，原型模式通过复制现有实例来创建类的新的实例，从而避免了初始化新对象的额外开销。
- en: In its simplest version, this pattern is just a `clone()` function that accepts
    an object as an input parameter and returns a clone of it. In Python, this can
    be done using the `copy.deepcopy()` function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的版本中，这个模式只是一个接受对象作为输入参数并返回其副本的`clone()`函数。在Python中，可以使用`copy.deepcopy()`函数来实现这一点。
- en: Real-world examples
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实世界的例子
- en: Cloning a plant by taking a cutting is a real-world example of the prototype
    pattern. Using this approach, you don’t grow the plant from a seed; you create
    a new plant that’s a copy of an existing one.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过剪枝繁殖植物是原型模式的一个真实世界的例子。使用这种方法，你不是从种子中生长植物；而是创建一个新的植物，它是现有植物的副本。
- en: Many Python applications make use of the prototype pattern, but it is rarely
    referred to as *prototype* since cloning objects is a built-in feature of the
    Python language.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python应用程序都使用原型模式，但很少将其称为*原型*，因为克隆对象是Python语言的一个内置功能。
- en: Use cases for the prototype pattern
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型模式的用例
- en: The prototype pattern is useful when we have an existing object that needs to
    stay untouched and we want to create an exact copy of it, allowing changes in
    some parts of the copy.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个需要保持不变且我们想要创建其精确副本的现有对象时，原型模式非常有用，允许在副本的某些部分进行更改。
- en: There is also the frequent need for duplicating an object that is populated
    from a database and has references to other database-based objects. It is costly
    (multiple queries to a database) to clone such a complex object, so a prototype
    is a convenient way to solve the problem.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从数据库中复制并具有对其他基于数据库的对象引用的对象外，还需要频繁地复制对象。克隆这样一个复杂的对象成本很高（对数据库进行多次查询），因此原型是一个方便解决问题的方法。
- en: Implementing the prototype pattern
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现原型模式
- en: Nowadays, some organizations, even of small size, deal with many websites and
    apps via their infrastructure/DevOps teams, hosting providers, or **cloud service**
    **providers** (**CSPs**).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一些组织，甚至规模较小的组织，通过其基础设施/DevOps团队、托管提供商或**云服务提供商**（**CSPs**）处理许多网站和应用。
- en: When you have to manage multiple websites, there is a point where it becomes
    difficult to follow. You need to access information quickly, such as IP addresses
    that are involved, domain names and their expiration dates, and maybe details
    about DNS parameters. So, you need a kind of inventory tool.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须管理多个网站时，有一个点变得难以跟踪。你需要快速访问信息，比如涉及的IP地址、域名及其到期日期，以及DNS参数的详细信息。因此，你需要一种库存工具。
- en: Let’s imagine how these teams deal with this type of data for daily activities,
    and touch on the implementation of a piece of software that helps consolidate
    and maintain the data (other than in Excel spreadsheets).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下这些团队如何处理这种类型的数据以进行日常活动，并简要讨论实现一个帮助整合和维护数据的软件（除了Excel表格之外）。
- en: 'First, we need to import Python’s standard `copy` module, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入Python的标准`copy`模块，如下所示：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At the heart of this system, we will have a `Website` class for holding all
    useful information such as the name, the domain name, a description, the author
    of a website we are managing, and so on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统的核心，我们将有一个`Website`类来存储所有有用的信息，例如名称、域名、描述、我们管理的网站的作者等。
- en: 'In the `__init__()` method of the class, only some parameters are fixed: `name`,
    `domain`, and `description`. But we also want flexibility, and client code can
    pass more parameters in the form of keywords (`name=value`) using the `kwargs`
    variable-length collection (each pair becomes an item of the `kwargs` Python dictionary).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的`__init__()`方法中，只有一些参数是固定的：`name`、`domain`和`description`。但我们还希望有灵活性，客户端代码可以使用`kwargs`变量长度集合（每个对成为`kwargs`
    Python 字典的一项）以`name=value`的形式传递更多参数。
- en: Additional information
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 其他信息
- en: 'There is a Python idiom that helps to set an arbitrary attribute named `attr`
    with a `val` value on an `obj` object, using the `setattr()` built-in function:
    `setattr(obj,` `attr, val)`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个帮助在`obj`对象上设置任意属性名为`attr`、值为`val`的惯用语，使用内置的`setattr()`函数：`setattr(obj,
    attr, val)`。
- en: 'So we are defining a `Website` class and initializing its objects, using the
    `setattr` technique for optional attributes, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个`Website`类并初始化其对象，使用`setattr`技术为可选属性，如下所示：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That’s not all. To improve the usability of the class, we also add its string
    representation method (`__str__()`). We extract the values of all instance attributes,
    using the `vars()` trick, and inject those values into the string that the method
    returns. Also, since we plan to clone objects, we include the object’s memory
    address using the `id()` function. The code is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不算完。为了提高类的可用性，我们还添加了其字符串表示方法（`__str__()`）。我们使用`vars()`技巧提取所有实例属性的值，并将这些值注入方法返回的字符串中。此外，由于我们计划克隆对象，我们还使用`id()`函数包含对象的内存地址。代码如下：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Additional information
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 其他信息
- en: The `vars()` function in Python returns the `__dict__` attribute of an object.
    The `__dict__` attribute is a dictionary containing the object’s attributes (both
    data attributes and methods). This function is useful for debugging, as it allows
    you to inspect the attributes and methods of an object or the local variables
    within a function. But note that not all objects have a `__dict__` attribute.
    For example, built-in types such as lists and dictionaries do not have this attribute.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`vars()`函数返回对象的`__dict__`属性。`__dict__`属性是一个包含对象属性（数据属性和方法）的字典。这个函数对于调试很有用，因为它允许你检查对象或函数内的局部变量的属性和方法。但请注意，并非所有对象都有`__dict__`属性。例如，列表和字典等内置类型没有这个属性。
- en: Next, we add a `Prototype` class that implements the prototype design pattern.
    At the heart of this class, we have the `clone()` method, which is in charge of
    cloning the object using the `copy.deepcopy()` function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个实现原型设计模式的`Prototype`类。在这个类的核心，我们有`clone()`方法，它负责使用`copy.deepcopy()`函数克隆对象。
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When we clone an object using `copy.deepcopy()`, the memory address of the clone
    must be different from the memory address of the original object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`copy.deepcopy()`克隆对象时，克隆对象的内存地址必须与原始对象的内存地址不同。
- en: 'Since cloning means that we allow setting values for optional attributes, notice
    how we use the `setattr` technique here with the `attrs` dictionary. Also, for
    more convenience, the `Prototype` class contains the `register()` and `unregister()`
    methods, which can be used to keep track of the cloned objects in a registry (a
    dictionary). The code of that class is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于克隆意味着我们允许为可选属性设置值，请注意我们在这里如何使用`setattr`技术与`attrs`字典。此外，为了方便起见，`Prototype`类包含`register()`和`unregister()`方法，这些方法可以用来跟踪注册表（字典）中的克隆对象。该类的代码如下：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `main()` function, which we define next, we complete the program: we
    clone a first `Website` instance, `site1`, to get a second object `site2`. Basically,
    we instantiate the `Prototype` class and we use its `.clone()` method. Then, we
    display the result. The code for that function is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来定义的`main()`函数中，我们完成程序：我们克隆一个`Website`实例，命名为`site1`，以获取第二个对象`site2`。基本上，我们实例化`Prototype`类，并使用其`.clone()`方法。然后，我们显示结果。该函数的代码如下：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we call the `main()` function, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`main()`函数，如下所示：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is a summary of what we do in the code (`ch03/prototype.py`):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对我们在代码中执行的操作的总结（`ch03/prototype.py`）：
- en: We start by importing the `copy` module.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入`copy`模块。
- en: We define a `Website` class, with its initialization method (`__init__()`) and
    its string representation method (`__str__()`).
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`Website`类，它具有初始化方法（`__init__()`）和字符串表示方法（`__str__()`）。
- en: We define our `Prototype` class as shown earlier.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了前面展示的`Prototype`类。
- en: 'Then, we have the `main()` function, where we do the following:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有`main()`函数，其中我们执行以下操作：
- en: We define a `keywords` list we need.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了我们需要的`keywords`列表。
- en: We create an instance of the `Website` class, called `site1` (we use the `keywords`
    list here).
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建`Website`类的实例，称为`site1`（这里我们使用`keywords`列表）。
- en: We create a `Prototype` object and we use its `register()` method to register
    `site1` with its identifier (this helps us keep track of the cloned objects in
    a dictionary).
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个`Prototype`对象，并使用其`register()`方法将`site1`及其标识符注册（这有助于我们跟踪字典中的克隆对象）。
- en: We clone the `site1` object to get `site2`.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们克隆`site1`对象以获得`site2`。
- en: We display the result (both `Website` objects).
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们显示结果（两个`Website`对象）。
- en: 'A sample output when I execute the `python ch03/prototype.py` command on my
    computer is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在电脑上执行`python ch03/prototype.py`命令时的一个示例输出如下：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Indeed, `Prototype` works as expected. We can see information about the original
    `Website` object and its clone.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`Prototype`按预期工作。我们可以看到原始`Website`对象及其克隆的信息。
- en: And looking at the ID value for each `Website` object, we can see that the two
    addresses are different.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看每个`Website`对象的ID值，我们可以看到两个地址是不同的。
- en: The singleton pattern
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: One of the original design patterns for OOP, the singleton pattern restricts
    the instantiation of a class to *one* object, which is useful when you need one
    object to coordinate actions for the system.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是面向对象编程的一个原始设计模式，它限制了一个类的实例化只能有一个对象，这在需要单个对象来协调系统动作时非常有用。
- en: The basic idea is that only one instance of a particular class, doing a job,
    is created for the needs of the program. To ensure that this works, we need mechanisms
    that prevent the instantiation of the class more than once and also prevent cloning.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是，为了满足程序的需求，只为特定类创建一个执行特定工作的实例。为了确保这一点，我们需要防止类被多次实例化和克隆的机制。
- en: In the Python programmer community, the singleton pattern is actually considered
    an anti-pattern. Let’s explore the pattern first, and later we will discuss the
    alternative approaches we are encouraged to use in Python.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python程序员社区中，单例模式实际上被认为是一种反模式。让我们首先探讨这个模式，然后我们将讨论我们被鼓励在Python中使用的替代方法。
- en: Real-world examples
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: In a real-life scenario, we can think of the captain of a ship or a boat. On
    the ship, they are the ones in charge. They are responsible for important decisions,
    and a number of requests are directed to them because of this responsibility.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们可以想到一艘船或船的船长。在船上，他们是负责人。他们负责重要的决策，并且由于这个责任，许多请求都指向他们。
- en: Another example is the printer spooler, in an office environment, which ensures
    that print jobs are coordinated through a single point, avoiding conflicts and
    ensuring orderly printing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是办公室环境中的打印机打印队列，它确保打印作业通过一个单一点协调，避免冲突并确保有序打印。
- en: Use cases for the singleton pattern
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式的用例
- en: The singleton design pattern is useful when you need to create only one object
    or you need some sort of object capable of maintaining a global state for your
    program.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 单例设计模式在你需要创建单个对象或需要某种能够维护程序全局状态的对象时非常有用。
- en: 'Other possible use cases are the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能的用例如下：
- en: Controlling concurrent access to a shared resource—for example, the class managing
    the connection to a database
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对共享资源的并发访问——例如，管理数据库连接的类
- en: A service or resource that is transversal in the sense that it can be accessed
    from different parts of the application or by different users and do its work—for
    example, the class at the core of a logging system or utility
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种跨越应用程序不同部分或不同用户访问的服务或资源，并执行其工作——例如，日志系统或实用程序的核心类
- en: Implementing the singleton pattern
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现单例模式
- en: As discussed, the singleton pattern ensures that a class has only one instance
    and provides a global point to access it. In this example, we’ll create a `URLFetcher`
    class that fetches content from web pages. We want to ensure that only one instance
    of this class exists to keep track of all fetched URLs.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，单例模式确保一个类只有一个实例，并提供了一个全局点来访问它。在这个例子中，我们将创建一个 `URLFetcher` 类，用于从网页获取内容。我们希望确保只有一个此类实例存在，以跟踪所有获取的
    URL。
- en: Imagine you have multiple fetchers in different parts of your program, but you
    want to keep track of all URLs that have been fetched. This is a classic case
    for a singleton pattern. By ensuring that all parts of your program use the same
    fetcher instance, you can easily keep track of all fetched URLs in one place.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在程序的多个部分有多个获取器，但你希望跟踪所有已获取的 URL。这是一个单例模式的典型用例。通过确保程序的所有部分都使用相同的获取器实例，你可以轻松地在同一位置跟踪所有已获取的
    URL。
- en: 'Initially, we create a naive version of the `URLFetcher` class. This class
    has a `fetch()` method that fetches the web page content and stores the URL in
    a list:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们创建了一个简单的 `URLFetcher` 类。这个类有一个 `fetch()` 方法，用于获取网页内容并将 URL 存储在列表中：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To check if our class is a `is` operator. If they are the same, then it’s a
    singleton:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的类是否是 `is` 操作符。如果它们相同，那么它就是一个单例：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you run this code (`ch03/singleton/before_singleton.py`), you’ll see that
    the output is the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码 (`ch03/singleton/before_singleton.py`)，你会看到以下输出：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This output shows that the class in this version does not yet respect the singleton
    pattern. To make it a singleton, we’ll use the **metaclass** technique.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示，在这个版本中，类还没有遵循单例模式。为了使其成为单例，我们将使用 **元类** 技术。
- en: Additional information
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 其他信息
- en: A metaclass in Python is a class of a class that defines how a class behaves.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的元类是一个定义了类如何行为的类。
- en: 'We’ll create a `SingletonType` metaclass that ensures that only one instance
    of `URLFetcher` exists, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `SingletonType` 元类，确保只有一个 `URLFetcher` 实例存在，如下所示：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we modify our `URLFetcher` class to use this metaclass, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们修改我们的 `URLFetcher` 类以使用这个元类，如下所示：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we create a `main()` function and call it to test our singleton, with
    the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个 `main()` 函数并调用它来测试我们的单例，代码如下：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is a summary of what we do in the code (`ch03``/singleton/singleton.py`):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在代码中执行的操作的总结 (`ch03``/singleton/singleton.py`)：
- en: We start with our needed module imports (`urllib.request`).
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从所需的模块导入开始 (`urllib.request`)。
- en: We define a `SingletonType` class, with its special `__call__()` method.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个 `SingletonType` 类，它有一个特殊的 `__call__()` 方法。
- en: We define `URLFetcher`, the class implementing the fetcher for the web pages,
    initializing it with the `urls` attribute; as discussed, we add its `fetch()`
    method.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了 `URLFetcher` 类，该类实现了网页的获取器，并通过 `urls` 属性初始化它；如前所述，我们添加了它的 `fetch()` 方法。
- en: Lastly, we add our `main()` function, and we add Python’s conventional snippet
    used to call it.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加了我们的 `main()` 函数，并添加了 Python 中用于调用它的传统代码片段。
- en: 'To test the implementation, run the `python ch03/singleton/singleton.py` command.
    You should get the following output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试实现，运行 `python ch03/singleton/singleton.py` 命令。你应该得到以下输出：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In addition, you will find that a file called `content.html` has been created,
    with the HTML text that comes from the different URLs added to it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你将发现已创建了一个名为 `content.html` 的文件，其中包含了来自不同 URL 的 HTML 文本。
- en: So, the program did its job as expected. This is a demonstration of how the
    singleton pattern may be used.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，程序按预期完成了任务。这是一个演示如何使用单例模式的例子。
- en: Should you use the singleton pattern?
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该使用单例模式吗？
- en: 'While the singleton pattern has its merits, it may not always be the most Pythonic
    approach to managing global states or resources. Our implementation example worked,
    but if we stop a minute to analyze the code again, we notice the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单例模式有其优点，但它可能并不总是管理全局状态或资源的最 Pythonic 方法。我们的实现示例是有效的，但如果我们停下来再次分析代码，我们会注意到以下情况：
- en: The techniques used for the implementation are rather advanced and not easy
    to explain to a beginner
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现所用的技术相当高级，不易向初学者解释。
- en: By reading the `SingletonType` class definition, it is not easy to immediately
    see that it provides a metaclass for a singleton if the name does not suggest
    it
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过阅读 `SingletonType` 类的定义，如果不看名字，你可能不会立即看出它提供了一个单例的元类。
- en: 'In Python, developers often prefer a simpler alternative to singleton: using
    a module-level global object.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，开发者通常更喜欢单例的简单替代方案：使用模块级全局对象。
- en: Note
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Python modules act as natural namespaces that can contain variables, functions,
    and classes, making them ideal for organizing and sharing global resources.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块充当自然命名空间，可以包含变量、函数和类，这使得它们非常适合组织和共享全局资源。
- en: By adopting the global object technique, as explained by Brandon Rhodes in what
    he calls the *Global Object Pattern* ([https://python-patterns.guide/python/module-globals/](https://python-patterns.guide/python/module-globals/)),
    you can achieve the same result as the singleton pattern without the need for
    complex instantiation processes or forcing a class to only have one instance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用全局对象技术，正如布兰登·罗德斯在其所谓的*全局对象模式*（[https://python-patterns.guide/python/module-globals/](https://python-patterns.guide/python/module-globals/））中解释的那样，你可以在不需要复杂实例化过程或迫使一个类只有一个实例的情况下，达到单例模式相同的结果。
- en: As an exercise, you can re-write the implementation of our example using a global
    object. For reference, the equivalent code, defining a global object, is provided
    in the `ch03/singleton/instead_of_singleton/example.py` file; for its use, check
    the `ch03/singleton/instead_of_singleton/use_example.py` file.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以使用全局对象重写我们示例的实现。为了参考，定义全局对象的等效代码在`ch03/singleton/instead_of_singleton/example.py`文件中；有关其使用，请查看`ch03/singleton/instead_of_singleton/use_example.py`文件。
- en: The object pool pattern
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池模式
- en: The object pool pattern is a creational design pattern that allows you to reuse
    existing objects instead of creating new ones when they are needed. This pattern
    is particularly useful when the cost, in terms of system resources, time, and
    so on of initializing a new object is high.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池模式是一种创建型设计模式，它允许你在需要时重用现有对象，而不是创建新的对象。这种模式在初始化新对象在系统资源、时间等方面的成本较高时特别有用。
- en: Real-world examples
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界中的例子
- en: Consider a car rental service. When a customer rents a car, the service doesn’t
    manufacture a new car for them. Instead, it provides one from a pool of available
    cars. Once the customer returns the car, it goes back into the pool, ready to
    be used by the next customer.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个汽车租赁服务。当客户租车时，服务不会为他们制造一辆新车。相反，它从可用的汽车池中提供一辆。一旦客户归还了汽车，它就会回到池中，准备好供下一个客户使用。
- en: Another example would be a public swimming pool. Rather than filling the pool
    with water every time someone wants to swim, the water is treated and reused for
    multiple swimmers. This saves both time and resources.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是一个公共游泳池。而不是每次有人想要游泳时都往游泳池里加水，而是对水进行处理并重复使用，供多个游泳者使用。这既节省了时间又节省了资源。
- en: Use cases for the object pool pattern
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象池模式的用例
- en: The object pool pattern is especially useful in scenarios where resource initialization
    is costly or time-consuming. This could be in terms of CPU cycles, memory usage,
    or even network bandwidth. For example, in a shooting video game, you might use
    this pattern to manage bullet objects. Creating a new bullet every time a gun
    is fired could be resource-intensive. Instead, you could have a pool of bullet
    objects that are reused.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池模式在资源初始化成本高昂或耗时的情况下特别有用。这可能涉及CPU周期、内存使用，甚至网络带宽。例如，在一个射击视频游戏中，你可能会使用这种模式来管理子弹对象。每次开枪时创建一个新的子弹可能会消耗大量资源。相反，你可以有一个子弹对象池，这些对象可以重复使用。
- en: Implementing the object pool pattern
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现对象池模式
- en: Let’s implement a pool of reusable `car` objects, for a car rental application,
    to avoid creating and destroying them repeatedly.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个可重用`car`对象池，用于汽车租赁应用程序，以避免重复创建和销毁它们。
- en: 'First, we need to define a `Car` class, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个`Car`类，如下所示：
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we start defining a `CarPool` class with its initialization, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始定义一个`CarPool`类及其初始化，如下所示：
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We need to express what happens when a client acquires a car. For that, we
    define a method on the class doing the following: if no car is available, we instantiate
    one and add it to the list of available cars in the pool; else, we return an available
    `car` object, while doing the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要表达当客户端获取一辆车时会发生什么。为此，我们在类上定义了一个方法，执行以下操作：如果没有可用的汽车，我们实例化一辆并添加到池中可用的汽车列表中；否则，我们返回一个可用的`car`对象，同时执行以下操作：
- en: Setting the `_in_use` attribute of the `car` object to `True`
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`car`对象中的`_in_use`属性设置为`True`
- en: Adding the `car` object to the list of “in use” cars (stored in the `_in_use`
    attribute of the `pool` object)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`car`对象添加到“正在使用”的车辆列表中（存储在`pool`对象的`_in_use`属性中）
- en: 'We add the code of that method to the class as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将那个方法的代码添加到类中，如下所示：
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then add a method that handles things when a client releases a car, as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了一个处理客户释放车辆时的方法，如下所示：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we add some code for testing the result of the implementation, as
    follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一些测试实现结果的代码，如下所示：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here is a summary of what we do in the code (in file `ch03/object_pool.py`):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在代码中执行的操作的摘要（在文件`ch03/object_pool.py`中）：
- en: We define a `Car` class.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`Car`类。
- en: We define a `CarPool` class with the `acquire_car()` and `release_car()` methods,
    as shown earlier.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个带有`acquire_car()`和`release_car()`方法的`CarPool`类，如前所述。
- en: We add code for testing the result of the implementation, as shown earlier.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了测试实现结果的代码，如前所述。
- en: 'To test the program, run the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试程序，请运行以下命令：
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You should get the following output:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE56]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Well done! This output shows that our object pool pattern implementation works
    as intended.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！这个输出表明我们的对象池模式实现按预期工作。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen *creational design patterns*, which are essential
    for crafting flexible, maintainable, and modular code. We kicked off the chapter
    by examining two variations of the factory pattern, each offering unique advantages
    for object creation. Next, we navigated through the builder pattern, which provides
    a more readable and maintainable way to construct complex objects. The prototype
    pattern followed, introducing a method to clone objects efficiently. Finally,
    we rounded out the chapter by discussing the singleton and object pool patterns,
    both of which are geared toward optimizing resource management and ensuring consistent
    state across the application.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了*创建型设计模式*，这对于构建灵活、可维护和模块化的代码至关重要。我们通过检查工厂模式的两种变体开始了本章，每种变体都为对象创建提供了独特的优势。接下来，我们探讨了构建者模式，它提供了一种更易读、更易于维护的方式来构建复杂对象。随后，原型模式引入了一种高效克隆对象的方法。最后，我们通过讨论单例和对象池模式结束了本章，这两种模式都旨在优化资源管理并确保应用程序中状态的一致性。
- en: Now, equipped with these foundational patterns for object creation, we are well
    prepared for the next chapter, where we will discover *structural* *design patterns*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有了这些对象创建的基础模式，我们为下一章做好了准备，我们将发现*结构性*设计模式。
