- en: 14\. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the concept of testing Django web applications.
    You will learn about the importance of testing in software development and, more
    importantly, in building web applications. You will write unit tests for your
    Django application's components, such as **views**, **models**, and **endpoints**.
    Completing this chapter will equip you with the skills to write test cases for
    Django web applications. That way, you can ensure that your application code works
    the way you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapters, we have focused upon building our web application
    in Django by writing different components such as database models, views, and
    templates. We did all that to provide our users with an interactive application
    where they can create a profile and write reviews for the books they have read.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from building and running the application, there is another important
    aspect of making sure that the application code works the way we expect it to
    work. This is ensured by a technique called **testing**. In testing, we run the
    different parts of the web application and check whether the output of the executed
    component matches the output we expected. If the output matches, we can say that
    the component was tested successfully, and if the output does not match, we say
    that the component failed to work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, as we go through the different sections, we will learn why
    testing is important, what the different ways to test a web application are, and
    how we can build a strong testing strategy that will help us ensure that the web
    application we build is robust. Let us start our journey by learning about the
    importance of testing.
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making sure that an application works the way it was designed to work is an
    important aspect of development efforts because, otherwise, our users might keep
    on encountering weird behaviors that will usually drive them away from engaging
    with the application.
  prefs: []
  type: TYPE_NORMAL
- en: The efforts we put into testing help us ensure that the different kinds of problems
    that we intend to solve are indeed being solved correctly. Imagine a case where
    a developer is building an online event scheduling platform. On this platform,
    users can schedule events on their calendars as per their local time zone. Now,
    what if, on this platform, users can schedule events as expected, but due to a
    bug, the events are scheduled in an incorrect time zone? It is such issues that
    tend to drive many users away.
  prefs: []
  type: TYPE_NORMAL
- en: That is why a lot of companies spend a huge amount of money making sure that
    the applications they are building have undergone thorough testing. That way,
    they ensure that they do not release a buggy product or a product that is far
    away from satisfying user requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, testing helps us achieve the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that the components of the application work according to specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensuring interoperability with different infrastructure platforms: if an application
    can be deployed on a different operating system, such as Linux, Windows, and so
    on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the probability of introducing a bug while refactoring the application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, a common assumption many people make about testing is that they have to
    test all the components manually as they are developed to make sure each component
    works according to its specifications, and repeat this exercise every time a change
    is made, or a new component is added to the application. While this is true, this
    does not provide a complete picture of testing. Testing as a technique has grown
    to be very powerful with time, and as a developer, you can reduce a huge amount
    of testing effort by implementing **automated test cases**. So, what are these
    automated test cases? Or, in other words, what is **automation testing**? Let
    us find out.
  prefs: []
  type: TYPE_NORMAL
- en: Automation Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing a whole application repeatedly when a single component is modified can
    turn out to be a challenging task, and even more so if that application consists
    of a large codebase. The size of the codebase could be due to the sheer number
    of features or the complexity of the problem it solves.
  prefs: []
  type: TYPE_NORMAL
- en: As we develop applications, it is important to make sure that the changes being
    made to these applications can be tested easily, so that we can verify whether
    there is something that is breaking. That is where the concept of automation testing
    comes in handy. The focus of automation testing is to write tests as code, such
    that the individual components of an application can be tested in isolation as
    well as in terms of their interaction with each other.
  prefs: []
  type: TYPE_NORMAL
- en: With this aspect, it now becomes important for us to define the different kinds
    of automation tests that can be done for applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automation testing can be broadly categorized into five different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit Testing**: In this type of testing, the individual isolated units of
    code are tested. For example, a unit test can target a single method or a single
    isolated API. This kind of testing is performed to make sure the basic units of
    the application work according to their specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration Testing**: In this type of testing, the individual isolated units
    of code are merged to form a logical grouping. Once this grouping is formed, testing
    is performed on this logical group to make sure that the group works in the way
    it is expected to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional Testing**: In this kind of testing, the overall functionality
    of the different components of the application is tested. This may include different
    APIs, user interfaces, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smoke Testing**: In this kind of testing, the stability of the deployed application
    is tested to make sure that the application continues to remain functional as
    users interact with it, without causing a crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression Testing**: This kind of testing is done to make sure that the
    changes being made to the application do not degrade the previously built functionality
    of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, testing is a big domain that takes time to master, and entire
    books have been written on this topic. To make sure we highlight the important
    aspects of testing, we are going to focus on the aspect of unit testing in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django is a feature-packed framework that aims to make web application development
    rapid. It provides a full-featured way of testing an application. It also provides
    a well-integrated module that allows application developers to write unit tests
    for their applications. This module is based on the Python `unittest` library
    that ships with most Python distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Let us get started with understanding how we can write basic test cases in Django
    and how to leverage the framework-provided modules to test our application code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Test Cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working on implementing mechanisms for testing your code, the first thing
    that needs to be understood is how this implementation can be logically grouped,
    such that modules that are closely related to each other are tested in one logical
    unit.
  prefs: []
  type: TYPE_NORMAL
- en: This is simplified by implementing a **test case**. A test case is nothing more
    than a logical unit that groups together tests that are related to logically similar
    units, such that all the common logic to initialize the environment for the test
    cases can be combined in the same place, hence avoiding duplication of work while
    implementing application testing code.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing in Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, with our basic understanding of the tests clear, let us look at how we
    can do unit testing inside Django. In the context of Django, a unit test consists
    of two major parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A `TestCase` class, which wraps the different test cases that are grouped for
    a given module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An actual test case, which needs to be executed to test the flow of a particular component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class implementing a unit test should inherit from the `TestCase` class
    provided by Django's `test` module. By default, Django provides a `tests.py` file
    in every application directory, which can be used to store the test cases for
    the application module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once these unit tests are written, they can also be executed easily by running
    them directly using the provided `test` command in `manage.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Utilizing Assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important part of writing tests is validating whether the test passed or
    failed. Generally, to implement such decisions inside a testing environment, we
    utilize something known as **assertions**.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions are a common concept in software testing. They take in two operands
    and validate whether the value of the operand on the **left-hand side (LHS)**
    matches the value of the operand on the **right-hand side (RHS)**. If the value
    on the LHS matches the value on the RHS, an assertion is considered to be successful,
    whereas if the values differ, the assertion is considered to have failed.
  prefs: []
  type: TYPE_NORMAL
- en: An assertion evaluating to `False` essentially causes a test case to be evaluated
    as a failure, which is then reported to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assertions in Python are quite easy to implement and they use a simple keyword
    called `assert`. For example, the following code snippet shows a very simple assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding assertion takes in a single expression, which evaluates to `True`.
    If this assertion were a part of a test case, the test would have succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us see how we can implement test cases using the Python `unittest`
    library. Doing so is quite easy and can be accomplished in a few easy-to-follow
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `unittest` module, which allows us to build the test cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the module is imported, you can create a class whose name starts with
    `Test`, which inherits from the `TestCase` class provided by the `unittest` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Only if the `TestMyModule` class inherits the `TestCase` class will Django be
    able to run it automatically with full integration with the framework. Once the
    class is defined, we can implement a new method inside the class named `test_method_a()`,
    which validates an assertion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An important part to note here is the naming scheme for the test cases and test
    functions. The test cases being implemented should be prefixed with the name `test`,
    such that the test execution modules can detect them as valid test cases and execute
    them. The same rule applies to the naming of testing methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the test case is written, it can be simply executed by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, with our basic understanding of implementing test cases clarified, let
    us write a very simple unit test to see how the unit testing framework behaves
    inside Django.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 14.01: Writing a Simple Unit Test'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will write a simple unit test to understand how the Django
    unit testing framework works and use this knowledge to implement your first test
    case that validates a couple of simple expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, open the `tests.py` file under the `reviews` application of
    the `Bookr` project. By default, this file will contain only a single line that
    imports Django''s `TestCase` class from the `test` module. In case the file already
    has a couple of test cases, you can remove all the lines in the file except the
    one which imports the `TestCase` class as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines of code in the `tests.py` file you just opened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you created a new class named `TestSimpleComponent`, which inherits from
    the `TestCase` class provided by Django's `test` module. The `assert` statement
    will compare the expression on the left-hand side (`1 + 1`) with the one on the
    right (`2`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have written the test case, navigate back to the project folder, and
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following output should be generated:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding output signifies that Django's test runner executed one test case,
    which successfully passed the evaluation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the test case confirmed to be working and passing, now try to add another
    assertion at the end of the `test_basic_sum()` method, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the `assert` statement added to `tests.py`, now execute the test cases
    by running the following command from the project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, you will notice Django reporting that the execution of the test
    cases has failed.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you now have an understanding of how test cases can be written in
    Django and how assertions can be used to validate whether the output generated
    from your method calls under test is correct or not.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Exercise 14.01*, *Writing a Simple Unit Test*, we had a brief encounter
    with assertions when we came across the following `assert` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'These assertion statements are simple and use the Python `assert` keyword.
    There are a few different types of assertions possible that can be tested inside
    a unit test while using the `unittest` library. Let us look at those:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertIsNone`: This assertion is used to check whether an expression evaluates
    to `None` or not. For example, this type of assertion can be used in cases where
    a query to a database returns `None` because no records were found for the specified
    filtering criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertIsInstance`: This assertion is used to validate whether a provided object
    evaluates to an instance of the provided type. For example, we can validate whether
    the value returned by a method is indeed of a specific type, such as list, dict,
    tuple, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEquals`: This is a very basic function that takes in two arguments and
    checks whether the provided arguments to it are equal in value or not. This can
    be useful when you plan to compare the values of data structures that do not guarantee
    ordering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertRaises`: This method is used to validate whether the name of the method
    provided to it when called raises a specified exception or not. This is helpful
    when we are writing test cases where a code path that raises an exception needs
    to be tested. As an example, this kind of assertion can be useful when we want
    to want to make sure an exception is raised by a method performing a database
    query (say, to let us know if the database connection is not yet established).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These were just a small set of useful assertions that we can make in our test
    cases. The `unittest` module on top of which Django's testing library is built
    provides a lot more assertions that can be tested for.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Pre-Test Setup and Cleanup after Every Test Case Run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes while writing test cases, we may need to perform some repetitive tasks;
    for example, setting up some variables that will be required for the test. Once
    the test is over, we would want to clean up all the changes made to the test variables,
    such that any new test starts with a fresh instance.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the `unittest` library provides a useful way through which we can automate
    our repetitive efforts of setting up the environment before every test case runs
    and cleaning it up after the test case is finished. This is achieved using the
    following two methods, which we can implement in `TestCase`.
  prefs: []
  type: TYPE_NORMAL
- en: '`setUp()`: This method is called before the execution of every `test` method
    inside the `TestCase` class. It implements the code required to set up the test
    case''s environment before the test executes. This method can be a good place
    to set up any local database instance or test variables that may be required for
    the test cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `setUp()` method is valid only for test cases written inside the `TestCase`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following example illustrates a simple definition of how the
    `setUp()` method is used inside a `TestCase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, when we try to execute the test cases, the `setUp()`
    method we defined here will be called every time before a `test` method executes.
    In other words, the `setUp()` method will be called before the execution of the
    `test_method_a()` call and then it will be called again before `test_method_b()`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: '`tearDown()`: This method is called once the `test` function finishes execution
    and cleans up the variables and their values once the test case execution is finished.
    This method is executed no matter whether the test case evaluates to `True` or
    `False`. An example of using the `tearDown()` method is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `tearDown()` method will be called every time
    a `test` method finishes execution, that is, once `test_method_a()` finishes execution
    and again once after `test_method_b()` finishes execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are aware of the different components of writing test cases. Let us
    now look at how we can test the different aspects of a Django application using
    the provided test framework.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Django Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Models in Django are object-based representations of how the data will be stored
    inside the database of an application. They provide methods that can help us validate
    the data input provided for a given record, as well as performing any processing
    on the data before it is inserted into the database.
  prefs: []
  type: TYPE_NORMAL
- en: As easy as it is to create models in Django, it is equally easy to test them.
    Now, let us look at how Django models can be tested using the Django test framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.02: Testing Django Models'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a new Django model and write test cases for
    it. The test case will validate whether your model can correctly insert and retrieve
    the data from the database. These kinds of test cases that work on database models
    can turn out to be useful in cases where a team of developers is collaborating
    on a large project and the same database model may get modified by multiple developers
    over time. Implementing test cases for database models allows developers to pre-emptively
    identify potentially breaking changes that they may inadvertently introduce as
    a part of their work:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To ensure we get a good hang of running tests from scratch on newly created
    apps, we'll be creating a new application called `bookr_test`. This application's
    code is independent of the main `bookr` application and consequently, we won't
    be including this app's files in the `final/bookr` folder. Upon completion of
    this chapter, we recommend you practice what you learned by writing similar tests
    for various components of the main `bookr` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new application, which you will use for the exercises in this chapter.
    To do this, run the following command, which will set up a new application for
    your use case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make sure the `bookr_test` application behaves the same way as any other
    application in the Django project, add this application to our `INSTALLED_APPS`
    section of the `bookr` project. To do this, open the `settings.py` file in your
    `bookr` project and append the following code to the `INSTALLED_APPS` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, with the application setup complete, create a new database model, which
    you will use for testing purposes. For this exercise, you are going to create
    a new model named `Publisher`, which will store the details about the book publisher
    in our database. To create the model, open the `models.py` file under the `bookr_test`
    directory and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code snippet, you have created a new class named `Publisher`,
    which inherits from the `Model` class of Django''s `models` module, defining the
    class as a Django model, which will be used to store data about the publisher:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this model, you have added three fields, which will act as the properties
    of the model:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name`: The name of the publisher'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`website`: The website belonging to the publisher'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`email`: The email address of the publisher'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once this is done, you create a class method, `__str__()`, which defines how
    the string representation of the model will look.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, with the model created, you first need to migrate this model before you
    can run a test on it. To do this, run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the model now set up, write the test case with which you are going to
    test the model created in *step 3*. For this, open the `tests.py` file under the
    `bookr_test` directory and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, there are a couple of things worth exploring.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the start, after importing the `TestCase` class from the Django `test` module,
    you imported the `Publisher` model from the `bookr_test` directory, which is going
    to be used for testing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the required libraries were imported, you created a new class named `TestPublisherModel`,
    which inherits the `TestCase` class and is used for grouping the unit tests related
    to the `Publisher` model:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this class, you defined a couple of methods. First, you defined a new
    method named `setUp()` and added the `Model` object creation code inside it such
    that the `Model` object is created every time a new `test` method is executed
    inside this test case. This `Model` object is stored as a class member, such that
    it can be accessed inside other methods without a problem:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first test case validates whether the `Model` object for the `Publisher`
    model was created successfully or not. To do this, you created a new method named
    `test_create_publisher()`, inside which you check whether the created Model object
    points to an object of the `Publisher` type. If this `Model` object was not created
    successfully, your test will fail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you check carefully, you are using the `assertIsInstance()` method of the
    `unittest` library here to assert whether the `Model` object belongs to the `Publisher`
    type or not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next test validates whether the string representation of the model is the
    same as what you expected it to be. From the code definition, the string representation
    of the `Publisher` model should output the name of the publisher. To test this,
    you create a new method named `test_str_representation()` and check whether the
    generated string representation of the model matches the one you are expecting:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To perform this validation, you use the `assertEquals` method of the `unittest`
    library, which validates whether the two values provided to it are equal or not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the test cases now in place, you can run them to check what happens. To
    run these test cases, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the command finishes execution, you will see an output that resembles
    the one shown here (your output may differ slightly, though):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see from the preceding output, the test cases are executed successfully,
    hence validating that the operations such as the creation of a new `Publisher`
    object and its string representation when fetched are being done correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this exercise, we got to see how we can write test cases for our Django
    models easily and validate their functioning, involving the creation of objects,
    their retrieval, and representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, there is an important line to notice in the output from this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This happens because when there are test cases that require the data to be persisted
    inside a database, instead of using the production database, Django creates a
    new empty database for the test cases, which it uses to persist the value for
    the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Django Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Views in Django control the rendering of the HTTP response for users based on
    the URL they visit in a web application. In this section, we will get on to understand
    how we can test views inside Django. Imagine you are working on a website where
    a lot of **Application Programming Interface** (**API**) endpoints are required.
    An interesting question to ask would be, how will you be able to validate every
    new endpoint? If done manually, you will have to first deploy the application
    every time a new endpoint is added, then manually visit the endpoint in the browser
    to validate whether it is working fine or not. Such an approach may work out when
    the number of endpoints is low but may become extremely cumbersome if there are
    hundreds of endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django provides a very comprehensive way of testing application views. This
    happens with the use of a testing client class provided by Django''s `test` module.
    This class can be used to visit URLs mapped to the views and capture the output
    generated by visiting the URL endpoint. Then we can use the captured output to
    test whether the URLs are generating a correct response or not. This client can
    be used by importing the `Client` class from the Django `test` module and then
    initializing it as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The client object supports several methods that can be used to simulate the
    different HTTP calls a user can make, namely, `GET`, `POST`, `PUT`, `DELETE`,
    and so on. An example of making such a request will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The response generated by the view is then captured by the client and gets exposed
    as a `response` object, which can then be queried to validate the output of the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, now let us look at how we can write test cases for our
    Django views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.03: Writing Unit Tests for Django Views'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the Django test client to write a test case
    for your Django view, which will be mapped to a specific URL. These test cases
    will help you validate whether your view function generates the correct response
    when visited using its mapped URL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you are going to use the `bookr_test` application that was
    created in *step 1* of *Exercise 14.02*, *Testing Django Models*. To get started,
    open the `views.py` file under the bookr_test directory and add the following
    code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you have created a simple Django view, which will be used to greet the
    user with a welcome message whenever they visit an endpoint mapped to the provided
    view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this view is created, you need to map it to a URL endpoint, which can
    then be visited in a browser or a test client. To do this, open the `urls.py`
    file under the `bookr_test` directory and add the highlighted code to the `urlpatterns` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this path is set up, you need to make sure that it is also identified
    by your project. To do this, you need to add this entry to the `bookr` project''s
    URL mapping. To achieve that, open the `urls.py` file in the `bookr` directory
    and append the following highlighted line to the end of the `urlpatterns` list,
    as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the view is set up, validate whether it works correctly. Do this by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then visit `http://localhost:8080/test/greeting` in your web browser. Once
    the page opens, you should see the following text, which you added to the greeting
    view in *step 1*, being displayed in the browser:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you are ready to write the test cases for `greeting_view`. In this exercise,
    you are going to write a test case that checks whether, on visiting the `/test/greeting`
    endpoint, you get a successful result or not. To implement this test case, open
    the `tests.py` file under the `bookr_test` directory and add the following code
    at the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, you have defined a test case that helps in validating
    whether the greeting view is working fine or not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is done by first importing Django''s test client, which allows testing
    views mapped to the URLs by making calls to them and analyzing the generated response:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the import is done, you now create a new class named `TestGreetingView`,
    which will group the test cases related to the greeting view that you created
    in *step 2*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this test case, you defined two methods, `setUp()` and `test_greeting_view()`.
    The `test_greeting_view()` method implements your test case. Inside this, you
    first make an HTTP `GET` call to the URL that is mapped to the greeting view and
    then store the response generated by the view inside the `response` object created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this call finishes, you will have its HTTP response code, contents, and
    headers available inside the `response` variable. Next, with the following code,
    you make an assertion validating whether the status code generated by the call
    matches the status code for successful HTTP calls (`HTTP 200`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, you are now ready to run the tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the test case written, let''s look at what happens when you run the test
    case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the command executes, you can expect to see an output like the one shown
    in the following snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see from the output, your test cases executed successfully, hence
    validating that the response generated by the `greeting_view()` method is as per
    your expectations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, you learned how you can implement a test case for a Django
    view function and use `TestClient` provided by Django to assert that the output
    generated by the view function matches the one that the developer should see.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Views with Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we looked at how we can test views inside Django. An
    important part to be highlighted about this view is that the view we created could
    be accessed by anyone and is not protected by any authentication or login checks.
    Now imagine a case where a view should only be accessible if the user is logged
    in. For example, imagine implementing a view function that renders the profile
    page of a registered user of our web application. To make sure that only logged-in
    users can view the profile page for their account, you might want to restrict
    the view to logged-in users only.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we now have an important question: *How can we test views that require authentication?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Django''s test client provides this functionality through which we
    can log in to our views and then run tests on them. This result can be achieved
    by using Django''s test client `login()` method. When this method is called, Django''s
    test client performs an authentication operation against the service and if the
    authentication succeeds, it stores the login cookie internally, which it can then
    use for further test runs. The following code snippet shows how you can set up
    Django''s test client to simulate a logged-in user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `login` method requires a username and password for the test user that we
    are going to test with, as will be shown in the next exercise. So, let us look
    at how we can test a flow that requires user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.04: Writing Test Cases to Validate Authenticated Users'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will write test cases for views that require the user
    to be authenticated. As part of this, you will validate the output generated by
    the view method when a user who is not logged in tries to visit the page and when
    a user who is logged in tries to visit the page mapped to the view function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you are going to use the `bookr_test` application that you
    created in *step 1* of *Exercise 14.02*, *Testing Django Models*. To get started,
    open the `views.py` file under the bookr_test application and add the following
    code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the preceding code snippet is added, create a new function, `greeting_view_user()`,
    at the end of the file, as shown in the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, you have created a simple Django view that will be used to greet
    the logged-in user with a welcome message whenever they visit an endpoint mapped
    to the provided view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this view is created, you need to map this view to a URL endpoint that
    can then be visited in a browser or a test client. To do this, open the `urls.py`
    file under the `bookr_test` directory and add the following highlighted code to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the view is set up, the next thing you need to do is to validate whether
    it works correctly. To do this, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then visit `http://localhost:8080/test/greet_user` in your web browser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are not logged in already, by visiting the preceding URL, you will be
    redirected to the login page for the project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, write the test cases for `greeting_view_user`, which checks whether, on
    visiting the `/test/greet_user` endpoint, you get a successful result. To implement
    this test case, open the `tests.py` file under the `bookr_test` directory and
    add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, you have implemented a test case that checks
    the views that have authentication enabled before their content can be seen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this, you first imported the required classes and methods that will be
    used to define the test case and initialize a testing client:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next thing you require is the `User` model from Django''s `auth` module:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This model is required because for the test cases requiring authentication,
    you will need to initialize a new test user. Next up, you created a new class
    named `TestLoggedInGreetingView`, which wraps your tests related to the `greeting_user`
    view (which requires authentication). Inside this class, you defined three methods,
    namely: `setUp()`, `test_user_greeting_not_authenticated()`, and `test_user_authenticated()`.
    The `setUp()` method is used to first initialize a test user, which you will use
    for authentication. This is a required step because a test environment inside
    Django is a completely isolated environment that doesn''t use data from your production
    application, hence all the required models and objects are to be instantiated
    separately inside the test environment.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You then created the test user and initiated the test client using the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up, you wrote the test case for the `greet_user` endpoint when the user
    is not authenticated. Inside this, you should expect Django to redirect the user
    to the login endpoint. This redirect can be detected by checking the HTTP status
    code of the response, which should be set to `HTTP 302`, indicating a redirect operation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you wrote another test case to check whether the `greet_user` endpoint
    renders successfully when the user is authenticated. To authenticate the user,
    you first call the `login()` method of the test client and perform authentication
    by providing the username and password of the test user you created in the `setUp()`
    method as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the login is completed, you make an `HTTP GET` request to the `greet_user`
    endpoint and validate whether the endpoint generates a correct result or not by
    checking the HTTP status code of the returned response:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the test cases written, it is time to check how they run. For this, run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the execution finishes, you can expect to see a response that resembles
    the one that follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see from the preceding output, our test cases have passed successfully,
    validating that the view we created generates the desired response of redirecting
    the user if the user is unauthenticated to the website, and allows the user to
    see the page if the user is authenticated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we just implemented a test case where we can test the output
    generated by a view function regarding the authentication status of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Django Request Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we have been using Django's test client to test the views we have
    created for our application. The test client class simulates a browser and uses
    this simulation to make calls to the required APIs. But what if we did not want
    to use the test client and its associated simulation of being a browser, but rather
    wanted to test the view functions directly by passing the request parameter? How
    can we do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us in such cases, we can leverage the `RequestFactory` class provided
    by Django. The `RequestFactory` class helps us provide the `request` object, which
    we can pass to our view functions to evaluate their working. The following object
    for `RequestFactory` can be created by instantiating the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `factory` object thus created supports only HTTP methods such as `get()`,
    `post()`, `put()`, and others, to simulate a call to any URL endpoint. Let us
    look at how we can modify the test case that we wrote in *Exercise 14.04*, *Writing
    Test Cases to Validate Authenticated Users*, to use `RequestFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.05: Using a Request Factory to Test Views'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use a request factory to test view functions in
    Django:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you are going to use the existing `greeting_view_user` view
    function, which you created earlier, in *step 1* of *Exercise 14.04*, *Writing
    Test Cases to Validate Authenticated Users*, which is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, modify the existing test case, `TestLoggedInGreetingView`, defined inside
    the `tests.py` file under the `bookr_test` directory. Open the `tests.py` file
    and make the following changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, you need to add the following import to use `RequestFactory` inside
    the test cases:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next thing you need is an import for the `AnonymousUser` class from Django''s
    `auth` module and the `greeting_view_user` view method from the `views` module.
    This is required to test the view functions with a simulated user who is not logged
    in. This can be done by adding the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the `import` statements are added, modify the `setUp()` method of the
    `TestLoggedInGreetingView` class and change its contents to resemble the one shown
    next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, you first created a `user` object and stored it as a class member
    such that you can use it later in the tests. Once the `user` object is created,
    then instantiate a new instance of the `RequestFactory` class to use it for testing
    our view function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the `setUp()` method now defined, modify the existing tests to use the
    `RequestFactory` instance. For the test for a non-authenticated call to the view
    function, modify the `test_user_greeting_not_authenticated` method to have the
    following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this method, you first created a `request` object using the `RequestFactory`
    instance you defined in the `setUp()` method. Once that was done, you assigned
    an `AnonymousUser()` instance to the `request.user` property. Assigning the `AnonymousUser()`
    instance to the property makes the view function think that the user making the
    request is not logged in:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, you made a call to the `greeting_view_user()` view method
    and passed to it the `request` object you created. Once the call is successful,
    you capture the output of the method in the `response` variable using the following
    code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the unauthenticated user, you expect to get a redirect response, which
    can be tested by checking the HTTP status code of the response as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, go ahead and modify the other method, `test_user_authenticated()`,
    similarly by using the `RequestFactory` instance as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, most of the code resembles the code you wrote in the `test_user_greeting_not_authenticated`
    method, with the small change that, in this method, instead of using `AnonymousUser`
    for our `request.user` property, you are using `test_user`, which you created
    in our `setUp()` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the changes done, it is time to run the tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run the tests and validate whether the request factory works as expected,
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the command executes, you can expect to see an output that resembles the
    one shown next:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see from the output, the test cases written by us have passed successfully,
    hence validating the behavior of the `RequestFactory` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this exercise, we learned how we can write test cases for view functions
    leveraging `RequestFactory` and passing the `request` object directly to the view
    function, rather than simulating a URL visit using the test client approach, and
    hence allowing more direct testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Class-Based Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we saw how we can test views defined as methods. But
    what about class-based views? How can we test those?
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, it is quite easy to test class-based views. For example, if
    we have a class-based view defined with the name `ExampleClassView(View)`, to
    test the view, all we need to do is to use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It is as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: A Django application generally consists of several different components that
    can work in isolation, such as models, and some other components that need to
    interact with the URL mapping and other parts of the framework to work. Testing
    these different components may require some steps that are common only to those
    components. For example, when testing a model, we might first want to create certain
    objects of the `Model` class before we start testing, or for views, we might first
    want to initialize a test client with user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, Django also provides some other classes based on top of the
    `TestCase` class, which can be used to write test cases of specific types about
    the type of the component being used. Let us look at these different classes provided
    by Django.
  prefs: []
  type: TYPE_NORMAL
- en: Test Case Classes in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond the base `TestCase` class provided by Django, which can be used to define
    a multitude of test cases for different components, Django also provides some
    specialized classes derived from the `TestCase` class. These classes are used
    for specific types of test cases based on the capabilities they provide to the
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: Let us take a quick look at them.
  prefs: []
  type: TYPE_NORMAL
- en: SimpleTestCase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class is derived from the `TestCase` class provided by Django''s `test`
    module and should be used for writing simple test cases that test the view functions.
    Usually, the class is not preferred when your test case involves making database
    queries. The class also provides a lot of useful features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to check for exceptions raised by a view function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to test form fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A built-in test client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to verify a redirect by a view function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching the equality of two HTML, JSON, or XML outputs generated by the view functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, with a basic idea of what `SimpleTestCase` is, let us try to understand
    another type of test case class that helps in writing test cases involving interaction
    with databases.
  prefs: []
  type: TYPE_NORMAL
- en: TransactionTestCase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class is derived from the `SimpleTestCase` class and should be used when
    writing test cases that involve interaction with the database, such as database
    queries, model object creations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class provides the following added features:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to reset the database to a default state before a test case runs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipping tests based on database features – this feature can come in handy if
    the database being used for testing does not support all the features of a production database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LiveServerTestCase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class is like the `TransactionTestCase` class, but with the small difference
    that the test cases written in the class use a live server created by Django (instead
    of using the default test client).
  prefs: []
  type: TYPE_NORMAL
- en: This ability to run the live server for testing comes in handy when writing
    test cases that test for the rendered web pages and any interaction with them,
    which is not possible while using the default test client.
  prefs: []
  type: TYPE_NORMAL
- en: Such test cases can leverage tools such as **Selenium**, which can be used to
    build interactive test cases that modify the state of the rendered page by interacting
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing Test Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercises, we have seen how we can write test cases for different
    components of our project. But an important aspect to note is that, till now,
    we have written the test cases for all the components in a single file. This approach
    is okay when the application does not have a lot of views and models. But this
    can become problematic as our application grows because now our single `tests.py`
    file will be hard to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid running into such scenarios, we should try to modularize our test
    cases such that the test cases for models are kept separately from test cases
    related to the views, and so on. To achieve this modularization, all we need to
    do is two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory named `tests` inside your application directory by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new empty file named `__init__.py` inside your tests directory by
    running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `__init__.py` file is required by Django to correctly detect the `tests`
    directory we created as a module and not a regular directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the preceding steps are done, you can go ahead and create new testing files
    for the different components in your application. For example, to write test cases
    for your models, you can create a new file named `test_models.py` inside the tests
    directory and add any associated code for your model testing inside this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you do not need to take any other additional steps to run your tests.
    The same command will work perfectly fine for your modular testing code base as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have now understood how we can write test cases for our projects.
    So, how about we assess this knowledge by writing test cases for the Bookr project
    that we are working on?
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14.01: Testing Models and Views in Bookr'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will implement test cases for the Bookr project. You will
    implement test cases to validate the functioning of the models created inside
    the `reviews` application of the Bookr project, and then you will implement a
    simple test case for validating the `reviews` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you work through this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `tests` inside the `reviews` application directory,
    such that all our test cases for the `reviews` application can be modularized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty `__init__.py` file, such that the directory is considered not
    as a general directory, but rather a Python module directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file, `test_models.py`, for implementing the code that tests the
    models. Inside this file, import the models you want to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `test_models.py`, create a new class that inherits from the `TestCase`
    class of the `django.tests` module and implements methods to validate the creation
    and reading of the `Model` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test the view function, create a new file named `test_views.py` inside the
    `tests` directory, which was created in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `test_views.py` file, import the test `Client` class from the `django.tests`
    module and the `index` view function from the `reviews` application's `views.py`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `test_views.py` file created in *step 5*, create a new `TestCase`
    class, and implement methods to validate the index view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `TestCase` class created in *step 7*, create a new function, `setUp()`,
    inside which you should initialize an instance of `RequestFactory`, which will
    be used to create a `request` object that can be directly passed to the view function
    for testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the previous steps are done and the test cases are written, run the test
    cases by executing the `python manage.py` test to validate that the test cases pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon completing this activity, all test cases should pass successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we looked at how we can write test cases for different
    components of our web application project with Django. We learned about why testing
    plays a crucial role in the development of any web application and the different
    types of testing techniques that are employed in the industry to make sure the
    application code they ship is stable and bug-free.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how we can use the `TestCase` class provided by Django's `test`
    module to implement our unit tests, which can be used to test the models as well
    as views. We also looked at how we can use Django's `test` client to test our
    view functions that require or do not require the user to be authenticated. We
    also glanced over another approach of using `RequestFactory` to test method views
    and class-based views.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded the chapter by understanding the predefined classes provided by
    Django and where they should be used and looked at how we can modularize our testing
    codebase to make it appear clean.
  prefs: []
  type: TYPE_NORMAL
- en: As we move on to the next chapter, we will try to understand how we can make
    our Django application more powerful by integrating third-party libraries into
    our project. This functionality will then be used to implement third-party authentication
    into our Django application and thus allow users to log in to the application
    using popular services such as Google Sign-In, Facebook Login, and more.
  prefs: []
  type: TYPE_NORMAL
