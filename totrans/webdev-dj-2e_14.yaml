- en: 14\. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 测试
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the concept of testing Django web applications.
    You will learn about the importance of testing in software development and, more
    importantly, in building web applications. You will write unit tests for your
    Django application's components, such as **views**, **models**, and **endpoints**.
    Completing this chapter will equip you with the skills to write test cases for
    Django web applications. That way, you can ensure that your application code works
    the way you expect.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了测试Django Web应用程序的概念。您将了解测试在软件开发中的重要性，尤其是在构建Web应用程序方面。您将为Django应用程序的组件编写单元测试，例如**视图**、**模型**和**端点**。完成本章后，您将具备为Django
    Web应用程序编写测试用例的技能。这样，您可以确保您的应用程序代码按预期工作。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the preceding chapters, we have focused upon building our web application
    in Django by writing different components such as database models, views, and
    templates. We did all that to provide our users with an interactive application
    where they can create a profile and write reviews for the books they have read.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们通过编写不同的组件，如数据库模型、视图和模板，来专注于构建我们的Django Web应用程序。我们这样做是为了提供一个交互式应用程序，让用户可以创建个人资料并为他们读过的书籍撰写评论。
- en: Apart from building and running the application, there is another important
    aspect of making sure that the application code works the way we expect it to
    work. This is ensured by a technique called **testing**. In testing, we run the
    different parts of the web application and check whether the output of the executed
    component matches the output we expected. If the output matches, we can say that
    the component was tested successfully, and if the output does not match, we say
    that the component failed to work as intended.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建和运行应用程序之外，确保应用程序代码按预期工作还有一个重要的方面。这是通过一种称为**测试**的技术来保证的。在测试中，我们运行Web应用程序的不同部分，并检查执行组件的输出是否与预期的输出匹配。如果输出匹配，我们可以说该组件已成功测试，如果输出不匹配，我们则说该组件未能按预期工作。
- en: In this chapter, as we go through the different sections, we will learn why
    testing is important, what the different ways to test a web application are, and
    how we can build a strong testing strategy that will help us ensure that the web
    application we build is robust. Let us start our journey by learning about the
    importance of testing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，随着我们浏览不同的部分，我们将了解测试的重要性，了解测试Web应用程序的不同方法，以及我们如何构建一个强大的测试策略，以确保我们构建的Web应用程序是健壮的。让我们从了解测试的重要性开始我们的旅程。
- en: The Importance of Testing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的重要性
- en: Making sure that an application works the way it was designed to work is an
    important aspect of development efforts because, otherwise, our users might keep
    on encountering weird behaviors that will usually drive them away from engaging
    with the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 确保应用程序按预期设计的方式工作是开发工作的重要方面，否则，我们的用户可能会不断遇到奇怪的行为，这通常会驱使他们远离与应用程序的互动。
- en: The efforts we put into testing help us ensure that the different kinds of problems
    that we intend to solve are indeed being solved correctly. Imagine a case where
    a developer is building an online event scheduling platform. On this platform,
    users can schedule events on their calendars as per their local time zone. Now,
    what if, on this platform, users can schedule events as expected, but due to a
    bug, the events are scheduled in an incorrect time zone? It is such issues that
    tend to drive many users away.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试上投入的努力帮助我们确保我们打算解决的问题确实被正确解决。想象一下，一个开发者正在构建一个在线活动调度平台。在这个平台上，用户可以根据他们的本地时区在日历上安排活动。现在，如果在这个平台上，用户可以按预期安排活动，但由于一个错误，活动被安排在了错误的时间区域？这类问题往往会驱使许多用户离开。
- en: That is why a lot of companies spend a huge amount of money making sure that
    the applications they are building have undergone thorough testing. That way,
    they ensure that they do not release a buggy product or a product that is far
    away from satisfying user requirements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，许多公司花费大量资金确保他们构建的应用程序已经经过彻底的测试。这样，他们可以确保不会发布有缺陷的产品或远未满足用户需求的产品。
- en: 'In brief, testing helps us achieve the following goals:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，测试帮助我们实现以下目标：
- en: Ensuring that the components of the application work according to specifications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保应用程序的组件按规范工作
- en: 'Ensuring interoperability with different infrastructure platforms: if an application
    can be deployed on a different operating system, such as Linux, Windows, and so
    on'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保与不同基础设施平台的互操作性：如果一个应用程序可以部署在不同的操作系统上，例如Linux、Windows等
- en: Reducing the probability of introducing a bug while refactoring the application code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重构应用程序代码时降低引入错误的可能性
- en: Now, a common assumption many people make about testing is that they have to
    test all the components manually as they are developed to make sure each component
    works according to its specifications, and repeat this exercise every time a change
    is made, or a new component is added to the application. While this is true, this
    does not provide a complete picture of testing. Testing as a technique has grown
    to be very powerful with time, and as a developer, you can reduce a huge amount
    of testing effort by implementing **automated test cases**. So, what are these
    automated test cases? Or, in other words, what is **automation testing**? Let
    us find out.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多人关于测试的常见假设是他们必须手动测试所有组件，以确保每个组件按照其规范工作，每次更改或向应用程序添加新组件时都重复此操作。虽然这是真的，但这并不提供完整的测试图景。随着时间的推移，测试作为一种技术已经变得非常强大，作为开发者，你可以通过实现**自动化测试用例**来减少大量的测试工作。那么，这些自动化测试用例是什么？或者说，什么是**自动化测试**？让我们来了解一下。
- en: Automation Testing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Testing a whole application repeatedly when a single component is modified can
    turn out to be a challenging task, and even more so if that application consists
    of a large codebase. The size of the codebase could be due to the sheer number
    of features or the complexity of the problem it solves.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个组件被修改时，重复测试整个应用程序可能是一项具有挑战性的任务，尤其是如果该应用程序包含大量的代码库。代码库的大小可能是由于功能数量庞大或解决的问题的复杂性。
- en: As we develop applications, it is important to make sure that the changes being
    made to these applications can be tested easily, so that we can verify whether
    there is something that is breaking. That is where the concept of automation testing
    comes in handy. The focus of automation testing is to write tests as code, such
    that the individual components of an application can be tested in isolation as
    well as in terms of their interaction with each other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开发应用程序，确保对这些应用程序所做的更改可以轻松测试非常重要，这样我们就可以验证是否有破坏性的东西。这就是自动化测试概念派上用场的地方。自动化测试的重点是将测试编写为代码，这样应用程序的各个组件就可以在隔离状态下以及它们相互交互的情况下进行测试。
- en: With this aspect, it now becomes important for us to define the different kinds
    of automation tests that can be done for applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，现在对我们来说，定义可以为应用程序执行的不同类型的自动化测试变得很重要。
- en: 'Automation testing can be broadly categorized into five different types:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试可以大致分为五种不同类型：
- en: '**Unit Testing**: In this type of testing, the individual isolated units of
    code are tested. For example, a unit test can target a single method or a single
    isolated API. This kind of testing is performed to make sure the basic units of
    the application work according to their specification.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：在这种测试类型中，代码的各个独立单元被单独测试。例如，单元测试可以针对单个方法或单个独立的API。这种测试的目的是确保应用程序的基本单元按照其规范工作。'
- en: '**Integration Testing**: In this type of testing, the individual isolated units
    of code are merged to form a logical grouping. Once this grouping is formed, testing
    is performed on this logical group to make sure that the group works in the way
    it is expected to.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：在这种测试类型中，代码的各个独立单元被合并成一个逻辑分组。一旦形成这种分组，就会对这个逻辑组进行测试，以确保该组按预期的方式工作。'
- en: '**Functional Testing**: In this kind of testing, the overall functionality
    of the different components of the application is tested. This may include different
    APIs, user interfaces, and so on.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：在这种测试中，测试应用程序不同组件的整体功能。这可能包括不同的API、用户界面等。'
- en: '**Smoke Testing**: In this kind of testing, the stability of the deployed application
    is tested to make sure that the application continues to remain functional as
    users interact with it, without causing a crash.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒烟测试**：在这种测试中，测试已部署应用程序的稳定性，以确保应用程序在用户与其交互时继续保持功能，而不会导致崩溃。'
- en: '**Regression Testing**: This kind of testing is done to make sure that the
    changes being made to the application do not degrade the previously built functionality
    of the application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：这种测试是为了确保对应用程序所做的更改不会降低应用程序先前构建的功能。'
- en: As we can see, testing is a big domain that takes time to master, and entire
    books have been written on this topic. To make sure we highlight the important
    aspects of testing, we are going to focus on the aspect of unit testing in this
    chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，测试是一个庞大的领域，需要时间来掌握，关于这个主题已经写出了整本书。为了确保我们突出测试的重要方面，我们将在本章中专注于单元测试的方面。
- en: Testing in Django
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django中的测试
- en: Django is a feature-packed framework that aims to make web application development
    rapid. It provides a full-featured way of testing an application. It also provides
    a well-integrated module that allows application developers to write unit tests
    for their applications. This module is based on the Python `unittest` library
    that ships with most Python distributions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Django是一个功能丰富的框架，旨在使Web应用程序开发快速。它提供了一种全面的方式来测试应用程序。它还提供了一个良好集成的模块，允许应用程序开发者为其应用程序编写单元测试。此模块基于大多数Python发行版附带的Python
    `unittest`库。
- en: Let us get started with understanding how we can write basic test cases in Django
    and how to leverage the framework-provided modules to test our application code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始了解如何在Django中编写基本的测试用例，以及如何利用框架提供的模块来测试我们的应用程序代码。
- en: Implementing Test Cases
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现测试用例
- en: When working on implementing mechanisms for testing your code, the first thing
    that needs to be understood is how this implementation can be logically grouped,
    such that modules that are closely related to each other are tested in one logical
    unit.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在实现测试代码的机制时，首先需要理解的是如何逻辑地分组这种实现，以便相互紧密相关的模块可以在一个逻辑单元中进行测试。
- en: This is simplified by implementing a **test case**. A test case is nothing more
    than a logical unit that groups together tests that are related to logically similar
    units, such that all the common logic to initialize the environment for the test
    cases can be combined in the same place, hence avoiding duplication of work while
    implementing application testing code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过实现一个**测试用例**来简化。测试用例不过是一个逻辑单元，它将逻辑上相似的测试组合在一起，这样所有用于初始化测试用例环境的公共逻辑都可以组合在同一个地方，从而在实现应用程序测试代码时避免重复工作。
- en: Unit Testing in Django
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django中的单元测试
- en: 'Now, with our basic understanding of the tests clear, let us look at how we
    can do unit testing inside Django. In the context of Django, a unit test consists
    of two major parts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们对测试的基本理解已经清楚，让我们看看我们如何在Django中进行单元测试。在Django的上下文中，一个单元测试由两个主要部分组成：
- en: A `TestCase` class, which wraps the different test cases that are grouped for
    a given module
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`TestCase`类，它封装了为给定模块分组的不同测试用例
- en: An actual test case, which needs to be executed to test the flow of a particular component
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要执行以测试特定组件流程的实际测试用例
- en: The class implementing a unit test should inherit from the `TestCase` class
    provided by Django's `test` module. By default, Django provides a `tests.py` file
    in every application directory, which can be used to store the test cases for
    the application module.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实现单元测试的类应该继承自Django的`test`模块提供的`TestCase`类。默认情况下，Django在应用程序目录中提供了一个`tests.py`文件，可以用来存储应用程序模块的测试用例。
- en: 'Once these unit tests are written, they can also be executed easily by running
    them directly using the provided `test` command in `manage.py` as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了这些单元测试，它们也可以通过直接运行`manage.py`中提供的`test`命令来轻松执行，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Utilizing Assertions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用断言
- en: An important part of writing tests is validating whether the test passed or
    failed. Generally, to implement such decisions inside a testing environment, we
    utilize something known as **assertions**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试的一个重要部分是验证测试是否通过或失败。通常，为了在测试环境中实现这样的决策，我们使用一种称为**断言**的东西。
- en: Assertions are a common concept in software testing. They take in two operands
    and validate whether the value of the operand on the **left-hand side (LHS)**
    matches the value of the operand on the **right-hand side (RHS)**. If the value
    on the LHS matches the value on the RHS, an assertion is considered to be successful,
    whereas if the values differ, the assertion is considered to have failed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是软件测试中的一个常见概念。它们接受两个操作数，并验证左边的操作数（LHS）的值是否与右边的操作数（RHS）的值匹配。如果左边的值与右边的值匹配，则认为断言成功，而如果值不同，则认为断言失败。
- en: An assertion evaluating to `False` essentially causes a test case to be evaluated
    as a failure, which is then reported to the user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个评估为`False`的断言实际上会导致测试用例被评估为失败，然后报告给用户。
- en: 'Assertions in Python are quite easy to implement and they use a simple keyword
    called `assert`. For example, the following code snippet shows a very simple assertion:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的断言实现相当简单，它们使用一个简单的关键字`assert`。例如，以下代码片段展示了一个非常简单的断言：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding assertion takes in a single expression, which evaluates to `True`.
    If this assertion were a part of a test case, the test would have succeeded.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的断言接受一个表达式，该表达式评估为`True`。如果这个断言是测试用例的一部分，那么测试就会成功。
- en: 'Now, let us see how we can implement test cases using the Python `unittest`
    library. Doing so is quite easy and can be accomplished in a few easy-to-follow
    steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用Python的`unittest`库实现测试用例。这样做相当简单，可以按照以下几个易于遵循的步骤完成：
- en: 'Import the `unittest` module, which allows us to build the test cases:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`unittest`模块，它允许我们构建测试用例：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the module is imported, you can create a class whose name starts with
    `Test`, which inherits from the `TestCase` class provided by the `unittest` module:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模块被导入，你可以创建一个以`Test`开头的新类，该类继承自`unittest`模块提供的`TestCase`类：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Only if the `TestMyModule` class inherits the `TestCase` class will Django be
    able to run it automatically with full integration with the framework. Once the
    class is defined, we can implement a new method inside the class named `test_method_a()`,
    which validates an assertion.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有当`TestMyModule`类继承自`TestCase`类时，Django才能自动运行它，并且与框架完全集成。一旦类被定义，我们就可以在类内部实现一个新的方法，命名为`test_method_a()`，该方法验证断言。
- en: Note
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: An important part to note here is the naming scheme for the test cases and test
    functions. The test cases being implemented should be prefixed with the name `test`,
    such that the test execution modules can detect them as valid test cases and execute
    them. The same rule applies to the naming of testing methods.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要部分是测试用例和测试函数的命名方案。所实现的测试用例应该以`test`为前缀，这样测试执行模块可以检测它们作为有效的测试用例并执行它们。同样的规则也适用于测试方法的命名。
- en: 'Once the test case is written, it can be simply executed by running the following command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦编写了测试用例，就可以简单地通过运行以下命令来执行它：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, with our basic understanding of implementing test cases clarified, let
    us write a very simple unit test to see how the unit testing framework behaves
    inside Django.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，随着我们对实现测试用例的基本理解已经明确，让我们编写一个非常简单的单元测试来查看单元测试框架在Django中的行为。
- en: 'Exercise 14.01: Writing a Simple Unit Test'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.01：编写简单的单元测试
- en: In this exercise, you will write a simple unit test to understand how the Django
    unit testing framework works and use this knowledge to implement your first test
    case that validates a couple of simple expressions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个简单的单元测试来了解Django单元测试框架的工作方式，并使用这些知识来实现你的第一个测试用例，该测试用例验证几个简单的表达式。
- en: 'To get started, open the `tests.py` file under the `reviews` application of
    the `Bookr` project. By default, this file will contain only a single line that
    imports Django''s `TestCase` class from the `test` module. In case the file already
    has a couple of test cases, you can remove all the lines in the file except the
    one which imports the `TestCase` class as shown next:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，打开`Bookr`项目下`reviews`应用的`tests.py`文件。默认情况下，该文件将只包含一行，导入Django的`TestCase`类。如果文件已经包含几个测试用例，你可以删除文件中除导入`TestCase`类的行之外的所有行，如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following lines of code in the `tests.py` file you just opened:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你刚刚打开的`tests.py`文件中添加以下代码行：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you created a new class named `TestSimpleComponent`, which inherits from
    the `TestCase` class provided by Django's `test` module. The `assert` statement
    will compare the expression on the left-hand side (`1 + 1`) with the one on the
    right (`2`).
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个名为 `TestSimpleComponent` 的新类，它继承自 Django 的 `test` 模块提供的 `TestCase`
    类。`assert` 语句将比较左侧的表达式（`1 + 1`）与右侧的表达式（`2`）。
- en: 'Once you have written the test case, navigate back to the project folder, and
    run the following command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你编写了测试用例，导航回项目文件夹，并运行以下命令：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following output should be generated:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该生成以下输出：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding output signifies that Django's test runner executed one test case,
    which successfully passed the evaluation.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的输出表明 Django 的测试运行器执行了一个测试用例，该测试用例成功通过了评估。
- en: 'With the test case confirmed to be working and passing, now try to add another
    assertion at the end of the `test_basic_sum()` method, as shown in the following
    code snippet:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认测试用例正常工作并通过测试后，现在尝试在 `test_basic_sum()` 方法的末尾添加另一个断言，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the `assert` statement added to `tests.py`, now execute the test cases
    by running the following command from the project folder:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tests.py` 文件中添加了 `assert` 语句后，现在可以从项目文件夹中运行以下命令来执行测试用例：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, you will notice Django reporting that the execution of the test
    cases has failed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你会注意到 Django 报告测试用例的执行失败了。
- en: With this, you now have an understanding of how test cases can be written in
    Django and how assertions can be used to validate whether the output generated
    from your method calls under test is correct or not.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你现在已经了解了如何在 Django 中编写测试用例以及如何使用断言来验证测试方法调用生成的输出是否正确。
- en: Types of Assertions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言类型
- en: 'In *Exercise 14.01*, *Writing a Simple Unit Test*, we had a brief encounter
    with assertions when we came across the following `assert` statement:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *练习 14.01*，*编写简单的单元测试* 中，当我们遇到以下 `assert` 语句时，我们对断言有了一个简短的接触：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These assertion statements are simple and use the Python `assert` keyword.
    There are a few different types of assertions possible that can be tested inside
    a unit test while using the `unittest` library. Let us look at those:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些断言语句很简单，使用了 Python 的 `assert` 关键字。在使用 `unittest` 库进行单元测试时，有几种不同的断言类型可以进行测试。让我们看看那些：
- en: '`assertIsNone`: This assertion is used to check whether an expression evaluates
    to `None` or not. For example, this type of assertion can be used in cases where
    a query to a database returns `None` because no records were found for the specified
    filtering criteria.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsNone`：这个断言用于检查一个表达式是否评估为 `None`。例如，这种类型的断言可以在查询数据库返回 `None` 的情况下使用，因为没有找到指定过滤条件下的记录。'
- en: '`assertIsInstance`: This assertion is used to validate whether a provided object
    evaluates to an instance of the provided type. For example, we can validate whether
    the value returned by a method is indeed of a specific type, such as list, dict,
    tuple, and so on.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsInstance`：这个断言用于验证提供的对象是否评估为提供的类型的实例。例如，我们可以验证方法返回的值是否确实为特定的类型，如列表、字典、元组等。'
- en: '`assertEquals`: This is a very basic function that takes in two arguments and
    checks whether the provided arguments to it are equal in value or not. This can
    be useful when you plan to compare the values of data structures that do not guarantee
    ordering.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals`：这是一个非常基础的函数，它接受两个参数并检查提供给它的参数是否在值上相等。这在你计划比较那些不保证排序的数据结构的值时可能很有用。'
- en: '`assertRaises`: This method is used to validate whether the name of the method
    provided to it when called raises a specified exception or not. This is helpful
    when we are writing test cases where a code path that raises an exception needs
    to be tested. As an example, this kind of assertion can be useful when we want
    to want to make sure an exception is raised by a method performing a database
    query (say, to let us know if the database connection is not yet established).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRaises`：这个方法用于验证当调用它时，提供给它的方法名称是否引发了指定的异常。这在编写测试用例时很有用，其中需要测试引发异常的代码路径。例如，这种断言在确保执行数据库查询的方法（例如，让我们知道数据库连接是否尚未建立）引发异常时可能很有用。'
- en: These were just a small set of useful assertions that we can make in our test
    cases. The `unittest` module on top of which Django's testing library is built
    provides a lot more assertions that can be tested for.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我们可以在测试用例中做出的一小部分有用的断言。Django 测试库建立在 `unittest` 模块之上，它提供了更多可以进行测试的断言。
- en: Performing Pre-Test Setup and Cleanup after Every Test Case Run
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在每个测试用例运行后执行预测试设置和清理
- en: Sometimes while writing test cases, we may need to perform some repetitive tasks;
    for example, setting up some variables that will be required for the test. Once
    the test is over, we would want to clean up all the changes made to the test variables,
    such that any new test starts with a fresh instance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试用例时，有时我们可能需要执行一些重复性任务；例如，设置一些测试所需的变量。一旦测试完成，我们希望清理所有对测试变量的更改，以便任何新的测试都从一个全新的实例开始。
- en: Luckily, the `unittest` library provides a useful way through which we can automate
    our repetitive efforts of setting up the environment before every test case runs
    and cleaning it up after the test case is finished. This is achieved using the
    following two methods, which we can implement in `TestCase`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`unittest`库提供了一种有用的方法，通过它可以自动化我们在每个测试用例运行之前设置环境以及在测试用例完成后清理环境时的重复性工作。这是通过以下两个方法实现的，我们可以在`TestCase`中实现这些方法。
- en: '`setUp()`: This method is called before the execution of every `test` method
    inside the `TestCase` class. It implements the code required to set up the test
    case''s environment before the test executes. This method can be a good place
    to set up any local database instance or test variables that may be required for
    the test cases.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()`：此方法在`TestCase`类中每个`test`方法执行之前调用。它实现了在测试执行之前设置测试用例环境的代码。此方法可以是一个设置任何本地数据库实例或测试变量的好地方，这些变量可能对测试用例是必需的。'
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `setUp()` method is valid only for test cases written inside the `TestCase`
    class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()`方法仅适用于在`TestCase`类内部编写的测试用例。'
- en: 'For example, the following example illustrates a simple definition of how the
    `setUp()` method is used inside a `TestCase` class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下示例说明了如何在`TestCase`类内部使用`setUp()`方法的一个简单定义：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, when we try to execute the test cases, the `setUp()`
    method we defined here will be called every time before a `test` method executes.
    In other words, the `setUp()` method will be called before the execution of the
    `test_method_a()` call and then it will be called again before `test_method_b()`
    is called.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当我们尝试执行测试用例时，我们定义的`setUp()`方法将在每次`test`方法执行之前调用。换句话说，`setUp()`方法将在`test_method_a()`调用之前调用，然后它将在`test_method_b()`调用之前再次调用。
- en: '`tearDown()`: This method is called once the `test` function finishes execution
    and cleans up the variables and their values once the test case execution is finished.
    This method is executed no matter whether the test case evaluates to `True` or
    `False`. An example of using the `tearDown()` method is shown next:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`tearDown()`：此方法在`test`函数执行完毕后调用，并在测试用例执行完毕后清理变量及其值。无论测试用例评估结果为`True`还是`False`，都会执行此方法。下面将展示如何使用`tearDown()`方法的示例：'
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, the `tearDown()` method will be called every time
    a `test` method finishes execution, that is, once `test_method_a()` finishes execution
    and again once after `test_method_b()` finishes execution.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`tearDown()`方法将在每次`test`方法执行完毕时调用，即`test_method_a()`执行完毕后，再次在`test_method_b()`执行完毕后。
- en: Now, we are aware of the different components of writing test cases. Let us
    now look at how we can test the different aspects of a Django application using
    the provided test framework.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了编写测试用例的不同组件。让我们看看如何使用提供的测试框架来测试Django应用程序的不同方面。
- en: Testing Django Models
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Django模型
- en: Models in Django are object-based representations of how the data will be stored
    inside the database of an application. They provide methods that can help us validate
    the data input provided for a given record, as well as performing any processing
    on the data before it is inserted into the database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Django中的模型是数据将在应用程序数据库中存储的对象表示。它们提供了可以帮助我们验证给定记录提供的数据输入的方法，以及在数据插入数据库之前对数据进行任何处理的方法。
- en: As easy as it is to create models in Django, it is equally easy to test them.
    Now, let us look at how Django models can be tested using the Django test framework.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Django中创建模型一样容易，测试它们也同样简单。现在，让我们看看如何使用Django测试框架来测试Django模型。
- en: 'Exercise 14.02: Testing Django Models'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.02：测试Django模型
- en: 'In this exercise, you will create a new Django model and write test cases for
    it. The test case will validate whether your model can correctly insert and retrieve
    the data from the database. These kinds of test cases that work on database models
    can turn out to be useful in cases where a team of developers is collaborating
    on a large project and the same database model may get modified by multiple developers
    over time. Implementing test cases for database models allows developers to pre-emptively
    identify potentially breaking changes that they may inadvertently introduce as
    a part of their work:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个新的 Django 模型，并为它编写测试用例。这个测试用例将验证您的模型是否能够正确地将数据插入和从数据库中检索。这类在数据库模型上运行的测试用例在团队开发大型项目时可能非常有用，因为同一个数据库模型可能会随着时间的推移被多个开发者修改。为数据库模型实现测试用例允许开发者预先识别他们可能在不经意间引入的潜在破坏性更改：
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To ensure we get a good hang of running tests from scratch on newly created
    apps, we'll be creating a new application called `bookr_test`. This application's
    code is independent of the main `bookr` application and consequently, we won't
    be including this app's files in the `final/bookr` folder. Upon completion of
    this chapter, we recommend you practice what you learned by writing similar tests
    for various components of the main `bookr` application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们能够熟练地从零开始在新创建的应用程序上运行测试，我们将创建一个新的应用程序，名为 `bookr_test`。这个应用程序的代码与主 `bookr`
    应用程序独立，因此，我们不会将这个应用程序的文件包含在 `final/bookr` 文件夹中。完成本章内容后，我们建议您通过为 `bookr` 应用程序的各种组件编写类似的测试来练习您所学的知识。
- en: 'Create a new application, which you will use for the exercises in this chapter.
    To do this, run the following command, which will set up a new application for
    your use case:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序，您将使用它来完成本章的练习。为此，运行以下命令，这将为您的情况设置一个新的应用程序：
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To make sure the `bookr_test` application behaves the same way as any other
    application in the Django project, add this application to our `INSTALLED_APPS`
    section of the `bookr` project. To do this, open the `settings.py` file in your
    `bookr` project and append the following code to the `INSTALLED_APPS` list:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保 `bookr_test` 应用程序的行为与 Django 项目中的任何其他应用程序相同，将此应用程序添加到 `bookr` 项目的 `INSTALLED_APPS`
    部分中。为此，打开您的 `bookr` 项目的 `settings.py` 文件，并将以下代码追加到 `INSTALLED_APPS` 列表中：
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, with the application setup complete, create a new database model, which
    you will use for testing purposes. For this exercise, you are going to create
    a new model named `Publisher`, which will store the details about the book publisher
    in our database. To create the model, open the `models.py` file under the `bookr_test`
    directory and add the following code to it:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，随着应用程序设置的完成，创建一个新的数据库模型，您将使用它来进行测试。对于这个练习，您将创建一个名为 `Publisher` 的新模型，该模型将存储有关书籍出版商的详细信息。要创建模型，打开
    `bookr_test` 目录下的 `models.py` 文件，并将以下代码添加到其中：
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code snippet, you have created a new class named `Publisher`,
    which inherits from the `Model` class of Django''s `models` module, defining the
    class as a Django model, which will be used to store data about the publisher:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您创建了一个名为 `Publisher` 的新类，该类继承自 Django 的 `models` 模块中的 `Model` 类，将类定义为
    Django 模型，该模型将用于存储有关出版商的数据：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Inside this model, you have added three fields, which will act as the properties
    of the model:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个模型内部，您添加了三个字段，这些字段将作为模型的属性：
- en: '`name`: The name of the publisher'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`name`: 出版商的名称'
- en: '`website`: The website belonging to the publisher'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`website`: 出版商的网站'
- en: '`email`: The email address of the publisher'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`email`: 出版商的电子邮件地址'
- en: Once this is done, you create a class method, `__str__()`, which defines how
    the string representation of the model will look.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此操作后，您创建了一个类方法 `__str__()`，它定义了模型字符串表示的形式。
- en: 'Now, with the model created, you first need to migrate this model before you
    can run a test on it. To do this, run the following commands:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，模型已经创建，您首先需要迁移此模型，然后才能在它上面运行测试。为此，运行以下命令：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the model now set up, write the test case with which you are going to
    test the model created in *step 3*. For this, open the `tests.py` file under the
    `bookr_test` directory and add the following code to it:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在模型已经设置好了，编写测试用例来测试在 *步骤 3* 中创建的模型。为此，打开 `bookr_test` 目录下的 `tests.py` 文件，并将以下代码添加到其中：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code snippet, there are a couple of things worth exploring.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，有几个值得探讨的地方。
- en: At the start, after importing the `TestCase` class from the Django `test` module,
    you imported the `Publisher` model from the `bookr_test` directory, which is going
    to be used for testing.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在开始时，在从Django的`test`模块导入`TestCase`类之后，你从`bookr_test`目录导入了`Publisher`模型，该模型将被用于测试。
- en: 'Once the required libraries were imported, you created a new class named `TestPublisherModel`,
    which inherits the `TestCase` class and is used for grouping the unit tests related
    to the `Publisher` model:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入所需的库之后，你创建了一个名为`TestPublisherModel`的新类，它继承自`TestCase`类，并用于组织与`Publisher`模型相关的单元测试：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside this class, you defined a couple of methods. First, you defined a new
    method named `setUp()` and added the `Model` object creation code inside it such
    that the `Model` object is created every time a new `test` method is executed
    inside this test case. This `Model` object is stored as a class member, such that
    it can be accessed inside other methods without a problem:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个类中，你定义了一些方法。首先，你定义了一个名为`setUp()`的新方法，并在其中添加了`Model`对象创建的代码，这样每次在这个测试用例中执行新的`test`方法时，都会创建一个`Model`对象。这个`Model`对象被存储为类成员，这样就可以在其他方法中无问题地访问它：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first test case validates whether the `Model` object for the `Publisher`
    model was created successfully or not. To do this, you created a new method named
    `test_create_publisher()`, inside which you check whether the created Model object
    points to an object of the `Publisher` type. If this `Model` object was not created
    successfully, your test will fail:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个测试用例验证`Publisher`模型的`Model`对象是否创建成功。为此，你创建了一个名为`test_create_publisher()`的新方法，在其中检查创建的模型对象是否指向`Publisher`类型的对象。如果这个`Model`对象没有成功创建，你的测试将失败：
- en: '[PRE22]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you check carefully, you are using the `assertIsInstance()` method of the
    `unittest` library here to assert whether the `Model` object belongs to the `Publisher`
    type or not.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你仔细检查，你在这里使用的是`unittest`库的`assertIsInstance()`方法来断言`Model`对象是否属于`Publisher`类型。
- en: 'The next test validates whether the string representation of the model is the
    same as what you expected it to be. From the code definition, the string representation
    of the `Publisher` model should output the name of the publisher. To test this,
    you create a new method named `test_str_representation()` and check whether the
    generated string representation of the model matches the one you are expecting:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个测试验证模型的字符串表示是否与预期相同。从代码定义来看，`Publisher`模型的字符串表示应该输出出版者的名称。为了测试这一点，你创建了一个名为`test_str_representation()`的新方法，并检查生成的模型字符串表示是否与预期匹配：
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To perform this validation, you use the `assertEquals` method of the `unittest`
    library, which validates whether the two values provided to it are equal or not.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了执行这个验证，你使用`unittest`库的`assertEquals`方法，该方法验证提供的两个值是否相等。
- en: 'With the test cases now in place, you can run them to check what happens. To
    run these test cases, run the following command:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在测试用例已经就绪，你可以运行它们来检查会发生什么。要运行这些测试用例，请运行以下命令：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the command finishes execution, you will see an output that resembles
    the one shown here (your output may differ slightly, though):'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦命令执行完成，你将看到类似于以下输出的输出（你的输出可能略有不同）：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see from the preceding output, the test cases are executed successfully,
    hence validating that the operations such as the creation of a new `Publisher`
    object and its string representation when fetched are being done correctly.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，测试用例执行成功，从而验证了诸如创建新的`Publisher`对象及其在检索时的字符串表示等操作是否正确执行。
- en: With this exercise, we got to see how we can write test cases for our Django
    models easily and validate their functioning, involving the creation of objects,
    their retrieval, and representation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们看到了如何轻松编写Django模型的测试用例并验证其功能，包括对象的创建、检索和表示。
- en: 'Also, there is an important line to notice in the output from this exercise:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这个练习的输出中还有一行重要的内容需要注意：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This happens because when there are test cases that require the data to be persisted
    inside a database, instead of using the production database, Django creates a
    new empty database for the test cases, which it uses to persist the value for
    the test case.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当存在需要将数据持久化存储在数据库中的测试用例时，Django不会使用生产数据库，而是为测试用例创建一个新的空数据库，它使用这个数据库来持久化测试用例的值。
- en: Testing Django Views
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Django视图
- en: Views in Django control the rendering of the HTTP response for users based on
    the URL they visit in a web application. In this section, we will get on to understand
    how we can test views inside Django. Imagine you are working on a website where
    a lot of **Application Programming Interface** (**API**) endpoints are required.
    An interesting question to ask would be, how will you be able to validate every
    new endpoint? If done manually, you will have to first deploy the application
    every time a new endpoint is added, then manually visit the endpoint in the browser
    to validate whether it is working fine or not. Such an approach may work out when
    the number of endpoints is low but may become extremely cumbersome if there are
    hundreds of endpoints.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Django provides a very comprehensive way of testing application views. This
    happens with the use of a testing client class provided by Django''s `test` module.
    This class can be used to visit URLs mapped to the views and capture the output
    generated by visiting the URL endpoint. Then we can use the captured output to
    test whether the URLs are generating a correct response or not. This client can
    be used by importing the `Client` class from the Django `test` module and then
    initializing it as shown in the following snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The client object supports several methods that can be used to simulate the
    different HTTP calls a user can make, namely, `GET`, `POST`, `PUT`, `DELETE`,
    and so on. An example of making such a request will look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The response generated by the view is then captured by the client and gets exposed
    as a `response` object, which can then be queried to validate the output of the
    view.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, now let us look at how we can write test cases for our
    Django views.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.03: Writing Unit Tests for Django Views'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the Django test client to write a test case
    for your Django view, which will be mapped to a specific URL. These test cases
    will help you validate whether your view function generates the correct response
    when visited using its mapped URL:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you are going to use the `bookr_test` application that was
    created in *step 1* of *Exercise 14.02*, *Testing Django Models*. To get started,
    open the `views.py` file under the bookr_test directory and add the following
    code to it:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, you have created a simple Django view, which will be used to greet the
    user with a welcome message whenever they visit an endpoint mapped to the provided
    view.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this view is created, you need to map it to a URL endpoint, which can
    then be visited in a browser or a test client. To do this, open the `urls.py`
    file under the `bookr_test` directory and add the highlighted code to the `urlpatterns` list:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once this path is set up, you need to make sure that it is also identified
    by your project. To do this, you need to add this entry to the `bookr` project''s
    URL mapping. To achieve that, open the `urls.py` file in the `bookr` directory
    and append the following highlighted line to the end of the `urlpatterns` list,
    as shown next:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once the view is set up, validate whether it works correctly. Do this by running
    the following command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then visit `http://localhost:8080/test/greeting` in your web browser. Once
    the page opens, you should see the following text, which you added to the greeting
    view in *step 1*, being displayed in the browser:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, you are ready to write the test cases for `greeting_view`. In this exercise,
    you are going to write a test case that checks whether, on visiting the `/test/greeting`
    endpoint, you get a successful result or not. To implement this test case, open
    the `tests.py` file under the `bookr_test` directory and add the following code
    at the end of the file:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code snippet, you have defined a test case that helps in validating
    whether the greeting view is working fine or not.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is done by first importing Django''s test client, which allows testing
    views mapped to the URLs by making calls to them and analyzing the generated response:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the import is done, you now create a new class named `TestGreetingView`,
    which will group the test cases related to the greeting view that you created
    in *step 2*:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside this test case, you defined two methods, `setUp()` and `test_greeting_view()`.
    The `test_greeting_view()` method implements your test case. Inside this, you
    first make an HTTP `GET` call to the URL that is mapped to the greeting view and
    then store the response generated by the view inside the `response` object created:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once this call finishes, you will have its HTTP response code, contents, and
    headers available inside the `response` variable. Next, with the following code,
    you make an assertion validating whether the status code generated by the call
    matches the status code for successful HTTP calls (`HTTP 200`):'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this, you are now ready to run the tests.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the test case written, let''s look at what happens when you run the test
    case:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once the command executes, you can expect to see an output like the one shown
    in the following snippet:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see from the output, your test cases executed successfully, hence
    validating that the response generated by the `greeting_view()` method is as per
    your expectations.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, you learned how you can implement a test case for a Django
    view function and use `TestClient` provided by Django to assert that the output
    generated by the view function matches the one that the developer should see.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Testing Views with Authentication
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we looked at how we can test views inside Django. An
    important part to be highlighted about this view is that the view we created could
    be accessed by anyone and is not protected by any authentication or login checks.
    Now imagine a case where a view should only be accessible if the user is logged
    in. For example, imagine implementing a view function that renders the profile
    page of a registered user of our web application. To make sure that only logged-in
    users can view the profile page for their account, you might want to restrict
    the view to logged-in users only.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we now have an important question: *How can we test views that require authentication?*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Django''s test client provides this functionality through which we
    can log in to our views and then run tests on them. This result can be achieved
    by using Django''s test client `login()` method. When this method is called, Django''s
    test client performs an authentication operation against the service and if the
    authentication succeeds, it stores the login cookie internally, which it can then
    use for further test runs. The following code snippet shows how you can set up
    Django''s test client to simulate a logged-in user:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `login` method requires a username and password for the test user that we
    are going to test with, as will be shown in the next exercise. So, let us look
    at how we can test a flow that requires user authentication.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.04: Writing Test Cases to Validate Authenticated Users'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will write test cases for views that require the user
    to be authenticated. As part of this, you will validate the output generated by
    the view method when a user who is not logged in tries to visit the page and when
    a user who is logged in tries to visit the page mapped to the view function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you are going to use the `bookr_test` application that you
    created in *step 1* of *Exercise 14.02*, *Testing Django Models*. To get started,
    open the `views.py` file under the bookr_test application and add the following
    code to it:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once the preceding code snippet is added, create a new function, `greeting_view_user()`,
    at the end of the file, as shown in the following code snippet:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With this, you have created a simple Django view that will be used to greet
    the logged-in user with a welcome message whenever they visit an endpoint mapped
    to the provided view.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this view is created, you need to map this view to a URL endpoint that
    can then be visited in a browser or a test client. To do this, open the `urls.py`
    file under the `bookr_test` directory and add the following highlighted code to
    it:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the view is set up, the next thing you need to do is to validate whether
    it works correctly. To do this, run the following command:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then visit `http://localhost:8080/test/greet_user` in your web browser.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are not logged in already, by visiting the preceding URL, you will be
    redirected to the login page for the project.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, write the test cases for `greeting_view_user`, which checks whether, on
    visiting the `/test/greet_user` endpoint, you get a successful result. To implement
    this test case, open the `tests.py` file under the `bookr_test` directory and
    add the following code to it:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding code snippet, you have implemented a test case that checks
    the views that have authentication enabled before their content can be seen.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this, you first imported the required classes and methods that will be
    used to define the test case and initialize a testing client:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The next thing you require is the `User` model from Django''s `auth` module:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This model is required because for the test cases requiring authentication,
    you will need to initialize a new test user. Next up, you created a new class
    named `TestLoggedInGreetingView`, which wraps your tests related to the `greeting_user`
    view (which requires authentication). Inside this class, you defined three methods,
    namely: `setUp()`, `test_user_greeting_not_authenticated()`, and `test_user_authenticated()`.
    The `setUp()` method is used to first initialize a test user, which you will use
    for authentication. This is a required step because a test environment inside
    Django is a completely isolated environment that doesn''t use data from your production
    application, hence all the required models and objects are to be instantiated
    separately inside the test environment.'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You then created the test user and initiated the test client using the following code:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next up, you wrote the test case for the `greet_user` endpoint when the user
    is not authenticated. Inside this, you should expect Django to redirect the user
    to the login endpoint. This redirect can be detected by checking the HTTP status
    code of the response, which should be set to `HTTP 302`, indicating a redirect operation:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, you wrote another test case to check whether the `greet_user` endpoint
    renders successfully when the user is authenticated. To authenticate the user,
    you first call the `login()` method of the test client and perform authentication
    by providing the username and password of the test user you created in the `setUp()`
    method as follows:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the login is completed, you make an `HTTP GET` request to the `greet_user`
    endpoint and validate whether the endpoint generates a correct result or not by
    checking the HTTP status code of the returned response:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With the test cases written, it is time to check how they run. For this, run
    the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once the execution finishes, you can expect to see a response that resembles
    the one that follows:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we can see from the preceding output, our test cases have passed successfully,
    validating that the view we created generates the desired response of redirecting
    the user if the user is unauthenticated to the website, and allows the user to
    see the page if the user is authenticated.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we just implemented a test case where we can test the output
    generated by a view function regarding the authentication status of the user.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Django Request Factory
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we have been using Django's test client to test the views we have
    created for our application. The test client class simulates a browser and uses
    this simulation to make calls to the required APIs. But what if we did not want
    to use the test client and its associated simulation of being a browser, but rather
    wanted to test the view functions directly by passing the request parameter? How
    can we do that?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us in such cases, we can leverage the `RequestFactory` class provided
    by Django. The `RequestFactory` class helps us provide the `request` object, which
    we can pass to our view functions to evaluate their working. The following object
    for `RequestFactory` can be created by instantiating the class as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `factory` object thus created supports only HTTP methods such as `get()`,
    `post()`, `put()`, and others, to simulate a call to any URL endpoint. Let us
    look at how we can modify the test case that we wrote in *Exercise 14.04*, *Writing
    Test Cases to Validate Authenticated Users*, to use `RequestFactory`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.05: Using a Request Factory to Test Views'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use a request factory to test view functions in
    Django:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you are going to use the existing `greeting_view_user` view
    function, which you created earlier, in *step 1* of *Exercise 14.04*, *Writing
    Test Cases to Validate Authenticated Users*, which is shown as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Next, modify the existing test case, `TestLoggedInGreetingView`, defined inside
    the `tests.py` file under the `bookr_test` directory. Open the `tests.py` file
    and make the following changes.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, you need to add the following import to use `RequestFactory` inside
    the test cases:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The next thing you need is an import for the `AnonymousUser` class from Django''s
    `auth` module and the `greeting_view_user` view method from the `views` module.
    This is required to test the view functions with a simulated user who is not logged
    in. This can be done by adding the following code:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once the `import` statements are added, modify the `setUp()` method of the
    `TestLoggedInGreetingView` class and change its contents to resemble the one shown
    next:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this method, you first created a `user` object and stored it as a class member
    such that you can use it later in the tests. Once the `user` object is created,
    then instantiate a new instance of the `RequestFactory` class to use it for testing
    our view function.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the `setUp()` method now defined, modify the existing tests to use the
    `RequestFactory` instance. For the test for a non-authenticated call to the view
    function, modify the `test_user_greeting_not_authenticated` method to have the
    following contents:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this method, you first created a `request` object using the `RequestFactory`
    instance you defined in the `setUp()` method. Once that was done, you assigned
    an `AnonymousUser()` instance to the `request.user` property. Assigning the `AnonymousUser()`
    instance to the property makes the view function think that the user making the
    request is not logged in:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once this is done, you made a call to the `greeting_view_user()` view method
    and passed to it the `request` object you created. Once the call is successful,
    you capture the output of the method in the `response` variable using the following
    code:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For the unauthenticated user, you expect to get a redirect response, which
    can be tested by checking the HTTP status code of the response as follows:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once this is done, go ahead and modify the other method, `test_user_authenticated()`,
    similarly by using the `RequestFactory` instance as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see, most of the code resembles the code you wrote in the `test_user_greeting_not_authenticated`
    method, with the small change that, in this method, instead of using `AnonymousUser`
    for our `request.user` property, you are using `test_user`, which you created
    in our `setUp()` method:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: With the changes done, it is time to run the tests.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run the tests and validate whether the request factory works as expected,
    run the following command:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once the command executes, you can expect to see an output that resembles the
    one shown next:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As we can see from the output, the test cases written by us have passed successfully,
    hence validating the behavior of the `RequestFactory` class.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this exercise, we learned how we can write test cases for view functions
    leveraging `RequestFactory` and passing the `request` object directly to the view
    function, rather than simulating a URL visit using the test client approach, and
    hence allowing more direct testing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Testing Class-Based Views
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we saw how we can test views defined as methods. But
    what about class-based views? How can we test those?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, it is quite easy to test class-based views. For example, if
    we have a class-based view defined with the name `ExampleClassView(View)`, to
    test the view, all we need to do is to use the following syntax:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It is as simple as that.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: A Django application generally consists of several different components that
    can work in isolation, such as models, and some other components that need to
    interact with the URL mapping and other parts of the framework to work. Testing
    these different components may require some steps that are common only to those
    components. For example, when testing a model, we might first want to create certain
    objects of the `Model` class before we start testing, or for views, we might first
    want to initialize a test client with user credentials.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, Django also provides some other classes based on top of the
    `TestCase` class, which can be used to write test cases of specific types about
    the type of the component being used. Let us look at these different classes provided
    by Django.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Test Case Classes in Django
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond the base `TestCase` class provided by Django, which can be used to define
    a multitude of test cases for different components, Django also provides some
    specialized classes derived from the `TestCase` class. These classes are used
    for specific types of test cases based on the capabilities they provide to the
    developer.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Let us take a quick look at them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: SimpleTestCase
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class is derived from the `TestCase` class provided by Django''s `test`
    module and should be used for writing simple test cases that test the view functions.
    Usually, the class is not preferred when your test case involves making database
    queries. The class also provides a lot of useful features, such as the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The ability to check for exceptions raised by a view function
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to test form fields
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A built-in test client
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to verify a redirect by a view function
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching the equality of two HTML, JSON, or XML outputs generated by the view functions
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, with a basic idea of what `SimpleTestCase` is, let us try to understand
    another type of test case class that helps in writing test cases involving interaction
    with databases.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: TransactionTestCase
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class is derived from the `SimpleTestCase` class and should be used when
    writing test cases that involve interaction with the database, such as database
    queries, model object creations, and so on.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The class provides the following added features:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The ability to reset the database to a default state before a test case runs
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipping tests based on database features – this feature can come in handy if
    the database being used for testing does not support all the features of a production database
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LiveServerTestCase
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class is like the `TransactionTestCase` class, but with the small difference
    that the test cases written in the class use a live server created by Django (instead
    of using the default test client).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: This ability to run the live server for testing comes in handy when writing
    test cases that test for the rendered web pages and any interaction with them,
    which is not possible while using the default test client.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Such test cases can leverage tools such as **Selenium**, which can be used to
    build interactive test cases that modify the state of the rendered page by interacting
    with it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing Test Code
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercises, we have seen how we can write test cases for different
    components of our project. But an important aspect to note is that, till now,
    we have written the test cases for all the components in a single file. This approach
    is okay when the application does not have a lot of views and models. But this
    can become problematic as our application grows because now our single `tests.py`
    file will be hard to maintain.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid running into such scenarios, we should try to modularize our test
    cases such that the test cases for models are kept separately from test cases
    related to the views, and so on. To achieve this modularization, all we need to
    do is two simple steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory named `tests` inside your application directory by running
    the following command:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a new empty file named `__init__.py` inside your tests directory by
    running the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This `__init__.py` file is required by Django to correctly detect the `tests`
    directory we created as a module and not a regular directory.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the preceding steps are done, you can go ahead and create new testing files
    for the different components in your application. For example, to write test cases
    for your models, you can create a new file named `test_models.py` inside the tests
    directory and add any associated code for your model testing inside this file.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you do not need to take any other additional steps to run your tests.
    The same command will work perfectly fine for your modular testing code base as
    well:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With this, we have now understood how we can write test cases for our projects.
    So, how about we assess this knowledge by writing test cases for the Bookr project
    that we are working on?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14.01: Testing Models and Views in Bookr'
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will implement test cases for the Bookr project. You will
    implement test cases to validate the functioning of the models created inside
    the `reviews` application of the Bookr project, and then you will implement a
    simple test case for validating the `reviews` application.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you work through this activity:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `tests` inside the `reviews` application directory,
    such that all our test cases for the `reviews` application can be modularized.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty `__init__.py` file, such that the directory is considered not
    as a general directory, but rather a Python module directory.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file, `test_models.py`, for implementing the code that tests the
    models. Inside this file, import the models you want to test.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `test_models.py`, create a new class that inherits from the `TestCase`
    class of the `django.tests` module and implements methods to validate the creation
    and reading of the `Model` objects.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test the view function, create a new file named `test_views.py` inside the
    `tests` directory, which was created in *step 1*.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `test_views.py` file, import the test `Client` class from the `django.tests`
    module and the `index` view function from the `reviews` application's `views.py`
    file.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `test_views.py` file created in *step 5*, create a new `TestCase`
    class, and implement methods to validate the index view.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `TestCase` class created in *step 7*, create a new function, `setUp()`,
    inside which you should initialize an instance of `RequestFactory`, which will
    be used to create a `request` object that can be directly passed to the view function
    for testing.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the previous steps are done and the test cases are written, run the test
    cases by executing the `python manage.py` test to validate that the test cases pass.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon completing this activity, all test cases should pass successfully.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we looked at how we can write test cases for different
    components of our web application project with Django. We learned about why testing
    plays a crucial role in the development of any web application and the different
    types of testing techniques that are employed in the industry to make sure the
    application code they ship is stable and bug-free.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how we can use the `TestCase` class provided by Django's `test`
    module to implement our unit tests, which can be used to test the models as well
    as views. We also looked at how we can use Django's `test` client to test our
    view functions that require or do not require the user to be authenticated. We
    also glanced over another approach of using `RequestFactory` to test method views
    and class-based views.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: We concluded the chapter by understanding the predefined classes provided by
    Django and where they should be used and looked at how we can modularize our testing
    codebase to make it appear clean.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: As we move on to the next chapter, we will try to understand how we can make
    our Django application more powerful by integrating third-party libraries into
    our project. This functionality will then be used to implement third-party authentication
    into our Django application and thus allow users to log in to the application
    using popular services such as Google Sign-In, Facebook Login, and more.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
