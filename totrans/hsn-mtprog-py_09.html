<html><head></head><body>
<div><div><h1 id="_idParaDest-88"><em class="italic"><a id="_idTextAnchor090"/>Chapter 7</em>: Understanding Generics and Typing</h1>
<p>In this chapter, we will look at what generics are and how to perform type checking in Python 3 and understand how it is useful in metaprogramming. </p>
<p>Python<a id="_idIndexMarker345"/> is a programming language where variables are declared as generics and they don’t get a data type assigned to them on the declaration. Python resolves the data types dynamically during runtime depending on the values assigned to variables. In other programming languages such as C++, generics need to be programmatically designed to make the variables generic, whereas in Python, generics are how the variables are defined. In such cases, how we would declare a variable with typing and restrict the behavior of the variables is what we will be focusing on in detail in this chapter.</p>
<p>Throughout this chapter, we will look at understanding how generics work in Python and how to define type checks so that we can apply metaprogramming on variables to statically type them so that we don’t have to wait for the complete program to run to determine that we have unintentionally used incorrect typing in our code.</p>
<p>In this chapter, we will be covering the following main topics:</p>
<ul>
<li>What are generics?</li>
<li>What happens when data types are specified?</li>
<li>Typing with explicit type checks – approach 1</li>
<li>Typing with explicit type checks – approach 2</li>
<li>Adding data types with constraints</li>
<li>Creating a simple custom data type</li>
<li>Creating a domain-specific data type</li>
</ul>
<p>By the end of this chapter, you should be able to apply generics and type checking on Python variables. You should also be able to create your own domain-specific data types.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor091"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter07">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter07</a>.</p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor092"/>What are generics?</h1>
<p><strong class="bold">Generics</strong> are<a id="_idIndexMarker346"/> a programming paradigm where any attribute or variable is a function in a language that is not assigned to any specific type. When we speak of type, it is either the variable data type or the function return type. </p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor093"/>How are generics connected to metaprogramming?</h2>
<p><strong class="bold">Metaprogramming</strong> deals <a id="_idIndexMarker347"/>with the concepts of Python 3 and above, where<a id="_idIndexMarker348"/> we can develop scripts or programs that manipulate the objects of Python externally without actually impacting the definition of classes, methods, or functions in a program. Generics are the way in which Python has built the handling of data types for its objects. If we need to change the data type handling in Python from generics to specific types, we can perform it through metaprogramming. To understand how to make specifics work, we need to understand generics with examples. Let’s look at generics in the following section.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor094"/>How are generics handled in Python?</h2>
<p>Here, we can<a id="_idIndexMarker349"/> investigate generics with an example. Throughout this <a id="_idIndexMarker350"/>chapter, we will look into another interesting section of our core example, <em class="italic">ABC Megamart</em>. In this chapter, we will be covering our examples using the clothing and fashion department of <em class="italic">ABC Megamart</em>. </p>
<p>Let’s <a id="_idIndexMarker351"/>consider the fashion department of <em class="italic">ABC Megamart</em> <a id="_idIndexMarker352"/>in this example. This department covers various clothing products. To examine generics, we will first define a class named <code>Fashion</code> with attributes such as <code>clothing_category</code>, <code>gender</code>, <code>model</code>, <code>design</code>, <code>dress_type</code>, <code>size</code>, and <code>color</code>. We will also add a method named <code>get_item</code> to return the preceding attributes. The code is defined as follows:</p>
<pre class="source-code">class Fashion:</pre>
<pre class="source-code">    def __init__(self,clothing_category,gender,model,design,dress_type,size, color):</pre>
<pre class="source-code">        self.clothing_category = clothing_category</pre>
<pre class="source-code">        self.gender = gender</pre>
<pre class="source-code">        self.model = model</pre>
<pre class="source-code">        self.design = design</pre>
<pre class="source-code">        self.dress_type = dress_type</pre>
<pre class="source-code">        self.size = size</pre>
<pre class="source-code">        self.color = color</pre>
<pre class="source-code">     def get_item(self):</pre>
<pre class="source-code">        return self.clothing_category,self.gender,self.model,self.design,self.dress_type, self.size,self.color        </pre>
<p>This code handles generics. Let’s explain this statement by assigning values of any data types to the attributes of <code>Fashion</code>:</p>
<pre class="source-code">fashion = Fashion("Clothing","Women","Western","Dotted","Jumpsuits",38,"blue")</pre>
<p>We have added string values to <code>clothing_category</code>, <code>gender</code>, <code>model</code>, <code>design</code>, <code>dress_type</code>, and <code>color</code>, while we added an integer value to the <code>size</code> attribute. Since the language handles generics by default, we did not have to declare the data types and the values are accepted without throwing any errors. We can call the <code>get_item</code> method to display these generic values:</p>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code"><strong class="bold">('Clothing', 'Women', 'Western', 'Dotted', 'Jumpsuits', 38, 'blue')</strong></pre>
<p>Examining the data types of <code>clothing_category</code> and <code>size</code> results as follows:</p>
<pre class="source-code">type(fashion.clothing_category)</pre>
<pre class="source-code"><strong class="bold">str</strong></pre>
<pre class="source-code">type(fashion.size)</pre>
<pre class="source-code"><strong class="bold">int</strong></pre>
<p>Let’s double-check our statement on generics now. What happens when we change the data types of input variables? Will they be accepted by Python? To test this, let’s change the data types of <code>clothing_category</code> and <code>size</code>:</p>
<pre class="source-code">fashion = Fashion(102,"Women","Western","Floral","T-Shirt","XS","green")</pre>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code"><strong class="bold">(102, 'Women', 'Western', 'Floral', 'T-Shirt', 'XS', 'green')</strong></pre>
<p>The change<a id="_idIndexMarker353"/> in data types is accepted and processed by Python and can<a id="_idIndexMarker354"/> be viewed as follows:</p>
<pre class="source-code">type(fashion.clothing_category)</pre>
<pre class="source-code"><strong class="bold">int</strong></pre>
<pre class="source-code">type(fashion.size)</pre>
<pre class="source-code"><strong class="bold">str</strong></pre>
<p>In the preceding example, no matter which data type the input value belongs to, they are processed successfully. In the following section, let’s explicitly assign data types and check further.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor095"/>What happens when data types are specified?</h1>
<p>Annotations<a id="_idIndexMarker355"/> in Python are added to code to provide additional information or help to end users with a piece of code while creating libraries. Annotations can be used to add data types to a specific code so that the information on data types can later be retrieved using the annotations by developers.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor096"/>Type hints as annotations</h2>
<p>In the context of typing, which is the topic of this chapter, let’s look at type hints in this section. Data types of a function or method can be defined in Python using a functionality of <a id="_idIndexMarker356"/>annotations called <code>Fashion</code> class by declaring type hints on the methods of the class. To implement this, we can explicitly assign a data type and its return type to a variable while declaring a variable and adding it to a method in Python. We will also add a type hint for the return type of a method. </p>
<p>Let’s declare the <code>Fashion</code> class initialized with its attributes or variables along with the data types, which we would expect the variables to be on:</p>
<pre class="source-code">class Fashion:</pre>
<pre class="source-code">    def __init__(self,clothing_category<code>: str</code>,gender<code>:str</code>,model<code>:str</code>,design<code>:str</code>,dress_type<code>:str</code>,size<code>:int</code>, color<code>:str</code>):</pre>
<pre class="source-code">        self.clothing_category = clothing_category</pre>
<pre class="source-code">        self.gender = gender</pre>
<pre class="source-code">        self.model = model</pre>
<pre class="source-code">        self.design = design</pre>
<pre class="source-code">        self.dress_type = dress_type</pre>
<pre class="source-code">        self.size = size</pre>
<pre class="source-code">        self.color = color</pre>
<pre class="source-code">    def get_item(self) <code>-&gt; list</code>:</pre>
<pre class="source-code">        return self.clothing_category,self.gender,self.model,self.design,self.dress_type, self.size,self.color</pre>
<p>In the preceding <a id="_idIndexMarker359"/>code, we have specifically tagged a data type to each variable. In this class, we will also add a <code>get_item</code> method and add annotation with a type hint specifying that this method returns a <code>list</code> item.</p>
<p>Let’s now check what happens when these data types are not followed while creating an object and assigning values to these variables:</p>
<pre class="source-code">fashion = Fashion(104,"Women","Western","Cotton","Shirt","S","white")</pre>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code">[<strong class="bold">104</strong>, 'Women', 'Western', 'Cotton', 'Shirt', <strong class="bold">'S'</strong>, 'white']</pre>
<p>We have declared <code>clothingCategory_c</code> as a string and <code>size</code> as an integer in the preceding class definition but we have assigned an integer to <code>clothing_category</code> and a string to the <code>size</code> variables. The program still ran successfully without throwing any type error, while there should, ideally, have been a type error in this case. This example again proves that types are handled as generics in Python when we assign a data type during variable declaration. </p>
<p>Let’s also look at the annotation for the <code>get_item</code> method in the following code:</p>
<pre class="source-code">print(Fashion.get_item.__annotations__)</pre>
<p>Calling <code>__annotations__</code> on the <a id="_idIndexMarker360"/>method provides the list data type annotated as the return type for the method:</p>
<pre class="source-code">{'return': &lt;class 'list'&gt;}</pre>
<p>Let’s look further into the concept of typing, in which we can look at how to deal with specific types instead of generics.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor097"/>Typing with explicit type checks – approach 1</h1>
<p>In the <a id="_idIndexMarker361"/>preceding section, we looked at Python’s ability to handle data types as generics. While building an application, there can be scenarios where a variable will need a specific data type, and we might expect metaprogramming to have the ability to handle such specific data types. In this section, let’s look at creating a class to perform type checking.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Creating a class to implement type checking   </h2>
<p>In this<a id="_idIndexMarker362"/> example, we will be creating a class named <code>typecheck</code> and adding methods to check each data type specifically. If a data type, for instance, an integer type, is provided as input to the method, it returns the input and, if the condition fails, it returns a message to provide the input value as an integer. Similarly, we will add various methods to check string, float, list, tuple, and dictionary objects:</p>
<pre class="source-code">class typecheck:</pre>
<p>Let’s now define a method named <code>intcheck</code>. The purpose of this method is to perform an integer type check of any input explicitly. In this method, a value will be provided as input and the method will verify whether the input value is an integer. If the input value is an integer, we will return the input value. If the value is not an integer, we will return a message that says <code>"value should be an integer"</code>:</p>
<pre class="source-code">    def intcheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != int:</pre>
<pre class="source-code">            print("value should be an integer")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>In the following method, let’s check that the input variable is not a string (for example, <code>Orangesexample</code>) and return an error message when the condition is <code>true</code> and return the input value when the condition is <code>false</code>:</p>
<pre class="source-code">    def stringcheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != str:</pre>
<pre class="source-code">            print("value should be a string")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>In the following method, let’s check that the input variable is not a floating-point value (for example, <code>example, 2335.2434</code>) and return an error message when the condition is <code>true</code> and return the input value when the condition is <code>false</code>:</p>
<pre class="source-code">    def floatcheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != float:</pre>
<pre class="source-code">            print("value should be a float")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>In the <a id="_idIndexMarker363"/>following method, let’s check that the input variable is not a list of variables (for example, <code>['fruits','flowers',1990]</code>) and return an error message when the condition is <code>true</code> and return the input value when the condition is <code>false</code>:</p>
<pre class="source-code">    def listcheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != list:</pre>
<pre class="source-code">            print("value should be a list")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>In the following method, let’s check that the input variable is not a tuple of variables (for example, <code>example, ('fruits','flowers',1990)</code>) and return an error message when the condition is <code>true</code> and return the input value when the condition is <code>false</code>:</p>
<pre class="source-code">    def tuplecheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != tuple:</pre>
<pre class="source-code">            print("value should be a tuple")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>In the following method, let’s check that the input variable is not a dictionary with key/value <a id="_idIndexMarker364"/>pairs (for example, <code>example: {'one': 1, 'two': 2}</code>) and return an error message when the condition is <code>true</code> and return the input value when the condition is <code>false</code>:</p>
<pre class="source-code">    def dictcheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != dict:</pre>
<pre class="source-code">            print("value should be a dict")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>Now let’s , we will proceed further to create the <code>Fashion</code> class to perform type checks using the <code>typecheck</code> class.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor099"/>Creating a class to test type checking</h2>
<p>Let’s now <a id="_idIndexMarker365"/>create the <code>Fashion</code> class with the same set of variables, that is, <code>clothing_category</code>, <code>gender</code>, <code>model</code>, <code>design</code>, <code>dress_type</code>, <code>size</code>, and <code>color</code>. In this example too, we will assign a specific data type to each variable. In the following class definition, let’s create an object for the <code>typecheck</code> class and call type-specific methods to store the variables of each type. For instance, a <code>price</code> variable will be declared as <code>float</code>, and the <code>floatcheck</code> method from <code>typecheck</code> will be used to store the variable instead of using generics:</p>
<pre class="source-code">class Fashion:</pre>
<p>In the following method, let’s initialize the variables for the <code>Fashion</code> class along with their specific data types defined using the type checking methods of the <code>typecheck</code> class:</p>
<pre class="source-code">    def __init__(self,clothing_category: str,gender:str,price:float,design:str,dress_type:str,size:int, color:list):</pre>
<pre class="source-code">        tc = typecheck()</pre>
<pre class="source-code">        self.clothing_category = tc.stringcheck(clothing_category)</pre>
<pre class="source-code">        self.gender = tc.stringcheck(gender)</pre>
<pre class="source-code">        self.price = tc.floatcheck(price)</pre>
<pre class="source-code">        self.design = tc.stringcheck(design)</pre>
<pre class="source-code">        self.dress_type = tc.stringcheck(dress_type)</pre>
<pre class="source-code">        self.size = tc.intcheck(size)</pre>
<pre class="source-code">        self.color = tc.listcheck(color)</pre>
<p>In the <a id="_idIndexMarker366"/>following method, let’s return all the variables initialized in the <code>Fashion</code> class:</p>
<pre class="source-code">   def get_item(self):</pre>
<pre class="source-code">        return self.clothing_category,self.gender,self.price,self.design,self.dress_type, self.size,self.color</pre>
<p>Calling the <code>floatcheck</code> method on the <code>price</code> variable acts as a typing mechanism for the variable declaration, and if the input provided is not a float, then an error will be displayed in the variable declaration phase itself:</p>
<pre class="source-code">fashion = Fashion(112,"Men","Western","Designer","Shirt",38.4,"black")</pre>
<pre class="source-code"><strong class="bold">value should be a string</strong></pre>
<pre class="source-code"><strong class="bold">value should be a float</strong></pre>
<pre class="source-code"><strong class="bold">value should be an integer</strong></pre>
<pre class="source-code"><strong class="bold">value should be a list</strong></pre>
<p>In the preceding example, we have declared four variables with incorrect data types; <code>clothing_category</code> should be a string, <code>price</code> should be a float, <code>size</code> should be an integer, and <code>color</code> should be a list. All these incorrect variables were not accepted by the code and hence we have received corresponding variable type errors:</p>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code">(None, 'Men', None, 'Designer', 'Shirt', None, None)</pre>
<p>While we get the items from the fashion object, all incorrect type variables have no values assigned to them. Let’s now look at the correct values and how they are accepted by the <code>fashion</code> object:</p>
<pre class="source-code">:fashion = Fashion("112","Men",20.0,"Designer","Shirt",38,["blue","white"])</pre>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code">('112', 'Men', 20.0, 'Designer', 'Shirt', 38, ['blue', 'white'])</pre>
<p>In the<a id="_idIndexMarker367"/> preceding code, we have corrected the input values by assigning values of specific data types and the error is now resolved. By developing such explicit typing libraries, we can convert Python’s generics into specifics.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor100"/>Typing with explicit type checks – approach 2</h1>
<p>In this <a id="_idIndexMarker368"/>section, we will look at another approach for applying specific data types to variables. In the first approach, we developed a <code>typecheck</code> class and used the type checking methods themselves to create new data types. In this example, we will be creating the <code>typecheck</code> class with each type checking method to check that the input value belongs to the expected type and returns a Boolean value based on the condition’s result. This method of type checking gives us the flexibility of modifying the <code>Fashion</code> class to provide variable-specific error messages when the condition is not met.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor101"/>Creating a class to implement type checking</h2>
<p>In this<a id="_idIndexMarker369"/> example, let’s begin by creating the <code>typecheck</code> class. </p>
<p>The <code>typecheck</code> class is created here to make all the methods in this class reusable just in case all the methods in the type check code need to be exported into a different file for later use. </p>
<p>All the<a id="_idIndexMarker370"/> methods in this example can be created with or without a class and used throughout this chapter: </p>
<pre class="source-code">class typecheck</pre>
<ul>
<li>In the following method, let’s check that the input variable is not an integer (for example, <code>23348</code>) and return <code>False</code> when the condition is true and return <code>True</code> when the condition is false:<pre>    def intcheck(self,inputvalue):
        if type(inputvalue) != int:
            return False
        else:
            return True</pre></li>
<li>In the following method, let’s check that the input variable is not a string (for example, <code>Orangesexample</code>) and return <code>False</code> when the condition is true and return <code>True</code> when the condition is false:<pre>    def stringcheck(self,inputvalue):
        if type(inputvalue) != str:
            return False
        else:
            return True</pre></li>
<li>In the following method, let’s check that the input variable is not a floating point value (for example, <code>2335.2434</code>) and return <code>False</code> when the condition is true and return <code>True</code> when the condition is false:<pre>   def floatcheck(self,inputvalue):
        if type(inputvalue) != float:
            return False
        else:
            return True</pre></li>
<li>In the<a id="_idIndexMarker371"/> following method, let’s check that the input variable is not a list of variables (for example, <code>['fruits','flowers',1990]</code>) and return <code>False</code> when the condition is true and return <code>True</code> when the condition is false:<pre>   def listcheck(self,inputvalue):
        if type(inputvalue) != list:
            return False
        else:
            return True</pre></li>
<li>In the following method, let’s check that the input variable is not a tuple of variables (for example, <code>('fruits','flowers',1990)</code>) and return <code>False</code> when the condition is true and return <code>True</code> when the condition is false:<pre>   def tuplecheck(self,inputvalue):
        if type(inputvalue) != tuple:
            return False
        else:
            return True</pre></li>
<li>In the following method, let’s check that the input variable is not a dictionary with key/value pairs (for example, <code>{'one': 1, 'two': 2}</code>) and return <code>False</code> when the condition is true and return <code>True</code> when the condition is false:<pre>   def dictcheck(self,inputvalue):
        if type(inputvalue) != dict:
            return False
        else:
            return True</pre></li>
</ul>
<p>Now, we <a id="_idIndexMarker372"/>can proceed further to create the <code>Fashion</code> class to perform type checks using the <code>typecheck</code> class.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/>Creating a class to test type checking </h2>
<p>In this <a id="_idIndexMarker373"/>section, let’s look at creating a <code>Fashion</code> class with a different variable type definition as follows:</p>
<pre class="source-code">class Fashion:</pre>
<ul>
<li>Let’s initialize the variables along with the specific data types for each:<pre>    def __init__(self,clothing_category: str,gender:str,model:tuple,design:int,price:float,size:dict, color:list):
        tc = typecheck()</pre></li>
<li>In the following code, let’s check whether the <code>clothing_category</code> input is a string and return the value if it is true, and return an error specific to <code>clothing_category</code> if it is false:<pre>        if tc.stringcheck(clothing_category):
            self.clothing_category = clothing_category
        else:
            print("clothing category should be a string")</pre></li>
<li>In the following code, let‘s check whether the <code>gender</code> input is a string and return the value if it is true and return an error specific to the <code>gender</code> variable if it is false:<pre>        if tc.stringcheck(gender):
            self.gender = gender
        else: 
            print("gender should be a string")</pre></li>
<li>In the <a id="_idIndexMarker374"/>following code, let’s check whether the <code>model</code> input is a tuple and return the value if it is true and return an error specific to the <code>model</code> variable if it is false:<pre>        if tc.tuplecheck(model):
            self.model = model
        else:
            print("model should be a tuple")</pre></li>
<li>In the following code, let’s check whether the <code>design</code> input is an integer and return the value if it is true and return an error specific to the <code>design</code> variable if it is false:<pre>if tc.intcheck(design):
            self.design = design
        else:
            print("design should be an integer")</pre></li>
<li>In the following code, let’s check whether the <code>price</code> input is a floating point value and return the value if it is true and return an error specific to the <code>price</code> variable if it is false:<pre>if tc.floatcheck(price):
            self.price = price
        else:
            print("price should be a floating point value")</pre></li>
<li>In the following code, let’s check whether the <code>size</code> input is a dictionary object and return the value if it is true and return an error specific to the <code>size</code> variable if it is false:<pre>if tc.dictcheck(size):
            self.size = size
        else:
            print("size should be a dictionary object")</pre></li>
<li>In the <a id="_idIndexMarker375"/>following code, let’s check whether the <code>color</code> input is a list object and return the value if it is true and return an error specific to the <code>color</code> variable if it is false:<pre>if tc.listcheck(color):       
            self.color = color
        else:
            print("color should be a list of values")</pre></li>
<li>In the following code, let’s create a method to return all the variables listed in the preceding code:<pre>    def get_item(self):
        return self.clothing_category,self.gender,self.model,self.design,self.price, self.size,self.color</pre></li>
</ul>
<p>To test this approach of type checking, let’s pass some incorrect values as input for some of these variables and check:</p>
<pre class="source-code">fashion = Fashion(12,"Women","Western","Floral","Maxi Dress",34,"yellow")</pre>
<p>Executing the preceding code results in the following list of errors:</p>
<pre class="source-code"><strong class="bold">clothing category should be a string</strong></pre>
<pre class="source-code"><strong class="bold">model should be a tuple</strong></pre>
<pre class="source-code"><strong class="bold">price should be a floating point value</strong></pre>
<pre class="source-code"><strong class="bold">size should be a dictionary object</strong></pre>
<pre class="source-code"><strong class="bold">color should be a list of values</strong></pre>
<p>Further, calling the <code>get_item</code> method on the preceding <code>fashion</code> object results in the following error:</p>
<pre class="source-code">fashion.get_item()</pre>
<p>The <a id="_idIndexMarker376"/>graphical representation of the error message is as follows:</p>
<div><div><img alt="Figure 7.1 – Error on calling the get_item method " height="287" src="img/Figure_7.1_B13426.jpg" width="1309"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Error on calling the get_item method</p>
<p>In the preceding error, the first variable, <code>clothing-category</code>, was not accepted by the method since type expectations were not met by this variable.</p>
<p>We can check further by providing the right input types as follows:</p>
<pre class="source-code">fashion = Fashion("Rayon","Women",("Western","Floral"),12012,100.50,{'XS': 36, 'S': 38, 'M': 40},["yellow","red"])</pre>
<p>There were no errors from the preceding value assignments. Calling the <code>get_item</code> method on the <code>fashion</code> object now results in the following output:</p>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code"><strong class="bold">('Rayon',</strong></pre>
<pre class="source-code"><strong class="bold"> 'Women',</strong></pre>
<pre class="source-code"><strong class="bold"> ('Western', 'Floral'),</strong></pre>
<pre class="source-code"><strong class="bold"> 12012,</strong></pre>
<pre class="source-code"><strong class="bold"> 100.5,</strong></pre>
<pre class="source-code"><strong class="bold"> {'XS': 36, 'S': 38, 'M': 40},</strong></pre>
<pre class="source-code"><strong class="bold"> ['yellow', 'red'])</strong></pre>
<p>The <a id="_idIndexMarker377"/>preceding output meets all the type requirements and the end goal of type checking is achieved successfully through this approach. Now that you understand this, let’s look further into the concept of data types with constraints.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor103"/>Adding data types with constraints</h1>
<p>In this section, we<a id="_idIndexMarker378"/> will look at an example of adding constraints to<a id="_idIndexMarker379"/> data types and checking constraints along with type checking. There might be scenarios where we would like to create an integer variable and restrict its length to two digits or to create a string and restrict its length to 10 characters and more. With this example, let’s explore how to add such constraints or restricts during the static type checking. </p>
<p>In this example, let’s create a <code>typecheck</code> class with only two methods to check an integer and a string. While checking these data types, let’s also add a few more constraints within the method definition:</p>
<pre class="source-code">class typecheck:</pre>
<ul>
<li>In the following method, let’s check that the input variable is not an integer or its length is greater than two, and return <code>False</code> when the condition is true, and return <code>True</code> when the condition is false:<pre>    def intcheck(self,inputvalue):
        if (type(inputvalue) != int) and (len(str(inputvalue))&gt;2):
            return False
        else:
            return True</pre></li>
<li>In the following method, let’s check that the input variable is not a string or its length is greater than 10, and return <code>False</code> when the condition is true, and return <code>True</code> when the condition is false:<pre>    def stringcheck(self,inputvalue):
        if (type(inputvalue) != str) and (len(str(inputvalue))&gt;10):
            return False
        else:
            return True</pre></li>
</ul>
<p>With just two methods with type checks and constraints, we can look into creating a <code>Fashion</code> class with two variables and one method:</p>
<pre class="source-code">class Fashion:</pre>
<ul>
<li>Let’s <a id="_idIndexMarker380"/>initialize the class with <code>clothing_category</code> as a<a id="_idIndexMarker381"/> string and <code>size</code> as an integer:<pre>    def __init__(self,clothing_category: str,size:int):
        tc = typecheck()</pre></li>
<li>In the following code, let’s declare <code>clothing_category</code> using the <code>stringcheck</code> method:<pre>        if tc.stringcheck(clothing_category):
            self.clothing_category = clothing_category
        else:
            print("value should be a string of length less than or equal to 10")</pre></li>
<li>In the following code, let’s declare <code>size</code> using the <code>intcheck</code> method:<pre>        if tc.intcheck(size):
            self.size = size
        else:
            print("value should be an integer of 2 digits or less")</pre></li>
<li> In the following code, let’s add the method to get the items and return them:<pre>    def get_item(self):
        return self.clothing_category,self.size</pre></li>
</ul>
<p>Let’s further create an object for the <code>fashion</code> class and assign two variables that do not match the type-checking conditions:</p>
<pre class="source-code">fashion = Fashion("Clothing &amp; Accessories",384)</pre>
<pre class="source-code"><strong class="bold">value should be a string of length less than or equal to 10</strong></pre>
<pre class="source-code"><strong class="bold">value should be an integer of 2 digits or less</strong></pre>
<p>The <a id="_idIndexMarker382"/>preceding error messages indicate that both the type checks <a id="_idIndexMarker383"/>and constraints are not met for the string as well as integer data types. Let’s now provide the right type of input values and perform static type checking:</p>
<pre class="source-code">fashion = Fashion("Cotton",34)</pre>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code">('Cotton', 34)</pre>
<p>The value assignments are now working as expected in the preceding code. With this understanding, let’s proceed further to create simple custom data types.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor104"/>Creating a simple custom data type</h1>
<p>Until the<a id="_idIndexMarker384"/> preceding section, we looked at adding explicit type checks and converting generic type variables into specific types to handle specific data needs we might get while programming an application, and we also added errors to help debug incorrect data types assigned to variables. </p>
<p>In this section, let’s look at creating our own simple data types and what will be required to do so. First of all, let’s answer the question of why we need our own data types. Any custom data type is a derivation of basic data types in Python along with certain variations to fulfill the purpose of our data needs in an application. Any data type will have its own set of operations that can be performed on top of the data of that specific type. For instance, an integer data type will support arithmetic operations such as addition, subtraction, multiplication, and division. Similarly, a string supports concatenation in the place of addition, and so on. So, when we create our own data type, we can override these basic operations to fulfill the need of our custom data type. </p>
<p>To demonstrate this, let‘s first create our own data type and override the basic operators to perform the operations that we expect. Please note that custom data types may be required only in situations where we would like to make it domain-specific or application-specific. We can always use default data types and avoid creating custom data types where there is no requirement:</p>
<ol>
<li>We will create a class named <code>DressSize</code> and initialize it with the <code>size</code> variable of the integer type. If the input value for <code>size</code> is not an integer and the input values do not follow a specific list of dress sizes, type checking returns an error message in red (as shown in <em class="italic">Figure 7.2</em>):<pre>class DressSize:
    def __init__(self,size:int):
        self.limit = [28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48]
        if type(size)==int and size in self.limit:
            self.size = size
        else:
            print("\x1B[31mSize should be a valid dress size")  </pre></li>
<li>Next, let’s override the default <code>str</code> method of a class to return the string version of the <code>size</code> variable:<pre>    def __str__(self):
        return str(self.size)</pre></li>
<li>Then, let’s<a id="_idIndexMarker385"/> add a new method named <code>value</code> to return the value of the <code>size</code> attribute:<pre>    def value(self):
        return self.size</pre></li>
<li>Now, let’s override the addition (<code>+</code>) operator of the integer method to increase <code>size</code> values from one dress size object created for the <code>DressSize</code> class:<pre>    def __add__(self, up):
        result = self.size + up
        if result in self.limit:
            return result
        else:
            return "Input valid size increments"</pre></li>
<li>Then, let’s override the subtraction (<code>-</code>) operator of the integer method to decrease <code>size</code> values from one size object created for the <code>DressSize</code> class:     <pre>    def __sub__(self, down):
        result = self.size - down
        if result in self.limit:
            return result
        else:
            return "Input valid size decrements"</pre></li>
<li>We will then <a id="_idIndexMarker386"/>create an object for the class, in this case, our new custom data type, <code>DressSize</code>, and initialize it with a string instead of an integer, as follows:<pre>s = DressSize("30")</pre></li>
</ol>
<p>Incorrect input type results in an error with a red font similar to how error messages are usually displayed while debugging:</p>
<div><div><img alt="Figure 7.2 – Error message for DressSize  " height="34" src="img/Figure_7.2_B13426.jpg" width="1004"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Error message for DressSize </p>
<ol>
<li value="7">Calling the <code>value</code> method would also result in an error since the type checking failed for the <code>DressSize</code> data type:<pre>s.value()</pre></li>
</ol>
<p>The value error is displayed as follows:</p>
<div><div><img alt="Figure 7.3 – Value error due to incorrect DressSize input type " height="332" src="img/Figure_7.3_B13426.jpg" width="887"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Value error due to incorrect DressSize input type</p>
<ol>
<li value="8">Let’s correct <a id="_idIndexMarker387"/>this error by providing the correct input type while creating a <code>DressSize</code> object:<pre>s = DressSize(30)
s
&lt;__main__.DressSize at 0x22c4bfc4a60&gt;</pre></li>
<li>In the following code, we can look at how the addition operation (<code>+</code>) works on the objects of <code>DressSize</code>:<pre>DressSize(30) + 6
<strong class="bold">36</strong>
DressSize(30) + 3
'Input valid size increments'</pre></li>
<li>The addition of two objects works like a regular addition since we have overloaded the addition operator (<code>+</code>) to add the initialized variables of two objects. Similarly, we can check the results of subtraction, as follows:<pre>DressSize(32) - 4
<strong class="bold">26</strong>
DressSize(30) – 3
'Input valid size decrements'</pre></li>
<li>The subtraction of two objects works like a regular subtraction since we have overloaded the subtraction operator (<code>-</code>) to subtract the initialized variables of two objects. Similarly, printing the object results in printing the string format of the <code>size</code> variable since we have overloaded the <code>str</code> method to do this:<pre>print(s)
<strong class="bold">30</strong></pre></li>
<li>We have also added a <code>value</code> method to display the value of the <code>size</code> variable, and it works as follows:<pre>s.value()
<strong class="bold">30</strong></pre></li>
<li>Calling the <code>type</code> method<a id="_idIndexMarker388"/> on the variable or the <code>s</code> object displays the class name, <code>DressSize</code>, which is the data type of <code>s</code> in this case:<pre>type(s)
<strong class="bold">__main__.DressSize</strong></pre></li>
</ol>
<p>Now, we can consider creating a more detailed data type of our own in the next section.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor105"/>Creating a domain-specific data type</h1>
<p>In this section, let’s<a id="_idIndexMarker389"/> create an even more customized data type to deal with the dress size of the fashion department of <em class="italic">ABC Megamart</em>. The <code>DressSize</code> data type we defined in the preceding section handles any integer as input and performs the operations we overloaded. When we look at the domain of the fashion industry and consider the dress size as a domain-specific variable, the <code>DressSize</code> data type should ideally be considering only specific values for <code>size</code> and not accept all integers. The dress size will be based on the size of dresses held in the inventory of <em class="italic">ABC Megamart</em>. </p>
<p>The accepted input for dress size in this example should be the list of integers, <code>[36,38,40,42,44,46,48]</code>, or the list of strings that indicates the equivalent text values for dress size such as <code>[XS,S,M,L,XL,XXL,XXXL]</code>:</p>
<ol>
<li value="1">Let’s begin by creating the <code>DressSize</code> class along with its methods to work as a domain-specific data type, and initialize <code>size</code> as its only input value:<pre>class DressSize:
    def __init__(self, size):</pre></li>
<li>Let’s further define two domain-specific lists that holds the valid set of values for dress size in text and integer formats, respectively:<pre>self.romanchart = ['XS','S','M','L','XL','XXL','XXXL']
self.sizenum = [36,38,40,42,44,46,48]</pre></li>
<li>In the following code, we will be creating a dictionary object that holds the integer and text format of <code>size</code> as key/value pairs. The reason behind adding this dictionary object is to use it further in the data type-specific methods created for this data type:<pre>self.chart = {}dict(zip(self.romanchart,self.sizenum))</pre></li>
<li>Let’s now add the condition that accepts the input value as <code>size</code> if it meets the data type criteria and then rejects the input value with an error if it does not meet the criteria:<pre>        if (size in self.romanchart) or (size in self.sizenum ):
            self.size = size
        else:
            print("\x1B[31mEnter valid size")</pre></li>
</ol>
<p>In the preceding code, the input value will be accepted if it is present in the <code>romanchart</code> list variable or if it is present in the <code>sizenum</code> list variable. If both the criteria are not met, the value will be rejected by the <code>DressSize</code> data type and an error message will be displayed in a red-colored font. Why do we need to set these strict constraints in this particular domain-specific data type? If we look at the <code>size</code> values of a dress, the size usually is an even number and there are no odd-numbered dress sizes in a shopping cart or in a clothing store. Also, the size of the clothing in most of the generic clothing stores falls between 36 and 48 in general. If the store holds clothes of lesser or greater sizes, we can adjust the lists accordingly and redefine the data type. In this specific scenario, let’s consider the dress sizes between 36 and 48 and their corresponding text codes between XS and XXXL as acceptable values. Now, we have added the acceptance<a id="_idIndexMarker390"/> criteria for the data type:</p>
<ol>
<li value="1">Let’s add specific methods that can be processed on the data type. In the following method, let’s override the default <code>str</code> method of a class to return the string version of the <code>size</code> variable:     <pre>    def __str__(self):
        return str(self.size)</pre></li>
<li>In the following code, let’s add a new method named <code>value</code> to return the value of the <code>size</code> attribute:<pre>    def value(self):
        return self.size</pre></li>
<li>In the following code, let’s add a method to increment the <code>size</code> value. The <code>size</code> value should increment by <code>2</code> since dress size is always measured in even numbers:<pre>    def increase(self):
        if (self.size in self.romanchart) :
            result = self.chart[self.size] + 2
            for key, value in self.chart.items():
                if value == result:
                    return resultkey
        elif (self.size in self.sizenum ):
            return self.size + 2</pre></li>
</ol>
<p>In the preceding code, we have added a logic to look up the value of a dress size such as <code>XL</code> if <code>DressSize</code> is a text input to the data type, and then increment the value by <code>2</code>. We have also added a logic to check the integer value of the dress size and increment by <code>2</code> if the dress size input is an integer. </p>
<ol>
<li value="4">Let’s add one more<a id="_idIndexMarker391"/> method to decrement the <code>DressSize</code> attribute:<pre>    def decrease(self):
        if self.size in self.romanchart :
            result = self.chart[self.size] - 2
            for key, value in self.chart.items():
                if value == result:
                    return key
        elif (self.size in self.sizenum ):
            return self.size – 2</pre></li>
</ol>
<p>In the preceding code, we have added a logic to look up the value of a dress size such as <code>XL</code> if <code>DressSize</code> is a text input to the data type, and then decrement the value by <code>2</code>. We have also added a logic to check the integer value of <code>DressSize</code> and decrement by <code>2</code> if the dress size input is an integer. This defines the overall creation of a domain-specific data type named <code>DressSize</code>.</p>
<ol>
<li value="5">The next step is to test this data type by creating an object:<pre>s = DressSize("XXL")</pre></li>
</ol>
<p>In the preceding code, we have created an object named <code>s</code>, so let’s look at how various methods and attributes work on this object:</p>
<div><div><img alt="Figure 7.4 – Attributes of DressSize " height="235" src="img/Figure_7.4_B13426.jpg" width="155"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Attributes of DressSize</p>
<ol>
<li value="6">In the following<a id="_idIndexMarker392"/> code, let’s call <code>chart</code> from the <code>s</code> object:<pre>s.chart
<strong class="bold">{'XS': 36, 'S': 38, 'M': 40, 'L': 42, 'XL': 44, 'XXL': 46, 'XXXL': 48}</strong></pre></li>
<li>Printing the object results in the string format representation of the value of the <code>s</code> object:<pre>print(s)
<strong class="bold">XS</strong>
<strong class="bold">XL</strong></pre></li>
<li>Calling the value method results as follows:<pre>s.value()
<strong class="bold">'XXL'</strong></pre></li>
<li>Calling the increment method results as follows:<pre>s.increase()
<strong class="bold">XXXL</strong></pre></li>
<li>Calling the decrement method results as follows:<pre>s.decrease()
<strong class="bold">XL</strong></pre></li>
<li>Let’s now create the <code>Fashion</code> class and initialize variables out of which the <code>size</code> variable<a id="_idIndexMarker393"/> will be initialized as the <code>DressSize</code> type:<pre>class Fashion:
    def __init__(self,clothing_category: str,gender:str,model:str,design:str,dress_type:str,color:str,size:DressSize):
        self.clothing_category = clothing_category
        self.gender = gender
        self.model = model
        self.design = design
        self.dress_type = dress_type
        self.color = color</pre></li>
<li>In the following code, let’s define the type checking condition for <code>DressSize</code>. If <code>size</code> is an instance of <code>DressSize</code>, then it returns the instance, and if it is not an instance, an appropriate error message will be displayed:<pre>if isinstance(size,DressSize):
            self.size = size
        else:
            print("value should be of type DressSize")   </pre></li>
<li>Let’s further add the <code>get_item</code> method to return the attributes of the <code>Fashion</code> class:<pre>    def get_item(self):
        return self.clothing_category,self.gender,self.model,self.design,self.dress_type,self.color,self.size</pre></li>
<li>Creating the object further results as follows:<pre>fashion = Fashion("Clothing","Women","Western","Dotted","Jumpsuits",'blue',"XL")
<strong class="bold">value should be of type DressSize</strong></pre></li>
</ol>
<p>In the preceding code, we did not assign the correct data type for the size variable. </p>
<ol>
<li value="15">To correct it, let’s create an instance of <code>DressSize</code> and provide it as input to the <code>Fashion</code> class:<pre>M = DressSize("M")
fashion = Fashion("Clothing","Women","Western","Dotted","Jumpsuits",'blue',M)</pre></li>
</ol>
<p>The preceding <a id="_idIndexMarker394"/>code did not result in any error and is accepted as input by the <code>Fashion</code> class. Calling the <code>get_item</code> method would result in the following output:</p>
<pre>fashion.get_item()
<strong class="bold">('Clothing',</strong>
<strong class="bold"> 'Women',</strong>
<strong class="bold"> 'Western',</strong>
<strong class="bold"> 'Dotted',</strong>
<strong class="bold"> 'Jumpsuits',</strong>
<strong class="bold"> 'blue',</strong>
<strong class="bold"> &lt;__main__.DressSize at 0x22c4cf4ba60&gt;)</strong></pre>
<p>If we want to look at the <a id="_idIndexMarker395"/>specific value of the <code>M</code> object, we can call the <code>value</code> method as follows:</p>
<pre>fashion.size.value()
<strong class="bold">'M'</strong></pre>
<p>In this section, we looked at how to create a domain-specific custom data type and how to use it on another class as a type variable. </p>
<p>These are some of the examples of how generics work in Python and how specifics can be applied to Python objects using user-defined functions.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor106"/>Summary</h1>
<p>In this chapter, we have learned the concepts of generics and type checking. We also looked at creating user-defined data types with specific constraints and we’ve also seen how to apply them to our core example. We created our own domain-specific data type and overloaded operators and methods to work according to the data type. Similar to other chapters covered in this book, this chapter is also used to change the behavior of Python objects externally using the concept of metaprogramming. </p>
<p>In the next chapter, we will be looking at the concept of templates with some interesting examples.</p>
</div>
</div></body></html>