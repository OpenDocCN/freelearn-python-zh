<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer082">
<h1 id="_idParaDest-88"><em class="italic"><a id="_idTextAnchor090"/>Chapter 7</em>: Understanding Generics and Typing</h1>
<p>In this chapter, we will look at what generics are and how to perform type checking in Python 3 and understand how it is useful in metaprogramming. </p>
<p>Python<a id="_idIndexMarker345"/> is a programming language where variables are declared as generics and they don’t get a data type assigned to them on the declaration. Python resolves the data types dynamically during runtime depending on the values assigned to variables. In other programming languages such as C++, generics need to be programmatically designed to make the variables generic, whereas in Python, generics are how the variables are defined. In such cases, how we would declare a variable with typing and restrict the behavior of the variables is what we will be focusing on in detail in this chapter.</p>
<p>Throughout this chapter, we will look at understanding how generics work in Python and how to define type checks so that we can apply metaprogramming on variables to statically type them so that we don’t have to wait for the complete program to run to determine that we have unintentionally used incorrect typing in our code.</p>
<p>In this chapter, we will be covering the following main topics:</p>
<ul>
<li>What are generics?</li>
<li>What happens when data types are specified?</li>
<li>Typing with explicit type checks – approach 1</li>
<li>Typing with explicit type checks – approach 2</li>
<li>Adding data types with constraints</li>
<li>Creating a simple custom data type</li>
<li>Creating a domain-specific data type</li>
</ul>
<p>By the end of this chapter, you should be able to apply generics and type checking on Python variables. You should also be able to create your own domain-specific data types.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor091"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here:<span class="superscript"> </span><a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter07">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter07</a>.</p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor092"/>What are generics?</h1>
<p><strong class="bold">Generics</strong> are<a id="_idIndexMarker346"/> a programming paradigm where any attribute or variable is a function in a language that is not assigned to any specific type. When we speak of type, it is either the variable data type or the function return type. </p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor093"/>How are generics connected to metaprogramming?</h2>
<p><strong class="bold">Metaprogramming</strong> deals <a id="_idIndexMarker347"/>with the concepts of Python 3 and above, where<a id="_idIndexMarker348"/> we can develop scripts or programs that manipulate the objects of Python externally without actually impacting the definition of classes, methods, or functions in a program. Generics are the way in which Python has built the handling of data types for its objects. If we need to change the data type handling in Python from generics to specific types, we can perform it through metaprogramming. To understand how to make specifics work, we need to understand generics with examples. Let’s look at generics in the following section.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor094"/>How are generics handled in Python?</h2>
<p>Here, we can<a id="_idIndexMarker349"/> investigate generics with an example. Throughout this <a id="_idIndexMarker350"/>chapter, we will look into another interesting section of our core example, <em class="italic">ABC Megamart</em>. In this chapter, we will be covering our examples using the clothing and fashion department of <em class="italic">ABC Megamart</em>. </p>
<p>Let’s <a id="_idIndexMarker351"/>consider the fashion department of <em class="italic">ABC Megamart</em> <a id="_idIndexMarker352"/>in this example. This department covers various clothing products. To examine generics, we will first define a class named <strong class="source-inline">Fashion</strong> with attributes such as <strong class="source-inline">clothing_category</strong>, <strong class="source-inline">gender</strong>, <strong class="source-inline">model</strong>, <strong class="source-inline">design</strong>, <strong class="source-inline">dress_type</strong>, <strong class="source-inline">size</strong>, and <strong class="source-inline">color</strong>. We will also add a method named <strong class="source-inline">get_item</strong> to return the preceding attributes. The code is defined as follows:</p>
<pre class="source-code">class Fashion:</pre>
<pre class="source-code">    def __init__(self,clothing_category,gender,model,design,dress_type,size, color):</pre>
<pre class="source-code">        self.clothing_category = clothing_category</pre>
<pre class="source-code">        self.gender = gender</pre>
<pre class="source-code">        self.model = model</pre>
<pre class="source-code">        self.design = design</pre>
<pre class="source-code">        self.dress_type = dress_type</pre>
<pre class="source-code">        self.size = size</pre>
<pre class="source-code">        self.color = color</pre>
<pre class="source-code">     def get_item(self):</pre>
<pre class="source-code">        return self.clothing_category,self.gender,self.model,self.design,self.dress_type, self.size,self.color        </pre>
<p>This code handles generics. Let’s explain this statement by assigning values of any data types to the attributes of <strong class="source-inline">Fashion</strong>:</p>
<pre class="source-code">fashion = Fashion("Clothing","Women","Western","Dotted","Jumpsuits",38,"blue")</pre>
<p>We have added string values to <strong class="source-inline">clothing_category</strong>, <strong class="source-inline">gender</strong>, <strong class="source-inline">model</strong>, <strong class="source-inline">design</strong>, <strong class="source-inline">dress_type</strong>, and <strong class="source-inline">color</strong>, while we added an integer value to the <strong class="source-inline">size</strong> attribute. Since the language handles generics by default, we did not have to declare the data types and the values are accepted without throwing any errors. We can call the <strong class="source-inline">get_item</strong> method to display these generic values:</p>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code"><strong class="bold">('Clothing', 'Women', 'Western', 'Dotted', 'Jumpsuits', 38, 'blue')</strong></pre>
<p>Examining the data types of <strong class="source-inline">clothing_category</strong> and <strong class="source-inline">size</strong> results as follows:</p>
<pre class="source-code">type(fashion.clothing_category)</pre>
<pre class="source-code"><strong class="bold">str</strong></pre>
<pre class="source-code">type(fashion.size)</pre>
<pre class="source-code"><strong class="bold">int</strong></pre>
<p>Let’s double-check our statement on generics now. What happens when we change the data types of input variables? Will they be accepted by Python? To test this, let’s change the data types of <strong class="source-inline">clothing_category</strong> and <strong class="source-inline">size</strong>:</p>
<pre class="source-code">fashion = Fashion(102,"Women","Western","Floral","T-Shirt","XS","green")</pre>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code"><strong class="bold">(102, 'Women', 'Western', 'Floral', 'T-Shirt', 'XS', 'green')</strong></pre>
<p>The change<a id="_idIndexMarker353"/> in data types is accepted and processed by Python and can<a id="_idIndexMarker354"/> be viewed as follows:</p>
<pre class="source-code">type(fashion.clothing_category)</pre>
<pre class="source-code"><strong class="bold">int</strong></pre>
<pre class="source-code">type(fashion.size)</pre>
<pre class="source-code"><strong class="bold">str</strong></pre>
<p>In the preceding example, no matter which data type the input value belongs to, they are processed successfully. In the following section, let’s explicitly assign data types and check further.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor095"/>What happens when data types are specified?</h1>
<p>Annotations<a id="_idIndexMarker355"/> in Python are added to code to provide additional information or help to end users with a piece of code while creating libraries. Annotations can be used to add data types to a specific code so that the information on data types can later be retrieved using the annotations by developers.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor096"/>Type hints as annotations</h2>
<p>In the context of typing, which is the topic of this chapter, let’s look at type hints in this section. Data types of a function or method can be defined in Python using a functionality of <a id="_idIndexMarker356"/>annotations called <strong class="bold">type hinting</strong>. Type hinting<a id="_idIndexMarker357"/> is a concept laid out in <strong class="bold">PEP 483</strong> (<strong class="bold">Python Enhancement Proposals</strong>) for <strong class="bold">Python 3.5</strong> by <em class="italic">Guido van Rossum</em> and <em class="italic">Ivan Levkivskyi</em>. Type hinting can be read in detail in the Python documentation available at <em class="italic">PEP 483 – The Theory of Type Hints </em>at <a href="http://peps.python.org">peps.python.org</a>. Type hinting is used to provide information to the developers on the data types and return types of Python objects and is not a strict requirement in Python coding. With or without<a id="_idIndexMarker358"/> type hinting, Python code executes the same way since it is a dynamically typed language. Let’s look at another example of the <strong class="source-inline">Fashion</strong> class by declaring type hints on the methods of the class. To implement this, we can explicitly assign a data type and its return type to a variable while declaring a variable and adding it to a method in Python. We will also add a type hint for the return type of a method. </p>
<p>Let’s declare the <strong class="source-inline">Fashion</strong> class initialized with its attributes or variables along with the data types, which we would expect the variables to be on:</p>
<pre class="source-code">class Fashion:</pre>
<pre class="source-code">    def __init__(self,clothing_category<strong class="source-inline">: str</strong>,gender<strong class="source-inline">:str</strong>,model<strong class="source-inline">:str</strong>,design<strong class="source-inline">:str</strong>,dress_type<strong class="source-inline">:str</strong>,size<strong class="source-inline">:int</strong>, color<strong class="source-inline">:str</strong>):</pre>
<pre class="source-code">        self.clothing_category = clothing_category</pre>
<pre class="source-code">        self.gender = gender</pre>
<pre class="source-code">        self.model = model</pre>
<pre class="source-code">        self.design = design</pre>
<pre class="source-code">        self.dress_type = dress_type</pre>
<pre class="source-code">        self.size = size</pre>
<pre class="source-code">        self.color = color</pre>
<pre class="source-code">    def get_item(self) <strong class="source-inline">-&gt; list</strong>:</pre>
<pre class="source-code">        return self.clothing_category,self.gender,self.model,self.design,self.dress_type, self.size,self.color</pre>
<p>In the preceding <a id="_idIndexMarker359"/>code, we have specifically tagged a data type to each variable. In this class, we will also add a <strong class="source-inline">get_item</strong> method and add annotation with a type hint specifying that this method returns a <strong class="source-inline">list</strong> item.</p>
<p>Let’s now check what happens when these data types are not followed while creating an object and assigning values to these variables:</p>
<pre class="source-code">fashion = Fashion(104,"Women","Western","Cotton","Shirt","S","white")</pre>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code">[<strong class="bold">104</strong>, 'Women', 'Western', 'Cotton', 'Shirt', <strong class="bold">'S'</strong>, 'white']</pre>
<p>We have declared <strong class="source-inline">clothingCategory_c</strong> as a string and <strong class="source-inline">size</strong> as an integer in the preceding class definition but we have assigned an integer to <strong class="source-inline">clothing_category</strong> and a string to the <strong class="source-inline">size</strong> variables. The program still ran successfully without throwing any type error, while there should, ideally, have been a type error in this case. This example again proves that types are handled as generics in Python when we assign a data type during variable declaration. </p>
<p>Let’s also look at the annotation for the <strong class="source-inline">get_item</strong> method in the following code:</p>
<pre class="source-code">print(Fashion.get_item.__annotations__)</pre>
<p>Calling <strong class="source-inline">__annotations__</strong> on the <a id="_idIndexMarker360"/>method provides the list data type annotated as the return type for the method:</p>
<pre class="source-code">{'return': &lt;class 'list'&gt;}</pre>
<p>Let’s look further into the concept of typing, in which we can look at how to deal with specific types instead of generics.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor097"/>Typing with explicit type checks – approach 1</h1>
<p>In the <a id="_idIndexMarker361"/>preceding section, we looked at Python’s ability to handle data types as generics. While building an application, there can be scenarios where a variable will need a specific data type, and we might expect metaprogramming to have the ability to handle such specific data types. In this section, let’s look at creating a class to perform type checking.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Creating a class to implement type checking   </h2>
<p>In this<a id="_idIndexMarker362"/> example, we will be creating a class named <strong class="source-inline">typecheck</strong> and adding methods to check each data type specifically. If a data type, for instance, an integer type, is provided as input to the method, it returns the input and, if the condition fails, it returns a message to provide the input value as an integer. Similarly, we will add various methods to check string, float, list, tuple, and dictionary objects:</p>
<pre class="source-code">class typecheck:</pre>
<p>Let’s now define a method named <strong class="source-inline">intcheck</strong>. The purpose of this method is to perform an integer type check of any input explicitly. In this method, a value will be provided as input and the method will verify whether the input value is an integer. If the input value is an integer, we will return the input value. If the value is not an integer, we will return a message that says <strong class="source-inline">"value should be an integer"</strong>:</p>
<pre class="source-code">    def intcheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != int:</pre>
<pre class="source-code">            print("value should be an integer")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>In the following method, let’s check that the input variable is not a string (for example, <strong class="source-inline">Orangesexample</strong>) and return an error message when the condition is <strong class="source-inline">true</strong> and return the input value when the condition is <strong class="source-inline">false</strong>:</p>
<pre class="source-code">    def stringcheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != str:</pre>
<pre class="source-code">            print("value should be a string")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>In the following method, let’s check that the input variable is not a floating-point value (for example, <strong class="source-inline">example, 2335.2434</strong>) and return an error message when the condition is <strong class="source-inline">true</strong> and return the input value when the condition is <strong class="source-inline">false</strong>:</p>
<pre class="source-code">    def floatcheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != float:</pre>
<pre class="source-code">            print("value should be a float")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>In the <a id="_idIndexMarker363"/>following method, let’s check that the input variable is not a list of variables (for example, <strong class="source-inline">['fruits','flowers',1990]</strong>) and return an error message when the condition is <strong class="source-inline">true</strong> and return the input value when the condition is <strong class="source-inline">false</strong>:</p>
<pre class="source-code">    def listcheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != list:</pre>
<pre class="source-code">            print("value should be a list")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>In the following method, let’s check that the input variable is not a tuple of variables (for example, <strong class="source-inline">example, ('fruits','flowers',1990)</strong>) and return an error message when the condition is <strong class="source-inline">true</strong> and return the input value when the condition is <strong class="source-inline">false</strong>:</p>
<pre class="source-code">    def tuplecheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != tuple:</pre>
<pre class="source-code">            print("value should be a tuple")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>In the following method, let’s check that the input variable is not a dictionary with key/value <a id="_idIndexMarker364"/>pairs (for example, <strong class="source-inline">example: {'one': 1, 'two': 2}</strong>) and return an error message when the condition is <strong class="source-inline">true</strong> and return the input value when the condition is <strong class="source-inline">false</strong>:</p>
<pre class="source-code">    def dictcheck(self,inputvalue):</pre>
<pre class="source-code">        if type(inputvalue) != dict:</pre>
<pre class="source-code">            print("value should be a dict")</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return inputvalue</pre>
<p>Now let’s , we will proceed further to create the <strong class="source-inline">Fashion</strong> class to perform type checks using the <strong class="source-inline">typecheck</strong> class.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor099"/>Creating a class to test type checking</h2>
<p>Let’s now <a id="_idIndexMarker365"/>create the <strong class="source-inline">Fashion</strong> class with the same set of variables, that is, <strong class="source-inline">clothing_category</strong>, <strong class="source-inline">gender</strong>, <strong class="source-inline">model</strong>, <strong class="source-inline">design</strong>, <strong class="source-inline">dress_type</strong>, <strong class="source-inline">size</strong>, and <strong class="source-inline">color</strong>. In this example too, we will assign a specific data type to each variable. In the following class definition, let’s create an object for the <strong class="source-inline">typecheck</strong> class and call type-specific methods to store the variables of each type. For instance, a <strong class="source-inline">price</strong> variable will be declared as <strong class="source-inline">float</strong>, and the <strong class="source-inline">floatcheck</strong> method from <strong class="source-inline">typecheck</strong> will be used to store the variable instead of using generics:</p>
<pre class="source-code">class Fashion:</pre>
<p>In the following method, let’s initialize the variables for the <strong class="source-inline">Fashion</strong> class along with their specific data types defined using the type checking methods of the <strong class="source-inline">typecheck</strong> class:</p>
<pre class="source-code">    def __init__(self,clothing_category: str,gender:str,price:float,design:str,dress_type:str,size:int, color:list):</pre>
<pre class="source-code">        tc = typecheck()</pre>
<pre class="source-code">        self.clothing_category = tc.stringcheck(clothing_category)</pre>
<pre class="source-code">        self.gender = tc.stringcheck(gender)</pre>
<pre class="source-code">        self.price = tc.floatcheck(price)</pre>
<pre class="source-code">        self.design = tc.stringcheck(design)</pre>
<pre class="source-code">        self.dress_type = tc.stringcheck(dress_type)</pre>
<pre class="source-code">        self.size = tc.intcheck(size)</pre>
<pre class="source-code">        self.color = tc.listcheck(color)</pre>
<p>In the <a id="_idIndexMarker366"/>following method, let’s return all the variables initialized in the <strong class="source-inline">Fashion</strong> class:</p>
<pre class="source-code">   def get_item(self):</pre>
<pre class="source-code">        return self.clothing_category,self.gender,self.price,self.design,self.dress_type, self.size,self.color</pre>
<p>Calling the <strong class="source-inline">floatcheck</strong> method on the <strong class="source-inline">price</strong> variable acts as a typing mechanism for the variable declaration, and if the input provided is not a float, then an error will be displayed in the variable declaration phase itself:</p>
<pre class="source-code">fashion = Fashion(112,"Men","Western","Designer","Shirt",38.4,"black")</pre>
<pre class="source-code"><strong class="bold">value should be a string</strong></pre>
<pre class="source-code"><strong class="bold">value should be a float</strong></pre>
<pre class="source-code"><strong class="bold">value should be an integer</strong></pre>
<pre class="source-code"><strong class="bold">value should be a list</strong></pre>
<p>In the preceding example, we have declared four variables with incorrect data types; <strong class="source-inline">clothing_category</strong> should be a string, <strong class="source-inline">price</strong> should be a float, <strong class="source-inline">size</strong> should be an integer, and <strong class="source-inline">color</strong> should be a list. All these incorrect variables were not accepted by the code and hence we have received corresponding variable type errors:</p>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code">(None, 'Men', None, 'Designer', 'Shirt', None, None)</pre>
<p>While we get the items from the fashion object, all incorrect type variables have no values assigned to them. Let’s now look at the correct values and how they are accepted by the <strong class="source-inline">fashion</strong> object:</p>
<pre class="source-code">:fashion = Fashion("112","Men",20.0,"Designer","Shirt",38,["blue","white"])</pre>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code">('112', 'Men', 20.0, 'Designer', 'Shirt', 38, ['blue', 'white'])</pre>
<p>In the<a id="_idIndexMarker367"/> preceding code, we have corrected the input values by assigning values of specific data types and the error is now resolved. By developing such explicit typing libraries, we can convert Python’s generics into specifics.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor100"/>Typing with explicit type checks – approach 2</h1>
<p>In this <a id="_idIndexMarker368"/>section, we will look at another approach for applying specific data types to variables. In the first approach, we developed a <strong class="source-inline">typecheck</strong> class and used the type checking methods themselves to create new data types. In this example, we will be creating the <strong class="source-inline">typecheck</strong> class with each type checking method to check that the input value belongs to the expected type and returns a Boolean value based on the condition’s result. This method of type checking gives us the flexibility of modifying the <strong class="source-inline">Fashion</strong> class to provide variable-specific error messages when the condition is not met.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor101"/>Creating a class to implement type checking</h2>
<p>In this<a id="_idIndexMarker369"/> example, let’s begin by creating the <strong class="source-inline">typecheck</strong> class. </p>
<p>The <strong class="source-inline">typecheck</strong> class is created here to make all the methods in this class reusable just in case all the methods in the type check code need to be exported into a different file for later use. </p>
<p>All the<a id="_idIndexMarker370"/> methods in this example can be created with or without a class and used throughout this chapter: </p>
<pre class="source-code">class typecheck</pre>
<ul>
<li>In the following method, let’s check that the input variable is not an integer (for example, <strong class="source-inline">23348</strong>) and return <strong class="source-inline">False</strong> when the condition is true and return <strong class="source-inline">True</strong> when the condition is false:<p class="source-code">    def intcheck(self,inputvalue):</p><p class="source-code">        if type(inputvalue) != int:</p><p class="source-code">            return False</p><p class="source-code">        else:</p><p class="source-code">            return True</p></li>
<li>In the following method, let’s check that the input variable is not a string (for example, <strong class="source-inline">Orangesexample</strong>) and return <strong class="source-inline">False</strong> when the condition is true and return <strong class="source-inline">True</strong> when the condition is false:<p class="source-code">    def stringcheck(self,inputvalue):</p><p class="source-code">        if type(inputvalue) != str:</p><p class="source-code">            return False</p><p class="source-code">        else:</p><p class="source-code">            return True</p></li>
<li>In the following method, let’s check that the input variable is not a floating point value (for example, <strong class="source-inline">2335.2434</strong>) and return <strong class="source-inline">False</strong> when the condition is true and return <strong class="source-inline">True</strong> when the condition is false:<p class="source-code">   def floatcheck(self,inputvalue):</p><p class="source-code">        if type(inputvalue) != float:</p><p class="source-code">            return False</p><p class="source-code">        else:</p><p class="source-code">            return True</p></li>
<li>In the<a id="_idIndexMarker371"/> following method, let’s check that the input variable is not a list of variables (for example, <strong class="source-inline">['fruits','flowers',1990]</strong>) and return <strong class="source-inline">False</strong> when the condition is true and return <strong class="source-inline">True</strong> when the condition is false:<p class="source-code">   def listcheck(self,inputvalue):</p><p class="source-code">        if type(inputvalue) != list:</p><p class="source-code">            return False</p><p class="source-code">        else:</p><p class="source-code">            return True</p></li>
<li>In the following method, let’s check that the input variable is not a tuple of variables (for example, <strong class="source-inline">('fruits','flowers',1990)</strong>) and return <strong class="source-inline">False</strong> when the condition is true and return <strong class="source-inline">True</strong> when the condition is false:<p class="source-code">   def tuplecheck(self,inputvalue):</p><p class="source-code">        if type(inputvalue) != tuple:</p><p class="source-code">            return False</p><p class="source-code">        else:</p><p class="source-code">            return True</p></li>
<li>In the following method, let’s check that the input variable is not a dictionary with key/value pairs (for example, <strong class="source-inline">{'one': 1, 'two': 2}</strong>) and return <strong class="source-inline">False</strong> when the condition is true and return <strong class="source-inline">True</strong> when the condition is false:<p class="source-code">   def dictcheck(self,inputvalue):</p><p class="source-code">        if type(inputvalue) != dict:</p><p class="source-code">            return False</p><p class="source-code">        else:</p><p class="source-code">            return True</p></li>
</ul>
<p>Now, we <a id="_idIndexMarker372"/>can proceed further to create the <strong class="source-inline">Fashion</strong> class to perform type checks using the <strong class="source-inline">typecheck</strong> class.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/>Creating a class to test type checking </h2>
<p>In this <a id="_idIndexMarker373"/>section, let’s look at creating a <strong class="source-inline">Fashion</strong> class with a different variable type definition as follows:</p>
<pre class="source-code">class Fashion:</pre>
<ul>
<li>Let’s initialize the variables along with the specific data types for each:<p class="source-code">    def __init__(self,clothing_category: str,gender:str,model:tuple,design:int,price:float,size:dict, color:list):</p><p class="source-code">        tc = typecheck()</p></li>
<li>In the following code, let’s check whether the <strong class="source-inline">clothing_category</strong> input is a string and return the value if it is true, and return an error specific to <strong class="source-inline">clothing_category</strong> if it is false:<p class="source-code">        if tc.stringcheck(clothing_category):</p><p class="source-code">            self.clothing_category = clothing_category</p><p class="source-code">        else:</p><p class="source-code">            print("clothing category should be a string")</p></li>
<li>In the following code, let‘s check whether the <strong class="source-inline">gender</strong> input is a string and return the value if it is true and return an error specific to the <strong class="source-inline">gender</strong> variable if it is false:<p class="source-code">        if tc.stringcheck(gender):</p><p class="source-code">            self.gender = gender</p><p class="source-code">        else: </p><p class="source-code">            print("gender should be a string")</p></li>
<li>In the <a id="_idIndexMarker374"/>following code, let’s check whether the <strong class="source-inline">model</strong> input is a tuple and return the value if it is true and return an error specific to the <strong class="source-inline">model</strong> variable if it is false:<p class="source-code">        if tc.tuplecheck(model):</p><p class="source-code">            self.model = model</p><p class="source-code">        else:</p><p class="source-code">            print("model should be a tuple")</p></li>
<li>In the following code, let’s check whether the <strong class="source-inline">design</strong> input is an integer and return the value if it is true and return an error specific to the <strong class="source-inline">design</strong> variable if it is false:<p class="source-code">if tc.intcheck(design):</p><p class="source-code">            self.design = design</p><p class="source-code">        else:</p><p class="source-code">            print("design should be an integer")</p></li>
<li>In the following code, let’s check whether the <strong class="source-inline">price</strong> input is a floating point value and return the value if it is true and return an error specific to the <strong class="source-inline">price</strong> variable if it is false:<p class="source-code">if tc.floatcheck(price):</p><p class="source-code">            self.price = price</p><p class="source-code">        else:</p><p class="source-code">            print("price should be a floating point value")</p></li>
<li>In the following code, let’s check whether the <strong class="source-inline">size</strong> input is a dictionary object and return the value if it is true and return an error specific to the <strong class="source-inline">size</strong> variable if it is false:<p class="source-code">if tc.dictcheck(size):</p><p class="source-code">            self.size = size</p><p class="source-code">        else:</p><p class="source-code">            print("size should be a dictionary object")</p></li>
<li>In the <a id="_idIndexMarker375"/>following code, let’s check whether the <strong class="source-inline">color</strong> input is a list object and return the value if it is true and return an error specific to the <strong class="source-inline">color</strong> variable if it is false:<p class="source-code">if tc.listcheck(color):       </p><p class="source-code">            self.color = color</p><p class="source-code">        else:</p><p class="source-code">            print("color should be a list of values")</p></li>
<li>In the following code, let’s create a method to return all the variables listed in the preceding code:<p class="source-code">    def get_item(self):</p><p class="source-code">        return self.clothing_category,self.gender,self.model,self.design,self.price, self.size,self.color</p></li>
</ul>
<p>To test this approach of type checking, let’s pass some incorrect values as input for some of these variables and check:</p>
<pre class="source-code">fashion = Fashion(12,"Women","Western","Floral","Maxi Dress",34,"yellow")</pre>
<p>Executing the preceding code results in the following list of errors:</p>
<pre class="source-code"><strong class="bold">clothing category should be a string</strong></pre>
<pre class="source-code"><strong class="bold">model should be a tuple</strong></pre>
<pre class="source-code"><strong class="bold">price should be a floating point value</strong></pre>
<pre class="source-code"><strong class="bold">size should be a dictionary object</strong></pre>
<pre class="source-code"><strong class="bold">color should be a list of values</strong></pre>
<p>Further, calling the <strong class="source-inline">get_item</strong> method on the preceding <strong class="source-inline">fashion</strong> object results in the following error:</p>
<pre class="source-code">fashion.get_item()</pre>
<p>The <a id="_idIndexMarker376"/>graphical representation of the error message is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<img alt="Figure 7.1 – Error on calling the get_item method " height="287" src="image/Figure_7.1_B13426.jpg" width="1309"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Error on calling the get_item method</p>
<p>In the preceding error, the first variable, <strong class="source-inline">clothing-category</strong>, was not accepted by the method since type expectations were not met by this variable.</p>
<p>We can check further by providing the right input types as follows:</p>
<pre class="source-code">fashion = Fashion("Rayon","Women",("Western","Floral"),12012,100.50,{'XS': 36, 'S': 38, 'M': 40},["yellow","red"])</pre>
<p>There were no errors from the preceding value assignments. Calling the <strong class="source-inline">get_item</strong> method on the <strong class="source-inline">fashion</strong> object now results in the following output:</p>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code"><strong class="bold">('Rayon',</strong></pre>
<pre class="source-code"><strong class="bold"> 'Women',</strong></pre>
<pre class="source-code"><strong class="bold"> ('Western', 'Floral'),</strong></pre>
<pre class="source-code"><strong class="bold"> 12012,</strong></pre>
<pre class="source-code"><strong class="bold"> 100.5,</strong></pre>
<pre class="source-code"><strong class="bold"> {'XS': 36, 'S': 38, 'M': 40},</strong></pre>
<pre class="source-code"><strong class="bold"> ['yellow', 'red'])</strong></pre>
<p>The <a id="_idIndexMarker377"/>preceding output meets all the type requirements and the end goal of type checking is achieved successfully through this approach. Now that you understand this, let’s look further into the concept of data types with constraints.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor103"/>Adding data types with constraints</h1>
<p>In this section, we<a id="_idIndexMarker378"/> will look at an example of adding constraints to<a id="_idIndexMarker379"/> data types and checking constraints along with type checking. There might be scenarios where we would like to create an integer variable and restrict its length to two digits or to create a string and restrict its length to 10 characters and more. With this example, let’s explore how to add such constraints or restricts during the static type checking. </p>
<p>In this example, let’s create a <strong class="source-inline">typecheck</strong> class with only two methods to check an integer and a string. While checking these data types, let’s also add a few more constraints within the method definition:</p>
<pre class="source-code">class typecheck:</pre>
<ul>
<li>In the following method, let’s check that the input variable is not an integer or its length is greater than two, and return <strong class="source-inline">False</strong> when the condition is true, and return <strong class="source-inline">True</strong> when the condition is false:<p class="source-code">    def intcheck(self,inputvalue):</p><p class="source-code">        if (type(inputvalue) != int) and (len(str(inputvalue))&gt;2):</p><p class="source-code">            return False</p><p class="source-code">        else:</p><p class="source-code">            return True</p></li>
<li>In the following method, let’s check that the input variable is not a string or its length is greater than 10, and return <strong class="source-inline">False</strong> when the condition is true, and return <strong class="source-inline">True</strong> when the condition is false:<p class="source-code">    def stringcheck(self,inputvalue):</p><p class="source-code">        if (type(inputvalue) != str) and (len(str(inputvalue))&gt;10):</p><p class="source-code">            return False</p><p class="source-code">        else:</p><p class="source-code">            return True</p></li>
</ul>
<p>With just two methods with type checks and constraints, we can look into creating a <strong class="source-inline">Fashion</strong> class with two variables and one method:</p>
<pre class="source-code">class Fashion:</pre>
<ul>
<li>Let’s <a id="_idIndexMarker380"/>initialize the class with <strong class="source-inline">clothing_category</strong> as a<a id="_idIndexMarker381"/> string and <strong class="source-inline">size</strong> as an integer:<p class="source-code">    def __init__(self,clothing_category: str,size:int):</p><p class="source-code">        tc = typecheck()</p></li>
<li>In the following code, let’s declare <strong class="source-inline">clothing_category</strong> using the <strong class="source-inline">stringcheck</strong> method:<p class="source-code">        if tc.stringcheck(clothing_category):</p><p class="source-code">            self.clothing_category = clothing_category</p><p class="source-code">        else:</p><p class="source-code">            print("value should be a string of length less than or equal to 10")</p></li>
<li>In the following code, let’s declare <strong class="source-inline">size</strong> using the <strong class="source-inline">intcheck</strong> method:<p class="source-code">        if tc.intcheck(size):</p><p class="source-code">            self.size = size</p><p class="source-code">        else:</p><p class="source-code">            print("value should be an integer of 2 digits or less")</p></li>
<li> In the following code, let’s add the method to get the items and return them:<p class="source-code">    def get_item(self):</p><p class="source-code">        return self.clothing_category,self.size</p></li>
</ul>
<p>Let’s further create an object for the <strong class="source-inline">fashion</strong> class and assign two variables that do not match the type-checking conditions:</p>
<pre class="source-code">fashion = Fashion("Clothing &amp; Accessories",384)</pre>
<pre class="source-code"><strong class="bold">value should be a string of length less than or equal to 10</strong></pre>
<pre class="source-code"><strong class="bold">value should be an integer of 2 digits or less</strong></pre>
<p>The <a id="_idIndexMarker382"/>preceding error messages indicate that both the type checks <a id="_idIndexMarker383"/>and constraints are not met for the string as well as integer data types. Let’s now provide the right type of input values and perform static type checking:</p>
<pre class="source-code">fashion = Fashion("Cotton",34)</pre>
<pre class="source-code">fashion.get_item()</pre>
<pre class="source-code">('Cotton', 34)</pre>
<p>The value assignments are now working as expected in the preceding code. With this understanding, let’s proceed further to create simple custom data types.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor104"/>Creating a simple custom data type</h1>
<p>Until the<a id="_idIndexMarker384"/> preceding section, we looked at adding explicit type checks and converting generic type variables into specific types to handle specific data needs we might get while programming an application, and we also added errors to help debug incorrect data types assigned to variables. </p>
<p>In this section, let’s look at creating our own simple data types and what will be required to do so. First of all, let’s answer the question of why we need our own data types. Any custom data type is a derivation of basic data types in Python along with certain variations to fulfill the purpose of our data needs in an application. Any data type will have its own set of operations that can be performed on top of the data of that specific type. For instance, an integer data type will support arithmetic operations such as addition, subtraction, multiplication, and division. Similarly, a string supports concatenation in the place of addition, and so on. So, when we create our own data type, we can override these basic operations to fulfill the need of our custom data type. </p>
<p>To demonstrate this, let‘s first create our own data type and override the basic operators to perform the operations that we expect. Please note that custom data types may be required only in situations where we would like to make it domain-specific or application-specific. We can always use default data types and avoid creating custom data types where there is no requirement:</p>
<ol>
<li>We will create a class named <strong class="source-inline">DressSize</strong> and initialize it with the <strong class="source-inline">size</strong> variable of the integer type. If the input value for <strong class="source-inline">size</strong> is not an integer and the input values do not follow a specific list of dress sizes, type checking returns an error message in red (as shown in <em class="italic">Figure 7.2</em>):<p class="source-code">class DressSize:</p><p class="source-code">    def __init__(self,size:int):</p><p class="source-code">        self.limit = [28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48]</p><p class="source-code">        if type(size)==int and size in self.limit:</p><p class="source-code">            self.size = size</p><p class="source-code">        else:</p><p class="source-code">            print("\x1B[31mSize should be a valid dress size")  </p></li>
<li>Next, let’s override the default <strong class="source-inline">str</strong> method of a class to return the string version of the <strong class="source-inline">size</strong> variable:<p class="source-code">    def __str__(self):</p><p class="source-code">        return str(self.size)</p></li>
<li>Then, let’s<a id="_idIndexMarker385"/> add a new method named <strong class="source-inline">value</strong> to return the value of the <strong class="source-inline">size</strong> attribute:<p class="source-code">    def value(self):</p><p class="source-code">        return self.size</p></li>
<li>Now, let’s override the addition (<strong class="source-inline">+</strong>) operator of the integer method to increase <strong class="source-inline">size</strong> values from one dress size object created for the <strong class="source-inline">DressSize</strong> class:<p class="source-code">    def __add__(self, up):</p><p class="source-code">        result = self.size + up</p><p class="source-code">        if result in self.limit:</p><p class="source-code">            return result</p><p class="source-code">        else:</p><p class="source-code">            return "Input valid size increments"</p></li>
<li>Then, let’s override the subtraction (<strong class="source-inline">-</strong>) operator of the integer method to decrease <strong class="source-inline">size</strong> values from one size object created for the <strong class="source-inline">DressSize</strong> class:     <p class="source-code">    def __sub__(self, down):</p><p class="source-code">        result = self.size - down</p><p class="source-code">        if result in self.limit:</p><p class="source-code">            return result</p><p class="source-code">        else:</p><p class="source-code">            return "Input valid size decrements"</p></li>
<li>We will then <a id="_idIndexMarker386"/>create an object for the class, in this case, our new custom data type, <strong class="source-inline">DressSize</strong>, and initialize it with a string instead of an integer, as follows:<p class="source-code">s = DressSize("30")</p></li>
</ol>
<p>Incorrect input type results in an error with a red font similar to how error messages are usually displayed while debugging:</p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="Figure 7.2 – Error message for DressSize  " height="34" src="image/Figure_7.2_B13426.jpg" width="1004"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Error message for DressSize </p>
<ol>
<li value="7">Calling the <strong class="source-inline">value</strong> method would also result in an error since the type checking failed for the <strong class="source-inline">DressSize</strong> data type:<p class="source-code">s.value()</p></li>
</ol>
<p>The value error is displayed as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="Figure 7.3 – Value error due to incorrect DressSize input type " height="332" src="image/Figure_7.3_B13426.jpg" width="887"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Value error due to incorrect DressSize input type</p>
<ol>
<li value="8">Let’s correct <a id="_idIndexMarker387"/>this error by providing the correct input type while creating a <strong class="source-inline">DressSize</strong> object:<p class="source-code">s = DressSize(30)</p><p class="source-code">s</p><p class="source-code">&lt;__main__.DressSize at 0x22c4bfc4a60&gt;</p></li>
<li>In the following code, we can look at how the addition operation (<strong class="source-inline">+</strong>) works on the objects of <strong class="source-inline">DressSize</strong>:<p class="source-code">DressSize(30) + 6</p><p class="source-code"><strong class="bold">36</strong></p><p class="source-code">DressSize(30) + 3</p><p class="source-code">'Input valid size increments'</p></li>
<li>The addition of two objects works like a regular addition since we have overloaded the addition operator (<strong class="source-inline">+</strong>) to add the initialized variables of two objects. Similarly, we can check the results of subtraction, as follows:<p class="source-code">DressSize(32) - 4</p><p class="source-code"><strong class="bold">26</strong></p><p class="source-code">DressSize(30) – 3</p><p class="source-code">'Input valid size decrements'</p></li>
<li>The subtraction of two objects works like a regular subtraction since we have overloaded the subtraction operator (<strong class="source-inline">-</strong>) to subtract the initialized variables of two objects. Similarly, printing the object results in printing the string format of the <strong class="source-inline">size</strong> variable since we have overloaded the <strong class="source-inline">str</strong> method to do this:<p class="source-code">print(s)</p><p class="source-code"><strong class="bold">30</strong></p></li>
<li>We have also added a <strong class="source-inline">value</strong> method to display the value of the <strong class="source-inline">size</strong> variable, and it works as follows:<p class="source-code">s.value()</p><p class="source-code"><strong class="bold">30</strong></p></li>
<li>Calling the <strong class="source-inline">type</strong> method<a id="_idIndexMarker388"/> on the variable or the <strong class="source-inline">s</strong> object displays the class name, <strong class="source-inline">DressSize</strong>, which is the data type of <strong class="source-inline">s</strong> in this case:<p class="source-code">type(s)</p><p class="source-code"><strong class="bold">__main__.DressSize</strong></p></li>
</ol>
<p>Now, we can consider creating a more detailed data type of our own in the next section.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor105"/>Creating a domain-specific data type</h1>
<p>In this section, let’s<a id="_idIndexMarker389"/> create an even more customized data type to deal with the dress size of the fashion department of <em class="italic">ABC Megamart</em>. The <strong class="source-inline">DressSize</strong> data type we defined in the preceding section handles any integer as input and performs the operations we overloaded. When we look at the domain of the fashion industry and consider the dress size as a domain-specific variable, the <strong class="source-inline">DressSize</strong> data type should ideally be considering only specific values for <strong class="source-inline">size</strong> and not accept all integers. The dress size will be based on the size of dresses held in the inventory of <em class="italic">ABC Megamart</em>. </p>
<p>The accepted input for dress size in this example should be the list of integers, <strong class="source-inline">[36,38,40,42,44,46,48]</strong>, or the list of strings that indicates the equivalent text values for dress size such as <strong class="source-inline">[XS,S,M,L,XL,XXL,XXXL]</strong>:</p>
<ol>
<li value="1">Let’s begin by creating the <strong class="source-inline">DressSize</strong> class along with its methods to work as a domain-specific data type, and initialize <strong class="source-inline">size</strong> as its only input value:<p class="source-code">class DressSize:</p><p class="source-code">    def __init__(self, size):</p></li>
<li>Let’s further define two domain-specific lists that holds the valid set of values for dress size in text and integer formats, respectively:<p class="source-code">self.romanchart = ['XS','S','M','L','XL','XXL','XXXL']</p><p class="source-code">self.sizenum = [36,38,40,42,44,46,48]</p></li>
<li>In the following code, we will be creating a dictionary object that holds the integer and text format of <strong class="source-inline">size</strong> as key/value pairs. The reason behind adding this dictionary object is to use it further in the data type-specific methods created for this data type:<p class="source-code">self.chart = {}dict(zip(self.romanchart,self.sizenum))</p></li>
<li>Let’s now add the condition that accepts the input value as <strong class="source-inline">size</strong> if it meets the data type criteria and then rejects the input value with an error if it does not meet the criteria:<p class="source-code">        if (size in self.romanchart) or (size in self.sizenum ):</p><p class="source-code">            self.size = size</p><p class="source-code">        else:</p><p class="source-code">            print("\x1B[31mEnter valid size")</p></li>
</ol>
<p>In the preceding code, the input value will be accepted if it is present in the <strong class="source-inline">romanchart</strong> list variable or if it is present in the <strong class="source-inline">sizenum</strong> list variable. If both the criteria are not met, the value will be rejected by the <strong class="source-inline">DressSize</strong> data type and an error message will be displayed in a red-colored font. Why do we need to set these strict constraints in this particular domain-specific data type? If we look at the <strong class="source-inline">size</strong> values of a dress, the size usually is an even number and there are no odd-numbered dress sizes in a shopping cart or in a clothing store. Also, the size of the clothing in most of the generic clothing stores falls between 36 and 48 in general. If the store holds clothes of lesser or greater sizes, we can adjust the lists accordingly and redefine the data type. In this specific scenario, let’s consider the dress sizes between 36 and 48 and their corresponding text codes between XS and XXXL as acceptable values. Now, we have added the acceptance<a id="_idIndexMarker390"/> criteria for the data type:</p>
<ol>
<li value="1">Let’s add specific methods that can be processed on the data type. In the following method, let’s override the default <strong class="source-inline">str</strong> method of a class to return the string version of the <strong class="source-inline">size</strong> variable:     <p class="source-code">    def __str__(self):</p><p class="source-code">        return str(self.size)</p></li>
<li>In the following code, let’s add a new method named <strong class="source-inline">value</strong> to return the value of the <strong class="source-inline">size</strong> attribute:<p class="source-code">    def value(self):</p><p class="source-code">        return self.size</p></li>
<li>In the following code, let’s add a method to increment the <strong class="source-inline">size</strong> value. The <strong class="source-inline">size</strong> value should increment by <strong class="source-inline">2</strong> since dress size is always measured in even numbers:<p class="source-code">    def increase(self):</p><p class="source-code">        if (self.size in self.romanchart) :</p><p class="source-code">            result = self.chart[self.size] + 2</p><p class="source-code">            for key, value in self.chart.items():</p><p class="source-code">                if value == result:</p><p class="source-code">                    return resultkey</p><p class="source-code">        elif (self.size in self.sizenum ):</p><p class="source-code">            return self.size + 2</p></li>
</ol>
<p>In the preceding code, we have added a logic to look up the value of a dress size such as <strong class="source-inline">XL</strong> if <strong class="source-inline">DressSize</strong> is a text input to the data type, and then increment the value by <strong class="source-inline">2</strong>. We have also added a logic to check the integer value of the dress size and increment by <strong class="source-inline">2</strong> if the dress size input is an integer. </p>
<ol>
<li value="4">Let’s add one more<a id="_idIndexMarker391"/> method to decrement the <strong class="source-inline">DressSize</strong> attribute:<p class="source-code">    def decrease(self):</p><p class="source-code">        if self.size in self.romanchart :</p><p class="source-code">            result = self.chart[self.size] - 2</p><p class="source-code">            for key, value in self.chart.items():</p><p class="source-code">                if value == result:</p><p class="source-code">                    return key</p><p class="source-code">        elif (self.size in self.sizenum ):</p><p class="source-code">            return self.size – 2</p></li>
</ol>
<p>In the preceding code, we have added a logic to look up the value of a dress size such as <strong class="source-inline">XL</strong> if <strong class="source-inline">DressSize</strong> is a text input to the data type, and then decrement the value by <strong class="source-inline">2</strong>. We have also added a logic to check the integer value of <strong class="source-inline">DressSize</strong> and decrement by <strong class="source-inline">2</strong> if the dress size input is an integer. This defines the overall creation of a domain-specific data type named <strong class="source-inline">DressSize</strong>.</p>
<ol>
<li value="5">The next step is to test this data type by creating an object:<p class="source-code">s = DressSize("XXL")</p></li>
</ol>
<p>In the preceding code, we have created an object named <strong class="source-inline">s</strong>, so let’s look at how various methods and attributes work on this object:</p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<img alt="Figure 7.4 – Attributes of DressSize " height="235" src="image/Figure_7.4_B13426.jpg" width="155"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Attributes of DressSize</p>
<ol>
<li value="6">In the following<a id="_idIndexMarker392"/> code, let’s call <strong class="source-inline">chart</strong> from the <strong class="source-inline">s</strong> object:<p class="source-code">s.chart</p><p class="source-code"><strong class="bold">{'XS': 36, 'S': 38, 'M': 40, 'L': 42, 'XL': 44, 'XXL': 46, 'XXXL': 48}</strong></p></li>
<li>Printing the object results in the string format representation of the value of the <strong class="source-inline">s</strong> object:<p class="source-code">print(s)</p><p class="source-code"><strong class="bold">XS</strong></p><p class="source-code"><strong class="bold">XL</strong></p></li>
<li>Calling the value method results as follows:<p class="source-code">s.value()</p><p class="source-code"><strong class="bold">'XXL'</strong></p></li>
<li>Calling the increment method results as follows:<p class="source-code">s.increase()</p><p class="source-code"><strong class="bold">XXXL</strong></p></li>
<li>Calling the decrement method results as follows:<p class="source-code">s.decrease()</p><p class="source-code"><strong class="bold">XL</strong></p></li>
<li>Let’s now create the <strong class="source-inline">Fashion</strong> class and initialize variables out of which the <strong class="source-inline">size</strong> variable<a id="_idIndexMarker393"/> will be initialized as the <strong class="source-inline">DressSize</strong> type:<p class="source-code">class Fashion:</p><p class="source-code">    def __init__(self,clothing_category: str,gender:str,model:str,design:str,dress_type:str,color:str,size:DressSize):</p><p class="source-code">        self.clothing_category = clothing_category</p><p class="source-code">        self.gender = gender</p><p class="source-code">        self.model = model</p><p class="source-code">        self.design = design</p><p class="source-code">        self.dress_type = dress_type</p><p class="source-code">        self.color = color</p></li>
<li>In the following code, let’s define the type checking condition for <strong class="source-inline">DressSize</strong>. If <strong class="source-inline">size</strong> is an instance of <strong class="source-inline">DressSize</strong>, then it returns the instance, and if it is not an instance, an appropriate error message will be displayed:<p class="source-code">if isinstance(size,DressSize):</p><p class="source-code">            self.size = size</p><p class="source-code">        else:</p><p class="source-code">            print("value should be of type DressSize")   </p></li>
<li>Let’s further add the <strong class="source-inline">get_item</strong> method to return the attributes of the <strong class="source-inline">Fashion</strong> class:<p class="source-code">    def get_item(self):</p><p class="source-code">        return self.clothing_category,self.gender,self.model,self.design,self.dress_type,self.color,self.size</p></li>
<li>Creating the object further results as follows:<p class="source-code">fashion = Fashion("Clothing","Women","Western","Dotted","Jumpsuits",'blue',"XL")</p><p class="source-code"><strong class="bold">value should be of type DressSize</strong></p></li>
</ol>
<p>In the preceding code, we did not assign the correct data type for the size variable. </p>
<ol>
<li value="15">To correct it, let’s create an instance of <strong class="source-inline">DressSize</strong> and provide it as input to the <strong class="source-inline">Fashion</strong> class:<p class="source-code">M = DressSize("M")</p><p class="source-code">fashion = Fashion("Clothing","Women","Western","Dotted","Jumpsuits",'blue',M)</p></li>
</ol>
<p>The preceding <a id="_idIndexMarker394"/>code did not result in any error and is accepted as input by the <strong class="source-inline">Fashion</strong> class. Calling the <strong class="source-inline">get_item</strong> method would result in the following output:</p>
<p class="source-code">fashion.get_item()</p>
<p class="source-code"><strong class="bold">('Clothing',</strong></p>
<p class="source-code"><strong class="bold"> 'Women',</strong></p>
<p class="source-code"><strong class="bold"> 'Western',</strong></p>
<p class="source-code"><strong class="bold"> 'Dotted',</strong></p>
<p class="source-code"><strong class="bold"> 'Jumpsuits',</strong></p>
<p class="source-code"><strong class="bold"> 'blue',</strong></p>
<p class="source-code"><strong class="bold"> &lt;__main__.DressSize at 0x22c4cf4ba60&gt;)</strong></p>
<p>If we want to look at the <a id="_idIndexMarker395"/>specific value of the <strong class="source-inline">M</strong> object, we can call the <strong class="source-inline">value</strong> method as follows:</p>
<p class="source-code">fashion.size.value()</p>
<p class="source-code"><strong class="bold">'M'</strong></p>
<p>In this section, we looked at how to create a domain-specific custom data type and how to use it on another class as a type variable. </p>
<p>These are some of the examples of how generics work in Python and how specifics can be applied to Python objects using user-defined functions.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor106"/>Summary</h1>
<p>In this chapter, we have learned the concepts of generics and type checking. We also looked at creating user-defined data types with specific constraints and we’ve also seen how to apply them to our core example. We created our own domain-specific data type and overloaded operators and methods to work according to the data type. Similar to other chapters covered in this book, this chapter is also used to change the behavior of Python objects externally using the concept of metaprogramming. </p>
<p>In the next chapter, we will be looking at the concept of templates with some interesting examples.</p>
</div>
</div></body></html>