<html><head></head><body>
  <div><h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-199" class="chapterTitle">Searching</h1>
    <p class="normal">An important operation for all data structures is searching for elements from a collection of data. There are various methods to search for an element in data structures; in this chapter, we shall explore the different strategies that can be used to find elements in a collection of items.</p>
    <p class="normal">Data elements can be stored in any kind of data structure, such as an array, link list, tree, or graph; the search operation is very important for many applications, mostly whenever we want to know if a particular data element is present in an existing list of data items. In order to retrieve the information efficiently, we require an efficient search algorithm.</p>
    <p class="normal">In this chapter, we will learn about the following:</p>
    <ul>
      <li class="bulletList">Various search algorithms</li>
      <li class="bulletList">Linear search algorithm</li>
      <li class="bulletList">Jump search algorithm </li>
      <li class="bulletList">Binary search algorithm</li>
      <li class="bulletList">Interpolation search algorithm</li>
      <li class="bulletList">Exponential search algorithm</li>
    </ul>
    <p class="normal">Let us start with an introduction to searching and a definition and then look at the linear search algorithm.</p>
    <h1 id="_idParaDest-200" class="heading-1">Introduction to searching</h1>
    <p class="normal">A <a id="_idIndexMarker849"/>search operation is carried out to find the location of the desired data item from a collection of data items. The search algorithm returns the location of the searched value where it is present in the list of items and if the data item is not present, it returns <code class="inlineCode">None</code>. </p>
    <p class="normal">Efficient searching is important to efficiently retrieve the location of the desired data item from a list of stored data items. For example, we have a long list of data values, such as <code class="inlineCode">{1, 45, 65, 23, 65, 75, 23}</code>, and we want to see if <code class="inlineCode">75</code> is present in the list or not. It becomes important to have an efficient search algorithm when the list of data items becomes large.</p>
    <p class="normal">There are two different ways in which data can be organized, which can affect how a search algorithm works:</p>
    <ul>
      <li class="bulletList">First, the <a id="_idIndexMarker850"/>search algorithm is applied to a list of items that is already sorted; that is, it is applied to an ordered set of items. For example, <code class="inlineCode">[1, 3, 5, 7, 9, 11, 13, 15, 17]</code>.</li>
      <li class="bulletList">The search algorithm is applied to an unordered set of items, which is not sorted. For example, <code class="inlineCode">[11, 3, 45, 76, 99, 11, 13, 35, 37]</code>.</li>
    </ul>
    <p class="normal">We will first take a look at linear searching.</p>
    <h1 id="_idParaDest-201" class="heading-1">Linear search</h1>
    <p class="normal">The search operation is <a id="_idIndexMarker851"/>used to find out the<a id="_idIndexMarker852"/> index position of a given data item in a list of data items. If the searched item is available in the given list of data items, then the search algorithm returns the index position where it is located; otherwise, it returns that the item is not found. Here, the index position is the location of the desired item in the given list.</p>
    <p class="normal">The simplest approach to search for an item in a list is to search linearly, in which we look for items one by one in the whole list. Let’s take an example of six list items <code class="inlineCode">{60, 1, 88, 10, 11, 100}</code> to understand the linear search algorithm, as shown in <em class="italic">Figure 10.1</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.1: An example of linear search</p>
    <p class="normal">The preceding list has elements that can be accessed through the index. To find an element in the list, we can search for the given element linearly one by one. This technique traverses the list of elements by using the index to move from the beginning of the list to the end. Each element is checked, and if it does not match the search item, the next item is examined. By hopping from one item to the next, the list is traversed sequentially. We use list items with integer values in this chapter to help you understand the concept, since integers can be compared easily; however, a list item can hold any other data type as well.</p>
    <p class="normal">The <a id="_idIndexMarker853"/>linear search approach <a id="_idIndexMarker854"/>depends on how the list items are stored in memory—whether they are already sorted in order or they are not sorted. Let’s first see how the linear search algorithm works if the given list of items is not sorted.</p>
    <h2 id="_idParaDest-202" class="heading-2">Unordered linear search</h2>
    <p class="normal">The <a id="_idIndexMarker855"/>unordered linear search<a id="_idIndexMarker856"/> is a linear search algorithm in which the given list of date items is not sorted. We linearly match the desired data item with the data items of the list one by one till the end of the list or until the desired data item is found. Consider an example list that contains the elements <code class="inlineCode">60</code>, <code class="inlineCode">1</code>, <code class="inlineCode">88</code>, <code class="inlineCode">10</code>, and <code class="inlineCode">100</code>—an unordered list. To perform a <code class="inlineCode">search</code> operation on such a list, one proceeds with the first item and compares that with the search item. If the search item is not matched, then the next element in the list is checked. This continues till we reach the last element in the list or until a match is found.</p>
    <p class="normal">In an unordered list of items, the search for the term <code class="inlineCode">10</code> starts from the first element and moves to the next element in the list. Thus, firstly <code class="inlineCode">60</code> is compared with <code class="inlineCode">10</code>, and since it is not equal, we compare <code class="inlineCode">66</code> with the next element <code class="inlineCode">1</code>, then <code class="inlineCode">88</code>, and so on till we find the search term in the list. Once the item is found, we return the index position of where we have found the desired item. This process is shown in <em class="italic">Figure 10.2</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.2: Unordered linear search</p>
    <p class="normal">Here is the<a id="_idIndexMarker857"/> implementation in Python for the linear search on an unordered list of items:</p>
    <pre class="programlisting code"><code class="hljs-code">def search(unordered_list, term):
    for i, item in enumerate(unordered_list):
        if term == unordered_list[i]:
            return i
    return None
</code></pre>
    <p class="normal">The <code class="inlineCode">search</code> functio<a id="_idIndexMarker858"/>n takes two parameters; the first is the list that holds the data, and the second parameter is the item that we are looking for, called <a id="_idIndexMarker859"/>the <strong class="keyWord">search term</strong>. On every pass of the <code class="inlineCode">for</code> loop, we check if the search term is equal to the indexed item. If this is true, then there is a match, and there is no need to proceed further with the search. We return the index position where the searched item is found in the list. If the loops run to the end of the list with no match found, then <code class="inlineCode">None</code> is returned to signify that there is no such item in the list.</p>
    <p class="normal">We can use the following code snippet to check if a desired data element is present in the given list of data items:</p>
    <pre class="programlisting code"><code class="hljs-code">list1 = [60, 1, 88, 10, 11, 600]
 
search_term = 10
index_position = search(list1, search_term) 
print(index_position)
list2 = ['packt', 'publish', 'data']
search_term2 = 'data'
Index_position2 = search(list2, search_term2)
print(Index_position2)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">3
2
</code></pre>
    <p class="normal">In the output of the <a id="_idIndexMarker860"/>above code, firstly, the index position <code class="inlineCode">3</code> is returned <a id="_idIndexMarker861"/>when we search for data element <code class="inlineCode">10</code> in <code class="inlineCode">list1</code>. And secondly, index position <code class="inlineCode">2</code> is returned when data item <code class="inlineCode">'data'</code> is searched for in <code class="inlineCode">list2</code>. We can use the same algorithm for searching a non-numeric data item from a list of non-numeric data items in Python, since string elements can also be compared similarly to numeric data in Python.</p>
    <p class="normal">When searching for any element from an unordered list of items, in the worst case the desired item may be in the last position or may not be present in the list. In this situation we will have to compare the search item with all the elements of the list, i.e. <code class="inlineCode">n</code> times if the total number of data items in the list is <code class="inlineCode">n</code>. Thus, the unordered linear search has a worst-case running time of <code class="inlineCode">O(n)</code>. All the elements may need to be visited before finding the search term. The worst-case scenario will be when the search term is located at the last position of the list.</p>
    <p class="normal">Next, we discuss how the linear search algorithm works if the given list of data items is already sorted.</p>
    <h2 id="_idParaDest-203" class="heading-2">Ordered linear search</h2>
    <p class="normal">If the <a id="_idIndexMarker862"/>data <a id="_idIndexMarker863"/>elements are already arranged in a sorted order, then the linear search algorithm can be improved. The linear search algorithm in a sorted list of elements has the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Move through the list sequentially</li>
      <li class="numberedList">If the value of a search item is greater than the object or item currently under inspection in the loop, then quit and return <code class="inlineCode">None</code></li>
    </ol>
    <p class="normal">In the process of<a id="_idIndexMarker864"/> iterating through the list, if the value of the search term is <a id="_idIndexMarker865"/>less than the current item in the list, then there is no need to continue with the search. Let’s consider an example to see how this works. Let’s say we have a list of items <code class="inlineCode">{2, 3, 4, 6, 7}</code> as shown in <em class="italic">Figure 10.3</em>, and we want to search for term <code class="inlineCode">5</code>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.3: Example of ordered linear search</p>
    <p class="normal">We start the <code class="inlineCode">search</code> operation by comparing the desired search element <code class="inlineCode">5</code> with the first element; no match is found. We continue on to compare the search element with the next element, i.e. <code class="inlineCode">3</code>, in the list. Since it also does not match, we move on to examine the next element, i.e. <code class="inlineCode">4</code>, and since it also does not match, we continue searching in the list, and we compare the search element with the fourth element, i.e. <code class="inlineCode">6</code>. This also does not match the search term. Since the given list is already sorted in ascending order and the value of the search item is less than the fourth element, the search item cannot be found in any later position in the list. In other words, if the current item in the list is greater than the search term, then it means there is no need to further search the list, and we stop searching for the element in the list.</p>
    <p class="normal">Here is the<a id="_idIndexMarker866"/> implementation <a id="_idIndexMarker867"/>of the linear search when the list is already sorted:</p>
    <pre class="programlisting code"><code class="hljs-code">def search_ordered(ordered_list, term):
     ordered_list_size = len(ordered_list)
     for i in range(ordered_list_size):
          if term == ordered_list[i]:
              return i
          elif ordered_list[i] &gt; term:
              return None
     return None
</code></pre>
    <p class="normal">In the preceding code, the <code class="inlineCode">if</code> statement now caters to checking if the search item is found in the list or not. Then, <code class="inlineCode">elif</code> tests the condition where <code class="inlineCode">ordered_list[i] &gt; term</code>. We stop searching if the comparison evaluates to <code class="inlineCode">True</code>, which means the current item in the list is greater than the search element. The last line in the method returns <code class="inlineCode">None</code> because the loop may go through the list and still the search item is not matched in the list.</p>
    <p class="normal">We use the following code snippet to use the search algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code">list1 = [2, 3, 4, 6, 7]
 
search_term = 5
index_position1 = search_ordered(list1, search_term)
 
if index_position1 is None:
    print("{} not found".format(search_term))
else:
    print("{} found at position {}".format(search_term, index_position1))
 
 
list2 = ['book','data','packt', 'structure']
 
search_term2 = 'structure'
index_position2 = search_ordered(list2, search_term2)
if index_position2 is None:
    print("{} not found".format(search_term2))
else:
    print("{} found at position {}".format(search_term2, index_position2))
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">5 not found
structure found at position 3
</code></pre>
    <p class="normal">In the output <a id="_idIndexMarker868"/>of the above code, firstly, the search item <code class="inlineCode">5</code> is not <a id="_idIndexMarker869"/>matched in the given list. And for the second list of non-numeric data elements, the string structure is matched at index position <code class="inlineCode">3</code>. Hence, we can use the same linear search algorithm for searching a non-numeric data item from an ordered list of data items, so the given list of data items should be sorted similarly to a contact list on a phone.</p>
    <p class="normal">In the worst-case scenario, the desired search item will be present in the last position of the list or will not be present at all. In this situation, we will have to trace the complete list (say <code class="inlineCode">n</code> elements). Thus, the worst-case time complexity of an ordered linear search is <code class="inlineCode">O(n)</code>.</p>
    <p class="normal">Next, we will discuss the jump search algorithm.</p>
    <h1 id="_idParaDest-204" class="heading-1">Jump search</h1>
    <p class="normal">The <strong class="keyWord">jump search</strong> algorithm<a id="_idIndexMarker870"/> is an improvement over linear search for searching for a given element from an ordered (or sorted) list of elements. This uses the <a id="_idIndexMarker871"/>divide-and-conquer strategy in order to search for the required element. In linear search, we compare the search value with each element of the list, whereas in jump search, we compare the search value at different intervals in the list, which reduces the number of comparisons.</p>
    <p class="normal">In this algorithm, firstly, we divide the sorted list of data into subsets of data elements called blocks. Within each block, the highest value will lie within the last element, as the array is sorted. Next, in this algorithm, we start comparing the search value with the last element of each block. There can be three conditions:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">If the search value is less than the last element of the block, we compare it with the next block.</li>
      <li class="numberedList">If the search value is greater than the last element of the block, it means the desired search value must be present in the current block. So, we apply linear search in this block and return the index position. </li>
      <li class="numberedList">If the search value is the same as the compared element of the block, we return the index position of the element and we return the candidate.</li>
    </ol>
    <p class="normal">Generally, the <a id="_idIndexMarker872"/>size of the block is taken as <img src="img/B17217_10_001.png" alt="" style="height: 1.2em !important; vertical-align: -0.10em !important;"/>, since it gives the best performance for a given array of length <code class="inlineCode">n</code>.</p>
    <p class="normal">In the <a id="_idIndexMarker873"/>worst-case situation, we will have to make <em class="italic">n/m</em> number of jumps (here, <code class="inlineCode">n</code> is the total number of elements, and <em class="italic">m</em> is the block size) if the last element of the last block is greater than the item to be searched, and we will need <em class="italic">m </em>- 1 comparisons for linear search in the last block. Therefore, the total number of comparisons will be ((<em class="italic">n/m</em>) + <em class="italic">m </em>- 1), which will minimize when <em class="italic">m</em> = <em class="italic">√n</em> . So the size of the block is taken as <em class="italic">√n</em> since it gives the best performance.</p>
    <p class="normal">Let’s take an example list <code class="inlineCode">{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}</code> to search for a given element (say <code class="inlineCode">10</code>):</p>
    <figure class="mediaobject"><img src="img/B17217_10_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.4: Illustration of the jump search algorithm</p>
    <p class="normal">In the <a id="_idIndexMarker874"/>above <a id="_idIndexMarker875"/>example, we find the desired element <code class="inlineCode">10</code> in <code class="inlineCode">5</code> comparisons. Firstly, we compare the first value of the array with the desired item <code class="inlineCode">A[0] &lt;= item</code>; if it is true, then we increase the index by the block size (this is shown in <em class="italic">step 1</em> in <em class="italic">Figure 10.4</em>). Next, we compare the desired item with the last element of each block. If it is greater, then we move to the next block, such as from block 1 to block 3 (this is shown in <em class="italic">steps 2</em>, <em class="italic">3</em>, and <em class="italic">4</em> in <em class="italic">Figure 10.4</em>).</p>
    <p class="normal">Further, when the desired search element becomes smaller than the last element of a block, we stop incrementing the index position and then we do the linear search in the current block. Now, let us discuss the implementation of the jump searching algorithms. Firstly, we implement the linear search algorithm, which is similar to what we discussed in the previous section. </p>
    <p class="normal">It is given again here for the sake of completeness as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def search_ordered(ordered_list, term):
    print("Entering Linear Search")
    ordered_list_size = len(ordered_list)
    for i in range(ordered_list_size):
        if term == ordered_list[i]:
            return i
        elif ordered_list[i] &gt; term:
            return -1
    return -1
</code></pre>
    <p class="normal">In the above <a id="_idIndexMarker876"/>code, given an ordered list of elements, it returns the index of the location where a given data element is found in the list. It returns <code class="inlineCode">–1</code> if the <a id="_idIndexMarker877"/>desired element is not found in the list. Next, we implement the <code class="inlineCode">jump_search()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def jump_search(ordered_list, item):
    import math
    print("Entering Jump Search")
    list_size = len(ordered_list)
    block_size = int(math.sqrt(list_size))
    i = 0
    while i != len(ordered_list)-1 and ordered_list[i] &lt;= item: 
        print("Block under consideration - {}".format(ordered_list[i: i+block_size]))
        if i+ block_size &gt; len(ordered_list):
            block_size =  len(ordered_list) - i
            block_list = ordered_list[i: i+block_size]
            j = search_ordered(block_list, item)
            if j == -1:
                print("Element not found")
                return
            return i + j
        if ordered_list[i + block_size -1] == item: 
            return i+block_size-1
        elif ordered_list[i + block_size - 1] &gt; item: 
            block_array = ordered_list[i: i + block_size - 1]
            j = search_ordered(block_array, item)
            if j == -1:
                print("Element not found")
                return
            return i + j
        i += block_size
</code></pre>
    <p class="normal">In the above code, firstly we assign the length of the list to the variable <code class="inlineCode">n</code>, and then we compute the block size as <img src="img/B17217_10_003.png" alt="" style="height: 1.2em !important; vertical-align: -0.10em !important;"/>. Next, we start with the first element, index 0, and then continue searching until we reach the end of the list.</p>
    <p class="normal">We start with the starting index <code class="inlineCode">i = 0</code> with a block of size <em class="italic">m</em>, and we continue incrementing until the window reaches the end of the list. We compare whether <code class="inlineCode">ordered_list [I + block_size -1] == item</code>. If they match, it returns the index position <code class="inlineCode">(i+ block_size -1)</code>. The code snippet for this is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">        if ordered_list[i+ block_size -1] == item:           
            return i+ block_size -1
</code></pre>
    <p class="normal">If <code class="inlineCode">ordered_list [i+ block_size -1] &gt; item</code>, we proceed to carry out the linear search algorithm<a id="_idIndexMarker878"/> inside the current block <code class="inlineCode">block_array = ordered_list [i : i+ block_size-1]</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">        elif ordered_list[i+ block_size -1] &gt; item:           
            block_array = ordered_list[i: i+ block_size -1]
            j = search_ordered(block_array, item) 
            if j == -1:
                print("Element not found")
                return   
            return i + j
</code></pre>
    <p class="normal">In the above <a id="_idIndexMarker879"/>code, we use the linear search algorithm in the subarray. It returns <code class="inlineCode">–1</code> if the desired element is not found in the list; otherwise, the index position of <code class="inlineCode">(i + j)</code> is returned. Here, <code class="inlineCode">i</code> is the index position until the previous block where we may find the desired element and <code class="inlineCode">j</code> is the position of the data element within the block where the desired element is matched. This process is also depicted in <em class="italic">Figure 10.5</em>. </p>
    <p class="normal">In this figure, we can see that <code class="inlineCode">i</code> is in index position 5, and then <code class="inlineCode">j</code> is the number of elements within the final block where we find the desired element, i.e. <code class="inlineCode">2</code>, so the final returned index will be <code class="inlineCode">5 + 2 = 7</code>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.5: Demonstration of index position i and j for the search value 8</p>
    <p class="normal">Further, we need to check for the length of the last block since it may have a number of elements less than the block size. For example, if the total number of elements is 11, then in the <a id="_idIndexMarker880"/>last block we will have 2 elements. So, we check if the desired search element is present in the last block, and if so we should update the starting and ending index as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">      if i+ block_size &gt; len(ordered_list):
            block_size =  len(ordered_list) - i
            block_list = ordered_list[i: i+block_size]
            j = search_ordered(block_list, item)
            if j == -1:
                print("Element not found")
                return
            return i + j
</code></pre>
    <p class="normal">In the above <a id="_idIndexMarker881"/>code, we search for the desired element using the linear search algorithm.</p>
    <p class="normal">Finally, if <code class="inlineCode">ordered_list[i+m-1] &lt; item</code>, then we move to the next iteration, and update the index by adding the block size to the index as <code class="inlineCode">i += block_size</code>.</p>
    <pre class="programlisting code"><code class="hljs-code">print(jump_search([1,2,3,4,5,6,7,8,9, 10, 11], 8))
</code></pre>
    <p class="normal">The output of the above code snippet is:</p>
    <pre class="programlisting con"><code class="hljs-con">Entering Jump Search
Block under consideration - [1, 2, 3]
Block under consideration - [4, 5, 6]
Block under consideration - [7, 8, 9]
Entering Linear Search
7
</code></pre>
    <p class="normal">In the above output, we can see the steps for how we searched for element <code class="inlineCode">10</code> in the given list of elements.</p>
    <p class="normal">Thus, jump search performs linear search on a block, so first it finds the block in which the element is present and then applies linear search within that block. The size of the block depends on the size of the array. If the size of the array is <code class="inlineCode">n</code>, then the block size may be <img src="img/B17217_10_003.png" alt="" style="height: 1.2em !important; vertical-align: -0.10em !important;"/>. If it does not find the element in that block, it moves to the next block. The jump search first finds out in which block the desired element may be present. For a list of <code class="inlineCode">n</code> elements, and a block size of <em class="italic">m</em>, the total number of jumps possible will be <em class="italic">n/m</em> jumps. Let’s say the size <a id="_idIndexMarker882"/>of the block is <img src="img/B17217_10_003.png" alt="" style="height: 1.2em !important; vertical-align: -0.10em !important;"/>; thus, the worst-case <a id="_idIndexMarker883"/>time complexity will be <img src="img/B17217_10_006.png" alt="" style="height: 1.4em !important; vertical-align: -0.30em !important;"/>.</p>
    <p class="normal">Next, we will discuss the binary search algorithm.</p>
    <h1 id="_idParaDest-205" class="heading-1">Binary search</h1>
    <p class="normal">The <strong class="keyWord">binary search</strong> algorithm <a id="_idIndexMarker884"/>finds a given item from the given sorted list of items. It is a fast and efficient algorithm to search for an element; however, one drawback of this algorithm is that we need a sorted list. The worst-case running time complexity of a binary search algorithm is <code class="inlineCode">O(logn)</code> whereas for linear search it is <code class="inlineCode">O(n)</code>.</p>
    <p class="normal">The binary search algorithm <a id="_idIndexMarker885"/>works as follows. It starts searching for the item by dividing the given list in half. If the search item is smaller than the middle value then it will look for the searched item only in the first half of the list, and if the search item is greater than the middle value it will only look at the second half of the list. We repeat the same process every time until we find the search item, or we have checked the whole list. In the case of a non-numeric list of data items, for example, if we have string data items, then we should sort the data items in alphabetical order (similar to how a contact list is stored on a phone).</p>
    <p class="normal">Let’s understand the <a id="_idIndexMarker886"/>binary search algorithm with an example. Suppose we have a book with 1,000 pages, and we want to reach page number 250. We know that every book has its pages numbered sequentially from <code class="inlineCode">1</code> upward. So, according to the binary search analogy, we first check forsearch item 250, which is less than the midpoint, which is 500. Thus, we search for the required page only in the first half of the book. </p>
    <p class="normal">We again find the midpoint of the first half of the book, using page 500 as a reference we find the midpoint, 250. That brings us closer to finding the 250<sup class="superscript">th</sup> page. Then we find the required page in the book.</p>
    <p class="normal">Let’s take another example to understand the workings of binary search. We want to search for item <code class="inlineCode">43</code> from a list of 12 items, as shown in <em class="italic">Figure 10.6</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.6: Working of binary search</p>
    <p class="normal">We start <a id="_idIndexMarker887"/>searching for the item by comparing it to the middle item of the list, which is <code class="inlineCode">37</code> in the example. If the value of the search item is less than the middle value, we <a id="_idIndexMarker888"/>only look at the first half of the list; otherwise, we will look at the other half. So, we only need to search for the item in the second half. We follow the same procedure until we find search item <code class="inlineCode">43</code> in the list. This process is shown in the <em class="italic">Figure 10.6</em>.</p>
    <p class="normal">The following is an implementation of the binary search algorithm on an ordered list of items:</p>
    <pre class="programlisting code"><code class="hljs-code">def binary_search_iterative(ordered_list, term):
    size_of_list = len(ordered_list) – 1
    index_of_first_element = 0
    index_of_last_element = size_of_list
    while index_of_first_element &lt;= index_of_last_element:
        mid_point = (index_of_first_element + index_of_last_element)/2
        if ordered_list[mid_point] == term:
            return mid_point
        if term &gt; ordered_list[mid_point]:
            index_of_first_element = mid_point + 1
        else:
            index_of_last_element = mid_point – 1
    if index_of_first_element &gt; index_of_last_element:
        return None
</code></pre>
    <p class="normal">We’ll explain <a id="_idIndexMarker889"/>the above code using a list of sorted elements <code class="inlineCode">{10, 30, 100, 120, 500}</code>. Now let’s assume we have to find the position where item <code class="inlineCode">10</code> is located in the list shown in <em class="italic">Figure 10.7</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.7: Sample list of five items</p>
    <p class="normal">Firstly, we <a id="_idIndexMarker890"/>declare two variables, i.e. <code class="inlineCode">index_of_first_element</code> and <code class="inlineCode">index_of_last_element</code>, which denote the starting and ending index positions in the given list. Next, the algorithm uses a <code class="inlineCode">while</code> loop to iteratively adjust the limits in the list within which we have to find a search item. The terminating condition to stop the <code class="inlineCode">while</code> loop is that the difference between the starting index, <code class="inlineCode">index_of_first_element</code>, and the <code class="inlineCode">index_of_last_element</code> index should be positive.</p>
    <p class="normal">The algorithm first finds the midpoint of the list by adding the index of the first element (i.e. <code class="inlineCode">0</code> in this case) to the index of the last element (which is <code class="inlineCode">4</code> in this example) and dividing it by <code class="inlineCode">2</code>. We get the middle index, <code class="inlineCode">mid_point</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">mid_point = (index_of_first_element + index_of_last_element)/2
</code></pre>
    <p class="normal">In this case, the index of the midpoint is <code class="inlineCode">2</code>, and the data item stored at this position is <code class="inlineCode">100</code>. We compare the midpoint element with the search item <code class="inlineCode">10</code>. </p>
    <p class="normal">Since these do not match, and the search item <code class="inlineCode">10</code> is less than the midpoint, the desired search item should lie in the first half of the list, thus, we adjust the index range of <code class="inlineCode">index_of_first_element</code> to <code class="inlineCode">mid_point-1</code>, which means the new search range becomes <code class="inlineCode">0</code> to <code class="inlineCode">1</code>, as shown in <em class="italic">Figure 10.8</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.8: Index of first and last elements for the first half of the list</p>
    <p class="normal">However, if we <a id="_idIndexMarker891"/>had been searching for <code class="inlineCode">120</code>, as <code class="inlineCode">120</code> would have been greater <a id="_idIndexMarker892"/>than the middle value (<code class="inlineCode">100</code>), we would have searched for the item in the second half of the list, and as a result, we would have needed to change the list index range to be <code class="inlineCode">mid_point +1</code> to <code class="inlineCode">index_of_last_element</code>. In that case the new range would have been <code class="inlineCode">(3, 4)</code>.</p>
    <p class="normal">So, with the new indexes of the first and last elements, i.e. <code class="inlineCode">index_of_first_element</code> and <code class="inlineCode">index_of_last_element</code>, now being <code class="inlineCode">0</code> and <code class="inlineCode">1</code> respectively, we compute the midpoint <code class="inlineCode">(0 + 1)/2</code>, which equals <code class="inlineCode">0</code>. The new midpoint is <code class="inlineCode">0</code>, so we find the middle item and compare it with the search item, which yields the value <code class="inlineCode">10</code>. Now, our search item is found, and the index position is returned.</p>
    <p class="normal">Finally, we check if <code class="inlineCode">index_of_first_element</code> is less than <code class="inlineCode">index_of_last_element</code> or not. If this condition fails, it means that the search term is not in the list.</p>
    <p class="normal">We can use the below code snippet to search for a term/item in the given list:</p>
    <pre class="programlisting code"><code class="hljs-code">list1 = [10, 30, 100, 120, 500]
 
search_term = 10
index_position1 = binary_search_iterative(list1, search_term)
if index_position1 is None:
    print("The data item {} is not found".format(search_term))
else:
    print("The data item {} is found at position {}".format(search_term, index_position1))
 
list2 = ['book','data','packt', 'structure']
 
search_term2 = 'structure'
index_position2 = binary_search_iterative(list2, search_term2)
if index_position2 is None:
    print("The data item {} is not found".format(search_term2))
else:
    print("The data item {} is found at position {}".format(search_term2, index_position2))
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">The data item 10 is found at position 0
The data item structure is found at position 3
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker893"/>above code, firstly we check the search term <code class="inlineCode">10</code> in the list, and we get the correct location, i.e. index position <code class="inlineCode">0</code>. Further, we check the index position <a id="_idIndexMarker894"/>of the string structure in the given sorted list of data items, and we get the index position <code class="inlineCode">3</code>.</p>
    <p class="normal">The implementation that we have discussed is based on an iterative process. However, we can also implement it using the recursive method, in which we recursively shift the pointers that point to the beginning (or starting) and end of the search list. See the following code for an example of a recursive implementation of the binary search algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code">def binary_search_recursive(ordered_list, first_element_index, last_element_index, term):
    if (last_element_index &lt; first_element_index):
        return None
    else:
        mid_point = first_element_index + ((last_element_index - first_element_index) // 2)
        if ordered_list[mid_point] &gt; term:
            return binary_search_recursive (ordered_list, first_element_index, mid_point-1, term)
        elif ordered_list[mid_point] &lt; term:
            return binary_search_recursive (ordered_list, mid_point+1, last_element_index, term)
        else:
            return mid_point
</code></pre>
    <p class="normal">A call to this <a id="_idIndexMarker895"/>recursive implementation of the binary search algorithm <a id="_idIndexMarker896"/>and its output is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">list1 = [10, 30, 100, 120, 500]
 
search_term = 10
index_position1 =  binary_search_recursive(list1, 0, len(list1)-1, search_term)
if index_position1 is None:
    print("The data item {} is not found".format(search_term))
else:
    print("The data item {} is found at position {}".format(search_term, index_position1))
 
 
list2 = ['book','data','packt',  'structure']
 
search_term2 = 'data'
index_position2 = binary_search_recursive(list2, 0, len(list1)-1, search_term2)
if index_position2 is None:
    print("The data item {} is not found".format(search_term2))
else:
    print("The data item {} is found at position {}".format(search_term2, index_position2))
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">The data item 10 is found at position 0
The data item data is found at position 1
</code></pre>
    <p class="normal">Here, the only distinction between the recursive binary search and the iterative binary search is the function definition and also the way in which <code class="inlineCode">mid_point</code> is calculated. The calculation for <code class="inlineCode">mid_point</code> after the <code class="inlineCode">((last_element_index - first_element_index)//2)</code> operation must add its result to <code class="inlineCode">first_element_index</code>. That way, we define the portion of the list to attempt the search.</p>
    <p class="normal">In binary search, we repeatedly divide the search space (i.e. the list in which the desired item may lie) in half. We <a id="_idIndexMarker897"/>start with the complete list, and in each iteration, we compute the middle point; we only consider half the list to search for the item and the other half of the list is ignored. We repeatedly check until the value is found, or the interval is empty. Therefore, at <a id="_idIndexMarker898"/>each iteration, the size of the array reduces by half; for example, at iteration 1, the size of the list is <code class="inlineCode">n</code>, in iteration 2, the size of the list becomes n/2, in iteration 3 the size of the list becomes n/2<sup class="superscript">2</sup>, and after <em class="italic">k</em> iterations the size of the list becomes n/2<sup class="superscript">k</sup>. At that time the size of the list will be equal to <code class="inlineCode">1</code>. That means:</p>
    <pre class="programlisting code"><code class="hljs-code">=&gt;  n/2<sup class="superscript">k</sup> = 1
</code></pre>
    <p class="normal">Applying the <code class="inlineCode">log</code> function on both sides:</p>
    <pre class="programlisting code"><code class="hljs-code">=&gt; log<sub class="subscript">2</sub>(n) = log<sub class="subscript">2</sub>(2k)
=&gt; log<sub class="subscript">2</sub>(n) = k log<sub class="subscript">2</sub>(2)
=&gt; k = log<sub class="subscript">2</sub>(n)
</code></pre>
    <p class="normal">Hence, the binary search algorithm has the worst-case time complexity of <code class="inlineCode">O(log n)</code>.</p>
    <p class="normal">Next, we will discuss the interpolation search algorithm.</p>
    <h1 id="_idParaDest-206" class="heading-1">Interpolation search</h1>
    <p class="normal">The <a id="_idIndexMarker899"/>binary search algorithm<a id="_idIndexMarker900"/> is an efficient algorithm for searching. It always reduces the search space by half by discarding one half of the search space depending on the value of the search item. If the search item is smaller than the value in the middle of the list, the second half of the list is discarded from the search space. In the case of binary search, we always reduce the search space by a fixed value of half, whereas the interpolation search algorithm is an improved version of the binary search algorithm in which we use a more efficient method that reduces the search space by more than half after each iteration.</p>
    <p class="normal">The interpolation search algorithm <a id="_idIndexMarker901"/>works efficiently when there are uniformly distributed elements in the sorted list. In a binary search, we always start searching from the middle of the list, whereas in the interpolation search we compute the starting search position depending on the item to be searched. In the interpolation search algorithm, the starting search position is most likely to be close to the start or end of the list; if the search item is near the first element in the list, then the starting search position is likely to be near the start of the list and if the search item is near the end of the list, then the starting search position is likely to be near the end of the list.</p>
    <p class="normal">It is quite <a id="_idIndexMarker902"/>similar to how humans perform a search on any list of items. It is based on trying to make a good guess of the index position where a search item is likely to be found in a sorted list of items. </p>
    <p class="normal">It works in a similar way to the binary search algorithm except for the method to determine the splitting criteria to divide the data in order to reduce the number of comparisons. In the case of a binary search, we divide the data into equal halves and in the case of an interpolation search, we divide the data using the following formula:</p>
    <figure class="mediaobject"><img src="img/B17217_10_007.png" alt=""/></figure>
    <p class="normal">In the preceding formula, <code class="inlineCode">low_index</code> is the lower-bound index of the list, which is the index of the smallest value, and <code class="inlineCode">upper_index</code> denotes the index position of the highest value in the list. The <code class="inlineCode">list[low_index]</code> and <code class="inlineCode">list[upper_index]</code> are the lowest and highest values respectively in the list. The <code class="inlineCode">search_value</code> variable contains the value of the item that is to be searched.</p>
    <p class="normal">Let’s consider an example to <a id="_idIndexMarker903"/>understand how the interpolation search algorithm works using the following list of seven items:</p>
    <figure class="mediaobject"><img src="img/B17217_10_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.9: Example of interpolation search</p>
    <p class="normal">Given the<a id="_idIndexMarker904"/> list of seven items, <code class="inlineCode">44</code>, <code class="inlineCode">60</code>, <code class="inlineCode">75</code>, <code class="inlineCode">100</code>, <code class="inlineCode">120</code>, <code class="inlineCode">230</code>, and <code class="inlineCode">250</code>, the <code class="inlineCode">mid</code> point <a id="_idIndexMarker905"/>can be computed using the above mentioned formula with the following values:</p>
    <pre class="programlisting code"><code class="hljs-code">list1 = [4,60,75,100,120,230,250]
low_index = 0
upper_index = 6
list1[upper_index] = 250
list1[low_index] = 44
search_value = 230
</code></pre>
    <p class="normal">Putting the values of all the variables in the formula, we get:</p>
    <pre class="programlisting code"><code class="hljs-code">mid = low_index +  ((upper_index - low_index)/ (list1[upper_index] - list1[low_index])) * (search_value - list1[low_index])
=&gt; 0 + [(6-0)/(250-44)] * (230-44)
=&gt; 5.41
=&gt; 5
</code></pre>
    <p class="normal">The <code class="inlineCode">mid</code> index is <code class="inlineCode">5</code>, in the case of an interpolation search, so the algorithm starts searching from the index position <code class="inlineCode">5</code>. So, this is how we compute the midpoint from which we start searching for the given element.</p>
    <p class="normal">The interpolation search algorithm works as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We start searching for the given search value from the midpoint (we have just seen how to compute it).</li>
      <li class="numberedList">If the search value matches the value stored at the index of the midpoint, we return this index position.</li>
      <li class="numberedList">If the search value does not match the value stored at the midpoint, we divide the list into two sublists, i.e. a higher sublist and lower sublist. The higher sublist has all the elements with higher index values than the midpoint, and the lower sublist has all the elements with lower index values.</li>
      <li class="numberedList">If the search value is greater than the value of the midpoint, we search the given search value in the higher sublist and ignore the lower sublist.</li>
      <li class="numberedList">If the search value is lower than the value of the midpoint, we search the given search value in the lower sublist and ignore the higher sublist.</li>
      <li class="numberedList">We repeat the process until the size of the sublists is reduced to zero.</li>
    </ol>
    <p class="normal">Let us <a id="_idIndexMarker906"/>understand the implementation <a id="_idIndexMarker907"/>of the interpolation search algorithm. Firstly, we define the <code class="inlineCode">nearest_mid()</code> method, which computes the midpoint as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def nearest_mid(input_list, low_index, upper_index, search_value):
       mid = low_index + (( upper_index - low_index)/(input_list[upper_index] - input_list[low_index])) * (search_value - input_list[low_index])
       return int(mid)
</code></pre>
    <p class="normal">The <code class="inlineCode">nearest_mid</code> function takes, as arguments, the lists on which to perform the search. The <code class="inlineCode">low_index</code> and <code class="inlineCode">upper_index</code> parameters represent the bounds in the list within which we are hoping to find the search term. Furthermore, <code class="inlineCode">search_value</code> represents the value being searched for.</p>
    <p class="normal">In an interpolation search, the midpoint is generally more to the left or right. This is caused by the effect of the multiplier being used when dividing to obtain the midpoint. The implementation of the interpolation algorithm remains the same as that of the binary search except for the way we compute the midpoint.</p>
    <p class="normal">In the following code, we provide the implementation of the interpolation search algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code">def interpolation_search(ordered_list, search_value):
    low_index = 0
    upper_index = len(ordered_list) - 1
    while low_index &lt;= upper_index:
        mid_point = nearest_mid(ordered_list, low_index, upper_index, search_value)
        if mid_point &gt; upper_index or mid_point &lt; low_index:
            return None
        if ordered_list[mid_point] == search_value:
            return mid_point
        if search_value &gt; ordered_list[mid_point]:
            low_index = mid_point + 1
        else:
            upper_index = mid_point – 1
    if low_index &gt; upper_index:
        return None
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker908"/>above code, we initialize the <code class="inlineCode">low_index</code> and <code class="inlineCode">upper_index</code> variables for the given sorted list. We firstly compute the midpoint <a id="_idIndexMarker909"/>using the <code class="inlineCode">nearest_mid()</code> method.</p>
    <p class="normal">The computed midpoint using the <code class="inlineCode">nearest_mid</code> function may produce values that are greater than <code class="inlineCode">upper_bound_index</code> or lower than <code class="inlineCode">lower_bound_index</code>. When this occurs, it means the search term, <code class="inlineCode">term</code>, is not in the list. <code class="inlineCode">None</code> is, therefore, returned to represent this.</p>
    <p class="normal">Next, we match the search value with the value stored at the midpoint, i.e. <code class="inlineCode">ordered_list[mid_point]</code>. If that matches, the index of the midpoint is returned; if it does not match, then we divide the lists into higher and lower sublists, and we readjust <code class="inlineCode">low_index</code> and <code class="inlineCode">upper_index</code> so that the algorithm will focus on the sublist that is likely to contain the search term similar to what we did in the binary search:</p>
    <pre class="programlisting code"><code class="hljs-code">        if search_value &gt; ordered_list[mid_point]:
            low_index = mid_point + 1
        else:
            upper_index = mid_point - 1
</code></pre>
    <p class="normal">In the above code, we check if the search value is greater than the value stored at <code class="inlineCode">ordered_list[mid_point]</code>, then we only adjust the <code class="inlineCode">low_index</code> variable to point to the <code class="inlineCode">mid_point + 1</code> index.</p>
    <p class="normal">Let’s see how this adjustment occurs. Suppose we want to search for <code class="inlineCode">190</code> in the given list in <em class="italic">Figure 10.10</em>, then the midpoint will be <code class="inlineCode">4</code> as per the above formula. Then we compare the search value (i.e. <code class="inlineCode">190</code>) with the value stored at the midpoint (i.e. <code class="inlineCode">120</code>). Since the search value is greater, we search for the element in the higher sublist, and readjust the <code class="inlineCode">low_index</code> value. This is shown in <em class="italic">Figure 10.10</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.10: Readjustment of the low_index when the value of the search item is greater than the value at the midpoint</p>
    <p class="normal">On the other <a id="_idIndexMarker910"/>hand, if the <a id="_idIndexMarker911"/>value of the search term is less than the value stored at <code class="inlineCode">ordered_list[mid_point]</code>, then we only adjust the <code class="inlineCode">upper_index</code> variable to point to the index <code class="inlineCode">mid_point - 1</code>. For example, if we have the list shown in <em class="italic">Figure 10.11</em>, and we want to search for <code class="inlineCode">185</code>, then the midpoint will be <code class="inlineCode">4</code> as per the formula. </p>
    <p class="normal">Next, we compare the search value (i.e. <code class="inlineCode">185</code>) with the value stored at the midpoint (i.e. <code class="inlineCode">190</code>). Since the search value is less as compared to <code class="inlineCode">ordered_list[mid_point]</code>, we search for the element in the lower sublist, and readjust the <code class="inlineCode">upper_index</code> value. This is shown in <em class="italic">Figure 10.11</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.11: Readjustment of the upper_index when the search item is less than the value at the midpoint</p>
    <pre>{44, 60, 75, 100, 120, 230, 250}</code>, in which we want to search for <code class="inlineCode">120</code> using the interpolation search algorithm.</pre>
    <pre class="programlisting code"><code class="hljs-code">list1 = [44, 60, 75, 100, 120, 230, 250]
a = interpolation_search(list1, 120)
print("Index position of value 2 is ", a)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Index position of value 2 is  4
</code></pre>
    <p class="normal">Let’s use a more <a id="_idIndexMarker912"/>practical example to understand <a id="_idIndexMarker913"/>the inner workings of both the binary search and interpolation algorithms.</p>
    <p class="normal">Consider for example the following list of elements:</p>
    <pre class="programlisting code"><code class="hljs-code">[ 2, 4, 5, 12, 43, 54, 60, 77] 
</code></pre>
    <p class="normal">At index 0, the value <code class="inlineCode">2</code> is stored, and at index <code class="inlineCode">7</code>, the value <code class="inlineCode">77</code> is stored. Now, assume that we want to find element <code class="inlineCode">2</code> in the list. How will the two different algorithms go about it?</p>
    <p class="normal">If we pass this list to the <code class="inlineCode">interpolation search</code> function, then the <code class="inlineCode">nearest_mid</code> function will return a value equal to <code class="inlineCode">0</code> using the formula of <code class="inlineCode">mid_point</code> computation, which is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">mid_point = 0 + [(7-0)/(77-2)] * (2-2)
          = 0 
</code></pre>
    <p class="normal">As we get the <code class="inlineCode">mid_point</code> value <code class="inlineCode">0</code>, we start the interpolation search with the value at index <code class="inlineCode">0</code>. Just with one comparison, we have found the search term.</p>
    <p class="normal">On the other hand, the binary search algorithm needs three comparisons to arrive at the search term, as illustrated in <em class="italic">Figure 10.12</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.12: Three comparisons are required to search for the item using the binary search algorithm</p>
    <p class="normal">The first <code class="inlineCode">mid_point</code> value calculated is <code class="inlineCode">3</code>. The second <code class="inlineCode">mid_point</code> value is <code class="inlineCode">1</code> and the last <code class="inlineCode">mid_point</code> value where <a id="_idIndexMarker914"/>the search term is found is <code class="inlineCode">0</code>. So, we reach the desired search item in three comparisons whereas in<a id="_idIndexMarker915"/> interpolation search we find the desired item on the first attempt.</p>
    <p class="normal">The interpolation search algorithm works well when the data set is sorted, and uniformly distributed. In this case, the average case time complexity is <code class="inlineCode">O(log(log n))</code> in which <code class="inlineCode">n</code> is the length of the array. Moreover, if the dataset is randomized, in that case, the worst-case time complexity of the interpolation search algorithm will be <code class="inlineCode">O(n)</code>. So, interpolation search may work better than binary search if the given data is uniformly distributed.</p>
    <h1 id="_idParaDest-207" class="heading-1">Exponential search</h1>
    <p class="normal">Exponential search is <a id="_idIndexMarker916"/>another search algorithm that is mostly used when we have large numbers of elements in a list. Exponential search is also known as galloping search and doubling search. The <a id="_idIndexMarker917"/>exponential search algorithm <a id="_idIndexMarker918"/>works in the following two steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Given a sorted array of <code class="inlineCode">n</code> data elements, we first determine the subrange in the original list where the desired search item may be present</li>
      <li class="numberedList">Next, we use the binary search algorithm to find out the search value within the subrange of data elements identified in <em class="italic">step 1</em></li>
    </ol>
    <p class="normal">Firstly, in order to find out the subrange of data elements, we start searching for the desired item in the given sorted array by jumping 2<sup class="superscript">i</sup> elements every iteration. Here, <code class="inlineCode">i</code> is the value of the index of the array. After each jump, we check if the search item is present between the last jump and the current jump. If the search item is present then we use the binary search algorithm within this subarray, and if it is not present, we move the index to the next location. Therefore, we first find the first occurrence of an exponent <code class="inlineCode">i</code> such that the value at index 2<sup class="superscript">i</sup> is greater than the search value. Then, the 2<sup class="superscript">i</sup> becomes the lower bound and 2<sup class="superscript">i</sup>-1 becomes the upper bound for this range of data elements in <a id="_idIndexMarker919"/>which the search value will be present. The exponential search algorithm<a id="_idIndexMarker920"/> is defined as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, we check the first element <code class="inlineCode">A[0]</code> with the search element.</li>
      <li class="numberedList">Initialize the index position <code class="inlineCode">i=1</code>.</li>
      <li class="numberedList">We check two conditions: (1) if it is the end of the array or not (i.e. 2<sup class="superscript">i</sup> <code class="inlineCode">&lt;</code> len(A)), and (2) if<code class="inlineCode"> A[i]</code> <code class="inlineCode">&lt;=</code> <code class="inlineCode">search_value</code>). In the first condition, we check if we have searched the complete list, and we stop if we have reached the end of the list. In the second condition, we stop searching when we reach an element whose value is greater than the search value, because it means the desired element will be present before this index position (since the list is sorted).</li>
      <li class="numberedList">If either of the above two conditions is true, we move to the next index position by incrementing <code class="inlineCode">i</code> in powers of <code class="inlineCode">2</code>.</li>
      <li class="numberedList">We stop when either of the two conditions of <em class="italic">step 3</em> is satisfied.</li>
      <li class="numberedList">We apply the binary search algorithm on the range 2<sup class="superscript">i</sup>//2 to min (2<sup class="superscript">i</sup>, len(A)).</li>
    </ol>
    <p class="normal">Let’s take an example of a <a id="_idIndexMarker921"/>sorted array of elements <code class="inlineCode">A = {3, 5, 8, 10, 15, 26, 35, 45, 56, 80, 120, 125, 138}</code> in which we want to search for the element <code class="inlineCode">125</code>.</p>
    <p class="normal">We start with comparing the first element at index i = 0, i.e. A[0] with the search element. Since A[0] &lt; <code class="inlineCode">search_value</code>, we jump to the next location 2<sup class="superscript">i</sup> with i = 0, since A[2<sup class="superscript">0</sup>] &lt; <code class="inlineCode">search_value</code>, the condition is true, hence we jump to the next location with i = 1 i.e. A<code class="inlineCode">[</code>22<sup class="superscript">1</sup><code class="inlineCode">]</code> &lt; <code class="inlineCode">search_value</code>. We again jump to the next location 2<sup class="superscript">i</sup> with i = 2, since A[2<sup class="superscript">2</sup>] &lt; <code class="inlineCode">search_value</code>, the condition is true. We iteratively jump to the next location until we complete searching the list or the search value is greater than the value at that location, i.e. A[2<sup class="superscript">i</sup>] &lt; len(A) or A[2<sup class="superscript">i</sup>] &lt;= <code class="inlineCode">search_value</code>. Then we apply the binary search algorithm on the range of the subarray. The complete process for searching a given element in the sorted <a id="_idIndexMarker922"/>array using the exponential search algorithm is depicted in <em class="italic">Figure 10.13</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_10_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.13: Illustration of the exponential search algorithm</p>
    <p class="normal">Now, let us discuss the implementation of the exponential search algorithm. Firstly, we implement the <a id="_idIndexMarker923"/>binary search algorithm, which we have already discussed in the previous section, but <a id="_idIndexMarker924"/>for the completeness of this algorithm it is given again as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def binary_search_recursive(ordered_list, first_element_index, last_element_index, term):
    if (last_element_index &lt; first_element_index):
        return None
    else:
        mid_point = first_element_index + ((last_element_index - first_element_index) // 2)
        if ordered_list[mid_point] &gt; term:
            return binary_search_recursive (ordered_list, first_element_index, mid_point-1, term)
        elif ordered_list[mid_point] &lt; term:
            return binary_search_recursive (ordered_list, mid_point+1, last_element_index, term)
        else:
            return mid_point
</code></pre>
    <p class="normal">In the above code, given the ordered list of elements, it returns the index of the location where the given data element is found in the list. It returns <code class="inlineCode">None</code> if the desired element is not found in the list. Next, we implement the <code class="inlineCode">exponential_search()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def exponential_search(A, search_value):
    if (A[0] == search_value):
        return 0    
    index = 1
    while index &lt; len(A) and A[index] &lt; search_value:
        index *= 2       
    return binary_search_recursive(A, index // 2, min(index, len(A) - 1), search_value)
</code></pre>
    <p class="normal">In the above code, firstly, we compare the first element <code class="inlineCode">A[0]</code> with the search value. If it matches then the index position <code class="inlineCode">0</code> is returned. If that does not match, we increase the index position to 2<sup class="superscript">0</sup>, i.e. 1. We check <code class="inlineCode">A[1] &lt; search_value</code>. Since the condition is true, we jump to the next location 2<sup class="superscript">1</sup>, i.e. we compare <code class="inlineCode">A[2] &lt; search_value</code>. Since the condition is true, we move to the next location. </p>
    <p class="normal">We iteratively increase the index position in the power of 2 until the stop condition is satisfied:</p>
    <pre class="programlisting code"><code class="hljs-code">    while index &lt; len(A) and A[index] &lt; search_value:
        index *= 2
</code></pre>
    <p class="normal">Finally, when the <a id="_idIndexMarker925"/>stopping criteria are met, we use the binary search algorithm to search for the desired search value within the subrange as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    return binary_search_recursive(A, index // 2, min(index, len(A) - 1), search_value)
</code></pre>
    <p class="normal">Finally, the <code class="inlineCode">exponential_search()</code> method returns the index position if the search value is found in <a id="_idIndexMarker926"/>the given array; otherwise, <code class="inlineCode">None</code> is returned.</p>
    <pre class="programlisting code"><code class="hljs-code">print(exponential_search([1,2,3,4,5,6,7,8,9, 10, 11, 12, 34, 40], 34))
</code></pre>
    <p class="normal">The output of the above code snippet is:</p>
    <pre class="programlisting con"><code class="hljs-con">12
</code></pre>
    <p class="normal">In the above output, we get index position <code class="inlineCode">12</code> for the search item <code class="inlineCode">34</code> in the given array.</p>
    <p class="normal">The exponential search is useful for very large-sized arrays. This is better than binary search because instead of performing a binary search on the complete array, we find a subarray in which the element may be present and then apply binary search, so it reduces the number of comparisons.</p>
    <p class="normal">The worst-case time complexity of exponential search is O(log<sub class="subscript">2</sub>i), where <code class="inlineCode">i</code> is the index where the element to be searched is present. The exponential search algorithm can outperform binary search when the desired search element is present at the beginning of the array.</p>
    <p class="normal">We can also use exponential search to search in bounded arrays. It can even out-perform binary search when the target is near the beginning of the array, since exponential search takes <code class="inlineCode">O(log(i))</code> time whereas the binary search takes <code class="inlineCode">O(logn)</code> time, where <code class="inlineCode">n</code> is the total number of elements. The best-case complexity of exponential search is <code class="inlineCode">O(1)</code>, when the element is present at the first location of the array.</p>
    <p class="normal">Next, let us discuss how to decide which search algorithm we should choose for a given situation.</p>
    <h1 id="_idParaDest-208" class="heading-1">Choosing a search algorithm</h1>
    <p class="normal">Now that <a id="_idIndexMarker927"/>we’ve covered the different types of search algorithms, we can look into which ones work better and in what situations. The binary search and interpolation search algorithms are better in performance compared to both ordered and unordered linear search functions. The linear search algorithm is slower because of the sequential probing of elements in the list to find the search term.</p>
    <p class="normal">Linear search has a time complexity of <code class="inlineCode">O(n)</code>. The linear search algorithm does not perform well when the given list of data elements is large.</p>
    <p class="normal">The binary search operation, on the other hand, slices the list in two anytime a search is attempted. On each iteration, we approach the search term much faster than in a linear strategy. The time complexity yields <code class="inlineCode">O(logn)</code>. The binary search algorithm performs well but the drawback of it is that it requires a sorted list of elements. So, if the given data elements are short and unsorted then it is better to use the linear search algorithm.</p>
    <p class="normal">Interpolation search discards more than half of the list of items from the search space, and this gives it the ability to get to the portion of the list that holds a search term more efficiently. In the interpolation search algorithm, the midpoint is computed in such a way that it gives a higher probability of obtaining the search term faster. The average-case time complexity of interpolation search is <code class="inlineCode">O(log(logn))</code>, whereas the worst-case time complexity of the interpolation search algorithm is <code class="inlineCode">O(n)</code>. This shows that interpolation search is better than binary search and provides faster searching in most cases.</p>
    <p class="normal">Therefore, if the list is short and unsorted, then the linear search algorithm is suitable, and if the list is sorted and not very big then the binary search algorithm can be used. Further, the interpolation search algorithm is good to use if the data elements in the list are uniformly distributed. If the list is very large, then the exponential search algorithm and jump search algorithm can be used.</p>
    <h1 id="_idParaDest-209" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed the concept of searching for a given element from a list of data elements. We discussed several important search algorithms, such as linear search, binary search, jump search, interpolation search, and exponential search. The implementations of these algorithms were discussed using Python in detail. We will be discussing sorting algorithms in the next chapter.</p>
    <h1 id="_idParaDest-210" class="heading-1">Exercise</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">On average, how many comparisons are required in a linear search of <code class="inlineCode">n</code> elements?</li>
      <li class="numberedList">Assume there are eight elements in a sorted array. What is the average number of comparisons that will be required if all the searches are successful and if the binary search algorithm is used?</li>
      <li class="numberedList">What is the worst-case time complexity of the binary search algorithm?</li>
      <li class="numberedList">When should the interpolation search algorithm perform better than the binary search algorithm?</li>
    </ol>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4">https://packt.link/MEvK4</a></p>
    <p class="normal"><img src="img/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>