<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Meet Tkinter</h1></div></div></div><p>Welcome to the exciting world of GUI programming with Tkinter. This project aims at getting you acquainted with Tkinter, the built-in <a id="id0" class="indexterm"/>
<strong>graphical user interface</strong> (<strong>GUI</strong>) interface for all standard Python distributions.</p><p>
<strong>Tkinter</strong>
<a id="id1" class="indexterm"/> (pronounced tea-kay-inter) is the Python interface to Tk, the GUI toolkit for Tcl/Tk.</p><p>
<strong>Tcl</strong> (pronounced "tickle" and is an acronym for <strong>Tool Command Language</strong>) is a<a id="id2" class="indexterm"/> popular scripting language in the domains of embedded applications, testing, prototyping, and GUI development. Tk on the other hand is an open source, multiplatform widget toolkit that is used by many different languages for building GUI programs.</p><p>The Tkinter interface is implemented as a Python module, <code class="literal">Tkinter.py</code>, which is just a wrapper around a C-extension that uses Tcl/Tk libraries.</p><p>Tkinter is suited for application to a wide variety of areas ranging from small desktop applications, to use in scientific modeling and research endeavors across various disciplines.</p><p>We believe that the concepts you will develop here will enable you to apply and develop GUI applications in your area of interest. Let's get started!</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Mission Briefing</h1></div></div></div><p>The purpose of this project is to make<a id="id3" class="indexterm"/> you comfortable with Tkinter. It aims at introducing you to various components of GUI programming with Tkinter.</p><p>By the end of this project, you will have developed several partly functional dummy applications such as the one shown as follows:</p><div><img src="img/7941_01_01.jpg" alt="Mission Briefing"/></div><p>The applications<a id="id4" class="indexterm"/> developed in this project are "dummy applications" because they are not fully functional. In fact, the purpose of each small dummy application is to introduce you to some specific aspects of programming with Tkinter. This will set up the context for developing some fun and fully functional project ideas from <a class="link" href="ch02.html" title="Chapter 2. Making a Text Editor like Notepad">Project 2</a>, <em>Making a Text Editor</em>, onwards.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Why Is It Awesome?</h2></div></div></div><p>The ability to program <a id="id5" class="indexterm"/>a GUI application (as opposed to a simple console application) opens a whole world of possibilities for a programmer. It shifts the focus of the program from the programmer to the end user, enabling the programmer to reach out to a wider audience.</p><p>When a person learning Python needs to graduate to GUI programming, Tkinter seems to be the easiest and fastest way to get the work done. Tkinter is a great tool for programming GUI applications in Python.</p><p>The features that make Tkinter a great choice for GUI programming include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is simple to learn (simpler than any other GUI package for Python)</li><li class="listitem" style="list-style-type: disc">Relatively little code can produce powerful GUI applications</li><li class="listitem" style="list-style-type: disc">Layered design ensures that it is easy to grasp</li><li class="listitem" style="list-style-type: disc">It is portable across all operating systems</li><li class="listitem" style="list-style-type: disc">It is easily accessible as it comes pre-installed with standard Python distribution</li></ul></div><p>None of the other <a id="id6" class="indexterm"/>GUI toolkits has all of these features at the same time.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Your Hotshot Objectives</h2></div></div></div><p>The key concepts that we want <a id="id7" class="indexterm"/>you to take from this project include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the concept of root window and main loop</li><li class="listitem" style="list-style-type: disc">Understanding widgets—the building blocks for your programs</li><li class="listitem" style="list-style-type: disc">Acquainting yourself with a list of available widgets</li><li class="listitem" style="list-style-type: disc">Developing layouts using three geometry managers: pack, grid, and place</li><li class="listitem" style="list-style-type: disc">Learning to apply events and callbacks to make your program functional</li><li class="listitem" style="list-style-type: disc">Styling your widgets with styling options and configuring the root widget</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Mission Checklist</h2></div></div></div><p>An elementary knowledge of data <a id="id8" class="indexterm"/>structures, syntax, and semantics of Python is assumed. To work along with this project, you must have a working copy of Python 2.7.3 installed on your computer.</p><p>The Python download package and instructions for downloading for different platforms are available at <a class="ulink" href="http://www.Python.org/getit/releases/2.7.3/">http://www.Python.org/getit/releases/2.7.3/</a>.</p><p>We will develop our application on the Windows 7 platform. However, since Tkinter is truly cross-platform, you can follow along on Mac or Linux distributions without any modifications to our code.</p><p>After the installation, open the IDLE window and type:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt;from Tkinter import *</strong>
</pre></div><p>If you have installed Python 2.7, this shell command should execute without any errors.</p><p>If there are no error messages the Tkinter module is installed in your Python distribution. When working with examples from this book, we do not support any other Python version except<a id="id9" class="indexterm"/> for Python 2.7, which comes bundled with Tkinter Tcl/Tk Version 8.5.</p><p>To test if you have the correct Tkinter version on your Python installation, type the following commands in your IDLE or interactive shell:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; import Tkinter</strong>
<strong>&gt;&gt;&gt;Tkinter._test()</strong>
</pre></div><p>This should pop up a window where the first line in the window reads <strong>This is Tcl/Tk version 8.5</strong>. Make sure it is not 8.4 or any earlier version, as Version 8.5 is a vast improvement over its previous versions.</p><p>You are ready to code your Tkinter GUI applications if your version test confirms it as Tcl/Tk version 8.5. Let's get started!</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>The root window – your drawing board</h1></div></div></div><p>GUI programming is an art, and like all art, you need a drawing board to capture your ideas. The drawing board you will use is called the <strong>root window</strong>. <a id="id10" class="indexterm"/>Our first goal is to get the root window ready.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Engage Thrusters</h2></div></div></div><p>The following <a id="id11" class="indexterm"/>screenshot depicts the root window we are going to create:</p><div><img src="img/7941_01_02.jpg" alt="Engage Thrusters"/></div><p>Drawing the root window is easy. You just need the following three lines of code:</p><div><pre class="programlisting">from Tkinter import * 
<strong>root = Tk()</strong>
<strong>root.mainloop()</strong>
</pre></div><p>Save this<a id="id12" class="indexterm"/> with the <code class="literal">.py</code> file extension or check out the code <code class="literal">1.01.py</code>. Open it in the IDLE window and run the program from the <strong>Run</strong> menu (<em>F5</em> in IDLE). Running this program should generate a blank root window as shown in the preceding screenshot. This window is furnished with functional minimize, maximize, and close buttons, and a blank <a id="id13" class="indexterm"/>frame.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>The description of the code is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first line imports all (<code class="literal">*</code>) classes, attributes, and methods of Tkinter into the current workspace.</li><li class="listitem" style="list-style-type: disc">The second line creates an instance of the class <code class="literal">Tkinter.Tk</code>. This creates what is called the "root" window that you see in the screenshot provided. By convention, the root window in Tkinter is usually called "root", but you are free to call it by any other name.</li><li class="listitem" style="list-style-type: disc">The third line executes the <code class="literal">mainloop</code> (that is, the event loop) method of the <code class="literal">root</code> object. The <code class="literal">mainloop</code> method<a id="id14" class="indexterm"/> is what keeps the root window visible. If you remove the third line, the window created in line 2 will disappear immediately as the script stops running. This will happen so fast that you will not even see the window appearing on your screen. Keeping the mainloop running also lets you keep the program running until you press the close button, which exits the main loop.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>Congratulations! You have completed your first objective, which was to draw the root window. You have now prepared your drawing canvas (root window). Now get ready to paint it with your imagination!</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Commit the<a id="id15" class="indexterm"/> three lines of code (shown in <em>code 1.01.py</em>) to memory. These three lines generate your root window, which will accommodate all other graphical components. These lines constitute the skeleton of any GUI application that you will develop in Tkinter. All code that will make your GUI application functional will go between line 2 (new object creation) and line 3 (<code class="literal">mainloop</code>) of this code.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Classified Intel</h2></div></div></div><p>This section describes the different styles of importing Tkinter modules.</p><p>In the preceding example, we imported Tkinter using the following command:</p><div><pre class="programlisting">
<strong>from Tkinter import *</strong>
</pre></div><p>This method of import eases the handling of methods defined in the module. That is to say, you can simply access the methods directly. Generally, it is considered a bad practice to import all (<code class="literal">*</code>) methods of a module like we did here. This is because if you import all methods from some other module with a common method name, it would lead to the overwriting of methods.</p><p>There are several ways to import Tkinter in which this overlapping can be avoided, a common one being:</p><div><pre class="programlisting">
<strong>import Tkinter</strong>
</pre></div><p>This style of importing does not pollute the namespace with a list of all methods defined within Tkinter. However, every method within Tkinter will now have to be called using the format <code class="literal">Tkinter.methodA</code> instead of directly calling the method.</p><p>Another commonly used import style is as follows:</p><div><pre class="programlisting">
<strong>import Tkinter as Tk </strong>
</pre></div><p>Here too, you do not pollute the current namespace with all Tkinter methods and now you can access methods such as <code class="literal">Tk.methodA</code>. "Tk" is a convenient, easy-to-type alias commonly used by many developers for importing Tkinter.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>The big picture</h3></div></div></div><p>As a GUI programmer, you will generally be responsible for deciding three aspects of your program:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>What components should appear on screen?</strong>: This involves choosing the components that <a id="id16" class="indexterm"/>make the user interface. Typical components include things such as buttons, entry fields, checkboxes, radio buttons, scroll bars, and the like. In Tkinter, the components that you add to your GUI are called widgets.</li><li class="listitem" style="list-style-type: disc"><strong>Where should the components go?</strong>: This involves deciding the positioning or placement of each component in the overall design structure. This includes decisions to be made on issues of positioning and the structural layout of various components. In Tkinter, this is referred to as <strong>geometry management</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>How do components interact and behave?</strong>: This involves adding functionality to each component. Each component or widget does some work. For example, a button, when clicked on, does something in response; a scrollbar handles scrolling; and checkboxes and radio buttons enable the user to make some choices. In Tkinter, the functionality of various widgets is managed by <code class="literal">command</code> binding or <code class="literal">event</code> binding using <strong>callback functions</strong>.<a id="id17" class="indexterm"/></li></ul></div><p>Let us delve deeper into each of these three components in the context of Tkinter.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Widgets – building blocks for your GUI program</h1></div></div></div><p>Now that we have our Toplevel window ready, it is time to think over the question, what components should appear in the window? In Tkinter jargon, these components are called <strong>widgets</strong>
<a id="id18" class="indexterm"/>.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Engage Thrusters</h2></div></div></div><p>The syntax<a id="id19" class="indexterm"/> for adding a widget is as follows:</p><div><pre class="programlisting">mywidget = Widget-name (its container window,**configuration options)</pre></div><p>In the <a id="id20" class="indexterm"/>following example (refer to the code <code class="literal">01.02.py</code>), we add two widgets, a label and a button, to the root frame. Notice how all widgets are added in between the skeleton code we defined in the first example.</p><div><pre class="programlisting">from Tkinter import *
root = Tk() 
mylabel = Label(root,text="I am a label widget")    
mybutton = Button(root,text="I am a button")       
mylabel<strong>.pack()</strong>
mybutton<strong>.pack()</strong>
root.mainloop()</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This code adds a new instance, <code class="literal">mylabel</code>, for the<a id="id21" class="indexterm"/> <strong>Label</strong> widget. The first parameter defines <code class="literal">root</code> as its parent or container. The second parameter configures its text option as <code class="literal">"I am a label widget"</code>.</li><li class="listitem" style="list-style-type: disc">We similarly define an instance of a <a id="id22" class="indexterm"/><strong>Button</strong> widget. This is also bound to the root window as its parent.</li><li class="listitem" style="list-style-type: disc">We use the <code class="literal">pack()</code> method, which is essentially required to position the label and button widgets within the window. We will discuss the <code class="literal">pack()</code> method and several other related concepts under the Geometry management task. However, you must note that some sort of geometry specification is essential for the widgets to display within the Toplevel window.</li><li class="listitem" style="list-style-type: disc">Running this code will generate a window as shown in the following screenshot. It will have a custom label and a custom button:<div><img src="img/7941_01_03.jpg" alt="Engage Thrusters"/></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>In this iteration, we have learned the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What widgets are.</li><li class="listitem" style="list-style-type: disc">How widgets are instantiated and displayed within a container window frame.</li><li class="listitem" style="list-style-type: disc">How to set options for the widgets at the time of instantiation.</li><li class="listitem" style="list-style-type: disc">The importance of specifying a geometry option such as <code class="literal">pack()</code> to display a widget. We will discuss more about this in a subsequent task.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Classified Intel</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All widgets are actually objects derived from their respective <strong>widget class</strong><a id="id23" class="indexterm"/>. So, a statement such as <code class="literal">mybutton = Button(myContainer)</code>, actually creates the button instance from the <code class="literal">Button</code> class.</li><li class="listitem" style="list-style-type: disc">Each widget <a id="id24" class="indexterm"/>has a set of options that decides its behavior and appearance. This includes attributes such as text labels, colors, font size, and many more. For example, the Button widget has attributes to manage its label, control its size, change its foreground and background colors, change the size of the border, and so on.</li><li class="listitem" style="list-style-type: disc">To set these attributes, you can set the values directly at the time of creation of the widget as we have done in the preceding example. Alternatively, you can later set or change the options of the widget by using the <code class="literal">.config()</code> or <code class="literal">.configure()</code> method. Note that the <code class="literal">.config()</code> or <code class="literal">.configure()</code> method are interchangeable and provide the same functionality.</li></ul></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>You can also add the <code class="literal">pack()</code> method<a id="id25" class="indexterm"/> on the same line in which you create a new instance of the widget. For example, consider the following code:</p><div><pre class="programlisting">mylabel = Label(root,text="I am a label widget")
mylabel.pack()</pre></div><p>If you are instantiating the widget directly, you can write both the lines together as follows:</p><div><pre class="programlisting">Label(root,text="I am a label widget").pack()</pre></div><p>You may keep a reference to the widget created (as in the first example, <code class="literal">mylabel</code>) or you can create a widget without keeping any reference to it (as in the second example).</p><p>You should ideally keep the reference if the widget content is likely to be modified by some action at a later stage in the program. If the widget state is to remain static after its <a id="id26" class="indexterm"/>creation, you need not keep a reference for the widget.</p><p>Also, note that calls to <code class="literal">pack()</code> (or other geometry managers) always returns <code class="literal">None</code>. So, consider you create a widget keeping a reference to it and add the geometry manager (say <code class="literal">pack()</code>) on the same line as shown:</p><div><pre class="programlisting">mylabel = Label(…).pack()</pre></div><p>In this case, you are actually not creating a reference to the widget but instead creating a <code class="literal">None</code> type object for the variable <code class="literal">mylabel</code>.</p><p>So, when you later try to modify the widget through the reference, you get an error as you are actually trying to work on a <code class="literal">None</code> type object.</p><p>This is one of the most common errors committed by beginners.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Getting to know core Tkinter widgets</h1></div></div></div><p>In this iteration, we <a id="id27" class="indexterm"/>will get to know all core Tkinter widgets. We have already seen two of them in the previous example—the Label and Button widgets. Let's now see all other core Tkinter widgets.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Prepare for Lift Off</h2></div></div></div><p>Tkinter includes 21 core widgets. These are as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>Toplevel widget<a id="id28" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Label widget<a id="id29" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Button widget<a id="id30" class="indexterm"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Canvas widget<a id="id31" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Checkbutton widget<a id="id32" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Entry widget<a id="id33" class="indexterm"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Frame widget<a id="id34" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>LabelFrame widget<a id="id35" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Listbox widget<a id="id36" class="indexterm"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Menu widget<a id="id37" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Menubutton widget<a id="id38" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Message widget<a id="id39" class="indexterm"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>OptionMenu widget<a id="id40" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>PanedWindow widget<a id="id41" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Radiobutton widget<a id="id42" class="indexterm"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Scale widget<a id="id43" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Scrollbar widget<a id="id44" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Spinbox widget<a id="id45" class="indexterm"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Text widget<a id="id46" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Bitmap Class widget<a id="id47" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Image Class widget<a id="id48" class="indexterm"/>
</p>
</td></tr></tbody></table></div><p>Let's write a program to include these widgets on our root window.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Engage Thrusters</h2></div></div></div><p>The format for <a id="id49" class="indexterm"/>adding widgets is the same as we discussed in the previous task. To give you a flavor, here's some sample code for adding some common widgets:</p><div><pre class="programlisting">
<strong>Label(parent, text=" Enter your Password:")    </strong>
<strong>Button(parent, text="Search")</strong>
<strong>Checkbutton(parent, text='RememberMe', variable=v, value=True)</strong>
<strong>Entry(parent, width=30)</strong>
<strong>Radiobutton(parent, text=Male, variable=v, value=1)</strong>
<strong>Radiobutton(parent, text=Female, variable=v, value=2)</strong>
<strong>OptionMenu(parent, var, "Select Country", "USA", "UK", "India", Others")</strong>
<strong>Scrollbar(parent, orient=VERTICAL, command=mytext.yview)</strong>
</pre></div><p>Can you spot the pattern common to each widget? Can you spot the differences?</p><p>As a reminder, the syntax for adding a widget is:</p><div><pre class="programlisting">
<strong>Widget-name (its container window, *configuration options)</strong>
</pre></div><div><div><h3 class="title"><a id="tip0200"/>Tip</h3><p>The method for creating all the previously mentioned widgets is the same. Most of the configuration options will also be similar. However, a few configuration options vary from widget to widget.</p><p>For example, the Button and Label widgets will have an option to configure their text, but scrollbars do not have a text-configuration option.</p></div></div><p>Using the same pattern, let's now add all the 21 core Tkinter <a id="id50" class="indexterm"/>widgets into a dummy application (code <code class="literal">01.03.py</code>).</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Do not be intimidated by the size of the program. Instead look for a common pattern that is used to initialize and display all the widgets. To reiterate, the syntax for adding a widget is:</p><div><pre class="programlisting">mywidget = Widget-name (container, all widget-options)</pre></div><p>Notice how the configuration options for each widget differ slightly from each other depending on the type of widget being initialized.</p></div></div><p>Refer to the code <code class="literal">1.03.py</code> for a demo of all Tkinter widgets. A summarized code description for <code class="literal">1.03.py</code> is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We create a Toplevel window and create a main loop as seen in the earlier examples.</li><li class="listitem" style="list-style-type: disc">We add a Frame widget that we named <code class="literal">menubar</code>. Note that Frame widgets are just holder widgets that hold other widgets. Frame widgets are great for grouping widgets together. The syntax for adding a frame is the same as that of all other widgets:<div><pre class="programlisting">myframe = Frame(root)
myframe.pack()</pre></div></li><li class="listitem" style="list-style-type: disc">Keeping the <code class="literal">menubar</code> frame as the container, we add two widgets to it, the Menubutton and Menu widgets.</li><li class="listitem" style="list-style-type: disc">We create another frame and name it <code class="literal">myframe1</code>. Keeping <code class="literal">myframe1</code> as the container/parent widget, we add seven widgets to it:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Label, Entry, Button, Checkbutton, Radiobutton, OptionMenu, and Bitmap Class widgets.</li></ul></div></li><li class="listitem" style="list-style-type: disc">We then <a id="id51" class="indexterm"/>proceed to create <code class="literal">myframe2</code>, another Frame widget. We add six more widgets to it:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Image Class, Listbox, Spinbox, Scale, LabelFrame, and Message widgets.</li></ul></div></li><li class="listitem" style="list-style-type: disc">We then create <code class="literal">myframe3</code>, another Frame widget. We add two more widgets to it, the Text and Scrollbar widgets.</li><li class="listitem" style="list-style-type: disc">Finally we create the last frame, <code class="literal">myframe4</code>, another Frame widget. We add two more widgets to it, the Canvas and PanedWindow widgets.</li></ul></div><p>All these widgets constitute the 21 core widgets of Tkinter.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Read through the code explanation, and find the corresponding piece of code in the example code <code class="literal">01.03.py</code>. Look at how each widget is created. Try to identify each widget's class name as used in Tkinter. Look what remains the same in all widgets, and what changes between one widget and another?</p><p>A few minutes spent reading and understanding the code in <code class="literal">1.03.py</code> will really help you appreciate the simplicity and overall structure of a Tkinter program.</p><p>Finally, note that we have used <code class="literal">.pack()</code> on each widget to display it inside its container frame. We discuss <code class="literal">.pack()</code> in the next task. However, for now just note that we have used something called <code class="literal">pack()</code>, without which the widgets would not have displayed at all.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>You have reached a major milestone in your GUI programming effort.</p><p>You now know all the 21 core widgets of Tkinter. You can identify them by their class names, and you can create them on a root frame or on a subframe within the root. You now know how to configure options of widgets.</p><p>With this you have now seen the first and the most important building block of a Tkinter program. You have mastered Tkinter widgets.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Classified Intel</h2></div></div></div><p>Widget options can be set at instantiation time as we have done in the examples so far. Alternatively, the options can be configured after instantiation using the following syntax:</p><div><pre class="programlisting">widget.configure(**options)</pre></div><p>This is a very handy tool that lets you change widget options dynamically after the widget has been created. We will be using this very often in all our projects.</p><p>For common widget configuration options, refer to the <em>Options common to widgets</em> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <em>Quick Reference Sheets</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Geometry management</h1></div></div></div><p>Having seen all the core Tkinter widgets, let us now turn our attention to the second component of GUI programming—the question of where to place those widgets.</p><p>This is taken care of by the geometry manager options of Tkinter. This component of GUI programming involves<a id="id52" class="indexterm"/> deciding the position of the widget, overall layout, and relative placement of various widgets on the screen.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Prepare for Lift Off</h2></div></div></div><p>Recall that we used the <code class="literal">pack()</code> method for adding widgets to the dummy application we developed in the previous section. <code class="literal">pack()</code> is an example of geometry management in Tkinter.</p><p>
<code class="literal">pack()</code> is not the only way you can manage the geometry in your interface. In fact, there are three geometry managers in Tkinter that let you specify the position of widgets inside a Toplevel or parent window.</p><p>The geometry managers are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pack</code>: This is the one we<a id="id53" class="indexterm"/> have used so far. Simple to <a id="id54" class="indexterm"/>use for simpler layouts but may get very complex for slightly complex layouts.</li><li class="listitem" style="list-style-type: disc"><code class="literal">grid</code>: This is the most<a id="id55" class="indexterm"/> commonly used geometry <a id="id56" class="indexterm"/>manager that provides a table-like layout of management features for easy layout management.</li><li class="listitem" style="list-style-type: disc"><code class="literal">place</code>: This is least popular, <a id="id57" class="indexterm"/>but provides the best <a id="id58" class="indexterm"/>control for absolute positioning of widgets.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Engage Thrusters</h2></div></div></div><p>Let us now see examples of all three geometry managers in action.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>The pack geometry manager</h3></div></div></div><p>The <code class="literal">pack</code> geometry <a id="id59" class="indexterm"/>derives its name from the fact that it literally packs widgets on a first-come-first-serve basis in the space available in the master frame in which widgets are pushed.</p><p>The <code class="literal">pack</code> geometry manager fits "slave widgets" into "parent spaces". When packing the slave <a id="id60" class="indexterm"/>widgets, the <code class="literal">pack</code> manager distinguishes between three kinds of spaces:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The unclaimed space</li><li class="listitem" style="list-style-type: disc">The claimed but unused space</li><li class="listitem" style="list-style-type: disc">The claimed and used space</li></ul></div><p>The most commonly<a id="id61" class="indexterm"/> used options in <code class="literal">pack()</code> include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">side</code>: <code class="literal">LEFT</code>, <code class="literal">TOP</code>, <code class="literal">RIGHT</code>, and <code class="literal">BOTTOM</code> (these decide the alignment of the widget)</li><li class="listitem" style="list-style-type: disc"><code class="literal">fill</code>: <code class="literal">X</code>, <code class="literal">Y</code>, <code class="literal">BOTH</code>, and <code class="literal">NONE</code> (these decide whether the widget can grow in size)</li><li class="listitem" style="list-style-type: disc"><code class="literal">expand</code> :<code class="literal">1</code>/<code class="literal">0</code> or <code class="literal">Yes</code>/<code class="literal">No</code> (corresponding to values respectively)</li><li class="listitem" style="list-style-type: disc"><code class="literal">anchor</code>: <code class="literal">NW</code>, <code class="literal">N</code>, <code class="literal">NE</code>, <code class="literal">E</code>, <code class="literal">SE</code>, <code class="literal">S</code>, <code class="literal">SW</code>, <code class="literal">W</code>, and <code class="literal">CENTER</code> (corresponding to the cardinal directions)</li><li class="listitem" style="list-style-type: disc">Internal padding (<code class="literal">ipadx</code> and <code class="literal">ipady</code>) and external padding (<code class="literal">padx</code> and <code class="literal">pady</code>), which all defaulted to a value of zero</li></ul></div><p>Let's take a look at some <a id="id62" class="indexterm"/>demo code that illustrates some of the <code class="literal">pack</code> features. Here's the code snippet (code <code class="literal">1.04.py</code>) that generates a GUI like the following screenshot:</p><div><img src="img/7941_01_04.jpg" alt="The pack geometry manager"/></div><div><pre class="programlisting">
<strong>from Tkinter import *</strong>
<strong>root = Tk()</strong>
<strong>Button(root, text="A").pack(side=LEFT, expand=YES, fill=Y)</strong>
<strong>Button(root, text="B").pack(side=TOP, expand=YES, fill=BOTH)</strong>
<strong>Button(root, text="C").pack(side=RIGHT, expand=YES, fill=NONE, anchor=NE)</strong>
<strong>Button(root, text="D").pack(side=LEFT, expand=NO, fill=Y)</strong>
<strong>Button(root, text="E").pack(side=TOP, expand=NO, fill=BOTH)</strong>
<strong>Button(root, text="F").pack(side=RIGHT, expand=NO, fill=NONE)</strong>
<strong>Button(root, text="G").pack(side=BOTTOM, expand=YES, fill=Y)</strong>
<strong>Button(root, text="H").pack(side=TOP, expand=NO, fill=BOTH)</strong>
<strong>Button(root, text="I").pack(side=RIGHT, expand=NO)</strong>
<strong>Button(root, text="J").pack(anchor=SE)</strong>
<strong>root.mainloop()</strong>
</pre></div><p>The description <a id="id63" class="indexterm"/>of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When you insert button <strong>A</strong> in the <code class="literal">root</code> frame, it captures the left-most area of the frame, it expands, and fills the <em>Y</em> dimension. Because expand and fill options are specified in affirmative, it claims all the area it wants and fills the <em>Y</em> dimension. If you increase the size of the root window pulling it down, you will notice that the button <strong>A</strong> expands in the downward direction (along the <em>Y</em> coordinate) but a side-wise increase in the window does not result in a horizontal increase in the size of button <strong>A</strong>.</li><li class="listitem" style="list-style-type: disc">When you insert the next button, <strong>B</strong>, into the root window, it picks up space from the remaining area but aligns itself to <code class="literal">TOP</code>, expand-fills the available area, and fills both <em>X</em> and <em>Y</em> coordinates of the available space.</li><li class="listitem" style="list-style-type: disc">The third button, <strong>C</strong>, adjusts to the right-hand side of the remaining space. But because fill is specified as <code class="literal">NONE</code>, it takes up only that much space as is required to accommodate the text inside the button. If you expand the root window, the button <strong>C</strong> will not change its size.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">anchor</code> attribute used in some lines provides a means to position a widget relative to a reference point. If the <code class="literal">anchor</code> attribute is not specified, the <code class="literal">pack</code> manager places the widget in the center of the available space or the <strong>packing box</strong><a id="id64" class="indexterm"/>. Other allowed options include the four cardinal directions (<code class="literal">N</code>, <code class="literal">S</code>, <code class="literal">E</code>, and <code class="literal">W</code>) and a combination of any two directions. Therefore, valid values for the <code class="literal">anchor</code> attribute are: <code class="literal">CENTER</code> (default), <code class="literal">N</code>, <code class="literal">S</code>, <code class="literal">E</code>, <code class="literal">W</code>, <code class="literal">NW</code>, <code class="literal">NE</code>, <code class="literal">SW</code>, and <code class="literal">SE</code>.</li></ul></div><p>The description for the rest of the lines is left as an exercise for you to explore. The best way to study this piece of code would be to comment out all lines of code and introduce each successive button one after another. At each step, try to resize the window to see the effect it has on various buttons.</p><div><img src="img/7941_01_05.jpg" alt="The pack geometry manager"/></div><p>We will <a id="id65" class="indexterm"/>use the <code class="literal">pack</code> geometry manager in some of our projects, so it would be a worthwhile exercise to get acquainted with <code class="literal">pack</code> and its options.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>Note that the value for most of the Tkinter geometry manager attributes can either be specified in capital letters without quotes (like <code class="literal">side=TOP</code>, <code class="literal">anchor=SE</code>) or in small letters but within quotes (like <code class="literal">side='top'</code>, <code class="literal">anchor='se'</code>).</p></div></div><p>For a complete <code class="literal">pack</code> manager reference refer to the <em>The pack manager</em> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <em>Quick Reference Sheets</em>.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>
<strong>Where should you use the pack() geometry manager?</strong>
</p><p>Using the <code class="literal">pack</code> manager is somewhat complicated compared to the <code class="literal">grid</code> method that we will discuss next, but it is a great choice in situations such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Having a widget fill the complete container frame</li><li class="listitem" style="list-style-type: disc">Placing several widgets on top of each other or in a side by side position (as in the previous screenshot). See code <code class="literal">1.05.py</code>.</li></ul></div></div></div><p>While you can create complicated layouts by nesting widgets in multiple frames, you can find the <code class="literal">grid</code> geometry manager more suitable for most of the complex layouts.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>The grid geometry manager</h3></div></div></div><p>The <code class="literal">grid</code> geometry manager<a id="id66" class="indexterm"/> is most easy to understand and, perhaps, the most useful geometry manager in Tkinter. The central idea of the <code class="literal">grid</code> geometry <a id="id67" class="indexterm"/>manager is to divide the container frame into a two-dimensional table divided into a number of rows and columns. Each cell in the table can then be targeted to hold a widget. In this context, a <strong>cell</strong>
<a id="id68" class="indexterm"/> is an intersection of imaginary rows and columns. Note that in the <code class="literal">grid</code> method, each cell can hold only one widget. However, widgets can be made to span multiple cells.</p><p>Within each cell <a id="id69" class="indexterm"/>you can further align the position of the widget using the <code class="literal">STICKY</code> option. The <code class="literal">sticky</code> option decides how the widget is expanded, if its container cell is larger than the size of the widget it contains. The <code class="literal">sticky</code> option can be specified using one or more of the <code class="literal">N</code>, <code class="literal">S</code>, <code class="literal">E</code>, and <code class="literal">W</code>, or <code class="literal">NW</code>, <code class="literal">NE</code>, <code class="literal">SW</code>, and <code class="literal">SE</code> options.</p><p>Not specifying stickiness defaults to stickiness to the center of the widget in the cell.</p><p>Let us now see a demo code that illustrates some of the features of the <code class="literal">grid</code> geometry manager. The code in <code class="literal">1.06.py</code> generates a GUI-like figure as shown:</p><div><img src="img/7941_01_06.jpg" alt="The grid geometry manager"/></div><div><pre class="programlisting">
<strong>from Tkinter import *</strong>
<strong>root = Tk()</strong>
<strong>Label(root, text="Username").grid(row=0, sticky=W)</strong>
<strong>Label(root, text="Password").grid(row=1, sticky=W)</strong>
<strong>Entry(root).grid(row=0, column=1, sticky=E)</strong>
<strong>Entry(root).grid(row=1, column=1, sticky=E)</strong>
<strong>Button(root, text="Login").grid(row=2, column=1, sticky=E)</strong>
<strong>root.mainloop()</strong>
</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Take a look at the grid position defined in terms of rows and column positions for an imaginary grid table spanning the entire frame. See how the use of <code class="literal">sticky=W</code> on both labels makes them stick to the west or left-hand side, resulting in a clean layout.</li><li class="listitem" style="list-style-type: disc">The width of each column (or height of each row) is automatically decided by the <a id="id70" class="indexterm"/>height or width of the widgets contained in the cell. Therefore, you need not worry about specifying the row or column width as equal. You may specify the width for widgets, if you need that extra bit of control.</li><li class="listitem" style="list-style-type: disc">You can<a id="id71" class="indexterm"/> use the argument <code class="literal">sticky=N+S+E+W</code> to make the widget expandable to fill the entire cell of the grid.</li></ul></div><p>In a more complex scenario, your widgets may span across multiple cells in the grid. To enable a grid to span multiple cells, the <code class="literal">grid</code> method offers very handy options such as <code class="literal">rowspan</code> and <code class="literal">columnspan</code>.</p><p>Furthermore, you may often need to provide some padding between cells in the grid. The <code class="literal">grid</code> manager provides <code class="literal">padx</code> and <code class="literal">pady</code> options to provide padding to place around the widget in a cell.</p><p>Similarly, there are <code class="literal">ipadx</code> and <code class="literal">ipady</code> options for internal padding. The default value of external and internal padding is <code class="literal">0</code>.</p><p>Let us see an example of the <code class="literal">grid</code> manager, where we use most of the common arguments to the <code class="literal">grid</code> method such as <code class="literal">row</code>, <code class="literal">column</code>, <code class="literal">padx</code>, <code class="literal">pady</code>, <code class="literal">rowspan</code>, and <code class="literal">columnspan</code> in action.</p><p>The code <code class="literal">1.08.py</code> is a demonstration of <a id="id72" class="indexterm"/>
<code class="literal">grid()</code> geometry manager options:</p><div><pre class="programlisting">
<strong>from Tkinter import *</strong>
<strong>top = Tk()</strong>
<strong>top.title('Find &amp; Replace')</strong>

<strong>Label(top,text="Find:").grid(row=0, column=0, sticky='e')</strong>
<strong>Entry(top).grid(row=0,column=1,padx=2,pady=2,sticky='we',columnspan=9)</strong>

<strong>Label(top, text="Replace:").grid(row=1, column=0, sticky='e')</strong>
<strong>Entry(top).grid(row=1,column=1,padx=2,pady=2,sticky='we',columnspan=9)</strong>

<strong>Button(top, text="Find").grid(row=0, column=10, sticky='ew', padx=2, pady=2)</strong>
<strong>Button(top, text="Find All").grid(row=1, column=10, sticky='ew', padx=2)</strong>
<strong>Button(top, text="Replace").grid(row=2, column=10, sticky='ew', padx=2)</strong>
<strong>Button(top, text="Replace All").grid(row=3, column=10, sticky='ew', padx=2)</strong>

<strong>Checkbutton(top, text='Match whole word only').grid(row =2, column=1, columnspan=4, sticky='w')</strong>
<strong>Checkbutton(top, text='Match Case').grid(row =3, column=1, columnspan=4, sticky='w')</strong>
<strong>Checkbutton(top, text='Wrap around').grid(row =4, column=1, columnspan=4, sticky='w')</strong>

<strong>Label(top, text="Direction:").grid(row=2, column=6, sticky='w')</strong>
<strong>Radiobutton(top, text='Up', value=1).grid(row=3, column=6, columnspan=6, sticky='w')</strong>
<strong>Radiobutton(top, text='Down', value=2).grid(row=3, column=7, columnspan=2, sticky='e')</strong>

<strong>top.mainloop()</strong>
</pre></div><p>Notice how just<a id="id73" class="indexterm"/> 14 lines of core <code class="literal">grid</code> manager<a id="id74" class="indexterm"/> code generates a complex layout such as the one shown in the following screenshot. In contrast, developing this with the <code class="literal">pack</code> manager would have been much more tedious:</p><div><img src="img/7941_01_07.jpg" alt="The grid geometry manager"/></div><p>Another <code class="literal">grid</code> option that you can sometimes use is the <code class="literal">widget.grid_forget()</code> method. This method can be used to hide the widget from the screen. When you use this option, the widget exists in its <a id="id75" class="indexterm"/>place but becomes invisible. The hidden widget may be made visible again but any <code class="literal">grid</code> options that you had originally assigned to the widget will be lost.</p><p>Similarly, <a id="id76" class="indexterm"/>there is a <code class="literal">widget.grid_remove()</code> method that removes the widget, except that in this case when you make the widget visible again, all its <code class="literal">grid</code> options will be restored.</p><p>For a complete <code class="literal">grid()</code> reference, refer to the the <em>The grid manager</em> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <em>Quick Reference Sheets</em>.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>
<strong>Where should you use the grid() geometry manager?</strong>
</p><p>The <code class="literal">grid</code> manager is a great tool for developing complex layouts. Complex structures can be easily achieved by breaking the container widget into grids of rows and columns and then placing the widgets in grids where they are wanted.</p><p>It is also commonly used in developing different kinds of dialog boxes.</p></div></div><p>Now we will delve into configuring grid column and row sizes.</p><p>Different widgets have different heights and widths. So when you specify the position of a widget in terms of rows and columns, the cell automatically expands to accommodate the widget.</p><p>Normally the height of all grid rows is automatically adjusted to be the height of its tallest cell. Similarly, <a id="id77" class="indexterm"/>the width of all grid columns is adjusted to be equal to the width of the widest widget cell.</p><p>If you then want a smaller widget to fill a larger cell or to stay at any one side of the cell, you use the <code class="literal">sticky</code> attribute<a id="id78" class="indexterm"/> on the widget to control that.</p><p>You can, however, override this automatic sizing of columns and rows using the following code:</p><div><pre class="programlisting">w.columnconfigure(n, option=value, ...)  AND 
w.rowconfigure(N, option=value, ...)</pre></div><p>Use these to configure the options for a given widget, <code class="literal">w</code>, in the column, <code class="literal">n</code>, specifying values for the options, <code class="literal">minsize</code>, <code class="literal">pad</code>, and <code class="literal">weight</code>.</p><p>The options available here are as mentioned in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Options</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">minsize</code>
<a id="id79" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The minimum size of column or row in pixels. If there is no widget in the given column or row, the cell does not appear despite this <code class="literal">minsize</code> specification.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">pad</code>
<a id="id80" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>External padding in pixels that will be added to the specified column or row over the size of largest cell.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">weight</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This specifies<a id="id81" class="indexterm"/> the relative weight of the row or column, then distributes the extra space. This enables making the row or column stretchable.</p>
<p>For example, the following code distributes two-fifths of the extra space to the first column and three-fifths to the second column:</p>
<div><pre class="programlisting">w.columnconfigure(0, weight=2)
w.columnconfigure(1, weight=3)</pre></div>
 </td></tr></tbody></table></div><p>The <code class="literal">columnconfigure()</code> and <code class="literal">rowconfigure()</code> methods are often used to implement dynamic resizing of widgets, especially on resizing the root window.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>You cannot use <code class="literal">grid</code> and <code class="literal">pack</code> methods together in the same container window. If you try doing that, your program will enter into an infinite negotiation loop.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec04"/>The place geometry manager</h3></div></div></div><p>The <code class="literal">place</code> geometry manager is the most rarely used geometry manager in Tkinter. Nevertheless, it has its<a id="id82" class="indexterm"/> uses in that it lets you precisely position widgets within its parent frame<a id="id83" class="indexterm"/> using the <em>X</em>-<em>Y</em> coordinate system.</p><p>The <code class="literal">place</code> manager can be assessed using the <code class="literal">place()</code> method on all standard widgets.</p><p>The important options for <code class="literal">place</code> geometry include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Absolute positioning (specified in terms of <code class="literal">x=N</code> or <code class="literal">y=N</code>)</li><li class="listitem" style="list-style-type: disc">Relative positioning (key options include <code class="literal">relx</code>, <code class="literal">rely</code>, <code class="literal">relwidth</code>, and <code class="literal">relheight</code>)</li></ul></div><p>Other options commonly used with <code class="literal">place()</code> include <code class="literal">width</code> and <code class="literal">anchor</code> (the default is <code class="literal">NW</code>). Refer to the code in <code class="literal">1.09.py</code> for a demonstration of the common <code class="literal">place</code> option:</p><div><pre class="programlisting">from Tkinter import *
root = Tk()
# Absolute positioning
Button(root,text="Absolute Placement").place(x=20, y=10)
# Relative positioning
Button(root, text="Relative").place(relx=0.8, rely=0.2, relwidth=0.5, width=10, anchor = NE)
root.mainloop()</pre></div><p>You may not see much of a difference between absolute and relative positions simply by looking at the code or the window frame. If, however, you try resizing the window, you will notice that the button placed absolutely does not change its coordinates, while the relative button changes its coordinates and size to fit the new size of the root window.</p><div><img src="img/7941_01_08.jpg" alt="The place geometry manager"/></div><p>For a<a id="id84" class="indexterm"/> complete <code class="literal">place()</code> reference, check out the <em>The place manager</em> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <em>Quick Reference Sheets</em>.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>
<strong>When should you use the place manager?</strong>
</p><p>The <code class="literal">place</code>
<a id="id85" class="indexterm"/> manager is useful in situations where you have to implement the custom geometry managers where the widget placement is decided by the end user.</p><p>While <code class="literal">pack()</code> and <code class="literal">grid()</code> managers cannot be used together in the same frame, the <code class="literal">place()</code> manager can be used with any other geometry manager within the same container frame.</p></div></div><p>The <code class="literal">place</code> manager is rarely used. This is because if you use it you have to worry about the exact coordinates. If say you make a minor change for one widget, it is very likely that you will have to change the <em>X</em>-<em>Y</em> values for other widgets as well, which can be very cumbersome.</p><p>We will not use the <code class="literal">place</code> manager in our projects. However, knowing that options for coordinate-based placement exist can be helpful in certain situations.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This concludes our discussion on geometry management in Tkinter.</p><p>In this section you implemented examples of <code class="literal">pack</code>, <code class="literal">grid</code>, and <code class="literal">place</code> geometry managers. You also understood the strength and weaknesses of each geometry manager.</p><p>You learned that <code class="literal">pack</code> is best for a simple side-wise or top-down widget placement. You also saw that the <code class="literal">grid</code> manager is best suited for handling complex layouts. You saw examples of the <code class="literal">place</code> <a id="id86" class="indexterm"/>geometry manager and the reasons why it is rarely used.</p><p>You should now be in a position to plan and execute different layouts for your programs using these<a id="id87" class="indexterm"/> geometry managers of Tkinter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Events and callbacks – adding life to programs</h1></div></div></div><p>Now that we have learned how to add widgets to our screen and how to position them where we want, let's turn our attention to the third component of GUI programming. This addresses the question of how to make the widgets functional.</p><p>Making the widgets functional involves making them responsive to events such as the pressing of buttons, the <a id="id88" class="indexterm"/>pressing keys on keyboards, mouse clicks, and the like. This requires associating callbacks to specific events.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Engage Thrusters</h2></div></div></div><p>Callbacks are normally <a id="id89" class="indexterm"/>associated with specific widget events using the <code class="literal">command</code> binding the rules, which is elaborated on in the following section.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Command binding</h3></div></div></div><p>The simplest way to add functionality to a button is called <a id="id90" class="indexterm"/>
<code class="literal">command</code> binding,<a id="id91" class="indexterm"/> whereby the callback function is mentioned in the form of <code class="literal">command = some_callback</code> in the widget option.</p><p>Take a look at the following sample code:</p><div><pre class="programlisting">def my_callback ():
  # do something
  Button(root,text="Click",command= my_callback) </pre></div><p>Note that <code class="literal">my_callback</code> is called without parentheses <code class="literal">()</code> from within the widget <code class="literal">command</code> option. This is because when the callback functions are set, it is necessary to pass a reference to a function rather than actually calling it.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Passing arguments to the callback</h3></div></div></div><p>If the callback does not take any argument, it can be handled with a simple function like the one we just used. <a id="id92" class="indexterm"/>However, if the callback needs to take some arguments, we can use the <code class="literal">lambda</code> function as shown in the following code snippet:</p><div><pre class="programlisting">def my_callback (somearg):
  #do something with argument
  Button(root,text="Click",command=lambda: my_callback ('some argument'))</pre></div><p>Python borrows syntax from a functional program called the <code class="literal">lambda</code> function. The <code class="literal">lambda</code> function lets you define a single-line, nameless function on the fly.</p><p>The format for using <code class="literal">lambda</code> is <code class="literal">lambda arg: #do something with arg in a single line</code>, for instance:</p><div><pre class="programlisting">lambda x: return x^2</pre></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Please note that the <code class="literal">command</code> option available with the Button widget is really an alternative function to ease programming the Button event. Many other widgets do not provide any equivalent <code class="literal">command</code> binding option.</p></div></div><p>The command button binds by default to the left mouse click and the Space bar. It does not bind to the Return key. Therefore, if you bind a button using the <code class="literal">command</code> function, it will react to the Space bar and not the Return key. This is counter-intuitive to many Windows users. What's worse is you cannot change this binding of the <code class="literal">command</code> function. The moral is that <code class="literal">command</code> binding, though a very handy tool, does not provide you the the independence to decide your own bindings.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Event binding</h3></div></div></div><p>Fortunately, Tkinter provides an alternative form <a id="id93" class="indexterm"/>of event binding mechanism called <code class="literal">bind()</code> to let you deal <a id="id94" class="indexterm"/>with different events. The standard syntax for binding an event is as follows:</p><div><pre class="programlisting">widget.bind(event, handler)</pre></div><p>When an event corresponding to the event description occurs in the widget, it calls the associated handle passing an instance of the event object as the argument, with the event details.</p><p>Let us look at an example of the <code class="literal">bind()</code> method (refer to the code file <code class="literal">1.10.py</code>):</p><div><pre class="programlisting">from Tkinter import *
root = Tk()
Label(root, text='Click at different\n locations in the frame below').pack()
<strong>def mycallback(event):</strong>
<strong>  print dir(event)                         </strong>
<strong>  print "you clicked at", event.x, event.y</strong>
myframe = Frame(root, bg='khaki', width=130, height=80)
<strong>myframe.bind("&lt;Button-1&gt;", mycallback)       </strong>
myframe.pack()
root.mainloop()</pre></div><p>The description<a id="id95" class="indexterm"/> of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We bind the Frame widget to the event, <code class="literal">&lt;Button-1&gt;</code>, which corresponds to left-click of the mouse. On the occurrence of this event, it calls the function <code class="literal">mycallback</code>, passing along an object instance as its argument.</li><li class="listitem" style="list-style-type: disc">We define the function <code class="literal">mycallback(event)</code>. Notice that it takes the event object generated by the event as the argument.</li><li class="listitem" style="list-style-type: disc">We inspect the event object using <code class="literal">dir(event)</code>, which returns a sorted list of attribute names for the event object passed to it. This prints the list: <div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">['__doc__', '__module__', 'char', 'delta', 'height', 'keycode', 'keysym', 'keysym_num', 'num', 'send_event', 'serial', 'state', 'time', 'type', 'widget', 'width', 'x', 'x_root', 'y', 'y_root']</code>.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Out of the attributes list generated by the object, we use two attributes, <code class="literal">event.x</code> and <code class="literal">event.y</code>, to print the coordinates of the point of click.</li></ul></div><p>When you run this code, it produces a window like the one shown. When you left-click anywhere in the frame, it outputs messages to the console. A sample message passed to the console is as follows:</p><div><img src="img/7941_01_09.jpg" alt="Event binding"/></div><div><pre class="programlisting">
<strong>['__doc__', '__module__', 'char', 'delta', 'height', 'keycode', 'keysym', 'keysym_num', 'num', 'send_event', 'serial', 'state', 'time', 'type', 'widget', 'width', 'x', 'x_root', 'y', 'y_root']</strong>
You clicked at 63 36.</pre></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Event pattern</h3></div></div></div><p>In the previous example, you saw how we used the event <code class="literal">&lt;Button-1&gt;</code> to denote the left-click of a mouse. This is a built-in pattern in Tkinter that maps it to the mouse's left-click event. Tkinter has an exhaustive mapping scheme that exactly<a id="id96" class="indexterm"/> identifies events such as this one.</p><p>Here are some examples to give you an idea of event patterns:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Event pattern</p>
</th><th style="text-align: left" valign="bottom">
<p>Associated Event</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;Button-1&gt;</code>
<a id="id97" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Left-click of the mouse button</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;KeyPress-B&gt;</code>
<a id="id98" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Keyboard press of the key <em>B</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;Alt-Control-KeyPress- KP_Delete&gt;</code>
<a id="id99" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Keyboard press of <em>Alt</em> + <em>Ctrl</em> + <em>Delete</em>
</p>
</td></tr></tbody></table></div><p>In general, the mapping pattern takes the following form:</p><div><pre class="programlisting">
<strong>&lt;[event modifier-]...event type [-event detail]&gt;</strong>
</pre></div><p>Typically an event pattern will comprise of:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>An event type</strong> (required): Some <a id="id100" class="indexterm"/>common event types include <code class="literal">Button</code>, <code class="literal">ButtonRelease</code>, <code class="literal">KeyRelease</code>, <code class="literal">Keypress</code>, <code class="literal">FocusIn</code>, <code class="literal">FocusOut</code>, <code class="literal">Leave</code> (mouse leaves the widget), <a id="id101" class="indexterm"/>and <code class="literal">MouseWheel</code>. For a complete list of event types, refer to the <em>The event types</em> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <em>Quick Reference Sheets</em>.</li><li class="listitem" style="list-style-type: disc"><strong>An event modifier</strong> (optional): Some common event modifiers include <code class="literal">Alt</code>, <code class="literal">Any</code> (used like in <code class="literal">&lt;Any-KeyPress&gt;</code>), <code class="literal">Control</code>, <code class="literal">Double</code> (used like in <code class="literal">&lt;Double-Button-1&gt;</code> to denote a double-click of the left mouse button), <code class="literal">Lock</code>, and <code class="literal">Shift</code>. For a complete list <a id="id102" class="indexterm"/>of event modifiers, refer to the <em>The event modifiers</em> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <em>Quick Reference Sheets</em>.</li><li class="listitem" style="list-style-type: disc"><strong>The event detail</strong> (optional): The mouse event detail is captured by number <code class="literal">1</code> for a left-click and number <a id="id103" class="indexterm"/><code class="literal">2</code> for a right-click. <a id="id104" class="indexterm"/>Similarly, each keyboard keypress is either represented by the key letter itself (say <em>B</em> in <code class="literal">&lt;KeyPress-B&gt;</code>) or using a key symbol abbreviated as <strong>keysym</strong>. For example, the up arrow key on the keyboard is represented by the <code class="literal">keysym</code> value of <code class="literal">KP_Up</code>. For a complete <code class="literal">keysym</code> mapping, refer to the <em>The event details</em> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <em>Quick Reference Sheets</em>.</li></ul></div><div><img src="img/7941_01_10.jpg" alt="Event pattern"/></div><p>Let's take a look at a practical example of the <code class="literal">event</code> binding on widgets. (See the code in <code class="literal">1.11.py</code> for the complete working example). The following is a modified snippet of code to give you a flavor of the commonly used the <code class="literal">event</code> bindings:</p><div><pre class="programlisting">
<strong>widget.bind("&lt;Button-1&gt;",callback)  #bind widget to left mouse click</strong>
<strong>widget.bind("&lt;Button-2&gt;", callback) # bind to right mouse click</strong>
<strong>widget.bind("&lt;Return&gt;", callback)# bind  to Return(Enter) Key </strong>
<strong>widget.bind("&lt;FocusIn&gt;", callback) #bind  to  Focus in Event</strong>
<strong>widget.bind("&lt;KeyPress-A&gt;", callback)# bind  to keypress A</strong>
<strong>widget.bind("&lt;KeyPress-Caps_Lock&gt;", callback)# bind to CapsLockkeysym</strong>
<strong>widget.bind("&lt;KeyPress-F1&gt;", callback)# bind widget to F1 keysym</strong>
<strong>widget.bind("&lt;KeyPress-KP_5&gt;", callback)# bind to keypad number 5</strong>
<strong>widget.bind('&lt;Motion&gt;', callback) # bind to motion over widget</strong>
<strong>widget.bind("&lt;Any-KeyPress&gt;", callback) # bind to any keypress</strong>
</pre></div><p>Rather than binding an event to a particular widget, you can also bind it to the Toplevel window. The syntax remains the same except that now you call it on the root instance of the root window like <code class="literal">root.bind()</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Levels of binding</h3></div></div></div><p>In the previous section, you saw how to bind an event<a id="id105" class="indexterm"/> to an instance of a widget. This can be called<a id="id106" class="indexterm"/> <strong>instance level binding</strong>.</p><p>However, there might be times when you need to bind events to the entire application. At other times you may want to bind the event to a particular class of widget. Tkinter provides different levels of binding options for this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>An application-level binding</strong>: Application-level bindings will let you use the same binding across all windows<a id="id107" class="indexterm"/> and widgets of the application, as long as any one window <a id="id108" class="indexterm"/>of the application is in focus.<p>The syntax for application-level bindings is:</p><div><pre class="programlisting">w.bind_all(event, callback)</pre></div><p>The typical usage pattern is as follows:</p><div><pre class="programlisting">root.bind_all('&lt;F1&gt;', show_help)</pre></div><p>An application-level binding here means that no matter what widget is under the current focus, a press of the <em>F1</em> key will always trigger the <code class="literal">show_help</code> callback as long as the application is under active focus.</p></li><li class="listitem" style="list-style-type: disc"><strong>A class-level binding</strong>: You can also bind events at a particular class level. This is normally <a id="id109" class="indexterm"/>used to set the same <a id="id110" class="indexterm"/>behavior of all instances of a particular widget class.<p>This syntax for class level binding is as follows:</p><div><pre class="programlisting">w.bind_class(className, event, callback)</pre></div><p>The typical<a id="id111" class="indexterm"/> usage pattern is as follows:</p><div><pre class="programlisting">myentry.bind_class('Entry', '&lt;Control-V&gt;', paste)</pre></div><p>In the preceding example, all entry widgets will be bound to the <code class="literal">&lt;Control-V&gt;</code> event that would call a method called <code class="literal">'paste (event)'</code>.</p></li></ul></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>
<strong>Event propagation</strong>
<a id="id112" class="indexterm"/>
</p><p>Most of the keyboard events and mouse events occur at the operating system level. It propagates from the source of the event, hierarchically up, until it finds a window that has a corresponding binding. The event propagation does not stop there. It propagates itself upwards looking for other bindings from other widgets until it reaches the root window. If it does reach the root window and no bindings are discovered by it, the event is disregarded.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Handling widget-specific variables</h3></div></div></div><p>You need variables with a wide variety<a id="id113" class="indexterm"/> of widgets. You likely need a string variable to track what the user enters into the entry widget or text widget. You most probably need Boolean variables to track whether the user has checked the Checkbox widget. You need integer variables to track the value entered in a Spinbox or Slider widget.</p><p>In order to respond to changes in widget-specific variables, Tkinter offers its own variable class. The variable that <a id="id114" class="indexterm"/>you use to track widget-specific values must be subclassed from this Tkinter variable class. Tkinter offers some commonly used predefined variables. They are <code class="literal">StringVar</code>, <code class="literal">IntVar</code>, <code class="literal">BooleanVar</code>, and <code class="literal">DoubleVar</code>.</p><p>You can use these variables to capture and play with changes in the value of variables from within your callback functions. You can also define your own variable type, if required.</p><p>Creating a Tkinter variable is simple. You simply call the required constructor:</p><div><pre class="programlisting">
<strong>mystring = StringVar()</strong>
<strong>ticked_yes = BooleanVar()</strong>
<strong>option1 = IntVar()</strong>
<strong>volume = DoubleVar()</strong>
</pre></div><p>Once the variable is created, you can use it as a widget option, as follows:</p><div><pre class="programlisting">
<strong>Entry(root, textvariable = mystring) </strong>
<strong>Checkbutton(root, text="Remember Me", variable=ticked_yes)</strong>
<strong>Radiobutton(root, text="Option1", variable=option1, value="option1") #radiobutton</strong>
<strong>Scale(root, label="Volume Control", variable=volume, from =0, to=10) # slider</strong>
</pre></div><p>Additionally, Tkinter <a id="id115" class="indexterm"/>provides access to the value of variables using <code class="literal">set()</code> and <code class="literal">get()</code> methods:</p><div><pre class="programlisting">
<strong>myvar.set("Wassup Dude") # setting  value of variable</strong>
<strong>myvar.get() # Assessing the value of variable from say a callback</strong>
</pre></div><p>A demonstration of the Tkinter <a id="id116" class="indexterm"/>variable class is available in the code file <code class="literal">1.12.py</code>. The code generates a window like the following screenshot:</p><div><img src="img/7941_01_11.jpg" alt="Handling widget-specific variables"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>In this lesson, you learned:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">command</code> binding to bind simple widgets to certain functions</li><li class="listitem" style="list-style-type: disc">Use of the <code class="literal">lambda</code> function, if you need to process arguments</li><li class="listitem" style="list-style-type: disc">The <code class="literal">event</code> binding using the <code class="literal">widget.bind(event, callback)</code> method to bind keyboard and mouse events to your widgets and to invoke callbacks on the occurrence of some events</li><li class="listitem" style="list-style-type: disc">How to pass extra arguments to a callback</li><li class="listitem" style="list-style-type: disc">How to bind events to an entire application or to a particular class of widget using <code class="literal">bind_all()</code> and <code class="literal">bind_class()</code></li><li class="listitem" style="list-style-type: disc">How to use the Tkinter variable class to set and get values of widget specific variables</li></ul></div><p>In short you now know how to make your GUI program functional!</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>Classified Intel</h2></div></div></div><p>In addition to the <code class="literal">bind</code> method<a id="id117" class="indexterm"/> we previously saw, you might find these two event-related options useful in certain cases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">unbind</code>: Tkinter provides the <code class="literal">unbind</code> options to undo the effect of an earlier binding. The syntax is as follows:<div><pre class="programlisting">widget.unbind(event)</pre></div><p>The following are some examples of its usage:</p><div><pre class="programlisting">entry.unbind('&lt;Alt-Shift-5&gt;')
root.unbind_all('&lt;F1&gt;')
root.unbind_class('Entry', '&lt;KeyPress-Del&gt;')</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>Virtual events</strong>: Tkinter<a id="id118" class="indexterm"/> also lets you create your own events. You can give these virtual events any name you want.<p>For example, imagine you want to create a new event called <code class="literal">&lt;&lt;commit&gt;&gt;</code>, which is triggered by the <em>F9</em> key. To create this virtual event on a given widget, use the syntax:</p><div><pre class="programlisting">widget.event_add('&lt;&lt;commit&gt;&gt;', '&lt;F-9&gt;')</pre></div><p>You can then bind <code class="literal">&lt;&lt;commit&gt;&gt;</code> to any callback using a normal <code class="literal">bind()</code> method like:</p><div><pre class="programlisting">widget.bind('&lt;&lt;commit&gt;&gt;', callback)</pre></div></li></ul></div><p>Other event-related methods are listed in the <em>Other event-related methods</em> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <em>Quick Reference Sheets</em>.</p><p>Now that you are ready to dive into real application development with Tkinter, let's spend some time exploring a few custom styling options that Tkinter offers. We will also see some of the configuration options commonly used with the root window.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Doing it in style</h1></div></div></div><p> So far, we have <a id="id119" class="indexterm"/>have relied on Tkinter to provide specific platform-based styling for our widgets. However, you can specify your own styling of widgets in terms of their<a id="id120" class="indexterm"/> color, font size, border width, and relief. A brief introduction of styling features available in Tkinter is covered in the following task.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec27"/>Prepare for Lift Off</h2></div></div></div><p>Recall that we <a id="id121" class="indexterm"/>could specify widget options at the time of its instantiation as shown:</p><div><pre class="programlisting">mybutton = Button(parent, **configuration options) </pre></div><p>Alternatively, you could specify widget options using <code class="literal">configure ()</code>:</p><div><pre class="programlisting">mybutton.configure(**options)</pre></div><p>Styling options are also specified as options to the widgets, either at the time of instantiation or later using the configure option.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec28"/>Engage Thrusters</h2></div></div></div><p>Under the purview of styling, we will cover how to apply different colors, fonts, border width, relief, cursor, and bitmap icons to our widgets. We will also look at some of the root configurations later in the section.</p><p>Let's first see how to specify color options for a widget. You can specify two types of color for most of the widgets:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Background color</li><li class="listitem" style="list-style-type: disc">Foreground color</li></ul></div><p>You can specify the color using hexadecimal color codes using the proportion of red, green, and blue. Commonly used representations are <code class="literal">#rgb</code> (4 bits), <code class="literal">#rrggbb</code> (8 bits), and <code class="literal">#rrrgggbbb</code> (12 bits).</p><p>For example, <code class="literal">#fff</code> is white, <code class="literal">#000000</code> is black, and <code class="literal">#fff000000</code> is red.</p><p>Alternatively, Tkinter provides mapping for standard color names. For a list of predefined colors, open the program titled <code class="literal">pynche</code> in the <code class="literal">Tools</code> folder within your Python installation directory (in my case, <code class="literal">C:\Python27\Tools\pynche</code>). Within the program click on <strong>View</strong> | <strong>Color list Window</strong>.</p><p>Next, the easiest and the most common way to specify a font is to represent it as a tuple. The standard representation is as follows:</p><div><pre class="programlisting">widget.configure( font= 'font family, fontsize, optional style modifiers like bold, italic, underline and overstrike')</pre></div><p>Here are some examples to illustrate the method for specifying fonts:</p><div><pre class="programlisting">widget.configure (font='Times, 8')
widget.configure  (font = 'Helvetica 24 bold italic')</pre></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>If you set a Tkinter dimension in a plain integer, the measurements takes place in units of pixel. Alternatively, Tkinter accepts four other measurement units which are: m (millimeters), c (centimeters), i (inches), and p (printer's points, which is about 1/72").</p></div></div><p>The default border <a id="id122" class="indexterm"/>width for most Tkinter widgets is 2 pixels. You can change the border width of the widgets by specifying it explicitly, as shown in the following line:</p><div><pre class="programlisting">button.configure (borderwidth=5)</pre></div><p>The relief style of a widget refers to the difference between the highest and lowest elevations in a widget. Tkinter offers five possible relief styles: <code class="literal">flat</code>, <code class="literal">raised</code>, <code class="literal">sunken</code>, <code class="literal">groove</code>, and <code class="literal">ridge</code>.</p><div><pre class="programlisting">button.configure (relief='raised')</pre></div><p>Tkinter lets you change the style of mouse cursor when you hover over a particular widget. This is done using the option cursor as in the following example:</p><div><pre class="programlisting">button.configure (cursor='cross')</pre></div><p>For a complete list of available cursors, refer to the <em>List of available cursors</em> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <em>Quick Reference Sheets</em>.</p><p>While you can specify styling options at each widget level, sometimes it may be cumbersome to do so individually for each widget. Widget-specific styling has several disadvantages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It mixes logic and presentation<a id="id123" class="indexterm"/> into one file making the code bulky and difficult to manage</li><li class="listitem" style="list-style-type: disc">Any change in styling is to be applied to each widget individually</li><li class="listitem" style="list-style-type: disc">It violates the <strong>don't repeat yourself</strong> (<strong>DRY</strong>)<a id="id124" class="indexterm"/> principle of effective coding as you keep specifying the same style for a large number of widgets</li></ul></div><p>Fortunately, Tkinter now offers a way to separate presentation from the logic and to specify styles in what is called the external "option database". This is nothing but a text file where you can specify the <a id="id125" class="indexterm"/>common styling options.</p><p>A typical option database text file may look like the following:</p><div><pre class="programlisting">*font: Arial 10
*Label*font: Times 12 bold
*background: AntiqueWhite1
*Text*background: #454545
*Button*foreground:gray55
*Button*relief: raised
*Button*width: 3</pre></div><p>The asterisk (<code class="literal">*</code>) symbol here means that the particular style applies to all instances of the given widget.</p><p>These entries are placed in an external text <code class="literal">(.txt)</code> file. To apply this styling to a particular piece of code, you simply call it using the <code class="literal">option_readfile()</code> call early in your code, as shown here:</p><div><pre class="programlisting">root.option_readfile('optionDB.txt')</pre></div><p>Now that we are done discussing styling options, let us wrap up with a discussion on some commonly used options for the root window:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">root.title("title of my program")<a id="id126" class="indexterm"/>
</pre></div>
</td><td style="text-align: left" valign="top">
<p>Specifying the title for the Title bar</p>
</td></tr><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">root.geometry('142x280+150+200') <a id="id127" class="indexterm"/>
</pre></div>
</td><td style="text-align: left" valign="top">
<p>You can specify the size and location of a root window using a string of the form <code class="literal">widthxheight</code> + <code class="literal">xoffset</code> + <code class="literal">yoffset</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
</p><div><pre class="programlisting">self.root.wm_iconbitmap('mynewicon.ico')<a id="id128" class="indexterm"/>
</pre></div><p>
</p>
<p>or</p>
 <div><pre class="programlisting">self.root.iconbitmap('mynewicon.ico ')<a id="id129" class="indexterm"/>
</pre></div>
 </td><td style="text-align: left" valign="top">
<p>Changing the Title bar icon to something different from the default Tk icon</p>
</td></tr><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">root.overrideredirect(1)<a id="id130" class="indexterm"/>
</pre></div>
</td><td style="text-align: left" valign="top">
<p>Removing the root border frame</p>
</td></tr></tbody></table></div><p>Now let's take a look at an example where we apply all the styling options and root window options as <a id="id131" class="indexterm"/>discussed previously (see the code <code class="literal">01.13.py</code>):</p><div><pre class="programlisting">from Tkinter import *
root = Tk()

#demo of some important root methods
root.geometry('142x280+150+200') #specify root window size and position
root.title("Style Demo") #specifying title of the program
self.root.wm_iconbitmap('brush1.ico')#changing the default icon
#root.overrideredirect(1) # remove the root border - uncomment #this line to see the difference
root.configure(background='#4D4D4D')#top level styling

# connecting to the external styling optionDB.txt
root.option_readfile('optionDB.txt')

#widget specific styling
mytext = Text(root, background='#101010', foreground="#D6D6D6", borderwidth=18, relief='sunken', width=16, height=5 )
mytext.insert(END, "Style is knowing \nwho you are, what \nyou want to say, \nand not giving a \ndamn.")
mytext.grid(row=0, column=0, columnspan=6, padx=5, pady=5)

# all the below widgets derive their styling from optionDB.txt file
Button(root, text='*' ).grid(row=1, column=1)
Button(root, text='^' ).grid(row=1, column=2)
Button(root, text='#' ).grid(row=1, column=3)
Button(root, text='&lt;' ).grid(row=2, column=1)
Button(root, text='OK', cursor='target').grid(row=2, column=2)
Button(root, text='&gt;').grid(row=2, column=3)
Button(root, text='+' ).grid(row=3, column=1)
Button(root, text='v', font='Verdana 8').grid(row=3, column=2)
Button(root, text='-' ).grid(row=3, column=3)
fori in range(0,10,1):
  Button(root, text=str(i) ).grid( column=3 if i%3==0  else (1 if i%3==1 else 2), row= 4 if i&lt;=3  else (5 if i&lt;=6 else 6))

#styling with built-in bitmap images
mybitmaps = ['info', 'error', 'hourglass', 'questhead', 'question', 'warning']
for i in mybitmaps:
  Button(root, bitmap=i,  width=20,height=20).grid(row=(mybitmaps.index(i)+1), column=4,sticky='nw')

root.mainloop()</pre></div><p>The description <a id="id132" class="indexterm"/>of the preceding code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first segment of code uses some important root methods to define the geometry, title of the program, icon for the program, and method to remove the border of the root window.</li><li class="listitem" style="list-style-type: disc">The code then connects to an external styling file called <code class="literal">optionDB.txt</code> that defines common styling for the widgets.</li><li class="listitem" style="list-style-type: disc">The next segment of code creates a Text widget and specifies styling on the widget level.</li><li class="listitem" style="list-style-type: disc">The next segment of code has several buttons, all of which derive their styling from the centralized <code class="literal">optionDb.txt</code> file. One of the buttons also defines a custom cursor.</li><li class="listitem" style="list-style-type: disc">The last segment of code styles some buttons using built-in bitmap images.</li></ul></div><p>Running this program would produce a window like the following screenshot:</p><div><img src="img/7941_01_12.jpg" alt="Engage Thrusters"/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec29"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>In this task, we explored how<a id="id133" class="indexterm"/> to use styling options to modify the default styling of Tkinter. We saw how to specify custom colors, fonts, reliefs, and cursors for our GUI programs. We also saw how to separate styling from the logic using the option database. Finally, we explored some of the common options for configuring our root window.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Mission Accomplished</h1></div></div></div><p>This brings us<a id="id134" class="indexterm"/> to end of <a class="link" href="ch01.html" title="Chapter 1. Meet Tkinter">Project 1</a>, <em>Meet Tkinter</em>. This project aimed to provide a high-level overview of Tkinter. We have worked our way through all the important concepts that drive a Tkinter program. We now know:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What a root window is and how to set it up</li><li class="listitem" style="list-style-type: disc">What the 21 core Tkinter widgets are and how to set them up</li><li class="listitem" style="list-style-type: disc">How to layout our programs using <code class="literal">pack</code>, <code class="literal">grid</code>, and <code class="literal">place</code> geometry managers</li><li class="listitem" style="list-style-type: disc">How to make our programs functional using events and callbacks</li><li class="listitem" style="list-style-type: disc">How to apply custom styles to our GUI programs</li></ul></div><p>To summarize,<a id="id135" class="indexterm"/> we can now start thinking of making interesting, functional, and stylish GUI programs with Tkinter!</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>A Hotshot Challenge</h1></div></div></div><p>Time for your first Hotshot challenge! Your task is to build a simple calculator (or if you are ambitious, a scientific calculator). It should be fully functional and should have custom-styled buttons and a screen. Try to make it look as close to real physical calculators as you can.</p><p>When you are done, we invite you to search in your computer for complex GUI programs. These can range from your operating system programs such as the search bar, to some simple dialog-based widgets. Try to replicate any chosen GUIs using Tkinter.</p></div></body></html>