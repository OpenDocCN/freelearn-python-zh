<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-213"><a id="_idTextAnchor443" class="pcalibre calibre4 pcalibre1"/>9</h1>
			<h1 id="_idParaDest-214" class="calibre6"><a id="_idTextAnchor444" class="pcalibre calibre4 pcalibre1"/>Launch Files – Starting All Your Nodes at Once</h1>
			<p class="calibre3">At this point, you know how to write nodes, how to make them communicate with topics, services, and actions, and how to make them more dynamic with parameters.</p>
			<p class="calibre3">In this last chapter of <em class="italic">Part 2</em>, we will bring everything together and go one step further toward making your application more scalable. Here, we will talk about launch files, which allow you to start all your nodes and parameters at once.</p>
			<p class="calibre3">To start with launch files, it’s important that you’re comfortable with the concepts seen in the previous chapters. As a starting point, we will use the code inside the <strong class="source-inline1">ch8</strong> folder from the book’s GitHub repository (<a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>). You can find the final code for launch files in the <strong class="source-inline1">ch9</strong> folder.</p>
			<p class="calibre3">First, as always, I will use a real-life example to explain why you need launch files and what they are exactly. You will then dive into the code and create your own launch file with XML and Python (we will discuss which language is more appropriate). You will also experiment with extra configurations to fully customize your nodes inside launch files, and you will practice more with a final challenge.</p>
			<p class="calibre3">By the end of this chapter, you will be able to properly scale your ROS 2 applications and know how to use or modify existing launch files. Almost every ROS 2 application or stack contains one or several launch files. Being comfortable with them is key to becoming a great ROS developer.</p>
			<p class="calibre3">In this chapter, we will cover the following topics:</p>
			<ul class="calibre9">
				<li class="calibre10">What is a ROS 2 launch file?</li>
				<li class="calibre10">Creating and installing an XML launch file</li>
				<li class="calibre10">Creating a Python launch file – XML or Python for launch files?</li>
				<li class="calibre10">Configuring nodes inside a launch file</li>
				<li class="calibre10">Launch file challenge</li>
			</ul>
			<h1 id="_idParaDest-215" class="calibre6"><a id="_idTextAnchor445" class="pcalibre calibre4 pcalibre1"/>What is a ROS 2 launch file?</h1>
			<p class="calibre3">After everything you’ve learned already, understanding the concept of launch files will not be very difficult.</p>
			<p class="calibre3">You have <a id="_idIndexMarker575" class="pcalibre calibre4 pcalibre1"/>experimented a bit with launch files in <a href="B22403_03.xhtml#_idTextAnchor092" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 3</em></a>. We will now, as usual, start from scratch and see what a launch file is with an example. First, we’ll look at why we need launch files.<a id="_idTextAnchor446" class="pcalibre calibre4 pcalibre1"/></p>
			<h2 id="_idParaDest-216" class="calibre6"><a id="_idTextAnchor447" class="pcalibre calibre4 pcalibre1"/>Why launch files?</h2>
			<p class="calibre3">As your ROS 2 application starts to grow, so does the number of nodes and parameters. For example, a ROS stack I developed for a robotic arm had more than 15 nodes and 200 parameters. Imagine <a id="_idIndexMarker576" class="pcalibre calibre4 pcalibre1"/>opening 15 terminals and starting all the nodes one by one with all the correct values for parameters. This would quickly become a nightmare.</p>
			<p class="calibre3">For this explanation, let’s assume we have the following nodes in our application:</p>
			<ul class="calibre9">
				<li class="calibre10">Three camera nodes with different settings</li>
				<li class="calibre10">Two LED panel nodes with varying numbers of LEDs</li>
				<li class="calibre10">One battery node</li>
				<li class="calibre10">Another node with more parameters</li>
			</ul>
			<p class="calibre3">Here is what your application would look like:</p>
			<div><div><img alt="Figure 9.1 – ROS 2 application with seven nodes and sixteen parameters" src="img/B22403_09_1.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.1 – ROS 2 application with seven nodes and sixteen parameters</p>
			<p class="calibre3">To start all those nodes, you will need to open seven terminals and start the nodes one by one. For each node, you will also need to provide all the required parameters’ values (with what you’ve seen in the previous chapter, you can use YAML param files to make this easier). Not only is this not scalable, but it will make your development process much slower <a id="_idIndexMarker577" class="pcalibre calibre4 pcalibre1"/>and frustrating. With so many terminals, it’s easy to make mistakes or to forget which terminal is doing what.</p>
			<p class="calibre3">A solution you could think of is to create a script (a <strong class="source-inline1">bash</strong> script, for example) to start all <strong class="source-inline1">ros2 run</strong> commands from one file. That way, you could run your application from just one terminal. This would reduce development time and allow your application to scale.</p>
			<p class="calibre3">Well, this is exactly what launch files are made for. There’s no need to write your own script; all you need to do is create a launch file and follow a few syntax rules. Launch files can be installed within your ROS 2 application. Let’s look at an example in the next section<a id="_idTextAnchor448" class="pcalibre calibre4 pcalibre1"/>.</p>
			<h2 id="_idParaDest-217" class="calibre6"><a id="_idTextAnchor449" class="pcalibre calibre4 pcalibre1"/>Example of a launch file with seven nodes</h2>
			<p class="calibre3">If we <a id="_idIndexMarker578" class="pcalibre calibre4 pcalibre1"/>continue with our example, here is how your nodes would be organized:</p>
			<div><div><img alt="Figure 9.2 – Launch file with all nodes and parameters" src="img/B22403_09_2.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Launch file with all nodes and parameters</p>
			<p class="calibre3">Inside one file, you start all the nodes and provide the values you want for each parameter. This file <a id="_idIndexMarker579" class="pcalibre calibre4 pcalibre1"/>can be written with XML, YAML, or Python—we will see how to do that in a moment. Then, once the launch file is written, you will install it (<strong class="source-inline1">colcon build</strong>) and run it with the <strong class="source-inline1">ros2 launch</strong> command-line tool.</p>
			<p class="calibre3">It’s not uncommon to have a few dozen nodes and a few hundred parameters inside one application. Without launch files, it would be impossible to quickly start the application, and you would spend most of your time debugging trivial things.</p>
			<p class="calibre3">Launch files allow you to customize and scale your application easily. There is not much more to say; the concept is fairly straightforward. Most of the work is about learning how to implement one and knowing the features to customize your nodes to make them more dynamic. This is what we will dive into right no<a id="_idTextAnchor450" class="pcalibre calibre4 pcalibre1"/>w.</p>
			<h1 id="_idParaDest-218" class="calibre6"><a id="_idTextAnchor451" class="pcalibre calibre4 pcalibre1"/>Creating and installing an XML launch file</h1>
			<p class="calibre3">You will now create your first launch file. We will start with XML. Later in this chapter, we will also <a id="_idIndexMarker580" class="pcalibre calibre4 pcalibre1"/>write Python launch files and compare the two languages, but let’s keep things simple to get started.</p>
			<p class="calibre3">To properly <a id="_idIndexMarker581" class="pcalibre calibre4 pcalibre1"/>create, install, and start a launch file, you need to do a bit of setup. In this section, we will follow all the necessary setup steps with a minimal launch file.</p>
			<p class="calibre3">What we want to do here is to start the number application (<strong class="source-inline1">number_publisher</strong> and <strong class="source-inline1">number_counter</strong> nodes) from one terminal, with just one command line. Let’s get star<a id="_idTextAnchor452" class="pcalibre calibre4 pcalibre1"/>ted.</p>
			<h2 id="_idParaDest-219" class="calibre6"><a id="_idTextAnchor453" class="pcalibre calibre4 pcalibre1"/>Setting up a package for launch files</h2>
			<p class="calibre3">Where should you put your launch files? You could theoretically create a launch file in any existing package.</p>
			<p class="calibre3">However, this method can quickly lead to a dependency mess between packages. If package A requires <a id="_idIndexMarker582" class="pcalibre calibre4 pcalibre1"/>package B, and you create a launch file in package B to start nodes from both packages, then you have created what’s <a id="_idIndexMarker583" class="pcalibre calibre4 pcalibre1"/>called a <em class="italic">dependency loop</em>. Package A depends on package B, and package B depends on package A. This is a very bad way to start a ROS application.</p>
			<p class="calibre3">As a best practice, we will create a package dedicated to launch files. We will not modify any existing package; instead, we will create a completely independent one.</p>
			<p class="calibre3">First, let’s choose a name for this package. We will follow a common naming convention. We start with the name of the robot or application, followed by the <strong class="source-inline1">_bringup</strong> suffix. As we don’t have a robot here, we will call this package <strong class="source-inline1">my_robot_bringup</strong>. If your robot were named <em class="italic">abc</em>, you would create an <strong class="source-inline1">abc_bringup</strong> package.</p>
			<p class="calibre3">Navigate to the <strong class="source-inline1">src</strong> directory in your ROS 2 workspace and create this package. It will not contain any Python or C++ nodes. For the build type, you can choose <strong class="source-inline1">ament_cmake</strong> (you could even omit the build type, as <strong class="source-inline1">ament_cmake</strong> is the default anyway):</p>
			<pre class="console">
$ cd ~/ros2_ws/src/
$ ros2 pkg create my_robot_bringup --build-type ament_cmake</pre>			<p class="calibre3">Alternatively, you could just run <strong class="source-inline1">$ ros2 pkg </strong><strong class="source-inline1">create my_robot_bringup</strong>.</p>
			<p class="calibre3">Once the package is created, we can remove directories that we don’t need:</p>
			<pre class="console">
$ cd my_robot_bringup/
$ rm -r include/ src/</pre>			<p class="calibre3">Then, we create a <strong class="source-inline1">launch</strong> directory. This is where we will put all our launch files for this application:</p>
			<pre class="console">
$ mkdir launch</pre>			<p class="calibre3">Before we <a id="_idIndexMarker584" class="pcalibre calibre4 pcalibre1"/>create a launch file, let’s finish the package configuration. Open the <strong class="source-inline1">CMakeLists.txt</strong> file and add these lines:</p>
			<pre class="source-code">
find_package(ament_cmake REQUIRED)
<strong class="bold1">install(DIRECTORY</strong>
<strong class="bold1">  launch</strong>
<strong class="bold1">  DESTINATION share/${PROJECT_NAME}/</strong>
<strong class="bold1">)</strong>
ament_package()</pre>			<p class="calibre3">This will install the <strong class="source-inline1">launch</strong> directory when you build your package with <strong class="source-inline1">colcon build</strong>.</p>
			<p class="calibre3">Now, the package is correctly configured. You only need to do those steps once for each ROS 2 application. Then, to add a launch file, you just have to create a new file inside the <strong class="source-inline1">launch</strong> folder. Let’s d<a id="_idTextAnchor454" class="pcalibre calibre4 pcalibre1"/>o that.</p>
			<h2 id="_idParaDest-220" class="calibre6"><a id="_idTextAnchor455" class="pcalibre calibre4 pcalibre1"/>Writing an XML launch file</h2>
			<p class="calibre3">Navigate <a id="_idIndexMarker585" class="pcalibre calibre4 pcalibre1"/>to the <strong class="source-inline1">launch</strong> folder you created inside the <strong class="source-inline1">my_robot_bringup</strong> package. To create a launch file, you will first choose a name and then use the <strong class="source-inline1">.launch.xml</strong> extension. Since we have named our application the <em class="italic">number app</em>, let’s create a new file named <strong class="source-inline1">number_app.launch.xml</strong>:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_robot_bringup/launch/
$ touch number_app.launch.xml</pre>			<p class="calibre3">Open the file, and let’s start to write the content for the launch file.</p>
			<p class="calibre3">First, you will need to open and close a <strong class="source-inline1">&lt;launch&gt;</strong> tag. Everything you write will be between those two lines. This is the minimum code for an XML launch file:</p>
			<pre class="source-code">
&lt;launch&gt;
&lt;/launch&gt;</pre>			<p class="calibre3">Then, we want to start the <strong class="source-inline1">number_publisher</strong> and <strong class="source-inline1">number_counter</strong> nodes.</p>
			<p class="calibre3">As a quick reminder, in the terminal, you would run this:</p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher
$ ros2 run my_cpp_pkg number_counter</pre>			<p class="calibre3">Here, I started one <a id="_idIndexMarker586" class="pcalibre calibre4 pcalibre1"/>node from the Python package and the other one from the C++ package. The two arguments we need to provide for <strong class="source-inline1">ros2 run</strong> are the package name and executable name. This is the same inside a launch file. To add a node, use a <strong class="source-inline1">&lt;node&gt;</strong> tag with the <strong class="source-inline1">pkg</strong> and <strong class="source-inline1">exec</strong> arguments:</p>
			<pre class="source-code">
&lt;launch&gt;
    &lt;node pkg="my_py_pkg" exec="number_publisher"/&gt;
    &lt;node pkg="my_cpp_pkg" exec="number_counter"/&gt;
&lt;/launch&gt;</pre>			<p class="calibre3">With this, we start the same two nodes from the launch file. As you can see, there’s nothing very complicated. Later on in this chapter, we will see how to configure the application with remappings, parameters, namespaces, and so on. For now, let’s focus on running this minimal lau<a id="_idTextAnchor456" class="pcalibre calibre4 pcalibre1"/>nch file.</p>
			<h2 id="_idParaDest-221" class="calibre6"><a id="_idTextAnchor457" class="pcalibre calibre4 pcalibre1"/>Installing and starting a launch file</h2>
			<p class="calibre3">You now <a id="_idIndexMarker587" class="pcalibre calibre4 pcalibre1"/>have to <a id="_idIndexMarker588" class="pcalibre calibre4 pcalibre1"/>install your new launch file before you can start using it.</p>
			<p class="calibre3">As we are starting nodes from the <strong class="source-inline1">my_py_pkg</strong> and <strong class="source-inline1">my_cpp_pkg</strong> packages, we need to add the dependencies in the <strong class="source-inline1">package.xml</strong> file of the <strong class="source-inline1">my_robot_bringup</strong> package:</p>
			<pre class="source-code">
&lt;exec_depend&gt;my_py_pkg&lt;/exec_depend&gt;
&lt;exec_depend&gt;my_cpp_pkg&lt;/exec_depend&gt;</pre>			<p class="callout-heading">Note</p>
			<p class="callout">Previously, we only used a <code>&lt;depend&gt;</code> tag when specifying dependencies. In this case, there is nothing to build; we only need the dependency when executing the launch file. Thus, we use a weaker tag, <code>&lt;exec_depend&gt;</code>.</p>
			<p class="calibre3">For each <a id="_idIndexMarker589" class="pcalibre calibre4 pcalibre1"/>new package you use in your launch files, you will add <a id="_idIndexMarker590" class="pcalibre calibre4 pcalibre1"/>a new <strong class="source-inline1">&lt;exec_depend&gt;</strong> tag in the <strong class="source-inline1">package.xml</strong> file.</p>
			<p class="calibre3">Now, we can install the launch file. To do so, you just need to build your package:</p>
			<pre class="console">
$ cd ~/ros2_ws/
$ colcon build --packages-select my_robot_bringup</pre>			<p class="calibre3">Then, source your environment, and use the <strong class="source-inline1">ros2 launch</strong> command-line tool to start the launch file. The full command is <strong class="source-inline1">ros2 launch &lt;</strong><strong class="source-inline1">package_name&gt; &lt;launch_file_name&gt;</strong>:</p>
			<pre class="console">
$ ros2 launch my_robot_bringup number_app.launch.xml</pre>			<p class="calibre3">You will see the following logs:</p>
			<pre class="console">
[INFO] [launch]: All log files can be found below /home/user/.ros/log/...
[INFO] [launch]: Default logging verbosity is set to INFO
[INFO] [number_publisher-1]: process started with pid [21108]
[INFO] [number_counter-2]: process started with pid [21110]
[number_counter-2] [INFO] [1716293867.204728817] [number_counter]: Number Counter has been started.
[number_publisher-1] [INFO] [1716293867.424510088] [number_publisher]: Number publisher has been started.
[number_counter-2] [INFO] [1716293868.413350769] [number_counter]: Counter: 2
[number_counter-2] [INFO] [1716293869.413321220] [number_counter]: Counter: 4
[number_counter-2] [INFO] [1716293870.413321491] [number_counter]: Counter: 6</pre>			<p class="calibre3">What’s happening here? Let’s take a closer look:</p>
			<ol class="calibre11">
				<li class="calibre10">A log file <a id="_idIndexMarker591" class="pcalibre calibre4 pcalibre1"/>is created and the logging verbosity is set.</li>
				<li class="calibre10">Each executable <a id="_idIndexMarker592" class="pcalibre calibre4 pcalibre1"/>that you provided in the launch file is started <a id="_idIndexMarker593" class="pcalibre calibre4 pcalibre1"/>as a new process. You can see the process name (for example, <code>number_publisher-1</code>) and the process ID (denoted as <code>pid</code>).</li>
				<li class="calibre10">Then, as all nodes are started in the same terminal, you will see all logs from all nodes.</li>
			</ol>
			<p class="calibre3">This example is quite simple, as we just start two executables with no additional configuration. Launch files will become quite handy when the number of nodes and settings gets bigger. Also, the <strong class="source-inline1">ros2 launch</strong> command-line tool is very easy to use. There is not really much more than what we’ve seen here.</p>
			<p class="calibre3">Now that you have completed the process to create, install, and start a launch file, let’s talk about Pyth<a id="_idTextAnchor458" class="pcalibre calibre4 pcalibre1"/>on launch files.</p>
			<h1 id="_idParaDest-222" class="calibre6"><a id="_idTextAnchor459" class="pcalibre calibre4 pcalibre1"/>Creating a Python launch file – XML or Python for launch files?</h1>
			<p class="calibre3">There are actually three languages you can use to create launch files in ROS 2: Python, XML, and YAML. I will not cover YAML launch files as they are not seldom used, and YAML doesn’t <a id="_idIndexMarker594" class="pcalibre calibre4 pcalibre1"/>have any competitive advantage over XML for launch files. Here, we will be focusing on Python and XML.</p>
			<p class="calibre3">We will start this section by creating a Python launch file (the same application as before). Then, I will compare XML and Python launch files and give you some guidance on how to get the best <a id="_idTextAnchor460" class="pcalibre calibre4 pcalibre1"/>out of them both.</p>
			<h2 id="_idParaDest-223" class="calibre6"><a id="_idTextAnchor461" class="pcalibre calibre4 pcalibre1"/>Writing a Python launch file</h2>
			<p class="calibre3">As we already <a id="_idIndexMarker595" class="pcalibre calibre4 pcalibre1"/>have a fully configured <strong class="source-inline1">my_robot_bringup</strong> package for our application, there’s no need to do anything else. All we have to do is create a new file inside the <strong class="source-inline1">launch</strong> directory.</p>
			<p class="calibre3">For Python launch files, you will use the <strong class="source-inline1">.launch.py</strong> extension. Create a new file named <strong class="source-inline1">number_app.launch.py</strong>. Here is the code required to start the <strong class="source-inline1">number_publisher</strong> and <strong class="source-inline1">number_counter</strong> nodes:</p>
			<pre class="source-code">
from launch import LaunchDescription
from launch_ros.actions import Node
def generate_launch_description():
    ld = LaunchDescription()
    number_publisher = Node(
        package="my_py_pkg",
        executable="number_publisher"
    )
    number_counter = Node(
        package="my_cpp_pkg",
        executable="number_counter"
    )
    ld.add_action(number_publisher)
    ld.add_action(number_counter)
    return ld</pre>			<p class="calibre3">The first thing you will notice is that the code is much, much longer than the XML one. I will come back <a id="_idIndexMarker596" class="pcalibre calibre4 pcalibre1"/>to this in a minute when I compare Python and XML. For now, let’s focus on the required steps to write a Python launch file:</p>
			<ol class="calibre11">
				<li class="calibre10">The launch file must include a <code>generate_launch_description()</code> function. Make sure you don’t make any typos.</li>
				<li class="calibre10">In this function, you will need to create and return a <code>LaunchDescription</code> object. You can get this from the <code>launch</code> module.</li>
				<li class="calibre10">To add a node in the launch file, you create a <code>Node</code> object (from <code>launch_ros.actions</code>) and specify the package and executable name. Then, you can add this object to the <code>LaunchDescription</code> object.</li>
			</ol>
			<p class="calibre3">That’s it for now, but there are more options that we will explore a bit later in this chapter.</p>
			<p class="calibre3">Once you have written the launch file, make sure to add all required dependencies in the <strong class="source-inline1">package.xml</strong> file of the <strong class="source-inline1">my_robot_bringup</strong> package. As we already did that with the XML launch file (and we have the same dependencies here), we can skip this step.</p>
			<p class="calibre3">Finally, to install this launch file, build the <strong class="source-inline1">my_robot_bringup</strong> package again. Since we already wrote the necessary instructions in the <strong class="source-inline1">CMakeLists.txt</strong> file, the launch file will be installed. All you need to do after that is to source your environment and start the launch file with <strong class="source-inline1">ros2 launch</strong>:</p>
			<pre class="console">
$ ros2 launch my_robot_bringup number_app.launch.py</pre>			<p class="calibre3">To create, install, and start a Python launch file, the process is the same as for an XML launch file. Only the <a id="_idIndexMarker597" class="pcalibre calibre4 pcalibre1"/>code is different. Let’s now compare the two languages regarding their <a id="_idTextAnchor462" class="pcalibre calibre4 pcalibre1"/>use in launch files.</p>
			<h2 id="_idParaDest-224" class="calibre6"><a id="_idTextAnchor463" class="pcalibre calibre4 pcalibre1"/>XML versus Python for launch files</h2>
			<p class="calibre3">I <a id="_idIndexMarker598" class="pcalibre calibre4 pcalibre1"/>have a strong bias toward simplicity, so, from <a id="_idIndexMarker599" class="pcalibre calibre4 pcalibre1"/>seeing the previous code examples, you can already guess where I’m going to stand.</p>
			<p class="calibre3">To answer the XML versus Python question, let’s f<a id="_idTextAnchor464" class="pcalibre calibre4 pcalibre1"/>irst go back in time.</p>
			<h3 class="calibre8">The issue with Python launch files</h3>
			<p class="calibre3">In ROS 1, the first version of ROS, XML was the only language used for launch files. Python was <a id="_idIndexMarker600" class="pcalibre calibre4 pcalibre1"/>actually also available, but due to non-existent documentation, nobody knew about it.</p>
			<p class="calibre3">At the beginning of ROS 2, the development team put a stronger emphasis on Python launch files and started to write the documentation only for Python, thus making it the default language for launch files. XML (and YAML) launch files were also supported, but again, due to non-existent documentation, nobody was using them.</p>
			<p class="calibre3">I was initially enthusiastic about the idea of writing Python launch files, as this meant you could take advantage of the Python logic and syntax to make launch files much more dynamic and easier to write. That’s the theory, but in practice, I realized I didn’t see any programming logic in most of the launch files I found, and it was just another—more complex and difficult—way to write a description, which is basically why XML exists in the first place.</p>
			<p class="calibre3">You can already see the added complexity in the two previous examples. To start two nodes, it takes four lines in XML and twenty lines in Python (I could optimize the code and make it less than fifteen lines, but that’s still a lot more). For the same number of nodes, you can expect Python launch files to be two to five times longer than the XML version.</p>
			<p class="calibre3">Also, with more functionalities (parameters, arguments from the terminal, conditions, paths, and so on), you will have to use an increasing amount of Python imports that are hard to find and use. You will realize this as we see more examples of XML and Python launch files all along this book.</p>
			<p class="calibre3">Fortunately, XML is coming back, as the official documentation is starting to include it as well as Python. More and more developers have started to use XML launch files again, which is a <a id="_idIndexMarker601" class="pcalibre calibre4 pcalibre1"/>good thing because more online tutorials and open source<a id="_idTextAnchor465" class="pcalibre calibre4 pcalibre1"/> code will include them.</p>
			<h3 class="calibre8">How to combine XML and Python launch files in your application</h3>
			<p class="calibre3">XML launch files are much simpler and smaller to write than Python launch files. However, for some advanced use cases, Python will be the only choice, as it contains some functionalities <a id="_idIndexMarker602" class="pcalibre calibre4 pcalibre1"/>that are not available for XML. This could be a problem because if you need just one Python functionality, it would mean <a id="_idIndexMarker603" class="pcalibre calibre4 pcalibre1"/>that you’d need to write the entire launch file in Python.</p>
			<p class="calibre3">Fortunately, there is a very easy way to solve that. As we will see in a minute, you can include any kind of launch file into any other launch file, be it Python, XML, or YAML.</p>
			<p class="calibre3">So, if you absolutely need to use Python for a specific launch functionality, then go ahead and create a Python launch file for that. You can then include this launch file in your <em class="italic">main</em> XML launch file. You can also include any other existing Python launch file (from an already installed package) that contains the functionality you need. By doing this, you keep your code minimal and simple.</p>
			<p class="calibre3">Now, what to do when you need to create a Python launch file for a specific use case? The syntax is really complicated, and there are too many imports for any functionality. It can quickly become a challenge.</p>
			<p class="calibre3">What I myself do when I have to create a Python launch file is to try to find an existing launch file on GitHub that does what I want and tweak the code so that it works with my application. I gave up on trying to learn or even memorize the Python launch file syntax. I am not usually a fan of the “copy/paste from the internet” method, but I make an exception for Python launch files.</p>
			<p class="calibre3">In the end, it’s a matter of choice for you. A correctly written XML, YAML, or Python launch file will do the exact same thing. As for YAML, it’s just another markup language, and I find XML easier to use for launch files. My recommendation is to use XML whenever possible. Use Python only if you have to and only for the functionalities that require Python. Then, include the Python launch file inside your XML one.</p>
			<p class="calibre3">Following this process will make your life easier when deve<a id="_idTextAnchor466" class="pcalibre calibre4 pcalibre1"/>loping ROS 2 applications.</p>
			<h3 class="calibre8">Including a launch file inside another launch file</h3>
			<p class="calibre3">Since I talked about including a Python launch file inside an XML launch file, let’s see how to <a id="_idIndexMarker604" class="pcalibre calibre4 pcalibre1"/>do that. The syntax won’t be that complicated.</p>
			<p class="calibre3">Make sure you add everything inside <strong class="source-inline1">&lt;launch&gt;&lt;/launch&gt;</strong> tags. To include another launch file, use an <strong class="source-inline1">&lt;include&gt;</strong> tag. Here is an example:</p>
			<pre class="source-code">
&lt;launch&gt;
    &lt;include file="$(find-pkg-share         my_robot_bringup)/launch/number_app.launch.py" /&gt;
&lt;/launch&gt;</pre>			<p class="calibre3">This line, with <strong class="source-inline1">find-pkg-share</strong>, will find the path to the <strong class="source-inline1">number_app.launch.py</strong> launch file inside the <strong class="source-inline1">my_robot_bringup</strong> package. Then, the content of the launch file will be included. Even if you include a Python launch file inside an XML one, this will work.</p>
			<p class="calibre3">You can reuse this line in any other XML launch file; just replace the package name and launch filename.</p>
			<p class="calibre3">Now, if you wanted to do the opposite (which means including an XML launch file inside a Python launch file), here is what you would need to write:</p>
			<pre class="source-code">
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch_xml.launch_description_sources import XMLLaunchDescriptionSource
import os
from ament_index_python import get_package_share_directory
def generate_launch_description():
    ld = LaunchDescription()
    other_launch_file = IncludeLaunchDescription(
     XMLLaunchDescriptionSource(os.path.join(
      get_package_share_directory('my_robot_bringup'),
                        'launch/number_app.launch.xml')))
    ld.add_action(other_launch_file)
    return ld</pre>			<p class="calibre3">This code <a id="_idIndexMarker605" class="pcalibre calibre4 pcalibre1"/>example illustrates what I was saying about the extra complexity brought by Python launch files. This complexity is not justified here, as it adds nothing compared to the XML file.</p>
			<p class="calibre3">With those two code examples, you can now combine any XML and Python launch files.</p>
			<p class="calibre3">Now that you have seen the process of creating a launch file in both XML and Python, let’s go a bit further and add some extra <a id="_idTextAnchor467" class="pcalibre calibre4 pcalibre1"/>configuration for the nodes.</p>
			<h1 id="_idParaDest-225" class="calibre6"><a id="_idTextAnchor468" class="pcalibre calibre4 pcalibre1"/>Configuring nodes inside a launch file</h1>
			<p class="calibre3">So far, we have just started two nodes, with zero extra configuration. When you start a <a id="_idIndexMarker606" class="pcalibre calibre4 pcalibre1"/>node with <strong class="source-inline1">ros2 run</strong>, as we have seen in <a id="_idIndexMarker607" class="pcalibre calibre4 pcalibre1"/>the previous chapters in <em class="italic">Part 2</em>, you can rename it, rename topics/services/actions, add parameters, and so on.</p>
			<p class="calibre3">In this section, you will learn how to do that inside a launch file. We will also introduce the concept of namespaces. All code examp<a id="_idTextAnchor469" class="pcalibre calibre4 pcalibre1"/>les will be in XML and Python.</p>
			<h2 id="_idParaDest-226" class="calibre6"><a id="_idTextAnchor470" class="pcalibre calibre4 pcalibre1"/>Renaming nodes and communications</h2>
			<p class="calibre3">In an XML <a id="_idIndexMarker608" class="pcalibre calibre4 pcalibre1"/>launch file, to <a id="_idIndexMarker609" class="pcalibre calibre4 pcalibre1"/>rename <a id="_idIndexMarker610" class="pcalibre calibre4 pcalibre1"/>a node, simply <a id="_idIndexMarker611" class="pcalibre calibre4 pcalibre1"/>add a <strong class="source-inline1">name</strong> argument in a <strong class="source-inline1">&lt;</strong><strong class="source-inline1">node&gt;</strong> tag:</p>
			<pre class="source-code">
&lt;node pkg="your_package" exec="your_exec" name="new_name" /&gt;</pre>			<p class="calibre3">Changing the name for a topic/service/action is actually named <em class="italic">remapping</em>. To remap a communication, you have to use a <strong class="source-inline1">&lt;remap&gt;</strong> tag, inside the <strong class="source-inline1">&lt;</strong><strong class="source-inline1">node&gt;</strong> tag:</p>
			<pre class="source-code">
&lt;node pkg="your_package" exec="your_exec"&gt;
    &lt;remap from="/topic1" to="/topic2" /&gt;
&lt;/node&gt;</pre>			<p class="calibre3">You can add as many <strong class="source-inline1">&lt;remap&gt;</strong> tags as you want, each one in a new line.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This is a quick XML reminder, but it can be useful if you’re not used to XML and can prevent lots of errors in the future. For one-line tags, you open the tag and end it with <code>/&gt;</code> (for example, <code>&lt;node /&gt;</code>). If you need to add a tag inside a tag, you then have to open the tag and close it later, like we did for <code>&lt;launch&gt;...&lt;/launch&gt;</code> or <code>&lt;node&gt;...&lt;/node&gt;</code>.</p>
			<p class="calibre3">From this, let’s <a id="_idIndexMarker612" class="pcalibre calibre4 pcalibre1"/>say we want to start two <strong class="source-inline1">number_publisher</strong> nodes <a id="_idIndexMarker613" class="pcalibre calibre4 pcalibre1"/>and one <strong class="source-inline1">number_counter</strong> node. On <a id="_idIndexMarker614" class="pcalibre calibre4 pcalibre1"/>top of that, we also <a id="_idIndexMarker615" class="pcalibre calibre4 pcalibre1"/>want to remap the topic from <strong class="source-inline1">number</strong> to <strong class="source-inline1">my_number</strong>. Here is the full XML launch file:</p>
			<pre class="source-code">
&lt;launch&gt;
    &lt;node pkg="my_py_pkg" exec="number_publisher" name="num_pub1"&gt;
        &lt;remap from="/number" to="/my_number" /&gt;
    &lt;/node&gt;
    &lt;node pkg="my_py_pkg" exec="number_publisher" name="num_pub2"&gt;
        &lt;remap from="/number" to="/my_number" /&gt;
    &lt;/node&gt;
    &lt;node pkg="my_cpp_pkg" exec="number_counter"&gt;
        &lt;remap from="/number" to="/my_number" /&gt;
    &lt;/node&gt;
&lt;/launch&gt;</pre>			<p class="calibre3">We rename <a id="_idIndexMarker616" class="pcalibre calibre4 pcalibre1"/>the two <strong class="source-inline1">number_publisher</strong> nodes <a id="_idIndexMarker617" class="pcalibre calibre4 pcalibre1"/>to avoid name conflicts. Then, we make sure to <a id="_idIndexMarker618" class="pcalibre calibre4 pcalibre1"/>add the same <strong class="source-inline1">&lt;remap&gt;</strong> tag for all nodes in <a id="_idIndexMarker619" class="pcalibre calibre4 pcalibre1"/>which we use a publisher or subscriber on the <strong class="source-inline1">number</strong> topic.</p>
			<p class="callout-heading">Additional tip</p>
			<p class="callout">When you rename nodes and remap communications, use <code>rqt_graph</code> to verify that everything is working fine. With the graphical view, you can easily spot if a topic name is not the same on both sides of the communication.</p>
			<p class="calibre3">Here is the code to do the same thing with a Python launch file:</p>
			<pre class="source-code">
from launch import LaunchDescription
from launch_ros.actions import Node
def generate_launch_description():
    ld = LaunchDescription()
    number_publisher1 = Node(
        package="my_py_pkg",
        executable="number_publisher",
        name="num_pub1",
        remappings=[("/number", "/my_number")]
    )
    number_publisher2 = Node(
        package="my_py_pkg",
        executable="number_publisher",
        name="num_pub2",
        remappings=[("/number", "/my_number")]
    )
    number_counter = Node(
        package="my_cpp_pkg",
        executable="number_counter",
        remappings=[("/number", "/my_number")]
    )
    ld.add_action(number_publisher1)
    ld.add_action(number_publisher2)
    ld.add_action(number_counter)
    return ld</pre>			<p class="calibre3">After <a id="_idIndexMarker620" class="pcalibre calibre4 pcalibre1"/>renaming <a id="_idIndexMarker621" class="pcalibre calibre4 pcalibre1"/>and remapping, let’s <a id="_idIndexMarker622" class="pcalibre calibre4 pcalibre1"/>see how to <a id="_idIndexMarker623" class="pcalibre calibre4 pcalibre1"/>add <a id="_idTextAnchor471" class="pcalibre calibre4 pcalibre1"/>parameters to your nodes inside a launch file.</p>
			<h2 id="_idParaDest-227" class="calibre6"><a id="_idTextAnchor472" class="pcalibre calibre4 pcalibre1"/>Parameters in a launch file</h2>
			<p class="calibre3">Setting <a id="_idIndexMarker624" class="pcalibre calibre4 pcalibre1"/>parameters’ values for a node in a launch <a id="_idIndexMarker625" class="pcalibre calibre4 pcalibre1"/>file is pretty straightforward. We will first see how to provide the va<a id="_idTextAnchor473" class="pcalibre calibre4 pcalibre1"/>lues directly, and then how to load a YAML file.</p>
			<h3 class="calibre8">Setting parameters’ values directly</h3>
			<p class="calibre3">To add a parameter’s value for a node in an XML launch file, you first need to open and close the <strong class="source-inline1">&lt;node&gt;&lt;/node&gt;</strong> tag. Inside this tag, you will add one <strong class="source-inline1">&lt;param&gt;</strong> tag per parameter, with two arguments: <strong class="source-inline1">name</strong> and <strong class="source-inline1">value</strong>.</p>
			<p class="calibre3">Here is <a id="_idIndexMarker626" class="pcalibre calibre4 pcalibre1"/>an example, where we set the <strong class="source-inline1">number</strong> and <strong class="source-inline1">publish_period</strong> parameters for the <strong class="source-inline1">number_publisher</strong> node:</p>
			<pre class="source-code">
&lt;node pkg="my_py_pkg" exec="number_publisher"&gt;
    &lt;param name="number" value="3" /&gt;
    &lt;param name="publish_period" value="1.5" /&gt;
&lt;/node&gt;</pre>			<p class="calibre3">It will work the same as adding <strong class="source-inline1">-p &lt;parameter&gt;:=&lt;value&gt;</strong> after the <strong class="source-inline1">ros2 </strong><strong class="source-inline1">run</strong> command.</p>
			<p class="calibre3">Now, you <a id="_idIndexMarker627" class="pcalibre calibre4 pcalibre1"/>can combine renaming, remapping, and setting parameters. Let’s add parameters to the previous example:</p>
			<pre class="source-code">
&lt;node pkg="my_py_pkg" exec="number_publisher" name="num_pub1"&gt;
    &lt;remap from="/number" to="/my_number" /&gt;
    &lt;param name="number" value="3" /&gt;
    &lt;param name="publish_period" value="1.5" /&gt;
&lt;/node&gt;</pre>			<p class="calibre3">In a Python launch file, you need to add a list of dictionaries in the <strong class="source-inline1">Node</strong> object:</p>
			<pre class="source-code">
number_publisher1 = Node(
    package="my_py_pkg",
    executable="number_publisher",
    name="num_pub1",
    remappings=[("/number", "/my_number")],
    parameters=[
        {"number": 3},
        {"publish_period": 1.5}
    ]
)</pre>			<p class="calibre3">Setting <a id="_idIndexMarker628" class="pcalibre calibre4 pcalibre1"/>each parameter’s value like this will work <a id="_idIndexMarker629" class="pcalibre calibre4 pcalibre1"/>fine if you only have a handful of parameters. For bigger numbers, it’s more suitable to use a YAML file.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Do not <a id="_idIndexMarker630" class="pcalibre calibre4 pcalibre1"/>confuse YAML param files with YAML launch files. Launch files can be written in Python, XML, and YAML (though we didn’t use YAML in this book). Any of <a id="_idIndexMarker631" class="pcalibre calibre4 pcalibre1"/>those launch files can include YAML param files, to ad<a id="_idTextAnchor474" class="pcalibre calibre4 pcalibre1"/>d parameters’ values for the nodes in the launch file.</p>
			<h3 class="calibre8">Installing and loading a YAML param file in a launch file</h3>
			<p class="calibre3">To <a id="_idIndexMarker632" class="pcalibre calibre4 pcalibre1"/>provide parameters’ values using a <a id="_idIndexMarker633" class="pcalibre calibre4 pcalibre1"/>YAML file, you will need to follow this process:</p>
			<ol class="calibre11">
				<li class="calibre10">Create a YAML file with the values.</li>
				<li class="calibre10">Install this file inside the <code>_bringup</code> package.</li>
				<li class="calibre10">Load the YAML file in your launch file (we will do that with XML and then Python).</li>
			</ol>
			<p class="calibre3">For this <a id="_idIndexMarker634" class="pcalibre calibre4 pcalibre1"/>example, we are going to reuse <a id="_idIndexMarker635" class="pcalibre calibre4 pcalibre1"/>the <strong class="source-inline1">number_params.yaml</strong> file that we created in <a href="B22403_08.xhtml#_idTextAnchor394" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 8</em></a>. In this file, you can find the following code:</p>
			<pre class="source-code">
/num_pub1:
  ros__parameters:
    number: 3
    publish_period: 0.5
/num_pub2:
  ros__parameters:
    number: 4
    publish_period: 1.0</pre>			<p class="calibre3">This will perfectly match the nodes that we launched in the previous example, as the names are exactly the same.</p>
			<p class="calibre3">Now, what we have done so far is just provide the path to the file when starting a node with <strong class="source-inline1">ros2 run</strong>. To use the YAML param file inside a launch file, we will need to install it in the package.</p>
			<p class="calibre3">To do <a id="_idIndexMarker636" class="pcalibre calibre4 pcalibre1"/>that, create a new directory inside <a id="_idIndexMarker637" class="pcalibre calibre4 pcalibre1"/>the <strong class="source-inline1">my_robot_bringup</strong> package. You could choose any name for that directory, but we will follow a common convention and name it <strong class="source-inline1">config</strong>:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_robot_bringup/
$ mkdir config</pre>			<p class="calibre3">Put the <strong class="source-inline1">number_params.yaml</strong> file inside this <strong class="source-inline1">config</strong> directory. This is where you will also <a id="_idIndexMarker638" class="pcalibre calibre4 pcalibre1"/>put all other YAML param files for this application.</p>
			<p class="calibre3">Now, to <a id="_idIndexMarker639" class="pcalibre calibre4 pcalibre1"/>write instructions to install this directory (and all the YAML files inside), open the <strong class="source-inline1">CMakeLists.txt</strong> file of the <strong class="source-inline1">my_robot_bringup</strong> package and add one line:</p>
			<pre class="source-code">
install(DIRECTORY
  launch
  <strong class="bold1">config</strong>
  DESTINATION share/${PROJECT_NAME}/
)</pre>			<p class="calibre3">You only need to do this once. Any other file inside the <strong class="source-inline1">config</strong> directory will be installed when running <strong class="source-inline1">colcon build</strong> for that package.</p>
			<p class="calibre3">Before we build the package, let’s modify the launch file so that we can use this YAML param file. The way to do this in XML is easy. You will add a <strong class="source-inline1">&lt;param&gt;</strong> tag, but instead of <strong class="source-inline1">name</strong> and <strong class="source-inline1">value</strong>, you need to specify a <strong class="source-inline1">from</strong> argument:</p>
			<pre class="source-code">
&lt;node pkg="my_py_pkg" exec="number_publisher" name="num_pub2"&gt;
    &lt;remap from="/number" to="/my_number" /&gt;
    &lt;param from="$(find-pkg-share             my_robot_bringup)/config/number_params.yaml" /&gt;
&lt;/node&gt;</pre>			<p class="calibre3">As we’ve <a id="_idIndexMarker640" class="pcalibre calibre4 pcalibre1"/>seen previously in this chapter, <strong class="source-inline1">$(find-pkg-share &lt;package_name&gt;)</strong> will locate the installation folder for <a id="_idIndexMarker641" class="pcalibre calibre4 pcalibre1"/>that package. Then, you only need to finish with the relative path to the file you want to retrieve.</p>
			<p class="calibre3">To test this, first build your package. This will install the YAML param files and the launch files. Then, source your environment and start the XML launch file.</p>
			<p class="calibre3">That’s it <a id="_idIndexMarker642" class="pcalibre calibre4 pcalibre1"/>for parameters. Let’s now see the <a id="_idIndexMarker643" class="pcalibre calibre4 pcalibre1"/>Python version. In your launch file, add the following imports:</p>
			<pre class="source-code">
from ament_index_python.packages import get_package_share_directory
import os</pre>			<p class="calibre3">Then, retrieve the YAML file:</p>
			<pre class="source-code">
param_config = os.path.join(
    get_package_share_directory("my_robot_bringup"),
    "config", "number_params.yaml")</pre>			<p class="calibre3">Finally, load the configuration into the node:</p>
			<pre class="source-code">
number_publisher2 = Node(
    ...
    parameters=[param_config]
)</pre>			<p class="calibre3">With this, you should be able to start any node you want with any number of parameters without having any scaling issues.</p>
			<p class="calibre3">Let’s now finish this section with namespaces. I have briefly mentioned them a few times during this book. As you now have a better understanding of how names work in ROS 2, and as namespaces are especia<a id="_idTextAnchor475" class="pcalibre calibre4 pcalibre1"/>lly useful in launch files, this is a good time to start with them.</p>
			<h2 id="_idParaDest-228" class="calibre6"><a id="_idTextAnchor476" class="pcalibre calibre4 pcalibre1"/>Namespaces</h2>
			<p class="calibre3">Namespaces are quite common in programming, and you are probably already familiar with them. With a namespace, you can group some functionalities (variables, functions, and so on) inside one <em class="italic">container</em> that has a name. This can help you better organize your code and avoid name conflicts.</p>
			<p class="calibre3">In ROS, namespaces <a id="_idIndexMarker644" class="pcalibre calibre4 pcalibre1"/>are also quite practical. Let’s say you want to start an application that contains two identical robots, but you want to be able to control each robot independently. Instead of renaming the nodes, topics, services, and actions for each robot, you could just add a namespace.</p>
			<p class="calibre3">If you have a node named <strong class="source-inline1">robot_controller</strong> and a topic named <strong class="source-inline1">cmd_vel</strong>, then those can become <strong class="source-inline1">/robot1/robot_controller</strong> and <strong class="source-inline1">/robot1/cmd_vel</strong> for the first robot. For the second robot, this would be <strong class="source-inline1">/robot2/robot_controller</strong> and <strong class="source-inline1">/robot2/cmd_vel</strong>. This way, the two robots are still running on the same application, but you make sure that the velocity command for each robot is independent.</p>
			<p class="calibre3">As you make progress with ROS 2 and learn new stacks and plugins, you will encounter namespaces everywhere. Let’s now see how to work with namespaces. As we have not done this previously, we will first use namespaces wi<a id="_idTextAnchor477" class="pcalibre calibre4 pcalibre1"/>th the <strong class="source-inline1">ros2 run</strong> command line, and then add them in our launch file.</p>
			<h3 class="calibre8">Starting a node inside a namespace</h3>
			<p class="calibre3">Adding a <a id="_idIndexMarker645" class="pcalibre calibre4 pcalibre1"/>namespace to a node is quite straightforward.</p>
			<p class="calibre3">First of all, after the <strong class="source-inline1">ros2 run &lt;package&gt; &lt;executable&gt;</strong> command, you add <strong class="source-inline1">--ros-args</strong> once. Then, to specify a namespace, you will write <strong class="source-inline1">-r __ns:=&lt;namespace&gt;</strong>. The <strong class="source-inline1">-r</strong> option (or <strong class="source-inline1">--remap</strong>) is the same as the one for renaming a node, only instead of <strong class="source-inline1">__node</strong>, you use <strong class="source-inline1">__ns</strong> here.</p>
			<p class="calibre3">Let’s start our <strong class="source-inline1">number_publisher</strong> node inside a <strong class="source-inline1">/</strong><strong class="source-inline1">abc</strong> namespace:</p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -r __ns:=/abc [INFO] [1716981935.646395625] [abc.number_publisher]: Number publisher has been started.</pre>			<p class="calibre3">After this, you can check what the node and topic names are:</p>
			<pre class="console">
$ ros2 node list
/abc/number_publisher
$ ros2 topic list
/abc/number
/parameter_events
/rosout</pre>			<p class="calibre3">As you <a id="_idIndexMarker646" class="pcalibre calibre4 pcalibre1"/>can see, <strong class="source-inline1">/abc</strong> was added to the node name but also to the topic name—if you have services and actions, the namespace will be equally applied.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The namespace was successfully applied because the topic name defined in the code is <code>number</code> without any leading slash. If you had written <code>/number</code> in the code, then the topic would have been considered to be in the <em class="italic">global</em> scope or namespace. Adding a namespace to the node will change the node name but not the topic name. Thus, pay attention to this when defining communication (topic, service, action) names in your code.</p>
			<p class="calibre3">Now, as the topic name is <strong class="source-inline1">/abc/number</strong>, if we want to start the <strong class="source-inline1">number_counter</strong> node and receive some data, we need to either rename the topic or also add a namespace to the node:</p>
			<pre class="console">
$ ros2 run my_cpp_pkg number_counter --ros-args -r __ns:=/abc
[abc.number_counter]: Number Counter has been started.
[abc.number_counter]: Counter: 2
[abc.number_counter]: Counter: 4</pre>			<p class="calibre3">When adding namespaces, name mismatches can become a frequent issue. One of the best ways to verify that things are working is to run <strong class="source-inline1">rqt_graph</strong>:</p>
			<div><div><img alt="Figure 9.3 – Double-checking namespaces with rqt_graph" src="img/B22403_09_3.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Double-checking namespaces with rqt_graph</p>
			<p class="calibre3">With this, you <a id="_idIndexMarker647" class="pcalibre calibre4 pcalibre1"/>can see that both nodes are publishing or subscribing to the <strong class="source-inline1">/</strong><strong class="source-inline1">abc/number</strong> topic.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can combine any type of renaming. For example, you could both add a namespace and rename the node: <code>$ ros2 run my_py_pkg number_publisher --ros-args -r __ns:=/abc -</code><code>r __node:=num_pub</code>.</p>
			<p class="calibre3">Now that you know how to provide a namespace <a id="_idTextAnchor478" class="pcalibre calibre4 pcalibre1"/>for a node at runtime, let’s see how to do this inside a launch file.</p>
			<h3 class="calibre8">Specifying a namespace in a launch file</h3>
			<p class="calibre3">To add a <a id="_idIndexMarker648" class="pcalibre calibre4 pcalibre1"/>namespace to a node in an XML launch file, you just have to add a <strong class="source-inline1">namespace</strong> argument inside the <strong class="source-inline1">&lt;node&gt;</strong> tag. Let’s continue with our previous example:</p>
			<pre class="source-code">
&lt;node pkg="my_py_pkg" exec="number_publisher" name="num_pub1" <strong class="bold1">namespace="/abc"</strong>&gt;</pre>			<p class="calibre3">For Python, the syntax is also quite easy; here too, you just need to add a <strong class="source-inline1">namespace</strong> argument inside the <strong class="source-inline1">Node</strong> object:</p>
			<pre class="source-code">
number_publisher1 = Node(
    package="my_py_pkg",
    executable="number_publisher",
    <strong class="bold1">namespace="/abc",</strong>
    name="num_pub1",
    ...</pre>			<p class="calibre3">If you add a namespace to this node, you will also add the same namespace to nodes that are directly communicating with it:</p>
			<pre class="source-code">
&lt;node pkg="my_py_pkg" exec="number_publisher" name="num_pub1" <strong class="bold1">namespace="/abc"</strong>&gt;
...
&lt;node pkg="my_cpp_pkg" exec="number_counter" <strong class="bold1">namespace="/abc"</strong>&gt;</pre>			<p class="calibre3">Adding namespaces to nodes in a launch file is quite straightforward. However, there is one important thing you need to pay attention to. If you are using YAML param files, you also need to specify the namespace in the YAML file. Open the <strong class="source-inline1">number_params.yaml</strong> file and add the namespace to the node name:</p>
			<pre class="source-code">
<strong class="bold1">/abc</strong>/num_pub2:
 ros__parameters:
   number: 4
   publish_period: 1.0</pre>			<p class="calibre3">If you don’t do this, the parameters will be applied to the <strong class="source-inline1">/num_pub2</strong> node, which doesn’t exist, since it’s named <strong class="source-inline1">/abc/num_pub2</strong>. This can be a common source of errors, so make sure you double-check param files when adding namespaces.</p>
			<p class="calibre3">After all those modifications, make sure to build the <strong class="source-inline1">my_robot_bringup</strong> package again and <a id="_idIndexMarker649" class="pcalibre calibre4 pcalibre1"/>source the environment before you start any launch file.</p>
			<p class="calibre3">You have now seen a few ways to configure your nodes inside a launch file. With this base knowledge, you can already scale your application a lot. Let’s finish this <a id="_idTextAnchor479" class="pcalibre calibre4 pcalibre1"/>chapter with a new challenge so that you can practice more on your own.</p>
			<h1 id="_idParaDest-229" class="calibre6"><a id="_idTextAnchor480" class="pcalibre calibre4 pcalibre1"/>Launch file challenge</h1>
			<p class="calibre3">In this challenge, you will practice more with launch files, YAML param files, remappings, and namespaces. This will be the conclusion of <em class="italic">Part 2</em>. To complete this chal<a id="_idTextAnchor481" class="pcalibre calibre4 pcalibre1"/>lenge, you can decide to write the launch file in XML, Python, or both.</p>
			<h2 id="_idParaDest-230" class="calibre6"><a id="_idTextAnchor482" class="pcalibre calibre4 pcalibre1"/>Challenge</h2>
			<p class="calibre3">What we want <a id="_idIndexMarker650" class="pcalibre calibre4 pcalibre1"/>to do here is to start two <strong class="source-inline1">turtlesim</strong> windows, each one <a id="_idIndexMarker651" class="pcalibre calibre4 pcalibre1"/>with one turtle. Then, for each turtle, we run a <strong class="source-inline1">turtle_controller</strong> node (the one we have been developing throughout the previous chapters).</p>
			<p class="calibre3">The goal is to have each <strong class="source-inline1">turtle_controller</strong> node controlling only one turtle. This is what the result should look like:</p>
			<div><div><img alt="Figure 9.4 – Two  different turtles with two independent controllers" src="img/B22403_09_4.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Two different turtles with two independent controllers</p>
			<p class="calibre3">For each <a id="_idIndexMarker652" class="pcalibre calibre4 pcalibre1"/>turtle, we will apply different settings (parameters):</p>
			<ul class="calibre9">
				<li class="calibre10">First <code>turtlesim</code> window:<ul class="calibre12"><li class="calibre10"><code>128</code> for the RGB value)</li></ul></li>
				<li class="calibre10">First <a id="_idIndexMarker653" class="pcalibre calibre4 pcalibre1"/>controller:<ul class="calibre12"><li class="calibre10"><code>1.5</code></li></ul></li>
				<li class="calibre10">Second <code>turtlesim</code> window:<ul class="calibre12"><li class="calibre10"><code>128</code> for the RGB value)</li></ul></li>
				<li class="calibre10">Second controller:<ul class="calibre12"><li class="calibre10"><code>0.5</code></li></ul></li>
			</ul>
			<p class="calibre3">Here are the steps you can take:</p>
			<ol class="calibre11">
				<li class="calibre10">Create a <code>turtle_params.yaml</code> file with the parameters for each node. Install this in the <code>my_robot_bringup</code> package.</li>
				<li class="calibre10">Create a new <a id="_idIndexMarker654" class="pcalibre calibre4 pcalibre1"/>launch file and start the four nodes. Load <a id="_idIndexMarker655" class="pcalibre calibre4 pcalibre1"/>the parameters from the YAML param file. Put the different nodes into appropriate namespaces (to keep it simple, use <code>t1</code> and <code>t2</code> for <code>turtle1</code> and <code>turtle2</code>, respectively).</li>
				<li class="calibre10">Build, source, and start the launch file. You will see that some topics and services are not matching, and thus you will know what remappings you need to add.</li>
			</ol>
			<p class="calibre3">To make it easier, start with just one pair of nodes (<strong class="source-inline1">turtlesim</strong> and <strong class="source-inline1">turtle_controller</strong>), and then add another pair when it’s working.</p>
			<p class="calibre3">Here is an important point for this challenge: we will not modify any of the existing code—even if it would make things easier. The goal is to take the nodes exactly as they are (use the code from the <strong class="source-inline1">ch8</strong> folder in the repo) and make things work using ap<a id="_idTextAnchor483" class="pcalibre calibre4 pcalibre1"/>propriate namespaces and remappings in the launch file and YAML param file.</p>
			<h2 id="_idParaDest-231" class="calibre6"><a id="_idTextAnchor484" class="pcalibre calibre4 pcalibre1"/>Solution</h2>
			<p class="calibre3">Create a <a id="_idIndexMarker656" class="pcalibre calibre4 pcalibre1"/>new file named <strong class="source-inline1">turtle_params.yaml</strong>, inside the <strong class="source-inline1">config</strong> directory of the <strong class="source-inline1">my_robot_bringup</strong> package. As a base, you can take the <a id="_idIndexMarker657" class="pcalibre calibre4 pcalibre1"/>one that we did in the parameter challenge for <a href="B22403_08.xhtml#_idTextAnchor394" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 8</em></a>.</p>
			<p class="calibre3">In this file, we will add parameters for all four nodes. Before we do this, we need to know exactly what will be the name for each node, including the namespaces.</p>
			<p class="calibre3">With the <strong class="source-inline1">t1</strong> and <strong class="source-inline1">t2</strong> namespaces, if we just add a namespace and we don’t rename the nodes, we will then have these names:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>/</code><code>t1/turtlesim</code></li>
				<li class="calibre10"><code>/</code><code>t2/turtlesim</code></li>
				<li class="calibre10"><code>/</code><code>t1/turtle_controller</code></li>
				<li class="calibre10"><code>/</code><code>t2/turtle_controller</code></li>
			</ul>
			<p class="calibre3">After <a id="_idIndexMarker658" class="pcalibre calibre4 pcalibre1"/>making this <a id="_idIndexMarker659" class="pcalibre calibre4 pcalibre1"/>choice, we can write the YAML param file:</p>
			<pre class="source-code">
/t1/turtlesim:
  ros__parameters:
    background_r: 128
    background_g: 0
    background_b: 0
/t2/turtlesim:
  ros__parameters:
    background_r: 0
    background_g: 128
    background_b: 0
/t1/turtle_controller:
  ros__parameters:
    color_1: [0, 0, 0]
    color_2: [255, 255, 255]
    turtle_velocity: 1.5
/t2/turtle_controller:
  ros__parameters:
    color_1: [255, 255, 255]
    color_2: [0, 0, 0]
    turtle_velocity: 0.5</pre>			<p class="calibre3">This contains all the configurations given in the challenge. Now, create a new launch file (for example, <strong class="source-inline1">turtlesim_control.launch.xml</strong>) inside the <strong class="source-inline1">launch</strong> directory.</p>
			<p class="calibre3">In this <a id="_idIndexMarker660" class="pcalibre calibre4 pcalibre1"/>launch file, let’s start with something simple. We want <a id="_idIndexMarker661" class="pcalibre calibre4 pcalibre1"/>to try to run one <strong class="source-inline1">turtlesim</strong> node and one <strong class="source-inline1">turtle_controller</strong> node, using the <strong class="source-inline1">t1</strong> namespace:</p>
			<pre class="source-code">
&lt;launch&gt;
    &lt;node pkg="turtlesim" exec="turtlesim_node" namespace="t1"&gt;
        &lt;param from="$(find-pkg-share             my_robot_bringup)/config/turtle_params.yaml" /&gt;
    &lt;/node&gt;
    &lt;node pkg="turtle_controller" exec="turtle_controller" namespace="t1"&gt;
        &lt;param from="$(find-pkg-share             my_robot_bringup)/config/turtle_params.yaml" /&gt;
    &lt;/node&gt;
&lt;/launch&gt;</pre>			<p class="calibre3">As we are starting nodes from the <strong class="source-inline1">turtlesim</strong> and <strong class="source-inline1">turtle_controller</strong> packages, we also add two new <strong class="source-inline1">&lt;exec_depend&gt;</strong> tags in the <strong class="source-inline1">package.xml</strong> file:</p>
			<pre class="source-code">
&lt;exec_depend&gt;turtlesim&lt;/exec_depend&gt;
&lt;exec_depend&gt;turtle_controller&lt;/exec_depend&gt;</pre>			<p class="calibre3">Now, if you launch this (make sure to build and source first), you will see the <strong class="source-inline1">turtlesim</strong> node, but the turtle won’t move. Why is that?</p>
			<p class="calibre3">If you look at the topic list, you will find these two topics:</p>
			<pre class="console">
$ ros2 topic list
/t1/turtle1/cmd_vel
/turtle1/cmd_vel</pre>			<p class="calibre3">With <strong class="source-inline1">rqt_graph</strong>, you can also see that the <strong class="source-inline1">turtlesim</strong> node is subscribing to <strong class="source-inline1">/t1/turtle1/cmd_vel</strong>, but the <strong class="source-inline1">turtle_controller</strong> node is publishing on <strong class="source-inline1">/turtle1/cmd_vel</strong>. Why did the namespace work for the node name but not for the topic name?</p>
			<p class="calibre3">This is because we wrote <strong class="source-inline1">/turtle1/cmd_vel</strong> in the code, and not <strong class="source-inline1">turtle1/cmd_vel</strong>. The fact that we added a leading slash makes the namespace the <em class="italic">global</em> namespace. Thus, if you try to add a namespace to that, it will not be taken into account.</p>
			<p class="calibre3">We have <a id="_idIndexMarker662" class="pcalibre calibre4 pcalibre1"/>two options here: either we modify the code (we simply need to remove this leading slash) or we adapt the launch file to make this work. As specified in the challenge instructions, we are not going to modify the code. The reason <a id="_idIndexMarker663" class="pcalibre calibre4 pcalibre1"/>why I’m adding this constraint is because, in real life, you won’t necessarily be able to modify the code of the nodes you run. Thus, knowing how to solve a name mismatch without touching the code is a great skill to have.</p>
			<p class="calibre3">So, if you look at the topic and service names (we don’t use actions here), you will see that we have two topics and one service to modify. Let’s add some <strong class="source-inline1">&lt;remap&gt;</strong> tags inside the node:</p>
			<pre class="source-code">
&lt;node pkg="turtle_controller" exec="turtle_controller" namespace="t1"&gt;
    &lt;param from="$(find-pkg-share             my_robot_bringup)/config/turtle_params.yaml" /&gt;
    &lt;remap from="/turtle1/pose" to="/t1/turtle1/pose" /&gt;
    &lt;remap from="/turtle1/cmd_vel" to="/t1/turtle1/cmd_vel" /&gt;
    &lt;remap from="/turtle1/set_pen" to="/t1/turtle1/set_pen" /&gt;
&lt;/node&gt;</pre>			<p class="calibre3">You can now start the launch file, and you will see the turtle moving. Now that we have this working, adding a second pair of nodes is easy. We basically need to copy/paste the two nodes and replace <strong class="source-inline1">t1</strong> with <strong class="source-inline1">t2</strong>:</p>
			<pre class="source-code">
&lt;node pkg="turtlesim" exec="turtlesim_node" namespace="t2"&gt;
    &lt;param from="$(find-pkg-share             my_robot_bringup)/config/turtle_params.yaml" /&gt;
&lt;/node&gt;
&lt;node pkg="turtle_controller" exec="turtle_controller" namespace="t2"&gt;
    &lt;param from="$(find-pkg-share             my_robot_bringup)/config/turtle_params.yaml" /&gt;
    &lt;remap from="/turtle1/pose" to="/t2/turtle1/pose" /&gt;
    &lt;remap from="/turtle1/cmd_vel" to="/t2/turtle1/cmd_vel" /&gt;
    &lt;remap from="/turtle1/set_pen" to="/t2/turtle1/set_pen" /&gt;
&lt;/node&gt;</pre>			<p class="calibre3">The challenge <a id="_idIndexMarker664" class="pcalibre calibre4 pcalibre1"/>is now complete. If you start this launch file, you will <a id="_idIndexMarker665" class="pcalibre calibre4 pcalibre1"/>see two <strong class="source-inline1">turtlesim</strong> windows, each one containing a turtle that moves at a different speed and using different pen colors.</p>
			<p class="calibre3">You can find the complete code and pa<a id="_idTextAnchor485" class="pcalibre calibre4 pcalibre1"/>ckage organization in the book’s GitHub repository (including the Python launch file).</p>
			<h1 id="_idParaDest-232" class="calibre6"><a id="_idTextAnchor486" class="pcalibre calibre4 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, you worked on ROS 2 launch files. Launch files allow you to properly scale your application with multiple nodes, parameters, and sets of configuration.</p>
			<p class="calibre3">You can write a launch file in Python, XML, or YAML. Here, you discovered the Python and XML syntax and saw that XML is probably the best choice by default. The syntax is much easier, and the code is much shorter. If you ever need to combine XML and Python launch files, you can do so by including a launch file in another one.</p>
			<p class="calibre3">The best practice is to set up a dedicated package for launch files and YAML files. You can name the package using the <strong class="source-inline1">_bringup</strong> suffix. Launch files will be installed in a <strong class="source-inline1">launch</strong> folder, and YAML param files in a <strong class="source-inline1">config</strong> folder.</p>
			<p class="calibre3">If you correctly understand how to start nodes with the <strong class="source-inline1">ros2 run command</strong>, then doing so in a launch file is pretty straightforward: you just need to provide the package and executable name for each node. The only thing to learn is the XML or Python syntax.</p>
			<p class="calibre3">In a launch file, you can also configure your nodes in multiple ways:</p>
			<ul class="calibre9">
				<li class="calibre10">Renaming the node and/or adding a namespace</li>
				<li class="calibre10">Remapping topics, services, and actions</li>
				<li class="calibre10">Adding parameters, individually or from a YAML param file</li>
			</ul>
			<p class="calibre3">This is what we have seen so far, but there are many other ways to configure your nodes that you will discover throughout your ROS 2 learning journey.</p>
			<p class="calibre3"><em class="italic">Part 2</em> of this book is now finished. You have discovered all the core concepts that will allow you to write complete ROS 2 applications and join existing ROS 2 projects. You should now be able to interact with any ROS 2 node, write code to communicate with it, and scale your application with parameters and launch files.</p>
			<p class="calibre3">Now, this part was heavily focused on programming (Python and C++), which is incredibly important, but ROS 2 is more than just that. In <em class="italic">Part 3</em>, we will dive into some additional concepts and tools (<strong class="bold">TransForms</strong> (<strong class="bold">TFs</strong>), <strong class="bold">Unified Robot Description Format</strong> (<strong class="bold">URDF</strong>), <strong class="bold">Gazebo</strong>) so that you can design a custom application for a robot, including a 3D simulation. This, combined with the programming we did in <em class="italic">Part 2</em>, will be the backbone of any ROS 2 application you work on.</p>
		</div>
	</body></html>