<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Strings and Serialization</h1>
                </header>
            
            <article>
                
<p>Before we get involved with higher-level design patterns, let's take a deep dive into one of Python's most common objects: the string. We'll see that there is a lot more to the string than meets the eye, and also cover searching strings for patterns, and serializing data for storage or transmission.</p>
<p>In particular, we'll look at the following topics:</p>
<ul>
<li>The complexities of strings, bytes, and byte arrays</li>
<li>The ins and outs of string formatting</li>
<li>A few ways to serialize data</li>
<li>The mysterious regular expression</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strings</h1>
                </header>
            
            <article>
                
<p>Strings are a basic primitive in Python; we've used them in nearly every example we've discussed so far. All they do is represent an immutable sequence of characters. However, though you may not have considered it before, <em>character</em> is a bit of an ambiguous word; can Python strings represent sequences of accented characters? Chinese characters? What about Greek, Cyrillic, or Farsi?</p>
<p>In Python 3, the answer is yes. Python strings are all represented in Unicode, a character definition standard that can represent virtually any character in any language on the planet (and some made-up languages and random characters as well). This is done seamlessly. So, let's think of Python 3 strings as an immutable sequence of Unicode characters. We've touched on many of the ways strings can be manipulated in previous examples, but let's quickly cover it all in one place: a crash course in string theory!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">String manipulation</h1>
                </header>
            
            <article>
                
<p>As you know, strings can be created in Python by wrapping a sequence of characters in single or double quotes. Multiline strings can easily be created using three quote characters, and multiple hardcoded strings can be concatenated together by placing them side by side. Here are some examples:</p>
<pre>a = "hello" 
b = 'world' 
c = '''a multiple 
line string''' 
d = """More 
multiple""" 
e = ("Three " "Strings " 
        "Together") </pre>
<p>That last string is automatically composed into a single string by the interpreter. It is also possible to concatenate strings using the <kbd>+</kbd> operator (as in <kbd>"hello " + "world"</kbd>). Of course, strings don't have to be hardcoded. They can also come from various outside sources, such as text files, user input, or can be encoded on the network.</p>
<div class="packt_tip">The automatic concatenation of adjacent strings can make for some hilarious bugs when a comma is missed. It is, however, extremely useful when a long string needs to be placed inside a function call without exceeding the 79 - character line-length limit suggested by the Python style guide.</div>
<p>Like other sequences, strings can be iterated over (character by character), indexed, sliced, or concatenated. The syntax is the same as for lists.</p>
<p>The <kbd>str</kbd> class has numerous methods on it to make manipulating strings easier. The <kbd>dir</kbd> and <kbd>help</kbd> commands in the Python interpreter can tell us how to use all of them; we'll consider some of the more common ones directly.</p>
<p>Several Boolean convenience methods help us identify whether or not the characters in a string match a certain pattern. Here is a summary of these methods. Most of these, such as <kbd>isalpha</kbd>, <kbd>isupper</kbd>/<kbd>islower</kbd>, and <kbd>startswith</kbd>/<kbd>endswith</kbd>, have obvious interpretations. The <kbd>isspace</kbd> method is also fairly obvious, but remember that all whitespace characters (including tab and newline) are considered, not just the space character.</p>
<p>The <kbd>istitle</kbd> method returns <kbd>True</kbd> if the first character of each word is capitalized and all other characters are lowercase. Note that it does not strictly enforce the English grammatical definition of title formatting. For example, Leigh Hunt's poem <em>The Glove and the Lions</em> should be a valid title, even though not all words are capitalized. Robert Service's <em>The Cremation of Sam McGee</em> should also be a valid title, even though there is an uppercase letter in the middle of the last word.</p>
<p>Be careful with the <kbd>isdigit</kbd>, <kbd>isdecimal</kbd>, and <kbd>isnumeric</kbd> methods, as they are more nuanced than we would expect. Many Unicode characters are considered numbers besides the 10 digits we are used to. Worse, the period character that we use to construct floats from strings is not considered a decimal character, so <kbd>'45.2'.isdecimal()</kbd> returns <kbd>False</kbd>. The real decimal character is represented by Unicode value 0660, as in 45.2 (or <kbd>45\u06602</kbd>). Further, these methods do not verify whether the strings are valid numbers; <kbd>127.0.0.1</kbd> returns <kbd>True</kbd> for all three methods. We might think we should use that decimal character instead of a period for all numeric quantities, but passing that character into the <kbd>float()</kbd> or <kbd>int()</kbd> constructor converts that decimal character to a zero:</p>
<pre><strong>&gt;&gt;&gt; float('45\u06602')</strong>
<strong>4502.0</strong>  </pre>
<p>The result of all these inconsistencies is that the Boolean numeric checks are not very useful at all. We're usually much better off using a regular expression (discussed later in this chapter) to confirm whether the string matches a specific numeric pattern.</p>
<p>Other methods useful for pattern-matching do not return Booleans. The <kbd>count</kbd> method tells us how many times a given substring shows up in the string, while <kbd>find</kbd>, <kbd>index</kbd>, <kbd>rfind</kbd>, and <kbd>rindex</kbd> tell us the position of a given substring within the original string. The two <kbd>r</kbd> (for <em>right</em> or <em>reverse</em>) methods start searching from the end of the string. The <kbd>find</kbd> methods return <kbd>-1</kbd> if the substring can't be found, while <kbd>index</kbd> raises <kbd>ValueError</kbd> in this situation. Have a look at some of these methods in action:</p>
<pre><strong>&gt;&gt;&gt; s = "hello world"</strong>
<strong>&gt;&gt;&gt; s.count('l')</strong>
<strong>3</strong>
<strong>&gt;&gt;&gt; s.find('l')</strong>
<strong>2</strong>
<strong>&gt;&gt;&gt; s.rindex('m')</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>ValueError: substring not found</strong>  </pre>
<p>Most of the remaining string methods return transformations of the string. The <kbd>upper</kbd>, <kbd>lower</kbd>, <kbd>capitalize</kbd>, and <kbd>title</kbd> methods create new strings with all alphabetical characters in the given format. The <kbd>translate</kbd> method can use a dictionary to map arbitrary input characters to specified output characters.</p>
<p>For all of these methods, note that the input string remains unmodified; a brand new <kbd>str</kbd> instance is returned instead. If we need to manipulate the resultant string, we should assign it to a new variable, as in <kbd>new_value</kbd><kbd>=</kbd><kbd>value.capitalize()</kbd>. Often, once we've performed the transformation, we don't need the old value anymore, so a common idiom is to assign it to the same variable, as in <kbd>value</kbd><kbd>=</kbd><kbd>value.title()</kbd>.</p>
<p>Finally, a couple of string methods return or operate on lists. The <kbd>split</kbd> method accepts a substring and splits the string into a list of strings wherever that substring occurs. You can pass a number as a second parameter to limit the number of resultant strings. The <kbd>rsplit</kbd>method behaves identically to <kbd>split</kbd> if you don't limit the number of strings, but if you do supply a limit, it starts splitting from the end of the string. The <kbd>partition</kbd> and <kbd>rpartition </kbd>methods split the string at only the first or last occurrence of the substring, and return a tuple of three values: characters before the substring, the substring itself, and the characters after the substring.</p>
<p>As the inverse of <kbd>split</kbd>, the <kbd>join</kbd> method accepts a list of strings, and returns all of those strings combined together by placing the original string between them. The <kbd>replace</kbd> method accepts two arguments, and returns a string where each instance of the first argument has been replaced with the second. Here are some of these methods in action:</p>
<pre><strong>&gt;&gt;&gt; s = "hello world, how are you"</strong>
<strong>&gt;&gt;&gt; s2 = s.split(' ')</strong>
<strong>&gt;&gt;&gt; s2</strong>
<strong>['hello', 'world,', 'how', 'are', 'you']</strong>
<strong>&gt;&gt;&gt; '#'.join(s2)</strong>
<strong>'hello#world,#how#are#you'</strong>
<strong>&gt;&gt;&gt; s.replace(' ', '**')</strong>
<strong>'hello**world,**how**are**you'</strong>
<strong>&gt;&gt;&gt; s.partition(' ')</strong>
<strong>('hello', ' ', 'world, how are you')</strong>  </pre>
<p>There you have it, a whirlwind tour of the most common methods on the <kbd>str</kbd> class! Now, let's look at Python 3's method for composing strings and variables to create new strings.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">String formatting</h1>
                </header>
            
            <article>
                
<p>Python 3 has powerful string formatting and templating mechanisms that allow us to construct strings comprised of hardcoded text and interspersed variables. We've used it in many previous examples, but it is much more versatile than the simple formatting specifiers we've used.</p>
<p>A string can be turned into a format string (also called an <strong>f-string</strong>) by prefixing the opening quotation mark with an f, as in <kbd>f"hello world"</kbd>. If such a string contains the special characters  <kbd>{</kbd> and <kbd>}</kbd>, variables from the surrounding scope can be used to replace them as in this example:</p>
<pre>name = "Dusty"<br/>activity = "writing"<br/>formatted = f"Hello {name}, you are currently {activity}."<br/>print(formatted)</pre>
<p>If we run these statements, it replaces the braces with variables, in order:</p>
<pre><strong>Hello Dusty, you are currently writing.</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Escaping braces</h1>
                </header>
            
            <article>
                
<p>Brace characters are often useful in strings, aside from formatting. We need a way to escape them in situations where we want them to be displayed as themselves, rather than being replaced. This can be done by doubling the braces. For example, we can use Python to format a basic Java program:</p>
<pre>classname = "MyClass"<br/>python_code = "print('hello world')"<br/>template = f"""<br/>public class {classname} {{<br/>    public static void main(String[] args) {{<br/>        System.out.println("{python_code}");<br/>    }}<br/>}}"""<br/><br/>print(template)</pre>
<p>Where we see the <kbd>{{</kbd> or <kbd>}}</kbd> sequence in the template<span>—</span>that is, the braces enclosing the Java class and method definition<span>—</span>we know the f-string will replace them with single braces, rather than some argument in the surrounding methods. Here's the output:</p>
<pre><strong>public class MyClass {</strong>
<strong>    public static void main(String[] args) {</strong>
<strong>        System.out.println("print('hello world')");</strong>
<strong>    }</strong>
<strong>}</strong>  </pre>
<p>The class name and contents of the output have been replaced with two parameters, while the double braces have been replaced with single braces, giving us a valid Java file. Turns out, this is about the simplest possible Python program to print the simplest possible Java program that can print the simplest possible Python program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">f-strings can contain Python code</h1>
                </header>
            
            <article>
                
<p>We aren't restricted to passing simple string variables into an f-string method. Any primitives, such as integers or floats, can be formatted. More interestingly, complex objects, including lists, tuples, dictionaries, and arbitrary objects can be used, and we can access indexes and variables or call functions on those objects from within the <kbd>format</kbd> string.</p>
<p>For example, if our email message had grouped the <kbd>From</kbd> and <kbd>To</kbd> email addresses into a tuple, and placed the subject and message in a dictionary, for some reason (perhaps because that's the input required for an existing <kbd>send_mail</kbd> function we want to use), we can format it like this:</p>
<pre>emails = ("a@example.com", "b@example.com")<br/>message = {<br/>    "subject": "You Have Mail!",<br/>    "message": "Here's some mail for you!",<br/>}<br/><br/>formatted = f"""<br/>From: &lt;{emails[0]}&gt;<br/>To: &lt;{emails[1]}&gt;<br/>Subject: {message['subject']}<br/>{message['message']}"""<br/>print(formatted)</pre>
<p>The variables inside the braces in the template string look a little weird, so let's look at what they're doing. The two email addresses are looked up by <kbd>emails[x]</kbd>, where <kbd>x</kbd> is either <kbd>0</kbd> or <kbd>1</kbd>.  The square brackets with a number inside are the same kind of index lookup we see in regular Python code, so <kbd>emails[0]</kbd>  refers to the first item in the <kbd>emails</kbd> tuple. The indexing syntax works with any indexable object, so we see similar behavior when we access <kbd>message[subject]</kbd>, except this time we are looking up a string key in a dictionary. Notice that, unlike in Python code, we do not need to put quotes around the string in the dictionary lookup.</p>
<p>We can even do multiple levels of lookup if we have nested data structures. If we modify the above code to put the <kbd>emails</kbd> tuple inside the <kbd>message</kbd> dictionary, we can use an indexed lookup as follows:</p>
<pre>message["emails"] = emails<br/><br/>formatted = f"""<br/>From: &lt;{message['emails'][0]}&gt;<br/>To: &lt;{message['emails'][1]}&gt;<br/>Subject: {message['subject']}<br/>{message['message']}"""<br/>print(formatted)</pre>
<p>I would recommend against doing this often, as template strings rapidly become difficult to understand.</p>
<p>Alternatively, if you have an object or class, you can execute object lookups or even call methods inside the f-string. Let's change our email message data once again, this time to a class:</p>
<pre>class EMail:<br/>    def __init__(self, from_addr, to_addr, subject, message):<br/>        self.from_addr = from_addr<br/>        self.to_addr = to_addr<br/>        self.subject = subject<br/>        self._message = message<br/><br/>    def message(self):<br/>        return self._message<br/><br/><br/>email = EMail(<br/>    "a@example.com",<br/>    "b@example.com",<br/>    "You Have Mail!",<br/>    "Here's some mail for you!",<br/>)<br/><br/>formatted = f"""<br/>From: &lt;{email.from_addr}&gt;<br/>To: &lt;{email.to_addr}&gt;<br/>Subject: {email.subject}<br/><br/>{email.message()}"""<br/>print(formatted)</pre>
<p>The template in this example may be more readable than the previous examples, but the overhead of creating an <kbd>email</kbd> class adds complexity to the Python code. It would be foolish to create a class for the express purpose of including the object in a template. Typically, we'd use this sort of lookup if the object we are trying to format already exists.</p>
<p>Pretty much any Python code that you would expect to return a string (or a value that can convert to a string with the <kbd>str()</kbd> function) can be executed inside an f-string.  As an example of how powerful it can get, you can even use a list comprehension or ternary operator in a format string parameter:</p>
<pre><strong>&gt;&gt;&gt; f"['a' for a in range(5)]"</strong><br/><strong>"['a' for a in range(5)]"</strong><br/><strong>&gt;&gt;&gt; f"{'yes' if True else 'no'}"</strong><br/><strong>'yes'</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making it look right</h1>
                </header>
            
            <article>
                
<p>It's nice to be able to include variables in template strings, but sometimes the variables need a bit of coercion to make them look the way we want them to in the output. For example, if we are performing calculations with currency, we may end up with a long decimal that we don't want to show up in our template:</p>
<pre>subtotal = 12.32<br/>tax = subtotal * 0.07<br/>total = subtotal + tax<br/><br/>print(<br/>    "Sub: ${0} Tax: ${1} Total: ${total}".format(<br/>        subtotal, tax, total=total<br/>    )<br/>)</pre>
<p>If we run this formatting code, the output doesn't quite look like proper currency:</p>
<pre><strong>Sub: $12.32 Tax: $0.8624 Total: $13.182400000000001</strong></pre>
<div class="packt_infobox">Technically, we should never use floating-point numbers in currency calculations like this; we should construct <kbd>decimal.Decimal()</kbd> objects instead. Floats are dangerous because their calculations are inherently inaccurate beyond a specific level of precision. But we're looking at strings, not floats, and currency is a great example for formatting!</div>
<p>To fix the preceding <kbd>format</kbd> string, we can include some additional information inside the curly braces to adjust the formatting of the parameters. There are tons of things we can customize, but the basic syntax inside the braces is the same. After providing the template value, we include a colon, and then some specific syntax for the formatting. Here's an improved version:</p>
<pre><br/>print(<br/>    "Sub: ${0:0.2f} Tax: ${1:0.2f} "<br/>    "Total: ${total:0.2f}".format(subtotal, tax, total=total)<br/>)<br/><br/></pre>
<p>The <kbd>0.2f</kbd> format specifier after the colons basically says the following, from left to right:</p>
<ul>
<li><kbd>0</kbd>: for values lower than one, make sure a zero is displayed on the left-hand of the decimal point</li>
<li><kbd>.</kbd>: show a decimal point</li>
<li><kbd>2</kbd>: show two places after the decimal</li>
<li><kbd>f</kbd>: format the input value as a float</li>
</ul>
<p>We can also specify that each number should take up a particular number of characters on the screen by placing a value before the period. This can be useful for outputting tabular data, for example:</p>
<pre>orders = [("burger", 2, 5), ("fries", 3.5, 1), ("cola", 1.75, 3)]<br/><br/>print("PRODUCT QUANTITY PRICE SUBTOTAL")<br/>for product, price, quantity in orders:<br/>    subtotal = price * quantity<br/>    print(<br/><strong>        f"{product:10s}{quantity: ^9d} "</strong><br/><strong>        f"${price: &lt;8.2f}${subtotal: &gt;7.2f}"</strong><br/>    )</pre>
<p>OK, that's a pretty scary-looking format string, so let's see how it works before we break it down into understandable parts:</p>
<pre><strong>PRODUCT    QUANTITY    PRICE    SUBTOTAL</strong>
<strong>burger        5        $2.00    $  10.00</strong>
<strong>fries         1        $3.50    $   3.50</strong>
<strong>cola          3        $1.75    $   5.25</strong>  </pre>
<p>Nifty! So, how is this actually happening? We have four variables we are formatting, in each line of the <kbd>for</kbd> loop. The first variable is a string that is formatted with <kbd>{product:10s}</kbd>. This one is easier to read from right to left:</p>
<ul>
<li> <kbd>s</kbd> means it is a string variable.</li>
<li><kbd>10</kbd> means it should take up 10 characters. By default, with strings, if the string is shorter than the specified number of characters, it appends spaces to the right-hand side of the string to make it long enough (beware, however: if the original string is too long, it won't be truncated!).</li>
<li><kbd>product:</kbd>, of course, is the name of the variable or Python expression being formatted.</li>
</ul>
<p>The formatter for the <kbd>quantity</kbd> value is<kbd>{quantity: ^9d}</kbd>. You can interpret this format from right to left as follows:</p>
<ul>
<li><kbd>d</kbd> represents an integer value.</li>
<li><kbd>9</kbd> tells us the value should take up nine characters on the screen.</li>
<li><kbd>^</kbd> tells us that the number should be aligned in the center of this available padding; this makes the column look a bit more professional.</li>
<li>(space) tells the formatter to use a space as the padding character. With integers, instead of spaces, the extra characters are zeros, by default.</li>
<li><kbd>quantity:</kbd> is the variable being formatted.</li>
</ul>
<p>All these specifiers have to be in the right order, although all are optional: fill first, then align, then the size, and finally, the type.</p>
<p>We do similar things with the specifiers for <kbd>price</kbd> and <kbd>subtotal</kbd>. For <kbd>price</kbd>, we use <kbd>{2:</kbd><kbd>&lt;8.2f}</kbd>; and for <kbd>subtotal</kbd>, <kbd>{3:</kbd><kbd>&gt;7.2f}</kbd>. In both cases, we're specifying a space as the fill character, but we use the <kbd>&lt;</kbd> and <kbd>&gt;</kbd> symbols, respectively, to represent that the numbers should be aligned to the left or right within a minimum space of eight or seven characters. Further, each float should be formatted to two decimal places.</p>
<p>The <em>type</em> character for different types can affect formatting output as well. We've seen the <kbd>s</kbd>, <kbd>d</kbd>, and <kbd>f</kbd> types, for strings, integers, and floats. Most of the other format specifiers are alternative versions of these; for example, <kbd>o</kbd> represents octal format and <kbd>X</kbd> represents hexadecimal if formatting integers. The <kbd>n</kbd> type specifier can be useful for formatting integer separators in the current locale's format. For floating-point numbers, the <kbd>%</kbd> type will multiply by 100 and format a float as a percentage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom formatters</h1>
                </header>
            
            <article>
                
<p>While these standard formatters apply to most built-in objects, it is also possible for other objects to define nonstandard specifiers. For example, if we pass a <kbd>datetime</kbd> object into <kbd>format</kbd>, we can use the specifiers used in the <kbd>datetime.strftime</kbd> function, as follows:</p>
<pre>import datetime 
print("{the_date:%Y-%m-%d %I:%M%p }".format( 
    datetime.datetime.now())) </pre>
<p>It is even possible to write custom formatters for objects we create ourselves, but that is beyond the scope of this book. Look into overriding the <kbd>__format__</kbd> special method if you need to do this in your code.</p>
<p>The Python formatting syntax is quite flexible but it is a difficult mini-language to remember. I use it every day and still occasionally have to look up forgotten concepts in the documentation. It also isn't powerful enough for serious templating needs, such as generating web pages. There are several third-party templating libraries you can look into if you need to do more than basic formatting of a few strings.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The format method</h1>
                </header>
            
            <article>
                
<p>There are a few cases where you won't be able to use f-strings. First, you can't reuse a single template string with different variables. Second, f-strings were introduced in Python 3.6. If you're stuck on an older version of Python or need to reuse template strings, you can use the older <kbd>str.format</kbd> method instead. It uses the same formatting specifiers as f-strings, but can be called multiple times on one string. Here's an example:</p>
<pre><strong>&gt;&gt;&gt; template = "abc {number:*^10d}"</strong><br/><strong>&gt;&gt;&gt; template.format(number=32)</strong><br/><strong>'abc ****32****'</strong><br/><strong>&gt;&gt;&gt; template.format(number=84)</strong><br/><strong>'abc ****84****'</strong></pre>
<p>The <kbd>format</kbd> method behaves similarly to f-strings, but there are a couple of differences:</p>
<ul>
<li>It is restricted in what it can look up. You can access attributes on objects or look up an index in a list or dict, but you can't call a function inside the template string.</li>
<li>You can use integers to access positional arguments passed to the format method: <kbd>"{0} world".format('bonjour')</kbd>. The indexes are optional if you specify the variables in order: <kbd>"{} {}".format('hello', 'world')</kbd>.</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strings are Unicode</h1>
                </header>
            
            <article>
                
<p>At the beginning of this section, we defined strings as collections of immutable Unicode characters. This actually makes things very complicated at times, because Unicode isn't really a storage format. If you get a string of bytes from a file or a socket, for example, they won't be in Unicode. They will, in fact, be the built-in type <kbd>bytes</kbd>. Bytes are immutable sequences of... well, bytes. Bytes are the basic storage format in computing. They represent 8 bits, usually described as an integer between 0 and 255, or a hexadecimal equivalent between 0 and FF. Bytes don't represent anything specific; a sequence of bytes may store characters of an encoded string, or pixels in an image.</p>
<p>If we print a byte object, any bytes that map to ASCII representations will be printed as their original character, while non-ASCII bytes (whether they are binary data or other characters) are printed as hex codes escaped by the <kbd>\x</kbd> escape sequence. You may find it odd that a byte, represented as an integer, can map to an ASCII character. But ASCII is really just code where each letter is represented by a different byte pattern, and therefore, a different integer. The character <em>a</em> is represented by the same byte as the integer 97, which is the hexadecimal number 0x61. Specifically, all of these are an interpretation of the binary pattern 01100001.</p>
<p>Many I/O operations only know how to deal with <kbd>bytes</kbd>, even if the <kbd>bytes</kbd> object refers to textual data. It is therefore vital to know how to convert between <kbd>bytes</kbd> and Unicode.</p>
<p>The problem is that there are many ways to map <kbd>bytes</kbd> to Unicode text. Bytes are machine-readable values, while text is a human-readable format. Sitting in between is an encoding that maps a given sequence of bytes to a given sequence of text characters.</p>
<p>However, there are multiple such encodings (ASCII is only one of them). The same sequence of bytes represents completely different text characters when mapped using different encodings! So, <kbd>bytes</kbd> must be decoded using the same character set with which they were encoded. It's not possible to get text from bytes without knowing how the bytes should be decoded. If we receive unknown bytes without a specified encoding, the best we can do is guess what format they are encoded in, and we may be wrong.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting bytes to text</h1>
                </header>
            
            <article>
                
<p>If we have an array of <kbd>bytes</kbd> from somewhere, we can convert it to Unicode using the <kbd>.decode</kbd> method on the <kbd>bytes</kbd> class. This method accepts a string for the name of the character encoding. There are many such names; common ones for Western languages include ASCII, UTF-8, and latin-1.</p>
<p>The sequence of bytes (in hex), 63 6c 69 63 68 e9, actually represents the characters of the word cliché in latin-1 encoding. The following example will encode this sequence of bytes and convert it to a Unicode string using latin-1 encoding:</p>
<pre>characters = b'\x63\x6c\x69\x63\x68\xe9' 
print(characters) 
print(characters.decode("latin-1")) </pre>
<p>The first line creates a <kbd>bytes</kbd> object. Analogous to an f-string, the <kbd>b</kbd> character immediately before the string tells us that we are defining a <kbd>bytes</kbd> object instead of a normal Unicode string. Within the string, each byte is specified using<span>—</span>in this case<span>—</span>a hexadecimal number. The <kbd>\x</kbd> character escapes within the byte string, and each say, <em>the next two characters represent a byte using hexadecimal digits</em>.</p>
<p>Provided we are using a shell that understands latin-1 encoding, the two <kbd>print</kbd> calls will output the following strings:</p>
<pre><strong>b'clich\xe9'</strong>
<strong>cliché</strong>  </pre>
<p>The first <kbd>print</kbd> statement renders the bytes for ASCII characters as themselves. The unknown (unknown to ASCII, that is) character stays in its escaped hex format. The output includes a <kbd>b</kbd> character at the beginning of the line to remind us that it is a <kbd>bytes</kbd> representation, not a string.</p>
<p>The next call decodes the string using latin-1 encoding. The <kbd>decode</kbd> method returns a normal (Unicode) string with the correct characters. However, if we had decoded this same string using the Cyrillic <kbd>iso8859-5</kbd> encoding, we'd have ended up with the <kbd>'clichщ'</kbd> <span>string</span>! This is because the <kbd>\xe9</kbd> byte maps to different characters in the two encodings.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting text to bytes</h1>
                </header>
            
            <article>
                
<p>If we need to convert incoming bytes into Unicode, we're clearly also going to have situations where we convert outgoing Unicode into byte sequences. This is done with the <kbd>encode</kbd> method on the <kbd>str</kbd> class, which, like the <kbd>decode</kbd> method, requires a character set. The following code creates a Unicode string and encodes it in different character sets:</p>
<pre>characters = "cliché" 
print(characters.encode("UTF-8")) 
print(characters.encode("latin-1")) 
print(characters.encode("CP437")) 
print(characters.encode("ascii")) </pre>
<p>The first three encodings create a different set of bytes for the accented character. The fourth one can't even handle that byte:</p>
<pre>    <strong>b'clich\xc3\xa9'</strong>
    <strong>b'clich\xe9'</strong>
    <strong>b'clich\x82'</strong>
    <strong>Traceback (most recent call last):</strong>
    <strong>  File "1261_10_16_decode_unicode.py", line 5, in &lt;module&gt;</strong>
    <strong>    print(characters.encode("ascii"))</strong>
    <strong>UnicodeEncodeError: 'ascii' codec can't encode character '\xe9' in position 5: ordinal not in range(128)</strong>  </pre>
<p>Now you should understand the importance of encodings! The accented character is represented as a different byte for each encoding; if we use the wrong one when we are decoding bytes to text, we get the wrong character.</p>
<p>The exception in the last case is not always the desired behavior; there may be cases where we want the unknown characters to be handled in a different way. The <kbd>encode</kbd> method takes an optional string argument named <kbd>errors</kbd> that can define how such characters should be handled. This string can be one of the following:</p>
<ul>
<li><kbd>strict</kbd></li>
<li><kbd>replace</kbd></li>
<li><kbd>ignore</kbd></li>
<li><kbd>xmlcharrefreplace</kbd></li>
</ul>
<p>The <kbd>strict</kbd> replacement strategy is the default we just saw. When a byte sequence is encountered that does not have a valid representation in the requested encoding, an exception is raised. When the <kbd>replace</kbd> strategy is used, the character is replaced with a different character; in ASCII, it is a question mark; other encodings may use different symbols, such as an empty box. The <kbd>ignore</kbd> strategy simply discards any bytes it doesn't understand, while the <kbd>xmlcharrefreplace</kbd> strategy creates an <kbd>xml</kbd> entity representing the Unicode character. This can be useful when converting unknown strings for use in an XML document. Here's how each of the strategies affects our sample word:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Strategy</strong></p>
</td>
<td>
<p><strong>Result of applying</strong> <kbd>"cliché".encode("ascii", strategy)</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>replace</kbd></p>
</td>
<td>
<p><kbd>b'clich?'</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>ignore</kbd></p>
</td>
<td>
<p><kbd>b'clich'</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>xmlcharrefreplace</kbd></p>
</td>
<td>
<p><kbd>b'cliché'</kbd></p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>
<p>It is possible to call the <kbd>str.encode</kbd> and <kbd>bytes.decode</kbd> methods without passing an encoding name. The encoding will be set to the default encoding for the current platform. This will depend on the current operating system and locale or regional settings; you can look it up using the <kbd>sys.getdefaultencoding()</kbd> function. It is usually a good idea to specify the encoding explicitly, though, since the default encoding for a platform may change, or the program may one day be extended to work on text from a wider variety of sources.</p>
<p>If you are encoding text and don't know which encoding to use, it is best to use UTF-8 encoding. UTF-8 is able to represent any Unicode character. In modern software, it is a de facto standard encoding to ensure documents in any language—or even multiple languages <span>—</span>can be exchanged. The various other possible encodings are useful for legacy documents or in regions that still use different character sets by default.</p>
<p>The UTF-8 encoding uses one byte to represent ASCII and other common characters, and up to four bytes for more complex characters. UTF-8 is special because it is backwards-compatible with ASCII; any ASCII document encoded using UTF-8 will be identical to the original ASCII document.</p>
<div class="packt_tip">I can never remember whether to use <kbd>encode</kbd> or <kbd>decode</kbd> to convert from binary bytes to Unicode. I always wished these methods were named <kbd>to_binary</kbd> and <kbd>from_binary</kbd> instead. If you have the same problem, try mentally replacing the word <em>code</em> with <em>binary</em>; <em>enbinary</em> and <em>debinary</em> are pretty close to <em>to_binary</em> and <em>from_binary</em>. I have saved a lot of time by not looking up the method help files since devising this mnemonic.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutable byte strings</h1>
                </header>
            
            <article>
                
<p>The <kbd>bytes</kbd> type, like <kbd>str</kbd>, is immutable. We can use index and slice notation on a <kbd>bytes</kbd> object and search for a particular sequence of bytes, but we can't extend or modify them. This can be very inconvenient when dealing with I/O, as it is often necessary to buffer incoming or outgoing bytes until they are ready to be sent. For example, if we are receiving data from a socket, it may take several <kbd>recv</kbd> calls before we have received an entire message.</p>
<p>This is where the <kbd>bytearray</kbd> built-in comes in. This type behaves something like a list, except it only holds bytes. The constructor for the class can accept a <kbd>bytes</kbd> object to initialize it. The <kbd>extend</kbd> method can be used to append another <kbd>bytes</kbd> object to the existing array (for example, when more data comes from a socket or other I/O channel).</p>
<p>Slice notation can be used on <kbd>bytearray</kbd> to modify the item inline. For example, this code constructs a <kbd>bytearray</kbd> from a <kbd>bytes</kbd> object and then replaces two bytes:</p>
<pre>b = bytearray(b"abcdefgh") 
b[4:6] = b"\x15\xa3" 
print(b) </pre>
<p>The output looks like this:</p>
<pre><strong>bytearray(b'abcd\x15\xa3gh')</strong>  </pre>
<p>If we want to manipulate a single element in <kbd>bytearray</kbd>, we must pass an integer between 0 and 255 (inclusive) as the value. This integer represents a specific <kbd>bytes</kbd> pattern. If we try to pass a character or <kbd>bytes</kbd> object, it will raise an exception.</p>
<p>A single byte character can be converted to an integer using the <kbd>ord</kbd> (short for ordinal) function. This function returns the integer representation of a single character:</p>
<pre>b = bytearray(b"abcdef")<br/>b[3] = ord(b"g")<br/>b[4] = 68<br/>print(b)</pre>
<p>The output looks like this:</p>
<pre><strong>bytearray(b'abcgDf')</strong>  </pre>
<p>After constructing the array, we replace the character at index <kbd>3</kbd> (the fourth character, as indexing starts at <kbd>0</kbd>, as with lists) with byte <kbd>103</kbd>. This integer was returned by the <kbd>ord</kbd> function and is the ASCII character for the lowercase <kbd>g</kbd>. For illustration, we also replaced the next character up with byte number <kbd>68</kbd>, which maps to the ASCII character for the uppercase <kbd>D</kbd>.</p>
<p>The <kbd>bytearray</kbd> type has methods that allow it to behave like a list (we can append integer bytes to it, for example), but also like a <kbd>bytes</kbd> object; we can use methods such as <kbd>count</kbd> and <kbd>find</kbd> the same way they would behave on a <kbd>bytes</kbd> or <kbd>str</kbd> object. The difference is that <kbd>bytearray</kbd> is a mutable type, which can be useful for building up complex sequences of bytes from a specific input source.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Regular expressions</h1>
                </header>
            
            <article>
                
<p>You know what's really hard to do using object-oriented principles? Parsing strings to match arbitrary patterns, that's what. There have been a fair number of academic papers written in which object-oriented design is used to set up string-parsing, but the result is always very verbose and hard to read, and they are not widely used in practice.</p>
<p>In the real world, string-parsing in most programming languages is handled by regular expressions. These are not verbose, but, wow, are they ever hard to read, at least until you learn the syntax. Even though regular expressions are not object-oriented, the Python regular expression library provides a few classes and objects that you can use to construct and run regular expressions.</p>
<p>Regular expressions are used to solve a common problem: Given a string, determine whether that string matches a given pattern and, optionally, collect substrings that contain relevant information. They can be used to answer questions such as the following:</p>
<ul>
<li>Is this string a valid URL?</li>
<li>What is the date and time of all warning messages in a log file?</li>
<li>Which users in <kbd>/etc/passwd</kbd> are in a given group?</li>
<li>What username and document were requested by the URL a visitor typed?</li>
</ul>
<p>There are many similar scenarios where regular expressions are the correct answer. Many programmers have made the mistake of implementing complicated and fragile string-parsing libraries because they didn't know or wouldn't learn regular expressions. In this section, we'll gain enough knowledge of regular expressions to not make such mistakes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Matching patterns</h1>
                </header>
            
            <article>
                
<p>Regular expressions are a complicated mini-language. They rely on special characters to match unknown strings, but let's start with literal characters, such as letters, numbers, and the space character, which always match themselves. Let's see a basic example:</p>
<pre>import re 
 
search_string = "hello world" 
pattern = "hello world" 
 
match = re.match(pattern, search_string) 
 
if match: 
    print("regex matches") </pre>
<p>The Python Standard Library module for regular expressions is called <kbd>re</kbd>. We import it and set up a search string and pattern to search for; in this case, they are the same string. Since the search string matches the given pattern, the conditional passes and the <kbd>print</kbd> statement executes.</p>
<p>Bear in mind that the <kbd>match</kbd> function matches the pattern to the beginning of the string. Thus, if the pattern were <kbd>"ello world"</kbd>, no match would be found. With confusing asymmetry, the parser stops searching as soon as it finds a match, so the pattern <kbd>"hello wo"</kbd> matches successfully. Let's build a small example program to demonstrate these differences and help us learn other regular expression syntax:</p>
<pre>import sys 
import re 
 
pattern = sys.argv[1] 
search_string = sys.argv[2] 
match = re.match(pattern, search_string) 
 
if match: 
    template = "'{}' matches pattern '{}'" 
else: 
    template = "'{}' does not match pattern '{}'" 
 
print(template.format(search_string, pattern)) </pre>
<p>This is just a generic version of the earlier example that accepts the pattern and search string from the command line. We can see how the start of the pattern must match, but a value is returned as soon as a match is found in the following command-line interaction:</p>
<pre><strong>$ python regex_generic.py "hello worl" "hello world"</strong>
<strong>'hello world' matches pattern 'hello worl'</strong>
<strong>$ python regex_generic.py "ello world" "hello world"</strong>
<strong>'hello world' does not match pattern 'ello world'</strong>  </pre>
<p>We'll be using this script throughout the next few sections. While the script is always invoked with the <kbd>python regex_generic.py "&lt;pattern&gt;" "&lt;string&gt;"</kbd> command, we'll only see the output in the following examples, to conserve space.</p>
<p>If you need control over whether items happen at the beginning or end of a line (or if there are no newlines in the string, or at the beginning and end of the string), you can use the <kbd>^</kbd> and <kbd>$</kbd> characters to represent the start and end of the string respectively. If you want a pattern to match an entire string, it's a good idea to include both of these:</p>
<pre><strong>'hello world' matches pattern '^hello world$'</strong>
<strong>'hello worl' does not match pattern '^hello world$'</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Matching a selection of characters</h1>
                </header>
            
            <article>
                
<p>Let's start with matching an arbitrary character. The period character, when used in a regular expression pattern, can match any single character. Using a period in the string means you don't care what the character is, just that there is a character there. Here are some examples:<br/></p>
<pre><strong>'hello world' matches pattern 'hel.o world'</strong>
<strong>'helpo world' matches pattern 'hel.o world'</strong>
<strong>'hel o world' matches pattern 'hel.o world'</strong>
<strong>'helo world' does not match pattern 'hel.o world'</strong>  </pre>
<p>Notice how the last example does not match because there is no character at the period's position in the pattern.</p>
<p>That's all well and good, but what if we only want a few specific characters to match? We can put a set of characters inside square brackets to match any one of those characters. So, if we encounter the string <kbd>[abc]</kbd>  in a regular expression pattern, we know that those five (including the two square brackets) characters will only match one character in the string being searched, and further, that this one character will be either an <kbd>a</kbd>, a <kbd>b</kbd>, or a <kbd>c</kbd>. Let's see a few examples:</p>
<pre><strong>'hello world' matches pattern 'hel[lp]o world'</strong>
<strong>'helpo world' matches pattern 'hel[lp]o world'</strong>
<strong>'helPo world' does not match pattern 'hel[lp]o world'</strong>  </pre>
<p>These square bracket sets should be named character sets, but they are more often referred to as <strong>character classes</strong>. Often, we want to include a large range of characters inside these sets, and typing them all out can be monotonous and error-prone. Fortunately, the regular expression designers thought of this and gave us a shortcut. The dash character, in a character set, will create a range. This is especially useful if you want to match <em>all lowercase letters</em>, <em>all letters</em>, or <em>all numbers,</em> as follows:</p>
<pre> '<strong>hello   world' does not match pattern 'hello [a-z] world'</strong>
 '<strong>hello b world' matches pattern 'hello [a-z] world'</strong>
 <strong>'hello B world' matches pattern 'hello [a-zA-Z] world'</strong>
 <strong>'hello 2 world' matches pattern 'hello [a-zA-Z0-9] world'</strong>  </pre>
<p>There are other ways to match or exclude individual characters, but you'll need to find a more comprehensive tutorial via a web search if you want to find out what they are!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Escaping characters</h1>
                </header>
            
            <article>
                
<p>If putting a period character in a pattern matches any arbitrary character, how do we match just a period in a string? One way might be to put the period inside square brackets to make a character class, but a more generic method is to use backslashes to escape it. Here's a regular expression to match two-digit decimal numbers between 0.00 and 0.99:</p>
<pre><strong>'0.05' matches pattern '0\.[0-9][0-9]'</strong>
<strong>'005' does not match pattern '0\.[0-9][0-9]'</strong>
<strong>'0,05' does not match pattern '0\.[0-9][0-9]'</strong>  </pre>
<p>For this pattern, the two characters <kbd>\.</kbd> match the single <kbd>.</kbd> character. If the period character is missing or is a different character, it will not match.</p>
<p>This backslash escape sequence is used for a variety of special characters in regular expressions. You can use <kbd>\[</kbd> to insert a square bracket without starting a character class, and <kbd>\(</kbd> to insert a parenthesis, which we'll later see is also a special character.</p>
<p>More interestingly, we can also use the escape symbol followed by a character to represent special characters such as newlines (<kbd>\n</kbd>) and tabs (<kbd>\t</kbd>). Further, some character classes can be represented more succinctly using escape strings: <kbd>\s</kbd> represents whitespace characters; <kbd>\w</kbd> represents letters, numbers, and underscore; and <kbd>\d</kbd> represents a digit:</p>
<pre><strong>'(abc]' matches pattern '\(abc\]'</strong>
<strong>' 1a' matches pattern '\s\d\w'</strong>
<strong>'\t5n' does not match pattern '\s\d\w'</strong>
<strong>'5n' matches pattern '\s\d\w'</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Matching multiple characters</h1>
                </header>
            
            <article>
                
<p>With this information, we can match most strings of a known length, but most of the time, we don't know how many characters to match inside a pattern. Regular expressions can take care of this, too. We can modify a pattern by appending one of several hard-to-remember punctuation symbols to match multiple characters.</p>
<p>The asterisk (<kbd>*</kbd>) character says that the previous pattern can be matched zero or more times. This probably sounds silly, but it's one of the most useful repetition characters. Before we explore why, consider some silly examples to make sure we understand what it does:</p>
<pre><strong>'hello' matches pattern 'hel*o'</strong>
<strong>'heo' matches pattern 'hel*o'</strong>
<strong>'helllllo' matches pattern 'hel*o'</strong>  </pre>
<p>So, the <kbd>*</kbd> character in the pattern says that the previous pattern (the <kbd>l</kbd> character) is optional, and if present, can be repeated as many times as possible to match the pattern. The rest of the characters (<kbd>h</kbd>, <kbd>e</kbd>, and <kbd>o</kbd>) have to appear exactly once.</p>
<p>It's pretty rare to want to match a single letter multiple times, but it gets more interesting if we combine the asterisk with patterns that match multiple characters. So, <kbd>.*</kbd>, for example, will match any string, whereas <kbd>[a-z]*</kbd> matches any collection of lowercase words, including the empty string. Here are a few examples:</p>
<pre><strong>'A string.' matches pattern '[A-Z][a-z]* [a-z]*\.'</strong>
<strong>'No .' matches pattern '[A-Z][a-z]* [a-z]*\.'</strong>
<strong>'' matches pattern '[a-z]*.*'</strong>  </pre>
<p>The plus (<kbd>+</kbd>) sign in a pattern behaves similarly to an asterisk; it states that the previous pattern can be repeated one or more times, but, unlike the asterisk, is not optional. The question mark (<kbd>?</kbd>) ensures a pattern shows up exactly zero or one times, but not more. Let's explore some of these by playing with numbers (remember that <kbd>\d</kbd> matches the same character class as <kbd>[0-9]</kbd>:</p>
<pre><strong>'0.4' matches pattern '\d+\.\d+'</strong>
<strong>'1.002' matches pattern '\d+\.\d+'</strong>
<strong>'1.' does not match pattern '\d+\.\d+'</strong>
<strong>'1%' matches pattern '\d?\d%'</strong>
<strong>'99%' matches pattern '\d?\d%'</strong>
<strong>'999%' does not match pattern '\d?\d%'</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grouping patterns together</h1>
                </header>
            
            <article>
                
<p>So far, we've seen how we can repeat a pattern multiple times, but we are restricted in what patterns we can repeat. If we want to repeat individual characters, we're covered, but what if we want a repeating sequence of characters? Enclosing any set of patterns in parentheses allows them to be treated as a single pattern when applying repetition operations. Compare these patterns:</p>
<pre><strong>'abccc' matches pattern 'abc{3}'</strong>
<strong>'abccc' does not match pattern '(abc){3}'</strong>
<strong>'abcabcabc' matches pattern '(abc){3}'</strong>  </pre>
<p>Combined with complex patterns, this grouping feature greatly expands our pattern-matching repertoire. Here's a regular expression that matches simple English sentences:</p>
<pre><strong>'Eat.' matches pattern '[A-Z][a-z]*( [a-z]+)*\.$'</strong>
<strong>'Eat more good food.' matches pattern '[A-Z][a-z]*( [a-z]+)*\.$'</strong>
<strong>'A good meal.' matches pattern '[A-Z][a-z]*( [a-z]+)*\.$'</strong>  </pre>
<p>The first word starts with a capital, followed by zero or more lowercase letters. Then, we enter a parenthetical that matches a single space followed by a word of one or more lowercase letters. This entire parenthetical is repeated zero or more times, and the pattern is terminated with a period. There cannot be any other characters after the period, as indicated by the <kbd>$</kbd> matching the end of string.</p>
<p>We've seen many of the most basic patterns, but the regular expression language supports many more. I spent my first few years using regular expressions looking up the syntax every time I needed to do something. It is worth bookmarking Python's documentation for the <kbd>re</kbd> module and reviewing it frequently. There are very few things that regular expressions cannot match, and they should be the first tool you reach for when parsing strings.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting information from regular expressions</h1>
                </header>
            
            <article>
                
<p>Let's now focus on the Python side of things. The regular expression syntax is the furthest thing from object-oriented programming. However, Python's <kbd>re</kbd> module provides an object-oriented interface to enter the regular expression engine.</p>
<p>We've been checking whether the <kbd>re.match</kbd> function returns a valid object or not. If a pattern does not match, that function returns <kbd>None</kbd>. If it does match, however, it returns a useful object that we can introspect for information about the pattern.</p>
<p>So far, our regular expressions have answered questions such as, <em>does this string match this pattern?</em> Matching patterns is useful, but in many cases, a more interesting question is, <em>if this string matches this pattern, what is the value of a relevant substring?</em> If you use groups to identify parts of the pattern that you want to reference later, you can get them out of the match return value, as illustrated in the next example:</p>
<pre>pattern = "^[a-zA-Z.]+@([a-z.]*\.[a-z]+)$" 
search_string = "some.user@example.com" 
match = re.match(pattern, search_string) 
 
if match: 
    domain = match.groups()[0] 
    print(domain) </pre>
<p>The specification describing valid email addresses is extremely complicated, and the regular expression that accurately matches all possibilities is obscenely long. So, we cheated and made a simple regular expression that matches some common email addresses; the point is that we want to access the domain name (after the <kbd>@</kbd> sign) so we can connect to that address. This is done easily by wrapping that part of the pattern in parentheses and calling the <kbd>groups()</kbd> method on the object returned by <kbd>match</kbd>.</p>
<p>The <kbd>groups</kbd> method returns a tuple of all the groups matched inside the pattern, which you can index to access a specific value. The groups are ordered from left to right. However, bear in mind that groups can be nested, meaning you can have one or more groups inside another group. In this case, the groups are returned in the order of their leftmost brackets, so the outermost group will be returned before its inner matching groups.</p>
<p>In addition to the <kbd>match</kbd> function, the <kbd>re</kbd> module provides a couple of other useful functions, <kbd>search</kbd> and <kbd>findall</kbd>. The <kbd>search</kbd> function finds the first instance of a matching pattern, relaxing the restriction that the pattern should start at the first letter of the string. Note that you can get a similar effect by using <kbd>match</kbd> and putting a  <kbd>^.*</kbd> character at the front of the pattern to match any characters between the start of the string and the pattern you are looking for.</p>
<p>The <kbd>findall</kbd> function behaves similarly to search, except that it finds all non-overlapping instances of the matching pattern, not just the first one. Basically, it finds the first match, then it resets the search to the end of that matching string and finds the next one.</p>
<p>Instead of returning a list of match objects, as you would expect, it returns a list of matching strings, or tuples. Sometimes it's strings, sometimes it's tuples. It's not a very good API at all! As with all bad APIs, you'll have to memorize the differences and not rely on intuition. The type of the return value depends on the number of bracketed groups inside the regular expression:</p>
<ul>
<li>If there are no groups in the pattern, <kbd>re.findall</kbd> will return a list of strings, where each value is a complete substring from the source string that matches the pattern</li>
<li>If there is exactly one group in the pattern, <kbd>re.findall</kbd> will return a list of strings where each value is the contents of that group</li>
<li>If there are multiple groups in the pattern, <kbd>re.findall</kbd> will return a list of tuples where each tuple contains a value from a matching group, in order</li>
</ul>
<div class="packt_infobox">When you are designing function calls in your own Python libraries, try to make the function always return a consistent data structure. It is often good to design functions that can take arbitrary inputs and process them, but the return value should not switch from a single value to a list, or a list of values to a list of tuples depending on the input. Let <kbd>re.findall</kbd> be a lesson!</div>
<p>The examples in the following interactive session will hopefully clarify the differences:</p>
<pre><strong>&gt;&gt;&gt; import re</strong>
<strong>&gt;&gt;&gt; re.findall('a.', 'abacadefagah')</strong>
<strong>['ab', 'ac', 'ad', 'ag', 'ah']</strong>
<strong>&gt;&gt;&gt; re.findall('a(.)', 'abacadefagah')</strong>
<strong>['b', 'c', 'd', 'g', 'h']</strong>
<strong>&gt;&gt;&gt; re.findall('(a)(.)', 'abacadefagah')</strong>
<strong>[('a', 'b'), ('a', 'c'), ('a', 'd'), ('a', 'g'), ('a', 'h')]</strong>
<strong>&gt;&gt;&gt; re.findall('((a)(.))', 'abacadefagah')</strong>
<strong>[('ab', 'a', 'b'), ('ac', 'a', 'c'), ('ad', 'a', 'd'), ('ag', 'a', 'g'), ('ah', 'a', <br/>'h')]</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making repeated regular expressions efficient</h1>
                </header>
            
            <article>
                
<p>Whenever you call one of the regular expression methods, the engine has to convert the pattern string into an internal structure that makes searching strings fast. This conversion takes a non-trivial amount of time. If a regular expression pattern is going to be reused multiple times (for example, inside a <kbd>for</kbd> or <kbd>while</kbd> loop), it would be better if this conversion step could be done only once.</p>
<p>This is possible with the <kbd>re.compile</kbd> method. It returns an object-oriented version of the regular expression that has been compiled down and has the methods we've explored (<kbd>match</kbd>, <kbd>search</kbd>, and <kbd>findall</kbd>) already, among others. We'll see examples of this in the case study.</p>
<p>This has definitely been a condensed introduction to regular expressions. At this point, we have a good feel for the basics and will recognize when we need to do further research. If we have a string pattern-matching problem, regular expressions will almost certainly be able to solve them for us. However, we may need to look up new syntaxes in a more comprehensive coverage of the topic. But now we know what to look for! Let's move on to a completely different topic: filesystem paths.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filesystem paths</h1>
                </header>
            
            <article>
                
<p>All operating systems provide a <em>filesystem</em>, a way of mapping a logical abstraction of <em>folders</em> (or <em>directories</em>) and <em>files</em> to the bits and bytes stored on a hard drive or other storage device. As humans, we typically interact with the filesystem using a drag-and-drop interface of folders and files of different types, or with command-line programs such as <kbd>cp</kbd>, <kbd>mv</kbd>, and <kbd>mkdir</kbd>.</p>
<p>As programmers, we have to interact with the filesystem with a series of system calls. You can think of these as library functions supplied by the operating system so that programs can call them. They have a clunky interface with integer file handles and buffered reads and writes, and that interface is different depending on which operating system you are using. Python provides an OS-independent abstraction over these system calls in the <kbd>os.path</kbd> module. It's a little easier to work with than accessing the operating system directly, but it's not very intuitive. It requires a lot of string concatenation and you have to be conscious of whether to use a forward slash or a backslash between directories, depending on the operating system. There is a <kbd>os.sep</kbd> file representing the path separator, but using it requires code that looks like this:</p>
<pre><strong>&gt;&gt;&gt; path = os.path.abspath(os.sep.join(['.', 'subdir', 'subsubdir', 'file.ext']))</strong><br/><strong>&gt;&gt;&gt; print(path)</strong><br/><strong>/home/dusty/subdir/subsubdir/file.ext</strong></pre>
<p>Working with filesystem paths is easily one of the most irritating uses of strings inside the entire standard library. Paths that are easy to type on the command line become illegible in Python code. When you have to manipulate and access multiple paths (for example, when processing images in a data pipeline for a machine learning computer vision problem), just managing those directories becomes a bit of an ordeal.</p>
<p>So, the Python language designers included a module called <kbd>pathlib</kbd> in the standard library. It's an object-oriented representation of paths and files that is much more pleasant to work with. The preceding path, using <kbd>pathlib</kbd>, would look like this:</p>
<pre><strong>&gt;&gt;&gt; path = (pathlib.Path(".") / "subdir" / " subsubdir" / "file.ext").absolute()</strong><br/><strong>&gt;&gt;&gt; print(path)</strong><br/><strong>/home/dusty/subdir/subsubdir/file.ext</strong></pre>
<p>As you can see, it's quite a bit easier to see what's going on. Notice the unique use of the division operator as a path separator so you don't have to do anything with <kbd>os.sep</kbd>.</p>
<p>In a more real-world example, consider some code that counts the number of lines of code excluding whitespace and comments in all Python files in the current directory and subdirectories:</p>
<pre>import pathlib<br/><br/><br/>def count_sloc(dir_path):<br/>    sloc = 0<br/>    for path in dir_path.iterdir():<br/>        if path.name.startswith("."):<br/>            continue<br/>        if path.is_dir():<br/>            sloc += count_sloc(path)<br/>            continue<br/>        if path.suffix != ".py":<br/>            continue<br/>        with path.open() as file:<br/>            for line in file:<br/>                line = line.strip()<br/>                if line and not line.startswith("#"):<br/>                    sloc += 1<br/>    return sloc<br/><br/><br/>root_path = pathlib.Path(".")<br/><br/>print(f"{count_sloc(root_path)} lines of python code")<br/><br/></pre>
<p>In typical <kbd>pathlib</kbd> usage, we rarely have to construct more than one or two paths. Usually, other files or directories are relative to a general path. This example demonstrates that. We only ever construct one path, from the current directory using <kbd>pathlib.Path(".")</kbd>. Then, other paths are created based on that path.</p>
<p>The <kbd>count_sloc</kbd> function first initializes the <strong>sloc</strong> (<strong>source lines of code</strong>) counter to zero. Then, it iterates over all the files and directories in the path that was passed into the function using the <kbd>dir_path.iterdir</kbd> generator (we'll discuss generators in detail in the next chapter; for now, think of it as a sort of dynamic list). Each of the paths returned to the <kbd>for</kbd> loop by <kbd>iterdir</kbd> is itself another path. We first test whether this path starts with a <kbd>.</kbd>, which represents a hidden directory on most OSes (this will keep it from counting any files in the <kbd>.git</kbd> directory if you are using version control). Then, we check whether it is a directory using the <kbd>isdir()</kbd>  method. If it is, we recursively call <kbd>count_sloc</kbd> to count the lines of code in modules in the child package.</p>
<p>If it's not a directory, we assume it is a normal file, and skip any files that don't end with the <kbd>.py</kbd> extension, using the <kbd>suffix</kbd> property. Now, knowing we have a path to a Python file, we open the file using the <kbd>open()</kbd> method, which returns a context manager. We wrap this in a <kbd>with</kbd> block so the file is automatically closed when we are done with it.</p>
<p>The <kbd>Path.open</kbd> method takes similar arguments to the <kbd>open</kbd> built-in function, but it uses a more object-oriented syntax. If you prefer the function version, you can pass a <kbd>Path</kbd> object into it as the first parameter (in other words, <kbd>with open(Path('./README.md')):</kbd>) just as you would a string. But I personally think <kbd>Path('./README.md').open()</kbd> is more legible if the path already exists.</p>
<p>We then iterate over each line in the file and add it to the count. We skip whitespace and comment lines, since these don't represent actual source code. The total count is returned to the calling function, which may be the original call or the recursive parent.</p>
<p>The <kbd>Path</kbd> class in the <kbd>pathlib</kbd> module has a method or property to cover pretty much everything you might want to do with a path. In addition to those we covered in the example, here are a few of my favorites:</p>
<ul>
<li><kbd>.absolute()</kbd> returns the full path from the root of the filesystem. I usually call this on every path I construct in due to a bit of paranoia that I might forget where relative paths came from.</li>
<li><kbd>.parent</kbd> returns a path to the parent directory.</li>
<li><kbd>.exists()</kbd> checks whether the file or directory exists.</li>
<li><kbd>.mkdir()</kbd> creates a directory at the current path. It takes Boolean <kbd>parents</kbd> and <kbd>exist_ok</kbd> arguments to indicate that it should recursively create the directories if necessary and that it shouldn't raise an exception if the directory already exists.</li>
</ul>
<p>Refer to the standard library documentation at <a href="https://docs.python.org/3/library/pathlib.html">https://docs.python.org/3/library/pathlib.html</a> for more exotic uses.</p>
<p>Most standard library modules that accept a string path can also accept a <kbd>pathlib.Path</kbd> object. For example, you can open a ZIP file by passing a path into it:</p>
<pre><strong>&gt;&gt;&gt; zipfile.ZipFile(Path('nothing.zip'), 'w').writestr('filename', 'contents')</strong></pre>
<p>This doesn't always work, especially if you are using a third-party library that is implemented as a C extension. In those cases, you'll have to cast the path to a string using <kbd>str(pathname)</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serializing objects</h1>
                </header>
            
            <article>
                
<p>Nowadays, we take the ability to write data to a file and retrieve it at an arbitrary later date for granted. As convenient as this is (imagine the state of computing if we couldn't store anything!), we often find ourselves converting data we have stored in a nice object or design pattern in memory into some kind of clunky text or binary format for storage, transfer over the network, or remote invocation on a distant server.</p>
<p>The Python <kbd>pickle</kbd> module is an object-oriented way to store objects directly in a special storage format. It essentially converts an object (and all the objects it holds as attributes) into a sequence of bytes that can be stored or transported however we see fit.</p>
<p>For basic tasks, the <kbd>pickle</kbd> module has an extremely simple interface. It comprises four basic functions for storing and loading data: two for manipulating file-like objects, and two for manipulating <kbd>bytes</kbd> objects (the latter are just shortcuts to the file-like interface, so we don't have to create a <kbd>BytesIO</kbd> file-like object ourselves).</p>
<p>The <kbd>dump</kbd> method accepts an object to be written and a file-like object to write the serialized bytes to. This object must have a <kbd>write</kbd> method (or it wouldn't be file-like), and that method must know how to handle a <kbd>bytes</kbd> argument (so, a file opened for text output wouldn't work).</p>
<p>The <kbd>load</kbd> method does exactly the opposite; it reads a serialized object from a file-like object. This object must have the proper file-like <kbd>read</kbd> and <kbd>readline</kbd> arguments, each of which must, of course, return <kbd>bytes</kbd>. The <kbd>pickle</kbd> module will load the object from these bytes and the <kbd>load</kbd> method will return the fully reconstructed object. Here's an example that stores and then loads some data in a list object:</p>
<pre>import pickle 
 
some_data = ["a list", "containing", 5, 
        "values including another list", 
        ["inner", "list"]] 
 
with open("pickled_list", 'wb') as file: 
    pickle.dump(some_data, file) 
 
with open("pickled_list", 'rb') as file: 
    loaded_data = pickle.load(file) 
 
print(loaded_data) 
assert loaded_data == some_data </pre>
<p>This code works as advertised: the objects are stored in the file and then loaded from the same file. In each case, we open the file using a <kbd>with</kbd> statement so that it is automatically closed. The file is first opened for writing and then a second time for reading, depending on whether we are storing or loading data.</p>
<p>The <kbd>assert</kbd> statement at the end would raise an error if the newly loaded object was not equal to the original object. Equality does not imply that they are the same object. Indeed, if we print the <kbd>id()</kbd> of both objects, we would discover they are different. However, because they are both lists whose contents are equal, the two lists are also considered equal.</p>
<p>The <kbd>dumps</kbd> and <kbd>loads</kbd> functions behave much like their file-like counterparts, except they return or accept <kbd>bytes</kbd> instead of file-like objects. The <kbd>dumps</kbd> function requires only one argument, the object to be stored, and it returns a serialized <kbd>bytes</kbd> object. The <kbd>loads</kbd> function requires a <kbd>bytes</kbd> object and returns the restored object. The <kbd>'s'</kbd> character in the method names is short for string; it's a legacy name from ancient versions of Python, where <kbd>str</kbd> objects were used instead of <kbd>bytes</kbd>.</p>
<p>It is possible to call <kbd>dump</kbd> or <kbd>load</kbd> on a single open file more than once. Each call to <kbd>dump</kbd> will store a single object (plus any objects it is composed of or contains), while a call to <kbd>load</kbd> will load and return just one object. So, for a single file, each separate call to <kbd>dump</kbd> when storing the object should have an associated call to <kbd>load</kbd> when restoring at a later date.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing pickles</h1>
                </header>
            
            <article>
                
<p>With most common Python objects, pickling <em>just works</em>. Basic primitives such as integers, floats, and strings can be pickled, as can any container objects, such as lists or dictionaries, provided the contents of those containers are also picklable. Further, and importantly, any object can be pickled, so long as all of its attributes are also picklable.</p>
<p>So, what makes an attribute unpicklable? Usually, it has something to do with time-sensitive attributes that it would not make sense to load in the future. For example, if we have an open network socket, open file, running thread, or database connection stored as an attribute on an object, it would not make sense to pickle these objects; a lot of operating system state would simply be gone when we attempted to reload them later. We can't just pretend a thread or socket connection exists and make it appear! No, we need to somehow customize how such transient data is stored and restored.</p>
<p>Here's a class that loads the contents of a web page every hour to ensure that they stay up to date. It uses the <kbd>threading.Timer</kbd> class to schedule the next update:</p>
<pre>from threading import Timer 
import datetime 
from urllib.request import urlopen 
 
class UpdatedURL: 
    def __init__(self, url): 
        self.url = url 
        self.contents = '' 
        self.last_updated = None 
        self.update() 
 
    def update(self): 
        self.contents = urlopen(self.url).read() 
        self.last_updated = datetime.datetime.now() 
        self.schedule() 
 
    def schedule(self): 
        self.timer = Timer(3600, self.update) 
        self.timer.setDaemon(True) 
        self.timer.start() </pre>
<p><kbd>url</kbd>, <kbd>contents</kbd>, and <kbd>last_updated</kbd> are all pickleable, but if we try to pickle an instance of this class, things go a little nutty on the <kbd>self.timer</kbd> instance:</p>
<pre><strong>&gt;&gt;&gt; u = UpdatedURL("http://dusty.phillips.codes")</strong><br/><strong>^[[Apickle.dumps(u)</strong><br/><strong>Traceback (most recent call last):</strong><br/><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong><br/><strong>TypeError: can't pickle _thread.lock objects</strong></pre>
<p>That's not a very useful error, but it looks like we're trying to pickle something we shouldn't be. That would be the <kbd>Timer</kbd> instance; we're storing a reference to <kbd>self.timer</kbd> in the schedule method, and that attribute cannot be serialized.</p>
<p>When <kbd>pickle</kbd> tries to serialize an object, it simply tries to store the object's <kbd>__dict__</kbd> attribute; <kbd>__dict__</kbd> is a dictionary mapping all the attribute names on the object to their values. Luckily, before checking <kbd>__dict__</kbd>, <kbd>pickle</kbd> checks to see whether a <kbd>__getstate__</kbd> method exists. If it does, it will store the return value of that method instead of the <kbd>__dict__</kbd>.</p>
<p>Let's add a <kbd>__getstate__</kbd> method to our <kbd>UpdatedURL</kbd> class that simply returns a copy of the <kbd>__dict__</kbd> without a timer:</p>
<pre>    def __getstate__(self): 
        new_state = self.__dict__.copy() 
        if 'timer' in new_state: 
            del new_state['timer'] 
        return new_state </pre>
<p>If we pickle the object now, it will no longer fail. And we can even successfully restore that object using <kbd>loads</kbd>. However, the restored object doesn't have a timer attribute, so it will not be refreshing the content like it is designed to do. We need to somehow create a new timer (to replace the missing one) when the object is unpickled.</p>
<p>As we might expect, there is a complementary <kbd>__setstate__</kbd> method that can be implemented to customize unpickling. This method accepts a single argument, which is the object returned by <kbd>__getstate__</kbd>. If we implement both methods, <kbd>__getstate__</kbd> is not required to return a dictionary, since <kbd>__setstate__</kbd> will know what to do with whatever object <kbd>__getstate__</kbd> chooses to return. In our case, we simply want to restore the <kbd>__dict__</kbd>, and then create a new timer:</p>
<pre> def __setstate__(self, data): self.__dict__ = data self.schedule() </pre>
<p>The <kbd>pickle</kbd> module is very flexible and provides other tools to further customize the pickling process if you need them. However, these are beyond the scope of this book. The tools we've covered are sufficient for many basic pickling tasks. Objects to be pickled are normally relatively simple data objects; we likely would not pickle an entire running program or complicated design pattern, for example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serializing web objects</h1>
                </header>
            
            <article>
                
<p>It is not a good idea to load a pickled object from an unknown or untrusted source. It is possible to inject arbitrary code into a pickled file to maliciously attack a computer via the pickle. Another disadvantage of pickles is that they can only be loaded by other Python programs, and cannot be easily shared with services written in other languages.</p>
<p>There are many formats that have been used for this purpose over the years. <strong>Extensible Markup Language</strong> (<strong>XML</strong>) used to be very popular, especially with Java developers. <strong>Yet Another Markup Language</strong> (<strong>YAML</strong>) is another format that you may see referenced occasionally. Tabular data is frequently exchanged in the <strong>Comma-Separated Value</strong> (<strong>CSV</strong>) format. Many of these are fading into obscurity and there are many more that you will encounter over time. Python has solid standard or third-party libraries for all of them.</p>
<p>Before using such libraries on untrusted data, make sure to investigate security concerns with each of them. XML and YAML, for example, both have obscure features that, used maliciously, can allow arbitrary commands to be executed on the host machine. These features may not be turned off by default. Do your research.</p>
<p><strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) is a human-readable format for exchanging primitive data. JSON is a standard format that can be interpreted by a wide array of heterogeneous client systems. Hence, JSON is extremely useful for transmitting data between completely decoupled systems. Further, JSON does not have any support for executable code, only data can be serialized; thus, it is more difficult to inject malicious statements into it.</p>
<p>Because JSON can be easily interpreted by JavaScript engines, it is often used for transmitting data from a web server to a JavaScript-capable web browser. If the web application serving the data is written in Python, it needs a way to convert internal data into the JSON format.</p>
<p>There is a module to do this, predictably named <kbd>json</kbd>. This module provides a similar interface to the <kbd>pickle</kbd> module, with <kbd>dump</kbd>, <kbd>load</kbd>, <kbd>dumps</kbd>, and <kbd>loads</kbd> functions. The default calls to these functions are nearly identical to those in <kbd>pickle</kbd>, so let's not repeat the details. There are a couple of differences; obviously, the output of these calls is valid JSON notation, rather than a pickled object. In addition, the <kbd>json</kbd> functions operate on <kbd>str</kbd> objects, rather than <kbd>bytes</kbd>. Therefore, when dumping to or loading from a file, we need to create text files rather than binary ones.</p>
<p>The JSON serializer is not as robust as the <kbd>pickle</kbd> module; it can only serialize basic types such as integers, floats, and strings, and simple containers such as dictionaries and lists. Each of these has a direct mapping to a JSON representation, but JSON is unable to represent classes, methods, or functions. It is not possible to transmit complete objects in this format. Because the receiver of an object we have dumped to JSON format is normally not a Python object, it would not be able to understand classes or methods in the same way that Python does, anyway. In spite of the O for Object in its name, JSON is a <strong>data</strong> notation; objects, as you recall, are composed of both data and behaviors.</p>
<p>If we do have objects for which we want to serialize only the data, we can always serialize the object's <kbd>__dict__</kbd> attribute. Or we can semi-automate this task by supplying custom code to create or parse a JSON serializable dictionary from certain types of objects.</p>
<p>In the <kbd>json</kbd> module, both the object storing and loading functions accept optional arguments to customize the behavior. The <kbd>dump</kbd> and <kbd>dumps</kbd> methods accept a poorly named <kbd>cls</kbd> (short for class, which is a reserved keyword) keyword argument. If passed, this should be a subclass of the <kbd>JSONEncoder</kbd> class, with the <kbd>default</kbd> method overridden. This method accepts an arbitrary object and converts it to a dictionary that <kbd>json</kbd> can digest. If it doesn't know how to process the object, we should call the <kbd>super()</kbd> method, so that it can take care of serializing basic types in the normal way.</p>
<p>The <kbd>load</kbd> and <kbd>loads</kbd> methods also accept such a <kbd>cls</kbd> argument that can be a subclass of the inverse class, <kbd>JSONDecoder</kbd>. However, it is normally sufficient to pass a function into these methods using the <kbd>object_hook</kbd> keyword argument. This function accepts a dictionary and returns an object; if it doesn't know what to do with the input dictionary, it can return it unmodified.</p>
<p>Let's look at an example. Imagine we have the following simple contact class that we want to serialize:</p>
<pre>class Contact: 
    def __init__(self, first, last): 
        self.first = first 
        self.last = last 
 
    @property 
    def full_name(self): 
        return("{} {}".format(self.first, self.last)) </pre>
<p>We could just serialize the <kbd>__dict__</kbd> attribute:</p>
<pre>    <strong>&gt;&gt;&gt; c = Contact("John", "Smith")</strong>
    <strong>&gt;&gt;&gt; json.dumps(c.__dict__)</strong>
    <strong>'{"last": "Smith", "first": "John"}'</strong>  </pre>
<p>But accessing special (double-underscore) attributes in this fashion is kind of crude. Also, what if the receiving code (perhaps some JavaScript on a web page) wanted that <kbd>full_name</kbd> property to be supplied? Of course, we could construct the dictionary by hand, but let's create a custom encoder instead:</p>
<pre>import json<br/><br/><br/>class ContactEncoder(json.JSONEncoder):<br/>    def default(self, obj):<br/>        if isinstance(obj, Contact):<br/>            return {<br/>                "is_contact": True,<br/>                "first": obj.first,<br/>                "last": obj.last,<br/>                "full": obj.full_name,<br/>            }<br/>        return super().default(obj)</pre>
<p>The <kbd>default</kbd> method basically checks to see what kind of object we're trying to serialize. If it's a contact, we convert it to a dictionary manually. Otherwise, we let the parent class handle serialization (by assuming that it is a basic type, which <kbd>json</kbd> knows how to handle). Notice that we pass an extra attribute to identify this object as a contact, since there would be no way to tell upon loading it. This is just a convention; for a more generic serialization mechanism, it might make more sense to store a string type in the dictionary, or possibly even the full class name, including package and module. Remember that the format of the dictionary depends on the code at the receiving end; there has to be an agreement as to how the data is going to be specified.</p>
<p>We can use this class to encode a contact by passing the class (not an instantiated object) to the <kbd>dump</kbd> or <kbd>dumps</kbd> function:</p>
<pre>    <strong>&gt;&gt;&gt; c = Contact("John", "Smith")</strong>
    <strong>&gt;&gt;&gt; json.dumps(c, cls=ContactEncoder)</strong>
    <strong>'{"is_contact": true, "last": "Smith", "full": "John Smith",</strong>
    <strong>"first": "John"}'</strong>  </pre>
<p>For decoding, we can write a function that accepts a dictionary and checks the existence of the <kbd>is_contact</kbd> variable to decide whether to convert it to a contact:</p>
<pre>def decode_contact(dic):<br/>    if dic.get("is_contact"):<br/>        return Contact(dic["first"], dic["last"])<br/>    else:<br/>        return dic</pre>
<p>We can pass this function to the <kbd>load</kbd> or <kbd>loads</kbd> function using the <kbd>object_hook</kbd> keyword argument:</p>
<pre>    <strong>&gt;&gt;&gt; data = ('{"is_contact": true, "last": "smith",'</strong>
    <strong>     '"full": "john smith", "first": "john"}')</strong>
    
    <strong>&gt;&gt;&gt; c = json.loads(data, object_hook=decode_contact)</strong>
    <strong>&gt;&gt;&gt; c</strong>
    <strong>&lt;__main__.Contact object at 0xa02918c&gt;</strong>
    <strong>&gt;&gt;&gt; c.full_name</strong>
    <strong>'john smith'</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study</h1>
                </header>
            
            <article>
                
<p>Let's build a basic regular expression-powered templating engine in Python. This engine will parse a text file (such as an HTML page) and replace certain directives with text calculated from the input to those directives. This is about the most complicated task we would want to do with regular expressions; indeed, a full-fledged version of this would likely utilize a proper language-parsing mechanism.</p>
<p>Consider the following input file:</p>
<pre>/** include header.html **/ 
&lt;h1&gt;This is the title of the front page&lt;/h1&gt; 
/** include menu.html **/ 
&lt;p&gt;My name is /** variable name **/. 
This is the content of my front page. It goes below the menu.&lt;/p&gt; 
&lt;table&gt; 
&lt;tr&gt;&lt;th&gt;Favourite Books&lt;/th&gt;&lt;/tr&gt; 
/** loopover book_list **/ 
&lt;tr&gt;&lt;td&gt;/** loopvar **/&lt;/td&gt;&lt;/tr&gt; 
 
/** endloop **/ 
&lt;/table&gt; 
/** include footer.html **/ 
Copyright &amp;copy; Today </pre>
<p>This file contains <em>tags</em> of the form <kbd>/** &lt;directive&gt; &lt;data&gt; **/</kbd> where the data is an optional single word and the directives are as follows:</p>
<ul>
<li><kbd>include</kbd>: Copy the contents of another file here</li>
<li><kbd>variable</kbd>: Insert the contents of a variable here</li>
<li><kbd>loopover</kbd>: Repeat the contents of the loop for a variable that is a list</li>
<li><kbd>endloop</kbd>: Signal the end of looped text</li>
<li><kbd>loopvar</kbd>: Insert a single value from the list being looped over</li>
</ul>
<p>This template will render a different page depending which variables are passed into it. These variables will be passed in from a so-called context file. This will be encoded as a <kbd>json</kbd> object with keys representing the variables in question. My context file might look like this, but you would derive your own:</p>
<pre>{ 
    "name": "Dusty", 
    "book_list": [ 
        "Thief Of Time", 
        "The Thief", 
        "Snow Crash", 
        "Lathe Of Heaven" 
    ] 
} </pre>
<p>Before we get into the actual string processing, let's throw together some object-oriented boilerplate code for processing files and grabbing data from the command line:</p>
<pre>import re 
import sys 
import json 
from pathlib import Path 
 
DIRECTIVE_RE = re.compile( 
    r'/\*\*\s*(include|variable|loopover|endloop|loopvar)' 
    r'\s*([^ *]*)\s*\*\*/') 
 
 
class TemplateEngine: 
    def __init__(self, infilename, outfilename, contextfilename): 
        self.template = open(infilename).read() 
        self.working_dir = Path(infilename).absolute().parent 
        self.pos = 0 
        self.outfile = open(outfilename, 'w') 
        with open(contextfilename) as contextfile: 
            self.context = json.load(contextfile) 
 
    def process(self): 
        print("PROCESSING...") 
 
 
if __name__ == '__main__': 
    infilename, outfilename, contextfilename = sys.argv[1:] 
    engine = TemplateEngine(infilename, outfilename, contextfilename) 
    engine.process() </pre>
<p>This is all pretty basic, we create a class and initialize it with some variables passed in on the command line.</p>
<p>Notice how we try to make the regular expression a little bit more readable by breaking it across two lines? We use raw strings (the r prefix), so we don't have to double escape all our backslashes. This is common in regular expressions, but it's still a mess. (Regular expressions always are, but they're often worth it.)</p>
<p>The <kbd>pos</kbd> indicates the current character in the content that we are processing; we'll see a lot more of it in a moment.</p>
<p>Now all that's left is to implement the process method. There are a few ways to do this. Let's do it in a fairly explicit way.</p>
<p>The process method has to find each directive that matches the regular expression and do the appropriate work with it. However, it also has to take care of outputting the normal text before, after, and between each directive to the output file, unmodified.</p>
<p>One good feature of the compiled version of regular expressions is that we can tell the <kbd>search</kbd> method to start searching at a specific position by passing the <kbd>pos</kbd> keyword argument. If we temporarily define doing the appropriate work with a directive as <em>ignore the directive and delete it from the output file</em>, our process loop looks quite simple:</p>
<pre>def process(self): 
    match = DIRECTIVE_RE.search(self.template, pos=self.pos) 
    while match: 
        self.outfile.write(self.template[self.pos:match.start()]) 
        self.pos = match.end() 
        match = DIRECTIVE_RE.search(self.template, pos=self.pos) 
    self.outfile.write(self.template[self.pos:]) </pre>
<p>In English, this function finds the first string in the text that matches the regular expression, outputs everything from the current position to the start of that match, and then advances the position to the end of the aforesaid match. Once it's out of matches, it outputs everything since the last position.</p>
<p>Of course, ignoring the directive is pretty useless in a templating engine, so let's replace that position advancing line with code that delegates to a different method on the class depending on the directive:</p>
<pre>def process(self): 
    match = DIRECTIVE_RE.search(self.template, pos=self.pos) 
    while match: 
        self.outfile.write(self.template[self.pos:match.start()]) 
        directive, argument = match.groups() 
        method_name = 'process_{}'.format(directive) 
        getattr(self, method_name)(match, argument) 
        match = DIRECTIVE_RE.search(self.template, pos=self.pos) 
    self.outfile.write(self.template[self.pos:]) </pre>
<p>So, we grab the directive and the single argument from the regular expression. The directive becomes a method name and we dynamically look up that method name on the <kbd>self</kbd> object (a little error processing here, in case the template writer provides an invalid directive, would be better). We pass the <kbd>match</kbd> object and argument into that method and assume that method will deal with everything appropriately, including moving the <kbd>pos</kbd> pointer.</p>
<p>Now that we've got our object-oriented architecture this far, it's actually pretty simple to implement the methods that are delegated to. The <kbd>include</kbd> and <kbd>variable</kbd> directives are totally straightforward:</p>
<pre>def process_include(self, match, argument): 
    with (self.working_dir / argument).open() as includefile: 
        self.outfile.write(includefile.read()) 
        self.pos = match.end() 
 
def process_variable(self, match, argument): 
    self.outfile.write(self.context.get(argument, '')) 
    self.pos = match.end() </pre>
<p>The first simply looks up the included file and inserts the file contents, while the second looks up the variable name in the context dictionary (which was loaded from <kbd>json</kbd> in the <kbd>__init__</kbd> method), defaulting to an empty string if it doesn't exist.</p>
<p>The three methods that deal with looping are a bit more intense, as they have to share state between the three of them. For simplicity (I'm sure you're eager to see the end of this long chapter<span>—</span>we're almost there!), we'll handle this case using instance variables on the class itself. As an exercise, you might want to consider better ways to architect this, especially after reading the next three chapters:</p>
<pre>    def process_loopover(self, match, argument): 
        self.loop_index = 0 
        self.loop_list = self.context.get(argument, []) 
        self.pos = self.loop_pos = match.end() 
 
    def process_loopvar(self, match, argument): 
        self.outfile.write(self.loop_list[self.loop_index]) 
        self.pos = match.end() 
 
    def process_endloop(self, match, argument): 
        self.loop_index += 1 
        if self.loop_index &gt;= len(self.loop_list): 
            self.pos = match.end() 
            del self.loop_index 
            del self.loop_list 
            del self.loop_pos 
        else: 
            self.pos = self.loop_pos </pre>
<p>When we encounter the <kbd>loopover</kbd> directive, we don't have to output anything, but we do have to set the initial state on three variables. The <kbd>loop_list</kbd> variable is assumed to be a list pulled from the context dictionary. The <kbd>loop_index</kbd> variable indicates which position in that list should be output in this iteration of the loop, while <kbd>loop_pos</kbd> is stored so we know where to jump back to when we get to the end of the loop.</p>
<p>The <kbd>loopvar</kbd> directive outputs the value at the current position in the <kbd>loop_list</kbd> variable and skips to the end of the directive. Note that it doesn't increment the loop index, because the <kbd>loopvar</kbd> directive could be called multiple times inside a loop.</p>
<p>The <kbd>endloop</kbd> directive is more complicated. It determines whether there are more elements in the <kbd>loop_list</kbd>; if there are, it just jumps back to the start of the loop, incrementing the index. Otherwise, it resets all the variables that were being used to process the loop and jumps to the end of the directive so the engine can carry on with the next match.</p>
<p>Note that this particular looping mechanism is very fragile; if a template designer were to try nesting loops or to forget an <kbd>endloop</kbd> call, it would go poorly for them. We would need a lot more error checking and would probably want to store more loop state to make this a production platform. But I promised that the end of the chapter was nigh, so let's just head to the exercises, after seeing how our sample template is rendered with its context:</p>
<pre>&lt;html&gt;<br/><br/>&lt;body&gt;<br/><br/>&lt;h1&gt;This is the title of the front page&lt;/h1&gt;<br/>&lt;a href="link1.html"&gt;First Link&lt;/a&gt;<br/>&lt;a href="link2.html"&gt;Second Link&lt;/a&gt;<br/><br/>&lt;p&gt;My name is Dusty. This is the content of my front page. It goes below the menu.&lt;/p&gt;<br/>&lt;table&gt;<br/>    &lt;tr&gt;<br/>        &lt;th&gt;Favourite Books&lt;/th&gt;<br/>    &lt;/tr&gt;<br/><br/>    &lt;tr&gt;<br/>        &lt;td&gt;Thief Of Time&lt;/td&gt;<br/>    &lt;/tr&gt;<br/><br/><br/>    &lt;tr&gt;<br/>        &lt;td&gt;The Thief&lt;/td&gt;<br/>    &lt;/tr&gt;<br/><br/><br/>    &lt;tr&gt;<br/>        &lt;td&gt;Snow Crash&lt;/td&gt;<br/>    &lt;/tr&gt;<br/><br/><br/>    &lt;tr&gt;<br/>        &lt;td&gt;Lathe Of Heaven&lt;/td&gt;<br/>    &lt;/tr&gt;<br/><br/><br/>&lt;/table&gt;<br/>&lt;/body&gt;<br/><br/>&lt;/html&gt;<br/> Copyright &amp;copy; Today</pre>
<p>There are some weird newline effects due to the way we planned our template, but it works as expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>We've covered a wide variety of topics in this chapter, from strings to regular expressions, to object serialization, and back again. Now it's time to consider how these ideas can be applied to your own code.</p>
<p>Python strings are very flexible, and Python is an extremely powerful tool for string-based manipulations. If you don't do a lot of string processing in your daily work, try designing a tool that is exclusively intended for manipulating strings. Try to come up with something innovative, but if you're stuck, consider writing a web log analyzer (how many requests per hour? How many people visit more than five pages?) or a template tool that replaces certain variable names with the contents of other files.</p>
<p>Spend a lot of time toying with the string formatting operators until you've got the syntax memorized. Write a bunch of template strings and objects to pass into the format function, and see what kind of output you get. Try the exotic formatting operators, such as percentage or hexadecimal notation. Try out the fill and alignment operators, and see how they behave differently for integers, strings, and floats. Consider writing a class of your own that has a <kbd>__format__</kbd> method; we didn't discuss this in detail, but explore just how much you can customize formatting.</p>
<p>Make sure you understand the difference between <kbd>bytes</kbd> and <kbd>str</kbd> objects. The distinction is very complicated in older versions of Python (there was no <kbd>bytes</kbd>, and <kbd>str</kbd> acted like both <kbd>bytes</kbd> and <kbd>str</kbd> unless we needed non-ASCII characters, in which case there was a separate <kbd>unicode</kbd> object, which was similar to Python 3's <kbd>str</kbd> class. It's even more confusing than it sounds!). It's clearer nowadays; <kbd>bytes</kbd> is for binary data, and <kbd>str</kbd> is for character data. The only tricky part is knowing how and when to convert between the two. For practice, try writing text data to a file opened for writing <kbd>bytes</kbd> (you'll have to encode the text yourself), and then reading from the same file.</p>
<p>Do some experimenting with <kbd>bytearray</kbd>. See how it can act both like a <kbd>bytes</kbd> object and a list or container object at the same time. Try writing to a buffer that holds data in the bytes array until it is a certain length before returning it. You can simulate the code that puts data into the buffer by using <kbd>time.sleep</kbd> calls to ensure data doesn't arrive too quickly.</p>
<p>Study regular expressions online. Study them some more. Especially learn about named groups, greedy versus lazy matching, and regex flags, three features that we didn't cover in this chapter. Make conscious decisions about when not to use them. Many people have very strong opinions about regular expressions and either overuse them or refuse to use them at all. Try to convince yourself to use them only when appropriate, and figure out when that is.</p>
<p>If you've ever written an adapter to load small amounts of data from a file or database and convert it to an object, consider using a pickle instead. Pickles are not efficient for storing massive amounts of data, but they can be useful for loading configuration or other simple objects. Try coding it multiple ways: using a pickle, a text file, or a small database. Which do you find easiest to work with?</p>
<p>Try experimenting with pickling data, then modifying the class that holds the data, and loading the pickle into the new class. What works? What doesn't? Is there a way to make drastic changes to a class, such as renaming an attribute or splitting it into two new attributes and still get the data out of an older pickle? (Hint: try placing a private pickle version number on each object and update it each time you change the class; you can then put a migration path in <kbd>__setstate__</kbd>.)</p>
<p>If you do any web development at all, do some experimenting with the JSON serializer. Personally, I prefer to serialize only standard JSON serializable objects, rather than writing custom encoders or <kbd>object_hooks</kbd>, but the desired effect really depends on the interaction between the frontend (JavaScript, typically) and backend code.</p>
<p>Create some new directives in the templating engine that take more than one or an arbitrary number of arguments. You might need to modify the regular expression or add new ones. Have a look at the Django project's online documentation, and see whether there are any other template tags you'd like to work with. Try mimicking their filter syntax instead of using the <kbd>variable</kbd> tag.</p>
<p>Revisit this chapter when you've studied iteration and coroutines and see whether you can come up with a more compact way of representing the state between related directives, such as the loop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We've covered string manipulation, regular expressions, and object serialization in this chapter. Hardcoded strings and program variables can be combined into outputtable strings using the powerful string formatting system. It is important to distinguish between binary and textual data, and <kbd>bytes</kbd> and <kbd>str</kbd> have specific purposes that must be understood. Both are immutable, but the <kbd>bytearray</kbd> type can be used when manipulating bytes.</p>
<p>Regular expressions are a complex topic, and we only scratched the surface. There are many ways to serialize Python data; pickles and JSON are two of the most popular.</p>
<p>In the next chapter, we'll look at a design pattern that is so fundamental to Python programming that it has been given special syntax support: the iterator pattern.</p>


            </article>

            
        </section>
    </body></html>