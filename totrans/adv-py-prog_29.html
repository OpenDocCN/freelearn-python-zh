<html><head></head><body>
<div><div><div><h1 id="_idParaDest-392"><em class="italic"><a id="_idTextAnchor373"/>Chapter 26</em>: The Observer Pattern</h1>
			<p>We use the observer pattern when we want to be able to inform/notify all stakeholders (an object or a group of objects) when the state of an object changes. An important feature of the observer pattern is that the number of subscribers/observers, as well as who the subscribers are, may vary and can be changed at runtime. </p>
			<p>In this chapter, we will learn about this design pattern while comparing it to a similar one we have seen in the past, known as the MVC pattern, and use it to implement a data formatter.</p>
			<p>Specifically, we will cover the following topics:</p>
			<ul>
				<li>Understanding the observer pattern</li>
				<li>Real-world examples</li>
				<li>Use cases</li>
				<li>Implementation</li>
			</ul>
			<h1 id="_idParaDest-393"><a id="_idTextAnchor374"/>Technical requirements</h1>
			<p>The code files for this chapter can be found at <a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter26">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter26</a>.</p>
			<h1 id="_idParaDest-394"><a id="_idTextAnchor375"/>Understanding the observer pattern</h1>
			<p>When we need to update <a id="_idIndexMarker1430"/>a group of objects when the state of another object <a id="_idIndexMarker1431"/>changes, a popular solution is offered by the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) pattern. Let's assume that we are using the data of the same <em class="italic">model</em> in two <em class="italic">views</em>; for instance, in a pie chart and a spreadsheet. Whenever the model is modified, both views need to be updated. That's the role of the observer pattern.</p>
			<p>The observer pattern describes <a id="_idIndexMarker1432"/>a publish-subscribe relationship between a single object – the publisher, which is also known as the <strong class="bold">subject</strong> or <strong class="bold">observable</strong> – and one or <a id="_idIndexMarker1433"/>more objects – the subscribers, also known as <strong class="bold">observers</strong>.</p>
			<p>In the case of MVC, the publisher is the model, while the subscribers are the views. There are other examples that we will discuss throughout this chapter.</p>
			<p>The ideas behind the observer pattern are the same as those behind the separation of concerns principle; that is, to increase decoupling between the publisher and subscribers, and to make it easy to add/remove subscribers at runtime. Let's look at a couple of examples of this.</p>
			<h1 id="_idParaDest-395"><a id="_idTextAnchor376"/>Real-world examples</h1>
			<p>In reality, an auction resembles the observer pattern. Every auction bidder has a numbered paddle that is <a id="_idIndexMarker1434"/>raised whenever they want to place a bid. Whenever the paddle is raised by a bidder, the auctioneer acts as the subject by updating the price of the bid and broadcasting the new price to all bidders (subscribers).</p>
			<p>In software, we can cite at least two examples:</p>
			<ul>
				<li>Kivy, the Python framework for developing user interfaces, has a module called <strong class="bold">Properties</strong>, which implements the <a id="_idIndexMarker1435"/>observer pattern. Using this technique, you can specify what should happen when a property's value changes.</li>
				<li>The RabbitMQ library can be used to add asynchronous messaging support to an application. Several messaging protocols are supported, such as HTTP and AMQP. RabbitMQ can be used in a Python application to implement a publish-subscribe pattern, which is nothing more than the observer design pattern (<a href="http://j.mp/rabbitmqobs">j.mp/rabbitmqobs</a>).</li>
			</ul>
			<p>In the next section, we will discuss when this design pattern could and should be used.</p>
			<h1 id="_idParaDest-396"><a id="_idTextAnchor377"/>Use cases</h1>
			<p>We generally use the observer pattern when we want to inform/update <em class="italic">one or more objects</em> (observers/subscribers) about a <a id="_idIndexMarker1436"/>change that happened on <em class="italic">a given object</em> (subject/publisher/observable). The number of observers, as well as who those observers are, may vary and can be changed dynamically.</p>
			<p>We can think of many cases where the observer pattern can be useful. One such use case is <strong class="bold">newsfeeds</strong>. With RSS, Atom, or other related formats, you follow a feed, and every time it is updated, you receive a notification about the update.</p>
			<p>The same concept exists in social networking. If you are connected to another person using a social networking service, and your connection updates something, you are notified about it. It doesn't matter if the connection is a Twitter user that you follow, a real friend on Facebook, or a business colleague on LinkedIn.</p>
			<p><strong class="bold">Event-driven systems</strong> is another example where the observer pattern is usually used. In such systems, you have <em class="italic">listeners</em> that <em class="italic">listen</em> for specific events. The listeners are triggered when an event <a id="_idIndexMarker1437"/>they are listening to is created. This can be typing a specific key (on the keyboard), moving the mouse, and more. The event plays the role of the publisher, and the listeners play the role of the observers. The key point, in this case, is that multiple listeners (observers) can be attached to a single event (publisher).</p>
			<p>Finally, in the next section, we will implement a data formatter.</p>
			<h1 id="_idParaDest-397"><a id="_idTextAnchor378"/>Implementation</h1>
			<p>The ideas described here are based on <a id="_idIndexMarker1438"/>the ActiveState Python Observer code recipe (<a href="https://code.activestate.com/">https://code.activestate.com/</a>). There is a default formatter that shows a value in decimal format. However, we can add/register more formatters. In this example, we will add a hex formatter and a binary formatter. Every time the value of the default formatter is updated, the registered formatters will be notified and take action. In this case, the action is to show the new value in the relevant format.</p>
			<p>The observer pattern is one of the patterns where inheritance makes sense. We can have a base <code>Publisher</code> class that contains the common functionality of adding, removing, and notifying observers. Our <code>DefaultFormatter</code> class derives from <code>Publisher</code> and adds the formatter-specific functionality. We can also dynamically add and remove observers on demand.</p>
			<p>We will begin with the <code>Publisher</code> class. The observers are kept in the observer's list. The <code>add()</code> method registers <a id="_idIndexMarker1439"/>a new observer or throws an error if it already exists. The <code>remove()</code> method unregisters an existing observer or throws an exception if it does not exist. Finally, the <code>notify()</code> method informs all observers about a change. This is shown in the following code block:</p>
			<pre>class Publisher:  
    def __init__(self):  
        self.observers = []  
 
    def add(self, observer):  
        if observer not in self.observers:  
            self.observers.append(observer)  
        else:  
            print(f'Failed to add: {observer}')  
 
    def remove(self, observer):  
        try:  
            self.observers.remove(observer)  
        except ValueError:  
            print(f'Failed to remove: {observer}')  
 
    def notify(self):  
        [o.notify(self) for o in self.observers]  </pre>
			<p>Let's continue with the <code>DefaultFormatter</code> class. The first thing that <code>__init__()</code> does is call the <code>__init__()</code> method of the base class since this is not done automatically in Python.</p>
			<p>A <code>DefaultFormatter</code> instance has a name to make it easier for us to track its status. We use <code>_data</code> variable to state that it should not be accessed directly. Note that this is <a id="_idIndexMarker1440"/>always possible in Python but fellow developers have no excuse for doing so since the code already states that they shouldn't. <code>DefaultFormatter</code> treats the <code>_data</code> variable as an integer, and the default value is <code>0</code>:</p>
			<pre>class DefaultFormatter(Publisher):  
     def __init__(self, name):  
         Publisher.__init__(self)  
         self.name = name  
         self._data = 0</pre>
			<p>The <code>__str__()</code> method returns information about the name of the publisher and the value of the <code>_data</code> attribute. <code>type(self).__name__</code> is a handy trick to get the name of a class without hardcoding it. It is one of those tricks that makes your code easier to maintain:</p>
			<pre>def __str__(self):
     return f"{type(self).__name__}: '{self.name}' \
       has data = 
     {self._data}"</pre>
			<p>There are two <code>data()</code> methods. The first one uses the <code>@property</code> decorator to give read access to the <code>_data</code> variable. Using this, we can just execute <code>object.data</code> instead of <code>object.data()</code>:</p>
			<pre>@property  
def data(self):  
    return self._data</pre>
			<p>The second <code>data()</code> method is more interesting. It uses the <code>@setter</code> decorator, which is called every time the assignment (<code>=</code>) operator is used to assign a new value to the <code>_data</code> variable. This method also tries to cast a new value to an integer, and does exception handling in case this operation fails:</p>
			<pre>@data.setter  
def data(self, new_value):  
    try:  
       self._data = int(new_value)  
    except ValueError as e:  
       print(f'Error: {e}')  
    else:
       self.notify()</pre>
			<p>The next step is to add <a id="_idIndexMarker1441"/>the observers. The functionality of <code>HexFormatter</code> and <code>BinaryFormatter</code> is very similar. The only difference between them is how they format the value of the data that's received by the publisher – that is, in hexadecimal and binary, respectively:</p>
			<pre>class HexFormatterObs:  
    def notify(self, publisher):  
        value = hex(publisher.data)
        print(f"{type(self).__name__}: '{publisher.name}' \
           has now hex data = {value}")  
 
class BinaryFormatterObs:  
    def notify(self, publisher):  
        value = bin(publisher.data)
        print(f"{type(self).__name__}: '{publisher.name}' \
          has now bin data = {value}")</pre>
			<p>To help us use those classes, the <code>main()</code> function initially creates a <code>DefaultFormatter</code> instance named <code>test1</code> and, afterward, attaches (and detaches) the two available observers. We also have some exception handling to ensure that the application doesn't crash <a id="_idIndexMarker1442"/>when erroneous data is passed by the user.</p>
			<p>The code is as follows:</p>
			<pre>def main():  
    df = DefaultFormatter('test1')  
    print(df)  
 
    print()  
    hf = HexFormatterObs()  
    df.add(hf)  
    df.data = 3  
    print(df)  
 
    print()  
    bf = BinaryFormatterObs()  
    df.add(bf)  
    df.data = 21  
    print(df)</pre>
			<p>Moreover, tasks such as trying to add the same observer twice or removing an observer that does not exist should cause no crashes:</p>
			<pre>print()  
df.remove(hf)  
df.data = 40  
print(df)  
 
print()  
df.remove(hf)  
df.add(bf)  
 
df.data = 'hello'  
print(df)  
 
print()  
df.data = 15.8  
print(df)</pre>
			<p>Before we run this code <a id="_idIndexMarker1443"/>and observe the output, let's have a recap on the full code (the <code>observer.py</code> file):</p>
			<ol>
				<li> First, we define the <code>Publisher</code> class. </li>
				<li>Then, we define the <code>DefaultFormatter</code> class, along with its <code>special __init__</code> and <code>__str__</code> methods. </li>
				<li>We add the <code>data</code> property getter and setter methods to the <code>DefaultFormatter</code> class. </li>
				<li>We define our two observer classes. </li>
				<li>Finally, we take care of the main part of the program.</li>
			</ol>
			<p>Executing the <code>python observer.py</code> command gives us the following output:</p>
			<pre>DefaultFormatter: 'test1' has data = 0
HexFormatterObs: 'test1' has now hex data = 0x3
DefaultFormatter: 'test1' has data = 3
HexFormatterObs: 'test1' has now hex data = 0x15
BinaryFormatterObs: 'test1' has now bin data = 0b10101
DefaultFormatter: 'test1' has data = 21
BinaryFormatterObs: 'test1' has now bin data = 0b101000
DefaultFormatter: 'test1' has data = 40
Failed to remove: &lt;__main__.HexFormatterObs object at 
0x7fe6e4c9d670&gt;
Failed to add: &lt;__main__.BinaryFormatterObs object at 
0x7fe6e4c9d5b0&gt;
Error: invalid literal for int() with base 10: 'hello'
DefaultFormatter: 'test1' has data = 40
BinaryFormatterObs: 'test1' has now bin data = 0b1111
DefaultFormatter: 'test1' has data = 15</pre>
			<p>Here, we can see that as the extra observers are added, the more (and more relevant) output is shown, and when an observer is removed, it is not notified any longer. That's exactly what we want: runtime notifications that we can enable/disable on demand.</p>
			<p>The defensive programming part of the application also seems to work fine. Trying to do funny things, such <a id="_idIndexMarker1444"/>as removing an observer that does not exist or adding the same observer twice, is not allowed. The messages that are shown are not very user-friendly, but I leave it up to you to make them friendlier as an exercise. Runtime failures such as trying to pass a string when the API expects a number are also handled properly without causing the application to crash/terminate.</p>
			<p>This example would be much more interesting if it were interactive. Even a simple menu that allows the user to attach/detach observers at runtime and modify the value of <code>DefaultFormatter</code> would be nice because the runtime aspect becomes much more visible. Feel free to do this.</p>
			<p>Another nice exercise is to add more observers. For example, you can add an octal formatter, a Roman <a id="_idIndexMarker1445"/>numeral formatter, or any other observer that uses your favorite representation. Be creative! With this, we have completed our discussion on the observer pattern.</p>
			<h1 id="_idParaDest-398"><a id="_idTextAnchor379"/>Summary</h1>
			<p>In this chapter, we covered the observer design pattern, including many examples, such as Kivy, the framework for developing innovative user interfaces, along with its <strong class="bold">Properties</strong> concept and module, and the Python bindings of RabbitMQ (we referred to a specific example of RabbitMQ that's used to implement the publish-subscribe, or the observer, pattern).</p>
			<p>We also learned how to use the observer pattern to create data formatters that can be attached and detached at runtime to enrich the behavior of an object. Hopefully, you will find the recommended exercises interesting.</p>
			<p>This also marks the end of this book. Congratulations on making it to the end, and I hope that the material that's been covered has been helpful for you in taking your Python skills to the next level!</p>
			<h1 id="_idParaDest-399"><a id="_idTextAnchor380"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">What is the main motivation for the observer pattern?</li>
				<li>How is the observer pattern different from the MVC pattern when it comes to updating other components of an application when a target component changes?</li>
				<li>How is the observer pattern implemented in the Python example of value formatters?</li>
			</ol>
		</div>
	</div>
</div>
</body></html>