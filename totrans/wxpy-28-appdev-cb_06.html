<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Retrieving Information from Users</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Selecting files with a<code class="literal"> FileDialog</code></li><li class="listitem" style="list-style-type: disc">Searching text with a<code class="literal"> FindReplaceDialog</code></li><li class="listitem" style="list-style-type: disc">Getting images with<code class="literal"> ImageDialog</code></li><li class="listitem" style="list-style-type: disc">Using the Print dialogs</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec01"/>Introduction</h1></div></div></div><p>Being able to retrieve information from users is an essential part of any application. Dialogs are one of the many ways of retrieving information from users; most desktop applications use a number of common dialogs for tasks such as opening, saving, and printing files.<a id="id230" class="indexterm"/>
</p><p>There are two main types of dialogs: Modal and Modeless. Modal dialogs are dialogs that, when shown, block and disable interaction with their parent window or all other windows in an application (in the case of an application-modal dialog). Modal dialogs are used for cases where a program must retrieve data from a user before proceeding to its next task. Modeless dialogs, on the other hand, behave similarly to Frames. When modeless dialogs are shown, the other windows in the application remain accessible. When closed, modeless dialogs will usually post an event to their parent window to inform it that the dialog has closed.<a id="id231" class="indexterm"/>
</p><p>wxPython supplies many built-in dialogs that can fill the needs of almost any common circumstance. So let's take a look at a handful of these common dialogs in action with the recipes in this chapter.<a id="id232" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec02"/>Selecting files with a FileDialog</h1></div></div></div><p>Allowing users to open and save files is one of the most fundamental capabilities of many applications. To provide this functionality, it is often necessary to give the user the ability to select which files to open, what to name a file, and where to put it when saving a new file. The<code class="literal"> FileDialog</code> can be used to fill this role in your application. This recipe creates a simple text editor application that can open and save text files to show how to use the<code class="literal"> FileDialog</code>.<a id="id233" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec01"/>How to do it...</h2></div></div></div><p>Here, we will create a complete text-editor application:<a id="id234" class="indexterm"/>
</p><div><pre class="programlisting">import wx

class FileEditorApp(wx.App):
    def OnInit(self):
        self.frame = FileEditorFrame(None,
                                     title="File Editor")
        self.frame.Show()
        return True

</pre></div><p>Our main application window is defined here, and consists of a Frame, TextCtrl, and MenuBar:<a id="id235" class="indexterm"/>
</p><div><pre class="programlisting">class FileEditorFrame(wx.Frame):
    def __init__(self, parent, *args, **kwargs):
        super(FileEditorFrame, self).__init__(*args, **kwargs) 

        # Attributes
        self.file = None
        style = style=wx.TE_MULTILINE|wx.TE_RICH2
        self.txtctrl = wx.TextCtrl(self, style=style)

        # Setup
        self._SetupMenus()

        # Layout
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.txtctrl, 1, wx.EXPAND)
        self.SetSizer(sizer)

        # Event Handlers
        self.Bind(wx.EVT_MENU, self.OnOpen, id=wx.ID_OPEN)
        self.Bind(wx.EVT_MENU, self.OnSave, id=wx.ID_SAVE)
        self.Bind(wx.EVT_MENU, self.OnSave, id=wx.ID_SAVEAS)
        self.Bind(wx.EVT_MENU, self.OnExit, id=wx.ID_EXIT)
        self.Bind(wx.EVT_CLOSE, self.OnExit)

    def _SetupMenus(self):
        """Make the frames menus"""
        menub = wx.MenuBar()
        fmenu = wx.Menu()
        fmenu.Append(wx.ID_OPEN, "Open\tCtrl+O")
        fmenu.AppendSeparator()
        fmenu.Append(wx.ID_SAVE, "Save\tCtrl+S")
        fmenu.Append(wx.ID_SAVEAS, "Save As\tCtrl+Shift+S")
        fmenu.AppendSeparator()
        fmenu.Append(wx.ID_EXIT, "Exit\tCtrl+Q")
        menub.Append(fmenu, "File")
        self.SetMenuBar(menub)

</pre></div><p>Here are the event handlers for the<code class="literal"> MenuItems</code> we added to the Frame's MenuBar above. These event handlers are used mostly to just delegate to the method that performs the action the user requested.<a id="id236" class="indexterm"/>
</p><div><pre class="programlisting">    #---- Event Handlers ----#

    def OnOpen(self, event):
        """Handle Open"""
        if event.GetId() == wx.ID_OPEN:
            self.DoOpen()
        else:
            event.Skip()

    def OnSave(self, event):
        """Handle Save/SaveAs"""
        evt_id = event.GetId()
        if evt_id in (wx.ID_SAVE,
                      wx.ID_SAVEAS):
            if self.file:
                self.Save(self.file)
            else:
                self.DoSaveAs()
        else:
            event.Skip()

    def OnExit(self, event):
        """Handle window close event"""
        # Give warning about unsaved changes
        if self.txtctrl.IsModified():
            message = ("There are unsaved changes.\n\n"
                       "Would you like to save them?")
            style = wx.YES_NO|wx.ICON_WARNING|wx.CENTRE
            result = wx.MessageBox(message,
                                   "Save Changes?",
                                   style=style)
            if result == wx.YES:
                if self.file is None:
                    self.DoSaveAs()
                else:
                    self.Save(self.file)
        event.Skip()

    #---- End Event Handlers ----#

    #---- Implementation ----#

</pre></div><p>Here, in the<code class="literal"> DoOpen</code> method, we make the first use of the<code class="literal"> FileDialog</code> in<code class="literal"> OPEN</code> mode to allow the user to select the file they wish to open:<a id="id237" class="indexterm"/>
</p><div><pre class="programlisting">    def DoOpen(self):
        """Show file open dialog and open file"""
        wildcard = "Text Files (*.txt)|*.txt"
        dlg = wx.FileDialog(self,
                            message="Open a File",
                            wildcard=wildcard,
                            style=wx.FD_OPEN)
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            with open(path, "rb") as handle:
                text = handle.read()
                self.txtctrl.SetValue(text)
                self.file = path
        dlg.Destroy()

</pre></div><p>In<code class="literal"> DoSaveAs</code>, we see the second use of the<code class="literal"> FileDialog</code> to allow the user to choose where to save the file to, by creating the dialog in<code class="literal"> SAVE</code> mode.</p><div><pre class="programlisting">    def DoSaveAs(self):
        """Show SaveAs dialog"""
        wildcard = "Text Files (*.txt)|*.txt"
        dlg = wx.FileDialog(self,
                            message="Save As",
                            wildcard=wildcard,
                            style=wx.FD_SAVE
                                  |wx.FD_OVERWRITE_PROMPT)
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            self.Save(path)
            self.file = path
        dlg.Destroy()

    def Save(self, path):
        """Save the file"""
        with open(path, "wb") as handle:
            text = self.txtctrl.GetValue()
            handle.write(text)
            self.txtctrl.SetModified(False)
        
    #---- End Implementation ----#

#---- Main Execution ----#
if __name__ == "__main__":
    app = FileEditorApp(False)
    app.MainLoop()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec02"/>How it works...</h2></div></div></div><p>Just to provide a feel of how quickly you can create a usable application in wxPython, let's just look at the recipe above. In roughly 100 lines of code, we have basically implemented a Windows Notepad clone. Since this recipe was about the<code class="literal"> FileDialog</code>, let's just focus in on the<code class="literal"> DoOpen</code> and<code class="literal"> DoSaveAs</code> methods of our text editor application, to see how it works.<a id="id238" class="indexterm"/>
</p><p>The<code class="literal"> FileDialog</code> has two basic modes: Open and Save. The mode of the dialog depends upon which style flags it was created with. Our<code class="literal"> DoOpen</code> method creates it with the<code class="literal"> FD_OPEN</code> style flag, which puts it into Open mode. Open mode differs from Save mode in that it only allows you to select a file and not enter a name in order to create a new one.<a id="id239" class="indexterm"/>
</p><p>In both of our uses of the<code class="literal"> FileDialog</code> in this application, we used the same set of optional parameters for creating it. The<code class="literal"> wildcards</code> parameter accepts a specially-formatted string to specify the file filter list in the dialog. This string must be formatted as follows:</p><div><pre class="programlisting">“All Files (*)|*|Text Files (*.txt;*.in)|*.txt;*.in”
</pre></div><p>The fields in this string are interpreted as follows:</p><div><pre class="programlisting">Description1|wildcard1|Description2|wildcard1;wildcard2
</pre></div><p>Each field is a description followed by the pipe character as a separator, and then the<code class="literal"> wx.ID_OK</code> wildcards to associate with that description. Multiple wildcards are separated by a semicolon.<a id="id240" class="indexterm"/>
</p><p>Once the dialog is set up, its usage is quite simple. It just needs to be shown by using<code class="literal"> ShowModal</code>. Then, if the user closed it with the affirmative, we just need to call the dialog's<code class="literal"> GetPath</code> method in order to get the path that was selected or entered into the dialog by the user.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec03"/>There's more...</h2></div></div></div><p>The<code class="literal"> FileDialog's</code> constructor takes a number of parameters to customize its behavior; see below for more information on how to setup a<code class="literal"> FileDIalog</code>.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec01"/>Default paths</h3></div></div></div><p>The<code class="literal"> FileDialog</code> has a few extra parameters that we did not use in our application, and that can be used to customize its initial state. The first is the<code class="literal"> defaultDir</code> parameter, which takes a directory path as a value. This path must exist, and will ensure that the dialog is shown with that directory selected initially. The other additional parameter is<code class="literal"> defaultFile</code>, which takes the name of a file as a value. This will be put as the default value in the dialog's filename field.<a id="id241" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec02"/>Style flags</h3></div></div></div><p>The style flags and their descriptions are shown in the following table:<a id="id242" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Style Flags</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FD_DEFAULT_STYLE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Same as<code class="literal"> wx.FD_OPEN</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FD_OPEN</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Create it as an Open dialog. Cannot be combined with<code class="literal"> wx.FD_SAVE</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FD_SAVE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Create it as a Save dialog. Cannot be combined with<code class="literal"> wx.FD_OPEN</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FD_OVERWRITE_PROMPT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Prompt for confirmation if the path already exists. For Save dialog only.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FD_FILE_MUST_EXIST</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allow users to select only files that actually exist. For Open dialog only.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FD_MULTIPLE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allow multiple files to be selected. For Open dialog only. Should use the dialogs<code class="literal"> GetPaths</code> method to get the list of selected paths.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FD_PREVIEW</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Show a preview of the selected file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FD_CHANGE_DIR</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Change the current working directory to where the user selected the file(s). If not using the<code class="literal"> defaultDir</code> parameter, the next time the dialog is opened, it will open to the last-used location.</p>
</td></tr></tbody></table></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec04"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Utilizing Stock IDs</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> explains the usage of the built-in IDs.</li><li class="listitem" style="list-style-type: disc">The<em> Handling events</em> recipe in<a class="link" href="ch02.html" title="Chapter 2. Responding to Events"> Chapter 2</a>,<em> Responding to Events</em> covers the basics of event handling.</li><li class="listitem" style="list-style-type: disc">The<em> Adding Menus and MenuBars</em> recipe in <a class="link" href="ch03.html" title="Chapter 3. Basic Building Blocks of a User Interface">Chapter 3</a>, <em>Basic Building Blocks of a User Interface</em> discusses how to add menus to a Frame.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec03"/>Searching text with a FindReplaceDialog</h1></div></div></div><p>The<code class="literal"> FindReplaceDialog</code> is a common dialog for getting information from the user in order to perform find and replace actions in an application. The<code class="literal"> FindReplaceDialog</code> is always used as a modeless dialog, and emits events when its buttons are clicked that notify the parent window of the action that the user wishes to perform. This recipe will extend the previous recipe (<code class="literal">FileDialog</code>) to show how to add the Find and Replace functionality to an application using the<code class="literal"> FindReplaceDialog</code>.<a id="id243" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec05"/>How to do it...</h2></div></div></div><p>Here we will show how we subclassed the<code class="literal"> FileEditorFrame</code> to add find and replace functionality with the<code class="literal"> FindReplaceDialog:</code>
</p><div><pre class="programlisting">import wx
# FileDialog Recipe sample module
import filedialog

class FindReplaceEditorFrame(filedialog.FileEditorFrame):
    def __init__(self, parent, *args, **kwargs):
        super(FindReplaceEditorFrame, self).__init__(*args,
                                                     **kwargs)

        # Attributes
        self.finddlg = None
        self.finddata = wx.FindReplaceData()

        # Setup
        menub = self.GetMenuBar()
        editmenu = wx.Menu()
        editmenu.Append(wx.ID_FIND, "Find\tCtrl+F")
        editmenu.Append(wx.ID_REPLACE, "Replace\tCtrl+R")
        menub.Append(editmenu, "Edit")

        # Event Handlers
        self.Bind(wx.EVT_MENU,
                  self.OnFindMenu,
                  id=wx.ID_FIND)
        self.Bind(wx.EVT_MENU,
                  self.OnFindMenu,
                  id=wx.ID_REPLACE)
        self.Bind(wx.EVT_FIND, self.OnFind)
        self.Bind(wx.EVT_FIND_NEXT, self.OnFind)
        self.Bind(wx.EVT_FIND_REPLACE, self.OnReplace)
        self.Bind(wx.EVT_FIND_REPLACE_ALL, self.OnReplaceAll)
        self.Bind(wx.EVT_FIND_CLOSE, self.OnFindClose)

</pre></div><p>This method is a helper method that creates the<code class="literal"> FindReplaceDialog</code> in the correct mode, depending on which action the user selects from the Menu:<a id="id244" class="indexterm"/>
</p><div><pre class="programlisting">    def _InitFindDialog(self, mode):
        if self.finddlg:
            self.finddlg.Destroy()

        style = (wx.FR_NOUPDOWN
                 |wx.FR_NOMATCHCASE
                 |wx.FR_NOWHOLEWORD)
        if mode == wx.ID_REPLACE:
            style |= wx.FR_REPLACEDIALOG
            title = "Find/Replace"
        else:
            title = "Find"
        dlg = wx.FindReplaceDialog(self,
                                   self.finddata,
                                   title,
                                   style)
        self.finddlg = dlg

    # ---- Event Handlers ----#

</pre></div><p>This first event handler is used to handle the events when a menu item is selected, and will be used to create and show the appropriate version of the<code class="literal"> FindReplaceDialog:</code>
</p><div><pre class="programlisting">    def OnFindMenu(self, event):
        evt_id = event.GetId()
        if evt_id in (wx.ID_FIND, wx.ID_REPLACE):
            self._InitFindDialog(evt_id)
            self.finddlg.Show()
        else:
            event.Skip()

</pre></div><p>These next four event handlers handle events that are generated by the<code class="literal"> FindReplaceDialog</code> in response to user actions:<a id="id245" class="indexterm"/>
</p><div><pre class="programlisting">    def OnFind(self, event):
        """Find text"""
        findstr = self.finddata.GetFindString()
        if not self.FindString(findstr):
            wx.Bell() # beep at the user for no match

    def OnReplace(self, event):
        """Replace text"""
        rstring = self.finddata.GetReplaceString()
        fstring = self.finddata.GetFindString()
        cpos = self.GetInsertionPoint()
        start, end = cpos, cpos
        if fstring:
            if self.FindString(fstring):
                start, end = self.txtctrl.GetSelection()
        self.txtctrl.Replace(start, end, rstring)

    def OnReplaceAll(self, event):
        """Do a replace all"""
        rstring = self.finddata.GetReplaceString()
        fstring = self.finddata.GetFindString()
        text = self.txtctrl.GetValue()
        newtext = text.replace(fstring, rstring)
        self.txtctrl.SetValue(newtext)

    def OnFindClose(self, event):
        if self.finddlg:
            self.finddlg.Destroy()
            self.finddlg = None

    #---- End Event Handlers ----#

    #---- Implementation ----#

</pre></div><p>Finally, here we have a very simple method of searching for a given string in the<code class="literal"> TextCtrl</code>, and setting the selection if a match is found:<a id="id246" class="indexterm"/>
</p><div><pre class="programlisting">    def FindString(self, findstr):
        """Find findstr in TextCtrl and set selection"""
        text = self.txtctrl.GetValue()
        csel = self.txtctrl.GetSelection()
        if csel[0] != csel[1]:
            cpos = max(csel)
        else:
            cpos = self.txtctrl.GetInsertionPoint()

        if cpos == self.txtctrl.GetLastPosition():
            cpos = 0

        # Do a simple case insensitive search 
        # to find the next match
        text = text.upper()
        findstr = findstr.upper()
        found = text.find(findstr, cpos)
        if found != -1:
            end = found + len(findstr)
            self.txtctrl.SetSelection(end, found)
            self.txtctrl.SetFocus()
            return True
        return False

</pre></div><p>Running the previous code will result in a window like the following being shown:</p><div><img src="img/1780_06_01.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec06"/>How it works...</h2></div></div></div><p>In this recipe, we took the<code class="literal"> FileEditorFrame</code> class that we created in the last recipe and extended it to have find and replace functionality, by using the<code class="literal"> FindReplaceDialog</code>. So let's take a look at how we made use of the<code class="literal"> FindReplaceDialog</code> by walking through what we added to this class from top to bottom.<a id="id247" class="indexterm"/>
</p><p>In our<code class="literal"> FindReplaceEditorFrame</code> class's<code class="literal"> __init__</code> method, we added two instance attributes,<code class="literal"> finddlg</code> and<code class="literal"> finddata</code>. Since the<code class="literal"> FindReplaceDialog</code> is modeless, we need to keep track of it in our class so we can properly clean it up later, to ensure that it will get assigned to the<code class="literal"> finddlg</code> attribute when it is created. The second attribute,<code class="literal"> finddata</code>, holds a reference to the<code class="literal"> FindReplaceData</code> that is used for initializing the dialog, as well as for passing data back and forth between the dialog, and its parent window. We keep a reference to this item for two firstly, one it allows convenient access to the dialogs flags and user entered find and replace field strings, and secondly, by using the same<code class="literal"> FindReplaceData</code> object each time, the dialog will be initialized with the same settings that the user last used it with. The last thing to take note of in<code class="literal"> __init__</code> is the event binding: we bound to five of the events that the<code class="literal"> FindReplaceDialog</code> can emit as a user interacts with it.</p><p>The next new method is the<code class="literal"> _InitFindDialog</code> method. This method is what we use to initialize the<code class="literal"> FindReplaceDialog</code> in response to the<strong> Find</strong> or<strong> Replace</strong> menu item events. Since our application is only going to support a simple one-direction, case-insensitive search, we disabled all the extra options in the dialog with the appropriate style flags. Then we simply create the dialog with the<code class="literal"> FR_REPLACEDIALOG</code> flag if we are in replace mode, or without it if we are not, and finally assign the new dialog instance to our<code class="literal"> finddlg</code> attribute.</p><p>The next section to look at is our<code class="literal"> FindReplaceDialog</code> event handlers. This is where we handle the requested actions made by the user that is using the dialog.<code class="literal"> OnFind</code> handles the situation where the user clicks the<strong> Find</strong> or<strong> Find Next</strong> buttons in the dialog. Here, we first get the string that was entered into the dialog by using our<code class="literal"> finddata</code> attribute to access it. Then we perform a simple search in the text of the base class's<code class="literal"> TextCtrl</code>, selecting the match if one is found, or use<code class="literal"> wx.Bell</code> to make the computer beep at the user if no match is found.</p><p>
<code class="literal">OnReplace</code> is called in response to the<code class="literal"> FindReplaceDialogs</code>
<strong> Replace</strong> button in the<code class="literal"> FindReplaceDialog</code> being clicked. Here we get both the entered find and replace strings from the<code class="literal"> FindReplaceData</code>. We then try to find a match and replace that match with the entered replace string.<code class="literal"> OnReplaceAll</code> is called in response to the dialog's<strong> Replace All</strong> button being clicked, and does basically the same thing as<code class="literal"> OnReplace</code>, but applies it to all matches in the<code class="literal"> TextCtrl</code> text.<a id="id248" class="indexterm"/>
</p><p>The last event handler is<code class="literal"> OnFindClose</code>. This is called when the user closes the<code class="literal"> FindReplaceDialog</code>. We need to handle this event so that we can clean up the dialog by calling<code class="literal"> Destroy</code> on it. That's it. Now we have a text editor application that has find and replace functionality!</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec07"/>There's more...</h2></div></div></div><p>For simplicity's sake, this recipe disabled the dialog's extra find options. When these options are selected in the dialog, they can be checked for, just like the find and replace strings, by using the<code class="literal"> FindReplaceData</code> object. It will have the selected option's flags set in the value returned from<code class="literal"> GetFlags</code>, which is a bitmask of the<code class="literal"> FindReplaceData</code> flags. Due to the way in which these flags and the dialog's style flags are named, it can be a little confusing to know which are which, so please refer to the following two tables to distinguish between these two different, yet similarly-named sets of flags.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec03"/>FindReplaceDialog style flags</h3></div></div></div><p>These flags are flags that should be passed to the dialog's constructor's style parameter:<a id="id249" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Flags</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FR_NOMATCHCASE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Disable the "match case" checkbox</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FR_NOUPDOWN</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Disable the "up" and "down" radio buttons</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FR_NOWHOLEWORD</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Disable the "whole word" checkbox</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FR_REPLACEDIALOG</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Create the dialog in Replace mode</p>
</td></tr></tbody></table></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec04"/>FindReplaceData flags</h3></div></div></div><p>The following flags are flags that can be set in<code class="literal"> FindReplaceData</code> to set the initial state of the dialog and to identify the user's selected find preferences.<a id="id250" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Flags</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FR_DOWN</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The "down" radio button is selected</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FR_MATCHCASE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The "match case" checkbox is selected</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FR_WHOLEWORD</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The "whole word" checkbox is selected</p>
</td></tr></tbody></table></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec08"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Selecting files with a FileDialog</em> recipe for the base example that this recipe extends.</li><li class="listitem" style="list-style-type: disc">The<em> Understanding event propagation</em> recipe in<a class="link" href="ch02.html" title="Chapter 2. Responding to Events"> Chapter 2</a>,<em> Responding to Events</em> contains more information on how events are delivered to different windows.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec04"/>Getting images with ImageDialog</h1></div></div></div><p>
<code class="literal">ImageDialog</code> is a custom dialog class provided by the<code class="literal"> wx.lib.imagebrowser</code> module. It is similar in purpose to the default<code class="literal"> FileDialog</code>, but is specialized for allowing the user to select and preview images. This recipe shows how to use this dialog to retrieve a user-selected image and load it into a<code class="literal"> StaticBitmap</code> for display in the application's main window.<a id="id251" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec09"/>How to do it...</h2></div></div></div><p>Here we will create a very simple image viewer application that allows the user to select an image to view with the ImageDialog:</p><div><pre class="programlisting">import wx
import wx.lib.imagebrowser as imagebrowser

class ImageDialogApp(wx.App):
    def OnInit(self):
        self.frame = ImageDialogFrame(None,
                                       title="ImageDialog")
        self.frame.Show()
        return True

class ImageDialogFrame(wx.Frame):
    def __init__(self, parent, *args, **kwargs):
        super(ImageDialogFrame, self).__init__(*args, 
                                               **kwargs)wx.Frame.__init__(self, parent, *args, **kwargs)

        # Attributes
        self.panel = ImageDialogPanel(self)

class ImageDialogPanel(wx.Panel):
    def __init__(self, parent, *args, **kwargs):
        super(ImageDialogPanel, self).__init__(*args, 
                                               **kwargs)wx.Panel.__init__(self, parent, *args, **kwargs)

        # Attributes
        self.lastpath = None
        self.bmp = wx.StaticBitmap(self)
        self.btn = wx.Button(self, label="Choose Image")

        # Layout
        vsizer = wx.BoxSizer(wx.VERTICAL)
        hsizer = wx.BoxSizer(wx.HORIZONTAL)
        vsizer.Add(self.bmp, 0, wx.ALIGN_CENTER)
        vsizer.AddSpacer((5, 5))
        vsizer.Add(self.btn, 0, wx.ALIGN_CENTER)
        hsizer.AddStretchSpacer()
        hsizer.Add(vsizer, 0, wx.ALIGN_CENTER)
        hsizer.AddStretchSpacer()
        self.SetSizer(hsizer)

        # Event Handlers
        self.Bind(wx.EVT_BUTTON, self.OnShowDialog, self.btn)

    def OnShowDialog(self, event):
        # Create the dialog with the path cached
        # from the last time it was opened
        dlg = imagebrowser.ImageDialog(self, self.lastpath)
        if dlg.ShowModal() == wx.ID_OK:
            # Save the last used path
            self.lastpath = dlg.GetDirectory()
            imgpath = dlg.GetFile()
            bitmap = wx.Bitmap(imgpath)
            if bitmap.IsOk():
                self.bmp.SetBitmap(bitmap)
                self.Layout()
                self.bmp.Refresh()
        dlg.Destroy()

if __name__ == '__main__':
    app = ImageDialogApp(False)
    app.MainLoop()

</pre></div><p>Running the previous code and clicking on the Choose Image button will result in the following dialog being shown:<a id="id253" class="indexterm"/>
</p><div><img src="img/1780_06_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec10"/>How it works...</h2></div></div></div><p>In this recipe we created a simple little image viewer application that allows the user to use the<code class="literal"> ImageDialog</code> to choose an image that is on the computer's hard drive, and have this image displayed in the application's window.</p><p>This application follows the common pattern of most simple applications. So let's take a detailed look at how we used the<code class="literal"> ImageDialog</code>. First, we had to import the<code class="literal"> wx.lib.imagebrowser</code> module, as the<code class="literal"> ImageDialog</code> is not a part of the standard wx module. In our<code class="literal"> ImageDialogFrame</code> class, we added three instance attributes. The first is to hold the path that was last used by the<code class="literal"> ImageDialog</code>. We did this as a way to improve the usability of the application so that we can open the dialog to the last path the user used the next time they open it. The second attribute is a<code class="literal"> StaticBitmap</code> object, which we will use to display the image that the user selects with the<code class="literal"> ImageDialog</code>. Note that we used a<code class="literal"> StaticBitmap</code> in this example for simplicity. To better support larger-sized images, it would be better to draw the image on the<code class="literal"> Panel</code> ourselves. This approach will be covered by topics in<a class="link" href="ch08.html" title="Chapter 8. Drawing to the Screen"> Chapter 8</a>,<em> Drawing to the Screen</em>. The last attribute is just a button that will be used to trigger the event to show the<code class="literal"> ImageDialog</code>.</p><p>This application follows the common pattern of most simple applications. So let's take a detailed look at how we used the<code class="literal"> ImageDialog</code>. First, we had to import the<code class="literal"> wx.lib.imagebrowser</code> module, as the<code class="literal"> ImageDialog</code> is not a part of the standard wx module. In our<code class="literal"> ImageDialogFrame</code> class, we added three instance attributes. The first is to hold the path that was last used by the<code class="literal"> ImageDialog</code>. We did this as a way to improve the usability of the application so that we can open the dialog to the last path the user used the next time they open it. The second attribute is a<code class="literal"> StaticBitmap</code> object, which we will use to display the image that the user selects with the<code class="literal"> ImageDialog</code>. Note that we used a<code class="literal"> StaticBitmap</code> in this example for simplicity. To better support larger-sized images, it would be better to draw the image on the<code class="literal"> Panel</code> ourselves. This approach will be covered by topics in<a class="link" href="ch08.html" title="Chapter 8. Drawing to the Screen"> Chapter 8</a>,<em> Drawing to the Screen</em>. The last attribute is just a button that will be used to trigger the event to show the<code class="literal"> ImageDialog</code>.</p><p>Our<code class="literal"> OnShowDialog</code> method in this recipe creates the<code class="literal"> ImageDialog</code> and initializes it to the last path used. The first time, it will be None, which defaults to the current working directory. The dialog is then shown, in order to allow the user to navigate to and select an image to display. If they click on the dialog's<strong> Open</strong> button, the dialog will return<code class="literal"> wx.ID_OK</code>. At this point, we first get and save a reference to the last directory that the dialog was at so that we can restore it next time the dialog is shown. Then all that is left is to create the Bitmap and call the<code class="literal"> StaticBitmap's SetBitmap</code> method to change the image that is displayed. After this, it is necessary to call<code class="literal"> Layout</code> on the<code class="literal"> Panel</code>, to make sure the sizers can compensate for the new<code class="literal"> Bitmap's</code> size, and then we finally call<code class="literal"> Refresh</code> on the<code class="literal"> StaticBitmap</code> to make sure it is completely repainted.<a id="id254" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec11"/>There's more...</h2></div></div></div><p>The only other option available in the current version of the<code class="literal"> ImageDialog</code> is the ability to change the list of supported file filters. This can be done by passing to the dialog's<code class="literal"> ChangeFileTypes</code> method a list of tuples that contain the file type's description and wildcard string.</p><div><pre class="programlisting">
<strong>dlg.ChangeFileTypes([('png, '*.png'), ('jpeg', '*.jpg')])</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec12"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Using Bitmaps</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>, <em>Getting Started</em> with wxPython has additional examples of using Bitmaps and the<code class="literal"> StaticBitmap</code> class.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec05"/>Using the Print dialogs</h1></div></div></div><p>Adding printing support to an application can be a difficult task, as there are a number of tasks that need to be handled. These include selecting and configuring a printer, translating your on-screen presentation to paper, and ultimately sending the data to the printer.<a id="id255" class="indexterm"/>
</p><p>In wxPython, there are three dialog classes related to printing: the<code class="literal"> PageSetupDialog, PreviewFrame</code>, and<code class="literal"> Printer</code> classes. In addition to these classes, there are a number of supporting classes that must be used in conjunction with these dialogs, in order to add printing support to an application. This recipe shows some of the basics of how to use the wx printing framework, by creating a class that encapsulates the usage of the three printing dialogs and allows an application to print a<code class="literal"> Bitmap</code>.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec13"/>How to do it...</h2></div></div></div><p>In order to simplify and condense the many different steps required to support printing in an application, we will start by defining a class to encapsulate the different tasks into a few simple method calls:</p><div><pre class="programlisting">class BitmapPrinter(object):
    """Manages PrintData and Printing"""
    def __init__(self, parent):
        """Initializes the Printer
        @param parent: parent window
        """
        super(BitmapPrinter, self).__init__()

        # Attributes
        self.parent = parent
        self.print_data = wx.PrintData()

    def CreatePrintout(self, bmp):
        """Creates a printout object
        @param bmp: wx.Bitmap
        """
        assert bmp.IsOk(), "Invalid Bitmap!"
        data = wx.PageSetupDialogData(self.print_data)
        return BitmapPrintout(bmp, data)

</pre></div><p>The<code class="literal"> PageSetup</code> method handles the display of the printer setup dialog, and storage of the settings in the<code class="literal"> print_data</code> attributes:</p><div><pre class="programlisting">    def PageSetup(self):
        """Show the PrinterSetup dialog"""
        # Make a copy of our print data for the setup dialog
        dlg_data = wx.PageSetupDialogData(self.print_data)
        print_dlg = wx.PageSetupDialog(self.parent, dlg_data)
        if print_dlg.ShowModal() == wx.ID_OK:
            # Update the printer data with the changes from
            # the setup dialog.
            newdata = dlg_data.GetPrintData()
            self.print_data = wx.PrintData(newdata)
            paperid = dlg_data.GetPaperId()
            self.print_data.SetPaperId(paperid)
        print_dlg.Destroy()
)
</pre></div><p>In Preview, we create the<code class="literal"> PrintPreview</code> dialog to give a preview of what the printout will look like:<a id="id256" class="indexterm"/>
</p><div><pre class="programlisting">    def Preview(self, bmp):
        """Show the print preview
        @param bmp: wx.Bitmap
        """
        printout = self.CreatePrintout(bmp)
        printout2 = self.CreatePrintout(bmp)
        preview = wx.PrintPreview(printout, printout2,
                                  self.print_data)
        preview.SetZoom(100)
        if preview.IsOk():
            pre_frame = wx.PreviewFrame(preview,
                                        self.parent,
                                        "Print Preview")
            # The default size of the preview frame
            # sometimes needs some help.
            dsize = wx.GetDisplaySize()
            width = self.parent.GetSize()[0]
            height = dsize.GetHeight() - 100
            pre_frame.SetInitialSize((width, height))
            pre_frame.Initialize()
            pre_frame.Show()
        else:
            # Error
            wx.MessageBox("Failed to create print preview",
                          "Print Error",
                          style=wx.ICON_ERROR|wx.OK)

</pre></div><p>Finally, in the<code class="literal"> Print</code> method, we show the<code class="literal"> Printer</code> dialog to allow the user to request a printout of a<code class="literal"> Bitmap</code>, and send it to the printer to be printed:</p><div><pre class="programlisting">    def Print(self, bmp):
        """Prints the document"""
        pdd = wx.PrintDialogData(self.print_data)
        printer = wx.Printer(pdd)
        printout = self.CreatePrintout(bmp)
        result = printer.Print(self.parent, printout)
        if result:
            # Store copy of print data for future use
            dlg_data = printer.GetPrintDialogData()
            newdata = dlg_data.GetPrintData()
            self.print_data = wx.PrintData(newdata)
        elif printer.GetLastError() == wx.PRINTER_ERROR:
            wx.MessageBox("Printer error detected.",
                          "Printer Error",
                          style=wx.ICON_ERROR|wx.OK)
        printout.Destroy()

</pre></div><p>Here we will implement the<code class="literal"> Printout</code> object for printing<code class="literal"> Bitmaps</code>. The<code class="literal"> Printout</code> object is the object that is responsible for managing the print job and drawing the bitmap to the printer's device context:<a id="id257" class="indexterm"/>
</p><div><pre class="programlisting">class BitmapPrintout(wx.Printout):
    """Creates an printout of a Bitmap"""
    def __init__(self, bmp, data):
        super(BitmapPrintout, self).__init__()wx.Printout.__init__(self)

        # Attributes
        self.bmp = bmp
        self.data = data

    def GetPageInfo(self):
        """Get the page range information"""
        # min, max, from, to # we only support 1 page
        return (1, 1, 1, 1)

    def HasPage(self, page):
        """Is a page within range"""
        return page &lt;= 1

    def OnPrintPage(self, page):
        """Scales and Renders the bitmap
        to a DC and prints it
        """
        dc = self.GetDC() # Get Device Context to draw on

        # Get the Bitmap Size
        bmpW, bmpH = self.bmp.GetSize()

        # Check if we need to scale the bitmap to fit
        self.MapScreenSizeToPageMargins(self.data)
        rect = self.GetLogicalPageRect()
        w, h = rect.width, rect.height
        if (bmpW &gt; w) or (bmpH &gt; h):
            # Image is large so apply some scaling
            self.FitThisSizeToPageMargins((bmpW, bmpH),
                                          self.data)
            x, y = 0, 0
        else:
            # try to center it
            x = (w - bmpW) / 2
            y = (h - bmpH) / 2

        # Draw the bitmap to DC
        dc.DrawBitmap(self.bmp, x, y)

        return True

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec14"/>How it works...</h2></div></div></div><p>The<code class="literal"> BitmapPrinter</code> class encapsulates the three main print-related tasks that an application may need to support: printer setup, print preview, and printing. This class is the interface that the application which wants to allow printing<code class="literal"> Bitmaps</code> will use for all of its printing needs. All that the application requires is a<code class="literal"> Bitmap</code>, and all that it needs to do is to use one of the three methods,<code class="literal"> PageSetup, Preview</code>, and<code class="literal"> Print</code>. So let's take a look at how this class and these three methods work.<a id="id258" class="indexterm"/>
</p><p>The constructor takes one argument for a parent window. This will be used as the parent window for all of the dialogs. This will typically be an application's main window. We also create and store a reference to a<code class="literal"> PrintData</code> object in the constructor. All of the print dialogs use<code class="literal"> PrintData</code> in one form or another. This allows us to save any print configuration changes a user may make while using one of the dialogs.</p><p>
<code class="literal">PageSetup</code> is used to create and show the<code class="literal"> PageSetupDialog</code>. To use the<code class="literal"> PageSetupDialog</code>, we first create a<code class="literal"> PageSetupDialogData</code> object by passing our<code class="literal"> PrintData</code> object to its constructor, so it will use any settings that may already be persisted in our data object. We then simply create the dialog by passing in the<code class="literal"> PageSetupDialogData</code> object. If the dialog is closed by the OK button, we then get the<code class="literal"> PrintData</code> from the dialog and make a copy of it to store. It is important to make a copy, because when the<code class="literal"> PageSetupDialog</code> is destroyed it will delete the data.</p><p>
<code class="literal">Preview</code> creates a preview of what the printout will look like, and shows it with the<code class="literal"> PreviewFrame</code>. The<code class="literal"> PreviewFrame</code> requires a<code class="literal"> PrintPreview</code> object. To create the<code class="literal"> PrintPreview</code> object, it must be passed two<code class="literal"> Printout</code> objects and a<code class="literal"> PrintData</code> object. A<code class="literal"> Printout</code> object is what does the actual work of rendering what will be printed by the printer. We will come back to the details about how the<code class="literal"> Printout</code> works when we get to our<code class="literal"> BitmapPrintout</code> class. The first<code class="literal"> Printout</code> object is used for the<code class="literal"> PreviewFrame</code>, and the second one is used for the actual printing if the user clicks on the<code class="literal"> PreviewFrame's</code> Print button.</p><p>
<code class="literal">Print</code> creates a<code class="literal"> Printer</code> object that will show the printer dialog when its<code class="literal"> Print</code> method is called. Like the<code class="literal"> Preview</code> object, the<code class="literal"> Printer</code> object is created with some<code class="literal"> PrintData</code> and an instance of a<code class="literal"> Printout</code> object. When the print dialog's Print button is clicked, it will use the<code class="literal"> Printout</code> object to tell the physical printer what to draw on the paper.</p><p>The<code class="literal"> BitmapPrintout</code> class implements a<code class="literal"> Printout</code> object that is used for printing a single bitmap to a single sheet of paper at a time.<code class="literal"> Printout</code> objects must always be subclassed in order to implement the application-specific requirements of the data that needs to be printed as the base class only provides an interface of virtual methods to override in the subclass. In our class, we overrode the three following methods:<code class="literal"> GetPageInfo, HasPage</code>, and<code class="literal"> OnPrintPage</code>. The first two are for returning information about the number of pages that will be printed; since we are only supporting one page, these are quite trivial in this recipe. The<code class="literal"> OnPrintPage</code> method is what does the actual drawing to the printer's device context. This method gets called to do the drawing of each page that will be printed.<a id="id259" class="indexterm"/>
</p><p>Drawing the<code class="literal"> Printout</code> is done by using the device context object returned by the call to<code class="literal"> GetDC</code>. The use of device contexts are covered in detail in<a class="link" href="ch08.html" title="Chapter 8. Drawing to the Screen"> Chapter 8</a>,<em> Drawing to the Screen</em> so just too keep things simple all we did here was just to set the scale of the canvas calculations to try and center the image on the paper, and then used the DC's<code class="literal"> DrawBitmap</code> method to draw the<code class="literal"> Bitmap</code> to the device context. For an example of the<code class="literal"> BitmapPrinter</code> class in action, see the sample code that accompanies this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec15"/>There's more...</h2></div></div></div><p>Included below is some additional information about the print framework.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec05"/>Printout</h3></div></div></div><p>The<code class="literal"> wx.Printout</code> object has a number of other overrideable methods that may be of use for different types of documents. The following table is a reference to some of these other interface methods.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Interface methods</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OnBeginDocument(start, end)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called at the beginning of each copy of a document that is in the print job. If this method is overridden, the base class's method must still be called in it.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OnEndDocument()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called at the end of printing each copy of a document in the print job. If this method is overridden, the base class method must be called in it.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OnBeginPrinting()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called once and only once at the beginning of a print job.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OnEndPrinting()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called once and only once at the end of a print job.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OnPreparePrinting()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called before any other use of the<code class="literal"> Printout</code> object. This is usually where the calculations about things such as the number of pages in a document are done.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec06"/>Bug notice</h3></div></div></div><p>There is a bug in wxPython 2.8 where the page orientation (Portrait or Landscape) cannot be retrieved from the<code class="literal"> PageSetup</code> or<code class="literal"> Print</code> dialog's<code class="literal"> PrintData</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec16"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Understanding inheritance limitations</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> includes a detailed explanation of how to override virtual methods in wxPython classes.</li><li class="listitem" style="list-style-type: disc">The<em> Screen drawing</em> recipe in<a class="link" href="ch08.html" title="Chapter 8. Drawing to the Screen"> Chapter 8</a>,<em> Drawing to the Screen</em> discusses the use of Device Contexts (DCs) and their drawing commands.</li></ul></div></div></div></div>
</body></html>