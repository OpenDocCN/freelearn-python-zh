- en: Creating 3D Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建3D图形
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with 3D coordinates and vertices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始学习3D坐标和顶点
- en: Creating and importing 3D models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和导入3D模型
- en: Creating a 3D world to explore
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可探索的3D世界
- en: Building 3D maps and mazes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建三维地图和迷宫
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The chip at the heart of the original Raspberry Pi (a **Broadcom BCM2835** processor)
    was originally designed to be a **Graphical Processing Unit** (**GPU**) for mobile
    and embedded applications. The ARM core that drives most of Raspberry Pi's functionality
    was added because some extra space was available on the chip; this enabled this
    powerful GPU to be used as a **System-on-Chip** (**SoC**) solution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 原始树莓派（搭载一款**博通BCM2835处理器**）的核心芯片最初是为了作为移动和嵌入式应用的**图形处理单元**（**GPU**）而设计的。由于芯片上还有额外的空间，因此添加了驱动树莓派大部分功能的ARM核心；这使得这个强大的GPU能够作为**片上系统**（**SoC**）解决方案使用。
- en: An SoC is an integrated service microchip with all the necessary electronic
    circuits and parts of a computer or electronic system, it is used in smartphones
    or wearable computers, on a single **integrated circuit** (**IC**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个SoC是一个集成了所有必要的电子电路和计算机或电子系统部件的集成服务微芯片，它用于智能手机或可穿戴计算机，集成在一个**集成电路**（**IC**）上。
- en: As you can imagine, if that original ARM core (**ARM1176JZF-S**, which is the
    **ARMv6** architecture) consisted of only a small part of the chip on Raspberry
    Pi, you would be right in thinking that the GPU must perform rather well.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，如果那个原始的ARM核心（**ARM1176JZF-S**，它是**ARMv6**架构）仅占Raspberry Pi芯片的一小部分，那么您认为GPU必须表现相当出色是正确的。
- en: The processor at the heart of Raspberry Pi 3 has been upgraded (to a **Broadcom
    BCM2837** processor); it now contains four ARM cores (**Cortex A53 ARMv8A**),
    each of which are more powerful than the original **ARMv6**. Coupled with the
    same GPU from the previous generation, Raspberry Pi 3 is far better equipped to
    perform the calculations required to build 3D environments. However, although
    Raspberry Pi 3 will load the examples faster, once the 3D models are generated,
    both versions of the chip perform just as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 3的核心处理器已经升级（升级到了**Broadcom BCM2837**处理器）；它现在包含四个ARM核心（**Cortex
    A53 ARMv8A**），每个都比原始的**ARMv6**更强大。与上一代相同的GPU相结合，Raspberry Pi 3在执行构建3D环境所需的计算方面装备得更加完善。然而，尽管Raspberry
    Pi 3将更快地加载示例，但一旦生成3D模型，两种芯片版本的表现都相当出色。
- en: The **VideoCore IV GPU** consists of 48 purpose-built processors, with some
    providing support for 1080p high-definition encoding and decoding of video, while
    others support **OpenGL ES 2.0**, which provides fast calculations for 3D graphics.
    It has been said that its graphics processing power is equivalent to that of an
    Apple iPhone 4S and the original Microsoft Xbox. This is even more apparent if
    you run **Quake 3** or **OpenArena** on Raspberry Pi (go to [http://www.raspberrypi.org/openarena-for-raspberry-pi](http://www.raspberrypi.org/openarena-for-raspberry-pi)
    for details).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**VideoCore IV GPU**由48个专门设计的处理器组成，其中一些提供对1080p高清视频编码和解码的支持，而另一些则支持**OpenGL
    ES 2.0**，这为3D图形提供了快速的运算。据说其图形处理能力相当于苹果iPhone 4S和原始的微软Xbox。如果你在树莓派上运行**Quake 3**或**OpenArena**，这一点会更加明显（详情请访问[http://www.raspberrypi.org/openarena-for-raspberry-pi](http://www.raspberrypi.org/openarena-for-raspberry-pi)）。'
- en: In this chapter, I hope to show you that while you can achieve a lot by performing
    operations using the ARM side of Raspberry Pi, if you venture to the side where
    the GPU is hidden, you may see that there is even more to this little computer
    than what first appears.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我希望向大家展示，虽然你可以通过使用树莓派的ARM端执行操作来取得很多成就，但如果你冒险进入隐藏GPU的那一侧，你可能会发现这个小巧的电脑比最初看起来还有更多潜力。
- en: The `pi3d` library created by the `pi3d` team (Patrick Gaunt, Tom Swirly, Tim
    Skillman, and others) provides a way to put the GPU to work by creating 3D graphics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由`pi3d`团队（帕特里克·冈特、汤姆·斯威利、蒂姆·斯凯尔曼等人）创建的`pi3d`库提供了一种通过创建3D图形来利用GPU的方法。
- en: The `pi3d` Wiki and documentation pages can be found at the following link: [http://pi3d.github.io/html/index.html.](http://pi3d.github.io/html/index.html)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3d` 维基和文档页面可以在以下链接找到：[http://pi3d.github.io/html/index.html.](http://pi3d.github.io/html/index.html)'
- en: The support/development group can be found at the following link: [https://groups.google.com/forum/#!forum/pi3d.](https://groups.google.com/forum/#!forum/pi3d)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 支持和开发小组可以在以下链接找到：[https://groups.google.com/forum/#!forum/pi3d.](https://groups.google.com/forum/#!forum/pi3d)
- en: The library contains many features, so it will not be possible to cover everything
    that is available in the following examples. It is recommended that you also take
    some time to try out the `pi3d` demos. To discover more options for the creation
    and handling of the 3D graphics, you can have a look through some of the Python
    modules which make up the library itself (described in the documentation or the
    code on GitHub at [https://github.com/pi3d/pi3d.github.com](https://github.com/pi3d/pi3d.github.com)).
    It is hoped that this chapter will introduce you to enough concepts to illustrate
    some of the raw potential available to you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该库包含许多功能，因此在下述示例中不可能涵盖所有可用内容。建议您也花些时间尝试一下`pi3d`演示。要发现更多用于创建和处理3D图形的选项，您可以查看构成库本身的某些Python模块（在文档或GitHub上的代码中描述，网址为[https://github.com/pi3d/pi3d.github.com](https://github.com/pi3d/pi3d.github.com)）。希望这一章能向您介绍足够的概念，以展示您可利用的一些原始潜力。
- en: Getting started with 3D coordinates and vertices
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习3D坐标和顶点
- en: The world around us is three-dimensional, so in order to simulate parts of the
    world, we can create a 3D representation and display it on our 2D screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们周围的世界是三维的，因此为了模拟世界的一部分，我们可以创建一个3D表示并在我们的2D屏幕上显示它。
- en: Raspberry Pi enables us to simulate a 3D space, place 3D objects within it,
    and observe them from a selected viewpoint. We will use the GPU to produce a representation
    of the 3D view as a 2D image to display it on the screen.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派使我们能够模拟一个3D空间，在其中放置3D对象，并从选定的视角观察它们。我们将使用GPU将3D视图表示为2D图像，以便在屏幕上显示。
- en: 'The following example will show you how we can use `pi3d` (an OpenGL ES library
    for Raspberry Pi) to place a single 3D object and display it within the 3D space.
    We will then allow the mouse to rotate the view around the object:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将向您展示我们如何使用`pi3d`（一个适用于Raspberry Pi的OpenGL ES库）来放置一个单独的3D对象并在3D空间中显示它。然后我们将允许鼠标围绕对象旋转视图：
- en: '![](img/3088707e-2c3a-49c2-b58a-3081dccd415c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3088707e-2c3a-49c2-b58a-3081dccd415c.png)'
- en: Single 3D object
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单个3D对象
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: Raspberry Pi must be directly connected to a display, either via the HDMI or
    an analog video output. The 3D graphics rendered by the GPU will only be displayed
    on a local display, even if you are connecting to Raspberry Pi remotely over a
    network. You will also need to use a locally connected mouse for control (however,
    keyboard control does work via a SSH connection).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 必须直接连接到显示器，无论是通过 HDMI 还是模拟视频输出。GPU 渲染的 3D 图形将仅在本地显示器上显示，即使您通过网络远程连接到
    Raspberry Pi。您还需要使用本地连接的鼠标进行控制（然而，通过 SSH 连接键盘控制也是可行的）。
- en: 'The first time we use `pi3d`, we will need to download and install it via the
    following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用 `pi3d`，我们需要按照以下步骤下载和安装它：
- en: The `pi3d` library uses Pillow, a version of the Python Imaging Library that
    is compatible with Python 3, to import graphics used in models (such as textures
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pi3d` 库使用 Pillow，这是与 Python 3 兼容的 Python 图像库版本，用于导入模型中使用的图形（例如纹理）'
- en: and backgrounds).
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及背景)。
- en: The installation of Pillow has been covered in the *Getting ready* section of
    [Chapter 3](eb11b6c6-b334-42e0-941c-5d32db18cc9d.xhtml), *Using Python for Automation
    and Productivity*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow的安装已在[第3章](eb11b6c6-b334-42e0-941c-5d32db18cc9d.xhtml)的“准备就绪”部分中介绍，即*使用Python进行自动化和生产效率提升*。
- en: 'The commands for the installation are shown in the following code (if you''ve
    installed them before, it will skip them and continue):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安装命令显示在下面的代码中（如果您之前已经安装过，它将跳过它们并继续）：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now use `pip` to install `pi3d` using the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `pip` 通过以下命令安装 `pi3d`：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `pi3d` team is continuously developing and improving the library; if you
    are experiencing problems, it may mean that a new release is not compatible with
    the previous ones.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3d` 团队正在持续开发和改进这个库；如果你遇到问题，可能意味着新版本与之前的版本不兼容。'
- en: You can also check in the Appendix, *Hardware and Software List*, to confirm
    which version of `pi3d` you have and, if required, install the same version listed.
    Alternatively, contact the `pi3d` team via the Google group; they will be happy
    to help!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在附录中的“**硬件和软件列表**”中查看确认您所使用的`pi3d`版本，并在需要的情况下安装列表中列出的相同版本。或者，您可以通过Google群组联系`pi3d`团队；他们将乐意提供帮助！
- en: 'Obtain `pi3d` demos from the GitHub site, as shown in the following command
    lines. You will need around 90 MB of free space to download and extract the files:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub网站获取`pi3d`演示，如下命令行所示。您需要大约90 MB的空闲空间来下载和解压文件：
- en: '`  cd ~`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd ~`'
- en: '`  wget    https://github.com/pi3d/pi3d_demos/archive/master.zip`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`wget  https://github.com/pi3d/pi3d_demos/archive/master.zip`'
- en: '`  unzip master.zip`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`  unzip master.zip`'
- en: '`  rm master.zip`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`  rm master.zip`'
- en: You will find that the demos have been unpacked to `pi3d_demos-master`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现演示已经解压到 `pi3d_demos-master`。
- en: 'By default, the demos are expected to be located at `home/pi/pi3d`; therefore,
    we will rename this directory `pi3d`, as shown in the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，演示文件预期位于 `home/pi/pi3d`；因此，我们将重命名此目录为 `pi3d`，如下命令所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, check the Raspberry Pi memory split. Run `raspi-config` (`sudo raspi-config`)
    and ensure that your memory split is set to 128\. (You should only need to do
    this if you have changed it in the past, as 128 MB is the default.) This ensures
    that you have plenty of RAM allocated for the GPU, so it will be able to handle
    lots of 3D objects if required.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查 Raspberry Pi 的内存分割。运行 `raspi-config` (`sudo raspi-config`) 并确保您的内存分割设置为
    128 MB。（如果您之前更改过，则只需这样做，因为 128 MB 是默认值。）这确保您为 GPU 分配了足够的 RAM，以便在需要时能够处理大量的 3D
    对象。
- en: 'Test if everything is working properly. You should now be able to run any of
    the scripts in the `pi3d_demos-master` directory. See the `pi3d` Wiki pages for
    details on how they function ([http://pi3d.github.io/html/ReadMe.html](http://pi3d.github.io/html/ReadMe.html)).
    To get the best performance, it is recommended that the scripts are run from the
    command prompt (without loading the desktop):'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一切是否运行正常。你现在应该能够运行`pi3d_demos-master`目录中的任何脚本。有关它们如何工作的详细信息，请参阅`pi3d`维基页面([http://pi3d.github.io/html/ReadMe.html](http://pi3d.github.io/html/ReadMe.html))。为了获得最佳性能，建议从命令提示符（不加载桌面）运行脚本：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `pi3d.Keyboard` object also supports keyboard control via SSH (see the *Connecting
    remotely to Raspberry Pi over the network using SSH (and X11 forwarding)* section
    of [Chapter 1](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml), *Getting Started with
    a Raspberry Pi 3 Computer*).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3d.Keyboard` 对象也支持通过 SSH 进行键盘控制（参见[第1章](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml)，*使用
    Raspberry Pi 3 计算机入门*中的*通过 SSH 远程连接到 Raspberry Pi 并使用 X11 转发*部分）。'
- en: 'Configure the setup for your own scripts. Since we will use some of the textures
    and models from the demos, it is recommended that you create your scripts within
    the `pi3d` directory. If you have a username that''s different from the default
    Pi account, you will need to adjust `/pi3d/demo.py`. Replace the `USERNAME` part
    with your own username by editing the file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 配置您自己的脚本设置。由于我们将使用一些来自演示的纹理和模型，建议您在`pi3d`目录内创建您的脚本。如果您有一个与默认Pi账户不同的用户名，您将需要调整`/pi3d/demo.py`文件。通过编辑文件，将`USERNAME`部分替换为您自己的用户名：
- en: '`  nano ~/pi3d/demo.py`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`  nano ~/pi3d/demo.py`'
- en: '`  import sys`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`  import sys`'
- en: '`  sys.path.insert(1, ''/home/USERNAME/pi3d'')`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`  sys.path.insert(1, ''/home/USERNAME/pi3d'')`'
- en: If you want to relocate your files somewhere else, ensure that you add a copy
    of `demo.py` in the folder with the correct path to any resource files you require.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将文件移动到其他位置，请确保在包含所需资源文件正确路径的文件夹中添加`demo.py`的副本。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the following `3dObject.py` script:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下 `3dObject.py` 脚本：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To run the script, use `python3 3dObject.py`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，请使用 `python3 3dObject.py`。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We import the `math` modules (for angle calculations used to control the view
    based on mouse movements). We also import the demo module, which just provides
    the path to the **shaders** and **textures** in this example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`math`模块（用于计算角度，以便根据鼠标移动来控制视图）。我们还导入了demo模块，它仅提供此示例中**着色器**和**纹理**的路径。
- en: We start by defining some key elements that will be used by `pi3d` to generate
    and display our object. The space in which we shall place our object is the `pi3d.Display`
    object; this defines the size of the space and initializes the screen to generate
    and display OpenGL ES graphics.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一些关键元素，这些元素将由 `pi3d` 用于生成和显示我们的对象。我们将放置对象的空间是 `pi3d.Display` 对象；这定义了空间的大小，并初始化屏幕以生成和显示
    OpenGL ES 图形。
- en: Next, we define a `pi3d.Camera` object, which will allow us to define how we
    view the
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`pi3d.Camera`对象，这将允许我们定义如何查看
- en: object within our space. To render our object, we define a texture to be applied
    to the surface and a shader that will apply the texture to the object. The shader
    is used to apply all the effects and lighting to the object, and it is coded to
    use the GPU's OpenGL ES core instead of the ARM processor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的空间内的对象。为了渲染我们的对象，我们定义了一个要应用到表面的纹理和一个将纹理应用到对象上的着色器。着色器用于将所有效果和光照应用到对象上，并且它被编码为使用GPU的OpenGL
    ES核心而不是ARM处理器。
- en: 'We define the `keyboard` and `mouse` object using `pi3d.keyboard()` and `pi3d.mouse()`
    so that we can respond to the keyboard and mouse input. The `restrict` flag of
    the `mouse` object allows the absolute mouse position to continue past the screen
    limits (so we can continuously rotate our 3D object). The main loop, when running,
    will check if the *Esc* key is pressed and will then close everything down (including
    calling `DISPLAY.destroy()` to release the screen). We use the `try: finally:`
    method to ensure that the display is closed correctly, even if there is an exception
    within `main()`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用 `pi3d.keyboard()` 和 `pi3d.mouse()` 定义了 `keyboard` 和 `mouse` 对象，以便我们可以响应键盘和鼠标输入。`mouse`
    对象的 `restrict` 标志允许鼠标的绝对位置超出屏幕限制（这样我们就可以连续旋转我们的3D对象）。当主循环运行时，会检查是否按下了 *Esc* 键，然后关闭所有内容（包括调用
    `DISPLAY.destroy()` 释放屏幕）。我们使用 `try: finally:` 方法来确保正确关闭显示，即使在 `main()` 中发生异常也是如此。'
- en: The mouse movement is collected in the main display loop using `mymouse.position()`,
    which returns the *x* and *y* coordinates. The difference in the *x* and *y* movement
    is used to rotate around the object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标移动是通过`mymouse.position()`在主显示循环中收集的，该函数返回*x*和*y*坐标。*x*和*y*移动的差值用于围绕对象旋转。
- en: The mouse movements determine the position and angle of the camera. Any adjustment
    to the forward/backward position of the mouse is used to move it over or under
    the object and change the angle of the camera (using `tilt`) so it remains pointing
    at the object. Similarly, any sideways movement will move the camera around the
    object using the `CAMERA.reset()` function. This ensures that the display updates
    the camera view with the new position, `CAMERA.rotate()`, to change the angle,
    and uses `CAMERA.position()` to move the camera to a position around the object,
    `camRad` units away from its center.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标移动决定了摄像机的位置和角度。对鼠标前后位置的任何调整都用于将其移动到物体上方或下方，并改变摄像机的角度（使用`倾斜`），使其始终指向物体。同样，任何侧向移动都将使用`CAMERA.reset()`函数使摄像机围绕物体移动。这确保了显示更新摄像机视图以显示新位置，`CAMERA.rotate()`用于改变角度，并使用`CAMERA.position()`将摄像机移动到距离物体中心`camRad`单位的某个位置。
- en: 'We will draw a three-dimensional object called a **tetrahedron**, a shape made
    up of four triangles to form a pyramid with a triangular base. The four corners
    of the shape (three around the base and one at the top) will be defined by the
    three-dimensional coordinates **A**, **B**, **C**, and **D**, as shown in the
    following diagram:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个称为**四面体**的三维物体，它是由四个三角形组成的形状，形成一个底面为三角形的金字塔。该形状的四个角（三个在底部周围，一个在顶部）将由三维坐标**A**、**B**、**C**和**D**定义，如下所示图所示：
- en: '![](img/5d899fc4-3493-449d-af5a-d1f8bd962c48.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d899fc4-3493-449d-af5a-d1f8bd962c48.png)'
- en: The tetrahedron placed within the 3D coordinates
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将四面体放置在三维坐标系中
- en: The `pi3d.Tetrahedron` object is defined by specifying *x*, *y,* and *z* coordinates
    of four points to position it in the space and then specify the corners that will
    be joined to form the four triangles that make up the shape.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3d.Tetrahedron` 对象通过指定四个点的 *x*、*y* 和 *z* 坐标来定位其在空间中的位置，然后指定将连接形成构成该形状的四个三角形的角。'
- en: Using `set_draw_details(flatsh,[text])`, we apply the shader(s) we wish to use
    and the texture(s) for the object. In our example, we are just using a single
    texture, but some shaders can use several textures for complex effects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `set_draw_details(flatsh,[text])`，我们应用我们希望使用的着色器（们）和对象的纹理（们）。在我们的例子中，我们只使用了一个纹理，但某些着色器可以使用多个纹理以产生复杂效果。
- en: To help highlight where the coordinates are, we will add some `pi3d.String`
    objects by setting the string text to specify the ID and coordinates next to them
    and placing it at the required location. We will create two string objects for
    each location, one facing forward and another facing backward (`ry=180` rotates
    the object by 180 degrees on the *y* axis). The `pi3d.String` objects are single-sided,
    so if we only had one side facing forward, it wouldn't be visible from behind
    when the view was rotated and would just disappear (plus, if it was visible, the
    text would be backwards anyway). Again, we use the `flatsh` shader to render it
    using the `set_shader()` string object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助突出坐标的位置，我们将通过设置字符串文本来指定ID和坐标，并在它们旁边放置一些`pi3d.String`对象，将其放置在所需的位置。对于每个位置，我们将创建两个字符串对象，一个朝前，另一个朝后（`ry=180`在*Y*轴上旋转对象180度）。`pi3d.String`对象是单面的，所以如果我们只有一面朝前，当视图旋转时，从后面看就不会可见，而且会直接消失（此外，如果可见，文本也会是反的）。再次强调，我们使用`flatsh`着色器通过`set_shader()`字符串对象来渲染它。
- en: All that is left to do now is to draw our tetrahedron and the string objects
    while checking for any keyboard events. Each time the `while` loop completes,
    `DISPLAY.loop_running()` is called, which will update the display with any adjustments
    to the camera as required.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的工作就是绘制我们的四面体和绳子对象，同时检查任何键盘事件。每次`while`循环完成时，都会调用`DISPLAY.loop_running()`，这将根据需要更新显示，调整相机设置。
- en: There's more...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In addition to introducing how to draw a basic object within the 3D space, the
    preceding example makes use of the following four key elements used in 3D graphics
    programming.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了介绍如何在三维空间中绘制基本对象之外，前面的示例还使用了以下在三维图形编程中使用的四个关键元素。
- en: Camera
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相机
- en: 'The camera represents our view in the 3D space; one way to explore and see
    more of the space is by moving the camera. The `Camera` class is defined as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 照相机代表我们在三维空间中的视角；探索和查看更多空间的一种方法是通过移动照相机。`Camera`类定义如下：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The camera is defined by providing two locations, one to look at (usually the
    object we wish to see, defined by `at`) and another to look from (the object's
    position, defined by `eye`). Other features of the camera, such as its field of
    view (`lens`) and so on, can be adjusted or used with the default settings.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机通过提供两个位置来定义，一个是要看的对象（通常是我们希望看到的对象，由`at`定义），另一个是观察的位置（对象的方位，由`eye`定义）。摄像机的其他特性，如其视野（`lens`）等，可以通过默认设置进行调整或使用。
- en: If we didn't define a camera in our display, a default one will be created that
    points at the origin (the center of the display, that is, `0,0,0`), positioned
    slightly in front of it (`0,0,-0.1`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在我们的显示中定义相机，系统将创建一个默认相机，该相机指向原点（即显示的中心，也就是`0,0,0`），并稍微位于其前方（`0,0,-0.1`）。
- en: See the `pi3d` documentation regarding the camera module for more details.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 查看有关相机模块的`pi3d`文档以获取更多详细信息。
- en: Shaders
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器
- en: 'Shaders are very useful as they allow a lot of the complex work required to
    apply textures and lighting to an object by offloading the task to the more powerful
    GPU in Raspberry Pi. The `Shader` class is defined as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器非常有用，因为它们允许将将纹理和光照应用到物体上的复杂工作卸载到更强大的Raspberry Pi GPU上。`Shader`类定义如下：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This allows you to specify a shader file (`shfile`) and specific vertex and
    fragment shaders (if required) within the file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在文件中指定一个着色器文件（`shfile`）以及所需的特定顶点和片段着色器（如果需要的话）。
- en: There are several shaders included in the `pi3d` library, some of which allow
    multiple textures to be used for reflections, close-up details, and transparency
    effects. The implementation of the shader will determine how the lights and textures
    are applied to the object (and in some cases, such as `uv_flat`, the shader will
    ignore any lighting effects).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3d` 库中包含几个着色器，其中一些允许使用多个纹理来实现反射、近距离细节和透明效果。着色器的实现方式将决定光线和纹理如何应用于对象（在某些情况下，例如
    `uv_flat`，着色器将忽略任何光照效果）。'
- en: The shader files are listed in the `pi3dshaders` directory. Try experimenting
    with different shaders, such as `mat_reflect`, which will ignore the textures/fonts
    but still apply the lighting effects, or `uv_toon`, which will apply a cartoon
    effect to the texture.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器文件列在 `pi3dshaders` 目录中。尝试使用不同的着色器进行实验，例如 `mat_reflect`，它将忽略纹理/字体但仍然应用光照效果，或者
    `uv_toon`，它将对纹理应用卡通效果。
- en: Each shader consists of two files, `vs` (vertex shader) and `fs` (fragment shader),
    written in C-like code. They work together to apply the effects to the object
    as desired. The vertex shader is responsible for mapping the 3D location of the
    vertices to the 2D display. The fragment shader (sometimes called the pixel shader)
    is responsible for applying lighting and texture effects to the pixels themselves.
    The construction and operation of these shaders is well beyond the scope of this
    chapter, but there are several example shaders that you can compare, change, and
    experiment with within the `pi3dshaders` directory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个着色器由两个文件组成，`vs`（顶点着色器）和`fs`（片段着色器），使用类似C语言的代码编写。它们协同工作以将所需的效果应用到对象上。顶点着色器负责将顶点的3D位置映射到2D显示。片段着色器（有时也称为像素着色器）负责将光照和纹理效果应用到像素本身。这些着色器的构建和操作超出了本章的范围，但在`pi3dshaders`目录中，你可以比较、更改和实验几个示例着色器。
- en: Lights
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灯光
- en: Lighting is very important in a 3D world; it could range from simple general
    lighting (as used in our example) to multiple lights angled from different directions
    providing different strengths and colors. How lights interact with objects and
    the effects they produce will be determined by the textures and shaders used to
    render them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D世界中，光照非常重要；它可以从简单的泛光照明（如我们示例中使用的）到从不同方向提供不同强度和颜色的多个光源。光照与物体相互作用以及它们产生的效果将由用于渲染它们的纹理和着色器决定。
- en: 'Lights are defined by their direction, their color and brightness, and also
    by an ambient light to define the background (non-directional) light. The `Light`
    class is defined as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光通过其方向、颜色和亮度来定义，同时通过环境光来定义背景（非方向性）光。`Light` 类的定义如下：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By default, the display will define a light that has the following properties:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，显示将定义具有以下属性的光：
- en: '`lightpos=(10, -10, 20)`: This is a light that shines from the front of the
    space (near the top-left side) down towards the back of the space (towards the
    right)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightpos=(10, -10, 20)`: 这是一个从空间前方（靠近左上角）向下照射到空间后方的灯光（向右方）'
- en: '`lightcol=(1.0, 1.0, 1.0)`: This is a bright, white, directional light (the
    direction is defined in the preceding dimension, and it is the color defined by
    the RGB values `1.0, 1.0, 1.0`)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightcol=(1.0, 1.0, 1.0)`: 这是一个明亮、白色的方向性光源（方向由前一个维度定义，颜色由RGB值`1.0, 1.0, 1.0`定义）'
- en: '`ightamb=(0.1, 0.1, 0.2)`: This is overall a dull, slightly bluish light'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ightamb=(0.1, 0.1, 0.2)`: 这是一个整体略显暗淡、略带蓝色的光'
- en: Textures
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理
- en: Textures are able to add realism to an object by allowing fine detail to be
    applied to the object's surface; this could be an image of bricks for a wall or
    a person's face displayed on the character. When a texture is used by the shader,
    it can often be rescaled and reflection can be added to it; some shaders even
    allow you to apply surface detail.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理能够通过将精细细节应用于物体的表面来为物体增添真实感；这可能是用于墙面的砖块图像或显示在角色上的人脸。当着色器使用纹理时，它通常可以被重新缩放，并且可以添加反射效果；一些着色器甚至允许你应用表面细节。
- en: We can apply multiple textures to an object to combine them and produce different
    effects; it will be up to the shader to determine how they are applied.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多种纹理应用于一个物体，将它们组合起来产生不同的效果；具体如何应用将由着色器来决定。
- en: Creating and importing 3D models
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和导入3D模型
- en: Creating complex shapes directly from code can often be cumbersome and time-consuming.
    Fortunately, it is possible to import prebuilt models into your 3D space.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从代码创建复杂形状通常会很繁琐且耗时。幸运的是，您可以将预构建的模型导入到您的3D空间中。
- en: It is even possible to use graphical 3D modeling programs to generate models
    and then export them as a suitable format for you to use. This example produces
    a Newell Teapot
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以使用图形3D建模程序来生成模型，然后将其导出为适合您使用的格式。此示例生成一个纽威尔茶壶模型
- en: 'in the Raspberry Pi theme, as shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派主题中，如下截图所示：
- en: '![](img/10aa71ca-a743-4972-a7f3-0a32fdbd9dcd.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10aa71ca-a743-4972-a7f3-0a32fdbd9dcd.png)'
- en: Newell Raspberry Pi teapot
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 新ell树莓派茶壶
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We shall use 3D models of a teapot (both `teapot.obj` and `teapot.mdl`) located
    in
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '`pi3dmodels`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3dmodels`.'
- en: Modeling a teapot is the traditional 3D equivalent of displaying *Hello World*.
    Computer graphics researcher Martin Newell first created the Newell Teapot in
    1975 as a basic test model for his work. The Newell Teapot soon became the standard
    model to quickly check if a 3D rendering system was working correctly (it even
    appeared in *Toy Story* and a 3D episode of *The Simpsons*).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 建模茶壶是显示*Hello World*的3D传统等效。计算机图形学研究员马丁·纽厄尔（Martin Newell）于1975年首次创建了纽厄尔茶壶（Newell
    Teapot），作为他工作的基本测试模型。纽厄尔茶壶很快成为了快速检查3D渲染系统是否正常工作的标准模型（它甚至出现在了*玩具总动员*和*辛普森一家*的3D集中）。
- en: Other models are available in the `pi3dmodels` directory (`monkey.obj/mdl`,
    which has been used later on, is available in the book's resource files).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模型可在`pi3dmodels`目录中找到（`monkey.obj/mdl`，后来在书中资源文件中使用过）。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create and run the following `3dModel.py` script:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并运行以下`3dModel.py`脚本：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Like the `3dObject.py` example, we define the `DISPLAY` shader (this time using
    `uv_reflect`) and some additional textures—`bumptex` (`floor_nm.jpg`) and `shinetex`
    (`stars.jpg`)—to use later. We define a model that we want to import, placing
    it at `z=10` (if no coordinates are given, it will be placed at `(0,0,0)`). Since
    we do not specify a camera position, the default will place it within the view
    (see the section regarding the camera for more details).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `3dObject.py` 示例，我们定义了 `DISPLAY` 着色器（这次使用 `uv_reflect`）和一些额外的纹理——`bumptex`
    (`floor_nm.jpg`) 和 `shinetex` (`stars.jpg`)——以便稍后使用。我们定义了一个想要导入的模型，将其放置在 `z=10`（如果没有给出坐标，它将被放置在
    `(0,0,0)`）。由于我们没有指定相机位置，默认情况下它将被放置在视图中（有关相机的详细信息，请参阅相关章节）。
- en: We apply the shader using the `set_shader()` function. Next, we add some textures
    and effects using `bumptex` as a surface texture (scaled by `4`). We apply an
    extra shiny effect using `shinetex` and apply a reflection strength of `0.5` (the
    strength ranges from 0.0, the weakest, to 1.0, the strongest) using the `set_normal_shine()`
    function. If you look closely at the surface of the model, the `bumptex` texture
    provides additional surface detail and the `shinetex` texture can be seen as the
    reflection on the surface.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `set_shader()` 函数应用着色器。接下来，我们使用 `bumptex` 作为表面纹理（按 `4` 缩放）添加一些纹理和效果。我们通过
    `set_normal_shine()` 函数应用额外的闪亮效果，并设置反射强度为 `0.5`（强度范围从 0.0，最弱，到 1.0，最强）。如果你仔细观察模型的表面，`bumptex`
    纹理提供了额外的表面细节，而 `shinetex` 纹理则可以看作是表面上的反射。
- en: To display our model within something more interesting than a default blue space,
    we will create an `EnvironmentCube` object. This defines a large space that has
    a special texture applied to the inside space (in this instance, it will load
    the `sbox_front/back/bottom/left` and `sbox_right` images from the `texturesecubes`
    directory), so it effectively encloses the objects within. The result is that
    you get a pleasant backdrop for your object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在比默认蓝色空间更有趣的环境中展示我们的模型，我们将创建一个`EnvironmentCube`对象。这定义了一个内部空间应用了特殊纹理的大空间（在这个例子中，它将从`texturesecubes`目录中加载`sbox_front/back/bottom/left`和`sbox_right`图像），因此它有效地包围了其中的对象。结果是，你得到了一个令人愉悦的背景来展示你的对象。
- en: Again, we define a default `CAMERA` object with `rot` and `tilt` variables to
    control the view. Within the `DISPLAY.loop_running()` section, we can control
    the view of the
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们定义了一个默认的 `CAMERA` 对象，并带有 `rot` 和 `tilt` 变量来控制视图。在 `DISPLAY.loop_running()`
    部分中，我们可以控制视图。
- en: '`CAMERA` object using the mouse and rotate the model on its axis at different
    rates to let it'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标操作`CAMERA`对象，并绕其轴以不同速度旋转模型，以便
- en: spin and show all its sides (using the `RotateIncX/Y/Z()` function to specify
    the rate of rotation). Finally, we ensure that the `DISPLAY` is updated by drawing
    the model and the environment cube.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转并展示其所有侧面（使用`RotateIncX/Y/Z()`函数来指定旋转速度）。最后，我们通过绘制模型和环境立方体来确保`DISPLAY`被更新。
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can create a wide range of objects to place within our simulated environment.
    `pi3d` provides methods to import our own models and apply multiple textures to
    them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在模拟环境中创建各种对象进行放置。`pi3d` 提供了导入我们自己的模型并将多种纹理应用于它们的方法。
- en: Creating or loading your own objects
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建或加载您自己的对象
- en: If you wish to use your own models in this example, you shall need to create
    one in the correct format; `pi3d` supports **obj** (wavefront object files) and
    **egg** (Panda3D).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在这个示例中使用自己的模型，你需要创建一个正确格式的模型；`pi3d`支持**obj**（波前对象文件）和**egg**（Panda3D）。
- en: An excellent, free, 3D modeling program is called **Blender** (available at
    [http://www.blender.org](http://www.blender.org)). There are lots of examples
    and tutorials on their website to get you started with basic modeling ([http://www.blender.org/education-help/tutorials](http://www.blender.org/education-help/tutorials)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一款优秀且免费的3D建模程序叫做**Blender**（可在[http://www.blender.org](http://www.blender.org)获取）。他们的网站上有很多示例和教程，可以帮助你开始学习基本的建模（[http://www.blender.org/education-help/tutorials](http://www.blender.org/education-help/tutorials)）。
- en: The `pi3d` model support is limited and will not support all the features that
    Blender can embed in an exported model, for example, deformable meshes. Therefore,
    only basic multipart models are supported. There are a few steps required to simplify
    the model so it can be loaded by `pi3d`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3d`模型支持有限，不会支持Blender可以嵌入导出模型中的所有功能，例如可变形网格。因此，只支持基本的多部件模型。需要几个步骤来简化模型，以便它可以由`pi3d`加载。'
- en: 'To convert an `.obj` model to use it with `pi3d`, proceed with the following
    steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `.obj` 模型转换为与 `pi3d` 一起使用，请按照以下步骤操作：
- en: Create or load a model in Blender—try starting with a simple object before attempting
    more complex models.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Blender中创建或加载一个模型——在尝试更复杂的模型之前，先从简单的对象开始。
- en: Select each Object and switch to Edit mode (press *Tab*).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每个对象并切换到编辑模式（按*Tab*键）。
- en: Select all vertices (press *A*) and uv-map them (press *U* and then select Unwrap).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有顶点（按 *A* 键）并对其进行 uv 映射（按 *U* 键然后选择 Unwrap）。
- en: Return to Object mode (press *Tab*).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回对象模式（按*Tab*键）。
- en: Export it as obj – from the File menu at the top, select Export, and then select Wavefront
    (.obj). Ensure that Include Normals is also checked in the list of options in
    the bottom-left list.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出为obj文件 – 从顶部菜单的文件菜单中选择导出，然后选择Wavefront (.obj)。确保在左下角的选项列表中也勾选了Include Normals。
- en: 'Click on Save and place the `.obj` and `.mtl` files in the `pi3dmodels` directory,
    and ensure that you update the script with the model''s filename, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击保存，并将`.obj`和`.mtl`文件放置在`pi3dmodels`目录中，同时确保您更新脚本以包含模型的文件名，如下所示：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run your updated script, you will see your model displayed in the
    3D space. For example, the `monkey.obj` model is shown in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行更新后的脚本时，你将在3D空间中看到你的模型。例如，`monkey.obj`模型在下面的屏幕截图中显示：
- en: '![](img/a9ce19a7-cf62-4b7d-b35d-b23f73fc4d13.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9ce19a7-cf62-4b7d-b35d-b23f73fc4d13.png)'
- en: A monkey head model created in Blender and displayed by pi3d
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Blender创建并由pi3d展示的猴子头模型
- en: Changing the object's textures and .mtl files
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改对象的纹理和 .mtl 文件
- en: The texture that is applied to the surface of the model is contained within
    the `.mtl` file of the model. This file defines the textures and how they are
    applied as set by the modeling software. Complex models may contain multiple textures
    for various parts of the object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 模型表面所应用的纹理包含在模型的 `.mtl` 文件中。此文件定义了纹理及其应用方式，这些方式由建模软件设定。复杂的模型可能包含多个纹理，用于对象的各个部分。
- en: 'If no material is defined, the first texture in the shader is used (in our
    example, this is the `bumptex` texture). To add a new texture to the object, add
    (or edit) the following line in the `.mtl` file (that is, to use `water.jpg`):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '如果没有定义材质，则使用着色器中的第一个纹理（在我们的例子中，这是`bumptex`纹理）。要向对象添加新的纹理，请在`.mtl`文件中添加（或编辑）以下行（即使用`water.jpg`）:'
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: More information about `.mtl` files and `.obj` files can be found at the following
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`.mtl`文件和`.obj`文件的更多信息可以在以下链接找到
- en: Wikipedia link: [https://en.wikipedia.org/wiki/Wavefront_.obj_file.](https://en.wikipedia.org/wiki/Wavefront_.obj_file)[ ](https://en.wikipedia.org/wiki/Wavefront_.obj_file)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科链接：[https://zh.wikipedia.org/wiki/Wavefront_.obj文件](https://zh.wikipedia.org/wiki/Wavefront_.obj_file)[ ](https://zh.wikipedia.org/wiki/Wavefront_.obj_file)
- en: Taking screenshots
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获屏幕截图
- en: 'The `pi3d` library includes a useful screenshot function to capture the screen
    in a `.jpg` or `.png` file. We can add a new key event to trigger it and call
    `pi3d.screenshot("filename.jpg")` to save an image (or use a counter to take multiple
    screenshots), as shown in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3d` 库包含一个有用的截图功能，可以捕获屏幕并将其保存为 `.jpg` 或 `.png` 文件。我们可以添加一个新的按键事件来触发它，并调用
    `pi3d.screenshot("filename.jpg")` 来保存图片（或使用计数器来拍摄多张截图），如下面的代码所示：'
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating a 3D world to explore
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可探索的3D世界
- en: Now that we are able to create models and objects within our 3D space, as well
    as
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够在我们的3D空间内创建模型和对象，以及
- en: generate backgrounds, we may want to create a more interesting environment within
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 生成背景时，我们可能想要在内部创建一个更有趣的环境
- en: which to place them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 哪里放置它们。
- en: '3D terrain maps provide an elegant way to define very complex landscapes. The
    terrain is defined using a grayscale image to set the elevation of the land. The
    following example shows how we can define our own landscape and simulate flying
    over it, or even walk on its surface:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 地形图提供了一种优雅的方式来定义非常复杂的地形。地形是通过使用灰度图像来设定土地的高程来定义的。以下示例展示了我们如何定义自己的景观并模拟在其上飞越，甚至在其表面行走：
- en: '![](img/e134ca0e-20c3-47c1-a71e-b9002102403f.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e134ca0e-20c3-47c1-a71e-b9002102403f.png)'
- en: A 3D landscape generated from a terrain map
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由地形图生成的3D景观
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will need to place the `Map.png` file (available in the book resource files)
    in the `pi3d/textures` directory of the `pi3d` library. Alternatively, you can
    use one of the elevation maps already present—replace the reference to `Map.png`
    with another one of the elevation maps, such as `testislands.jpg`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将 `Map.png` 文件（可在书籍资源文件中找到）放置在 `pi3d` 库的 `pi3d/textures` 目录下。或者，您可以使用已经存在的其中一个高程图——将
    `Map.png` 的引用替换为另一个高程图，例如 `testislands.jpg`。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the following `3dWorld.py` script:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下 `3dWorld.py` 脚本：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we have defined the display, camera, textures, and shaders that we are
    going to use, we can define the `ElevationMap` object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了将要使用的显示、相机、纹理和着色器，我们就可以定义`ElevationMap`对象。
- en: 'It works by assigning a height to the terrain image based on the pixel value
    of the selected points of the image. For example, a single line of an image will
    provide a slice of the `ElevationMap` object and a row of elevation points on
    the 3D surface:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过根据图像所选点的像素值为地形图像分配高度来工作。例如，图像的单行将提供`ElevationMap`对象的切片和3D表面上的一个高程点行：
- en: '![](img/6621618c-a3c5-4eb0-ba4e-af33aaf25ad1.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6621618c-a3c5-4eb0-ba4e-af33aaf25ad1.png)'
- en: Mapping the map.png pixel shade to the terrain height
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将地图.png像素色调映射到地形高度
- en: 'We create an `ElevationMap` object by providing the filename of the image we
    will use for the gradient information (`textures/Map.png`), and we also create
    the dimensions of the map (`width`, `depth`, and `height`—which is how high the
    white spaces will be compared to the black spaces):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过提供用于梯度信息的图像文件名（`textures/Map.png`）来创建一个`ElevationMap`对象，同时我们也创建了地图的尺寸（`width`、`depth`和`height`——这是白色空间与黑色空间相比的高度）：
- en: '![](img/acf91238-7e92-4cb2-943a-aca1ef10a20e.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acf91238-7e92-4cb2-943a-aca1ef10a20e.png)'
- en: ElevationMap object
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 高程图对象
- en: The `Map.png` texture provides an example terrain map, which is converted into
    a
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map.png`纹理提供了一个示例地形图，该图被转换成'
- en: three-dimensional surface.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 三维曲面。
- en: We also specify `divx` and `divy`, which determine how much detail of the terrain
    map is used (how many points from the terrain map are used to create the elevation
    surface). Finally, `ntiles` specifies that the texture used will be scaled to
    fit `20 times` across the surface.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了 `divx` 和 `divy`，它们决定了地形图细节的使用程度（使用地形图中的多少点来创建高程表面）。最后，`ntiles` 指定使用的纹理将被缩放到覆盖表面的
    `20 倍`。
- en: Within the main `DISPLAY.loop_running()` section, we will control the camera,
    draw `ElevationMap`, respond to inputs, and limit movements in our space.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`DISPLAY.loop_running()`部分，我们将控制相机，绘制`高程图`，响应用户输入，并限制我们在空间中的移动。
- en: As before, we use a `Keyboard` object to capture mouse movements and translate
    them to control the camera. We will also use `mykeys.read()` to determine if *W*,
    *S*, *R*, and *T* have been pressed, which allow us to move forward and backwards,
    as well as rise up and down.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用一个`Keyboard`对象来捕捉鼠标移动并将它们转换为控制相机。我们还将使用`mykeys.read()`来确定是否按下了*W*、*S*、*R*和*T*键，这允许我们前进和后退，以及上升和下降。
- en: 'To allow easy conversion between the values returned from the   and their equivalent
    meaning, we will use a Python dictionary:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便在返回值和它们等效意义之间进行转换，我们将使用一个Python字典：
- en: '`  KEY = {''R'':114,''S'':115,''T'':116,''W'':119,''ESC'':27,''NONE'':-1}`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary provides an easy way to translate between a given value and the
    resulting string. To access a key's value, we use `KEY['W']`. We also used a dictionary
    in [Chapter 3](eb11b6c6-b334-42e0-941c-5d32db18cc9d.xhtml), *Using Python for
    Automation and Productivity*, to translate between the image EXIF tag names and
    IDs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 词典提供了一种简单的方法在给定的值和结果字符串之间进行转换。要访问键的值，我们使用 `KEY['W']`。我们还在[第3章](eb11b6c6-b334-42e0-941c-5d32db18cc9d.xhtml)，《使用Python进行自动化和生产效率》，中使用了一个字典来在图像EXIF标签名称和ID之间进行转换。
- en: To ensure that we do not fall through the surface of the `ElevationMap` object
    when
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们不会穿过`ElevationMap`对象表面
- en: we move over it, we can use `mymap.calcHeight()` to provide us with the height
    of
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移动到它上面，可以使用 `mymap.calcHeight()` 来提供其高度
- en: the terrain at a specific location (`x,y,z`). We can either follow the ground
    by ensuring the camera is set to equal this, or fly through the air by just ensuring
    that we never go below it. When we detect that we are on the ground, we ensure
    that we remain on the ground until
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定位置（`x,y,z`）的地形。我们可以通过确保相机设置为等于这个值来跟随地面，或者通过确保我们从未低于它来飞行于空中。当我们检测到我们在地面上时，我们确保我们保持在地面直到
- en: we press *R* to rise again.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按*R*键再次升起。
- en: Building 3D maps and mazes
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建三维地图和迷宫
- en: We've seen that the `pi3d` library can be used to create lots of interesting
    objects and environments. Using some of the more complex classes (or by constructing
    our own), whole custom spaces can be designed for the user to explore.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，`pi3d`库可以用来创建许多有趣的对象和环境。通过使用一些更复杂的类（或者通过构建我们自己的类），可以为用户设计出整个定制的空间供其探索。
- en: 'In the following example, we use a special module called **Building**, which
    has been designed to allow you to construct a whole building using a single image
    file to provide the layout:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用一个名为**Building**的特殊模块，该模块已被设计为允许您使用单个图像文件来提供布局，从而构建整个建筑：
- en: '![](img/3928fd78-57bb-4112-a73b-c18c94c9d64b.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3928fd78-57bb-4112-a73b-c18c94c9d64b.png)'
- en: Exploring the maze and finding the sphere that marks the exit
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 探索迷宫并找到标记出口的球体
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You will need to ensure that you have the following files in the `pi3d/textures`
    directory:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保在`pi3d/textures`目录中拥有以下文件：
- en: '`squareblocksred.png`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`squareblocksred.png`'
- en: '`floor.png`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floor.png`'
- en: '`inside_map0.png`, `inside_map1.png`, `inside_map2.png`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inside_map0.png`, `inside_map1.png`, `inside_map2.png`'
- en: These files are available as part of the book's resources placed in `Chapter07resourcesource_filestextures`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件作为书籍资源的一部分提供，位于`Chapter07resourcesource_filestextures`。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s run the following `3dMaze.py` script by performing the following steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤运行以下`3dMaze.py`脚本：
- en: 'First, we set up the keyboard, mouse, display, and settings for the model using
    the following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用以下代码设置模型的键盘、鼠标、显示器和设置：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then create functions to allow us to reload the levels and display messages
    to the player using the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后创建函数以便我们使用以下代码重新加载关卡并向玩家显示消息：
- en: '[PRE14]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Within the main function, we set up the 3D environment and draw all of the
    objects using the following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们使用以下代码设置3D环境和绘制所有对象：
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we monitor for key presses, handle any collisions with objects, and
    move within the maze as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们监控按键，处理与物体的任何碰撞，并在迷宫中按照以下方式移动：
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We define many of the elements we used in the preceding examples, such as the
    display, textures, shaders, font, and lighting. We also define the objects, such
    as the building itself, the `ElevationMap` object, as well as the start and end
    points of the maze. We also use SolidObjects to help detect movement within the
    space. See the *Using* *SolidObjects* *to detect collisions* subsection in the
    *There's more...* section of this recipe for more information.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了在前面示例中使用到的许多元素，例如显示、纹理、着色器、字体和光照。我们还定义了对象，如建筑本身、`ElevationMap` 对象，以及迷宫的起点和终点。此外，我们还使用
    SolidObjects 来帮助检测空间内的移动。有关更多信息，请参阅此食谱中 *There's more...* 部分的 *Using *SolidObjects*
    *to detect collisions* 子部分。
- en: Finally, we create the actual `Building` object based on the selected map image
    (using the `loadLevel()` function) and locate the camera (which represents our
    first person viewpoint) at the start. See the *The Building module* subsection
    in the *There's more...* section of this recipe for more information.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据选定的地图图像创建实际的 `Building` 对象（使用 `loadLevel()` 函数），并将摄像机（代表我们的第一人称视角）定位在起始位置。有关更多信息，请参阅此食谱中
    *There's more...* 部分的 *The Building module* 子节。
- en: Within the `main` loop, we draw all the objects in our space and apply the lighting
    effects. We will also monitor for movement in the mouse (to control the tilt and
    rotation of the camera) or the keyboard to move the player (or exit/provide help).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`循环中，我们绘制我们空间中的所有对象并应用光照效果。我们还将监控鼠标（以控制相机的倾斜和旋转）或键盘的移动来移动玩家（或退出/提供帮助）。
- en: 'The controls are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 控制方式如下：
- en: '**Mouse movement**: This changes the camera tilt and rotation.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鼠标移动**：这会改变相机的倾斜和旋转。'
- en: '**'' or / key**: This changes the camera to tilt either downwards or upwards.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**'' 或 / 键**：这会将相机倾斜向上或向下。'
- en: '**A or D**: This changes the camera to rotate from left to right or vice versa.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A或D**：这会将相机旋转从左到右或反之。'
- en: '**W or S**: This moves the player forwards or backwards.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**W 或 S**: 这将使玩家向前或向后移动。'
- en: '**H**: This helps the player by rotating them to face the end of the maze.
    The useful `CAMERA.point_at()` function is used to quickly rotate and tilt the
    camera''s viewpoint towards the provided coordinates (the end position).'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**H**: 这通过旋转玩家使其面对迷宫的终点来帮助玩家。有用的 `CAMERA.point_at()` 函数用于快速旋转和倾斜摄像机的视角，使其指向提供的坐标（终点位置）。'
- en: Whenever the player moves, we check if the new position (`NewPos`) collides
    with another `SolidObject` using `CollisionList(NewPos)`. The function will return
    a list of any other SolidObjects that overlap the coordinates provided.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家移动时，我们检查新位置(`NewPos`)是否与另一个`SolidObject`发生碰撞，使用`CollisionList(NewPos)`。该函数将返回与提供的坐标重叠的任何其他`SolidObject`的列表。
- en: If there are no SolidObjects in the way, we make the player move; otherwise,
    we check to see if one of the SolidObject's names is the `end` object, in which
    case we have reached the end of the maze.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有障碍物挡道，我们就让玩家移动；否则，我们检查是否有SolidObject的名称是`end`对象，在这种情况下，我们就到达了迷宫的尽头。
- en: When the player reaches the end, we remove the walls from the old `Building`
    object and display a loading message. If we don't remove the walls, all of the
    SolidObjects belonging to the previous `Building` will still remain, creating
    invisible obstacles in the next level.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家到达终点时，我们从旧的`Building`对象中移除墙壁并显示加载信息。如果我们不移除墙壁，属于前一个`Building`的所有SolidObjects仍然会保留，从而在下一级中创建不可见的障碍物。
- en: 'We will use the `showMessage()` function to inform the user that the next level
    will be loaded soon (since it can take a while for the building object to be constructed).
    We need to ensure that we call `DISPLAY.loop_running()` after we draw the message.
    This ensures it is displayed on the screen before we start loading the level (after
    which the person will be unable to move while loading takes place). We need to
    ensure that the message is always facing the player, regardless of which of their
    sides collides with the `end` object, by using the camera rotation (`rot`) for
    its angle:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`showMessage()`函数来通知用户下一级关卡即将加载（因为构建对象可能需要一段时间）。我们需要确保在绘制消息后调用`DISPLAY.loop_running()`，这样可以确保在开始加载关卡之前（在此之后，玩家将无法移动，因为正在加载）消息已经在屏幕上显示。我们需要确保无论玩家的哪一侧与`end`对象发生碰撞，消息总是面向玩家，通过使用摄像机的旋转（`rot`）来调整其角度：
- en: '![](img/cc05fc13-625c-465b-9569-34302419fd8e.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc05fc13-625c-465b-9569-34302419fd8e.png)'
- en: When the exit ball is found, the next level is loaded
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到出口球时，加载下一级
- en: When the next level in the list has been loaded (or the first level has been
    loaded again when all the levels have been completed), we replace the message
    with a blank one to remove it and reset the person's position back to the start.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表中的下一级被加载（或者在所有级别都完成后再次加载第一级时），我们将消息替换为一个空白消息以移除它，并将该人的位置重置回起始位置。
- en: You can design and add your own levels by creating additional map files (20
    x 20 PNG files with walls marked out with black pixels and walkways in white)
    and listing them in `levelList`. The player will start at the top-left corner
    of the map, and the exit is placed at the center.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建额外的地图文件（20 x 20的PNG文件，用黑色像素标记墙壁，用白色表示通道）并在`levelList`中列出它们来设计和添加自己的关卡。玩家将从地图的左上角开始，出口放置在中心。
- en: You will notice that loading the levels can take quite a long time; this is
    the relatively slow ARM processor in Raspberry Pi performing all the calculations
    required to construct the maze and locate all the components. As soon as the maze
    has been built, the more powerful GPU takes over, which results in fast and smooth
    graphics as the player explores the space.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到加载关卡可能需要相当长的时间；这是相对较慢的树莓派ARM处理器在执行构建迷宫和定位所有组件所需的所有计算。一旦迷宫构建完成，更强大的GPU接管，这使得玩家探索空间时图形快速且流畅。
- en: This recipe demonstrates the difference between the original Raspberry Pi processor
    and Raspberry Pi 2\. Raspberry Pi 2 takes around 1 minute 20 seconds to load the
    first level, while the original Raspberry Pi can take up to 4 minutes 20 seconds.
    Raspberry Pi 3 takes a stunning 4 seconds to load the same level.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了原始树莓派处理器与树莓派2之间的区别。树莓派2加载第一级需要大约1分20秒，而原始树莓派可能需要长达4分20秒。树莓派3加载同一级仅需惊人的4秒。
- en: There's more...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The preceding example creates a building for the player to explore and interact
    with. In order to achieve this, we use the `Building` module of `pi3d` to create
    a building and use `SolidObject` to detect collisions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例为玩家创建了一个可以探索和交互的建筑。为了实现这一点，我们使用`pi3d`的`Building`模块来创建建筑，并使用`SolidObject`来检测碰撞。
- en: The Building module
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建筑模块
- en: 'The `pi3d.Building` module allows you to define a whole level or floor of a
    building using map files. Like the terrain maps used in the preceding example,
    the color of the pixels will be converted into different parts of the level. In
    our case, black is for the walls and white is used for the passages and halls,
    complete with ceilings:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3d.Building`模块允许您使用地图文件定义建筑物的整个楼层或楼层。就像前一个示例中使用的地形图一样，像素的颜色将被转换为不同部分的楼层。在我们的例子中，黑色用于墙壁，白色用于通道和走廊，并配有天花板：'
- en: '![](img/abc8e87e-59f5-4fc2-8a5b-abc3efd02e5e.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abc8e87e-59f5-4fc2-8a5b-abc3efd02e5e.png)'
- en: The building layout is defined by the pixels in the image
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑布局由图像中的像素定义
- en: 'The sections built by the `Building` object are defined by the `Scheme` used.
    The `Scheme` is defined by two sections, by the number of models, and then by
    the definitions for various aspects of the model, as seen in the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由`Building`对象构建的章节由所使用的`Scheme`定义。`Scheme`由两个部分定义，首先是模型的数量，然后是针对模型各个方面的定义，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first **tuple** defines the type of cell/square that the selected model
    should be applied to. Since there are two pixel colors in the map, the squares
    will either be black (`0`) or white (`1`). By determining the position and type
    of a particular cell/square, we can define which models (wall, ceiling, or roof)
    we want to apply.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个**元组**定义了所选模型应应用于哪种类型的单元格/方块。由于地图中有两种像素颜色，方块将是黑色（`0`）或白色（`1`）。通过确定特定单元格/方块的位置和类型，我们可以定义我们想要应用哪些模型（墙壁、天花板或屋顶）。
- en: 'We can define three main types of cell/square location:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义三种主要的单元格/方块位置类型：
- en: '**A whole square (1,None)**: This is a white cell representing open space in'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个完整的平方（1，None）**：这是一个代表开放空间的白色单元格。'
- en: the building.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这座建筑。
- en: '**One cell bordering another, on the edge (0,1,"edge")**: This is a black cell
    next to a white one on the map edge. This also includes `(1,0,"edge")`. This will
    represent the outer wall of the building.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相邻的两个单元格，在边缘（0,1,"edge"）**：这是地图边缘旁边的一个黑色单元格和一个白色单元格。这还包括 `(1,0,"edge")`。这将会代表建筑的外墙。'
- en: '**Any black cell that is next to a white cell (0,1)**: This will represent
    all of the internal walls of the building.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧挨着白色细胞（0,1）的任何黑色细胞**：这代表建筑物的所有内部墙壁。'
- en: 'Next, we allocate a type of object(s) to be applied for that type (`W` or `C`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分配一种（或多种）对象类型以应用于该类型（`W` 或 `C`）：
- en: '**Wall (W)**: This is a vertical wall that is placed between the specified
    cells (such as between black and white cells).'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**墙 (W)**: 这是一个放置在指定单元格之间（例如黑色和白色单元格之间）的垂直墙。'
- en: '**Ceiling (C)**: This is a horizontal section of the ceiling to cover the current
    cell.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天花板（C）**：这是覆盖当前单元格的水平天花板部分。'
- en: '**Roof (R)**: This is an additional horizontal section that is placed slightly
    above the ceiling to provide a roofing effect. It is typically used for buildings
    that may need to be viewed from the outside (this is not used in our example).'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屋顶 (R)**: 这是一个放置在天花板稍上方的额外水平部分，用于提供屋顶效果。它通常用于可能需要从外部观看的建筑（在我们的示例中不使用）。'
- en: '**Ceiling Edge (CE)**: This is used to join the ceiling sections to the roof
    around the edges of the building (it is not used in our example since ours is
    an indoor model).'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天花板边缘 (CE)**: 这用于将天花板部分连接到建筑物的屋顶边缘（在我们的示例中不使用，因为我们的模型是室内模型）。'
- en: Finally, we specify the model that will be used for each object. We are using
    three models in this example (normal walls, walls on an edge, and the ceiling),
    so we can define the model used by specifying `0`, `1`, or `2`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们指定每个对象将使用的模型。在这个示例中我们使用了三种模型（普通墙壁、边缘上的墙壁和天花板），因此我们可以通过指定`0`、`1`或`2`来定义所使用的模型。
- en: 'Each of the models are defined in the `details` array, which allows us to set
    the required textures and shaders for each one (this contains the same information
    that would normally be set by the `.set_draw_details()` function), as shown in
    the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型都在`details`数组中定义，这使得我们可以为每个模型设置所需的纹理和着色器（这包含通常由`.set_draw_details()`函数设置的相同信息），如下面的代码所示：
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our example, the inside walls are allocated to the `wallimg` texture (`textures/squareblocksred.png`)
    and the ceilings are allocated to the `ceilingimg` texture (`textures/squareblocks4.png`).
    You may be able to note from the following screenshot that we can apply different
    texture models (in our case, a slightly different scaling) to the different types
    of blocks. The walls that border the outside of the maze (with the edge identifier)
    will use the `wallimg` model texture scaled by 4 x 8 (`details[1]`) while the
    same model texture will be scaled 4 x 16 for the internal walls (`details[0]`):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，内部墙壁分配给了`wallimg`纹理（`textures/squareblocksred.png`），而天花板分配给了`ceilingimg`纹理（`textures/squareblocks4.png`）。您可能可以从下面的屏幕截图中发现，我们可以将不同的纹理模型（在我们的情况下，稍微不同的缩放）应用于不同类型的方块。迷宫外部的墙壁（带有边缘标识符）将使用`wallimg`模型纹理，缩放为4
    x 8（`details[1]`），而对于内部墙壁，相同的模型纹理将缩放为4 x 16（`details[0]`）：
- en: '![](img/94c15c80-75a1-47ff-96e0-12967c6792b4.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94c15c80-75a1-47ff-96e0-12967c6792b4.png)'
- en: Walls with different scaling
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 不同缩放的墙壁
- en: 'Both `scheme` and `draw_details` are set when the `pi3d.Building` object is
    created, as shown in the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`pi3d.Building`对象时，`scheme`和`draw_details`都被设置，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the map file (`levelList[next_level`]), the scheme (`mazeScheme`), and
    draw details (`details`), the entire building is created within the environment:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用地图文件（`levelList[next_level`]），方案（`mazeScheme`）和绘制细节（`details`），整个建筑在环境中被创建出来：
- en: '![](img/9f60cce2-156c-41f4-8e51-ebd2ec4fe8f6.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f60cce2-156c-41f4-8e51-ebd2ec4fe8f6.png)'
- en: An overhead view of the 3D maze we created
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的3D迷宫的俯视图
- en: Although we use just black and white in this example, other colored pixels can
    also be used to define additional block types (and therefore different textures,
    if required). If another color (such as gray) is added, the indexing of the color
    mapping is shifted so that black blocks are referenced as `0`, the new colored
    blocks as `1`, and the white blocks as `2`. See the **Silo** example in the `pi3d`
    demos for details.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: We also need to define an `ElevationMap` object: `mymap`. The `pi3d.Building`
    module makes use of the `ElevationMap` object's `calcHeight()` function to correctly
    place the walls on top of the `ElevationMap` object's surface. In this example,
    we will apply a basic `ElevationMap` object using `textures/floor.png`, which
    will generate a flat surface that the `Building` object will be placed on.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Using SolidObjects to detect collisions
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SolidObjects检测碰撞
- en: In addition to the `Building` object, we will define an object for the player
    and also define two objects to mark the start and end points of the maze. Although
    the player's view is the first person viewpoint (that is, we don't actually see
    them since the view is effectively through their eyes), we need to define a **SolidObject**
    to represent them.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: A SolidObject is a special type of invisible object that can be checked to determine
    if the space that would be occupied by one SolidObject has overlapped another.
    This will allow us to use `person.CollisionList(NewPos)` to get a list of any
    other SolidObjects that the `person` object will be in contact with at the `NewPos`
    position. Since the `Building` class defines SolidObjects for all of the parts
    of the `Building` object, we will be able to detect when the player tries to move
    through a wall (or, for some reason, the roof/ceiling) and stop them from moving
    through it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: We also use SolidObjects for the start and end locations in the maze. The place
    where the player starts is set as the top-left corner of the map (the white-space
    pixel from the top left of the map) and is marked by the `startpos` object (a
    small `pi3d.Sphere` with the `rock1.jpg` texture) placed above the person's head.
    The end of the maze is marked with another `pi3d.Sphere` object (with the `water.jpg`
    texture) located at the center of the map. We also define another SolidObject
    at the end so that we can detect when the player reaches it and collides with
    it (and load the next level).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
