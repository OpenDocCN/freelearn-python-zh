- en: Working with Models, Migrations, Serialization, and Deserialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与模型、迁移、序列化和反序列化一起工作
- en: 'In this chapter, we will define the requirements for our first RESTful Web
    Service. We will start working with Django, Django REST framework, Python, configurations,
    models, migrations, serialization, and deserialization. We will create a RESTful
    Web Service that performs **CRUD** (short for **Create**, **Read**, **Update**
    and **Delete**) operations on a simple SQLite database. We will be:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将定义我们第一个RESTful Web服务的要求。我们将开始使用Django、Django REST框架、Python、配置、模型、迁移、序列化和反序列化。我们将创建一个在简单SQLite数据库上执行**CRUD**（即**创建**、**读取**、**更新**和**删除**）操作的RESTful
    Web服务。我们将：
- en: Defining the requirements for our first RESTful Web Service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们第一个RESTful Web服务的要求
- en: Creating our first model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个模型
- en: Running our initial migration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行我们的初始迁移
- en: Understanding migrations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解迁移
- en: Analyzing the database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析数据库
- en: Understanding Django tables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Django表
- en: Controlling, serialization, and deserialization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制序列化和反序列化
- en: Working with the Django shell and diving deeply into serialization and deserialization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django shell并深入序列化和反序列化
- en: Defining the requirements for our first RESTful Web Service
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们第一个RESTful Web服务的要求
- en: Imagine a team of developers working on a mobile app for iOS and Android and
    requires a RESTful Web Service to perform CRUD operations with toys. We definitely
    don't want to use a mock web service and we don't want to spend time choosing
    and configuring an **ORM** (short for **Object-Relational Mapping**). We want
    to quickly build a RESTful Web Service and have it ready as soon as possible to
    start interacting with it in the mobile app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个开发团队正在为iOS和Android开发一个移动应用，并需要一个RESTful Web服务来执行与玩具相关的CRUD操作。我们肯定不想使用模拟Web服务，也不想花费时间选择和配置**ORM**（即**对象关系映射**）。我们希望快速构建一个RESTful
    Web服务，并尽快准备好以便在移动应用中与之交互。
- en: We really want the toys to persist in a database but we don't need it to be
    production-ready. Therefore, we can use the simplest possible relational database,
    as long as we don't have to spend time performing complex installations or configurations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的希望玩具在数据库中持久化，但我们不需要它准备好用于生产。因此，我们可以使用最简单的可能的关系数据库，只要我们不需要花费时间进行复杂的安装或配置。
- en: '**Django REST framework**, also known as **DRF**, will allow us to easily accomplish
    this task and start making HTTP requests to the first version of our RESTful Web
    Service. In this case, we will work with a very simple SQLite database, the default
    database for a new Django REST framework project.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Django REST框架**，也称为**DRF**，将使我们能够轻松完成这项任务，并开始向我们的RESTful Web服务的第一版本发送HTTP请求。在这种情况下，我们将使用一个非常简单的SQLite数据库，它是新Django
    REST框架项目的默认数据库。'
- en: 'First, we must specify the requirements for our main resource: a toy. We need
    the following attributes or fields for a toy entity:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须指定我们主要资源：玩具的要求。对于一个玩具实体，我们需要以下属性或字段：
- en: An integer identifier
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数标识符
- en: A name
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: An optional description
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的描述
- en: A toy category description, such as action figures, dolls, or playsets
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩具类别描述，例如动作人偶、娃娃或玩具套装
- en: A release date
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布日期
- en: A bool value indicating whether the toy has been on the online store's homepage
    at least once
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，表示玩具是否至少一次出现在在线商店的主页上
- en: In addition, we want to have a timestamp with the date and time of the toy's
    addition to the database table, which will be generated to persist toys.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望在数据库表中添加一个时间戳，记录玩具添加的日期和时间，这将用于持久化玩具信息。
- en: In a RESTful Web Service, each resource has its own unique URL. In our web service,
    each toy will have its own unique URL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在RESTful Web服务中，每个资源都有自己的唯一URL。在我们的Web服务中，每个玩具都将有自己的唯一URL。
- en: 'The following table shows the HTTP verbs, the scope, and the semantics of the
    methods that our first version of the web service must support. Each method is
    composed of an HTTP verb and a scope. All the methods have a well-defined meaning
    for toys and collections:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们的Web服务第一版本必须支持的HTTP动词、范围和方法的语义。每个方法由一个HTTP动词和一个范围组成。所有方法都对玩具和集合有明确的含义：
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **范围** | **语义** |'
- en: '| GET | Toy | Retrieve a single toy |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| GET | Toy | 获取单个玩具 |'
- en: '| GET | Collection of toys | Retrieve all the stored toys in the collection,
    sorted by their name in ascending order |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| GET | 玩具集合 | 获取存储在集合中的所有玩具，按名称升序排序 |'
- en: '| POST | Collection of toys | Create a new toy in the collection |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| POST | 玩具集合 | 在集合中创建一个新的玩具 |'
- en: '| PUT | Toy | Update an existing toy |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| PUT | 玩具 | 更新现有的玩具 |'
- en: '| DELETE | Toy | Delete an existing toy |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | 玩具 | 删除现有的玩具 |'
- en: 'In the previous table, the GET HTTP verb appears twice but with two different
    scopes: toys and collection of toys. The first row shows a GET HTTP verb applied
    to a toy, that is, to a single resource. The second row shows a GET HTTP verb
    applied to a collection of toys, that is, to a collection of resources.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的表中，GET HTTP动词出现了两次，但有两个不同的作用域：玩具和玩具集合。第一行显示GET HTTP动词应用于玩具，即单个资源。第二行显示GET
    HTTP动词应用于玩具集合，即资源集合。
- en: We want our web service to be able to differentiate collections from a single
    resource of the collection in the URLs. When we refer to a collection, we will
    use a slash (`/`) as the last character for the URL, as in `http://localhost:8000/toys/`.
    When we refer to a single resource of the collection we won't use a slash (`/`)
    as the last character for the URL, as in `http://localhost:8000/toys/5`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的Web服务能够区分URL中的集合与单个集合资源。当我们提到集合时，我们将使用斜杠（`/`）作为URL的最后一个字符，例如`http://localhost:8000/toys/`。当我们提到集合的单个资源时，我们不会在URL的最后一个字符使用斜杠（`/`），例如`http://localhost:8000/toys/5`。
- en: Let's consider that `http://localhost:8000/toys/` is the URL for the collection
    of toys. If we add a number to the previous URL, we identify a specific toy with
    an ID or primary key equal to the specified numeric value. For example, `http://localhost:8000/toys/42`
    identifies the toy with an ID equal to `42`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`http://localhost:8000/toys/`是玩具集合的URL。如果我们向之前的URL添加一个数字，我们就可以通过一个ID或主键等于指定数值的特定玩具来识别。例如，`http://localhost:8000/toys/42`识别ID等于`42`的玩具。
- en: 'We have to compose and send an HTTP request with the `POST` HTTP verb and `http://localhost:8000/toys/` request
    URL to create a new toy and add it to the toys collection. In this example, our
    RESTful Web Service will work with **JSON** (short for **JavaScript Object Notation**),
    and therefore we have to provide the JSON key-value pairs with the field names
    and the values to create the new toy. As a result of the request, the server will
    validate the provided values for the fields, make sure that it is a valid toy,
    and persist it in the database. The server will insert a new row with the new
    toy in the appropriate table and it will return a `201 Created` status code and
    a JSON body with the recently added toy serialized to JSON, including the assigned
    ID that was automatically generated by the database and assigned to the toy object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`POST` HTTP动词和`http://localhost:8000/toys/`请求URL来创建一个新的玩具并将其添加到玩具收藏中。在这个例子中，我们的RESTful
    Web服务将使用**JSON**（即**JavaScript对象表示法**），因此我们必须提供JSON键值对，包括字段名称和值来创建新的玩具。请求的结果是，服务器将验证提供的字段值，确保它是一个有效的玩具，并将其持久化到数据库中。服务器将在适当的表中插入一行新的玩具，并返回一个`201
    Created`状态码和一个包含最近添加的玩具序列化为JSON的JSON正文，包括由数据库自动生成的分配给玩具对象的ID：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have to compose and send an HTTP request with the `GET` HTTP verb and `http://localhost:8000/toys/{id}` request
    URL to retrieve the toy whose ID matches the specified numeric value in `{id}`.
    For example, if we use the request URL `http://localhost:8000/toys/25`, the server
    will retrieve the toy whose ID matches `25`. As a result of the request, the server
    will retrieve a toy with the specified ID from the database and create the appropriate
    toy object in Python. If a toy is found, the server will serialize the toy object
    into JSON, return a `200 OK` status code, and return a JSON body with the serialized
    toy object. If no toy matches the specified ID, the server will return only a
    `404 Not Found` status:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`GET` HTTP动词和`http://localhost:8000/toys/{id}`请求URL来检索ID与`{id}`中指定的数值匹配的玩具。例如，如果我们使用请求URL
    `http://localhost:8000/toys/25`，服务器将检索ID匹配`25`的玩具。请求的结果是，服务器将从数据库中检索具有指定ID的玩具并创建适当的Python玩具对象。如果找到玩具，服务器将序列化玩具对象为JSON，返回一个`200
    OK`状态码，并返回一个包含序列化玩具对象的JSON正文。如果没有找到与指定ID匹配的玩具，服务器将只返回一个`404 Not Found`状态：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have to compose and send an HTTP request with the `PUT` HTTP verb and request
    URL `http://localhost:8000/toys/{id}` to retrieve the toy whose ID matches the
    value in `{id}` and replace it with a toy created with the provided data. In addition,
    we have to provide the JSON key-value pairs with the field names and the values
    to create the new toy that will replace the existing one. As a result of the request,
    the server will validate the provided values for the fields, make sure that it
    is a valid toy, and replace the one that matches the specified ID with the new
    one in the database. The ID for the toy will be the same after the update operation.
    The server will update the existing row in the appropriate table and it will return
    a `200 OK` status code and a JSON body with the recently updated toy serialized
    to JSON. If we don''t provide all the necessary data for the new toy, the server
    will return a `400 Bad Request` status code. If the server doesn''t find a toy
    with the specified ID, the server will only return a `404 Not Found` status:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `PUT` HTTP 动词和请求 URL `http://localhost:8000/toys/{id}` 来发送一个 HTTP 请求，以检索与
    `{id}` 中值匹配的玩具，并用提供的数据创建的玩具替换它。此外，我们必须提供带有字段名称和值的 JSON 键值对，以创建将替换现有玩具的新玩具。请求的结果是，服务器将验证提供的字段值，确保它是一个有效的玩具，并将数据库中与指定
    ID 匹配的玩具替换为新玩具。更新操作后，玩具的 ID 将保持不变。服务器将更新适当表中的现有行，并返回一个 `200 OK` 状态码和一个包含最近更新的玩具序列化为
    JSON 的 JSON 主体。如果我们没有提供新玩具的所有必要数据，服务器将返回一个 `400 Bad Request` 状态码。如果服务器找不到具有指定
    ID 的玩具，服务器将只返回一个 `404 Not Found` 状态：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have to compose and send an HTTP request with the `DELETE `HTTP verb and
    request URL `http://localhost:8000/toys/{id}` to remove the toy whose ID matches
    the specified numeric value in `{id}`. For example, if we use the request URL
    `http://localhost:8000/toys/34`, the server will delete the toy whose ID matches
    `34`. As a result of the request, the server will retrieve a toy with the specified
    ID from the database and create the appropriate toy object in Python. If a toy
    is found, the server will request the ORM delete the toy row associated with this
    toy object and the server will return a `204 No Content` status code. If no toy
    matches the specified ID, the server will return only a `404 Not Found` status:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `DELETE` HTTP 动词和请求 URL `http://localhost:8000/toys/{id}` 来发送一个 HTTP
    请求，以删除与指定在 `{id}` 中的数值匹配的玩具。例如，如果我们使用请求 URL `http://localhost:8000/toys/34`，服务器将删除与
    `34` 匹配的玩具。请求的结果是，服务器将从数据库中检索具有指定 ID 的玩具，并在 Python 中创建适当的玩具对象。如果找到玩具，服务器将请求 ORM
    删除与该玩具对象关联的玩具行，服务器将返回一个 `204 No Content` 状态码。如果没有找到与指定 ID 匹配的玩具，服务器将只返回一个 `404
    Not Found` 状态：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating our first model
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个模型
- en: 'Now, we will create a simple `Toy` model in Django, which we will use to represent
    and persist toys. Open the `toys/models.py` file. The following lines show the
    initial code for this file with just one `import` statement and a comment that
    indicates we should create the models:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 Django 中创建一个简单的 `Toy` 模型，我们将使用它来表示和持久化玩具。打开 `toys/models.py` 文件。以下行显示了该文件的初始代码，其中只有一个
    `import` 语句和一个注释，表明我们应该创建模型：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following lines show the new code that creates a `Toy` class, specifically,
    a `Toy` model in the `toys/models.py` file. The code file for the sample is included
    in the `hillar_django_restful_02_01` folder in the `restful01/toys/models.py`
    file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了创建 `Toy` 类的新代码，具体来说，是在 `toys/models.py` 文件中的 `Toy` 模型。示例的代码文件包含在 `restful01/toys/models.py`
    文件中的 `hillar_django_restful_02_01` 文件夹中：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Toy` class is a subclass of the `django.db.models.Model` class and defines
    the following attributes: `created`, `name`, `description`, `toy_category`, `release_date`, and
    `was_included_in_home`. Each of these attributes represents a database column
    or field.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toy` 类是 `django.db.models.Model` 类的子类，并定义了以下属性：`created`、`name`、`description`、`toy_category`、`release_date`
    和 `was_included_in_home`。这些属性中的每一个都代表一个数据库列或字段。'
- en: Django automatically adds an auto-increment integer primary key column named
    `id` when it creates the database table related to the model. It is very important
    to notice that the model maps the underlying `id` column in an attribute named
    `pk` for the model.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Django 在创建与模型相关的数据库表时自动添加一个名为 `id` 的自增整数主键列。非常重要的一点是，模型将底层的 `id` 列映射到模型的一个名为
    `pk` 的属性。
- en: We specified the field types, maximum lengths, and defaults for many attributes.
    The class declares a `Meta` inner class that declares an `ordering` attribute
    and sets its value to a tuple of `string` whose first value is the `'name'` string.
    This way, the inner class indicates to Django that, by default, we want the results
    ordered by the `name` attribute in ascending order.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了许多属性的字段类型、最大长度和默认值。类声明了一个 `Meta` 内部类，它声明了一个 `ordering` 属性并将其值设置为包含 `string`
    的元组，其第一个值是 `'name'` 字符串。这样，内部类指示Django，默认情况下，我们希望按 `name` 属性的升序排序结果。
- en: Running our initial migration
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的初始迁移
- en: Now, it is necessary to create the initial migration for the new `Toy` model
    we recently coded. We will also synchronize the SQLite database for the first
    time. By default, Django uses the popular self-contained and embedded SQLite database,
    and therefore we don't need to make changes in the initial ORM configuration.
    In this example, we will be working with this default configuration. Of course,
    we will upgrade to another database after we have a sample web service built with
    Django. We will only use SQLite for this example.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有必要为最近编写的新的 `Toy` 模型创建初始迁移。我们还将首次同步SQLite数据库。默认情况下，Django使用流行的自包含和嵌入式SQLite数据库，因此我们不需要在初始ORM配置中进行更改。在这个例子中，我们将使用这个默认配置。当然，在我们用Django构建一个示例网络服务之后，我们将升级到另一个数据库。在这个例子中，我们只会使用SQLite。
- en: 'We just need to run the following Python script in the virtual environment
    that we activated in the previous chapter. Make sure you are in the `restful01`
    folder within the main folder for the virtual environment when you run the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在上一章中激活的虚拟环境中运行以下Python脚本。确保你在虚拟环境主文件夹中的 `restful01` 文件夹内运行以下命令：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following lines show the output generated after running the previous command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一条命令后生成的输出：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output indicates that the `restful01/toys/migrations/0001_initial.py` file
    includes the code to create the `Toy` model. The following lines show the code
    for this file that was automatically generated by Django. The code file for the
    sample is included in the `hillar_django_restful_02_01` folder in the `restful01/toys/migrations/0001_initial.py`
    file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明 `restful01/toys/migrations/0001_initial.py` 文件包含了创建 `Toy` 模型的代码。以下行显示了由Django自动生成的此文件的代码。示例代码文件包含在
    `hillar_django_restful_02_01` 文件夹中的 `restful01/toys/migrations/0001_initial.py`
    文件中：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Understanding migrations
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解迁移
- en: The automatically generated code defines a subclass of the `django.db.migrations.Migration`
    class named `Migration`, which defines an operation that creates the `Toy` model's
    table and includes it in the `operations` attribute. The call to the `migrations.CreateModel`
    method specifies the model's name, the fields, and the options to instruct the
    ORM to create a table that will allow the underlying database to persist the model.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的代码定义了一个名为 `Migration` 的 `django.db.migrations.Migration` 类的子类，它定义了一个创建
    `Toy` 模型表的操作，并将其包含在 `operations` 属性中。对 `migrations.CreateModel` 方法的调用指定了模型名称、字段以及指令ORM创建一个允许底层数据库持久化模型的表的选项。
- en: The `fields` argument is a list of tuples that includes information about the
    field name, the field type, and additional attributes based on the data we provided
    in our model, that is, in the `Toy` class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`fields` 参数是一个包含有关字段名称、字段类型以及基于我们在模型中（即 `Toy` 类中）提供的数据的额外属性的元组列表。这些属性包括字段名称、字段类型和基于我们提供的模型数据的额外属性。'
- en: 'Now, run the following Python script to apply all the generated migrations.
    Make sure you are in the `restful01` folder within the main folder for the virtual
    environment when you run the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下Python脚本来应用所有生成的迁移。确保你在虚拟环境的主文件夹中的 `restful01` 文件夹内运行以下命令：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following lines show the output generated after running the previous command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一条命令后生成的输出：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After we run the previous command, we will notice that the root folder for our
    `restful01` project now has a `db.sqlite3` file that contains the SQLite database.
    We can use the SQLite command line or any other application that allows us to
    easily check the contents of the SQLite database to check the tables that Django
    generated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行上一条命令后，我们会注意到我们的 `restful01` 项目的根文件夹现在有一个包含SQLite数据库的 `db.sqlite3` 文件。我们可以使用SQLite命令行或任何其他允许我们轻松检查SQLite数据库内容的应用程序来检查Django生成的表。
- en: The first migration will generate many tables required by Django and its installed
    apps before running the code that creates the table for the `Toys` model. These
    tables provide support for user authentication, permissions, groups, logs, and
    migration management. We will work with the models related to these tables after
    we add more features and security to our web services.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次迁移将在运行创建 `Toys` 模型表的代码之前生成 Django 和其安装的应用程序所需的大量表。这些表为用户身份验证、权限、组、日志和迁移管理提供支持。在添加更多功能和安全性到我们的
    Web 服务之后，我们将与这些表相关的模型一起工作。
- en: After the migration process creates all these Django tables in the underlying
    database, the first migration runs the Python code that creates the table required
    to persist our model. Thus, the last line of the running migrations section displays
    `Applying toys.0001_initial`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移过程在底层数据库中创建所有这些 Django 表之后，第一次迁移运行创建我们模型所需的表的 Python 代码。因此，运行迁移部分的最后一行显示为
    `Applying toys.0001_initial`。
- en: Analyzing the database
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析数据库
- en: In most modern Linux distributions and macOS, SQLite is already installed, and
    therefore you can run the `sqlite3` command-line utility.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代 Linux 发行版和 macOS 中，SQLite 已经安装，因此您可以运行 `sqlite3` 命令行实用程序。
- en: In Windows, if you want to work with the `sqlite3.exe` command-line utility,
    you have to download the bundle of command-line tools for managing SQLite database
    files from the downloads section of the SQLite webpage at [http://www.sqlite.org/download.html](http://www.sqlite.org/download.html).
    For example, the ZIP file that includes the command-line tools for version 3.20.1
    is `sqlite-tools-win32-x8 6-3200100.zip`. The name for the file changes with the
    SQLite version. You just need to make sure that you download the bundle of command-line
    tools and not the ZIP file that provides the SQLite DLLs. After you unzip the
    file, you can include the folder that includes the command-line tools in the PATH
    environment variable, or you can access the `sqlite3.exe` command-line utility
    by specifying the full path to it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，如果您想使用 `sqlite3.exe` 命令行实用程序，您必须从 SQLite 网页的下载部分下载管理 SQLite 数据库文件的命令行工具包。[http://www.sqlite.org/download.html](http://www.sqlite.org/download.html)。例如，包含版本
    3.20.1 的命令行工具的 ZIP 文件是 `sqlite-tools-win32-x86-3200100.zip`。文件名会随着 SQLite 版本而变化。您只需确保您下载的是命令行工具包，而不是提供
    SQLite DLLs 的 ZIP 文件。解压缩文件后，您可以将包含命令行工具的文件夹包含在 PATH 环境变量中，或者通过指定其完整路径来访问 `sqlite3.exe`
    命令行实用程序。
- en: 'Run the following command to list the generated tables. The first argument,
    `db.sqlite3`, specifies the file that contains that SQLite database and the second
    argument indicates the command that we want the `sqlite3` command-line utility
    to run against the specified database:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以列出生成的表。第一个参数 `db.sqlite3` 指定了包含该 SQLite 数据库的文件，第二个参数表示我们想要 `sqlite3`
    命令行实用程序针对指定数据库运行的命令：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following lines show the output for the previous command with the list
    of tables that Django generated in the SQLite database:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了上一条命令的输出，列出了 Django 在 SQLite 数据库中生成的表列表：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following command will allow you to check the contents of the `toys_toy`
    table after we compose and send HTTP requests to the RESTful Web Service and the
    web service makes CRUD operations to the `toys_toy` table:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在我们向 RESTful Web 服务发送并发送 HTTP 请求后，以及该 Web 服务对 `toys_toy` 表执行 CRUD 操作后，允许您检查
    `toys_toy` 表的内容：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Instead of working with the SQLite command-line utility, you can use a GUI tool
    to check the contents of the SQLite database. DB Browser for SQLite is a useful,
    free, multiplatform GUI tool that allows us to easily check the database contents
    of an SQLite database in Linux, macOS, and Windows. You can read more information
    about this tool and download its different versions from [http://sqlitebrowser.org](http://sqlitebrowser.org).
    Once you have installed the tool, you just need to open the `db.sqlite3` file
    and you can check the database structure and browse the data for the different
    tables. After we start working with the first version of our web service, you
    need to check the contents of the `toys_toy` table with this tool.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用图形界面工具而不是 SQLite 命令行实用程序来检查 SQLite 数据库的内容。DB Browser for SQLite 是一个有用、免费、多平台的图形界面工具，它允许我们在
    Linux、macOS 和 Windows 中轻松检查 SQLite 数据库的内容。您可以从 [http://sqlitebrowser.org](http://sqlitebrowser.org)
    阅读有关此工具的更多信息并下载其不同版本。一旦您安装了此工具，您只需打开 `db.sqlite3` 文件，就可以检查数据库结构并浏览不同表的数据。在我们开始使用
    Web 服务的第一个版本后，您需要使用此工具检查 `toys_toy` 表的内容。
- en: You can also use the database tools included with your favorite IDE to check
    the contents of the SQLite database.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用您最喜欢的 IDE 中包含的数据库工具来检查 SQLite 数据库的内容。
- en: 'The SQLite database engine and the database file name are specified in the
    `restful01/settings.py` Python file. The following lines show the declaration
    of the DATABASES dictionary, which contains the settings for all the databases
    that Django uses. The nested dictionary maps the database named `default` with
    the `django.db.backends.sqlite3` database engine and the `db.sqlite3` database
    file located in the `BASE_DIR` folder (`restful01`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库引擎和数据库文件名在 `restful01/settings.py` Python 文件中指定。以下行显示了 `DATABASES`
    字典的声明，其中包含 Django 所用所有数据库的设置。嵌套字典将名为 `default` 的数据库映射到 `django.db.backends.sqlite3`
    数据库引擎和位于 `BASE_DIR` 文件夹（`restful01`）中的 `db.sqlite3` 数据库文件：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After we execute the migrations, the SQLite database will have the following
    tables. Django uses prefixes to identify the modules and applications that each
    table belongs to. The tables that start with the `auth_` prefix belong to the
    Django authentication module. The table that starts with the `toys_` prefix belongs
    to our `toys` application. If we add more models to our `toys` application, Django
    will create new tables with the `toys_` prefix:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 执行迁移后，SQLite 数据库将具有以下表。Django 使用前缀来标识每个表所属的模块和应用程序。以 `auth_` 前缀开头的表属于 Django
    认证模块。以 `toys_` 前缀开头的表属于我们的 `toys` 应用程序。如果我们向 `toys` 应用程序添加更多模型，Django 将创建具有 `toys_`
    前缀的新表：
- en: '`auth_group`: Stores authentication groups'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_group`: 存储认证组'
- en: '`auth_group_permissions`: Stores permissions for authentication groups'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_group_permissions`: 存储认证组的权限'
- en: '`auth_permission`: Stores permissions for authentication'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_permission`: 存储认证权限'
- en: '`auth_user`: Stores authentication users'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_user`: 存储认证用户'
- en: '`auth_user_groups`: Stores authentication user groups'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_user_groups`: 存储认证用户组'
- en: '`auth_user_groups_permissions`: Stores permissions for authentication user
    groups'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_user_groups_permissions`: 存储认证用户组的权限'
- en: '`django_admin_log`: Stores the Django administrator log'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django_admin_log`: 存储Django管理员日志'
- en: '`django_content_type`: Stores Django content types'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django_content_type`: 存储Django内容类型'
- en: '`django_migrations`: Stores the scripts generated by Django migrations and
    the date and time at which they were applied'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django_migrations`: 存储Django迁移生成的脚本以及它们应用的时间和日期'
- en: '`django_session`: Stores Django sessions'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django_session`: 存储Django会话'
- en: '`toys_toy`: Persists the `Toys` model'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toys_toy`: 持久化 `Toys` 模型'
- en: '`sqlite_sequence`: Stores sequences for SQLite primary keys with autoincrement
    fields'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite_sequence`: 存储具有自增字段的 SQLite 主键的序列'
- en: Understanding the table generated by Django
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Django 生成的表
- en: The `toys_toy` table persists in the database the `Toy` class we recently created,
    specifically, the `Toy` model. Django's integrated ORM generated the `toys_toy`
    table based on our `Toy` model.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`toys_toy` 表在数据库中持久化了我们最近创建的 `Toy` 类，具体来说，是 `Toy` 模型。Django 的集成 ORM 根据我们的 `Toy`
    模型生成了 `toys_toy` 表。'
- en: 'Run the following command to retrieve the SQL used to create the `toys_toy`
    table:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以检索创建 `toys_toy` 表所用的 SQL：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following lines show the output for the previous command together with
    the SQL that the migrations process executed, to create the `toys_toy` table that
    persists the `Toy` model. The next lines are formatted to make it easier to understand
    the SQL code. Notice that the output from the command is formatted in a different
    way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了上一条命令的输出以及迁移过程执行的 SQL，以创建持久化 `Toy` 模型的 `toys_toy` 表。以下行格式化以便更容易理解 SQL
    代码。注意，命令的输出格式不同：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `toys_toy` table has the following columns (also known as fields) with
    their SQLite types, all of them not nullable:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`toys_toy` 表具有以下列（也称为字段），以及它们的 SQLite 类型，所有这些列均不可为空：'
- en: '`id`: The integer primary key, an autoincrement row'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 整数主键，自增行'
- en: '`created`: DateTime'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`: 日期时间'
- en: '`name`: varchar(150)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: varchar(150)'
- en: '`description`: varchar(250)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: varchar(250)'
- en: '`toy_category`: varchar(200)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toy_category`: varchar(200)'
- en: '`release_date`: DateTime'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release_date`: 日期时间'
- en: '`was_included_in_home`: bool'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`was_included_in_home`: 布尔值'
- en: Controlling, serialization, and deserialization
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制、序列化和反序列化
- en: Our RESTful Web Service has to be able to serialize and deserialize the `Toy`
    instances into JSON representations. In Django REST framework, we just need to
    create a serializer class for the `Toy` instances to manage serialization to JSON
    and deserialization from JSON. Now, we will dive deep into the serialization and
    deserialization process in Django REST framework. It is very important to understand
    how it works because it is one of the most important components for all the RESTful
    Web Services we will build.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 RESTful 网络服务必须能够将 `Toy` 实例序列化和反序列化为 JSON 表示形式。在 Django REST 框架中，我们只需为 `Toy`
    实例创建一个序列化器类来管理对 JSON 的序列化和从 JSON 的反序列化。现在，我们将深入探讨 Django REST 框架中的序列化和反序列化过程。理解其工作原理非常重要，因为它是我们将要构建的所有
    RESTful 网络服务最重要的组件之一。
- en: Django REST framework uses a two-phase process for serialization. The serializers
    are mediators between the model instances and Python primitives. Parser and renderers
    handle as mediators between Python primitives and HTTP requests and responses.
    We will configure our mediator between the `Toy` model instances and Python primitives
    by creating a subclass of the `rest_framework.serializers.Serializer` class to
    declare the fields and the necessary methods to manage serialization and deserialization.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST 框架使用两阶段过程进行序列化。序列化器是模型实例和 Python 基本类型之间的中介。解析器和渲染器作为 Python 基本类型和
    HTTP 请求及响应之间的中介。我们将通过创建 `rest_framework.serializers.Serializer` 类的子类来配置我们的中介，以在
    `Toy` 模型实例和 Python 基本类型之间声明字段和必要的序列化和反序列化管理方法。
- en: We will repeat some of the information about the fields that we have included
    in the `Toy` model so that we understand all the things that we can configure
    in a subclass of the `Serializer` class. However, we will work with shortcuts,
    which will reduce boilerplate code later in the following examples. We will write
    less code in the following examples by using the `ModelSerializer` class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复一些关于 `Toy` 模型中包含的字段的信息，以便我们理解在 `Serializer` 类的子类中可以配置的所有内容。然而，我们将使用快捷方式，这将在以下示例中减少样板代码。我们将通过使用
    `ModelSerializer` 类来编写更少的代码。
- en: 'Now, go to the `restful01/toys` folder and create a new Python code file named
    `serializers.py`. The following lines show the code that declares the new `ToySerializer`
    class. The code file for the sample is included in the `hillar_django_restful_02_01`
    folder in the `restful01/toys/``serializers.py` file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `restful01/toys` 文件夹，创建一个名为 `serializers.py` 的新 Python 代码文件。以下行显示了声明新
    `ToySerializer` 类的代码。示例的代码文件包含在 `hillar_django_restful_02_01` 文件夹中的 `restful01/toys/serializers.py`
    文件中：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `ToySerializer` class declares the attributes that represent the fields
    that we want to be serialized. Notice that we have omitted the `created` attribute
    that was present in the `Toy` model. When there is a call to the `save` method
    that `ToySerializer` inherits from the `serializers.Serializer` superclass, the
    overridden `create` and `update` methods define how to create a new instance or
    update an existing instance. In fact, these methods must be implemented in our
    class because they only raise a `NotImplementedError` exception in their base
    declaration in the `serializers.Serializer` superclass.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToySerializer` 类声明了代表我们想要序列化的字段的属性。请注意，我们已经省略了在 `Toy` 模型中存在的 `created` 属性。当调用
    `ToySerializer` 从 `serializers.Serializer` 超类继承的 `save` 方法时，重写的 `create` 和 `update`
    方法定义了如何创建新实例或更新现有实例。实际上，这些方法必须在我们的类中实现，因为它们在其基类 `serializers.Serializer` 中的声明中只引发一个
    `NotImplementedError` 异常。'
- en: The `create` method receives the validated data in the `validated_data` argument.
    The code creates and returns a new `Toy` instance based on the received validated
    data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 方法接收 `validated_data` 参数中的验证数据。代码根据接收到的验证数据创建并返回一个新的 `Toy` 实例。'
- en: The `update` method receives an existing `Toy` instance that is being updated
    and the new validated data in the `instance` and `validated_data` arguments. The
    code updates the values for the attributes of the instance with the updated attribute
    values retrieved from the validated data. Finally, the code calls the `save` method
    for the updated `Toy` instance and returns the updated and saved instance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 方法接收一个正在更新的现有 `Toy` 实例和包含在 `instance` 和 `validated_data` 参数中的新验证数据。代码使用从验证数据中检索的更新属性值来更新实例的属性值。最后，代码调用更新后的
    `Toy` 实例的 `save` 方法，并返回更新并保存的实例。'
- en: Working with the Django shell and diving deeply into serialization and deserialization
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Django shell 并深入探讨序列化和反序列化
- en: We can launch our default Python interactive shell in our virtual environment
    and make all the Django project modules available before it starts. This way,
    we can check that the serializer works as expected. We will do this to understand
    how serialization works in Django.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在虚拟环境中启动默认的Python交互式shell，并在它开始之前使所有Django项目模块可用。这样，我们可以检查序列化器是否按预期工作。我们将这样做以了解Django中序列化的工作方式。
- en: 'Run the following command to launch the interactive shell. Make sure you are
    within the `restful01` folder in the terminal, Command Prompt, or Windows Powershell:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以启动交互式shell。请确保你在终端、命令提示符或Windows Powershell中的`restful01`文件夹内：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will notice a line that says `(InteractiveConsole)` is displayed after
    the usual lines that introduce your default Python interactive shell. The following
    screenshot shows the Django shell launched in a Windows command prompt:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在通常介绍默认Python交互式shell的行之后，会显示一行说`(InteractiveConsole)`。以下截图显示了在Windows命令提示符中启动的Django
    shell：
- en: '![](img/c9ec6e74-4bbd-4c0a-9178-4c81bd2d1b33.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9ec6e74-4bbd-4c0a-9178-4c81bd2d1b33.png)'
- en: 'Enter the following code in the Python interactive shell to import all the
    things we will need to test the `Toy` model and its serializer. The code file
    for the sample is included in the `hillar_django_restful_02_01` folder, in the
    `restful01/toy_serializers_test_01.py` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python交互式shell中输入以下代码以导入我们将需要测试`Toy`模型及其序列化器的所有内容。示例的代码文件包含在`hillar_django_restful_02_01`文件夹中，位于`restful01/toy_serializers_test_01.py`文件中：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Enter the following code to create two instances of the `Toy` model and save
    them. The code file for the sample is included in the `hillar_django_restful_02_01`
    folder, in the `restful01/toy_serializers_test_01.py` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码以创建两个`Toy`模型的实例并将它们保存。示例的代码文件包含在`hillar_django_restful_02_01`文件夹中，位于`restful01/toy_serializers_test_01.py`文件中：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After we execute the preceding code, we can check the SQLite database with the
    previously introduced command-line or GUI tools to check the contents of the `toys_toy`
    table. We will notice the table has two rows and columns with the values we have
    provided to the different attributes of the `Toy` instances. The following screenshot
    shows the results of browsing the data of the `toys_toy` table with the DB Browser
    for SQLite GUI utility. We can see that two rows were inserted.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，我们可以使用之前介绍的命令行或GUI工具检查SQLite数据库，以检查`toys_toy`表的内容。我们会注意到表中有两行，列出了我们提供给`Toy`实例不同属性的值。以下截图显示了使用DB
    Browser for SQLite GUI实用程序浏览`toys_toy`表数据的结果。我们可以看到插入了两个行。
- en: 'Enter the following code in the interactive shell to check the values for the
    primary keys or identifiers for the saved `Toy` instances, and the value of their
    `name` and `was_included_in_home_attribute` attributes. The code also checks the
    value of the `created` attribute, which includes the date and time at which Django
    saved each instance to the database. The code file for the sample is included
    in the `hillar_django_restful_02_01` folder, in the `restful01/toy_serializers_test_01.py`
    file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式shell中输入以下代码以检查已保存`Toy`实例的主键或标识符的值，以及它们的`name`和`was_included_in_home_attribute`属性的值。代码还检查`created`属性的值，该属性包括Django将每个实例保存到数据库的日期和时间。示例的代码文件包含在`hillar_django_restful_02_01`文件夹中，位于`restful01/toy_serializers_test_01.py`文件中：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following screenshot shows sample results of the previously shown code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了之前展示的代码的示例结果：
- en: '![](img/9c6597cc-6372-4109-9ce0-0103b525bd4b.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c6597cc-6372-4109-9ce0-0103b525bd4b.png)'
- en: 'Now, let''s write the following code to serialize the first `Toy` instance
    (`toy1`). The code file for the sample is included in the `hillar_django_restful_02_01`
    folder, in the `restful01/toy_serializers_test_01.py` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写以下代码以序列化第一个`Toy`实例（`toy1`）。示例的代码文件包含在`hillar_django_restful_02_01`文件夹中，位于`restful01/toy_serializers_test_01.py`文件中：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following lines show the generated dictionary, specifically, a `rest_framework.utils.serializer_helpers.ReturnDict`
    instance, stored in the `serializer_for_toy1.data` attribute. The next lines show
    the results with easily understood formatting:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了生成的字典，特别是存储在`serializer_for_toy1.data`属性中的`rest_framework.utils.serializer_helpers.ReturnDict`实例。接下来的行显示了易于理解的格式化结果：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s serialize the second `Toy` instance (`toy2`). The code file for
    the sample is included in the `hillar_django_restful_02_01` folder, in the `restful01/toy_serializers_test_01.py`
    file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们序列化第二个`Toy`实例（`toy2`）。示例的代码文件包含在`hillar_django_restful_02_01`文件夹中，位于`restful01/toy_serializers_test_01.py`文件中：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following lines show the generated dictionary stored in the `serializer_for_toy2.data`
    attribute. The next lines show the results with easily understood formatting:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行代码显示了存储在`serializer_for_toy2.data`属性中的生成的字典。下一行显示了以易于理解的方式格式化的结果：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can easily render the dictionaries held in the `data` attribute into JSON
    with the help of the `rest_framework.renderers.JSONRenderer` class. The following
    lines create an instance of this class and then call the `render` method to render
    the dictionaries held in the `data` attribute into JSON. The code file for the
    sample is included in the `hillar_django_restful_02_01` folder, in the `restful01/toy_serializers_test_01.py`
    file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rest_framework.renderers.JSONRenderer`类轻松地将存储在`data`属性中的字典渲染成JSON格式。以下几行代码创建了这个类的实例，然后调用`render`方法将存储在`data`属性中的字典渲染成JSON。示例代码文件位于`hillar_django_restful_02_01`文件夹中的`restful01/toy_serializers_test_01.py`文件中：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following lines show the output generated from the two calls to the `render`
    method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行代码显示了两次调用`render`方法生成的输出。
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we will work in the opposite direction: from serialized data to the population
    of a `Toy` instance. The following lines generate a new `Toy` instance from a
    JSON string (serialized data), that is, the code deserializes and parses the data.
    The code file for the sample is included in the `hillar_django_restful_02_01`
    folder, in the `restful01/toy_serializers_test_01.py` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将反向操作：从序列化数据到`Toy`实例的集合。以下几行代码从一个JSON字符串（序列化数据）生成一个新的`Toy`实例，即代码反序列化和解析数据。示例代码文件位于`hillar_django_restful_02_01`文件夹中的`restful01/toy_serializers_test_01.py`文件中：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first line creates a new string with the JSON that defines a new toy (`json_string_for_new_toy`).
    The next line converts the string to `bytes` and saves the results of the conversion
    in the `json_bytes_for_new_toy` variable. The `django.utils.six.BytesIO` class
    provides a buffered I/O implementation using an in-memory bytes buffer. The code
    uses this class to create a stream from the previously generated JSON bytes with
    the serialized data, `json_bytes_for_new_toy`, and saves the generated stream
    instance in the `stream_for_new_toy` variable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个新的字符串，其中包含定义新玩具的JSON（`json_string_for_new_toy`）。下一行将字符串转换为`bytes`，并将转换结果保存到`json_bytes_for_new_toy`变量中。`django.utils.six.BytesIO`类提供了一个使用内存中的bytes缓冲区的缓冲I/O实现。代码使用这个类从之前生成的JSON
    bytes和序列化数据`json_bytes_for_new_toy`创建一个流，并将生成的流实例保存到`stream_for_new_toy`变量中。
- en: We can easily deserialize and parse a stream into a Python model with the help
    of the `rest_framework.parsers.JSONParser` class. The next line creates an instance
    of this class and then calls the `parse` method with `stream_for_new_toy` as an
    argument, parses the stream into Python native datatypes, and saves the results
    in the `parsed_new_toy` variable.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rest_framework.parsers.JSONParser`类轻松地将流反序列化和解析成Python模型。下一行代码创建了这个类的实例，然后使用`stream_for_new_toy`作为参数调用`parse`方法，将流解析成Python原生数据类型，并将结果保存到`parsed_new_toy`变量中。
- en: 'After executing the previous lines, `parsed_new_toy` holds a Python dictionary,
    parsed from the stream. The following lines show the output generated after executing
    the preceding code snippet. The next lines show the results with easily understood
    formatting:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，`parsed_new_toy`变量中保存了一个从流中解析出的Python字典。以下几行代码显示了执行前面的代码片段后生成的输出。下一行显示了以易于理解的方式格式化的结果：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following lines use the `ToySerializer` class to generate a fully populated
    `Toy` instance named `toy3` from the Python dictionary, parsed from the stream.
    The code file for the sample is included in the `hillar_django_restful_02_01`
    folder, in the `restful01/toy_serializers_test_01.py` file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行代码使用`ToySerializer`类从流中解析的Python字典生成一个完全填充的`Toy`实例，命名为`toy3`。示例代码文件位于`hillar_django_restful_02_01`文件夹中的`restful01/toy_serializers_test_01.py`文件中：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, the code creates an instance of the `ToySerializer` class with the Python
    dictionary that we previously parsed from the stream (`parsed_new_toy`) passed
    as the `data` keyword argument. Then, the code calls the `is_valid` method to
    check whether the data is valid.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码创建了一个`ToySerializer`类的实例，该实例使用我们从流中之前解析的Python字典（`parsed_new_toy`）作为`data`关键字参数传递。然后，代码调用`is_valid`方法来检查数据是否有效。
- en: Note that we must always call `is_valid` before we attempt to access the serialized
    data representation when we pass a `data` keyword argument in the creation of
    a serializer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在创建序列化器时传递`data`关键字参数并尝试访问序列化数据表示之前，我们必须始终调用`is_valid`。
- en: 'If the method returns `true`, we can access the serialized representation in
    the `data` attribute, and therefore, the code calls the `save` method that persists
    the new instance. In this case, it is a new `Toy` instance, and therefore the
    code to the `save` method inserts the corresponding row in the database and returns
    a fully populated `Toy` instance, saved in the `toy3` local variable. Then, the
    code prints one of the attributes from the fully populated `Toy` instance. After
    executing the previous code, we fully populated a new `Toy` instance: `toy3`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该方法返回`true`，我们可以访问`data`属性中的序列化表示，因此代码调用`save`方法以持久化新实例。在这种情况下，它是一个新的`Toy`实例，因此将相应的行插入数据库并返回一个完全填充的`Toy`实例的代码插入到`save`方法中，然后返回一个完全填充的`Toy`实例，保存在`toy3`局部变量中。然后，代码打印完全填充的`Toy`实例的一个属性。在执行上述代码后，我们完全填充了一个新的`Toy`实例：`toy3`。
- en: As we can see from the previous code, Django REST framework makes it easy to
    serialize from objects to JSON and deserialize from JSON to objects, which are
    core requirements for our RESTful Web Service that has to perform CRUD operations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，Django REST框架使得从对象序列化为JSON以及从JSON反序列化为对象变得容易，这是我们必须执行CRUD操作的RESTful
    Web服务的核心需求。
- en: 'Enter the following command to leave the Django shell with the Django project
    modules that we loaded to test serialization and deserialization:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令以退出Django shell，并加载Django项目模块以测试序列化和反序列化：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Test your knowledge
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'In Django REST framework, serializers are:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Django REST框架中，序列化器是：
- en: Mediators between the view functions and Python primitives
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图函数和Python基本类型之间的中介
- en: Mediators between the URLs and view functions
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL和视图函数之间的中介
- en: Mediators between the model instances and Python primitives
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型实例和Python基本类型之间的中介
- en: 'If we want to create a simple `Toy` model that we will use to represent and
    persist toys in Django REST framework, we can create:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个简单的`Toy`模型，我们将使用它来表示和持久化Django REST框架中的玩具，我们可以创建：
- en: A `Toy` class as a subclass of the `djangorestframework.models.Model` class
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个作为`djangorestframework.models.Model`类子类的`Toy`类
- en: A `Toy` class as a subclass of the `django.db.models.Model` class
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个作为`django.db.models.Model`类子类的`Toy`类
- en: A `Toy` function in the `restframeworkmodels.py` file
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`restframeworkmodels.py`文件中的`Toy`函数'
- en: 'In Django REST framework, parsers and renderers:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Django REST框架中，解析器和渲染器：
- en: Handle as mediators between model instances and Python primitives
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为模型实例和Python基本类型之间的中介进行处理
- en: Handle as mediators between Python primitives and HTTP requests and responses
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为Python基本类型和HTTP请求/响应之间的中介进行处理
- en: Handle as mediators between the view functions and Python primitives.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为视图函数和Python基本类型之间的中介进行处理。
- en: Which of the following commands starts the Django shell?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令启动了Django shell？
- en: '`python manage.py shell`'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`python manage.py shell`'
- en: '`python django.py shell`'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`python django.py shell`'
- en: '`django shell`'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django shell`'
- en: If we have a Django application named `computers` and a model called `memory`,
    what is the name of the table that Django's ORM will create to persist the model
    in the database?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有一个名为`computers`的Django应用程序和一个名为`memory`的模型，Django的ORM将创建什么名字的表来在数据库中持久化该模型？
- en: '`computers_memories`'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`computers_memories`'
- en: '`memory_computers`'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`memory_computers`'
- en: '`computers_memory`'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`computers_memory`'
- en: The rights answers are included in the [Appendix](dj-rst-websvc_ch19.html), *Solutions*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案包含在[附录](dj-rst-websvc_ch19.html)，*解决方案*中。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we designed a RESTful Web Service to interact with a simple
    SQLite database and perform CRUD operations with toys. We defined the requirements
    for our web service and we understood the tasks performed by each HTTP method
    and the different scopes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计了一个RESTful Web服务来与简单的SQLite数据库交互，并使用玩具执行CRUD操作。我们定义了我们的Web服务的需求，并理解了每个HTTP方法执行的任务和不同的范围。
- en: We created a model to represent and persist toys, and we executed migrations
    in Django to create the required tables in an SQLite database. We analyzed the
    tables that Django generated. We learned to manage serialization of toy instances
    into JSON representations with Django REST framework and the reverse process.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个模型来表示和持久化玩具，并在Django中执行迁移以在SQLite数据库中创建所需的表。我们分析了Django生成的表。我们学习了如何使用Django
    REST框架管理玩具实例的序列化为JSON表示以及反向过程。
- en: Now that we understand models, migrations, serialization, and deserialization
    with Django and Django REST framework, we will create Django views combined with
    serializer classes and start making HTTP requests to our web service. We will
    cover these topics in [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Django 和 Django REST framework 中的模型、迁移、序列化和反序列化，我们将创建结合序列化类的 Django
    视图，并开始向我们的网络服务发送 HTTP 请求。我们将在[第 3 章](dj-rst-websvc_ch13.html)，“创建 API 视图”中介绍这些主题。
