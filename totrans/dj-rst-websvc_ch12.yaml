- en: Working with Models, Migrations, Serialization, and Deserialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will define the requirements for our first RESTful Web
    Service. We will start working with Django, Django REST framework, Python, configurations,
    models, migrations, serialization, and deserialization. We will create a RESTful
    Web Service that performs **CRUD** (short for **Create**, **Read**, **Update**
    and **Delete**) operations on a simple SQLite database. We will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the requirements for our first RESTful Web Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our first model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our initial migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Django tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling, serialization, and deserialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Django shell and diving deeply into serialization and deserialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the requirements for our first RESTful Web Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a team of developers working on a mobile app for iOS and Android and
    requires a RESTful Web Service to perform CRUD operations with toys. We definitely
    don't want to use a mock web service and we don't want to spend time choosing
    and configuring an **ORM** (short for **Object-Relational Mapping**). We want
    to quickly build a RESTful Web Service and have it ready as soon as possible to
    start interacting with it in the mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: We really want the toys to persist in a database but we don't need it to be
    production-ready. Therefore, we can use the simplest possible relational database,
    as long as we don't have to spend time performing complex installations or configurations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Django REST framework**, also known as **DRF**, will allow us to easily accomplish
    this task and start making HTTP requests to the first version of our RESTful Web
    Service. In this case, we will work with a very simple SQLite database, the default
    database for a new Django REST framework project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must specify the requirements for our main resource: a toy. We need
    the following attributes or fields for a toy entity:'
  prefs: []
  type: TYPE_NORMAL
- en: An integer identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A toy category description, such as action figures, dolls, or playsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A release date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bool value indicating whether the toy has been on the online store's homepage
    at least once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we want to have a timestamp with the date and time of the toy's
    addition to the database table, which will be generated to persist toys.
  prefs: []
  type: TYPE_NORMAL
- en: In a RESTful Web Service, each resource has its own unique URL. In our web service,
    each toy will have its own unique URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the HTTP verbs, the scope, and the semantics of the
    methods that our first version of the web service must support. Each method is
    composed of an HTTP verb and a scope. All the methods have a well-defined meaning
    for toys and collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  prefs: []
  type: TYPE_TB
- en: '| GET | Toy | Retrieve a single toy |'
  prefs: []
  type: TYPE_TB
- en: '| GET | Collection of toys | Retrieve all the stored toys in the collection,
    sorted by their name in ascending order |'
  prefs: []
  type: TYPE_TB
- en: '| POST | Collection of toys | Create a new toy in the collection |'
  prefs: []
  type: TYPE_TB
- en: '| PUT | Toy | Update an existing toy |'
  prefs: []
  type: TYPE_TB
- en: '| DELETE | Toy | Delete an existing toy |'
  prefs: []
  type: TYPE_TB
- en: 'In the previous table, the GET HTTP verb appears twice but with two different
    scopes: toys and collection of toys. The first row shows a GET HTTP verb applied
    to a toy, that is, to a single resource. The second row shows a GET HTTP verb
    applied to a collection of toys, that is, to a collection of resources.'
  prefs: []
  type: TYPE_NORMAL
- en: We want our web service to be able to differentiate collections from a single
    resource of the collection in the URLs. When we refer to a collection, we will
    use a slash (`/`) as the last character for the URL, as in `http://localhost:8000/toys/`.
    When we refer to a single resource of the collection we won't use a slash (`/`)
    as the last character for the URL, as in `http://localhost:8000/toys/5`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider that `http://localhost:8000/toys/` is the URL for the collection
    of toys. If we add a number to the previous URL, we identify a specific toy with
    an ID or primary key equal to the specified numeric value. For example, `http://localhost:8000/toys/42`
    identifies the toy with an ID equal to `42`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to compose and send an HTTP request with the `POST` HTTP verb and `http://localhost:8000/toys/` request
    URL to create a new toy and add it to the toys collection. In this example, our
    RESTful Web Service will work with **JSON** (short for **JavaScript Object Notation**),
    and therefore we have to provide the JSON key-value pairs with the field names
    and the values to create the new toy. As a result of the request, the server will
    validate the provided values for the fields, make sure that it is a valid toy,
    and persist it in the database. The server will insert a new row with the new
    toy in the appropriate table and it will return a `201 Created` status code and
    a JSON body with the recently added toy serialized to JSON, including the assigned
    ID that was automatically generated by the database and assigned to the toy object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the `GET` HTTP verb and `http://localhost:8000/toys/{id}` request
    URL to retrieve the toy whose ID matches the specified numeric value in `{id}`.
    For example, if we use the request URL `http://localhost:8000/toys/25`, the server
    will retrieve the toy whose ID matches `25`. As a result of the request, the server
    will retrieve a toy with the specified ID from the database and create the appropriate
    toy object in Python. If a toy is found, the server will serialize the toy object
    into JSON, return a `200 OK` status code, and return a JSON body with the serialized
    toy object. If no toy matches the specified ID, the server will return only a
    `404 Not Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the `PUT` HTTP verb and request
    URL `http://localhost:8000/toys/{id}` to retrieve the toy whose ID matches the
    value in `{id}` and replace it with a toy created with the provided data. In addition,
    we have to provide the JSON key-value pairs with the field names and the values
    to create the new toy that will replace the existing one. As a result of the request,
    the server will validate the provided values for the fields, make sure that it
    is a valid toy, and replace the one that matches the specified ID with the new
    one in the database. The ID for the toy will be the same after the update operation.
    The server will update the existing row in the appropriate table and it will return
    a `200 OK` status code and a JSON body with the recently updated toy serialized
    to JSON. If we don''t provide all the necessary data for the new toy, the server
    will return a `400 Bad Request` status code. If the server doesn''t find a toy
    with the specified ID, the server will only return a `404 Not Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the `DELETE `HTTP verb and
    request URL `http://localhost:8000/toys/{id}` to remove the toy whose ID matches
    the specified numeric value in `{id}`. For example, if we use the request URL
    `http://localhost:8000/toys/34`, the server will delete the toy whose ID matches
    `34`. As a result of the request, the server will retrieve a toy with the specified
    ID from the database and create the appropriate toy object in Python. If a toy
    is found, the server will request the ORM delete the toy row associated with this
    toy object and the server will return a `204 No Content` status code. If no toy
    matches the specified ID, the server will return only a `404 Not Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating our first model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create a simple `Toy` model in Django, which we will use to represent
    and persist toys. Open the `toys/models.py` file. The following lines show the
    initial code for this file with just one `import` statement and a comment that
    indicates we should create the models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the new code that creates a `Toy` class, specifically,
    a `Toy` model in the `toys/models.py` file. The code file for the sample is included
    in the `hillar_django_restful_02_01` folder in the `restful01/toys/models.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Toy` class is a subclass of the `django.db.models.Model` class and defines
    the following attributes: `created`, `name`, `description`, `toy_category`, `release_date`, and
    `was_included_in_home`. Each of these attributes represents a database column
    or field.'
  prefs: []
  type: TYPE_NORMAL
- en: Django automatically adds an auto-increment integer primary key column named
    `id` when it creates the database table related to the model. It is very important
    to notice that the model maps the underlying `id` column in an attribute named
    `pk` for the model.
  prefs: []
  type: TYPE_NORMAL
- en: We specified the field types, maximum lengths, and defaults for many attributes.
    The class declares a `Meta` inner class that declares an `ordering` attribute
    and sets its value to a tuple of `string` whose first value is the `'name'` string.
    This way, the inner class indicates to Django that, by default, we want the results
    ordered by the `name` attribute in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Running our initial migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is necessary to create the initial migration for the new `Toy` model
    we recently coded. We will also synchronize the SQLite database for the first
    time. By default, Django uses the popular self-contained and embedded SQLite database,
    and therefore we don't need to make changes in the initial ORM configuration.
    In this example, we will be working with this default configuration. Of course,
    we will upgrade to another database after we have a sample web service built with
    Django. We will only use SQLite for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to run the following Python script in the virtual environment
    that we activated in the previous chapter. Make sure you are in the `restful01`
    folder within the main folder for the virtual environment when you run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that the `restful01/toys/migrations/0001_initial.py` file
    includes the code to create the `Toy` model. The following lines show the code
    for this file that was automatically generated by Django. The code file for the
    sample is included in the `hillar_django_restful_02_01` folder in the `restful01/toys/migrations/0001_initial.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Understanding migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The automatically generated code defines a subclass of the `django.db.migrations.Migration`
    class named `Migration`, which defines an operation that creates the `Toy` model's
    table and includes it in the `operations` attribute. The call to the `migrations.CreateModel`
    method specifies the model's name, the fields, and the options to instruct the
    ORM to create a table that will allow the underlying database to persist the model.
  prefs: []
  type: TYPE_NORMAL
- en: The `fields` argument is a list of tuples that includes information about the
    field name, the field type, and additional attributes based on the data we provided
    in our model, that is, in the `Toy` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following Python script to apply all the generated migrations.
    Make sure you are in the `restful01` folder within the main folder for the virtual
    environment when you run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After we run the previous command, we will notice that the root folder for our
    `restful01` project now has a `db.sqlite3` file that contains the SQLite database.
    We can use the SQLite command line or any other application that allows us to
    easily check the contents of the SQLite database to check the tables that Django
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: The first migration will generate many tables required by Django and its installed
    apps before running the code that creates the table for the `Toys` model. These
    tables provide support for user authentication, permissions, groups, logs, and
    migration management. We will work with the models related to these tables after
    we add more features and security to our web services.
  prefs: []
  type: TYPE_NORMAL
- en: After the migration process creates all these Django tables in the underlying
    database, the first migration runs the Python code that creates the table required
    to persist our model. Thus, the last line of the running migrations section displays
    `Applying toys.0001_initial`.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most modern Linux distributions and macOS, SQLite is already installed, and
    therefore you can run the `sqlite3` command-line utility.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, if you want to work with the `sqlite3.exe` command-line utility,
    you have to download the bundle of command-line tools for managing SQLite database
    files from the downloads section of the SQLite webpage at [http://www.sqlite.org/download.html](http://www.sqlite.org/download.html).
    For example, the ZIP file that includes the command-line tools for version 3.20.1
    is `sqlite-tools-win32-x8 6-3200100.zip`. The name for the file changes with the
    SQLite version. You just need to make sure that you download the bundle of command-line
    tools and not the ZIP file that provides the SQLite DLLs. After you unzip the
    file, you can include the folder that includes the command-line tools in the PATH
    environment variable, or you can access the `sqlite3.exe` command-line utility
    by specifying the full path to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to list the generated tables. The first argument,
    `db.sqlite3`, specifies the file that contains that SQLite database and the second
    argument indicates the command that we want the `sqlite3` command-line utility
    to run against the specified database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output for the previous command with the list
    of tables that Django generated in the SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will allow you to check the contents of the `toys_toy`
    table after we compose and send HTTP requests to the RESTful Web Service and the
    web service makes CRUD operations to the `toys_toy` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Instead of working with the SQLite command-line utility, you can use a GUI tool
    to check the contents of the SQLite database. DB Browser for SQLite is a useful,
    free, multiplatform GUI tool that allows us to easily check the database contents
    of an SQLite database in Linux, macOS, and Windows. You can read more information
    about this tool and download its different versions from [http://sqlitebrowser.org](http://sqlitebrowser.org).
    Once you have installed the tool, you just need to open the `db.sqlite3` file
    and you can check the database structure and browse the data for the different
    tables. After we start working with the first version of our web service, you
    need to check the contents of the `toys_toy` table with this tool.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the database tools included with your favorite IDE to check
    the contents of the SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLite database engine and the database file name are specified in the
    `restful01/settings.py` Python file. The following lines show the declaration
    of the DATABASES dictionary, which contains the settings for all the databases
    that Django uses. The nested dictionary maps the database named `default` with
    the `django.db.backends.sqlite3` database engine and the `db.sqlite3` database
    file located in the `BASE_DIR` folder (`restful01`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After we execute the migrations, the SQLite database will have the following
    tables. Django uses prefixes to identify the modules and applications that each
    table belongs to. The tables that start with the `auth_` prefix belong to the
    Django authentication module. The table that starts with the `toys_` prefix belongs
    to our `toys` application. If we add more models to our `toys` application, Django
    will create new tables with the `toys_` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`auth_group`: Stores authentication groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth_group_permissions`: Stores permissions for authentication groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth_permission`: Stores permissions for authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth_user`: Stores authentication users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth_user_groups`: Stores authentication user groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth_user_groups_permissions`: Stores permissions for authentication user
    groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django_admin_log`: Stores the Django administrator log'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django_content_type`: Stores Django content types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django_migrations`: Stores the scripts generated by Django migrations and
    the date and time at which they were applied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django_session`: Stores Django sessions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toys_toy`: Persists the `Toys` model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite_sequence`: Stores sequences for SQLite primary keys with autoincrement
    fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the table generated by Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `toys_toy` table persists in the database the `Toy` class we recently created,
    specifically, the `Toy` model. Django's integrated ORM generated the `toys_toy`
    table based on our `Toy` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to retrieve the SQL used to create the `toys_toy`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output for the previous command together with
    the SQL that the migrations process executed, to create the `toys_toy` table that
    persists the `Toy` model. The next lines are formatted to make it easier to understand
    the SQL code. Notice that the output from the command is formatted in a different
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toys_toy` table has the following columns (also known as fields) with
    their SQLite types, all of them not nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: The integer primary key, an autoincrement row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`: DateTime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: varchar(150)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: varchar(250)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toy_category`: varchar(200)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`release_date`: DateTime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`was_included_in_home`: bool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling, serialization, and deserialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our RESTful Web Service has to be able to serialize and deserialize the `Toy`
    instances into JSON representations. In Django REST framework, we just need to
    create a serializer class for the `Toy` instances to manage serialization to JSON
    and deserialization from JSON. Now, we will dive deep into the serialization and
    deserialization process in Django REST framework. It is very important to understand
    how it works because it is one of the most important components for all the RESTful
    Web Services we will build.
  prefs: []
  type: TYPE_NORMAL
- en: Django REST framework uses a two-phase process for serialization. The serializers
    are mediators between the model instances and Python primitives. Parser and renderers
    handle as mediators between Python primitives and HTTP requests and responses.
    We will configure our mediator between the `Toy` model instances and Python primitives
    by creating a subclass of the `rest_framework.serializers.Serializer` class to
    declare the fields and the necessary methods to manage serialization and deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: We will repeat some of the information about the fields that we have included
    in the `Toy` model so that we understand all the things that we can configure
    in a subclass of the `Serializer` class. However, we will work with shortcuts,
    which will reduce boilerplate code later in the following examples. We will write
    less code in the following examples by using the `ModelSerializer` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to the `restful01/toys` folder and create a new Python code file named
    `serializers.py`. The following lines show the code that declares the new `ToySerializer`
    class. The code file for the sample is included in the `hillar_django_restful_02_01`
    folder in the `restful01/toys/``serializers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `ToySerializer` class declares the attributes that represent the fields
    that we want to be serialized. Notice that we have omitted the `created` attribute
    that was present in the `Toy` model. When there is a call to the `save` method
    that `ToySerializer` inherits from the `serializers.Serializer` superclass, the
    overridden `create` and `update` methods define how to create a new instance or
    update an existing instance. In fact, these methods must be implemented in our
    class because they only raise a `NotImplementedError` exception in their base
    declaration in the `serializers.Serializer` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The `create` method receives the validated data in the `validated_data` argument.
    The code creates and returns a new `Toy` instance based on the received validated
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The `update` method receives an existing `Toy` instance that is being updated
    and the new validated data in the `instance` and `validated_data` arguments. The
    code updates the values for the attributes of the instance with the updated attribute
    values retrieved from the validated data. Finally, the code calls the `save` method
    for the updated `Toy` instance and returns the updated and saved instance.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Django shell and diving deeply into serialization and deserialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can launch our default Python interactive shell in our virtual environment
    and make all the Django project modules available before it starts. This way,
    we can check that the serializer works as expected. We will do this to understand
    how serialization works in Django.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to launch the interactive shell. Make sure you are
    within the `restful01` folder in the terminal, Command Prompt, or Windows Powershell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice a line that says `(InteractiveConsole)` is displayed after
    the usual lines that introduce your default Python interactive shell. The following
    screenshot shows the Django shell launched in a Windows command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9ec6e74-4bbd-4c0a-9178-4c81bd2d1b33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the following code in the Python interactive shell to import all the
    things we will need to test the `Toy` model and its serializer. The code file
    for the sample is included in the `hillar_django_restful_02_01` folder, in the
    `restful01/toy_serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code to create two instances of the `Toy` model and save
    them. The code file for the sample is included in the `hillar_django_restful_02_01`
    folder, in the `restful01/toy_serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After we execute the preceding code, we can check the SQLite database with the
    previously introduced command-line or GUI tools to check the contents of the `toys_toy`
    table. We will notice the table has two rows and columns with the values we have
    provided to the different attributes of the `Toy` instances. The following screenshot
    shows the results of browsing the data of the `toys_toy` table with the DB Browser
    for SQLite GUI utility. We can see that two rows were inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in the interactive shell to check the values for the
    primary keys or identifiers for the saved `Toy` instances, and the value of their
    `name` and `was_included_in_home_attribute` attributes. The code also checks the
    value of the `created` attribute, which includes the date and time at which Django
    saved each instance to the database. The code file for the sample is included
    in the `hillar_django_restful_02_01` folder, in the `restful01/toy_serializers_test_01.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows sample results of the previously shown code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c6597cc-6372-4109-9ce0-0103b525bd4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s write the following code to serialize the first `Toy` instance
    (`toy1`). The code file for the sample is included in the `hillar_django_restful_02_01`
    folder, in the `restful01/toy_serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the generated dictionary, specifically, a `rest_framework.utils.serializer_helpers.ReturnDict`
    instance, stored in the `serializer_for_toy1.data` attribute. The next lines show
    the results with easily understood formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s serialize the second `Toy` instance (`toy2`). The code file for
    the sample is included in the `hillar_django_restful_02_01` folder, in the `restful01/toy_serializers_test_01.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the generated dictionary stored in the `serializer_for_toy2.data`
    attribute. The next lines show the results with easily understood formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily render the dictionaries held in the `data` attribute into JSON
    with the help of the `rest_framework.renderers.JSONRenderer` class. The following
    lines create an instance of this class and then call the `render` method to render
    the dictionaries held in the `data` attribute into JSON. The code file for the
    sample is included in the `hillar_django_restful_02_01` folder, in the `restful01/toy_serializers_test_01.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated from the two calls to the `render`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will work in the opposite direction: from serialized data to the population
    of a `Toy` instance. The following lines generate a new `Toy` instance from a
    JSON string (serialized data), that is, the code deserializes and parses the data.
    The code file for the sample is included in the `hillar_django_restful_02_01`
    folder, in the `restful01/toy_serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a new string with the JSON that defines a new toy (`json_string_for_new_toy`).
    The next line converts the string to `bytes` and saves the results of the conversion
    in the `json_bytes_for_new_toy` variable. The `django.utils.six.BytesIO` class
    provides a buffered I/O implementation using an in-memory bytes buffer. The code
    uses this class to create a stream from the previously generated JSON bytes with
    the serialized data, `json_bytes_for_new_toy`, and saves the generated stream
    instance in the `stream_for_new_toy` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily deserialize and parse a stream into a Python model with the help
    of the `rest_framework.parsers.JSONParser` class. The next line creates an instance
    of this class and then calls the `parse` method with `stream_for_new_toy` as an
    argument, parses the stream into Python native datatypes, and saves the results
    in the `parsed_new_toy` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the previous lines, `parsed_new_toy` holds a Python dictionary,
    parsed from the stream. The following lines show the output generated after executing
    the preceding code snippet. The next lines show the results with easily understood
    formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines use the `ToySerializer` class to generate a fully populated
    `Toy` instance named `toy3` from the Python dictionary, parsed from the stream.
    The code file for the sample is included in the `hillar_django_restful_02_01`
    folder, in the `restful01/toy_serializers_test_01.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: First, the code creates an instance of the `ToySerializer` class with the Python
    dictionary that we previously parsed from the stream (`parsed_new_toy`) passed
    as the `data` keyword argument. Then, the code calls the `is_valid` method to
    check whether the data is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we must always call `is_valid` before we attempt to access the serialized
    data representation when we pass a `data` keyword argument in the creation of
    a serializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the method returns `true`, we can access the serialized representation in
    the `data` attribute, and therefore, the code calls the `save` method that persists
    the new instance. In this case, it is a new `Toy` instance, and therefore the
    code to the `save` method inserts the corresponding row in the database and returns
    a fully populated `Toy` instance, saved in the `toy3` local variable. Then, the
    code prints one of the attributes from the fully populated `Toy` instance. After
    executing the previous code, we fully populated a new `Toy` instance: `toy3`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the previous code, Django REST framework makes it easy to
    serialize from objects to JSON and deserialize from JSON to objects, which are
    core requirements for our RESTful Web Service that has to perform CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command to leave the Django shell with the Django project
    modules that we loaded to test serialization and deserialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Django REST framework, serializers are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mediators between the view functions and Python primitives
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mediators between the URLs and view functions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mediators between the model instances and Python primitives
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we want to create a simple `Toy` model that we will use to represent and
    persist toys in Django REST framework, we can create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Toy` class as a subclass of the `djangorestframework.models.Model` class
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Toy` class as a subclass of the `django.db.models.Model` class
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Toy` function in the `restframeworkmodels.py` file
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Django REST framework, parsers and renderers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle as mediators between model instances and Python primitives
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle as mediators between Python primitives and HTTP requests and responses
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle as mediators between the view functions and Python primitives.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following commands starts the Django shell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`python manage.py shell`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`python django.py shell`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django shell`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have a Django application named `computers` and a model called `memory`,
    what is the name of the table that Django's ORM will create to persist the model
    in the database?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`computers_memories`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`memory_computers`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`computers_memory`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The rights answers are included in the [Appendix](dj-rst-websvc_ch19.html), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we designed a RESTful Web Service to interact with a simple
    SQLite database and perform CRUD operations with toys. We defined the requirements
    for our web service and we understood the tasks performed by each HTTP method
    and the different scopes.
  prefs: []
  type: TYPE_NORMAL
- en: We created a model to represent and persist toys, and we executed migrations
    in Django to create the required tables in an SQLite database. We analyzed the
    tables that Django generated. We learned to manage serialization of toy instances
    into JSON representations with Django REST framework and the reverse process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand models, migrations, serialization, and deserialization
    with Django and Django REST framework, we will create Django views combined with
    serializer classes and start making HTTP requests to our web service. We will
    cover these topics in [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*.
  prefs: []
  type: TYPE_NORMAL
