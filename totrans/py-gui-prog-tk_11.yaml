- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Automated Tests with unittest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the size and complexity of your application rapidly expanding, you've become
    nervous about making changes. What if you break something? How will you know?
    You can, of course, run through all the features of the program manually with
    various input and watch for errors, but this approach gets harder and more time
    consuming as you add more features. What you really need is a fast and reliable
    way to make sure your program is working properly whenever you make a code change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a way: automated testing. In this chapter, you''ll learn
    about automated testing in the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Automated testing basics*, you'll discover the fundamentals of automated
    testing in Python using `unittest`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Testing Tkinter code*, we'll discuss specific strategies for testing Tkinter
    applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Writing tests for our application*, we'll apply this knowledge to the ABQ
    Data Entry application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated testing basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, testing our application has been a process of launching it, running
    it through a few basic procedures, and verifying that it did what we expected
    it to do. This approach works acceptably on a very small script, but, as our application
    grows, it becomes an increasingly time-consuming and error-prone process to verify
    the application's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Using automated testing, we can consistently verify our application logic within
    seconds. There are several forms of automated testing, but the two most common
    are **unit testing** and **integration testing**. Unit tests work with discrete
    pieces of code in isolation, allowing us to quickly verify the behavior of specific
    sections. Integration tests verify the interactions of multiple units of code.
    We'll be writing both kinds of tests to verify the behavior of our application.
  prefs: []
  type: TYPE_NORMAL
- en: A simple unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At its most basic, a unit test is just a short program that runs a unit of code
    under different conditions and compares its output against expected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following calculation class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This class is initialized with two numbers on which it can subsequently perform
    a variety of mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to write some code to test if this class works as it should.
    A naive approach might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This test code creates a `MyCalc` object and then uses `assert` statements to
    check the output of `add()` and `mod_divide()` against expected values. The `assert`
    keyword in Python is a special statement that raises an `AssertionError` exception
    if the expression that follows it evaluates to `False`. The message string after
    the comma is the error string that will be passed to the `AssertionError` exception's
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the statement `assert expression, "message"` is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, all tests pass if you run the test script for `MyCalc`. Let''s try
    changing the `add()` method to make it fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, running the test gives this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the value of such tests? With such a simple function, it seems pointless.
    But suppose someone decides to refactor our `mod_divide()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method is a little more complex, and you may or may not be familiar with
    all the operators involved. However, since this passes our tests, we have some
    evidence that this algorithm is correct, even if we didn't completely understand
    the code. If there were a problem with the refactor, our tests could help us identify
    the problem quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing pure mathematical functions is fairly simple; unfortunately, testing
    real application code presents us with some challenges that demand a more sophisticated
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Code units often rely on a pre-existing state that must be set up before the
    test and cleared up afterward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code may have side effects that change objects outside the code unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code may interact with resources that are slow, unreliable, or unpredictable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real applications contain many functions and classes that require testing, and
    ideally we'd like to be alerted to all problems at once. Our test script, as written,
    would stop on the first failed assertion, so we'd only get alerted to one problem
    at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To address these issues and others, programmers rely on **testing frameworks**
    to make writing and executing automated tests as simple, efficient, and reliable
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The unittest module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `unittest` module is the Python standard library''s automated testing framework.
    It provides us with some powerful tools to make testing our code reasonably easy,
    and is based on some standard unit testing concepts found in many test frameworks.
    These concepts include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test**: A test is a single method that will either finish or raise an exception.
    Tests generally focus on one unit of code, such as a function, method, or process.
    A test can either pass, meaning the test was successful; fail, meaning the code
    failed the test; or error, meaning the test itself encountered a problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test case**: A test case is a collection of tests that should be run together
    and contain similar setup and tear-down requirements, typically corresponding
    to a class or module. Test cases can have **fixtures**, which are items that need
    to be set up before each test and torn down after each test to provide a clean,
    predictable environment in which the test can run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test suite**: A test suite is a collection of test cases that cover all the
    code for an application or module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mock**: A mock is an object that stands in for another object. Typically,
    they''re used to replace an external resource, such as a file, database, or library
    module. Mocks are patched over those resources during the test to provide a fast
    and predictable stand-in with no side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To explore these concepts in depth, let's test our `MyCalc` class using `unittest`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a test case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a test case for the `MyCalc` class. Create a new file called
    `test_mycalc.py`, and enter this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The names of both your test modules and your test methods should be prefixed
    with `test_`. Doing so allows the `unittest` runner to automatically find test
    modules and distinguish test methods from other methods in your test case classes.
  prefs: []
  type: TYPE_NORMAL
- en: As you probably guessed, the `TestCase` class represents a test case. To make
    our test case for `MyCalc`, we have subclassed `TestCase` and added a `test_`
    method that will test some aspect of our class. Inside the `test_add()` method,
    we created a `MyCalc` object, then made an assertion about the output of `add()`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the file, we've added a call to `unittest.main()`, which will
    cause all test cases in the file to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run your test file at the command line, you should get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The single dot on the first line represents our one test (`test_add()`). For
    each test method, `unittest.main()` will output one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A dot, which means the test passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F`, which means it failed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E`, meaning the test caused an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end, we get a summary of what happened, including the number of tests
    run and how long it took. The `OK` indicates that all tests passed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what happens when a test fails, let''s alter our test so that it intentionally
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you run the test module, you should see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note the single `F` at the top, representing our failed test. After all the
    tests have run, we get the full traceback of any failed tests, so that we can
    easily locate the failing code and correct it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This traceback output isn''t very ideal, though; we can see that `mc.add()`
    didn''t return `12`, but we don''t know what it *did* return. We could add a comment
    string to our `assert` call, but `unittest` provides a nicer approach: `TestCase`
    assertion methods.'
  prefs: []
  type: TYPE_NORMAL
- en: TestCase assertion methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TestCase` objects have a number of assertion methods that provide a cleaner
    and more robust way to run various tests on our code output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there is the `TestCase.assertEqual()` method to test equality,
    which we can use as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our test case with this code, you can see that the traceback is
    improved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see the value that `mc.add()` returned, which is much more helpful
    for debugging. `TestCase` contains more than 20 assertion methods that can simplify
    testing for a variety of conditions such as class inheritance, raised exceptions,
    and sequence membership.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more commonly used ones are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Tests |'
  prefs: []
  type: TYPE_TB
- en: '| `assertEqual(a`, `b)` | `a` `==` `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertTrue(a)` | `a` `is` `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertFalse(a)` | `a` `is` `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertIn(item`, `sequence)` | `item` `in` `sequence` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertRaises(exception`, `callable`, `*args)` | `callable` raises `exception`
    when called with `args` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertGreater(a`, `b)` | `a` is greater than `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertLess(a`, `b)` | `a` is less than `b` |'
  prefs: []
  type: TYPE_TB
- en: A full list of the available assertion methods can be found in the `unittest`
    documentation at [https://docs.python.org/3/library/unittest.html#unittest.TestCase](https://docs.python.org/3/library/unittest.html#unittest.TestCase).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use an assertion method to test that `mod_divide()` raises a `ValueError`
    exception when `b` is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`assertRaises()` *passes* if the function raises the given exception when called.
    If we need to pass any arguments into the tested function, they can be specified
    as additional arguments to `assertRaises()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertRaises()` can also be used as a context manager like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code accomplishes the exact same thing, but is a little clearer and more
    flexible, since it allows us to put multiple lines of code in the block.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily add your own custom assertion methods to your test case as well;
    it's simply a matter of creating a method that raises an `AssertionError` exception
    under some condition.
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be clear that each test in our test case is going to need access to
    a `MyCalc` object. It would be nice if we didn't have to do this manually in each
    test method. To help us avoid this tedious task, the `TestCase` object offers
    a `setUp()` method. This method is run before every test case is run, and by overriding
    it we can take care of any setup that needs to be done for each test.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use it to create `MyCalc` objects, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, every test case can use these objects to run its tests rather than creating
    their own. Understand that the `setUp()` method will be rerun before *every* test,
    so these objects will always be reset between test methods. If we have items that
    need to be cleaned up after each test, we can override the `tearDown()` method
    as well, which is run after each test (in this case, it's not necessary).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a `setUp()` method, our `test_add()` method can be much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the instance methods `setUp()` and `tearDown()`, `TestCase` also
    has class methods for setup and tear-down of the object itself as well; these
    are `setUpClass()` and `tearDownClass()`. These two methods can be used for slower
    operations that can be run when the test case is created and destroyed, rather
    than needing to be refreshed between each test; for example, you might use them
    to create complex objects that are required for your tests, but won't be altered
    by any of them.
  prefs: []
  type: TYPE_NORMAL
- en: Using Mock and patch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MyCalc.rand_between()` method generates a random number between `a` and
    `b`. Because we can't possibly predict its output, we can't provide a fixed value
    to test it against. How can we test this method?
  prefs: []
  type: TYPE_NORMAL
- en: 'A naive approach might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This test passes if our code is correct, but it doesn't necessarily fail if
    the code is wrong; in fact, if the code is wrong, it may pass or fail unpredictably
    since the return value of `rand_between()` is random. For example, if `MyCalc(1,10).rand_between()`
    was incorrectly returning values between 2 and 11, the test would pass if it returned
    2 through 10, and only fail if it returned 11\. Thus, even though the code is
    wrong, there would be only a 10% chance that the test would fail on each run of
    the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of our tests, we can safely assume that a standard library
    function such as `random()` works correctly; so our unit test should really test
    whether *our* method correctly handles the number provided to it by `random()`.
    If we could temporarily replace `random()` with a function that returns a predictable
    fixed value, it would be simple to test the correctness of our subsequent calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The `unittest.mock` module provides us with the `Mock` class for this purpose.
    `Mock` objects can be used to predictably simulate the behavior of another class,
    method, or library. We can give our `Mock` objects return values, side effects,
    properties, methods, and other features needed to fake the behavior of another
    class, object, function, or module, then drop them in place before running our
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, let''s create a fake `random()` function using `Mock`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Mock` object's `return_value` argument allows us to hard-code a value to
    be returned whenever it's called as a function. Here, our mock object `fakerandom`
    will behave like a function that always returns `0.5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can put `fakerandom` in place of `random()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We start by saving a reference to `mycalc.random.random` before replacing it.
    Note that we're specifically replacing *only* the version of `random` being used
    in `mycalc.py` so that we don't affect calls to `random()` anywhere else. It's
    a best practice to be as specific as possible when patching libraries to avoid
    unforeseen side effects.
  prefs: []
  type: TYPE_NORMAL
- en: With `fakerandom` in place, we can call `rand_between()` and test the output.
    Because `fakerandom()` will always return `0.5`, we know that the answer when
    `a` is `1` and `b` is `0` should be `(0.5 × 1 + 0) = 0.5`. Any other value would
    indicate an error in our algorithm. At the end of the test code, we revert `random`
    to the original standard library function so that other tests (or the classes
    or functions they call) don't accidentally use the mock.
  prefs: []
  type: TYPE_NORMAL
- en: Having to store or revert the original library each time is an annoyance we
    can do without, so `unittest.mock` provides a cleaner approach using `patch()`.
    The `patch()` function can be used as either a context manager or a decorator,
    and either approach makes patching a `Mock` object into our code much cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swapping in `fakerandom()` using `patch()` as a context manager looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `patch()` command takes an import path string and provides us with a new
    `Mock` object that it has patched in place of the object at that path. Inside
    the context manager block, we can set methods and properties on the `Mock` object,
    then run our actual tests. The patched function will be reverted to its original
    version when the block ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `patch()` as a decorator is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `Mock` object created by `patch()` is passed as an argument
    to our test method and will remain patched for the duration of the decorated function.
    This approach works well if we plan to use the mock multiple times in a test method.
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we can run our unit tests by including a call to `unittest.main()` at
    the end of the file, that approach doesn't scale well. As our application grows,
    we're going to write many test files, which we'll want to run in groups or all
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, `unittest` can discover and run all tests in a project with one
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So long as you have followed the recommended naming scheme of prefixing your
    test modules with `test_`, running this command in your project's root directory
    should run all your test scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Tkinter code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Tkinter code presents us with a few particular challenges. First, Tkinter
    handles many callbacks and methods asynchronously, meaning that we can't count
    on the results of some code to be apparent immediately. Also, testing GUI behaviors
    often relies on external factors such as window management or visual cues that
    our tests cannot detect.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to learn some tools and strategies to address these
    issues and help you craft tests for your Tkinter code.
  prefs: []
  type: TYPE_NORMAL
- en: Managing asynchronous code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you interact with a Tkinter UI – whether it's clicking a button, typing
    in a field, or raising a window, for example – the response is not executed immediately
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, these actions are placed in a sort of to-do list, called an **event
    queue**, to be handled later while code execution continues. While these actions
    seem instant to users, test code cannot count on a requested action being completed
    before the next line of code is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, Tkinter widgets have some methods that allow us to manage
    the event queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wait_visibility()`: This method causes the code to wait until a widget is
    fully drawn on-screen before executing the next line of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_idletasks()`: This method forces Tkinter to process any idle tasks
    currently outstanding on the widget. Idle tasks are low-priority tasks such as
    drawing and rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()`: This method forces Tkinter to process all events that are outstanding
    on a widget, including calling callbacks, redraws, and geometry management. It
    includes everything that `update_idletasks()` does and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event queue will be discussed in more detail in *Chapter 14*, *Asynchronous
    Programming with Thread and Queue*.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating user actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When automating GUI tests, we may wish to know what happens when a user clicks
    on a certain widget, or types a certain keystroke. When these actions happen in
    the GUI, Tkinter generates an `Event` object for the widget and passes it to the
    event queue. We can do the same thing in code, using a widget's `event_generate()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying an event sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we learned in *Chapter 6*, *Planning for the Expansion of Our Application*,
    we can cause an event to be registered on a widget by passing an event **sequence
    string** to `event_generate()` in the format `<EventModifier-EventType-EventDetail>`.
    Let's look at sequence strings in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The core part of a sequence string is the **event type**. It specifies the kind
    of event we're sending, such as a keystroke, mouse click, windowing event, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter has around 30 event types, but you will typically only need to work
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event types | Action represented |'
  prefs: []
  type: TYPE_TB
- en: '| `ButtonPress` or `Button` | Mouse-button click |'
  prefs: []
  type: TYPE_TB
- en: '| `ButtonRelease` | Lifting off a mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyPress` or `Key` | Pressing a keyboard key |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyRelease` | Lifting off a keyboard key |'
  prefs: []
  type: TYPE_TB
- en: '| `FocusIn` | Giving focus to a widget, such as a button or input widget |'
  prefs: []
  type: TYPE_TB
- en: '| `FocusOut` | Exiting a focused widget |'
  prefs: []
  type: TYPE_TB
- en: '| `Enter` | The mouse cursor entering a widget |'
  prefs: []
  type: TYPE_TB
- en: '| `Leave` | The mouse cursor moving off a widget |'
  prefs: []
  type: TYPE_TB
- en: '| `Configure` | A change in the widget''s configuration, for example, a `config()`
    call, or the user resizing the window, and so on |'
  prefs: []
  type: TYPE_TB
- en: '**Event modifiers** are optional words that can alter the event type; for example,
    `Control`, `Alt`, and `Shift` can be used to indicate that one of those modifier
    keys is held down; `Double` or `Triple` can be used with `Button` to indicate
    a double- or triple-click of the described button. Multiple modifiers can be strung
    together if required.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event detail**, only valid for keyboard or mouse events, describes which
    key or button was pressed. For example, `<Button-1>` refers to the left mouse
    button, while `<Button-3>` refers to the right. For letter and number keys, the
    literal letter or number can be used, such as `<Control-KeyPress-a>`; most symbols,
    however, are described by a word (`minus`, `colon`, `semicolon`, and so on) to
    avoid syntactic clashes.'
  prefs: []
  type: TYPE_NORMAL
- en: For button presses and keypresses, the event type is technically optional; for
    example, you could use `<Control-a>` instead of `<Control-KeyPress-a>`. However,
    it's probably a good idea to leave it in for the sake of clarity. For example,
    `<1>` is a valid event, but does it refer to pressing the left mouse button or
    the 1 key? You may be surprised to find that it's the mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some examples of valid event sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Sequence | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `<Double-Button-3>` | Double-clicking the right mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `<Alt-KeyPress-exclam>` | Holding Alt and typing an exclamation point |'
  prefs: []
  type: TYPE_TB
- en: '| `<Control-Alt-Key-m>` | Holding Control and Alt and pressing the M key |'
  prefs: []
  type: TYPE_TB
- en: '| `<KeyRelease-minus>` | Lifting off a pressed minus key |'
  prefs: []
  type: TYPE_TB
- en: In addition to the sequence, we can pass other arguments to `event_generate()`
    that describe various aspects of the event. Many of these are redundant, but,
    in some cases, we need to provide extra information for the event to have any
    meaning; for example, mouse button events need to include an `x` and a `y` argument
    that specify the coordinates of the click.
  prefs: []
  type: TYPE_NORMAL
- en: Single brackets around a sequence indicate a built-in event type. Double brackets
    are used for custom events, such as those we have been using in our main menu
    and elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Managing focus and grab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Focus** refers to the widget or window that is currently receiving keyboard
    input. Widgets can also **grab focus**, preventing mouse movements or keystrokes
    outside their bounds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter gives us these widget methods for managing focus and grab, some of
    which are useful for running tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `focus_set()` | Focuses the widget whenever its window next gains focus |'
  prefs: []
  type: TYPE_TB
- en: '| `focus_force()` | Focuses a widget and the window it''s in, immediately |'
  prefs: []
  type: TYPE_TB
- en: '| `grab_set()` | The widget grabs all events for the application |'
  prefs: []
  type: TYPE_TB
- en: '| `grab_set_global()` | The widget grabs all screen events |'
  prefs: []
  type: TYPE_TB
- en: '| `grab_release()` | The widget relinquishes its grab |'
  prefs: []
  type: TYPE_TB
- en: In a test environment, we can use these methods to make sure that our generated
    keyboard and mouse events are going to the correct widget or window.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time the `focus_set()` method will be adequate, but depending on
    the behavior of your application and your operating system's windowing environment,
    you may need the more extreme enforcement of `focus_force()` or `grab_set()`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting widget information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tkinter widgets have a set of `winfo_` methods that give us access to information
    about the widget. While the available functionality leaves much to be desired,
    these methods include some information we can use in tests to provide feedback
    about the state of a given widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few `winfo_` methods that we will find useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `winfo_height()`, `winfo_width()` | Get the height and width of the widget
    |'
  prefs: []
  type: TYPE_TB
- en: '| `winfo_children()` | Get a list of child widgets |'
  prefs: []
  type: TYPE_TB
- en: '| `winfo_geometry()` | Get the size and location of the widget |'
  prefs: []
  type: TYPE_TB
- en: '| `winfo_ismapped()` | Determine whether the widget is mapped (that is, it''s
    been added to a layout using a geometry manager) |'
  prefs: []
  type: TYPE_TB
- en: '| `winfo_viewable()` | Determine whether a widget is viewable (that is, it
    and all its parents have been mapped) |'
  prefs: []
  type: TYPE_TB
- en: '| `winfo_x()`, `winfo_y()` | Get the *x* or *y* coordinate of the widget''s
    top-left corner |'
  prefs: []
  type: TYPE_TB
- en: Writing tests for our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's put our knowledge of `unittest` and Tkinter to work and write some automated
    tests for our application. To get started, we need to create a test module. Make
    a directory called `test` inside the `abq_data_entry` package, and create the
    customary empty `__init__.py` file inside. We'll create all of our test modules
    inside this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the data model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `CSVModel` class is fairly self-contained apart from its need to read and
    write files. We'll need to mock out this functionality so that the tests don't
    disturb the filesystem. Since file operations are one of the more common things
    that need to be mocked out in a test, the `mock` module provides `mock_open()`,
    a `Mock` subclass ready-made to replace Python's `open()` method. When called,
    a `mock_open` object returns a mock file handle object, complete with support
    for the `read()`, `write()`, and `readlines()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in the `test` directory called `test_models.py`. This will
    be our test module for our data model classes. Begin it with some module imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the `models` module, we'll need `TestCase` and `mock`, of course,
    as well as the `Path` class since our `CSVModel` works with `Path` objects internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll begin a test case for the `CSVModel` class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the `setUp()` method for this case, we've created two mocked data files.
    The first contains a CSV header and two rows of CSV data, while the second is
    empty. The `mock_open` object's `read_data` argument allows us to specify a string
    that will be returned when code attempts to read data from it.
  prefs: []
  type: TYPE_NORMAL
- en: We've also created two `CSVModel` objects, one with a filename of `file1` and
    the other with a filename of `file2`. It's worth mentioning that there's no actual
    connection between our models and our `mock_open` objects; the filenames given
    are arbitrary, since we won't actually be opening a file, and the choice of which
    `mock_open` object we use will be made in our test methods using `patch()`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing file reading in get_all_records()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see how we use these, let''s start a test for the `get_all_records()` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since our filenames don't actually exist, we're using the decorator version
    of `patch()` to replace `Path.exists()` with a mock function that always returns
    `True`. We can later change the `return_value` value property of this object if
    we want to test a scenario where the file doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the `get_all_records()` method against one of our `mock_open` objects,
    we''ll use the context manager form of `patch()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Any call to `open()` in `models.py` initiated by code inside this context manager
    block will be replaced by our `mock_open` object, and the file handle returned
    will contain the `read_data` string we specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start making assertions about the records that have been returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're checking that `records` contains two lines (since our read data
    contained two CSV records), that it's a `list` object, and that its first member
    is a `dict` object (or a subclass of `dict`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s make sure all our fields made it through and that our Boolean
    conversion worked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By iterating over a tuple of all our field names, we can check that all our
    fields are present in the record output. Don't be afraid to use loops in a test
    this way to check a large amount of content quickly.
  prefs: []
  type: TYPE_NORMAL
- en: A `Mock` object can do more than just stand in for another class or function;
    it also has its own assertion methods that can tell us if it's been called, how
    many times, and with what arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can check our `mock_open` object to make sure it was called
    with the expected arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`assert_called_with()` takes any number of positional and keyword arguments
    and checks if the last call to the mock object included those exact arguments.
    We expected `file1_open()` to be called with a `Path` object containing the filename
    `file1`, a mode of `r`, a `newline` set to a blank string, and an `encoding` value
    of `utf-8`. By confirming that a mocked function was called with the correct arguments,
    and assuming the correctness of the real function (the built-in `open()` function,
    in this case), we can avoid having to test the actual outcome.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the order in which the keyword arguments are passed does not matter
    for this method.
  prefs: []
  type: TYPE_NORMAL
- en: Testing file saving in save_record()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate how to test file-writing with `mock_open`, let''s test `save_record()`.
    Begin by creating a test method that defines some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This method begins by once again mocking `Path.exists` and creating a dictionary
    of data, and the same data represented as a row of CSV data.
  prefs: []
  type: TYPE_NORMAL
- en: You may be tempted to generate either the record or its expected CSV output
    using code, but it's always better to stick to literal values in tests; doing
    so makes the expectations of the test explicit and avoids logic errors in your
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for our first test scenario, let''s simulate writing to an empty but existing
    file by using `file2_open` and `model2` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Setting our `mock_path_exists.return_value` to `True` to tell our method that
    the file already exists, we then patch over `open()` with our second `mock_open`
    object (the one representing an empty file) and call the `CSVModel.save_record()`
    method. Since we passed in a record with no row number (which indicates a record
    insert), this should result in our code trying to open `file2` in append mode
    and writing in the CSV-formatted record.
  prefs: []
  type: TYPE_NORMAL
- en: '`assert_called_with()` will test that assumption as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: While this method can tell us that `file2_open` was called with the expected
    parameters, how do we access its actual file handler so that we can see what was
    written to it?
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out we can just call our `mock_open` object and retrieve the mock
    file handle object, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the mock file handle (which is itself a `Mock` object), we can
    run test methods on its `write()` member to find out if it was called with the
    CSV data as expected. In this case, the file handle's `write()` method should
    have been called with the CSV-format record string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a similar set of tests, passing in a row number to simulate a record
    update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking that our update was done correctly presents a problem: `assert_called_with()`
    only checks the *last* call made to the mock function. When we update our CSV
    file, the entire CSV file is updated, with one `write()` call per row. We can''t
    just check that the last call was correct; we need to make sure the `write()`
    calls for *all* the rows were correct. To accomplish this, `Mock` contains a method
    called `assert_has_calls()`, which we can use to test the history of calls made
    to the object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, we need to create a list of `Call` objects. Each `Call` object represents
    a call to the mock object. We create `Call` objects using the `mock.call()` function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The arguments to `mock.call()` represent the arguments that should have been
    passed to the function call, which in our cases should just be single strings
    of CSV row data. The list of `Call` objects we pass to `assert_has_calls()` represents
    each call that should have been made to the mocked file handle's `write()` method,
    *in order*. The `assert_has_calls()` method's `in_order` argument can also be
    set to `False`, in which case the order won't need to match. In our case, order
    matters, since a wrong order would result in a corrupt CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: More tests on the models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing the remainder of the `CSVModel` class and the `SettingsModel` class
    methods should be essentially along the same lines as these two methods. A few
    more tests are included in the sample code, but see if you can come up with some
    of your own as well.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our Application object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've implemented our application as a Tk object that acts not only as a main
    window but also as a controller, patching together models and views defined elsewhere
    in the application. As you may expect, then, `patch()` is going to figure heavily
    into our testing code as we mock out all of those other components to isolate
    the `Application` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new file under the `test` directory called `test_application.py`, and
    we''ll begin with our imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s begin our test case class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As our `TestApplication` class will be using mocks in place of our data and
    settings models, we've created some class properties here to store samples of
    the data that `Application` expects to retrieve from those models. The `setUp()`
    method is going to patch out all the external classes with mocks, configure the
    mocked models to return our sample data, and then create an `Application` instance
    that our tests can use.
  prefs: []
  type: TYPE_NORMAL
- en: Note that while the Boolean values in the test records are `bool` objects, the
    numeric values are strings. This is actually how `CSVModel` returns the data,
    since no actual data type conversion is done at this point in the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create our `setUp()` method, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve created a `with` block using seven `patch()` context managers,
    one for each class, method, or function that we''re mocking out, including:'
  prefs: []
  type: TYPE_NORMAL
- en: The CSV and Settings models. These have been patched out with aliases, so that
    we can configure them to return the appropriate data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `show_login()` method, whose return value we hard-code to `True` so login
    will always succeed. Note that if we were going to write full test coverage of
    this class, we'd want to test this function too, but for now we'll just mock it
    out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The record form and record list classes, since we don't want issues in those
    classes to cause errors in our `Application` test code. Those classes will have
    their own test cases, so we aren't interested in testing them in this case. We
    don't need to configure anything about them, so we have not aliased these mock
    objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Notebook` class. Without mocking this, we'd be passing `Mock` objects to
    its `add()` method, causing an unnecessary error. We can assume Tkinter classes
    work correctly, so we mock this out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get_main_menu_for_os` class, since we don't want to deal with an actual
    menu object. Like the record form and record list, our menu classes will have
    their own test cases, so we are better off just taking them out of the equation
    here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Python 3.2, you can create a block with multiple context managers by separating
    each context manager call with a comma. Unfortunately, in Python 3.9 or lower,
    you can't put them in parentheses, so we're using the comparatively ugly escaped-newline
    method of breaking this gigantic call into multiple lines. If you're using Python
    3.10 or later, you can use parentheses around your list of context managers for
    a cleaner layout.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we're creating instances of our `settingsmodel` and `csvmodel` objects
    and configuring methods on the *return values* from the mock objects rather than
    the mocks themselves. Remember that our mocks are replacing the *classes*, not
    the *objects*, and it is the objects that will contain the methods our `Application`
    object will be calling. Therefore, we need to call the mocked classes to access
    the actual `Mock` object that will be used by `Application` as the data or settings
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the actual class that it stands in for, a `Mock` object called as a function
    will return the same object every time it's called. Thus, we don't have to save
    a reference to the object created by calling a mocked class; we can just call
    the mocked class repeatedly to access that object. Note, however, that a unique
    `Mock` object is created by the `Mock` *class* itself each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `Application` is a subclass of Tk, it''s a good idea for us to safely
    dispose of it after each use; even though we''re reassigning its variable name,
    the Tcl/Tk object will go on existing and cause problems with our tests. To solve
    this, create a `tearDown()` method in `TestApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice the call to `app.update()`. If we don't call this before destroying `app`,
    there may be tasks in the event queue that will try to access it after it's gone.
    This won't break our code, but it will clutter up our test output with error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our fixtures are taken care of, let''s write a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`Application._show_recordlist()` contains one line of code, which is merely
    a call to `self.notebook.select()`. Because we made `recordlist` a mock object,
    all of its members (including `select`) are also mock objects. Thus we can use
    the mock assertion methods to check that `select()` was called and with what arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a similar technique to check `_populate_recordlist()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're also using the `assert_called()` method to see if `CSVModel.get_all_records()`
    was called, which it should have been as part of populating the recordlist. Unlike
    `assert_called_with()`, `assert_called()` merely checks to see if a function was
    called, and as such is useful for functions that take no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under some circumstances, `get_all_records()` can raise an exception, in which
    case we''re supposed to show an error message box. But since we''ve mocked out
    our data model, how can we get the `Mock` object to raise an exception? The solution
    is to use mock''s `side_effect` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`side_effect` can be used to simulate more complex functionality in a mocked
    function or method. It can be set to a function, in which case the mock will run
    that function and return the results when called; it can be set to an iterable,
    in which case the mock will return the next item in the iterable each time it''s
    called; or, as in this case, it can be set to an exception, which will be raised
    when the mock is called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use this, we''ll need to patch out `messagebox` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This time when we call `_populate_recordlist()`, our mocked `CSVModel` object
    raises an exception, which should result in the method calling `messagebox.showerror()`.
    Since we've mocked `showerror()`, we can assert that it was called with the expected
    arguments using `assert_called_with()`.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the hardest part of testing our `Application` object is patching in
    all the mocked components and making sure they behave enough like the real thing
    to satisfy `Application`. Once we've done that, writing the actual tests is fairly
    straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we''ve done well testing our components with `patch()`, `Mock`, and
    the default `TestCase` class, but testing our widgets module is going to present
    some new challenges. To begin with, our widgets will need a Tk instance to be
    their root window. We can create this in each case''s `setUp()` method, but this
    will slow down the tests considerably, and it isn''t really necessary to do it
    over and over again: our tests aren''t going to modify the root window, so one
    root window will suffice for each test case. To keep things running at a reasonable
    pace, we can take advantage of the `setUpClass()` method to create a single instance
    of Tk just once when the test case instance is created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we have a large number of widgets to test, each of which will need
    its own `TestCase` class. As a result, we''ll need to create a large number of
    test cases requiring this same Tk setup and tear down. To address this, we''ll
    create a custom `TestCase` base class to handle the root window setup and tear-down,
    then subclass it for each of our widget test cases. Open a new file under the
    `test` directory called `test_widgets.py`, and begin with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `setUpClass()` method creates the Tk object and calls `wait_visibility()`
    just to make sure the root window is visible and completely drawn before our tests
    start working with it. We've also supplied a complementary tear-down method that
    updates the Tk instance (to finish out any events in the queue) and destroys it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for each widget test case, we will subclass `TkTestCase` to ensure we have
    a proper testing environment for the widget.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing the ValidatedSpinbox widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ValidatedSpinbox` is one of the more complicated widgets we created for our
    application, so it''s a good place to start writing tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subclass the `TkTestCase` class to create a test case for `ValidatedSpinbox`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `setUp()` method creates a control variable in which to store the widget''s
    value, then creates an instance of the `ValidatedSpinbox` widget with some basic
    settings: a minimum value of `-10`, a maximum of `10`, and an increment of `1`.
    After creating it, we pack it and wait for it to become visible. For our tear-down
    method, we simply destroy the widget.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s begin writing tests. We''ll start with a unit test of the `_key_validate()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we're simply iterating from 0 to 9 and testing both the positive
    and negative of the number against `_key_validate()`, which should return `True`
    for all of these values.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `_key_validate()` method takes a lot of positional arguments,
    and most of them are redundant; it might be nice to have a wrapper method that
    makes it easier to call, since a proper test of this function will likely need
    to call it dozens of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call that method `key_validate()` and add it to our `TestValidatedSpinbox`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make future calls to the method shorter and less error-prone. Let''s
    use this method now to test some invalid input, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we're entering the letter `a`; in the second, a `1` character
    when `0.` is already in the box (resulting in a proposed value of `0.1`); in the
    third, a `0` character when `10` is in the box (resulting in a proposed value
    of `100`). All of these scenarios should fail the validation method, causing it
    to return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing the ValidatedSpinbox widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding tests, we weren't actually entering any data into the widget;
    we were simply calling the key validation method directly and evaluating its output.
    This is good unit testing, but as a test of our widget's functionality it isn't
    very satisfying, is it? Since our custom widget is so deeply interactive with
    Tkinter's validation API, we'd like to test that we've actually interfaced with
    this API correctly. After all, *that* aspect of the code was more challenging
    than the actual logic in our validation methods.
  prefs: []
  type: TYPE_NORMAL
- en: We can accomplish this by creating some integration tests that simulate actual
    user actions and then check the results of those actions. To do this cleanly,
    we'll first need to create some supporting methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we''ll need a way to simulate typing text into the widget. Let''s
    start a new `type_in_widget()` method in the `TkTestCase` class that will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first thing this method does is force the focus to the widget; recall that
    `focus_force()` gives the widget focus even if the containing window is not in
    focus; we need to use this because our test Tk window is unlikely to be in focus
    when the test is being run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have focus, we''ll need to iterate through the characters in the string
    and translate the raw character into the appropriate key symbols for our event
    sequence. Recall that some characters, particularly symbols, must be represented
    as name strings, such as `minus` or `colon`. To make this work, we''ll need a
    way to translate between characters and their key symbols. We can do this with
    a dictionary added as a class property, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'More key symbols can be found at [http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm](http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm),
    but these should do for now. Let''s finish the `type_in_widget()` method like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this loop, we start by checking to see if our `char` value has a name string
    in `keysyms`. Then we generate a `KeyPress` event on the widget with the given
    character or key symbol. Note that we call `self.root.update_idletasks()` after
    generating the keypress event. This ensures that the typed characters register
    after being generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to simulating keyboard input, we''ll need to be able to simulate
    mouse clicks. We can create a similar method, `click_on_widget()`, for simulating
    mouse button clicks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This method takes a widget, an `x` and `y` coordinate for the click, and optionally
    a mouse button that will be clicked (defaulting to `1`, which is the left mouse
    button). Just as we did with our keystroke method, we first force focus, generate
    our events, then update the application. The `x` and `y` coordinates for the mouse
    click specify where the widget is clicked, relative to its upper-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these methods in place, return to the `TestValidatedSpinbox` class and
    write a new test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This method starts by clearing the widget, then simulates some valid input with
    `type_in_widget()`. Then we retrieve the value from the widget using `get()`,
    checking that it matches the expected value. Note that in these integration tests
    we'll need to clear the widget each time because we are simulating keystrokes
    in an actual widget and triggering all the side effects of that action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s test some invalid input; add the following to the test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This time, we've simulated typing non-numeric or out-of-range values into the
    widget and check the widget to make sure it has properly rejected the invalid
    keystrokes. In the first example, the `ValidatedSpinbox` should reject all the
    keystrokes since they are letters; in the second, only the initial `2` should
    be accepted since the subsequent `0` keystrokes would put the number out of range.
  prefs: []
  type: TYPE_NORMAL
- en: We can use our mouse click method to test the functionality of the `ValidatedSpinbox`
    widget's arrow buttons as well. To make this simpler, we could create a helper
    method in our test case class to click on the arrow we want. Of course, to click
    a particular arrow, we have to figure out how to locate that element within the
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach would be to just estimate a hard-coded number of pixels. In most
    default themes, the arrows are on the right side of the box, and the box is about
    20 pixels high. So, something like this method could work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This approach actually works fairly well and may be sufficient for your needs.
    However, it's a little brittle as it makes assumptions about your theme and screen
    resolution. For more complex custom widgets, you may have a hard time locating
    elements this way. What would be better is a way to find the actual coordinates
    of widget elements.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Tkinter widgets don't offer us a way to locate the *x* and *y*
    coordinates of elements within a widget; Ttk elements, however, do offer us a
    way to see which element is at a given set of coordinates, using the `identify()`
    method. Using this, we can write a method that scans through a widget looking
    for a particular element and returns the first set of *x* and *y* coordinates
    where it can be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this as a static method to the `TkTestCase` class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The method begins by updating the widget's idle tasks. Without this call, it's
    possible that all the elements are not yet drawn, and `identify()` will return
    an empty string. Next, we get a list of all the *x* and *y* coordinates in the
    widget by passing its width and height into the `range()` function. We iterate
    through these lists, calling `widget.identify()` on each pixel coordinate in the
    widget. If the returned element name matches the element name we're looking for,
    we return the current coordinates as a tuple. If we make it all the way through
    the widget without returning, we raise an exception stating that the element was
    not found.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we add 1 to each of the *x* and *y* coordinates; that's because this
    element returns the upper-left corner coordinate of the widget. In some cases,
    clicking on these corner coordinates doesn't register as a click on the widget.
    To be sure we're actually clicking *in* the widget, we return coordinates 1 pixel
    right and down from the corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there''s a snag here: what is the name of the element we''re looking
    for? Recall from *Chapter 9*, *Improving the Look with Styles and Themes*, that
    the elements that compose a widget are determined by the theme, and that different
    themes may have completely different elements. For example, if you''re looking
    for the increment arrow element, the default theme on Windows calls it `Spinbox.uparrow`.
    The default theme on Linux, however, calls it simply `uparrow`, and the default
    theme on macOS doesn''t even have a separate element for it (both arrows are a
    single element called `Spinbox.spinbutton`)!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, we need to force our test window to a specific theme so that
    we can rely on the names being consistent. In the `TestValidatedSpinbox.setUp()`
    method, we''ll add some code to force an explicit theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `classic` theme should be available on all platforms, and it uses the simple
    element names `uparrow` and `downarrow` for the `Spinbox` arrow elements. We've
    added a call to `update_idletasks()` to make sure the theme changes have taken
    effect in the widget before our tests start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can write a better `click_arrow()` method for `TestValidatedSpinbox`
    that relies on element names instead of hard-coded pixel values. Add this method
    to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Just as with our naive version, this method takes an arrow direction and a number
    of times. We use the arrow direction to build an element name, then use our `find_element()`
    method to locate the appropriate arrow inside the `ValidatedSpinbox` widget. Once
    we have the coordinates, we can use the `click_on_widget()` method we wrote to
    click on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this method to work and test our arrow key functionality in a new
    test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: By setting the value of the widget, then clicking the appropriate arrow a specified
    number of times, we can test that the arrows did their jobs according to the rules
    we created in our widget class.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our mixin class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One additional challenge we haven''t approached yet is testing our mixin class.
    Unlike our other widget classes, our mixin cannot really exist on its own: it
    depends on methods and properties found in the Ttk widget with which it''s combined.'
  prefs: []
  type: TYPE_NORMAL
- en: One approach to testing this class would be to mix it with a `Mock` object that
    mocks out any inherited methods. This approach has merit, but a simpler (if less
    theoretically pure) approach is to subclass it with the simplest possible `Ttk`
    widget and test the resulting child class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a test case that uses the latter approach. Start it in `test_widgets.py`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `setUp()` method creates just a basic child class of `ValidatedMixin`
    and `ttk.Entry` with no other modifications, then creates an instance of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write a test case for the `_validate()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Because we're sending a key event to `_validate()`, it routes the request to
    `_key_validate()`, which simply returns `True` by default. We'll need to verify
    that `_validate()` does what is needed when `_key_validate()` returns `False`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll employ `Mock` to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: By testing that `False` is returned and that `_key_validate()` was called with
    the correct arguments, we've demonstrated that `_validate()` is properly routing
    events to the right validation methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'By updating the `event` value in args, we can check that focus-out events also
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We've taken an identical approach here, just mocking out `_focusout_validate()`
    to make it return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, once we've created our test class, testing `ValidatedMixin`
    is like testing any other widget class. There are other test method examples in
    the included source code; these should be enough to get you started with creating
    a complete test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the benefits of automated testing and the
    capabilities provided by Python's `unittest` library. You learned how to isolate
    units of code by using `Mock` and `patch()` to replace external modules, classes,
    and functions. You learned strategies for controlling Tkinter's event queue and
    simulating user input to automate tests of our GUI components, and wrote both
    unit tests and integration tests against sections of the ABQ application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll upgrade our backend to use a relational database.
    In the process, you'll learn about relational database design and data normalization.
    You'll also learn to work with the PostgreSQL database server and Python's `psycopg2`
    PostgreSQL interface library.
  prefs: []
  type: TYPE_NORMAL
