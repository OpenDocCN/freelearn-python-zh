- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Creating Automated Tests with unittest
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用unittest创建自动测试
- en: With the size and complexity of your application rapidly expanding, you've become
    nervous about making changes. What if you break something? How will you know?
    You can, of course, run through all the features of the program manually with
    various input and watch for errors, but this approach gets harder and more time
    consuming as you add more features. What you really need is a fast and reliable
    way to make sure your program is working properly whenever you make a code change.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序规模和复杂性的快速扩展，你对做出更改感到紧张。万一你弄坏了什么？你怎么知道？当然，你可以手动运行程序的所有功能，使用各种输入并监视错误，但随着你添加更多功能，这种方法会变得更加困难且耗时。你真正需要的是一个快速且可靠的方法来确保每次代码更改时程序都能正常工作。
- en: 'Fortunately, there is a way: automated testing. In this chapter, you''ll learn
    about automated testing in the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种方法：自动测试。在本章中，你将学习以下关于自动测试的内容：
- en: In *Automated testing basics*, you'll discover the fundamentals of automated
    testing in Python using `unittest`.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*自动测试基础*中，你将了解使用`unittest`在Python中进行自动测试的基本原理。
- en: In *Testing Tkinter code*, we'll discuss specific strategies for testing Tkinter
    applications.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*测试Tkinter代码*中，我们将讨论测试Tkinter应用程序的具体策略。
- en: In *Writing tests for our application*, we'll apply this knowledge to the ABQ
    Data Entry application.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*为我们的应用程序编写测试*中，我们将应用这些知识到ABQ数据录入应用程序。
- en: Automated testing basics
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动测试基础
- en: Up until now, testing our application has been a process of launching it, running
    it through a few basic procedures, and verifying that it did what we expected
    it to do. This approach works acceptably on a very small script, but, as our application
    grows, it becomes an increasingly time-consuming and error-prone process to verify
    the application's behavior.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，测试我们的应用程序一直是一个启动它，运行一些基本程序，并验证它是否按预期执行的过程。这种方法在非常小的脚本上可以接受，但随着我们的应用程序增长，验证应用程序行为的过程变得越来越耗时且容易出错。
- en: Using automated testing, we can consistently verify our application logic within
    seconds. There are several forms of automated testing, but the two most common
    are **unit testing** and **integration testing**. Unit tests work with discrete
    pieces of code in isolation, allowing us to quickly verify the behavior of specific
    sections. Integration tests verify the interactions of multiple units of code.
    We'll be writing both kinds of tests to verify the behavior of our application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动测试，我们可以在几秒钟内一致地验证我们的应用程序逻辑。有几种自动测试的形式，但最常见的是**单元测试**和**集成测试**。单元测试与独立的代码片段一起工作，使我们能够快速验证特定部分的行为。集成测试验证多个代码单元之间的交互。我们将编写这两种类型的测试来验证我们应用程序的行为。
- en: A simple unit test
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单单元测试
- en: At its most basic, a unit test is just a short program that runs a unit of code
    under different conditions and compares its output against expected results.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的单元测试只是一个短程序，它在不同的条件下运行一段代码单元，并将其输出与预期结果进行比较。
- en: 'Consider the following calculation class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下计算类：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class is initialized with two numbers on which it can subsequently perform
    a variety of mathematical operations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类初始化时带有两个数字，它可以在其后执行各种数学运算。
- en: 'Suppose we want to write some code to test if this class works as it should.
    A naive approach might look like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想编写一些代码来测试这个类是否按预期工作。一种简单的方法可能如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This test code creates a `MyCalc` object and then uses `assert` statements to
    check the output of `add()` and `mod_divide()` against expected values. The `assert`
    keyword in Python is a special statement that raises an `AssertionError` exception
    if the expression that follows it evaluates to `False`. The message string after
    the comma is the error string that will be passed to the `AssertionError` exception's
    initializer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段测试代码创建了一个`MyCalc`对象，然后使用`assert`语句检查`add()`和`mod_divide()`的输出是否与预期值相符。Python中的`assert`关键字是一个特殊的语句，如果其后的表达式评估为`False`，则会引发`AssertionError`异常。逗号后面的消息字符串是传递给`AssertionError`异常初始化器的错误字符串。
- en: 'In other words, the statement `assert expression, "message"` is equivalent
    to:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`assert expression, "message"`语句等同于：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Currently, all tests pass if you run the test script for `MyCalc`. Let''s try
    changing the `add()` method to make it fail:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果你运行`MyCalc`的测试脚本，所有测试都通过。让我们尝试更改`add()`方法使其失败：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, running the test gives this error:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试给出以下错误：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What is the value of such tests? With such a simple function, it seems pointless.
    But suppose someone decides to refactor our `mod_divide()` method as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的测试有什么价值？对于这样一个简单的函数，这似乎是多余的。但是，假设有人决定按照以下方式重构我们的`mod_divide()`方法：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method is a little more complex, and you may or may not be familiar with
    all the operators involved. However, since this passes our tests, we have some
    evidence that this algorithm is correct, even if we didn't completely understand
    the code. If there were a problem with the refactor, our tests could help us identify
    the problem quickly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法稍微复杂一些，你可能对涉及的运算符熟悉或不熟悉。然而，由于这种方法通过了我们的测试，我们有证据表明这个算法是正确的，即使我们没有完全理解代码。如果重构存在问题，我们的测试可以帮助我们快速识别问题。
- en: Testing pure mathematical functions is fairly simple; unfortunately, testing
    real application code presents us with some challenges that demand a more sophisticated
    approach.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试纯数学函数相对简单；不幸的是，测试实际应用程序代码给我们带来了挑战，需要更复杂的方法。
- en: 'Consider these issues:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这些问题：
- en: Code units often rely on a pre-existing state that must be set up before the
    test and cleared up afterward.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码单元通常依赖于在测试之前必须设置并在测试之后清理的预存在状态。
- en: Code may have side effects that change objects outside the code unit.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可能存在副作用，会改变代码单元外部的对象。
- en: Code may interact with resources that are slow, unreliable, or unpredictable.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可能与慢速、不可靠或不可预测的资源交互。
- en: Real applications contain many functions and classes that require testing, and
    ideally we'd like to be alerted to all problems at once. Our test script, as written,
    would stop on the first failed assertion, so we'd only get alerted to one problem
    at a time.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际应用程序包含许多需要测试的函数和类，理想情况下我们希望一次性被提醒所有问题。按照目前编写的测试脚本，它会在第一个失败的断言处停止，所以我们只会一次被提醒一个问题。
- en: To address these issues and others, programmers rely on **testing frameworks**
    to make writing and executing automated tests as simple, efficient, and reliable
    as possible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题以及其他问题，程序员依赖于**测试框架**，以使编写和执行自动化测试尽可能简单、高效和可靠。
- en: The unittest module
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unittest模块
- en: 'The `unittest` module is the Python standard library''s automated testing framework.
    It provides us with some powerful tools to make testing our code reasonably easy,
    and is based on some standard unit testing concepts found in many test frameworks.
    These concepts include:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块是Python标准库的自动化测试框架。它为我们提供了一些强大的工具，使测试我们的代码变得相对容易，并且基于许多测试框架中发现的某些标准单元测试概念。这些概念包括：'
- en: '**Test**: A test is a single method that will either finish or raise an exception.
    Tests generally focus on one unit of code, such as a function, method, or process.
    A test can either pass, meaning the test was successful; fail, meaning the code
    failed the test; or error, meaning the test itself encountered a problem.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：测试是一个单独的方法，它要么完成，要么引发异常。测试通常关注一个代码单元，如函数、方法或过程。测试可以成功，表示测试成功；失败，表示代码未通过测试；或者错误，表示测试本身遇到了问题。'
- en: '**Test case**: A test case is a collection of tests that should be run together
    and contain similar setup and tear-down requirements, typically corresponding
    to a class or module. Test cases can have **fixtures**, which are items that need
    to be set up before each test and torn down after each test to provide a clean,
    predictable environment in which the test can run.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例**：测试用例是一组应该一起运行的测试，包含类似的设置和清理要求，通常对应于一个类或模块。测试用例可以有**固定装置**，这些是在每个测试之前需要设置并在每个测试之后清理的项目，以提供一个干净、可预测的环境，使测试可以运行。'
- en: '**Test suite**: A test suite is a collection of test cases that cover all the
    code for an application or module.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**：测试套件是一组测试用例，用于覆盖应用程序或模块的所有代码。'
- en: '**Mock**: A mock is an object that stands in for another object. Typically,
    they''re used to replace an external resource, such as a file, database, or library
    module. Mocks are patched over those resources during the test to provide a fast
    and predictable stand-in with no side effects.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟对象**：模拟对象是代表另一个对象的实体。通常，它们用于替换外部资源，如文件、数据库或库模块。在测试期间，模拟对象会覆盖这些资源，以提供一个快速且可预测的替代品，且没有副作用。'
- en: To explore these concepts in depth, let's test our `MyCalc` class using `unittest`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入探索这些概念，让我们使用`unittest`测试我们的`MyCalc`类。
- en: Writing a test case
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: 'Let''s create a test case for the `MyCalc` class. Create a new file called
    `test_mycalc.py`, and enter this code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`MyCalc`类创建一个测试用例。创建一个名为`test_mycalc.py`的新文件，并输入以下代码：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The names of both your test modules and your test methods should be prefixed
    with `test_`. Doing so allows the `unittest` runner to automatically find test
    modules and distinguish test methods from other methods in your test case classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试模块和测试方法的名称都应该以`test_`为前缀。这样做允许`unittest`运行器自动找到测试模块，并区分测试用例类中的测试方法和其他方法。
- en: As you probably guessed, the `TestCase` class represents a test case. To make
    our test case for `MyCalc`, we have subclassed `TestCase` and added a `test_`
    method that will test some aspect of our class. Inside the `test_add()` method,
    we created a `MyCalc` object, then made an assertion about the output of `add()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`TestCase`类代表一个测试用例。为了对`MyCalc`进行测试用例，我们已从`TestCase`派生并添加了一个`test_`方法，该方法将测试我们类的一些方面。在`test_add()`方法内部，我们创建了一个`MyCalc`对象，然后对`add()`的输出进行了断言。
- en: At the end of the file, we've added a call to `unittest.main()`, which will
    cause all test cases in the file to be executed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，我们添加了对`unittest.main()`的调用，这将导致文件中的所有测试用例被执行。
- en: 'If you run your test file at the command line, you should get the following
    output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行中运行你的测试文件，你应该得到以下输出：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The single dot on the first line represents our one test (`test_add()`). For
    each test method, `unittest.main()` will output one of the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行上的单个点代表我们的一个测试（`test_add()`）。对于每个测试方法，`unittest.main()`将输出以下之一：
- en: A dot, which means the test passed
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个点，表示测试通过
- en: '`F`, which means it failed'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F`，表示它失败了'
- en: '`E`, meaning the test caused an error'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E`，表示测试引发了错误'
- en: At the end, we get a summary of what happened, including the number of tests
    run and how long it took. The `OK` indicates that all tests passed successfully.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到一个总结，包括运行了多少个测试以及花费了多长时间。`OK`表示所有测试都成功通过。
- en: 'To see what happens when a test fails, let''s alter our test so that it intentionally
    fails:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看测试失败时会发生什么，让我们修改我们的测试，使其故意失败：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now when you run the test module, you should see output like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你运行测试模块时，你应该看到如下输出：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the single `F` at the top, representing our failed test. After all the
    tests have run, we get the full traceback of any failed tests, so that we can
    easily locate the failing code and correct it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意顶部单个的`F`，代表我们的失败测试。在所有测试运行完毕后，我们得到任何失败测试的完整跟踪记录，这样我们就可以轻松地定位失败的代码并更正它。
- en: 'This traceback output isn''t very ideal, though; we can see that `mc.add()`
    didn''t return `12`, but we don''t know what it *did* return. We could add a comment
    string to our `assert` call, but `unittest` provides a nicer approach: `TestCase`
    assertion methods.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这个跟踪输出并不理想；我们可以看到`mc.add()`没有返回`12`，但我们不知道它*实际上*返回了什么。我们可以在我们的`assert`调用中添加一个注释字符串，但`unittest`提供了一个更好的方法：`TestCase`断言方法。
- en: TestCase assertion methods
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TestCase断言方法
- en: '`TestCase` objects have a number of assertion methods that provide a cleaner
    and more robust way to run various tests on our code output.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestCase`对象具有许多断言方法，提供了一种更干净、更健壮的方式来运行我们代码输出的各种测试。'
- en: 'For example, there is the `TestCase.assertEqual()` method to test equality,
    which we can use as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有`TestCase.assertEqual()`方法来测试相等性，我们可以如下使用：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we run our test case with this code, you can see that the traceback is
    improved:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用此代码运行测试用例时，你可以看到跟踪记录得到了改进：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we can see the value that `mc.add()` returned, which is much more helpful
    for debugging. `TestCase` contains more than 20 assertion methods that can simplify
    testing for a variety of conditions such as class inheritance, raised exceptions,
    and sequence membership.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到`mc.add()`返回的值，这对调试非常有帮助。`TestCase`包含20多种断言方法，可以简化对各种条件（如类继承、抛出异常和序列成员资格）的测试。
- en: 'Some more commonly used ones are listed in the following table:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更常用的方法列在以下表格中：
- en: '| Method | Tests |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 测试 |'
- en: '| `assertEqual(a`, `b)` | `a` `==` `b` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `assertEqual(a`, `b)` | `a` `==` `b` |'
- en: '| `assertTrue(a)` | `a` `is` `True` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `assertTrue(a)` | `a` `is` `True` |'
- en: '| `assertFalse(a)` | `a` `is` `False` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `assertFalse(a)` | `a` `is` `False` |'
- en: '| `assertIn(item`, `sequence)` | `item` `in` `sequence` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `assertIn(item`, `sequence)` | `item` `in` `sequence` |'
- en: '| `assertRaises(exception`, `callable`, `*args)` | `callable` raises `exception`
    when called with `args` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `assertRaises(exception`, `callable`, `*args)` | `callable` raises `exception`
    when called with `args` |'
- en: '| `assertGreater(a`, `b)` | `a` is greater than `b` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `assertGreater(a`, `b)` | `a` is greater than `b` |'
- en: '| `assertLess(a`, `b)` | `a` is less than `b` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `assertLess(a`, `b)` | `a` is less than `b` |'
- en: A full list of the available assertion methods can be found in the `unittest`
    documentation at [https://docs.python.org/3/library/unittest.html#unittest.TestCase](https://docs.python.org/3/library/unittest.html#unittest.TestCase).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的断言方法的完整列表可以在 `unittest` 文档的 [https://docs.python.org/3/library/unittest.html#unittest.TestCase](https://docs.python.org/3/library/unittest.html#unittest.TestCase)
    找到。
- en: 'Let''s use an assertion method to test that `mod_divide()` raises a `ValueError`
    exception when `b` is `0`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个断言方法来测试当 `b` 为 `0` 时，`mod_divide()` 会引发一个 `ValueError` 异常：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`assertRaises()` *passes* if the function raises the given exception when called.
    If we need to pass any arguments into the tested function, they can be specified
    as additional arguments to `assertRaises()`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数在调用时引发给定的异常时，`assertRaises()` 会 *通过*。如果我们需要将任何参数传递给测试的函数，它们可以作为额外的参数指定给 `assertRaises()`。
- en: '`assertRaises()` can also be used as a context manager like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertRaises()` 也可以像这样用作上下文管理器：'
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code accomplishes the exact same thing, but is a little clearer and more
    flexible, since it allows us to put multiple lines of code in the block.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实现了完全相同的功能，但更加清晰和灵活，因为它允许我们将多行代码放入代码块中。
- en: You can easily add your own custom assertion methods to your test case as well;
    it's simply a matter of creating a method that raises an `AssertionError` exception
    under some condition.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以轻松地将自己的自定义断言方法添加到测试用例中；这只是一个创建在某种条件下引发 `AssertionError` 异常的方法的问题。
- en: Fixtures
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定设施
- en: It should be clear that each test in our test case is going to need access to
    a `MyCalc` object. It would be nice if we didn't have to do this manually in each
    test method. To help us avoid this tedious task, the `TestCase` object offers
    a `setUp()` method. This method is run before every test case is run, and by overriding
    it we can take care of any setup that needs to be done for each test.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，我们测试用例中的每个测试都需要访问一个 `MyCalc` 对象。如果我们不需要在每个测试方法中手动做这件事，那就很好了。为了帮助我们避免这项繁琐的任务，`TestCase`
    对象提供了一个 `setUp()` 方法。该方法在运行每个测试用例之前运行，通过覆盖它，我们可以处理每个测试所需的任何设置。
- en: 'For example, we can use it to create `MyCalc` objects, like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以用它来创建 `MyCalc` 对象，如下所示：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, every test case can use these objects to run its tests rather than creating
    their own. Understand that the `setUp()` method will be rerun before *every* test,
    so these objects will always be reset between test methods. If we have items that
    need to be cleaned up after each test, we can override the `tearDown()` method
    as well, which is run after each test (in this case, it's not necessary).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个测试用例都可以使用这些对象来运行其测试，而不是创建它们自己的。理解到 `setUp()` 方法将在 *每个* 测试之前重新运行，因此这些对象将在测试方法之间始终重置。如果我们有需要在每次测试后清理的项目，我们也可以覆盖
    `tearDown()` 方法，该方法在每次测试之后运行（在这种情况下，这不是必要的）。
- en: 'Now that we have a `setUp()` method, our `test_add()` method can be much simpler:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `setUp()` 方法，我们的 `test_add()` 方法可以更加简单：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In addition to the instance methods `setUp()` and `tearDown()`, `TestCase` also
    has class methods for setup and tear-down of the object itself as well; these
    are `setUpClass()` and `tearDownClass()`. These two methods can be used for slower
    operations that can be run when the test case is created and destroyed, rather
    than needing to be refreshed between each test; for example, you might use them
    to create complex objects that are required for your tests, but won't be altered
    by any of them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例方法 `setUp()` 和 `tearDown()` 之外，`TestCase` 还具有用于对象本身设置和清理的类方法；这些是 `setUpClass()`
    和 `tearDownClass()`。这两个方法可以用于在测试用例创建和销毁时运行的较慢操作，而不是需要在每次测试之间刷新；例如，您可能可以使用它们来创建测试所需的复杂对象，而这些对象不会被任何测试所更改。
- en: Using Mock and patch
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Mock 和 patch
- en: The `MyCalc.rand_between()` method generates a random number between `a` and
    `b`. Because we can't possibly predict its output, we can't provide a fixed value
    to test it against. How can we test this method?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyCalc.rand_between()` 方法生成一个介于 `a` 和 `b` 之间的随机数。因为我们无法预测其输出，所以我们不能提供一个固定值来测试它。我们如何测试这个方法？'
- en: 'A naive approach might look something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法可能看起来像这样：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This test passes if our code is correct, but it doesn't necessarily fail if
    the code is wrong; in fact, if the code is wrong, it may pass or fail unpredictably
    since the return value of `rand_between()` is random. For example, if `MyCalc(1,10).rand_between()`
    was incorrectly returning values between 2 and 11, the test would pass if it returned
    2 through 10, and only fail if it returned 11\. Thus, even though the code is
    wrong, there would be only a 10% chance that the test would fail on each run of
    the test suite.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码是正确的，这个测试就会通过，但代码错误时它不一定失败；事实上，如果代码错误，它可能会不可预测地通过或失败，因为`rand_between()`的返回值是随机的。例如，如果`MyCalc(1,10).rand_between()`错误地返回了2到11之间的值，那么如果返回2到10之间的值，测试就会通过，只有当返回11时才会失败。因此，即使代码是错误的，测试套件在每次运行时只有10%的几率会失败。
- en: For the purposes of our tests, we can safely assume that a standard library
    function such as `random()` works correctly; so our unit test should really test
    whether *our* method correctly handles the number provided to it by `random()`.
    If we could temporarily replace `random()` with a function that returns a predictable
    fixed value, it would be simple to test the correctness of our subsequent calculations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试的目的，我们可以安全地假设标准库函数，如`random()`，是正确工作的；因此，我们的单元测试实际上应该测试我们自己的方法是否正确处理了`random()`提供的数值。如果我们能够临时替换`random()`为一个返回可预测固定值的函数，那么测试我们后续计算的准确性就会变得简单。
- en: The `unittest.mock` module provides us with the `Mock` class for this purpose.
    `Mock` objects can be used to predictably simulate the behavior of another class,
    method, or library. We can give our `Mock` objects return values, side effects,
    properties, methods, and other features needed to fake the behavior of another
    class, object, function, or module, then drop them in place before running our
    tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock`模块为我们提供了`Mock`类来实现这个目的。`Mock`对象可以用来可预测地模拟另一个类、方法或库的行为。我们可以为我们的`Mock`对象提供返回值、副作用、属性、方法和其他特征，以模拟另一个类、对象、函数或模块的行为，然后在运行测试之前将其放置在适当的位置。'
- en: 'To see this in action, let''s create a fake `random()` function using `Mock`,
    like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个效果，让我们使用`Mock`创建一个假的`random()`函数，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Mock` object's `return_value` argument allows us to hard-code a value to
    be returned whenever it's called as a function. Here, our mock object `fakerandom`
    will behave like a function that always returns `0.5`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mock`对象的`return_value`参数允许我们在每次调用函数时硬编码一个返回值。在这里，我们的模拟对象`fakerandom`将表现得像一个总是返回`0.5`的函数。'
- en: 'Now we can put `fakerandom` in place of `random()` as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将`fakerandom`替换为`random()`，如下所示：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We start by saving a reference to `mycalc.random.random` before replacing it.
    Note that we're specifically replacing *only* the version of `random` being used
    in `mycalc.py` so that we don't affect calls to `random()` anywhere else. It's
    a best practice to be as specific as possible when patching libraries to avoid
    unforeseen side effects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先保存对`mycalc.random.random`的引用，然后再进行替换。请注意，我们特别替换了`mycalc.py`中使用的`random`版本，这样就不会影响到其他地方的`random()`调用。在修补库时尽可能具体是一种最佳实践，以避免不可预见的副作用。
- en: With `fakerandom` in place, we can call `rand_between()` and test the output.
    Because `fakerandom()` will always return `0.5`, we know that the answer when
    `a` is `1` and `b` is `0` should be `(0.5 × 1 + 0) = 0.5`. Any other value would
    indicate an error in our algorithm. At the end of the test code, we revert `random`
    to the original standard library function so that other tests (or the classes
    or functions they call) don't accidentally use the mock.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fakerandom`模块就绪后，我们可以调用`rand_between()`并测试输出。因为`fakerandom()`总是返回`0.5`，所以当`a`为`1`且`b`为`0`时，答案应该是`(0.5
    × 1 + 0) = 0.5`。任何其他值都表明我们的算法中存在错误。在测试代码的末尾，我们将`random`恢复到原始的标准库函数，这样其他测试（或它们调用的类或函数）就不会意外地使用模拟。
- en: Having to store or revert the original library each time is an annoyance we
    can do without, so `unittest.mock` provides a cleaner approach using `patch()`.
    The `patch()` function can be used as either a context manager or a decorator,
    and either approach makes patching a `Mock` object into our code much cleaner.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每次需要存储或恢复原始库时都是一种不必要的麻烦，所以`unittest.mock`提供了一个更干净的方法，使用`patch()`。`patch()`函数可以用作上下文管理器或装饰器，两种方法都可以使将`Mock`对象修补到我们的代码中变得更加干净。
- en: 'Swapping in `fakerandom()` using `patch()` as a context manager looks like
    this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`patch()`作为上下文管理器来交换`fakerandom()`看起来是这样的：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `patch()` command takes an import path string and provides us with a new
    `Mock` object that it has patched in place of the object at that path. Inside
    the context manager block, we can set methods and properties on the `Mock` object,
    then run our actual tests. The patched function will be reverted to its original
    version when the block ends.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch()`命令接受一个导入路径字符串，并为我们提供一个新创建的`Mock`对象，该对象已在该路径上替换了原始对象。在上下文管理器块内部，我们可以在`Mock`对象上设置方法和属性，然后运行我们的实际测试。当块结束时，修补的函数将恢复到其原始版本。'
- en: 'Using `patch()` as a decorator is similar:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将`patch()`用作装饰器类似：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, the `Mock` object created by `patch()` is passed as an argument
    to our test method and will remain patched for the duration of the decorated function.
    This approach works well if we plan to use the mock multiple times in a test method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由`patch()`创建的`Mock`对象作为参数传递给我们的测试方法，并在装饰函数的持续时间内在其位置上保持修补。如果我们计划在测试方法中多次使用模拟，这种方法效果很好。
- en: Running multiple unit tests
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行多个单元测试
- en: While we can run our unit tests by including a call to `unittest.main()` at
    the end of the file, that approach doesn't scale well. As our application grows,
    we're going to write many test files, which we'll want to run in groups or all
    at once.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在文件末尾包含对`unittest.main()`的调用以运行我们的单元测试，但这种方法扩展性不好。随着我们的应用程序增长，我们将编写许多测试文件，我们希望可以分组或一次性运行。
- en: 'Fortunately, `unittest` can discover and run all tests in a project with one
    command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`unittest`可以通过一条命令发现并运行项目中的所有测试：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So long as you have followed the recommended naming scheme of prefixing your
    test modules with `test_`, running this command in your project's root directory
    should run all your test scripts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你遵循了推荐的命名方案，即以`test_`前缀命名你的测试模块，在项目根目录下运行此命令就应该会运行所有测试脚本。
- en: Testing Tkinter code
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Tkinter代码
- en: Testing Tkinter code presents us with a few particular challenges. First, Tkinter
    handles many callbacks and methods asynchronously, meaning that we can't count
    on the results of some code to be apparent immediately. Also, testing GUI behaviors
    often relies on external factors such as window management or visual cues that
    our tests cannot detect.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Tkinter代码给我们带来了一些特定的挑战。首先，Tkinter异步处理许多回调和方法，这意味着我们不能指望某些代码的结果立即显现。此外，测试GUI行为通常依赖于外部因素，如窗口管理或视觉提示，这些因素是我们测试无法检测的。
- en: In this section, we're going to learn some tools and strategies to address these
    issues and help you craft tests for your Tkinter code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习一些工具和策略来解决这些问题，并帮助你为Tkinter代码编写测试。
- en: Managing asynchronous code
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理异步代码
- en: Whenever you interact with a Tkinter UI – whether it's clicking a button, typing
    in a field, or raising a window, for example – the response is not executed immediately
    in place.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你与Tkinter UI交互时——无论是点击按钮、在字段中输入还是打开窗口等——响应不会立即执行。
- en: Instead, these actions are placed in a sort of to-do list, called an **event
    queue**, to be handled later while code execution continues. While these actions
    seem instant to users, test code cannot count on a requested action being completed
    before the next line of code is run.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这些操作被放置在一个类似于待办事项列表的**事件队列**中，以便在代码执行继续的同时进行处理。虽然这些操作对用户来说似乎是瞬间的，但测试代码不能指望在运行下一行代码之前完成请求的操作。
- en: 'To solve this problem, Tkinter widgets have some methods that allow us to manage
    the event queue:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Tkinter部件有一些方法允许我们管理事件队列：
- en: '`wait_visibility()`: This method causes the code to wait until a widget is
    fully drawn on-screen before executing the next line of code.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait_visibility()`: 此方法导致代码等待直到部件完全绘制到屏幕上，然后执行下一行代码。'
- en: '`update_idletasks()`: This method forces Tkinter to process any idle tasks
    currently outstanding on the widget. Idle tasks are low-priority tasks such as
    drawing and rendering.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_idletasks()`: 此方法强制Tkinter处理当前在部件上挂起的任何空闲任务。空闲任务是指低优先级任务，如绘图和渲染。'
- en: '`update()`: This method forces Tkinter to process all events that are outstanding
    on a widget, including calling callbacks, redraws, and geometry management. It
    includes everything that `update_idletasks()` does and more.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`: 此方法强制Tkinter处理部件上挂起的全部事件，包括调用回调、重绘和几何管理。它包括`update_idletasks()`所做的一切以及更多。'
- en: The event queue will be discussed in more detail in *Chapter 14*, *Asynchronous
    Programming with Thread and Queue*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 事件队列将在第14章“使用线程和队列的异步编程”中更详细地讨论。
- en: Simulating user actions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟用户操作
- en: When automating GUI tests, we may wish to know what happens when a user clicks
    on a certain widget, or types a certain keystroke. When these actions happen in
    the GUI, Tkinter generates an `Event` object for the widget and passes it to the
    event queue. We can do the same thing in code, using a widget's `event_generate()`
    method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化 GUI 测试时，我们可能想知道当用户点击某个控件或输入某个按键时会发生什么。当这些动作在 GUI 中发生时，Tkinter 会为该控件生成一个
    `Event` 对象并将其传递给事件队列。我们可以在代码中做同样的事情，使用控件的 `event_generate()` 方法。
- en: Specifying an event sequence
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定事件序列
- en: As we learned in *Chapter 6*, *Planning for the Expansion of Our Application*,
    we can cause an event to be registered on a widget by passing an event **sequence
    string** to `event_generate()` in the format `<EventModifier-EventType-EventDetail>`.
    Let's look at sequence strings in more detail.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第 6 章* 中学到的，*为应用扩展做准备*，我们可以通过将事件**序列字符串**传递给 `event_generate()` 方法中的格式
    `<EventModifier-EventType-EventDetail>` 来在控件上注册一个事件。让我们更详细地看看序列字符串。
- en: The core part of a sequence string is the **event type**. It specifies the kind
    of event we're sending, such as a keystroke, mouse click, windowing event, and
    so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 事件序列字符串的核心部分是**事件类型**。它指定了我们发送的事件类型，例如按键、鼠标点击、窗口事件等。
- en: 'Tkinter has around 30 event types, but you will typically only need to work
    with the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 大约有 30 种事件类型，但通常你只需要处理以下几种：
- en: '| Event types | Action represented |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 表示的动作 |'
- en: '| `ButtonPress` or `Button` | Mouse-button click |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `ButtonPress` 或 `Button` | 鼠标按钮点击 |'
- en: '| `ButtonRelease` | Lifting off a mouse button |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `ButtonRelease` | 松开鼠标按钮 |'
- en: '| `KeyPress` or `Key` | Pressing a keyboard key |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `KeyPress` 或 `Key` | 按下键盘上的键 |'
- en: '| `KeyRelease` | Lifting off a keyboard key |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `KeyRelease` | 松开键盘上的键 |'
- en: '| `FocusIn` | Giving focus to a widget, such as a button or input widget |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `FocusIn` | 将焦点给予一个控件，例如按钮或输入控件 |'
- en: '| `FocusOut` | Exiting a focused widget |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `FocusOut` | 离开一个聚焦的控件 |'
- en: '| `Enter` | The mouse cursor entering a widget |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `Enter` | 鼠标光标进入一个控件 |'
- en: '| `Leave` | The mouse cursor moving off a widget |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `Leave` | 鼠标光标从一个控件上移开 |'
- en: '| `Configure` | A change in the widget''s configuration, for example, a `config()`
    call, or the user resizing the window, and so on |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `Configure` | 控件配置的改变，例如，调用 `config()`，或者用户调整窗口大小等 |'
- en: '**Event modifiers** are optional words that can alter the event type; for example,
    `Control`, `Alt`, and `Shift` can be used to indicate that one of those modifier
    keys is held down; `Double` or `Triple` can be used with `Button` to indicate
    a double- or triple-click of the described button. Multiple modifiers can be strung
    together if required.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件修饰符**是可选的单词，可以改变事件类型；例如，`Control`、`Alt` 和 `Shift` 可以用来表示这些修饰键之一被按下；`Double`
    或 `Triple` 可以与 `Button` 结合使用，以表示描述的按钮的双击或三击。如果需要，可以串联多个修饰符。'
- en: '**Event detail**, only valid for keyboard or mouse events, describes which
    key or button was pressed. For example, `<Button-1>` refers to the left mouse
    button, while `<Button-3>` refers to the right. For letter and number keys, the
    literal letter or number can be used, such as `<Control-KeyPress-a>`; most symbols,
    however, are described by a word (`minus`, `colon`, `semicolon`, and so on) to
    avoid syntactic clashes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件细节**，仅对键盘或鼠标事件有效，描述了哪个键或按钮被按下。例如，`<Button-1>` 指的是左鼠标按钮，而 `<Button-3>` 指的是右。对于字母和数字键，可以使用实际的字母或数字，例如
    `<Control-KeyPress-a>`；然而，大多数符号都由一个单词（如 `minus`、`colon`、`semicolon` 等）描述，以避免语法冲突。'
- en: For button presses and keypresses, the event type is technically optional; for
    example, you could use `<Control-a>` instead of `<Control-KeyPress-a>`. However,
    it's probably a good idea to leave it in for the sake of clarity. For example,
    `<1>` is a valid event, but does it refer to pressing the left mouse button or
    the 1 key? You may be surprised to find that it's the mouse button.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于按钮点击和按键，事件类型在技术上不是必需的；例如，你可以使用 `<Control-a>` 而不是 `<Control-KeyPress-a>`。然而，出于清晰起见，保留它可能是个好主意。例如，`<1>`
    是一个有效的事件，但它指的是按下左鼠标按钮还是数字键 1？你可能惊讶地发现它是鼠标按钮。
- en: 'The following table shows some examples of valid event sequences:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了有效事件序列的一些示例：
- en: '| Sequence | Meaning |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 序列 | 含义 |'
- en: '| `<Double-Button-3>` | Double-clicking the right mouse button |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `<Double-Button-3>` | 双击右鼠标按钮 |'
- en: '| `<Alt-KeyPress-exclam>` | Holding Alt and typing an exclamation point |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `<Alt-KeyPress-exclam>` | 按住 Alt 并输入感叹号 |'
- en: '| `<Control-Alt-Key-m>` | Holding Control and Alt and pressing the M key |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `<Control-Alt-Key-m>` | 按住 Control 和 Alt 并按下 M 键 |'
- en: '| `<KeyRelease-minus>` | Lifting off a pressed minus key |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `<KeyRelease-minus>` | 释放按下的减号键 |'
- en: In addition to the sequence, we can pass other arguments to `event_generate()`
    that describe various aspects of the event. Many of these are redundant, but,
    in some cases, we need to provide extra information for the event to have any
    meaning; for example, mouse button events need to include an `x` and a `y` argument
    that specify the coordinates of the click.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了序列之外，我们还可以向`event_generate()`传递其他参数，以描述事件的各个方面。其中许多是多余的，但在某些情况下，我们需要为事件提供额外信息，以便它具有任何意义；例如，鼠标按钮事件需要包括一个`x`和`y`参数，以指定点击的坐标。
- en: Single brackets around a sequence indicate a built-in event type. Double brackets
    are used for custom events, such as those we have been using in our main menu
    and elsewhere.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 单括号包围的序列表示内置事件类型。双括号用于自定义事件，例如我们在主菜单和其他地方使用的事件。
- en: Managing focus and grab
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理焦点和抓取
- en: '**Focus** refers to the widget or window that is currently receiving keyboard
    input. Widgets can also **grab focus**, preventing mouse movements or keystrokes
    outside their bounds.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**焦点**指的是当前接收键盘输入的控件或窗口。控件也可以**抓取焦点**，防止鼠标在其边界之外移动或按键。'
- en: 'Tkinter gives us these widget methods for managing focus and grab, some of
    which are useful for running tests:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter为我们提供了这些用于管理焦点和抓取的控件方法，其中一些对于运行测试很有用：
- en: '| Method | Description |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `focus_set()` | Focuses the widget whenever its window next gains focus |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `focus_set()` | 当其窗口下次获得焦点时聚焦控件 |'
- en: '| `focus_force()` | Focuses a widget and the window it''s in, immediately |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `focus_force()` | 立即聚焦控件及其所在的窗口 |'
- en: '| `grab_set()` | The widget grabs all events for the application |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `grab_set()` | 控件抓取应用程序的所有事件 |'
- en: '| `grab_set_global()` | The widget grabs all screen events |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `grab_set_global()` | 控件抓取屏幕上的所有事件 |'
- en: '| `grab_release()` | The widget relinquishes its grab |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `grab_release()` | 控件放弃其抓取 |'
- en: In a test environment, we can use these methods to make sure that our generated
    keyboard and mouse events are going to the correct widget or window.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境中，我们可以使用这些方法来确保我们生成的键盘和鼠标事件将发送到正确的控件或窗口。
- en: Most of the time the `focus_set()` method will be adequate, but depending on
    the behavior of your application and your operating system's windowing environment,
    you may need the more extreme enforcement of `focus_force()` or `grab_set()`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候`focus_set()`方法就足够了，但根据您应用程序的行为和操作系统窗口环境，您可能需要更极端的强制措施，如`focus_force()`或`grab_set()`。
- en: Getting widget information
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取控件信息
- en: Tkinter widgets have a set of `winfo_` methods that give us access to information
    about the widget. While the available functionality leaves much to be desired,
    these methods include some information we can use in tests to provide feedback
    about the state of a given widget.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter控件有一组`winfo_`方法，使我们能够访问有关控件的信息。虽然可用的功能还有很多不足，但这些方法包括一些我们可以在测试中使用的信息，以提供有关给定控件状态的反馈。
- en: 'The following are a few `winfo_` methods that we will find useful:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些我们将发现很有用的`winfo_`方法：
- en: '| Method | Description |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `winfo_height()`, `winfo_width()` | Get the height and width of the widget
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_height()`、`winfo_width()` | 获取控件的高度和宽度 |'
- en: '| `winfo_children()` | Get a list of child widgets |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_children()` | 获取子控件的列表 |'
- en: '| `winfo_geometry()` | Get the size and location of the widget |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_geometry()` | 获取控件的大小和位置 |'
- en: '| `winfo_ismapped()` | Determine whether the widget is mapped (that is, it''s
    been added to a layout using a geometry manager) |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_ismapped()` | 确定控件是否已映射（即，它已被添加到布局中，使用几何管理器） |'
- en: '| `winfo_viewable()` | Determine whether a widget is viewable (that is, it
    and all its parents have been mapped) |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_viewable()` | 确定控件是否可见（即，它及其所有父控件都已映射） |'
- en: '| `winfo_x()`, `winfo_y()` | Get the *x* or *y* coordinate of the widget''s
    top-left corner |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_x()`、`winfo_y()` | 获取控件左上角的*x*或*y*坐标 |'
- en: Writing tests for our application
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序编写测试
- en: Let's put our knowledge of `unittest` and Tkinter to work and write some automated
    tests for our application. To get started, we need to create a test module. Make
    a directory called `test` inside the `abq_data_entry` package, and create the
    customary empty `__init__.py` file inside. We'll create all of our test modules
    inside this directory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们对`unittest`和Tkinter的知识运用起来，为我们的应用程序编写一些自动化测试。要开始，我们需要创建一个测试模块。在`abq_data_entry`包内创建一个名为`test`的目录，并在其中创建传统的空`__init__.py`文件。我们将在该目录内创建所有的测试模块。
- en: Testing the data model
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试数据模型
- en: Our `CSVModel` class is fairly self-contained apart from its need to read and
    write files. We'll need to mock out this functionality so that the tests don't
    disturb the filesystem. Since file operations are one of the more common things
    that need to be mocked out in a test, the `mock` module provides `mock_open()`,
    a `Mock` subclass ready-made to replace Python's `open()` method. When called,
    a `mock_open` object returns a mock file handle object, complete with support
    for the `read()`, `write()`, and `readlines()` methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了需要读取和写入文件之外，我们的`CSVModel`类相当独立。我们需要模拟这一功能，以便测试不会干扰文件系统。由于文件操作是在测试中需要模拟的更常见的事情之一，因此`mock`模块提供了`mock_open()`，这是一个现成的`Mock`子类，用于替换Python的`open()`方法。当调用时，`mock_open`对象返回一个模拟文件句柄对象，并支持`read()`、`write()`和`readlines()`方法。
- en: 'Create a new file in the `test` directory called `test_models.py`. This will
    be our test module for our data model classes. Begin it with some module imports:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test`目录中创建一个名为`test_models.py`的新文件。这将是我们的数据模型类测试模块。以一些模块导入开始：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In addition to the `models` module, we'll need `TestCase` and `mock`, of course,
    as well as the `Path` class since our `CSVModel` works with `Path` objects internally.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`models`模块，我们还需要`TestCase`和`mock`，当然，以及`Path`类，因为我们的`CSVModel`内部使用`Path`对象。
- en: 'Now, we''ll begin a test case for the `CSVModel` class, like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始对`CSVModel`类进行测试用例，如下所示：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the `setUp()` method for this case, we've created two mocked data files.
    The first contains a CSV header and two rows of CSV data, while the second is
    empty. The `mock_open` object's `read_data` argument allows us to specify a string
    that will be returned when code attempts to read data from it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在此案例的`setUp()`方法中，我们创建了两个模拟数据文件。第一个包含CSV标题和两行CSV数据，而第二个是空的。`mock_open`对象的`read_data`参数允许我们指定当代码尝试从它读取数据时将返回的字符串。
- en: We've also created two `CSVModel` objects, one with a filename of `file1` and
    the other with a filename of `file2`. It's worth mentioning that there's no actual
    connection between our models and our `mock_open` objects; the filenames given
    are arbitrary, since we won't actually be opening a file, and the choice of which
    `mock_open` object we use will be made in our test methods using `patch()`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了两个`CSVModel`对象，一个文件名为`file1`，另一个文件名为`file2`。值得一提的是，我们的模型和`mock_open`对象之间没有实际的联系；给定的文件名是任意的，因为我们实际上不会打开文件，而选择使用哪个`mock_open`对象将在我们的测试方法中使用`patch()`来决定。
- en: Testing file reading in get_all_records()
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`get_all_records()`中测试文件读取
- en: 'To see how we use these, let''s start a test for the `get_all_records()` method
    as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们如何使用这些，让我们从对`get_all_records()`方法的测试开始，如下所示：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since our filenames don't actually exist, we're using the decorator version
    of `patch()` to replace `Path.exists()` with a mock function that always returns
    `True`. We can later change the `return_value` value property of this object if
    we want to test a scenario where the file doesn't exist.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的文件名实际上不存在，我们使用`patch()`的装饰器版本将`Path.exists()`替换为始终返回`True`的模拟函数。如果我们想测试文件不存在的情况，我们可以稍后更改此对象的`return_value`属性。
- en: 'To run the `get_all_records()` method against one of our `mock_open` objects,
    we''ll use the context manager form of `patch()` as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要针对我们的一个`mock_open`对象运行`get_all_records()`方法，我们将使用`patch()`的上下文管理器形式，如下所示：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Any call to `open()` in `models.py` initiated by code inside this context manager
    block will be replaced by our `mock_open` object, and the file handle returned
    will contain the `read_data` string we specified.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文管理器块内的代码中，对`open()`的任何调用都将由我们的`mock_open`对象替换，返回的文件句柄将包含我们指定的`read_data`字符串。
- en: 'Now we can start making assertions about the records that have been returned:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始对返回的记录进行断言：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we're checking that `records` contains two lines (since our read data
    contained two CSV records), that it's a `list` object, and that its first member
    is a `dict` object (or a subclass of `dict`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查`records`包含两行（因为我们的读取数据包含两个CSV记录），它是一个`list`对象，并且它的第一个成员是一个`dict`对象（或`dict`的子类）。
- en: 'Next, let''s make sure all our fields made it through and that our Boolean
    conversion worked:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确保所有字段都已通过，并且布尔转换已成功：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By iterating over a tuple of all our field names, we can check that all our
    fields are present in the record output. Don't be afraid to use loops in a test
    this way to check a large amount of content quickly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遍历所有字段名称的元组，我们可以检查记录输出中是否包含所有我们的字段。不要害怕在测试中使用这种方式来快速检查大量内容。
- en: A `Mock` object can do more than just stand in for another class or function;
    it also has its own assertion methods that can tell us if it's been called, how
    many times, and with what arguments.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mock`对象不仅可以代替另一个类或函数；它还具有自己的断言方法，可以告诉我们它是否被调用、调用了多少次以及调用的参数。'
- en: 'For example, we can check our `mock_open` object to make sure it was called
    with the expected arguments:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以检查我们的`mock_open`对象以确保它以预期的参数被调用：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`assert_called_with()` takes any number of positional and keyword arguments
    and checks if the last call to the mock object included those exact arguments.
    We expected `file1_open()` to be called with a `Path` object containing the filename
    `file1`, a mode of `r`, a `newline` set to a blank string, and an `encoding` value
    of `utf-8`. By confirming that a mocked function was called with the correct arguments,
    and assuming the correctness of the real function (the built-in `open()` function,
    in this case), we can avoid having to test the actual outcome.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_called_with()`接受任意数量的位置参数和关键字参数，并检查模拟对象的最后调用是否包含那些确切的参数。我们期望`file1_open()`以包含文件名`file1`的`Path`对象、模式为`r`、`newline`设置为空字符串以及`encoding`值为`utf-8`的方式被调用。通过确认模拟函数是否以正确的参数被调用，并假设真实函数（在这种情况下是内置的`open()`函数）的正确性，我们可以避免测试实际的结果。'
- en: Note that the order in which the keyword arguments are passed does not matter
    for this method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于此方法，关键字参数的传递顺序并不重要。
- en: Testing file saving in save_record()
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`save_record()`中测试文件保存
- en: 'To demonstrate how to test file-writing with `mock_open`, let''s test `save_record()`.
    Begin by creating a test method that defines some data:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用`mock_open`测试文件写入，让我们测试`save_record()`。首先创建一个测试方法，定义一些数据：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method begins by once again mocking `Path.exists` and creating a dictionary
    of data, and the same data represented as a row of CSV data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先再次模拟`Path.exists`并创建一个数据字典，以及以CSV数据行表示的相同数据。
- en: You may be tempted to generate either the record or its expected CSV output
    using code, but it's always better to stick to literal values in tests; doing
    so makes the expectations of the test explicit and avoids logic errors in your
    tests.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想通过代码生成记录或其预期的CSV输出，但始终最好在测试中坚持使用字面值；这样做使得测试的期望变得明确，并避免测试中的逻辑错误。
- en: 'Now, for our first test scenario, let''s simulate writing to an empty but existing
    file by using `file2_open` and `model2` as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们的第一个测试场景，让我们通过使用`file2_open`和`model2`来模拟向一个空但存在的文件写入：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Setting our `mock_path_exists.return_value` to `True` to tell our method that
    the file already exists, we then patch over `open()` with our second `mock_open`
    object (the one representing an empty file) and call the `CSVModel.save_record()`
    method. Since we passed in a record with no row number (which indicates a record
    insert), this should result in our code trying to open `file2` in append mode
    and writing in the CSV-formatted record.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的`mock_path_exists.return_value`设置为`True`以告诉我们的方法文件已经存在，然后我们用我们的第二个`mock_open`对象（表示一个空文件）覆盖`open()`，并调用`CSVModel.save_record()`方法。由于我们传递了一个没有行号的记录（这表示记录插入），这应该导致我们的代码尝试以追加模式打开`file2`并写入CSV格式的记录。
- en: '`assert_called_with()` will test that assumption as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_called_with()`将按以下方式测试这个假设：'
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While this method can tell us that `file2_open` was called with the expected
    parameters, how do we access its actual file handler so that we can see what was
    written to it?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此方法可以告诉我们`file2_open`是否以预期的参数被调用，但我们如何访问其实际的文件句柄，以便我们可以看到写入的内容？
- en: 'It turns out we can just call our `mock_open` object and retrieve the mock
    file handle object, like so:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 结果我们只需调用我们的`mock_open`对象并检索模拟的文件句柄对象，如下所示：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once we have the mock file handle (which is itself a `Mock` object), we can
    run test methods on its `write()` member to find out if it was called with the
    CSV data as expected. In this case, the file handle's `write()` method should
    have been called with the CSV-format record string.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了模拟的文件句柄（它本身也是一个`Mock`对象），我们就可以在其`write()`成员上运行测试方法，以找出它是否以预期的CSV数据被调用。在这种情况下，文件句柄的`write()`方法应该被调用，带有CSV格式的记录字符串。
- en: 'Let''s do a similar set of tests, passing in a row number to simulate a record
    update:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一组类似的测试，传递一个行号来模拟记录更新：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Checking that our update was done correctly presents a problem: `assert_called_with()`
    only checks the *last* call made to the mock function. When we update our CSV
    file, the entire CSV file is updated, with one `write()` call per row. We can''t
    just check that the last call was correct; we need to make sure the `write()`
    calls for *all* the rows were correct. To accomplish this, `Mock` contains a method
    called `assert_has_calls()`, which we can use to test the history of calls made
    to the object.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的更新是否正确完成会带来问题：`assert_called_with()` 只检查对模拟函数的最后调用。当我们更新 CSV 文件时，整个 CSV
    文件都会更新，每行有一个 `write()` 调用。我们不能仅仅检查最后一个调用是否正确；我们需要确保所有行的 `write()` 调用都是正确的。为了完成这个任务，`Mock`
    包含一个名为 `assert_has_calls()` 的方法，我们可以使用它来测试对对象进行的调用历史。
- en: 'To use it, we need to create a list of `Call` objects. Each `Call` object represents
    a call to the mock object. We create `Call` objects using the `mock.call()` function
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们需要创建一个 `Call` 对象列表。每个 `Call` 对象代表对模拟对象的调用。我们使用 `mock.call()` 函数创建 `Call`
    对象，如下所示：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The arguments to `mock.call()` represent the arguments that should have been
    passed to the function call, which in our cases should just be single strings
    of CSV row data. The list of `Call` objects we pass to `assert_has_calls()` represents
    each call that should have been made to the mocked file handle's `write()` method,
    *in order*. The `assert_has_calls()` method's `in_order` argument can also be
    set to `False`, in which case the order won't need to match. In our case, order
    matters, since a wrong order would result in a corrupt CSV file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock.call()` 的参数代表应该传递给函数调用的参数，在我们的情况下应该是单行的 CSV 数据字符串。我们传递给 `assert_has_calls()`
    的 `Call` 对象列表代表了对模拟文件句柄的 `write()` 方法应该进行的每个调用，*按顺序*。`assert_has_calls()` 方法的
    `in_order` 参数也可以设置为 `False`，在这种情况下，顺序不需要匹配。在我们的情况下，顺序很重要，因为错误的顺序会导致 CSV 文件损坏。'
- en: More tests on the models
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对模型进行更多测试
- en: Testing the remainder of the `CSVModel` class and the `SettingsModel` class
    methods should be essentially along the same lines as these two methods. A few
    more tests are included in the sample code, but see if you can come up with some
    of your own as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `CSVModel` 类和 `SettingsModel` 类的其他方法应该与这两个方法基本相同。示例代码中包含了一些额外的测试，但请尝试自己想出一些。
- en: Testing our Application object
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的应用程序对象
- en: We've implemented our application as a Tk object that acts not only as a main
    window but also as a controller, patching together models and views defined elsewhere
    in the application. As you may expect, then, `patch()` is going to figure heavily
    into our testing code as we mock out all of those other components to isolate
    the `Application` object.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用程序实现为一个 Tk 对象，它不仅作为主窗口，还作为控制器，将应用程序中其他地方定义的模型和视图连接起来。因此，正如你所期望的，`patch()`
    将在我们的测试代码中发挥重要作用，因为我们模拟了所有其他组件以隔离 `Application` 对象。
- en: 'Open a new file under the `test` directory called `test_application.py`, and
    we''ll begin with our imports:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `test` 目录下打开一个名为 `test_application.py` 的新文件，我们将从导入开始：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s begin our test case class like so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以这种方式开始我们的测试用例类：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As our `TestApplication` class will be using mocks in place of our data and
    settings models, we've created some class properties here to store samples of
    the data that `Application` expects to retrieve from those models. The `setUp()`
    method is going to patch out all the external classes with mocks, configure the
    mocked models to return our sample data, and then create an `Application` instance
    that our tests can use.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 `TestApplication` 类将使用模拟数据代替数据和设置模型，我们在其中创建了一些类属性来存储 `Application` 预期从这些模型检索的数据样本。`setUp()`
    方法将使用模拟替换所有外部类，配置模拟模型以返回我们的样本数据，然后创建一个 `Application` 实例，以便我们的测试可以使用。
- en: Note that while the Boolean values in the test records are `bool` objects, the
    numeric values are strings. This is actually how `CSVModel` returns the data,
    since no actual data type conversion is done at this point in the model.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然测试记录中的布尔值是 `bool` 对象，但数值是字符串。实际上，`CSVModel` 就是这么返回数据的，因为在模型的这个点上没有进行实际的数据类型转换。
- en: 'Now, let''s create our `setUp()` method, which looks like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的 `setUp()` 方法，它看起来像这样：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we''ve created a `with` block using seven `patch()` context managers,
    one for each class, method, or function that we''re mocking out, including:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用七个 `patch()` 上下文管理器创建了一个 `with` 块，每个类、方法或函数都有一个，包括：
- en: The CSV and Settings models. These have been patched out with aliases, so that
    we can configure them to return the appropriate data.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV 和设置模型。这些已经被别名替换，这样我们就可以配置它们以返回适当的数据。
- en: The `show_login()` method, whose return value we hard-code to `True` so login
    will always succeed. Note that if we were going to write full test coverage of
    this class, we'd want to test this function too, but for now we'll just mock it
    out.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show_login()` 方法，我们将返回值硬编码为 `True` 以确保登录始终成功。注意，如果我们打算编写这个类的完整测试覆盖率，我们还想测试这个函数，但现在我们只是模拟它。'
- en: The record form and record list classes, since we don't want issues in those
    classes to cause errors in our `Application` test code. Those classes will have
    their own test cases, so we aren't interested in testing them in this case. We
    don't need to configure anything about them, so we have not aliased these mock
    objects.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录表和记录列表类，因为我们不希望这些类的问题导致我们的 `Application` 测试代码出现错误。这些类将有自己的测试用例，所以我们在这个案例中不感兴趣测试它们。我们不需要对它们进行任何配置，因此我们没有对这些模拟对象进行别名设置。
- en: The `Notebook` class. Without mocking this, we'd be passing `Mock` objects to
    its `add()` method, causing an unnecessary error. We can assume Tkinter classes
    work correctly, so we mock this out.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notebook` 类。如果不进行模拟，我们将在其 `add()` 方法中传递 `Mock` 对象，从而引发不必要的错误。我们可以假设 Tkinter
    类可以正常工作，因此我们模拟这一部分。'
- en: The `get_main_menu_for_os` class, since we don't want to deal with an actual
    menu object. Like the record form and record list, our menu classes will have
    their own test cases, so we are better off just taking them out of the equation
    here.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_main_menu_for_os` 类，因为我们不想处理实际的菜单对象。就像记录表和记录列表一样，我们的菜单类将有自己的测试用例，所以我们最好在这里将它们排除在外。'
- en: Since Python 3.2, you can create a block with multiple context managers by separating
    each context manager call with a comma. Unfortunately, in Python 3.9 or lower,
    you can't put them in parentheses, so we're using the comparatively ugly escaped-newline
    method of breaking this gigantic call into multiple lines. If you're using Python
    3.10 or later, you can use parentheses around your list of context managers for
    a cleaner layout.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.2 以来，您可以通过在每次上下文管理器调用之间使用逗号来创建包含多个上下文管理器的块。不幸的是，在 Python 3.9 或更低版本中，您不能将它们放在括号中，因此我们使用相对丑陋的转义换行方法将这个巨大的调用拆分成多行。如果您使用
    Python 3.10 或更高版本，您可以在上下文管理器列表周围使用括号以获得更整洁的布局。
- en: Notice that we're creating instances of our `settingsmodel` and `csvmodel` objects
    and configuring methods on the *return values* from the mock objects rather than
    the mocks themselves. Remember that our mocks are replacing the *classes*, not
    the *objects*, and it is the objects that will contain the methods our `Application`
    object will be calling. Therefore, we need to call the mocked classes to access
    the actual `Mock` object that will be used by `Application` as the data or settings
    model.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在创建 `settingsmodel` 和 `csvmodel` 对象的实例，并在模拟对象的 *返回值* 上配置方法，而不是在模拟对象本身上。记住，我们的模拟正在替换
    *类*，而不是 *对象*，并且是对象将包含 `Application` 对象将要调用的方法。因此，我们需要调用模拟类来访问 `Application` 将用作数据或设置模型的实际
    `Mock` 对象。
- en: Unlike the actual class that it stands in for, a `Mock` object called as a function
    will return the same object every time it's called. Thus, we don't have to save
    a reference to the object created by calling a mocked class; we can just call
    the mocked class repeatedly to access that object. Note, however, that a unique
    `Mock` object is created by the `Mock` *class* itself each time.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与它所替代的实际类不同，当作为函数调用的 `Mock` 对象每次调用时都会返回相同的对象。因此，我们不需要保存由调用模拟类创建的对象的引用；我们只需重复调用模拟类即可访问该对象。然而，请注意，每次
    `Mock` 类本身都会创建一个唯一的 `Mock` 对象。
- en: 'Because `Application` is a subclass of Tk, it''s a good idea for us to safely
    dispose of it after each use; even though we''re reassigning its variable name,
    the Tcl/Tk object will go on existing and cause problems with our tests. To solve
    this, create a `tearDown()` method in `TestApplication`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Application` 是 Tk 的子类，因此在使用后安全地销毁它是我们的好主意；即使我们重新分配了它的变量名，Tcl/Tk 对象仍然会存在，并可能对我们的测试造成问题。为了解决这个问题，在
    `TestApplication` 中创建一个 `tearDown()` 方法：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice the call to `app.update()`. If we don't call this before destroying `app`,
    there may be tasks in the event queue that will try to access it after it's gone.
    This won't break our code, but it will clutter up our test output with error messages.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对 `app.update()` 的调用。如果我们不在销毁 `app` 之前调用它，事件队列中可能有任务会在它消失后尝试访问它。这不会破坏我们的代码，但它会在我们的测试输出中添加错误消息。
- en: 'Now that our fixtures are taken care of, let''s write a test:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理好了我们的固定值，让我们编写一个测试：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Application._show_recordlist()` contains one line of code, which is merely
    a call to `self.notebook.select()`. Because we made `recordlist` a mock object,
    all of its members (including `select`) are also mock objects. Thus we can use
    the mock assertion methods to check that `select()` was called and with what arguments.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application._show_recordlist()` 只有一行代码，它只是调用 `self.notebook.select()`。因为我们把
    `recordlist` 设置为一个模拟对象，所以它的所有成员（包括 `select`）也都是模拟对象。因此，我们可以使用模拟断言方法来检查 `select()`
    是否被调用以及调用的参数。'
- en: 'We can use a similar technique to check `_populate_recordlist()` as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的技术来检查 `_populate_recordlist()`，如下所示：
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this case, we're also using the `assert_called()` method to see if `CSVModel.get_all_records()`
    was called, which it should have been as part of populating the recordlist. Unlike
    `assert_called_with()`, `assert_called()` merely checks to see if a function was
    called, and as such is useful for functions that take no arguments.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们还在使用 `assert_called()` 方法来查看 `CSVModel.get_all_records()` 是否被调用，它应该已经被调用来填充记录列表。与
    `assert_called_with()` 不同，`assert_called()` 只检查一个函数是否被调用，因此对于没有参数的函数来说是有用的。
- en: 'Under some circumstances, `get_all_records()` can raise an exception, in which
    case we''re supposed to show an error message box. But since we''ve mocked out
    our data model, how can we get the `Mock` object to raise an exception? The solution
    is to use mock''s `side_effect` property as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`get_all_records()` 可以引发一个异常，在这种情况下，我们应该显示一个错误消息框。但由于我们已经模拟了我们的数据模型，我们如何让
    `Mock` 对象引发一个异常呢？解决方案是使用模拟的 `side_effect` 属性，如下所示：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`side_effect` can be used to simulate more complex functionality in a mocked
    function or method. It can be set to a function, in which case the mock will run
    that function and return the results when called; it can be set to an iterable,
    in which case the mock will return the next item in the iterable each time it''s
    called; or, as in this case, it can be set to an exception, which will be raised
    when the mock is called.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`side_effect` 可以用来模拟在模拟函数或方法中的更复杂的功能。它可以设置为一个函数，在这种情况下，模拟将在被调用时运行该函数并返回结果；它可以设置为一个可迭代对象，在这种情况下，模拟将在每次被调用时返回可迭代对象中的下一个项目；或者，正如这个例子中所示，它可以设置为一个异常，当模拟被调用时将引发该异常。'
- en: 'Before we can use this, we''ll need to patch out `messagebox` as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用它之前，我们需要按照以下方式修补 `messagebox`：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This time when we call `_populate_recordlist()`, our mocked `CSVModel` object
    raises an exception, which should result in the method calling `messagebox.showerror()`.
    Since we've mocked `showerror()`, we can assert that it was called with the expected
    arguments using `assert_called_with()`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们调用 `_populate_recordlist()` 时，我们的模拟 `CSVModel` 对象引发了一个异常，这应该会导致方法调用 `messagebox.showerror()`。由于我们已经模拟了
    `showerror()`，我们可以使用 `assert_called_with()` 断言它以预期的参数被调用。
- en: Clearly, the hardest part of testing our `Application` object is patching in
    all the mocked components and making sure they behave enough like the real thing
    to satisfy `Application`. Once we've done that, writing the actual tests is fairly
    straightforward.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，测试我们的 `Application` 对象最困难的部分是修补所有模拟组件并确保它们足够像真实的东西以使 `Application` 满意。一旦我们做到了这一点，编写实际的测试就相对简单了。
- en: Testing our widgets
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的小部件
- en: 'So far, we''ve done well testing our components with `patch()`, `Mock`, and
    the default `TestCase` class, but testing our widgets module is going to present
    some new challenges. To begin with, our widgets will need a Tk instance to be
    their root window. We can create this in each case''s `setUp()` method, but this
    will slow down the tests considerably, and it isn''t really necessary to do it
    over and over again: our tests aren''t going to modify the root window, so one
    root window will suffice for each test case. To keep things running at a reasonable
    pace, we can take advantage of the `setUpClass()` method to create a single instance
    of Tk just once when the test case instance is created.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经很好地使用 `patch()`、`Mock` 和默认的 `TestCase` 类测试了我们的组件，但测试我们的小部件模块将带来一些新的挑战。首先，我们的小部件需要一个
    Tk 实例作为它们的根窗口。我们可以在每个案例的 `setUp()` 方法中创建这个实例，但这会显著减慢测试速度，而且这并不是真正必要的：我们的测试不会修改根窗口，所以每个测试用例只需要一个根窗口。为了保持测试以合理的速度运行，我们可以利用
    `setUpClass()` 方法在测试用例实例创建时只创建一个 Tk 实例一次。
- en: 'Secondly, we have a large number of widgets to test, each of which will need
    its own `TestCase` class. As a result, we''ll need to create a large number of
    test cases requiring this same Tk setup and tear down. To address this, we''ll
    create a custom `TestCase` base class to handle the root window setup and tear-down,
    then subclass it for each of our widget test cases. Open a new file under the
    `test` directory called `test_widgets.py`, and begin with this code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们有大量的小部件要测试，每个小部件都需要自己的 `TestCase` 类。因此，我们需要创建大量需要相同 Tk 设置和清理的测试用例。为了解决这个问题，我们将创建一个自定义的
    `TestCase` 基类来处理根窗口的设置和清理，然后为每个小部件测试用例子类化它。在 `test` 目录下打开一个新文件，命名为 `test_widgets.py`，并从以下代码开始：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `setUpClass()` method creates the Tk object and calls `wait_visibility()`
    just to make sure the root window is visible and completely drawn before our tests
    start working with it. We've also supplied a complementary tear-down method that
    updates the Tk instance (to finish out any events in the queue) and destroys it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUpClass()` 方法创建 Tk 对象并调用 `wait_visibility()` 以确保在测试开始工作之前，根窗口是可见的并且完全绘制。我们还提供了一个互补的清理方法，该方法更新
    Tk 实例（以完成队列中的任何事件）并销毁它。'
- en: Now, for each widget test case, we will subclass `TkTestCase` to ensure we have
    a proper testing environment for the widget.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于每个小部件测试用例，我们将子类化 `TkTestCase` 以确保我们为小部件有一个合适的测试环境。
- en: Unit testing the ValidatedSpinbox widget
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ValidatedSpinbox 小部件的单元测试
- en: '`ValidatedSpinbox` is one of the more complicated widgets we created for our
    application, so it''s a good place to start writing tests.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidatedSpinbox` 是我们为应用程序创建的较为复杂的小部件之一，因此它是开始编写测试的好地方。'
- en: 'Subclass the `TkTestCase` class to create a test case for `ValidatedSpinbox`
    as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `TkTestCase` 类子类化以创建 `ValidatedSpinbox` 的测试用例，如下所示：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our `setUp()` method creates a control variable in which to store the widget''s
    value, then creates an instance of the `ValidatedSpinbox` widget with some basic
    settings: a minimum value of `-10`, a maximum of `10`, and an increment of `1`.
    After creating it, we pack it and wait for it to become visible. For our tear-down
    method, we simply destroy the widget.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `setUp()` 方法创建一个控制变量来存储小部件的值，然后创建一个具有一些基本设置的 `ValidatedSpinbox` 小部件实例：最小值为
    `-10`，最大值为 `10`，增量值为 `1`。创建后，我们将其打包并等待其变得可见。对于我们的清理方法，我们只需销毁小部件。
- en: 'Now, let''s begin writing tests. We''ll start with a unit test of the `_key_validate()`
    method:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写测试。我们将从 `_key_validate()` 方法的单元测试开始：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this test, we're simply iterating from 0 to 9 and testing both the positive
    and negative of the number against `_key_validate()`, which should return `True`
    for all of these values.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们只是从 0 迭代到 9 并测试数字的正负值与 `_key_validate()`，它应该对所有这些值返回 `True`。
- en: Note that the `_key_validate()` method takes a lot of positional arguments,
    and most of them are redundant; it might be nice to have a wrapper method that
    makes it easier to call, since a proper test of this function will likely need
    to call it dozens of times.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `_key_validate()` 方法接受许多位置参数，其中大部分是冗余的；可能有一个包装方法来使其更容易调用会很好，因为对这个函数的适当测试可能需要调用它几十次。
- en: 'Let''s call that method `key_validate()` and add it to our `TestValidatedSpinbox`
    class as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称这个方法为 `key_validate()` 并将其添加到我们的 `TestValidatedSpinbox` 类中，如下所示：
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will make future calls to the method shorter and less error-prone. Let''s
    use this method now to test some invalid input, like so:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使未来对该方法的调用更短且更不容易出错。现在让我们使用这个方法来测试一些无效的输入，如下所示：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the first example, we're entering the letter `a`; in the second, a `1` character
    when `0.` is already in the box (resulting in a proposed value of `0.1`); in the
    third, a `0` character when `10` is in the box (resulting in a proposed value
    of `100`). All of these scenarios should fail the validation method, causing it
    to return `False`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们输入字母 `a`；在第二个例子中，当框中已有 `0.` 时输入一个 `1` 字符（导致建议值为 `0.1`）；在第三个例子中，当框中有
    `10` 时输入一个 `0` 字符（导致建议值为 `100`）。所有这些场景都应该使验证方法失败，导致它返回 `False`。
- en: Integration testing the ValidatedSpinbox widget
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试 ValidatedSpinbox 小部件
- en: In the preceding tests, we weren't actually entering any data into the widget;
    we were simply calling the key validation method directly and evaluating its output.
    This is good unit testing, but as a test of our widget's functionality it isn't
    very satisfying, is it? Since our custom widget is so deeply interactive with
    Tkinter's validation API, we'd like to test that we've actually interfaced with
    this API correctly. After all, *that* aspect of the code was more challenging
    than the actual logic in our validation methods.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们实际上并没有向小部件输入任何数据；我们只是直接调用键验证方法并评估其输出。这是好的单元测试，但作为对我们小部件功能性的测试，它并不令人满意，对吧？鉴于我们的自定义小部件与Tkinter的验证API深度交互，我们希望测试我们是否正确地与这个API接口。毕竟，*那个*方面的代码比我们验证方法中的实际逻辑更具挑战性。
- en: We can accomplish this by creating some integration tests that simulate actual
    user actions and then check the results of those actions. To do this cleanly,
    we'll first need to create some supporting methods.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一些模拟实际用户操作的集成测试来完成这项任务，然后检查这些操作的结果。为了干净利落地完成这项任务，我们首先需要创建一些支持方法。
- en: 'First of all, we''ll need a way to simulate typing text into the widget. Let''s
    start a new `type_in_widget()` method in the `TkTestCase` class that will do this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种方法来模拟在窗口中输入文本。让我们在`TkTestCase`类中开始一个新的`type_in_widget()`方法来完成这个任务：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first thing this method does is force the focus to the widget; recall that
    `focus_force()` gives the widget focus even if the containing window is not in
    focus; we need to use this because our test Tk window is unlikely to be in focus
    when the test is being run.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的第一步是迫使注意力集中在小部件上；回想一下，`focus_force()`即使在包含窗口没有焦点的情况下也会给小部件分配焦点；我们需要使用这个方法，因为我们的测试Tk窗口在测试运行时很可能没有焦点。
- en: 'Once we have focus, we''ll need to iterate through the characters in the string
    and translate the raw character into the appropriate key symbols for our event
    sequence. Recall that some characters, particularly symbols, must be represented
    as name strings, such as `minus` or `colon`. To make this work, we''ll need a
    way to translate between characters and their key symbols. We can do this with
    a dictionary added as a class property, like so:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得焦点，我们就需要遍历字符串中的字符，并将原始字符转换为适当的事件序列键符号。回想一下，一些字符，尤其是符号，必须表示为名称字符串，例如`minus`或`colon`。为了使这可行，我们需要一种方法在字符和它们的键符号之间进行转换。我们可以通过添加一个类属性字典来实现这一点，如下所示：
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'More key symbols can be found at [http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm](http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm),
    but these should do for now. Let''s finish the `type_in_widget()` method like
    so:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 更多键符号可以在[http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm](http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm)找到，但这些都足够了。让我们这样完成`type_in_widget()`方法：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this loop, we start by checking to see if our `char` value has a name string
    in `keysyms`. Then we generate a `KeyPress` event on the widget with the given
    character or key symbol. Note that we call `self.root.update_idletasks()` after
    generating the keypress event. This ensures that the typed characters register
    after being generated.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，我们首先检查我们的`char`值在`keysyms`中是否有名称字符串。然后我们在小部件上生成一个带有给定字符或键符号的`KeyPress`事件。请注意，我们在生成按键事件后调用`self.root.update_idletasks()`。这确保了生成的按键字符在生成后能够注册。
- en: 'In addition to simulating keyboard input, we''ll need to be able to simulate
    mouse clicks. We can create a similar method, `click_on_widget()`, for simulating
    mouse button clicks as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模拟键盘输入外，我们还需要能够模拟鼠标点击。我们可以创建一个类似的方法，`click_on_widget()`，来模拟鼠标按钮点击，如下所示：
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This method takes a widget, an `x` and `y` coordinate for the click, and optionally
    a mouse button that will be clicked (defaulting to `1`, which is the left mouse
    button). Just as we did with our keystroke method, we first force focus, generate
    our events, then update the application. The `x` and `y` coordinates for the mouse
    click specify where the widget is clicked, relative to its upper-left corner.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个小部件、一个点击的`x`和`y`坐标，以及可选的将被点击的鼠标按钮（默认为`1`，即左鼠标按钮）。就像我们处理按键方法一样，我们首先强制焦点，生成我们的事件，然后更新应用程序。鼠标点击的`x`和`y`坐标指定了相对于小部件左上角的点击位置。
- en: 'With these methods in place, return to the `TestValidatedSpinbox` class and
    write a new test:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法就绪后，回到`TestValidatedSpinbox`类并编写一个新的测试：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This method starts by clearing the widget, then simulates some valid input with
    `type_in_widget()`. Then we retrieve the value from the widget using `get()`,
    checking that it matches the expected value. Note that in these integration tests
    we'll need to clear the widget each time because we are simulating keystrokes
    in an actual widget and triggering all the side effects of that action.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先清除小部件，然后使用`type_in_widget()`模拟一些有效输入。然后我们使用`get()`从控件中检索值，检查它是否与预期值匹配。请注意，在这些集成测试中，我们需要每次都清除控件，因为我们正在模拟在真实控件中的按键操作并触发该操作的所有副作用。
- en: 'Next, let''s test some invalid input; add the following to the test method:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试一些无效输入；在测试方法中添加以下内容：
- en: '[PRE53]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This time, we've simulated typing non-numeric or out-of-range values into the
    widget and check the widget to make sure it has properly rejected the invalid
    keystrokes. In the first example, the `ValidatedSpinbox` should reject all the
    keystrokes since they are letters; in the second, only the initial `2` should
    be accepted since the subsequent `0` keystrokes would put the number out of range.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们模拟在控件中输入非数字或超出范围的值，并检查控件以确保它已正确拒绝无效的按键。在第一个例子中，`ValidatedSpinbox`应该拒绝所有按键，因为它们都是字母；在第二个例子中，只有初始的`2`应该被接受，因为随后的`0`按键会使数字超出范围。
- en: We can use our mouse click method to test the functionality of the `ValidatedSpinbox`
    widget's arrow buttons as well. To make this simpler, we could create a helper
    method in our test case class to click on the arrow we want. Of course, to click
    a particular arrow, we have to figure out how to locate that element within the
    widget.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的鼠标点击方法来测试`ValidatedSpinbox`小部件箭头按钮的功能。为了简化这个过程，我们可以在测试用例类中创建一个辅助方法来点击我们想要的箭头。当然，要点击特定的箭头，我们必须找出如何在小部件内定位该元素。
- en: 'One approach would be to just estimate a hard-coded number of pixels. In most
    default themes, the arrows are on the right side of the box, and the box is about
    20 pixels high. So, something like this method could work:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法就是简单地估计一个硬编码的像素数。在大多数默认主题中，箭头位于框的右侧，框的高度大约为20像素。因此，这种方法可能可行：
- en: '[PRE54]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This approach actually works fairly well and may be sufficient for your needs.
    However, it's a little brittle as it makes assumptions about your theme and screen
    resolution. For more complex custom widgets, you may have a hard time locating
    elements this way. What would be better is a way to find the actual coordinates
    of widget elements.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法实际上效果相当不错，可能足以满足您的需求。然而，由于它对您的主题和屏幕分辨率做出了假设，因此它有点脆弱。对于更复杂的自定义小部件，您可能很难通过这种方式定位元素。更好的方法可能是找到小部件元素的实际坐标。
- en: Unfortunately, Tkinter widgets don't offer us a way to locate the *x* and *y*
    coordinates of elements within a widget; Ttk elements, however, do offer us a
    way to see which element is at a given set of coordinates, using the `identify()`
    method. Using this, we can write a method that scans through a widget looking
    for a particular element and returns the first set of *x* and *y* coordinates
    where it can be found.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Tkinter小部件没有提供一种方法来定位小部件内元素的*x*和*y*坐标；然而，Ttk元素提供了一个使用`identify()`方法查看给定坐标集下哪个元素的方法。使用这种方法，我们可以编写一个方法，遍历小部件以查找特定元素，并返回找到的第一个*x*和*y*坐标集。
- en: 'Let''s add this as a static method to the `TkTestCase` class, like so:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个方法作为静态方法添加到`TkTestCase`类中，如下所示：
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The method begins by updating the widget's idle tasks. Without this call, it's
    possible that all the elements are not yet drawn, and `identify()` will return
    an empty string. Next, we get a list of all the *x* and *y* coordinates in the
    widget by passing its width and height into the `range()` function. We iterate
    through these lists, calling `widget.identify()` on each pixel coordinate in the
    widget. If the returned element name matches the element name we're looking for,
    we return the current coordinates as a tuple. If we make it all the way through
    the widget without returning, we raise an exception stating that the element was
    not found.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先更新小部件的空闲任务。如果没有这个调用，所有元素可能还没有被绘制，`identify()`将返回一个空字符串。接下来，我们通过将小部件的宽度和高度传递给`range()`函数来获取小部件中所有*x*和*y*坐标的列表。我们遍历这些列表，在小部件的每个像素坐标上调用`widget.identify()`。如果返回的元素名称与我们正在寻找的元素名称匹配，我们就返回当前坐标作为一个元组。如果我们遍历整个小部件而没有返回，我们将引发一个异常，指出未找到元素。
- en: Note that we add 1 to each of the *x* and *y* coordinates; that's because this
    element returns the upper-left corner coordinate of the widget. In some cases,
    clicking on these corner coordinates doesn't register as a click on the widget.
    To be sure we're actually clicking *in* the widget, we return coordinates 1 pixel
    right and down from the corner.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们对每个 *x* 和 *y* 坐标都加上了 1；这是因为该元素返回小部件的左上角坐标。在某些情况下，点击这些角落坐标不会注册为对小部件的点击。为了确保我们实际上是在小部件内部点击，我们从角落向右和向下返回
    1 像素的坐标。
- en: 'Of course, there''s a snag here: what is the name of the element we''re looking
    for? Recall from *Chapter 9*, *Improving the Look with Styles and Themes*, that
    the elements that compose a widget are determined by the theme, and that different
    themes may have completely different elements. For example, if you''re looking
    for the increment arrow element, the default theme on Windows calls it `Spinbox.uparrow`.
    The default theme on Linux, however, calls it simply `uparrow`, and the default
    theme on macOS doesn''t even have a separate element for it (both arrows are a
    single element called `Spinbox.spinbutton`)!'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里有一个问题：我们正在寻找的元素名称是什么？回想一下 *第 9 章*，*通过样式和主题改进外观*，组成小部件的元素由主题确定，不同的主题可能有完全不同的元素。例如，如果你正在寻找增加箭头元素，Windows
    上的默认主题将其称为 `Spinbox.uparrow`。然而，Linux 上的默认主题简单地将其称为 `uparrow`，而 macOS 上的默认主题甚至没有为它提供单独的元素（两个箭头都是一个名为
    `Spinbox.spinbutton` 的单个元素）！
- en: 'To address this, we need to force our test window to a specific theme so that
    we can rely on the names being consistent. In the `TestValidatedSpinbox.setUp()`
    method, we''ll add some code to force an explicit theme:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要强制我们的测试窗口使用特定的主题，这样我们就可以依赖名称的一致性。在 `TestValidatedSpinbox.setUp()`
    方法中，我们将添加一些代码来强制显式主题：
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `classic` theme should be available on all platforms, and it uses the simple
    element names `uparrow` and `downarrow` for the `Spinbox` arrow elements. We've
    added a call to `update_idletasks()` to make sure the theme changes have taken
    effect in the widget before our tests start.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`classic` 主题应在所有平台上都可用，并且它使用简单的元素名称 `uparrow` 和 `downarrow` 作为 `Spinbox` 箭头元素。我们已经添加了对
    `update_idletasks()` 的调用，以确保在测试开始之前主题更改已经在小部件中生效。'
- en: 'Now, we can write a better `click_arrow()` method for `TestValidatedSpinbox`
    that relies on element names instead of hard-coded pixel values. Add this method
    to the class:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为 `TestValidatedSpinbox` 编写一个更好的 `click_arrow()` 方法，该方法依赖于元素名称而不是硬编码的像素值。将此方法添加到类中：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Just as with our naive version, this method takes an arrow direction and a number
    of times. We use the arrow direction to build an element name, then use our `find_element()`
    method to locate the appropriate arrow inside the `ValidatedSpinbox` widget. Once
    we have the coordinates, we can use the `click_on_widget()` method we wrote to
    click on it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的原始版本一样，这个方法接受一个箭头方向和次数。我们使用箭头方向来构建元素名称，然后使用我们的 `find_element()` 方法在 `ValidatedSpinbox`
    小部件内定位适当的箭头。一旦我们有了坐标，我们就可以使用我们编写的 `click_on_widget()` 方法来点击它。
- en: 'Let''s put this method to work and test our arrow key functionality in a new
    test method:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这种方法付诸实践，并在新的测试方法中测试我们的箭头键功能：
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: By setting the value of the widget, then clicking the appropriate arrow a specified
    number of times, we can test that the arrows did their jobs according to the rules
    we created in our widget class.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置小部件的值，然后点击适当的箭头指定次数，我们可以测试箭头是否按照我们在小部件类中创建的规则完成了工作。
- en: Testing our mixin class
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的混合类
- en: 'One additional challenge we haven''t approached yet is testing our mixin class.
    Unlike our other widget classes, our mixin cannot really exist on its own: it
    depends on methods and properties found in the Ttk widget with which it''s combined.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有着手解决的一个额外挑战是测试我们的混合类。与我们的其他小部件类不同，我们的混合类不能独立存在：它依赖于与它结合的 Ttk 小部件中找到的方法和属性。
- en: One approach to testing this class would be to mix it with a `Mock` object that
    mocks out any inherited methods. This approach has merit, but a simpler (if less
    theoretically pure) approach is to subclass it with the simplest possible `Ttk`
    widget and test the resulting child class.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个类的一个方法是将它与一个 `Mock` 对象混合，该对象模拟了任何继承的方法。这种方法有其优点，但一个更简单（如果理论纯度较低）的方法是用最简单的
    `Ttk` 小部件子类化它，并测试生成的子类。
- en: 'We''ll create a test case that uses the latter approach. Start it in `test_widgets.py`,
    like so:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个使用后一种方法的测试用例。在 `test_widgets.py` 中启动它，如下所示：
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, the `setUp()` method creates just a basic child class of `ValidatedMixin`
    and `ttk.Entry` with no other modifications, then creates an instance of it.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`setUp()` 方法仅创建了一个 `ValidatedMixin` 和 `ttk.Entry` 的基本子类，没有其他修改，然后创建了其实例。
- en: 'Now let''s write a test case for the `_validate()` method, like so:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个针对 `_validate()` 方法的测试用例，如下所示：
- en: '[PRE60]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Because we're sending a key event to `_validate()`, it routes the request to
    `_key_validate()`, which simply returns `True` by default. We'll need to verify
    that `_validate()` does what is needed when `_key_validate()` returns `False`
    as well.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们向 `_validate()` 发送了一个按键事件，它将请求路由到 `_key_validate()`，该函数默认简单地返回 `True`。我们需要验证当
    `_key_validate()` 返回 `False` 时，`_validate()` 是否执行了所需操作。
- en: 'We''ll employ `Mock` to do this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `Mock` 来完成这个任务：
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: By testing that `False` is returned and that `_key_validate()` was called with
    the correct arguments, we've demonstrated that `_validate()` is properly routing
    events to the right validation methods.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试返回 `False` 并验证 `_key_validate()` 是否以正确的参数被调用，我们已经证明了 `_validate()` 正确地将事件路由到正确的验证方法。
- en: 'By updating the `event` value in args, we can check that focus-out events also
    work:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新 `args` 中的 `event` 值，我们可以检查焦点移出事件是否也正常工作：
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We've taken an identical approach here, just mocking out `_focusout_validate()`
    to make it return `False`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里采取了相同的方法，只是模拟了 `_focusout_validate()` 函数，使其返回 `False`。
- en: As you can see, once we've created our test class, testing `ValidatedMixin`
    is like testing any other widget class. There are other test method examples in
    the included source code; these should be enough to get you started with creating
    a complete test suite.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一旦我们创建了测试类，测试 `ValidatedMixin` 就像测试任何其他小部件类一样。包含的源代码中有其他测试方法示例；这些应该足以帮助你开始创建完整的测试套件。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the benefits of automated testing and the
    capabilities provided by Python's `unittest` library. You learned how to isolate
    units of code by using `Mock` and `patch()` to replace external modules, classes,
    and functions. You learned strategies for controlling Tkinter's event queue and
    simulating user input to automate tests of our GUI components, and wrote both
    unit tests and integration tests against sections of the ABQ application.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了自动化测试的好处以及 Python 的 `unittest` 库提供的能力。你学习了如何使用 `Mock` 和 `patch()` 来替换外部模块、类和函数，从而隔离代码单元。你还学习了控制
    Tkinter 事件队列和模拟用户输入以自动化测试我们的 GUI 组件的策略，并针对 ABQ 应用程序的部分编写了单元测试和集成测试。
- en: In the next chapter, we'll upgrade our backend to use a relational database.
    In the process, you'll learn about relational database design and data normalization.
    You'll also learn to work with the PostgreSQL database server and Python's `psycopg2`
    PostgreSQL interface library.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将升级我们的后端以使用关系数据库。在这个过程中，你将了解关系数据库设计和数据规范化的知识。你还将学习如何与 PostgreSQL 数据库服务器以及
    Python 的 `psycopg2` PostgreSQL 接口库一起工作。
