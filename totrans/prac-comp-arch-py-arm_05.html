<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-62" class="chapter-number" lang="en-GB"><a id="_idTextAnchor062"/>4</h1>&#13;
			<h1 id="_idParaDest-63" lang="en-GB"><a id="_idTextAnchor063"/>Crafting an Interpreter – First Steps</h1>&#13;
			<p lang="en-GB">In this chapter, we’ll take our first steps toward constructing a computer simulator by constructing a very primitive simulator that can execute only a single instruction. Once we’ve taken this step, we can move on by gradually enhancing this simulator.</p>&#13;
			<p lang="en-GB">The key topics that we’ll cover in this chapter are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Designing a minimal computer with one instruction</li>&#13;
				<li lang="en-GB">Designing a simple simulator that can decode and execute several instructions</li>&#13;
				<li lang="en-GB">The instruction set of a general-purpose computer called TC1</li>&#13;
				<li lang="en-GB">Handing bits in Python (Boolean operations)</li>&#13;
				<li lang="en-GB">Decoding an instruction in binary form into its component parts</li>&#13;
				<li lang="en-GB">Executing an instruction after it has been decoded</li>&#13;
				<li lang="en-GB">Arithmetic operations in a computer</li>&#13;
				<li lang="en-GB">Designing functions in Python</li>&#13;
				<li lang="en-GB">Branch and flow control instructions in computer instruction sets</li>&#13;
			</ul>&#13;
			<p lang="en-GB">Collectively, these topics cover three areas. Some topics expand our knowledge of Python to help us construct a simulator. Some topics introduce the instruction set of a typical digital computer that we call TC1 (TC1 simply means <em class="italic">Teaching Computer 1</em>). Some topics cover the actual design of TC1 in Python.</p>&#13;
			<p lang="en-GB">This chapter will introduce the computer simulator and look at some basic building blocks. The actual simulator will be presented in <a href="B19624_06.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a>.</p>&#13;
			<h1 id="_idParaDest-64" lang="en-GB"><a id="_idTextAnchor064"/>Technical Requirements</h1>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">You can find the programs used in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04</a>.</p>&#13;
			<h3 lang="en-GB">An ultra-primitive one-instruction computer</h3>&#13;
			<p lang="en-GB">Our first <em class="italic">one-instruction interpreter</em> demonstrates both instruction decoding and execution, which are <a id="_idIndexMarker224"/>key to all simulators. This computer has a memory with nine locations, <code>mem[0]</code> to <code>mem[8]</code>, arranged as a list of integers. The contents of the memory are preset to <code>mem = [4,6,1,2,7,8,4,4,5]</code>. The memory locations are 0 to 8 and are read left to right in the list; for example, memory location 0 contains a value of 4, location 1 contains a value of 6, and location 8 contains a value of 5.</p>&#13;
			<p lang="en-GB">The computer has an array of eight registers, <code>r[0]</code> to <code>r[7]</code>. These are specified in Python via the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
 r = [0,0,0,0,0,0,0,0]                  #. Define a list of 8 registers and set them all to 0.</pre>&#13;
			<p lang="en-GB">The single instruction we are going to execute is <code>add r[4],mem[3],mem[7]</code>. This instruction adds the contents of memory location 3 to the contents of memory location 7 and puts the sum in register 4. We have chosen to begin with a single-instruction computer because it can be expressed in a few lines of Python code and yet it performs many of the actions required of a real computer simulator.</p>&#13;
			<p lang="en-GB">We have defined this add memory to memory operation as a demonstration. It’s not part of any real computer language. Interestingly, it’s more complex than most real computer instructions because it uses memory-to-memory operations rather than register-to-register operations.</p>&#13;
			<p lang="en-GB">We are going to <a id="_idIndexMarker225"/>write the Python code necessary to read this instruction in text form and carry out the action it defines. The two shaded lines in the following code take this instruction and split it into a list of tokens that can be processed. A token is an element in an instruction (just as a sentence in English can be split into tokens that we call words). The tokens here are <code>'add'</code>, <code>'r[4]'</code>, <code>'mem[3]'</code>, and <code>'mem[7]'</code>.</p>&#13;
			<p lang="en-GB">This instruction reads the contents of <code>mem[3]</code>, which is 2; reads the contents of <code>mem[7]</code>, which is 4; adds them together to get 2 + 4 = 6; and then stores the value 6 in register 4. After this instruction has been executed, the value of register <code>r[4]</code> should be 6:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<code>mem = [4,6,1,2,7,8,4,4,5]</code>            # Create a 9-location memory. Fill with some data&#13;
r =   [0,0,0,0,0,0,0,0]                 # Create a set of 8 registers, all initialized to 0&#13;
<strong class="bold">inst   = 'add r[4],mem[3],mem[7]'</strong>       # inst is our solitary instruction, stored as a string&#13;
inst1  = inst.replace(' ',',')          # Step 1: Replace any space with a comma&#13;
inst2  = inst1.split(',')               # Step 2: Split instruction into tokens at each comma&#13;
token0 = inst2[0]                       # Step 3: Get token0 via the 'add' instruction&#13;
token1 = inst2[1]                       # Step 4: Get token1, register 'r[4]'&#13;
token2 = inst2[2]                       # Step 5: Get token2, 'mem[3]'&#13;
token3 = inst2[3]                       # Step 6: Get token3, 'mem[7]'&#13;
value1 = int(token1[2])                 # Step 7: Get the register number as an integer&#13;
value2 = int(token2[4])                 # Step 8: Get the first memory number as an integer&#13;
value3 = int(token3[4])                 # Step 9: Get the second memory number as an integer&#13;
if token0 == ‹add›:                     # Step 10: Test for an 'add' instruction&#13;
  r[value1] = mem[value2] + mem[value3]<strong class="bold"> </strong># Step 11: If ADD, then add the contents of the memory&#13;
print('Registers: ',r)</pre>&#13;
			<p lang="en-GB">The <code>inst1 = inst.replace(' ',',')</code> operation takes the instruction and replaces a space with a comma to get <code>'add r[4],mem[3],mem[7]'</code>.This is now a string with the tokens separated by commas.</p>&#13;
			<p lang="en-GB">The next step <a id="_idIndexMarker226"/>is to create a list of tokens so that we can access the individual components of the instruction. The effect of <code>inst2 = inst1.split(',')</code> is to create a list of strings:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
inst2 = ['add', 'r[4]', 'mem[3]', 'mem[7]']</pre>&#13;
			<p lang="en-GB">The <code>split()</code> method takes a string and creates a list of strings using the delimiter specified as a parameter. If <code>y = x.split('!')</code>, the value of <code>y</code> is a list of strings and the separator is <code>!</code>. An example of the use of <code>split()</code> is shown here:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
&gt;&gt;&gt; x = 'asssfg! !   !,!!rr'&#13;
&gt;&gt;&gt; x&#13;
'asssfg! !   !,!!rr'&#13;
&gt;&gt;&gt; y = x.split('!')&#13;
&gt;&gt;&gt; y&#13;
['asssfg', ' ', '   ', ',', '', 'rr']</pre>&#13;
			<p lang="en-GB">The <code>token2 = inst2[2]</code> line gives <code>token2 = 'mem[3]'</code>; that is, the fourth token.</p>&#13;
			<p lang="en-GB">The <code>value2 = int(token2[4])</code> line gives <code>value2 = 3</code> because the second slice is the 3 in the <code>'mem[3]'</code> string. Note that we use the <code>int()</code> function to convert the characters 4, 3, and 7 into integer values. When going from strings to numeric operations, you have to remember to convert between character and integer types.</p>&#13;
			<p lang="en-GB">If we execute this program, we get the following output:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Registers:  [0, 0, 0, 0, <strong class="bold">6</strong>, 0, 0, 0]    Output from the program. The correct value is in r4</pre>&#13;
			<p lang="en-GB">Now that we’ve <a id="_idIndexMarker227"/>introduced the fundamental components of a simulator, the next step is to construct a computer that can handle more instructions, albeit a tiny subset of typical operations. However, this is a subset that includes all categories of real computer operations.</p>&#13;
			<h1 id="_idParaDest-65" lang="en-GB"><a id="_idTextAnchor065"/>Building a simple computer interpreter in Python</h1>&#13;
			<p lang="en-GB">We can take the concept of a simulator a step further and execute a program with multiple instructions <a id="_idIndexMarker228"/>using the concepts we just developed. Consecutive instructions are executed by reading them from program memory, one by one, and using a program counter to keep track of where we are in the program.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Please be aware <a id="_idIndexMarker229"/>of a possible source of confusion when we refer to a <em class="italic">program</em>. We are writing a program in the high-level language Python to simulate a computer. That simulated computer runs a program written in assembly language. Consequently, the term program can refer to two different entities. It should be clear from the context which one we are referring to.</p>&#13;
			<p lang="en-GB">Note that pseudocode is not a computer language, but a method of expressing a computer algorithm in almost plain English. So, a piece of pseudocode can represent either a high-level language such as Python or an assembly language.</p>&#13;
			<p lang="en-GB">In the following example, the source program of assembly language instructions is expressed as a Python list, where each instruction is a string: </p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
prog=['LDRL r0 0','LDRL r1 0','ADDL r1 r1 1','ADD r0 r0 r1','CMPL r1 10', \&#13;
     'BNE 2','STOP']</pre>&#13;
			<p lang="en-GB">The effect of these instructions is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
LDRL r0 0           Load r0 with literal 0&#13;
ADDL r1 r1 1        Add 1 to r1 and put the result in r1&#13;
ADD  r0 r0 r1       Add r1 to r0 and put the result in r0&#13;
CMPL r1 10          Compare the contents of r1 with literal 10&#13;
BNE  2              Branch to instruction 2 if the last result is not 0&#13;
STOP                Stop</pre>&#13;
			<p lang="en-GB">To simplify the Python code, we’ve used spaces as separators – for example, <code>LDRL r0,0</code> is written as <code>LDRL </code><code>r0 0</code>.</p>&#13;
			<p lang="en-GB">Real computers store assembly language instructions as strings of 32- or 64-bit binary numbers. We’re going to directly execute the assembly language instructions from the text string to avoid having to translate text into binary and then interpret the binary as instructions. Here, we have one goal: to demonstrate how a program is executed.</p>&#13;
			<p lang="en-GB">The computer <a id="_idIndexMarker230"/>on which the preceding assembly-level code runs has only a handful of instructions, although it is very easy to add extra instructions. Throughout this <a id="_idIndexMarker231"/>text, the term <em class="italic">opcode</em> or operation code indicates the binary code (or text version) of an assembly language instruction such as <code>ADD</code> or <code>BNE</code>. The structure of the simulator program in pseudocode is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
prog=['LDRL r0 0','LDRL r1 0','ADDL r1 r1 1','ADD r0 r0 r1', \&#13;
      'CMPL r1 10','BNE 2','STOP']&#13;
Define and initialize variables (PC, registers, memory)&#13;
while run == True:&#13;
   read instruction from prog&#13;
   point to next instruction (increment program counter)&#13;
   split instruction into fields (opcode plus operands)&#13;
   if   first field = op-code1 get operands and execute&#13;
   elif first field = op-code2 get operands and execute&#13;
   elif first field = op-code3 . . .&#13;
   . . .</pre>&#13;
			<pre class="source-code">   else declare an error if no instruction matches.</pre>&#13;
			<p lang="en-GB">This assembly language program, <code>prog</code> (provided as a list in the simulator code), uses a conditional branch, <code>BNE 2</code>, to jump back to instruction 2 if the previous operation result was not 0. The assembly language version in the Python program in the following section uses a symbolic name, <code>Loop</code>, to indicate the target of the branch, but the actual code uses a literal 2. We will look at how symbolic names such as <code>Loop</code> are handled later.</p>&#13;
			<h2 id="_idParaDest-66" lang="en-GB"><a id="_idTextAnchor066"/>Python code for a primitive simulator</h2>&#13;
			<p lang="en-GB">The following is <a id="_idIndexMarker232"/>the Python code for this simulator. The initial series of comments on lines 0 to 6 show the assembly language pro :</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
#                                 @ Test fetch/execute cycle&#13;
#0       LDRL r0 0                @ Load register r0 with 0 (the sum)&#13;
#1       LDRL r1 0                @ Load register r1 with 0 (the counter)&#13;
#2 Loop  ADDL r1 r1 1             @ REPEAT Increment counter in r1. Loop address = 2&#13;
#3       ADD  r0 r0 r1            @ Add the count to the sum in r0&#13;
#4       CMPL r1 10               @ Compare the count with 10&#13;
#5       BNE  Loop                @ Branch back to Loop until all numbers added (BNE 2)&#13;
#6       STOP                     @ Terminate execution&#13;
prog=['LDRL r0 0','LDRL r1 0','ADDL r1 r1 1','ADD r0 r0 r1','CMPL r1 10', \&#13;
      'BNE 2','STOP']&#13;
r = [0] * 8                       # Initialize r[0], r[1], ... r[7] and initialize to 0&#13;
z = 0                             # Z is zero flag: if a compare result is 0, z = 1&#13;
run = True                        # Run flag True to execute&#13;
pc = 0                            # Pc is program counter, initially 0&#13;
while run == True:                # The fetch/execute loop&#13;
    inst = prog[pc]               # Read next instruction from memory&#13;
    oldPC = pc                    # Save the old value of the the pc (program counter)&#13;
    pc = pc + 1                   # Point to the next instruction&#13;
    inst = inst.split(' ')        # Split divides the instruction into tokens (separate fields)&#13;
    if inst[0] == 'ADD':          # Test for ADD rd,rS1,rS2 instruction&#13;
        rd  = int(inst[1][1])     # Get dest, source 1 and source 2&#13;
        rS1 = int(inst[2][1])&#13;
        rS2 = int(inst[3][1])&#13;
        r[rd] = r[rS1] + r[rS2]   # Add reg 1 and 2 sum in destination register&#13;
    elif inst[0] == 'ADDL':       # Test for ADD literal instruction, ADDL&#13;
        rd  = int(inst[1][1])     # If found, get destination register&#13;
        rS1 = int(inst[2][1])     # Now get source 1 register&#13;
        literal =  int(inst[3])   # Now get the literal&#13;
        r[rd] = r[rS1] + literal  # Add reg 1 and literal&#13;
    elif inst[0] == 'BNE':        # Test for branch on not zero&#13;
        if z == 0:                # If z is 0 (last register not zero)&#13;
           pc = int(inst[1])      # Get branch destination from operation&#13;
    elif inst[0] == 'CMPL':       # Test register for equality with a literal&#13;
        z = 0                     # Set z flag to 0 (assume not equal)&#13;
        rVal = r[int(inst[1][1])] # Register value&#13;
        intVal = int(inst[2])     # Literal value&#13;
        if rVal == intVal: z = 1  # If reg value =s literal, z=1&#13;
    elif inst[0] == 'LDRL':       # Test for load literal into register operation&#13;
        rd = int(inst[1][1])      # Get destination register&#13;
        data = int(inst[2])       # Test literal value&#13;
        r[rd] = data              # Store literal in destination register&#13;
    elif inst[0] == 'STOP':       # Test for STOP instruction&#13;
        run = False               # If STOP found, then set run flag to False&#13;
        print('End of program reached')&#13;
    else:                         # If we end up here, not a valid instruction&#13;
        run = False               # So set run flag to False and stop&#13;
        print('Error: illegal instruction ',inst)&#13;
    print('PC = ',oldPC,'r0 = ',r[0],'r1 = ',r[1],'z = ',z)  # Print results&#13;
                                  # Repeat loop until Run = False</pre>&#13;
			<p lang="en-GB">The interesting <a id="_idIndexMarker233"/>part of the code is extracting the operands from the instruction. Consider the <code>ADDL r1 r2 3</code> instruction, which means add a literal to the source register and put the sum in the destination register. The destination register is <code>r1</code>, the source register is <code>r2</code>, and the literal is <code>3</code>.</p>&#13;
			<p lang="en-GB">The Python <code>inst = inst.split(' ')</code> operation converts a string into a list of substrings using a space as a separator. Therefore, the new value of <code>inst</code> is the following list:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
inst =  ['ADDL', 'r1', 'r2', '3'] # An instruction converted into a list of substrings</pre>&#13;
			<p lang="en-GB">We can now examine the four fields of this list; for example, <code>inst[0] = 'ADDL'</code> gives us the actual instruction mnemonic.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Suppose we want to get the contents of the source register, <code>r2</code>. The source register is in the third position in the list at <code>['ADDL', 'r1', 'r2', '3']</code>; that is, <code>inst[2]</code>. Let’s write <code>rS1 = inst[2]</code>. The value of <code>rS1</code> is <code>'r2'</code>.</p>&#13;
			<p lang="en-GB">We want the register number (that is, 2) as an integer, so we have to get the second character of r2 and convert it into an integer. We can do this in the following way:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
rS1 = int(rS1[1])              # get second character of the rS1 string and convert it into an integer</pre>&#13;
			<p lang="en-GB">We can combine these two expressions into one as follows.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<code>rS1 = int(inst[2]</code>[1]<code>)</code>        # inst[2][1], which gets character 1 of substring 2.</pre>&#13;
			<p lang="en-GB">The tiny computer we have created executed only five different instructions, but it includes many <a id="_idIndexMarker234"/>of the most important components of a real computer. This computer directly executes instructions from their assembly language form, rather than from their binary code. The next step is to look a little more closely at instruction sets before we can build a more realistic machine.</p>&#13;
			<p lang="en-GB">Having constructed a simulator, the next step is to look at the type of instructions a computer can execute.</p>&#13;
			<p lang="en-GB">In the next section, we will develop an instruction set for the TC1 computer. As well as providing a practical example of instruction set design, we will demonstrate how instructions are divided into multiple fields and each field supplies some information about the current instruction.</p>&#13;
			<h2 id="_idParaDest-67" lang="en-GB"><a id="_idTextAnchor067"/>The TC1 instruction set</h2>&#13;
			<p lang="en-GB">In this section, we will <a id="_idIndexMarker235"/>introduce the key component of our demonstration computer: its instruction set. This computer, TC1, has many <a id="_idIndexMarker236"/>of the functions of a real computer and is easy to understand and modify. We will begin by introducing the TC1 instruction set encoding.</p>&#13;
			<p lang="en-GB">To simplify this, we can use separate programs and data memories. This departure from the traditional von Neuman model allows us to have a 32-bit program memory and a 16-bit data memory. Moreover, we don’t have to worry about accidentally putting data in the middle of the program area.</p>&#13;
			<p lang="en-GB">A typical instruction has several fields; for example, operation code, registers, and literals (that is, constants). However, the number of bits in each field must add up to the total length of the instruction.</p>&#13;
			<p lang="en-GB">Modern computers normally employ different formats for each class of instruction. This optimizes the allocation of op-codes to bits; for example, a branch instruction may have a 4-bit opcode and a 28-bit literal field, whereas a data-processing instruction may have a 17-bit opcode and three 5-bit register-select fields.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">For the sake of simplicity, the TC1 computer has a single, fixed format. All instructions have the same number of fields, and fields are the same size for each instruction. An instruction, as shown in <em class="italic">Figure 4</em><em class="italic">.1</em>, is made up of an operation <em class="italic">class</em> plus an opcode, three register fields, and a literal field. <em class="italic">Figure 4</em><em class="italic">.1</em> shows the opcode field as 7 bits, with a 2-bit opcode class and a 5-bit actual opcode.</p>&#13;
			<p lang="en-GB">The structure of this instruction format is inefficient because if an instruction does not access a register, the three register select fields are wasted. In a three-register instruction such as ADD rd,rS1,rS2, the rd register is the destination, rS1 is source register 1, and rS2 is source register 2:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_4.01_B19624.jpg" alt="Figure 4.1 – TC1 instruction format (RISC style)" width="1109" height="282"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – TC1 instruction format (RISC style)</p>&#13;
			<p lang="en-GB">We devote 16 bits to the literal field so that we can load a constant into memory with a single instruction. That leaves 32 - 16 = 16 bits to allocate to all the other fields.</p>&#13;
			<p lang="en-GB">TC1 has a three-register format, which is typical of load and store computers such as ARM and MIPS. If we have eight registers, it takes 3 x 3 = 9 bits to specify all three registers. After allocating 16 bits to the literal and 9 bits to the register selection, we are left with 32 - (16 + 9) = 7 bits to specify up to 128 different possible instructions (27 = 128).</p>&#13;
			<p lang="en-GB">The opcode field itself is divided into four categories or classes, which take two bits, leaving 7- 2 = 5 for the instructions in each category. <em class="italic">Table 4.1</em> defines the categories (class) of instructions:</p>&#13;
			<table id="table001-3" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="IMG---Figure" lang="en-GB"><strong class="bold CharOverride-1">Class</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="IMG---Figure ParaOverride-1" lang="en-GB"><strong class="bold CharOverride-2">Group</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="bold">Comments</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure" lang="en-GB">0 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure ParaOverride-1" lang="en-GB">Special operation</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure ParaOverride-1" lang="en-GB">Operations that perform functions such as <code>STOP</code> or read the keyboard</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure" lang="en-GB">0 1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure ParaOverride-1" lang="en-GB">Data transfer</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure ParaOverride-1" lang="en-GB">Operations that copy data from one place to another</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure" lang="en-GB">1 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure ParaOverride-1" lang="en-GB">Data processing</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure ParaOverride-1" lang="en-GB">Arithmetic and logic data-processing operations</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure" lang="en-GB">1 1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure ParaOverride-1" lang="en-GB">Flow control</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="IMG---Figure ParaOverride-1" lang="en-GB">Operations that control the sequencing of instructions, such as <code>BEQ</code></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.1 – TC1 instruction classes</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><em class="italic">Table 4.2</em> illustrates the <a id="_idIndexMarker237"/>TC1 instruction set. The first column (<code>01 00001</code> loads a register with the contents of a memory location. The leftmost two bits are separated to indicate the instruction group:</p>&#13;
			<table id="table002-3" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB"><strong class="bold">Binary Code</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB"><strong class="bold">Operation</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB"><strong class="bold">Mnemonic</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB"><strong class="bold">Instruction Format</strong></p>&#13;
							<p class="ParaOverride-2" lang="en-GB"><strong class="bold">rrr = Rd, aaa = rS1, bbb = </strong><strong class="bold">rS2</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB"><strong class="bold">Code </strong><strong class="bold">Format</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>00 00000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Stop operation</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">STOP</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">00 00000 000 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">0 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>00 00001</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">No operation</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">NOP</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">00 00001 000 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">0 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>00 </code><code>00 010</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Get a char from the keyboard</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">GET  r0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">00 00010 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>00 00011</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Get a random character</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">RND  r0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">00 00011 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>00 00100</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Swap bytes in the register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">SWAP r0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">00 00100 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>00 01000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Print a hex value in the register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">PRT  r0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">00 01000 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB"><code>00 11111</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Terminate program</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">END</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">00 11111 000 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">0 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB"><code>01 00000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Load register from register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">MOV  r0,r1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">01 00000 rrr aaa 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB"><code>01 00001</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Load register from memory</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">LDRM r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">01 00001 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB"><code>01 00010</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Load register with literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">LDRL r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">01 00010 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB"><code>01 00011</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Load register indirect</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">LDRI r0,[r1,L]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">01 00011 rrr aaa 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB"><code>01 00100</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Store register in memory</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">STRM r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">01 00100 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB"><code>01 00101</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Store register indirect</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">STRI r0,[r1,L]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">01 00101 rrr aaa 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 00000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Add register to register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">ADD  r0,r1,r2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 00000 rrr aaa bbb 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 1 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 00001</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Add register to literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">ADDL r0,r1,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 00001 rrr aaa 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 00010</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Subtract register from register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">SUB  r0,r1,r2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 00010 rrr aaa bbb 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 1 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 00011</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Subtract literal from register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">SUBL r0,r1,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 00011 rrr aaa 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 00100</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Multiply register by register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">MUL  r0,r1,r2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 00100 rrr aaa bbb 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 1 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 00101</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Multiply literal by register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">MULL r0,r1,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 00101 rrr aaa 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 00110</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Divide register by register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">DIV  r0,r1,r2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 00110 rrr aaa bbb 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 1 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 00111</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Divide register by literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">DIVL r0,r1,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 00111 rrr aaa 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 01000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Mod register by register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">MOD  r0,r1,r2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 01000 rrr aaa bbb 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 1 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 01001</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Mod register by literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">MOD  r0,r1,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 01001 rrr aaa 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 01010</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">AND register to register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">AND  r0,r1,r2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 01000 rrr aaa bbb 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 1 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 01011</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">AND register to literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">ANDL r0,r1,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 01001 rrr aaa 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 01100</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">OR register to register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">OR   r0,r1,r2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 01010 rrr aaa bbb 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 1 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 01101</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">OR register to literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">ORL  r0,r1,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 01011 rrr aaa 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 01110</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">EOR register to register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">EOR  r0,r1,r2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 01010 rrr aaa bbb 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 1 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 01111</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">EOR register to literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">EORL r0,r1,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 01011 rrr aaa 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 10000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">NOT register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">NOT  r0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10000 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 10010</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Increment register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">INC  r0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10010 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 10011</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Decrement register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">DEC  r0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10011 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 10100</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Compare register with register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">CMP  r0,r1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10100 rrr aaa 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 10101</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Compare register with literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">CMPL r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10101 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 10110</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Add with carry</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">ADC  r0,r1,r2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10110 rrr aaa bbb 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 1 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 10111</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Subtract with borrow</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">SBC  r0,r1,r2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10111 rrr aaa bbb 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 1 1 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 11000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Logical shift left</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">LSL  r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10000 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 11001</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Logical shift left literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">LSLL r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10000 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 11010</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Logical shift right</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">LSR  r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10001 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 11011</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Logical shift right literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">LSRL r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10001 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 11100</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Rotate left</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">ROL  r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10010 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 11101</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Rotate left literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">ROLL r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10010 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 11110</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Rotate right</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">ROR  r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10010 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>10 11111</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Rotate right literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">RORL r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">10 10010 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-6">&#13;
							<p lang="en-GB"><code>11 00000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Branch unconditionally</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">BRA  L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">11 00000 000 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">0 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-6">&#13;
							<p lang="en-GB"><code>11 00001</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Branch on zero</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">BEQ  L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">11 00001 000 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">0 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-6">&#13;
							<p lang="en-GB"><code>11 00010</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Branch on not zero</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">BNE  L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">11 00010 000 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">0 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-6">&#13;
							<p lang="en-GB"><code>11 00011</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Branch on minus</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">BMI  L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">11 00011 000 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">0 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-6">&#13;
							<p lang="en-GB"><code>11 00100</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Branch to subroutine</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">BSR  L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">11 00100 000 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">0 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-6">&#13;
							<p lang="en-GB"><code>11 00101</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Return from subroutine</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">RTS</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">11 00101 000 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">0 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-6">&#13;
							<p lang="en-GB"><code>11 00110</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Decrement and branch on not ٠</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">DBNE r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">11 00110 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-6">&#13;
							<p lang="en-GB"><code>11 00111</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Decrement and branch on zero</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">DBEQ r0,L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">11 00111 rrr 000 000 L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-6">&#13;
							<p lang="en-GB"><code>11 01000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Push register on the stack</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">PUSH r0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">11 01000 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-6">&#13;
							<p lang="en-GB"><code>11 01001</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Pull register off the stack</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">PULL r0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">11 01001 rrr 000 000 0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">1 0 0 0</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.2 – TC1 Instruction encoding (the 4 code format bits are not part of the opcode)</p>&#13;
			<p lang="en-GB">The rightmost <a id="_idIndexMarker238"/>column is called <code>1001</code> tells the assembler that the <a id="_idIndexMarker239"/>instruction requires a destination register and a 16-bit literal. Code 0000 tells us that the instruction contains no operands at all.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We chose these instructions to demonstrate a range of operations. Many of these instructions are typical of a RISC computer such as ARM (that is, we don’t include operations on data in memory). Note that later, we’ll introduce a simulator for a memory-to-register instruction set that allows operations such as <code>ADD r1,12</code>, where <code>12</code> is a memory location.</p>&#13;
			<p lang="en-GB">Some instructions in <em class="italic">Table 4.2</em> don’t exist on a real computer; for example, read a character from the keyboard. We added that to simplify debugging and experimentation. Similarly, TC1 can generate a random number, a feature not found in most computer instruction sets. However, it’s useful for generating random test data. Some instructions, such as <a id="_idIndexMarker240"/>subroutine calls and returns, implement more sophisticated operations, which we shall encounter later.</p>&#13;
			<p lang="en-GB">The column labeled <code>L</code> indicates a literal value (that is, a 16-bit constant).</p>&#13;
			<p lang="en-GB">The fourth <a id="_idIndexMarker241"/>column (<code>rrr</code>, <code>aaa</code>, and <code>bbb</code> show the location of the three register select fields. The rightmost field (<code>0</code> or <code>L</code>) represents 16 bits of the literal. We show <code>0</code> if all bits are 0, and <code>L</code> if a 16-bit literal is required by the instruction. If a register field is not required, the corresponding field is filled with zeros (although it doesn’t matter what value these bits are because they are not used by the instruction).</p>&#13;
			<p lang="en-GB">Remember that the four bits in the rightmost column are not part of the opcode or instruction itself. These bits show which fields are required by the current instruction: the destination register (<code>rrr</code>), the source 1 register (<code>aaa</code>), the source 2 register (<code>bb</code>), and the literal, <code>L</code>. For example, code <code>1100</code> indicates that the instruction has a destination register and a single source register.</p>&#13;
			<h3 lang="en-GB">Explaining some of the instructions</h3>&#13;
			<p lang="en-GB">Some of the <a id="_idIndexMarker242"/>instructions in <em class="italic">Table 4.2</em> are typical of real processors. Several instructions have been included to provide useful facilities such as generating a random number for testing purposes. This section describes several of the instructions in <em class="italic">Table 4.2</em>.</p>&#13;
			<p lang="en-GB"><code>STOP</code> terminates instruction processing. Most modern computers don’t have an explicit <code>STOP</code> operation.</p>&#13;
			<p lang="en-GB"><code>NOP</code> does nothing other than advance the program counter. It’s a dummy operation that is useful as a marker in code, a placeholder for future code, or as an aid to testing.</p>&#13;
			<p lang="en-GB"><code>GET</code> reads data from the keyboard and offers a simple way of getting input from the keyboard into a register. This is useful when testing programs and is not a normal computer instruction.</p>&#13;
			<p lang="en-GB"><code>RND</code> generates a random number. It’s not in computer instruction sets but provides an excellent means of generating data internally when testing your code.</p>&#13;
			<p lang="en-GB"><code>SWAP</code> exchanges upper- and lower-order bytes – for example, <code>0x1234</code> becomes <code>0x3412</code>.</p>&#13;
			<p lang="en-GB">The load and store instructions move data between memory and registers. The difference between <a id="_idIndexMarker243"/>members of this class is the direction (store is computer-to-memory, while load is memory-to-computer), size (some computers allow byte, 16-bit, or 32-bit transfers), and addressing mode (using a literal value, an absolute address, or an address from a register).</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><code>MOV</code> copies one register to another – for example, <code>MOV r3,r1</code> copies the contents of <code>r1</code> to <code>r3</code>. <code>MOV</code> is, essentially, an a load register with register (LDRR) instruction.</p>&#13;
			<p lang="en-GB"><code>LDRL</code> loads a register with a literal value – for example, <code>LDRL r3,20</code> loads register <code>r3</code> with <code>20</code>.</p>&#13;
			<p lang="en-GB"><code>LDRM</code> loads a register with the contents of a memory location specified by a literal address. <code>LDRM r1,42</code> loads <code>r1</code> with the contents of memory location <code>42</code>. This instruction does not exist on modern RISC processors. Most modern processors do not allow you to access an absolute memory address,</p>&#13;
			<p lang="en-GB"><code>LDRI</code>, the load register indexed (or load register indirect) instruction, loads a register with the contents of a memory location specified by the contents of a register plus a literal address. <code>LDRM r2,[r3,10]</code> loads <code>r2</code> with the contents of the memory location whose address is given by the contents of <code>r3</code> plus <code>10</code>. This instruction is the standard RISC load operation.</p>&#13;
			<p lang="en-GB"><code>STRM</code>, the store register memory instruction, stores a register at the location specified by a literal address. <code>STRM r2,15</code> stores register <code>r2</code> at memory location <code>15</code>. RISC processors don’t implement this instruction.</p>&#13;
			<p lang="en-GB"><code>STRI</code>, the store register indexed instruction, stores a register at the location specified by a register plus a literal. <code>STRI r2,[r6,8]</code> stores <code>r2</code> at the memory location whose address is <code>r6</code> plus <code>8</code>.</p>&#13;
			<p lang="en-GB">The <code>STR</code>, <code>STRM</code>, and <code>STRI</code> instructions are anomalous because they write the source and destination <a id="_idIndexMarker244"/>operands in the reverse order to <code>LDR</code> (and all other processor operations); that is, if you write <code>LDR r0,PQR</code>, you should write <code>STR PQR,r0</code> to indicate the reverse data flow. But, by custom and practice, we don’t.</p>&#13;
			<p lang="en-GB"><code>DBNE</code> We added the decrement and branch on not zero instruction for fun because it reminds me of my old Motorola days. The 68000 was a powerful microprocessor (at the time) with a 32-bit architecture. It has a decrement and branch instruction that is used at the end of a loop. On each pass around the loop, the specified register is decremented, and a branch back to a label is made if the counter is not -1. <code>DBNE r0,L</code> decrements <code>r0</code> and branches to the line numbered <code>L</code> if the count is not zero.</p>&#13;
			<h3 lang="en-GB">Register indirect addressing</h3>&#13;
			<p lang="en-GB">Two instructions require a special mention because they are concerned not with operations on <a id="_idIndexMarker245"/>data but with accessing data in memory. These are <code>LDRI</code> and <code>STRI</code>, both of which use register indirect addressing. In <em class="italic">Table 4.2,</em> the <code>0b0100011</code> opcode corresponds to <code>LDRI</code> (that is, load register <em class="italic">indirect</em>). This instruction doesn’t give you the actual address of the operand; it tells you where the address can be found. The register indirect addressing mode is also called pointer-based or indexed addressing. The operand address in memory is given by the contents of a register plus an offset; that is, <code>r[rD]=mem[r[rS1]+lit]</code>. If we use bold and shading, we can make its interpretation a little easier:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
r[rD] = mem[<strong class="bold">r[rS1]</strong>+lit]</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><em class="italic">Figure 4</em><em class="italic">.2</em> demonstrates the effect of the <code>LDRI r1,[r0,3]</code> TC1 instruction, where pointer register <code>r0</code> contains 100 and the operand is accessed at memory address 100 + 3 = 103:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_4.02_B19624.jpg" alt="Figure 4.2 – Register indirect addressing" width="903" height="450"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Register indirect addressing</p>&#13;
			<p lang="en-GB">This addressing mode lets you modify addresses while the program is running (because you can change <a id="_idIndexMarker246"/>the contents of the pointer, <code>r0</code>). Pointer-based addressing makes it possible to step through a list of items, element by element, simply by incrementing the pointer. Here’s an example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
LDRI  <strong class="bold">r1</strong>,[<strong class="bold">r</strong>2,0]    @ Get the element pointed at by r2. Here the offset is 0&#13;
INC   <strong class="bold">r</strong>2           @ Increment r2 to point to the next element</pre>&#13;
			<p lang="en-GB">We access the element pointed at by <code>r2</code> (in this case, the offset is <code>0</code>). The next line increments <code>r2</code> to point to the next element. If this sequence is executed in a loop, the data will be accessed element by element.</p>&#13;
			<p lang="en-GB">Computers implement both arithmetic and Boolean (logical) operations. In the next section, we’ll briefly look at how Python can be used to simulate logical operations at the assembly language level.</p>&#13;
			<h2 id="_idParaDest-68" lang="en-GB"><a id="_idTextAnchor068"/>Bit-handling in Python</h2>&#13;
			<p lang="en-GB">In this section, we’ll look <a id="_idIndexMarker247"/>at how Python deals with the fundamental component of all computer data: the bit. Because simulated computers operate at the level of bits, we have to look at how <a id="_idIndexMarker248"/>bits are manipulated in Python before we can construct a simulator that can perform logical operations such as <code>AND</code> and <code>OR</code>.</p>&#13;
			<p lang="en-GB">Computers can <a id="_idIndexMarker249"/>operate on entire words as a single entity, or on the individual bits of a word. Consequently, we have to be able to perform both bit operations and word operations to simulate a computer.</p>&#13;
			<p lang="en-GB">Python lets you input data and display it as a binary string of bits. You can operate on individual bits of a string using Boolean operators, and you can shift the bits of a word left and right. You have all the tools you need in Python. We are now going to look at Python, which lets you operate on the individual bits of an integer.</p>&#13;
			<p lang="en-GB">Because the <a id="_idIndexMarker250"/>simulator will operate on binary numbers, we have to exploit several Python facilities; for example, a binary value is indicated by prefixing it with <code>0b</code>. If you want to use the binary equivalent of 15, you must write <code>0b1111</code> and use it just like a decimal number. The following two operations have the same effect:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = y + 0b111      # Addition using a binary integer</pre>&#13;
			<pre class="source-code">x = y + 15         # Addition using a decimal integer</pre>&#13;
			<p lang="en-GB">Two important binary operators are <code>&gt;&gt;</code> (shift right) and <code>&lt;&lt;</code> (shift left). Shift expressions are written as <code>p &gt;&gt; q</code> or <code>p &lt;&lt; q</code>, where <code>p</code> is the number to be operated on and <code>q</code> is the number of bit positions shifted. Consider the following example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = 0b1110110&#13;
x = x &lt;&lt; 2</pre>&#13;
			<p lang="en-GB">This shifts <code>x</code> two places left to give the new value <code>0b111011000</code>. All the bits have moved two places left and 0s have been entered at the right-hand end to fill the newly vacated positions. The shifted version of <code>x</code> now has nine bits, rather than seven. However, when we simulate a computer, we have to ensure that, whatever we do, the number of bits in a word remains constant. If a register has 16 bits, any operation you perform on it must yield 16 bits.</p>&#13;
			<p lang="en-GB">We can take two words and perform Boolean (bitwise) operations on them; for example, C = A &amp; B ANDs together words A and B by calculating ci = ai · bi for each bit in the word (that is, for i = 0 to 7). Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = 0b11101101 &amp; 0b00001111</pre>&#13;
			<table id="table003-1" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3" colspan="3">&#13;
							<p class="ParaOverride-2" lang="en-GB"><strong class="bold CharOverride-7">Truth table </strong><strong class="bold CharOverride-7">for AND</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">x</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">y</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">z=x &amp; y</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-2" lang="en-GB">1</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p lang="en-GB">This gives <code>x = 0b000001101</code>, because ANDing a bit with 0 gives a 0 result, and ANDing a bit x with 1 gives x, because 1 &amp; 0 = 0 and 1 &amp; 1 = 1, as the truth table demonstrates.</p>&#13;
			<p lang="en-GB">In Python, hexadecimal <a id="_idIndexMarker251"/>numbers are prefixed with <code>0x</code>; for example, <code>0x2F1A</code>. We use hexadecimal numbers in Python programs because they are shorter than <a id="_idIndexMarker252"/>binary numbers. Here is an example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
0x1234 = 0b0001001000110100&#13;
0xA0C2 = 0b1010000011000010&#13;
0xFFFF = 0b1111111111111111</pre>&#13;
			<p lang="en-GB">Consider the following fragment of Python code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = 0b<strong class="bold">0011</strong>1001<strong class="bold">0101</strong>0011   # A 16-bit binary string we are going to process&#13;
y = (x &gt;&gt; 8) &amp; 0xF       # Shift x right 8 places and mask it to 4 bits&#13;
print('y is ',bin(y))    # Print the result in binary form using bin()</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The output from this code is <code>y </code><code>is 0b1001</code>.</p>&#13;
			<p lang="en-GB">Python uses more than 16 bits to represent numbers. To simulate binary arithmetic in TC1, we must constrain Python’s numbers to 16 bits. We have to work with the longer words provided by Python and chop them down to 16 or 32 bits as necessary. Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = 0xF009       # Set up 16-bit number       <strong class="bold">1111</strong>0000<strong class="bold">0000</strong>1001&#13;
y = x &lt;&lt; 2       # Shift left twice to get      11<strong class="bold">1100</strong>0000<strong class="bold">0010</strong>0100 = 0x3C024 (18 bits)&#13;
y = y &amp; 0xFFFF   # Constrain to 16 bits to get     <strong class="bold">1100</strong>0000<strong class="bold">0010</strong>0100 = 0xC024</pre>&#13;
			<p lang="en-GB">Shifting the 16-bit <a id="_idIndexMarker253"/>word left two places made it an 18-bit word. ANDing it <a id="_idIndexMarker254"/>with the <code>0b1111111111111111</code> binary value forces it to 16 significant bits.</p>&#13;
			<h2 id="_idParaDest-69" lang="en-GB"><a id="_idTextAnchor069"/>Operator precedence in Python</h2>&#13;
			<p lang="en-GB">Now, we have to re-learn something that we learned about in high school arithmetic: operator <a id="_idIndexMarker255"/>precedence. When you use several operators in an expression, you have to be aware of operator precedence; that is, which operations are performed before others. For example, is 4 * 5 + 3 equal to 23 or 32? All computer <a id="_idIndexMarker256"/>languages have a hierarchy of operator precedence. The partial list of operator precedence for Python is as follows, with the highest precedence first. We often use parentheses to make the meaning of expressions clearer, even if it’s not required – for example, <code>(xxx &lt;&lt; 4) &amp; (yyy &lt;&lt; </code><code>2)</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
()                          Parentheses               Highest precedence&#13;
~                           Negation&#13;
*,/, %                      Multiplication, division, modulus&#13;
+,-                         Addition, subtraction&#13;
&lt;&lt;, &gt;&gt;                      Bitwise shift left, right&#13;
&amp;                           Logical (bitwise) AND&#13;
^                           Logical (bitwise) XOR&#13;
|                           Logical (bitwise) OR&#13;
&lt;, &lt;+, &gt;, &gt;+, &lt;&gt;, !=, ==    Boolean comparisons         Lowest precedence</pre>&#13;
			<p lang="en-GB">In the next section, we’ll look at how an instruction, which is a string of 1s and 0s, is decoded and the appropriate operation that’s performed.</p>&#13;
			<p lang="en-GB">Next, we’ll take a major step in constructing a simulator – that is, decoding a machine-level binary instruction to extract information about the operation it is going to simulate.</p>&#13;
			<h1 id="_idParaDest-70" lang="en-GB"><a id="_idTextAnchor070"/>Decoding and executing an instruction</h1>&#13;
			<p lang="en-GB">In this section, we’ll look at a few examples of how instructions are encoded and decoded. Consider the <code>ADD r1,r2,r3</code>, operation (where the codes for registers <code>rD</code>, <code>rS1</code>, and <code>rS2</code> are shaded), which is defined in RTL as follows:</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><code>[r1] </code><code>←</code><code> [r2] + [</code><code>r3]</code></p>&#13;
			<p lang="en-GB"><em class="italic">Table 4.2</em> shows that the encoding of <code>ADD r1,r2,r3</code> is <code>10 00000 001 010 011 0000000000000000</code>. The corresponding 4-bit format code that defines the registers to be used is <code>1110</code> because we use three registers and no literal field (remember that this 4-bit format <a id="_idIndexMarker257"/>code is not part of the opcode but is used by the assembler to interpret the instruction).</p>&#13;
			<p lang="en-GB">The following <a id="_idIndexMarker258"/>Python code shows how we can decode an instruction to extract five variables: the operation code (<code>binOp</code>); the three registers, <code>rD</code>, <code>rS1</code>, and <code>rS2</code>; and a literal. Decoding is performed by shifting the bits of the instruction right to move the required field into the least significant position and then ANDing it with a mask to remove any other fields. Consider, <code>xxxxxxx xxx 010 xxx xxxxxxxxxxxxxxxx</code>. If we shift this string 19 places right, we get <code>0000000000000000000xxxxxxxxxx010</code>. The zeros have been shifted in, and the three bits we’re interested in are right-justified in the least significant bits. If we <code>AND</code> this with <code>0b111</code> to select only the three least significant bits, we get <code>0000000000000000000000000000010</code> – that is, the required register value is now right-justified and we can use it:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
binOp = binCode &gt;&gt; 25             # Extract the 7-bit opcode binOp by shifting 25 bits right&#13;
rD    = binCode &gt;&gt; 22 &amp; 0b111     # Extract the destination register as rD. 0b111 is a mask&#13;
rS1   = binCode &gt;&gt; 19 &amp; 0b111     # Extract source register 1 as rS1&#13;
rS2   = binCode &gt;&gt; 16 &amp; 0b111     # Extract the source register 2 as rS2&#13;
lit   = binCode &amp; 0xFFFF          # Extract the low-order 16 bits (the literal) as lit&#13;
op0 = r[rD]                       # Read contents of destination register operand 0 as op0&#13;
op1 = r[rS1]                      # Read contents of source 1 register as op1&#13;
op2 = r[rS2]                      # Read contents of source 2 register as op2</pre>&#13;
			<p lang="en-GB">The shift-right operator in Python is <code>&gt;&gt;</code> and the bit-wise logical <code>AND</code> operator is <code>&amp;</code>. The mask is expressed <a id="_idIndexMarker259"/>as a string of bits (rather than a decimal number) because ANDing with binary 111 is clearer than ANDing with decimal 7. In Python, a binary <a id="_idIndexMarker260"/>value is preceded by 0b, so 7 is represented by <code>0b111</code>. The literal is ANDed with 16 ones, expressed as <code>0xFFFF</code>. We use binary for short fields, and hex value for long fields. It’s just personal preference.</p>&#13;
			<p lang="en-GB">The <code>binCode &gt;&gt; 22 &amp; 0b111</code> expression shifts the bits of <code>binCode</code> 22 places right, and then bitwise ANDs the result with <code>000…000111</code>. Because of operator precedence, the shifting is performed first. Otherwise, we would have written <code>(binCode &gt;&gt; 22) &amp; 0b111</code>. We often use parentheses, even when not strictly necessary, to stress operator precedence.</p>&#13;
			<p lang="en-GB">Note that we extract all fields, even though they may not be required by each instruction. Similarly, we read all three register’s contents. This approach simplifies the Python code, at the cost of efficiency.</p>&#13;
			<p lang="en-GB">Consider extracting the destination register field, <code>rrr</code>. Suppose that the instruction is <code>ADD r1,r2,r3</code>, and the opcode is <code>10</code>00000001010<code>011</code>0000000000000000. We have put alternate fields in bold font and the destination field is shaded to make it easier to read. Performing a 22-bit right shift moves the destination register into the least-significant bits and leaves us with </p>&#13;
			<pre class="source-code"><code>00000000000000000000001000000</code>001   (after shifting 22 places right).</pre>&#13;
			<p lang="en-GB">Now, if we perform the <code>AND</code> operation with 111 (all bits to the left are zero), we get the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
0000000000000000000000<strong class="bold">1</strong>000000001      (after shifting 22 places right)&#13;
00000000000000000000000000000111      (the three-bit mask)&#13;
00000000000000000000000000000001      (The result; the 1 in bit position 9 has been removed)</pre>&#13;
			<p lang="en-GB">We have now <a id="_idIndexMarker261"/>isolated the first register field to get <code>001</code>, which corresponds <a id="_idIndexMarker262"/>to register <code>r1</code>. The final three lines of the program to decode an instruction are as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
op0 = r[rD]    # Operand 0 is the contents of the destination register&#13;
op1 = r[rS1]   # Operand 1 is the contents of source register 1&#13;
op2 = r[rS2]   # Operand 2 is the contents of source register 2</pre>&#13;
			<p lang="en-GB">These instructions use the register addresses (<code>rD</code>, <code>rS1</code>, and <code>rS2</code>) to access registers; that is, the instruction specifies which registers are to be used. For example, if <code>op0 = r[5],</code> register <code>r5</code> is operand zero, the destination register. If an instruction does not specify a register, the unused field is set to zero.</p>&#13;
			<p lang="en-GB">Once an instruction has been decoded, it can be executed. Fortunately, executing most instructions is remarkably easy. Consider the following examples:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if   opCode == 0b0100010: r[rD] = lit               # Load register with literal&#13;
elif opCode == 0b0100001: r[rD] = mem[lit]          # Load register from memory&#13;
elif opCode == 0b0100011: r[rD] = mem[op1 + lit]    # Load register indirect&#13;
elif opCode == 0b0100100: mem[lit] = r[rD]          # Store register in memory</pre>&#13;
			<p lang="en-GB">This fragment of code demonstrates the execution of four instructions from the load and store (that is, memory access) group. The Python <code>if … elif</code> construct tests each opcode in turn. The first line compares the 7-bit opcode with the binary value <code>0100010</code>, which corresponds to the <code>LDRL</code> (load a register with a literal value) instruction. Incidentally, in the final version of TC1, we made the code easier to read by comparing operations with the actual mnemonic; for example, <code>'LDRL'</code> is easier to read than its code, <code>0b100010</code>.</p>&#13;
			<p lang="en-GB">If there is a match, the code following the colon is executed, <code>(r[rD] = lit)</code>. If not, the next line uses the <code>elif</code> command to compare the opcode with 010001. If there is a match, the code after <a id="_idIndexMarker263"/>the colon is executed. In this way, the opcode is compared with all its possible values until a match is found.</p>&#13;
			<p lang="en-GB">Suppose the <a id="_idIndexMarker264"/>instruction’s opcode is <code>0100010</code>, and the <code>r[rD] = lit</code> line is executed. This Python operation transfers the value of the 16-bit literal provided in the instruction to the destination register specified in the instruction. In RTL terms, it carries out <code>r[rD] ← lit</code> and is used by the programmer to load an integer into a register. Let’s say the binary pattern of the instruction code is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
01 00010 <strong class="bold">110</strong> 000 000 <strong class="bold">0000</strong>0000<strong class="bold">1100</strong>0001,</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Here, the 16-bit literal is loaded into register <code>r6</code> to implement <code>LDRL r6,193</code>.</p>&#13;
			<h2 id="_idParaDest-71" lang="en-GB"><a id="_idTextAnchor071"/>Arithmetic and logical operations</h2>&#13;
			<p lang="en-GB">The arithmetic and logical group of operations do all the work (data processing) in a program. They include <a id="_idIndexMarker265"/>arithmetic operations (addition, subtraction, and multiplication), as well as logical operations (<code>AND</code>, <code>OR</code>, <code>EOR</code>, and <code>NOT</code>). These are <a id="_idIndexMarker266"/>three-operand instructions, apart from <code>NOT</code>; for example, <code>AND r</code><code>3,r0,r5</code> performs a bitwise <code>AND</code> between the bits of <code>r0</code> and <code>r5</code>, and puts the result in <code>r3</code>.</p>&#13;
			<p lang="en-GB">The following fragment of Python code shows how TC1 interprets four instructions in this group. There are two pairs of instructions: addition and subtraction. Each pair consists of a register-to-register operation and a register-with-literal operation; for example, <code>ADD r1,r2,r3</code> adds the contents of registers <code>r2</code> and <code>r3</code> together, whereas <code>ADDL r1,r2,L</code> adds the contents of a 16-bit literal to the contents of register <code>r2</code>. We don’t do the <a id="_idIndexMarker267"/>arithmetic here. Instead, we call a function called <code>alu(f,a,b)</code> to perform the <a id="_idIndexMarker268"/>required action. The next section will show you how to create your own functions:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
elif opCode==0b1000000: reg[dest]=alu(1,reg[src1],<strong class="bold CharOverride-11">reg[src2]</strong>) # Add register to register&#13;
elif opCode==0b1000001: reg[dest]=alu(1,reg[src1],<strong class="bold CharOverride-11">literal</strong>)   # Add literal to register&#13;
elif opCode==0b1000010: reg[dest]=alu(2,reg[src1],reg[src2]) # Subtract register from register&#13;
elif opCode==0b1000011: reg[dest]=alu(2,reg[src1],literal)   # Subtract literal from register</pre>&#13;
			<p lang="en-GB">If you were to write the full Python code required to execute each operation, it would require several lines of code per instruction. An addition operation such as <code>reg[dest] = reg[src1] + reg[src2]</code> appears simple enough, but there is more to an arithmetic operation.</p>&#13;
			<p lang="en-GB">To explain why, we need to discuss the role of conditional flag bits. Recall that computers make decisions regarding whether to execute the next instruction in sequence, or whether to jump to a different place in the code (that is, an <code>if…then…else</code> construct). The decision whether to take the <code>if</code> branch or the <code>else</code> branch is determined by the outcome of an arithmetic or logical operation (this includes compare operations).</p>&#13;
			<p lang="en-GB">The result of an arithmetic or logical operation is tested and used to set or clear condition code flags. These flags are usually the negative, zero, carry, and overflow flags and are written as <code>n</code>, <code>z</code>, <code>c</code>, and <code>v</code>. For example, if an operation is x = p – q and the result is x = 0, then the z-bit (zero bit) is set to 1. Similarly, if an operation yields a result that cannot be represented in 16 bits, the carry bit, c, is set. Because most computers use two’s complement arithmetic, the negative flag, n, is set if the result is negative in two’s complement terms (that is, its most significant bit is 1). The v-bit indicates arithmetic overflow <a id="_idIndexMarker269"/>and is set if the result is out of range. This means <a id="_idIndexMarker270"/>that two positive numbers have been added and the result is negative, or two negative numbers have been added and the result is positive.</p>&#13;
			<p lang="en-GB"><em class="italic">Table 4.3</em> demonstrates how 4 bits can be allocated to the numbers 0 to 15 (unsigned) or -8 to 7 (signed two’s complement). It’s up to the programmer to choose the convention. However, the arithmetic remains the same for both conventions.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Consider 0110 + 1100, which is 10010 (or 0010 in 4 bits). If we interpret these figures as unsigned, the calculation gives us 6 + 12 = 2, which is incorrect, because the result 18 cannot be represented in 4 bits. If we consider these as signed values, the calculation is 6 + -4 = 2 and the result is correct:</p>&#13;
			<table id="table004-1" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-7">&#13;
							<p lang="en-GB"><strong class="bold">8</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-7">&#13;
							<p lang="en-GB"><strong class="bold">4</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-7">&#13;
							<p lang="en-GB"><strong class="bold">2</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-7">&#13;
							<p lang="en-GB"><strong class="bold">1</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-7">&#13;
							<p lang="en-GB"><strong class="bold">Unsigned value</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-7">&#13;
							<p lang="en-GB"><strong class="bold">Signed value</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    2</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    3</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    3</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    4</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    4</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    5</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    5</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    6</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    6</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    7</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-5">&#13;
							<p lang="en-GB">    7</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-7">&#13;
							<p lang="en-GB">8</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-7">&#13;
							<p lang="en-GB">4</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-7">&#13;
							<p lang="en-GB">2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-7">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-7"/>&#13;
						<td class="No-Table-Style CellOverride-7"/>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">    8</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-8">&#13;
							<p lang="en-GB">    -8</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">    9</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-8">&#13;
							<p lang="en-GB">    -7</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">    10</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-8">&#13;
							<p lang="en-GB">    -6</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">    11</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-8">&#13;
							<p lang="en-GB">    -5</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">    12</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-8">&#13;
							<p lang="en-GB">    -4</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">    13</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-8">&#13;
							<p lang="en-GB">    -3</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">    14</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-8">&#13;
							<p lang="en-GB">    -2</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">    15</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-8">&#13;
							<p lang="en-GB">    -1</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.3 – A representation of 4-bit values in signed and unsigned forms</p>&#13;
			<h4 lang="en-GB">Two’s complement arithmetic – a note</h4>&#13;
			<p lang="en-GB">There are several <a id="_idIndexMarker271"/>ways of representing negative numbers in binary arithmetic. One of the oldest is called sign and magnitude, where a number is prefixed by 0 if it’s positive and 1 if it’s negative. This is not used today in binary arithmetic (except for floating-point numbers).</p>&#13;
			<p lang="en-GB">Two’s complement notation is used by almost all modern computers to represent signed integers. In two’s complement arithmetic, if N is a positive number in n bits, the value of -N is given by 2n – 1. The two’s complement of N can be calculated easily by inverting the bits and adding 1. For example, if N = <code>000110</code> in six bits, the value of -6 is represented by <code>111010</code>.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The advantage of two’s complement arithmetic is that addition and subtraction are performed in the same way. If you add a two’s complement value to another number, the result is correctly calculated. For example, if we add 9 (that is, <code>001001</code>) to the previous value of -6, we get <code>001001</code> + <code>111010</code> = <code>1000011</code>, which is +3 in six bits. The carry-out (in bold font) is discarded.</p>&#13;
			<h4 lang="en-GB">Zero, carry, and sign bits</h4>&#13;
			<p lang="en-GB">The carry <a id="_idIndexMarker272"/>and sign bits are used to determine whether a result is in range or out of range. In signed <a id="_idIndexMarker273"/>arithmetic, the result of a two’s complement addition of S = A+B is <a id="_idIndexMarker274"/>out of range, if the sign bits of A and B are both 0 and the sign bit of S is 1, or if the sign bits of A and B are both 1 and the sign bit of S is 0. Consider addition and subtraction using four bits. Two’s complement arithmetic is used, and the leftmost bit is the sign bit. In each case, we’ve performed a two’s complement addition on signed numbers. The results give us the state of the flag bits:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
 +0101                               +5 + -5 = 0&#13;
 +1011&#13;
 10000 Z = 1, N = 0, C = 1, V = 0   &#13;
                            The result is zero and the Z-bit is set. The C bit is 1, and N, V bits are clear&#13;
 +1101                               -3 + -3 = -6&#13;
 +1101&#13;
 11010 Z = 0, N = 1, C = 1, V = 0    The result is negative, N = 1, and a carry is generated, C = 1&#13;
 +1101                               -3 + +5 = +2&#13;
 +0101&#13;
 10010 Z = 0, N = 0, C = 1, V = 0    The result is positive and the carry bit is set&#13;
 +0101                               +5 + 6 = -5&#13;
 +0110&#13;
  1011 Z = 0, N = 1, C = 0, V = 1&#13;
                                 Two positive numbers are added and the result is negative. V is set&#13;
  1010                               -6 + -4 = +7&#13;
 +1100&#13;
 10111 Z = 0, N = 0, C = 1, V = 1&#13;
                                 Two negative numbers are added and the result is positive. V is set</pre>&#13;
			<p lang="en-GB">How do we know <a id="_idIndexMarker275"/>whether a number is signed or unsigned? We don’t! There is no <a id="_idIndexMarker276"/>difference. If you use signed numbers, you must interpret the result <a id="_idIndexMarker277"/>as a signed value. If you use unsigned numbers, you must interpret the result as an unsigned value. For example, in four bits, 1110 is both -2 and +14, depending on how you look at it.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The next topic deals with how we handle groups of repetitive operations. If the same sequence of operations is going to be used more than once in a program, it makes sense to combine them into a group and invoke that group whenever you need it. In Python, this group of actions is called a function.</p>&#13;
			<h1 id="_idParaDest-72" lang="en-GB"><a id="_idTextAnchor072"/>Functions in Python</h1>&#13;
			<p lang="en-GB">We will now <a id="_idIndexMarker278"/>describe Python’s functions. We’ve already used functions that are part of the language, such as <code>len()</code>. In this section, we’ll do the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Explain why functions are useful</li>&#13;
				<li lang="en-GB">Provide an example of a function to implement an ALU</li>&#13;
				<li lang="en-GB">Explain how variables can be private to a function or shared between functions (scope)</li>&#13;
				<li lang="en-GB">Describe how parameters are passed to functions</li>&#13;
				<li lang="en-GB">Describe how a function returns a result</li>&#13;
			</ul>&#13;
			<p lang="en-GB">Writing the Python code to deal with each arithmetic or logical operation implemented by a simulator would be tedious because so much code would be replicated by individual instructions. Instead, we can create a Python function (that is, a subroutine or procedure) that carries out both the arithmetic/logic operation and the appropriate flag-bit setting.</p>&#13;
			<p lang="en-GB">Consider a Python function called <code>alu(f,p,q)</code> that returns an integer that is a function of the <code>f</code>, <code>p</code>, and <code>q</code> parameters. The operation to be performed is passed to the procedure as an integer, <code>f</code>. The function also updates the z and n flag bits. This is a simplified version of the actual function we will use and will provide just two operations, add and subtract, and update only two flag bits:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def alu(f,p,q):                  # Define the alu function with the f, p, and q input parameters&#13;
    global z,n                   # Declare flags as global&#13;
    if f == 1: r = p + q         # If f (the operation) is 1, do an addition&#13;
    if f == 2: r = p – q         # If f is 2, do a subtraction&#13;
    z, n = 0, 0                  # Clear zero and negative flags&#13;
    if r &amp; 0xFFFF == 0: z = 1    # If the result is 0 in 16 bits, then z = 1&#13;
    if r &amp; 0x8000 != 0: n = 1    # If result is negative (msb = 1), then n = 1&#13;
    return (0xFFFF &amp; r)          # Ensure result is restricted to 16 bits</pre>&#13;
			<p lang="en-GB">The function is introduced by <code>def</code>, its name, and any parameters followed by a colon. The body of the function <a id="_idIndexMarker279"/>is indented. The first parameter, <code>f</code>, selects the operation we wish to perform (<code>f</code> = 1 for addition and 2 for subtraction). The next two input parameters, <code>p</code> and <code>q</code>, are the data values used by the function. The last line of the function returns the result to the function’s calling point. This function can be called by, for example, <code>opVal = alu(2,s1,s2)</code>. In this case, the result, <code>opVal</code>, would be the value of <code>s1 – </code><code>s2</code>.</p>&#13;
			<p lang="en-GB">We also update two flag bits, <code>z</code> and <code>n</code>. Initially, both <code>z</code> and <code>n</code> are set to zero by <code>z, n = 0, 0</code>. (Python allows multiple assignments on the same line; for example, <code>a,b,c = 1,5,0</code> sets <code>a</code>, <code>b</code>, and <code>c </code>to 1, 5, and 0, respectively.)</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">You can pass data to a function via parameters and receive a result via <code>return()</code>. However, you can declare variables in a function as <code>global</code>, which means they can be accessed and modified as if they were part of the calling program.</p>&#13;
			<p lang="en-GB"><code>return()</code> is not mandatory because some functions don’t return a value. You can have multiple <code>return()</code> statements in a function because you can return from more than one point in a function. A return can pass multiple values because Python permits multiple assignments on a line; for example, see the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
this, that  = myFunction(f,g)  # Assign f to this and g to that</pre>&#13;
			<p lang="en-GB">Testing for a <a id="_idIndexMarker280"/>zero result can easily be done by comparing the result, <code>r</code>, with 0. Testing for a negative result is harder. In two’s complement arithmetic, a signed value is negative if the most significant bit is 1. We are using 16-bit arithmetic, so that corresponds to bit 15. We can extract bit 15 by ANDing the result, <code>r</code>, with the binary value of 1000000000000000 by writing <code>r&amp;0x8000</code> (the literal is expressed in hex form as 0x8000, which is mercifully shorter than the binary version).</p>&#13;
			<p lang="en-GB">To call the function, we can write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
 if opCode == 0b1000000: r[rD] = alu(1,r[rS1],r[rS2])</pre>&#13;
			<p lang="en-GB">We test for opcode 1000000 and call the <code>alu</code> function if it corresponds to <code>ADD</code>. The function is called with the <code>f = 1</code> parameter for addition; the numbers to be added are the contents of the two source registers. The result is loaded into the <code>r[rD]</code> register. In the current version of TC1, we use the opcode to look up the mnemonic and then apply the test if <code>mnemonic == 'ADD':</code>. This approach is easier to read and can use the mnemonic when displaying the output during tracing.</p>&#13;
			<p lang="en-GB">We have made the <code>z</code> and <code>n</code> variables global (that is, they can be changed by the function and accessed externally). If we didn’t make them global, we would have to have made them return parameters. In general, it is regarded as a better practice to pass variables as parameters rather than making them global.</p>&#13;
			<h3 lang="en-GB">Functions and scope</h3>&#13;
			<p lang="en-GB">Variables are associated with <em class="italic">scope</em> or <em class="italic">visibility</em>. If you write a program without functions, variables <a id="_idIndexMarker281"/>can be accessed everywhere in the program. If you use functions, life becomes rather more complex.</p>&#13;
			<p lang="en-GB">If you declare a variable in the main body, that variable will be visible in functions (that is, you can use it). However, you cannot change it in the function and then access the new value outside the function. What goes on in the function stays in the function. If you wish to access it from outside the function, you must declare it as <em class="italic">global</em>. If you write <code>global temp3</code>, then the <code>temp3</code> variable is the same variable both in and outside the function.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">If you create a variable in a function, that variable cannot be accessed outside the function because it’s private to the function (a local variable). You can create a variable with the same name in another function or the body of the program, but the variable in this function has no effect on variables with the same name outside the function.</p>&#13;
			<p lang="en-GB">If you create <a id="_idIndexMarker282"/>a variable in a function that you want to be visible outside the function, you have to declare it as global in the function. Consider the following code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def fun_1():                      # A dummy function&#13;
    p = 3                         # p is local to fun_1 and set to 3&#13;
    <strong class="bold">global q</strong>                      # q is global and visible everywhere&#13;
    print('In fun_1 p =',p)       # Print p in fun_1&#13;
    print('In fun_1 q =',q)       # Print q in fun_1&#13;
    q = q + 1                     # q is changed in this function&#13;
    p = p + 1                     # p is changed in this function&#13;
    r = 5                         # set local variable r to 5&#13;
    return()                      # You don't need a return&#13;
p = 5                             # p is defined in the body&#13;
q = 10                            # q is defined in the body&#13;
print('In body: p =',p, 'q =',q ) # Print current values of p and q&#13;
fun_1()                           # Call fun_1 and see what happens to p and q&#13;
print('In body after fun_1 q =',q, 'after fun_1 p = ',p)</pre>&#13;
			<p lang="en-GB">After running this code, we get the following. As you can see, the function changes <code>q</code> because it is global, whereas <code>p</code> does not change since it is a local variable in the function:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
In body: p = 5 q = 10&#13;
In fun_1 p = 3&#13;
In fun_1 q = 10&#13;
In body after fun_1 q = 11 after fun_1 p =  5</pre>&#13;
			<p lang="en-GB">Here is a summary of the rules:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">If you don’t change it in a function, you can use it anywhere</li>&#13;
				<li lang="en-GB">If you declare it in a function, it’s all yours and private to the function</li>&#13;
				<li lang="en-GB">If you want to change it in the function and use it outside the function, then declare it as global in the function</li>&#13;
			</ul>&#13;
			<p lang="en-GB">This means that <a id="_idIndexMarker283"/>variables such as the <code>z</code> and <code>n</code> condition code flags can be accessed in a function. If you wish to change them in a function, they must be declared as global by using the following command:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
global z,n</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">If a function returns a value, it ends with <code>return(whatever)</code>. If you don’t return a value from a function, the <code>return</code> statement is not necessary. However, we usually include a <code>return()</code> that returns nothing, and then we explicitly mark the end of the function.</p>&#13;
			<p lang="en-GB">Although the use of global variables is supported by Python, some programmers avoid them because global variables make it too easy to accidentally change a variable in a function and not notice it, leading to headaches when debugging a faulty program. They argue that all variables should be passed to a function as a parameter.</p>&#13;
			<p lang="en-GB">In the next section, we’ll describe the very thing that makes a computer a computer – its ability to take two different courses of action, depending on the outcome of an operation.</p>&#13;
			<h2 id="_idParaDest-73" lang="en-GB"><a id="_idTextAnchor073"/>Branches and flow control</h2>&#13;
			<p lang="en-GB">All microprocessors <a id="_idIndexMarker284"/>have flow control instructions; for example, the unconditional branch, <code>BRA XYZ</code>, means execute the next instruction at address <code>XYZ</code>. A typical conditional instruction is <code>BNE</code> <code>XYZ</code>, which implements taking the branch to the instruction at location <code>XYZ</code>, if and only if, the z flag is not set. The <code>BNE</code> mnemonic means “branch on not equal” because the z-bit is evaluated by comparing two values using subtraction. Consider the following example, which uses the TC1 assembly language:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
     LDRL <strong class="bold">r2</strong>,0        @ Load r2 (the sum) with 0&#13;
     LDRL <strong class="bold">r0</strong>,5        @ Load r0 (the loop counter) with 5&#13;
     LDRL <strong class="bold">r1</strong>,1        @ Load r1 (the register added to the sum) with 1&#13;
Loop ADD  <strong class="bold">r2</strong>,r2,r1    @ Repeat: add r1 to r2&#13;
     INC  <strong class="bold">r1</strong>          @ Increment r1 so that we add 1, 2, 3 … as we go round the loop&#13;
     DEC  <strong class="bold">r0</strong>          @ Decrement the loop counter in r0&#13;
     BNE  Loop        @ Until loop counter = 0&#13;
     STOP             @ Program completed</pre>&#13;
			<p lang="en-GB">Load register with a literal (<code>LDRL</code>) is used three times to load <code>r2</code> with 0, <code>r0</code> with 5, and <code>r1</code> with 1. In the line labeled <code>Loop</code>, we add <code>r2</code> to <code>r1</code> and put the result in <code>r2</code>. On its first execution, <code>r2</code> becomes 0 + 1 = 1.</p>&#13;
			<p lang="en-GB">The next two lines increment <code>r1</code> and decrement r0 so that <code>r1</code> becomes 2 and <code>r0</code> becomes 4. When we decrement <code>r0</code>, the z-flag is set if the result is zero. Since r2 initially contains 5 and then 4 after decrementing, the result is not zero and the z-flag is not set.</p>&#13;
			<p lang="en-GB">When <code>BNE</code> is executed, the z-flag is tested. If it is not zero, a branch is taken to the line labeled <code>Loop</code> and the same batch of four instructions are executed again. When the <code>BNE</code> is encountered a second time, the z-bit is still zero, because this time the decrement went from 4 to 3. Eventually, <code>r0</code> contains 1 and is decremented to 0. The z-bit is then set. When <code>BNE</code> is next executed, the branch to loop is not taken, and the next instruction in the sequence, <code>STOP</code>, is executed. The loop is repeated 5 times. This program evaluates 1 + 2 + 3 + 4 + 5 = 15, which is the result in <code>r2</code>.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Branch addresses can be a little complicated. You can provide an absolute address; for example, <code>BRA 24</code> jumps to the instruction at memory location 24. Most computers use a relative address, which is relative to the current instruction. For example, in this case, we would branch three instructions back from the current location (that is, the <code>BNE</code> instruction). So, you might think that the relative address is -3. It is a negative address because it is backward from the current address. Since the program counter has already been incremented to point to the next instruction, the branch back is -4. So, the literal field of the <code>BNE</code> loop would be -4.</p>&#13;
			<p lang="en-GB">The following fragment of code demonstrates testing four branch instructions and their implementation. In this example, we are using relative addressing for the branch; that is, the target address is specified with respect to the program counter. The first branch, <code>BRA</code>, is an <a id="_idIndexMarker285"/>unconditional branch and the next value of <code>pc</code> is calculated. All the others are conditional branches, and <code>pc</code> is changed only if the required condition is met. Note that the last operation is <code>BMI</code>, which means branch on minus, although some call it branch on negative (which has the same meaning):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if   opCode == 0b1100000:            pc = 0xFFFF &amp; (pc + literal) # Branch always&#13;
elif opCode == 0b1100001 and z == 1: pc = 0xFFFF &amp; (pc + literal) # Branch on zero&#13;
elif opCode == 0b1100010 and z == 0: pc = 0xFFFF &amp; (pc + literal) # Branch on not zero&#13;
elif opCode == 0b1100011 and n == 1: pc = 0xFFFF &amp; (pc + literal) # Branch on minus</pre>&#13;
			<p lang="en-GB"><code>The pc</code> is incremented by <code>pc + literal</code>. However, since backward branches are represented in two’s complement form, it is necessary to <code>AND</code> the result with 0xFFFF to force it to 16 bits to generate the correct value. This is because we are simulating 16-bit arithmetic using a computer language, Python, that represents numbers with more than 16 bits. This is <a id="_idIndexMarker286"/>just an unfortunate consequence of computer arithmetic that you have to be aware of when simulating binary arithmetic.</p>&#13;
			<p lang="en-GB">In the next chapter, we will return to Python and extend our ability to handle data structures and use Python’s functions.</p>&#13;
			<h1 id="_idParaDest-74" lang="en-GB"><a id="_idTextAnchor074"/>Summary</h1>&#13;
			<p lang="en-GB">We started this chapter by designing a computer simulator. However, we haven’t created a final product yet. Instead, we looked at some of the issues involved, such as the nature of an instruction set and the structure of an opcode.</p>&#13;
			<p lang="en-GB">We examined how an instruction can be decoded and how it can be executed. We also took the opportunity to broaden our knowledge of Python and introduced Python’s bit-manipulation facilities, which let us implement machine-level instructions that operate on bits.</p>&#13;
			<p lang="en-GB">We also introduced an important component of Python, known as a function, which allows the programmer to create a self-contained unit of code that can be called to perform a specific job from many points in a program. Functions are vital to modern programming because they facilitate elegant design by bundling a complex sequence of operations into a unit, which you call to carry out a task.</p>&#13;
			<p lang="en-GB">In <a href="B19624_05.xhtml#_idTextAnchor075"><em class="italic">Chapter 5</em></a>, we’ll return to Python and look at some topics in a little more depth – in particular, lists. Lists are probably Python’s most interesting and important feature.</p>&#13;
		</div>&#13;
	</div></body></html>