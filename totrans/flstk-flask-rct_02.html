<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-28"><a id="_idTextAnchor038"/>2</h1>
<h1 id="_idParaDest-29"><a id="_idTextAnchor039"/>Getting Started with React</h1>
<p>So far, we have laid a solid foundation for understanding full stack web development using modern software stacks. Hopefully, you have already set up a React development environment on your local machine. If not, you can go back to <a href="B18554_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Full Stack Ready with React and Flask</em>, and revisit the <em class="italic">Setting up a development environment with </em><em class="italic">React</em> section.</p>
<p>In this chapter, we’ll systematically start to introduce you to the world of React in a subtle way. You will learn a bunch of cool concepts and techniques that will help you develop intuitive user interfaces that enable users to interact with your web application. You will learn how to spring up your first React project without the hassle of a complex configuration and understand the basic directory structure required for every React project. Then, you’ll learn how to use ES6 features in React.</p>
<p><strong class="bold">Components</strong> are<a id="_idIndexMarker057"/> the building blocks of any React application. In this chapter, you will understand concepts around components and how you can use them to build user interfaces in React. This knowledge is vital for building modern frontend technologies in your project. With detailed use cases, you will understand the use of props in React for passing information between components, and how states add interactivity to React applications.</p>
<p>By the end of this chapter, you will have acquired, in a practical way, the skill sets required to get started with any React project. You will also have a deeper understanding of React core features (components, props, and state) to develop interactivity in any web application.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Exploring a React project directory structure</li>
<li>Arrow functions in React</li>
<li>Understanding what destructuring is</li>
<li>Default and named exports</li>
<li>What is a React component?</li>
<li>What are props?</li>
<li>React state</li>
</ul>
<h1 id="_idParaDest-30"><a id="_idTextAnchor040"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter02">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter02</a>.</p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor041"/>Exploring a React project directory structure</h1>
<p>In a moment, we’ll set up a React application project. There are many ways to create a React application. You could use the <strong class="bold">Create React App</strong> tool<a id="_idIndexMarker058"/> to generate a boilerplate application with no build configurations. This doesn’t require you to have complex configuration knowledge.</p>
<p>You can simply focus on the implementation of your application straight up. This is what we’ll be using in this book. And if you are <a id="_idIndexMarker059"/>open to exploring <strong class="bold">Vite</strong> (<a href="https://vitejs.dev/">https://vitejs.dev/</a>), it is another<a id="_idIndexMarker060"/> next-generation frontend tooling for rapid React application setup.</p>
<p>The other way of creating a React application requires knowledge of Webpack and Babel configurations. Now, without further delay, let’s dive into creating our React project application. You are expected to follow along.</p>
<p>Open your terminal and type the following command:</p>
<pre class="console">npx create-react-app frontend</pre>
<p>You will get the following output:</p>
<div><div><img alt="Figure 2.1 – Screenshot of the create -react-app command" src="img/Figure_2.1_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Screenshot of the create -react-app command</p>
<p>Navigate into the <code>frontend</code> folder after the setup has finished:</p>
<pre class="console">$ cd frontend</pre>
<p>Now, we can open the application<a id="_idIndexMarker061"/> using <code>code .</code> on the command line:</p>
<div><div><img alt="Figure 2.2 – Screenshot of ﻿create-react-app showing code ﻿to open the VS Code editor ﻿in the project root directory" src="img/Figure_2.2_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Screenshot of create-react-app showing code to open the VS Code editor in the project root directory</p>
<p>The following extracted folders a<a id="_idTextAnchor042"/>nd files structure will appear in the VS Code editor:</p>
<pre class="source-code">frontend/--node_modules/
--public/
----index.html
----manifest.json
--src/
----App.css
----App.js
----App.test.js
----index.css
----index.js
--.gitignore
--package-lock.json
--package.json
--README.md</pre>
<p>The following screenshot shows the screenshot of the VS Code project directory structure:</p>
<div><div><img alt="Figure 2.3 – Screenshot showing the project directory structure" src="img/Figure_2.3_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Screenshot showing the project directory structure</p>
<p>So, let’s quickly dive into the<a id="_idIndexMarker062"/> preceding file and folder list to understand their individual purposes:</p>
<ul>
<li><code>node_modules/</code>: This folder holds all node packages installed with the Create React App tool. All the <code>dependencies</code> and <code>devdependencies</code> are stored inside. It is good to note that all subsequent packages we’ll install in the future will also be kept in this folder.</li>
<li><code>public/</code>: This folder contains important public files such as <code>public/index.html</code> and <code>public/manifest.json</code>:<ul><li>The <code>index</code> file displays on <code>localhost:3000</code> when the app is in the development environment or on a hosted domain. Essentially, this file puts React components’ execution results in the <code>index</code> file’s root <code>div</code> container for public view.</li>
<li>The folder also contains the <code>manifest.json</code> file, which contains application metadata and details for responsive screen display.</li>
</ul></li>
<li><code>src/</code>: This is the most vital folder in React application development. More than 80% of your coding activities’ time will be spent here. So, it is important to know exactly what you are doing inside this folder. This folder contains components and a few other files, such as <code>src/App.js</code>, <code>src/App.css</code>, <code>src/index.css</code>, <code>src/App.test.js</code>, and <code>src/index.js</code>:<ul><li>The <code>src/App.js</code> file is used to implement React components. If you are working on a small project, you can use it to implement your application without creating other component files. All your component code will be put inside a single file. As your application grows, you might consider splitting up your components into multiple component files. With this split up, each file will then maintain one or more components.</li>
<li>The <code>src/App.css</code> file is used to style your component. The same goes for the <code>src/index.css</code> file, which is used to style your overall application. Both these files can be edited to suit your style requirements.</li>
<li>The <code>src/App.test.js</code> file is used to write unit tests for React applications.</li>
<li>The <code>index.js</code> file is the entry point to your React application.</li>
</ul></li>
<li><code>.gitignore</code>: This <a id="_idIndexMarker063"/>file contains lists of files and folders that shouldn’t be tracked and added to the Git repository in your project. For instance, <code>node_modules</code> is always listed in the file as it is only needed in the development environment.</li>
<li><code>package.json</code>: This file contains node package dependencies and other metadata used in the project. This makes it easy to set up the same on another computer system<a id="_idIndexMarker064"/> using <strong class="bold">Node Package Manager</strong> (<strong class="bold">npm</strong>) without much hassle.</li>
<li><code>package-lock.json</code>: This file stores the version number of your installed packages from <code>npm</code>. This ensures consistency of package installation from <code>npm</code> to other developers’ local computer systems.</li>
<li><code>README.md</code>: This is a Markdown file. <code>README.md</code> file helps developers to give instructions and essential information about their projects. On GitHub, you can use the <code>README.md</code> file to display information about the content contained in project repositories. The <a id="_idIndexMarker066"/>Create React App tool generates this file for us out of the box.</li>
</ul>
<p>Now that you know some of the purposes of the folders and files structure of your React project, let’s run the <code>npm start</code> command in the terminal to see the default React application:</p>
<div><div><img alt="Figure 2.4 – Screenshot of the React app home page on localhost:3000" src="img/Figure_2.4_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Screenshot of the React app home page on localhost:3000</p>
<p class="callout-heading">Note</p>
<p class="callout">The following shows some of the messages such as success messages, available scripts, and how to start the development server after the installation of React:</p>
<ul>
<li class="callout"><code>npm start</code>: Starts the development server</li>
<li class="callout"><code>npm run build</code>: Bundles the app into static files for production</li>
<li class="callout"><code>npm test</code>: Starts the test runner</li>
</ul>
<p>In summary, we have discussed how you can power up your React application with the create-react-app tool. You now know what each folder and file represents in detail. With this, you can be confident that you know how to set up a React application. Let’s start the next section by discussing arrow functions. Arrow functions are one of the features<a id="_idIndexMarker067"/> of <strong class="bold">ECMAScript 2015</strong> (<strong class="bold">ES6</strong>). They’re a nifty addition to JavaScript that makes writing functions a breeze!</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor043"/>Arrow functions in React</h1>
<p><strong class="bold">Arrow functions</strong> provide a more concise and readable syntax for defining functions in JavaScript. Arrow functions<a id="_idIndexMarker068"/> have become a widely used feature in React development <a id="_idIndexMarker069"/>for obvious reasons: shorter syntax and implicit return. You will have a better understanding of what these mean in a moment.</p>
<p>In traditional JavaScript, you would have to define a regular function that adds two numbers together like this:</p>
<pre class="source-code">function addNumbers(a, b) {    return a + b;
}</pre>
<p>Not bad, right? But arrow functions can make this even simpler and more elegant. Check this out:</p>
<pre class="source-code">const addNumbers = (a, b) =&gt; {    return a + b;
};</pre>
<p>Pretty cool? The <code>function</code> keyword is replaced with a funky-looking arrow, <code>=&gt;</code>, and you can omit the curly braces and the <code>return</code> statement if your function is just a one-liner:</p>
<pre class="source-code">const addNumbers = (a, b) =&gt; a + b;</pre>
<p>Basically, you define arrow functions by following this syntax rule:</p>
<pre class="source-code">const functionName = (parameters) =&gt; {    return returnValue;
};</pre>
<p>Or, for even shorter function definition with implicit return when the function body consists of a single expression, use this rule:</p>
<pre class="source-code">const functionName = (parameters) =&gt; returnValue;</pre>
<p>Arrow functions are often used within React applications due to their concise syntax and benefits, especially when defining function components, handling event callbacks, and mapping arrays. We will see more arrow functions usage in the course of this book.</p>
<p>However, it’s important to note that arrow functions are not a complete replacement for regular functions. They have some limitations, such as not having their own <code>this</code> context, which makes them unsuitable for certain use cases, such as defining object methods.</p>
<p>When used in<a id="_idIndexMarker070"/> defining the object method, arrow functions do not <a id="_idIndexMarker071"/>have their own context and would not properly access the name property within the object. Let’s use the following code example to illustrate it better.</p>
<pre class="source-code">const speaker = {    name: 'Alice Andrew',
    sayHi: function () {
        console.log(`Hi, I'm ${this.name}!`);
    },
};
speaker.sayHi(); // Output: Hi, I'm Alice Andrew!</pre>
<p>Now, let’s use an arrow function to define the object method:</p>
<pre class="source-code">const speaker = {    name: 'Alice Andrew',
    sayHi: () =&gt; {
        console.log(`Hi, I'm ${this.name}!`);
    },
};
speaker.sayHi(); // Output: Hi, I'm undefined!</pre>
<p>In summary, arrow<a id="_idIndexMarker072"/> functions are a fantastic feature in ES6, making your code<a id="_idIndexMarker073"/> cleaner and more pleasant to work with. They’re perfect for short functions and can make your life as a React developer a whole lot easier.</p>
<p>Next, we will take a look at another cool ES6 feature: <strong class="bold">destructuring</strong>. You will need the destructuring technique to be able to extract values from arrays or objects in a more concise and readable way.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor044"/>Understanding what destructuring is</h1>
<p><strong class="bold">Destructuring</strong> is simply<a id="_idIndexMarker074"/> a JavaScript expression that ensures you are able to extract multiple values from arrays or properties from objects into separate unique variables. Destructuring is one of the awesome JavaScript ES6 features used in React to manage data.</p>
<p>ES6 was a major milestone in the effort to improve standards in the JavaScript language. Destructuring takes extracting data from arrays and objects to a new concise level. Prior to ES6, you could declare and extract data from an array this way:</p>
<pre class="source-code">const speakers = ["John", "Walke", "Dan", "Sophie"];const firstspeakerName = speakers[0];
const secondspeakerName = speakers[1];
const thirdspeakerName = speakers[2];
const fourthspeakerName = speakers[3];
console.log(firstspeakerName); // "John"
console.log(secondspeakerName); // "Walke"
console.log(thirdspeakerName); // "Dan"
console.log(fourthspeakerName); // "Sophie"</pre>
<p>With<a id="_idIndexMarker075"/> destructuring, the code looks like this:</p>
<pre class="source-code">const speakers = ["John", "Walke", "Dan", "Sophie"];const [firstspeakerName, secondspeakerName,
    thirdspeakerName,fourthspeakerName] = speakers
console.log(firstspeakerName) // "John"
console.log(secondspeakerName) // "Walke"
console.log(thirdspeakerName) // "Dan"
console.log(fourthspeakerName) // "Sophie"</pre>
<p>If we want to skip <code>"John"</code> in the array and write out to the console the remaining items in the array, we can do the following:</p>
<pre class="source-code">const speakers = ["John", "Walke", "Dan", "Sophie"];const [, ...rest] = speakers // the … used is called the
                                spread operator
console.log(rest)// output: "Walke", "Dan", "Sophie" John
                    will be skipped</pre>
<p>In addition, it is not only arrays that can be destructured; you can perform destructuring in objects as well. For instance, the following code shows how to destructure object properties:</p>
<pre class="source-code">const speakers = {    id: 1,
    name: "Juliet Runolf",
    jobTitle: "Director, Marketing",
    company: "Abernatny Group",
    address: {
    street: "Okaland Dtuse",
    city: "Greenland",
    state: "Houston",
    country: "USA",
    }
}
function App()
{
    const {name, jobTitle, company} = speakers;
    //destructuring of object properties
    return (
        &lt;&gt;
            &lt;div&gt;
                &lt;h2&gt;Name: {name}&lt;/h2&gt;
                &lt;h4&gt;Position: {jobTitle}&lt;/h4&gt;
                &lt;h4&gt;Company: {company}&lt;/h4&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
}</pre>
<p>You can see how we were able to extract the values of properties in the preceding code snippet. It is even possible to<a id="_idIndexMarker076"/> destructure the nested <code>address</code> property in the object:</p>
<pre class="source-code">const {name, jobTitle, company, address} = speakers;// destructuring of object properties
const {street, city, state, country} = address;
// destructuring of nested address property
    return (
    &lt;div&gt; &lt;h2&gt;Name: {name}&lt;/h2&gt;
        &lt;h4&gt;Position: {jobTitle}&lt;/h4&gt;
        &lt;h4&gt;Company: {company}&lt;/h4&gt;
        &lt;h4&gt;Street: {street}&lt;/h4&gt;
        &lt;h4&gt;City: {city}&lt;/h4&gt;
        &lt;h4&gt;State: {state}&lt;/h4&gt;
        &lt;h4&gt;Country: {country}&lt;/h4&gt;
    &lt;/div&gt;
  );
}</pre>
<p>So, what are the benefits of destructuring in React applications? Destructuring makes your code more compact and easier to understand. It allows you to extract specific properties from objects or elements from arrays directly, reducing the need for repetitive dot notation or array indexing.</p>
<p>Also, destructuring allows you to set default values for properties – for instance, take a look at the following line<a id="_idTextAnchor045"/> of code:</p>
<pre class="source-code">const { name = 'Anonymous', age = 0} = speaker</pre>
<p>The preceding code can be useful when working with optional or potentially undefined data and default values are required. Destructuring is used in accessing <code>props</code> and <code>state</code> in components. Oh, you don’t know what <code>components</code>, <code>props</code>, and <code>state</code> are all about? Fret not, we will discuss these concepts in this chapter shortly.</p>
<p>In summary, destructuring<a id="_idIndexMarker077"/> allows programmers to access data, even complex nested data in arrays and objects, in an easy way. It substantially improves the quality of code readability and access. And if you want a shorter line of code in your React application, destructuring clearly helps. It helps to cut the amount of code used in an application.</p>
<p>The next cool concepts to understand in React application development are default and named exports. Let’s dive in and understand these React concepts.</p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor046"/>Default and named exports</h1>
<p>As mentioned earlier, ECMAScript 2015, also known as ES6, was a major milestone in the effort to improve standards in the JavaScript language. Among the new features added were modules and the ability to <a id="_idIndexMarker078"/>use <code>import</code> expressions. Modules allow us<a id="_idIndexMarker079"/> to better organize our code base into logical units. Basically, modules could be a function or related functions designed to perform specific tasks. They make code reusability across projects easier.</p>
<p>In React, we use a default export to make component functions, variables, classes, or objects available to other component files. Only one default export<a id="_idIndexMarker080"/> is allowed per file.</p>
<p>For instance, the following code makes it possible to import a file from the <code>Speaker</code> component:</p>
<pre class="source-code">import Speaker from './Speaker';</pre>
<p>The following code makes it possible to export the file to another component file:</p>
<pre class="source-code">function App(){
    return (
    &lt;div&gt;  …   &lt;/div&gt;
    );
}
    export default App; // Specifically, this code line
                           makes it possible to export the
                           file to another component file</pre>
<p>In a named export, you can have multiple named exports<a id="_idIndexMarker081"/> per file. And when you want to import, you can name the specific import with braces, like this:</p>
<pre class="source-code">import { FirstComponent, SecondComponent } from "./ThirdComponent";</pre>
<p>To sum up, default and named components are a way to make specific functions available across components in any React project.</p>
<p>Next, <a id="_idTextAnchor047"/>we’ll delve into the core essence of React components and gain a clear understanding of their purpose and functionality.</p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor048"/>What is a React component?</h1>
<p>A <strong class="bold">component</strong> is the core <a id="_idIndexMarker082"/>building block of any React application. Sometimes, you could perceive React as a JavaScript coated with some chocolate. Chocolate is sweet I guess, and so is React. Seriously, building a UI with vanilla JavaScript can be cumbersome. You can struggle with the expensive DOM dilemma!</p>
<p>The thing is, when working with vanilla JavaScript to handle the <strong class="bold">Document Object Mo<a id="_idTextAnchor049"/>del</strong> (<strong class="bold">DOM</strong>), it can get <a id="_idIndexMarker083"/>pretty expensive – both in terms of time and effort. Frequent DOM manipulation is high in non-React applications, which ultimately results in the slowness of website elements update.</p>
<p>The <strong class="bold">virtual DOM</strong> solved<a id="_idIndexMarker084"/> this problem in React. The DOM only updates what was changed, not the entire DOM tree. However, if you remember how you use functions in plain JavaScript, writing components won’t be a challenge. A function in JavaScript is a code block designed essentially to perform certain tasks.</p>
<p>The same applies to React components, which are reusable, maintainable, and self-contained blocks of code to return a UI. In React, components return HTML elements mixed with some JavaScript.</p>
<p>There are two types of React components: <strong class="bold">class components</strong> and <strong class="bold">function components</strong>. In this book, we’ll <a id="_idIndexMarker085"/>adopt function component <a id="_idIndexMarker086"/>coding patterns to develop our React application.</p>
<p>Function components are<a id="_idIndexMarker087"/> the present and future of React, so if you are just learning React, the function component is easier to learn without the extras involved in writing class components. And if you are already familiar with class components in React, you can still use function components along with class components. If you find yourself working with a legacy React code base, it’s definitely worth considering a gradual migration toward function components.</p>
<p>Let us learn how to<a id="_idIndexMarker088"/> define a function component and use it in React applications by doing the following steps:</p>
<ol>
<li>Open <code>App.js</code> in the <code>src/</code> file of the React project directory. The <code>src/App.js</code> file contains the following code:<pre class="source-code">import logo from './logo.svg';import './App.css';function App() {    return (        &lt;div className="App"&gt;            &lt;header className="App-header"&gt;                &lt;img src={logo} className="App-logo"                    alt="logo" /&gt;                &lt;p&gt;                    Edit &lt;code&gt;src/App.js&lt;/code&gt; and                        save to reload.                &lt;/p&gt;                &lt;a                    className="App-link"                    href="https://reactjs.org"                    target="_blank"                    rel="noopener noreferrer"&gt;                    Learn React                &lt;/a&gt;            &lt;/header&gt;        &lt;/div&gt;    );}export default App;</pre></li>
<li>Let’s remove all the <a id="_idIndexMarker089"/>boilerplate code in the file to easily understand the code structure. Replace the preceding code snippet with the following code snippet:<pre class="source-code">function App() {    return (        &lt;div&gt;            &lt;h1&gt;Welcome to Bizza Platform&lt;/h1&gt;        &lt;/div&gt;    );}export default App;</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Your <code>src/App.js</code> file should now look like the preceding snippet.</p>
<ol>
<li value="3">Save the file, start your application with <code>npm start</code> in the command line, and you will get the following output:</li>
</ol>
<div><div><img alt="Figure 2.5 – Screenshot showing the output of the npm start command" src="img/Figure_2.5_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Screenshot showing the output of the npm start command</p>
<ol>
<li value="4">Check <a id="_idIndexMarker090"/>whether <strong class="bold">Welcome to Bizza Platform</strong> displays on your browser. If yes, you are still on the right track.</li>
</ol>
<div><div><img alt="Figure 2.6 – Screenshot of the React app home page on localhost:3000" src="img/Figure_2.6_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Screenshot of the React app home page on localhost:3000</p>
<p>So, let’s dive deeper into each element of the code block to understand function components better.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor050"/>Function components</h2>
<p>As stated <a id="_idIndexMarker091"/>already, function components<a id="_idIndexMarker092"/> are conceptually a typical JavaScript function with the ability to receive data as props and return HTML elements in the form of JavaScript XML.</p>
<p>In the<a id="_idIndexMarker093"/> preceding code, the <code>App</code> component doesn’t have any parameters <a id="_idIndexMarker094"/>yet in its function definition.</p>
<p>This is how you define an <code>App</code> component in a React application:</p>
<pre class="source-code">    function App() {.....}</pre>
<p>The code returns the following HTML elements:</p>
<pre class="source-code">    return (        &lt;div&gt;
            &lt;h1&gt;....&lt;/h1&gt;
        &lt;/div&gt;
    );</pre>
<p>The <code>App</code> component returns HTML code. The returned HTML code is a mixture of HTML and JavaScript. This is called <strong class="bold">JavaScript XML</strong> (<strong class="bold">JSX</strong>). JSX is a syntax extension used in React that allows you to write HTML-like<a id="_idIndexMarker095"/> code directly within JavaScript. JSX makes it easier to describe the structure of user interfaces in React components. In <a href="B18554_05.xhtml#_idTextAnchor095"><em class="italic">Chapter 5</em></a>, <em class="italic">JSX and Displaying Lists in React</em>, we’ll discuss JSX in depth.</p>
<p>As discussed earlier, we’ll be focusing more on function components in this book. If you are comfortable writing functions in plain JavaScript, function components in React will definitely be familiar. In React function components, you are able to have implementation details between the function definition and the <code>return</code> statement.</p>
<p>For instance, let’s check <code>App</code> component inside <code>src/App.js</code>:</p>
<pre class="source-code">function App() {    // you can perform some operations here.
    return (
        &lt;div&gt;
            &lt;h1&gt;Welcome to Bizza Platform&lt;/h1&gt;
        &lt;/div&gt;
    );
}
export default App;</pre>
<p>Any variables defined in the function’s body will be re-defined each time this function runs:</p>
<pre class="source-code">function App() {    const speakerName = 'John Wilson';
    // variable declared inside function component body
    return (
        &lt;div&gt;
            &lt;h1&gt;Welcome to Bizza Platform, {speakerName}
                &lt;/h1&gt;
        &lt;/div&gt;
    );
}
export default App;</pre>
<p>Start your <a id="_idIndexMarker096"/>browser with <code>npm start</code> and check the updated content<a id="_idIndexMarker097"/> in your browser.</p>
<p>If your server is still running, you do not need to use <code>npm start</code> again. Your app will recompile and display an updated view as soon as you save your file:</p>
<div><div><img alt="Figure 2.7 – Screenshot showing the preceding snippet output" src="img/Figure_2.7_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Screenshot showing the preceding snippet output</p>
<p>Also, you can have your variable defined outside the body of your component:</p>
<pre class="source-code">const speakerName = 'John  Wilson';// variable declared outside function component body
function App() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Welcome to Bizza Platform, {speakerName}
                &lt;/h1&gt;
        &lt;/div&gt;
    );
}
export default App;</pre>
<p>In the function<a id="_idIndexMarker098"/> component, the results from the function<a id="_idIndexMarker099"/> operation can either be <em class="italic">run the first time</em> or <em class="italic">re-rendered on updates.</em> However, you can define your variable outside the function component if it doesn’t need anything from within the function component’s body; otherwise, consider defining it in the function component’s body.</p>
<p>In summary, we have been able to discuss function components in React and how to write and display the content of your function component. Next, we will discuss class components and why they are called <strong class="bold">stateful components</strong>.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor051"/>Class components</h2>
<p>React provides us with the <a id="_idIndexMarker100"/>flexibility to <a id="_idIndexMarker101"/>construct UI components using either functions or classes for the component code. Class components are JavaScript classes that extend <code>React.Component</code> and call a <code>render</code> method that returns an HTML element. Classes are stateful and were the only way to manage state in React before the React team came up with Hooks. More on Hooks later, in <a href="B18554_03.xhtml#_idTextAnchor064"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing State with React Hooks</em>. Let’s look at the class code syntax for writing minimal React class components.</p>
<p>Create a <code>SpeakerProfile.js</code> file in <code>src/</code> and type in the following code in <code>src/SpeakerProfile.js</code>:</p>
<pre class="source-code">import React from 'react';class SpeakerProfile extends React.Component {
    render() {
        return &lt;h1&gt;This is the class component expression
            from Speaker Profile!&lt;/h1&gt;;
    }
}
export default SpeakerProfile;</pre>
<p>Let’s dive into each line of code to understand what they do:</p>
<ul>
<li><code>import React from 'react'</code>: This allows us to use the core functions of React in our code file</li>
<li><code>class S<a id="_idTextAnchor052"/>peakerProfile extends React.Component { }</code>: This allows us to create the <code>SpeakerProfile</code> class component that inherits from the <code>React.Component</code> base class</li>
<li><code>render() {  return &lt;h1&gt;...&lt;/h1&gt;;  </code><code>}</code>: Every class component must have a <code>render</code> function that returns an HTML element</li>
</ul>
<p>The preceding<a id="_idIndexMarker102"/> code lines explain the basic structure of React <a id="_idIndexMarker103"/>class components.</p>
<p>In <code>src/App.js</code>, add the following:</p>
<pre class="source-code">import React from 'react';import SpeakerProfile from './SpeakerProfile';
function App(){
    return (
        &lt;div style={{backgroundColor: 'gray', margin:20,
            color:'white'}}&gt;
        &lt;SpeakerProfile  /&gt;
        &lt;/div&gt;
    );
}
export default App;</pre>
<p>If your <code>http://localhost:3000/</code> server is still running, you will see the following screen. If not, open <a id="_idIndexMarker104"/>your terminal and go to your working directory and type <a id="_idIndexMarker105"/>the <code>npm </code><code>start</code> command:</p>
<div><div><img alt="Figure 2.8 – Screenshot showing output for class component" src="img/Figure_2.8_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Screenshot showing output for class component</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>&lt;SpeakerProfile</code><code>  /&gt;</code> component was added to <code>src/App.js</code> for rendering the content of the <code>SpeakerProfile</code> component.</p>
<p>Let’s compare the function component equivalent to the class component we wrote in <code>src/SpeakerProfile.js</code>:</p>
<pre class="source-code">import React from 'react';const SpeakerProfile =()=&gt; {
return &lt;h1&gt;This is a function component equivalent to a
    class component !&lt;/h1&gt;;
}
export default SpeakerProfile;</pre>
<p>So, you <a id="_idIndexMarker106"/>can see that the function components take fewer lines of code – meaning <a id="_idIndexMarker107"/>they can be elegant, concise, and readable. When using funct<a id="_idTextAnchor053"/>ion components, you don’t need to define a <code>render()</code> method, and the component itself is the function that returns JSX, making the code simpler and easier to read.</p>
<p>Let’s briefly discuss the subtle differences in class and function components.</p>
<h3>Class component versus function component</h3>
<p>When creating a <a id="_idIndexMarker108"/>class component, you must <a id="_idIndexMarker109"/>inherit it from <code>React.Component</code> with the <code>extend</code> keyword and create a <code>render</code> method that is responsible for returning a React element. In the function component, there is no <code>render</code> function. It accepts <code>props</code> as an argument and returns HTML elements.</p>
<p>Class components are stateful when compared to function components, which are stateless. The only way you could make a function component stateful was to rewrite the code as a class component before Hooks came to its rescue with React version 16.8. Now, with Hooks, function components can be stateful.</p>
<p>In class components, you can utilize React life cycle methods such as <code>componentDidMount()</code>, <code>componentDidUpdate()</code>, and <code>componentWillUnmount()</code>. However, in React function components, you cannot use these life cycle methods.</p>
<p>In summary, we discussed class components in React and how to write and display the content of your class component. Next, we will be discussing the component life cycle to better design reusable and maintainable React components.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor054"/>Component life cycle</h2>
<p>So far, we have seen the<a id="_idIndexMarker110"/> component-oriented nature of every React application. Components interact with components to provide an interface for user interaction in web applications. However, a component – the building block of every UI we interact with – has a life cycle.</p>
<p>As in life, there are different phases involved; we are born, then we grow, and then we die. React components experience phases as well. They undergo three phases: mounting, updating, and unmounting. Each of these phases will be discussed briefly.</p>
<h3>Mounting phase</h3>
<p>This represents the birth phase of a<a id="_idIndexMarker111"/> React component. This is the phase when a component instance is created and inserted into the DOM. There are four methods present in this phase, which are listed as follows in their order:</p>
<ol>
<li><code>constructor()</code>: This method is called during the mounting phase and actually before the component is mounted. Calling the <code>constructor()</code> method accepts <code>props</code> as arguments. This is followed by calling <code>super(props)</code> as well. The <code>constructor()</code> method, however, serves two main purposes:<ul><li>Initializes a local state in the class component by assigning an object to <code>this.state</code></li>
<li>Binds event handler methods</li>
</ul></li>
<li><code>static getDerivedStateFromProps()</code>: This method is invoked immediately before rendering the elements in the DOM.</li>
<li><code>render()</code>: This method is the most vital and it is always required for outputting React HTML elements. It normally injects HTML into the DOM. What you see on your interface depends on what this <code>render</code> method returns in the form of JSX.</li>
<li><code>componentDidMount()</code>: This method is initiated after the React component is rendered <a id="_idTextAnchor055"/>into the DOM tree, essentially after the first <code>render()</code> invocation. The <code>componentDidMount()</code> method allows you to execute user actions and other side effects once components are mounted. For instance, the <code>componentDidMount()</code> method can run statements that require the loading of data from external sources. Also, you can trigger a user or system event when components<a id="_idIndexMarker112"/> had been rendered.</li>
</ol>
<h3>Updating phase</h3>
<p>This is the hypothetical growing <a id="_idIndexMarker113"/>phase of the React component. This phase occurs immediately after the mounting phase of the component life cycle. The <code>componentDidUpdate()</code> method is commonly used in this phase. A React component is updated whenever there is a change in data st<a id="_idTextAnchor056"/>ate or props. The state is re-rendered using the <code>render()</code> method, and the updated state is returned to the UI.</p>
<h3>Unmounting phase</h3>
<p>This phase is regarded as the <a id="_idIndexMarker114"/>death phase of the component life cycle process. The <code>componentWillUnmount()</code> method is invoked in this phase immediately before the component is unmounted from the DOM tree.</p>
<p>Typically, web applications have many user interfaces, such as buttons, form input, accordions tabs, and even a navigation bar in our application. Users tend to move from one component interaction to another and, on the whole, have a reactive experience.</p>
<p>So, when users stop interacting with a component – say by moving on from a<em class="italic"> contact</em> component to an <em class="italic">accordion tab</em> on the home page of our application – that switch from the <em class="italic">contact</em> page to an <em class="italic">accordion tab</em> on the home page spells the death of the life cycle to the <em class="italic">contact</em> page component.</p>
<p>At every point in the <a id="_idIndexMarker115"/>user interaction cycle, the React components are either inserted into the DOM tree or state changes, or the completion of component’s lifecycle.</p>
<p>The following figure shows the React life cycle methods:</p>
<div><div><img alt="Figure 2.9 – React life cycle methods (source: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)" src="img/Figure_2.09_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – React life cycle methods (source: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)</p>
<p>In summary, we have briefly discussed various life cycle methods in React class components and why each of them exists in rendering React components. Later in the book, we’ll explore how the life cycle is handled in a function component. Meanwhile, we will be discussing <strong class="bold">properties</strong> (<strong class="bold">props</strong>) in React. Props are one of the key features that allow React components to communicate with other components, making React applications so reusable.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor057"/>What are props?</h1>
<p><strong class="bold">Props</strong> are arguments <a id="_idIndexMarker116"/>passed to React functions and class components. If that is too techy, let’s break it down a bit. Basically, you use props to pass data from one component to another component. So, props refer to objects that store the value of attributes. This is similar to HTML when you pass a value to an attribute of a tag.</p>
<p>In the React world, props are used to customize and configure components and are passed from parent to child down the component tree. This means the parent component can only pass information to the child component. This is a unidirectional data flow concept in React. In essence, props are read-only, meaning that the component receiving them cannot modify their values directly.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor058"/>Passing data as props</h2>
<p>Let’s take a <a id="_idIndexMarker117"/>look at an example where props are used in React <a id="_idIndexMarker118"/>components. As we have discussed, props are used in React to pass information from one component to another. In the following snippet, we will explain how data is passed as props in React.</p>
<p>In <code>src/App.js</code>, add the following:</p>
<pre class="source-code">import React from 'react';function SpeakerProfile(props) {
    return(
        &lt;&gt;
            &lt;h3&gt;{props.name}&lt;/h3&gt;
            &lt;p&gt;Position: {props.jobTitle}&lt;/p&gt;
            &lt;p&gt;Company: {props.company}&lt;/p&gt;
        &lt;/&gt;
    );
}
//Parent component
function App() {
    return (
        &lt;&gt;
            &lt;h1&gt;Speaker Profile&lt;/h1&gt;
            // Child component with attributes
               name,jobTitle and company inside parent
               component
            &lt;SpeakerProfile
                name='Juliet Runolf'
                jobTitle='Director,
                Marketing' company='Abernathy Group'
            /&gt;
        &lt;/&gt;
    );
}
export default App;</pre>
<p>In the <a id="_idIndexMarker119"/>preceding code, we<a id="_idIndexMarker120"/> added a child component, <code>&lt;SpeakerProfile /&gt;</code>, into the parent function component, <code>App.js</code>, and have some props passed to the <code>&lt;</code><code>SpeakerProfile/&gt;</code> component.</p>
<p>Now, let’s dive into the internal structure of the <code>SpeakerProfile</code> snippet:</p>
<pre class="source-code">const SpeakerProfile = (props)=&gt;{    return(
        &lt;&gt;
            &lt;h3&gt;{props.name}&lt;/h3&gt;
            &lt;p&gt;Position: {props.jobTitle}&lt;/p&gt;
            &lt;p&gt;Company: {props.company}&lt;/p&gt;
        &lt;/&gt;
    );
}</pre>
<p><code>SpeakerProfile</code> is a child component. We define a <code>SpeakerProfile</code> function and pass data props to it in the parent component. In the <code>Speake<a id="_idTextAnchor059"/>rProfile</code> component body, we return HTML elements, <code>&lt;h3&gt;{props.name}&lt;/h3&gt;</code>.</p>
<p>We then pass attribute values to these properties (props) from the <code>App</code> parent component to the <code>SpeakerProfile</code> child component:</p>
<pre class="source-code">    &lt;p&gt;Position: {props.jobTitle}&lt;/p&gt;    &lt;p&gt;Company: {props.company}&lt;/p&gt;</pre>
<p>The <a id="_idIndexMarker121"/>following shows the screen output for the props passed <a id="_idIndexMarker122"/>to the <code>SpeakerProfile</code> component:</p>
<div><div><img alt="Figure 2.10 – Screenshot showing props in a component" src="img/Figure_2.10_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Screenshot showing props in a component</p>
<p>In summary, we learned how to pass information from one component to another component in a function component. The flow of information from the parent component to the child component is expected to be unidirectional as a rule in React: from parent to child component.</p>
<p>Props are read-only. Child components cannot mutate directly. Later in the chapter, we’ll discuss how this rule can be overridden by passing props from <a id="_idTextAnchor060"/>the child to the parent component.</p>
<p>Now, we will discuss state in React as a way to make React components dynamic and interactive.</p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor061"/>React state</h1>
<p><strong class="bold">State</strong> is a built-in <a id="_idIndexMarker123"/>object in React that is used to hold information about components. It is<a id="_idIndexMarker124"/> what is responsible for the interactivity of components. In the React application, stat<a id="_idTextAnchor062"/>e changes. When there is a change in the component state, React re-renders the component.</p>
<p>This change also impacts how the component behaves and renders on the screen. There are factors that can make the state change – for instance, a response to a user’s action or system-generated events. Props and state are twin features of React. While props essentially pass information from a parent component to a child component, state alters components’ internal data.</p>
<p>Let’s take a look at a search use case for the implementation of state in components. Anytime a user types something into an HTML search input field, the user intends to see this typed information, which represents a new state, displayed somewhere else in the application.</p>
<p>The default state is <a id="_idIndexMarker125"/>the blank search input field. Hence, we need a way to change <a id="_idIndexMarker126"/>information in the input field and notify React to re-render its component. This means displaying the new state of the component.</p>
<p>Let’s add a new component named <code>SearchSpeaker.js</code> to <code>src/SearchSpeaker/</code>:</p>
<pre class="source-code">import React,{useState} from "react";const SearchSpeaker = () =&gt;{
    const [searchText, setSearchText] = useState('');
    return (
        &lt;div&gt;
             &lt;label htmlFor="search"&gt;Search speaker:
                 &lt;/label&gt;
             &lt;input id="search" type="text" onChange={e =&gt;
                 setSearchText(e.target.value)} /&gt;
             &lt;p&gt;
                 Searching for &lt;strong&gt;{searchText}
                     &lt;/strong&gt;
             &lt;/p&gt;
        &lt;/div&gt;
    );
}
export default SearchSpeaker;</pre>
<p>In the preceding code snippet, the <code>SearchSpeaker</code> component has two variables:</p>
<pre class="source-code">const [searchText, setSearchText] = useState('');</pre>
<p>The <code>searchText</code> and <code>setSearchText</code> variables manage how the <code>searchSpeaker</code> component updates its state upon changes in state. This line of code is an example of the array destructuring we discussed earlier, where we assign the values returned by the <code>useState</code> hook to two variables in a single line. In <a href="B18554_03.xhtml#_idTextAnchor064"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing State with React Hooks</em>, we will discuss <code>useState</code> extensively.</p>
<p>The <code>searchText</code> variable<a id="_idIndexMarker127"/> is used to set the current state and tells React to re-render its <code>searchSpeaker</code> component whenever the event handler notifies a change in state <a id="_idIndexMarker128"/>with the new value or state set by <code>setSearchText</code>.</p>
<p>In React, <code>useState</code> is a utility function that takes an initial state as an argument. In this case, the initial state is empty: <code>useState('')</code>. The empty string initial state notifies React that the state will change over time.  Therefore, <code>useState</code> comprises a two-entry array. The first entry, <code>searchText</code>, represents the current state; the second entry is a function to change the state using <code>setSearchText</code>.</p>
<p>These are the mechanisms we use to display the current state or change the state inside a React component.</p>
<p>In <code>App.js</code>, add the following code:</p>
<pre class="source-code">…import SearchSpeaker from './SearchSpeaker';
function App()
{
    return (
        &lt;div style={{backgroundColor: 'blue', margin:20,
            color:'white'}}&gt;
            &lt;h1&gt;...&lt;/h1&gt;
            …..
            &lt;SearchSpeaker   /&gt;
        &lt;/div&gt;
    );
}
export default App;</pre>
<p>The following screenshot shows how the state changes in a React component:</p>
<div><div><img alt="Figure 2.11 – Screenshot showing the onChange state of the form field" src="img/Figure_2.12_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Screenshot showing the onChange state of the form field</p>
<p>With the<a id="_idIndexMarker129"/> understanding of state as an object used by React components<a id="_idIndexMarker130"/> to hold and manage data that can change over time, developers can create interactive and dynamic UIs that respond to user actions, and also provide a better user experience.</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor063"/>Summary</h1>
<p>In this chapter, we discussed some of the core concepts in React applications. We started with the basic anatomy of a React project structure as generated by the Create React App tool. Some of the purposes of the files and folders were explained. We discussed some of the ES6 features, such as using arrow functions, destructuring, and default and named exports.</p>
<p>We also defined components as a core building block of any React application. Two types of components were discussed: <code>class</code> and <code>function</code> components. In addition, we discussed props and how to pass information in props. The unidirectional information flow in React was clarified. Finally, we discussed state as a way React manages the internal data.</p>
<p>In the next chapter, we’ll dive deeper into React application development by discussing some of the hooks available in React. This will expose us to some of the advanced topics in React.</p>
</div>
</body></html>