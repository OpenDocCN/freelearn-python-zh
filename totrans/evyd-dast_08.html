<html><head></head><body>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Structs: Complex Types</h1></div></div></div><p class="calibre7">A <strong class="calibre16">struct</strong> is a collection of data variables or values that are grouped together under a single memory block, whereas a data structure is typically some sort of collection of objects that are related to one another in some way. Therefore, a struct, also known as a structure, is less of a data structure and more of a complex data type. This definition sounds pretty simple, but appearances are deceiving in this case. The topic of structs is a complex one, and each of the languages we are examining has unique qualities in how structs are supported, if they are supported at all.</p><p class="calibre7">In this chapter, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem">Definition of the struct data structure</li><li class="listitem">Creating structs</li><li class="listitem">Common applications of structs</li><li class="listitem">Examples of structs in each language</li><li class="listitem">Enums</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec39" class="calibre1"/>The essentials</h1></div></div></div><p class="calibre7">Due to varying support from language to language, we're will take a different approach in this chapter. Instead of examining structs as a whole and then examining a case study, we will examine structs and case studies simultaneously for each language. This will give us the opportunity to examine the nuances of structs in each language within the proper context.</p></div></div>

<div><div><div><div><div><div><h2 class="title2" id="calibre_pb_2"><a id="ch08lvl2sec41" class="calibre1"/>C#</h2></div></div></div><p class="calibre7">In C#, a struct is defined as a value type that encapsulates small groups of related fields, which sounds very similar to the underlying C language implementation. However, C# structs are in fact quite different from those found in C, and they more closely resemble a regular class than a struct from that language. For instance, a C# struct can have methods, fields, properties, constants, indexers, operator methods, nested types, and events as well as defined constructors (but not default constructors, which are defined automatically). Structs can also implement one or more interfaces, all of which make the C# variety much more flexible than C.</p><p class="calibre7">However, it would be a mistake to think of structs as lightweight classes. C# structs do not support inheritance, meaning they cannot inherit from classes or other structs, nor can they be used as a base for other structures or classes. Structure members cannot be declared as abstract, protected, or virtual. Unlike classes, structs can be instantiated without using the <code class="literal">new</code> keyword, although doing so prevents the resulting object from being used until every field has been assigned. Finally, and perhaps most importantly, structs are value types while classes are reference types.</p><p class="calibre7">This final point cannot be overemphasized because it represents the key advantage to choosing a struct in place of a class. Structs are collections of values and, therefore, do not store references to objects such as arrays, for instance. Therefore, when you are passing a struct off to a method, it is passed by value rather than reference. Additionally, according to the MSDN documentation, being a value type means that structs do not require allocation to the heap memory and, therefore, do not carry the overhead that a class does in terms of memory and processing requirements.</p><div><h3 class="title1"><a id="note31" class="calibre1"/>Note</h3><p class="calibre7">What does this mean and why is this beneficial? When you create a new class by using the new operator, the object that is returned will be allocated on the heap. When you instantiate a struct, on the other hand, it gets created directly on the stack and that nets a performance gain because the stack provides much faster memory access than the heap. As long as you don't overload the stack and cause a stack overflow, using structs strategically can be a great way to improve performance in your application.</p></div><p class="calibre7">Now you might be saying to yourself, <em class="calibre20">Why do we even have classes if structs are so awesome?</em> For starters, the applications for structs in C# are very limited. According to Microsoft, you should only consider using a struct instead of a class if the instances of the type will be small and short-lived or they are typically embedded in other objects. Furthermore, you should not define a struct unless it meets at least three of the following criteria:</p><div><ul class="itemizedlist"><li class="listitem">The struct will logically represent a single value similar to a primitive type such as an integer, double, and so on</li><li class="listitem">Each instance of the struct will be smaller than 16 bytes</li><li class="listitem">The data in the struct will be immutable once it has been instantiated</li><li class="listitem">The struct will not need to be boxed and unboxed repeatedly</li></ul></div><p class="calibre7">Those are some pretty strict requirements! The outlook gets slightly worse when you consider what you can actually do with structs. Here's a hint--not much. Let's examine struct capabilities in comparison to a class:</p><div><ul class="itemizedlist"><li class="listitem">You can set and access individual components--classes can do that too.</li><li class="listitem">You can pass structs to functions--yes, you can do that with a class.</li><li class="listitem">You can assign the contents of one struct to another using the assignment (<code class="literal">=</code>) operator--nothing special here.</li><li class="listitem">You can return a struct from a function, which actually creates a copy of the struct so now you have two on the stack. Classes? Check. However, classes are superior in this regard because, when a function returns an instance of a class, the object gets passed by reference so there is no need to create an additional copy.</li><li class="listitem">Structs <em class="calibre20">cannot</em> test for equality using the equality (<code class="literal">==</code>) operator, because structs may contain other bits of data. Classes can compare using the equality operator, however. In fact, if you want the same functionality in a struct you have to compare fields component, by component which is tedious.</li></ul></div><p class="calibre7">If someone were to score this match-up, I think the result would look something like <em class="calibre20">structs: 4, classes: 5 (maybe 6)</em>. So obviously, classes are more flexible in terms of functionality and convenience, which is why higher-level languages with their roots in C typically provide mechanisms to implement these more complex objects.</p><p class="calibre7">That is not to say that structs do not have their value. Although their usefulness falls into very niche scenarios, there are times when a struct is the right tool for the job.
</p><div><div><div><div><h3 class="title1"><a id="ch08lvl3sec3" class="calibre1"/>Creating structs in C#</h3></div></div></div><p class="calibre7">Creating a struct in C# is a fairly simple process. Our only two requirements are <code class="literal">using System</code> and declaring our object using the <code class="literal">struct</code> keyword. Here's an example:</p><pre class="programlisting">    using System; 
    
    public struct MyStruct 
    { 
        private int xval; 
        public int X 
        { 
            get  
            { 
                return xval; 
            } 
            set  
            { 
                if (value &lt; 100) 
                    xval = value; 
            } 
        } 
 
        public void WriteXToConsole() 
        { 
            Console.WriteLine("The x value is: {0}", xval); 
        } 
    } 
 
    //Usage 
    MyStruct ms1 = new MyStruct(); 
    MyStruct ms2 = MyStruct(); 
 
    ms.X = 9; 
    ms.WriteXToConsole(); 

    //Output 
    //The x value is: 9 
</pre><p class="calibre7">As you can see from the preceding example, our struct is declared with a private backing field, a public accessor and one instance method named <code class="literal">WriteXToConsole()</code>, all perfectly legitimate characteristics of a struct in C#. Note the two instances of <code class="literal">MyStruct</code>. The first is instantiated using the <code class="literal">new</code> keyword, while the second is not. Again, both of these operations are perfectly valid in C#, although the latter requires you to populate all of the member properties before you can use the object in any way. If you were to change the <code class="literal">struct</code> keyword in our definition to class, the second initializer would not compile.</p><p class="calibre7">Next, we'll examine an example from <a class="calibre1" title="Chapter 3. Lists: Linear Collections" href="part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3">Chapter 3</a>, <em class="calibre20">Lists: Linear Collections</em>. In that chapter's case study, we built a data structure that stores a list of <code class="literal">Waypoint</code> objects. Here's what the <code class="literal">Waypoint</code> class looks like in C#:</p><pre class="programlisting">    public class Waypoint 
    { 
        public readonly Int32 lat; 
        public readonly Int32 lon; 
        public Boolean active { get; private set; } 
 
        public Waypoint(Int32 latitude, Int32 longitude) 
        { 
            this.lat = latitude; 
            this.lon = longitude; 
            this.active = true; 
        } 
 
        public void DeactivateWaypoint() 
        { 
            this.active = false; 
        } 
 
        public void ReactivateWaypoint() 
        { 
            this.active = true; 
        } 
    }</pre><p class="calibre7">As you can see, this class is pretty simple. It is so simple that it begs the question as to whether or not such a simple collection of values is worthy of the overhead and resources afforded to a class, especially when you consider that our list could contain hundreds of these <code class="literal">Waypoint</code> objects. Can we improve performance by converting the class to a struct without requiring significant refactoring to support this change? First, we need to determine whether it is recommended or even possible to do so, and we can make that decision by examining our struct criteria rules.
</p></div><div><div><div><div><h3 class="title1"><a id="ch08lvl3sec4" class="calibre1"/>Rule 1: The struct will logically represent a single value</h3></div></div></div><p class="calibre7">In this case, our class has three fields, namely <code class="literal">lat</code>, <code class="literal">lon</code>, and <code class="literal">active</code>. Three is definitely not singular, but since the rule is that a struct must <em class="calibre20">logically represent</em> a single value, our plan to convert the class to a struct is still valid. This is because the <code class="literal">Waypoint</code> object represents a <em class="calibre20">single</em> location in 2-dimensional space, and we require at least two values to represent a 2D coordinate, so there is no violation there. Also, the active property denotes a state of the waypoint, so this is characteristically acceptable as well. Before you cry foul on this interpretation, allow me to point out that even Microsoft plays fast and loose with this rule. For instance, <code class="literal">System.Drawing.Rectangle</code> is defined as a structure, and that type stores <em class="calibre20">four</em> integers representing both the size and location of a rectangle. Size and location are two properties of one object, and that is considered acceptable, so I believe <code class="literal">Waypoint</code> is fine here.</p></div><div><div><div><div><h3 class="title1"><a id="ch08lvl3sec5" class="calibre1"/>Rule 2: Each instance of the struct must be under 16 bytes</h3></div></div></div><p class="calibre7">Our <code class="literal">Waypoint</code> class is easily within the margin of safety for this rule. Referring to <a class="calibre1" title="Chapter 1. Data Types: Foundational Structures" href="part0015_split_000.html#E9OE2-77f2b5b248f04368a6f723b0e9357ef3">Chapter 1</a>, <em class="calibre20">Data Types: Foundational Structures</em>, the <code class="literal">Int32</code> structures are 4 bytes in length and Boolean primitives are only 1 byte in length. This means that a single instance of <code class="literal">Waypoint</code> will weigh in at a grand total of only nine bytes, leaving us seven bytes to spare.</p></div><div><div><div><div><h3 class="title1"><a id="ch08lvl3sec6" class="calibre1"/>Rule 3: The data must be immutable</h3></div></div></div><p class="calibre7">The reason that structs should, ideally, be immutable has to do with their status as value types. As mentioned previously, whenever a value type is passed around, you end up with a copy of that value rather than a reference to the original value itself. This means that when you change a value within the struct, you are only changing that struct and none of the others that happen to be hanging around in the stack.</p><p class="calibre7">This requirement may represent a problem for us and it is not a trivial one. In our application, we have chosen to store the active state of the <code class="literal">Waypoint</code> value on the object itself, and this field is definitely not immutable. We could move the property out of the <code class="literal">Waypoint</code> class somehow, but doing so would require much more refactoring than if we simply left it alone. Since we want to avoid a significant refactor for the time being, we will leave the field alone and count this rule as a strike against our plan. Our only recourse is to examine our usage of the <code class="literal">Waypoint</code> objects in our code to ensure that we never create a situation where an instance of <code class="literal">Waypoint</code> is passed in such a way that we lose focus on the correct instance. Technically speaking, so long as <code class="literal">Waypoint</code> passes the next requirement, we are still in business.</p></div><div><div><div><div><h3 class="title1"><a id="ch08lvl3sec7" class="calibre1"/>Rule 4: The struct will not require repeated boxing</h3></div></div></div><p class="calibre7">Since the <code class="literal">Waypoint</code> object is used as-is once it has been instantiated, each instance will rarely, if ever, be boxed or unboxed. Therefore, our class passes this test and qualifies for conversion to a struct.</p></div><div><div><div><div><h3 class="title1"><a id="ch08lvl3sec8" class="calibre1"/>Conversion</h3></div></div></div><p class="calibre7">The next question is, <em class="calibre20">Can the Waypoint class be converted to a struct?</em> There are three points of concern in our class that may need to be addressed. First, we have that mutable <code class="literal">active</code> field to deal with. In its current form, this field is not very struct-like since it really should be immutable. Since we really have no recourse at this stage, we will have to deal with it in another manner. Predominantly, this means we will need to very strictly monitor our usage of <code class="literal">Waypoint</code> objects to ensure that we are not working on copies of a struct when we believe we are working with the original struct. Although this may become tedious, it is not unreasonable. Our next concern is the defined constructor, but since this is not without a parameter or a default constructor, everything is fine here and we can move on. Finally, our class has two public methods named <code class="literal">DeactivateWaypoint()</code> and <code class="literal">ReactivateWaypoint()</code>. Since C# also allows for public methods in a struct, these two are fine where they are as well. In fact, the only thing we really need to do to convert this class to a struct is to change the <code class="literal">class</code> keyword to a <code class="literal">struct</code> keyword! Here's our resulting code:</p><pre class="programlisting">    public struct Waypoint 
    { 
        public readonly Int32 lat; 
        public readonly Int32 lon; 
        public Boolean active { get; private set; } 
 
        public Waypoint(Int32 latitude, Int32 longitude) 
        { 
            this.lat = latitude; 
            this.lon = longitude; 
            this.active = true; 
        } 
 
        public void DeactivateWaypoint() 
        { 
            this.active = false; 
        } 
 
        public void ReactivateWaypoint() 
        { 
            this.active = true; 
        } 
    }; 
</pre><p class="calibre7">Lastly, we need to know if this change will represent any improvement in our app as a whole. Without extensive testing and analysis of the app at runtime, it is impossible to say for sure, but odds are this modification will net a positive impact on the overall performance of our off-road biking application without introducing any further refactoring requirements.</p></div></div></div></div>

<div><div><div><div><div><div><h2 class="title2" id="calibre_pb_3"><a id="ch08lvl2sec42" class="calibre1"/>Java</h2></div></div></div><p class="calibre7">This is going to be a short discussion, since Java does not support structs. Apparently, the authors of Java decided that, when the language finally crawled out of the C programming swamp, it would not be lugging around these non-object-oriented structures. Therefore, our only recourse in Java is to create a class with public properties that will mimic the behavior of a struct, but without any of the performance benefits.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title2" id="calibre_pb_4"><a id="ch08lvl2sec43" class="calibre1"/>Objective-C</h2></div></div></div><p class="calibre7">Objective-C does not support structs directly; however, you can implement and use simple C structs in your code. C structs are similar to their C# counterpart, in that they allow you to frame several primitive values into a single more complex value type. However, C structs do not permit the addition of methods or initializers nor any other cool object-oriented programming features that C# structs enjoy. Additionally, C structs cannot contain any objects that inherit from <code class="literal">NSObject</code>, as these are classes and not value types.</p><p class="calibre7">That being said, structs are actually found very frequently in Objective-C applications. One of the most common applications for structs is in the definition of <strong class="calibre16">enumerations</strong>, or <strong class="calibre16">enums</strong>. Enums are lists of constants representing integer values whose purpose is to create higher levels of abstraction in your code so that developers can focus on what the values symbolize without worrying about how they are implemented in the background. We will examine enums in more detail later in this chapter.</p><div><div><div><div><h3 class="title1"><a id="ch08lvl3sec9" class="calibre1"/>Creating structs in Objective-C</h3></div></div></div><p class="calibre7">Another common source of structs in Objective-C can be found in the <strong class="calibre16">Core Graphics framework</strong>, which contains four useful structures. We'll examine these structures in detail in order to demonstrate how structures are defined in Objective-C:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">CGPoint</code>: This structure contains a simple two-point coordinate system consisting of two <code class="literal">CGFloat</code> values. Here's what the <code class="literal">CGPoint</code> struct definition looks like:</li></ul></div><pre class="programlisting">        struct CGPoint { 
            CGFloat x; 
            CGFloat y; 
        }; 
        typedef struct CGPoint CGPoint; 
</pre><div><ul class="itemizedlist"><li class="listitem"><code class="literal">CGSize</code>: This structure is simply a container for a width and height, consisting of two <code class="literal">CGFloat</code> values. Here's what the <code class="literal">CGSize</code> struct definition looks like:</li></ul></div><pre class="programlisting">        struct CGSize { 
            CGFloat width; 
            CGFloat height; 
        }; 
        typedef struct CGSize CGSize; 
</pre><div><ul class="itemizedlist"><li class="listitem"><code class="literal">CGRect</code>: This is a structure that defines both the location and size of a rectangle, consisting of one <code class="literal">CGPoint</code> value and one <code class="literal">CGSize</code> value. Here's what the <code class="literal">CGRect</code> struct definition looks like:</li></ul></div><pre class="programlisting">        struct CGRect { 
            CGPoint origin; 
            CGSize size; 
        }; 
        typedef struct CGRect CGRect; 
</pre><div><ul class="itemizedlist"><li class="listitem"><code class="literal">CGVector</code>: This is a structure that simply contains a 2-dimensional vector, consisting of two <code class="literal">CGFloat</code> values. Here's what the <code class="literal">CGVector</code> struct definition looks like:</li></ul></div><pre class="programlisting">        struct CGVector { 
            CGFloat dx; 
            CGFloat dy; 
        }; 
        typedef struct CGVector CGVector; 
</pre><div><h3 class="title1"><a id="note32" class="calibre1"/>Note</h3><p class="calibre7">You should note the <code class="literal">typedef</code> and <code class="literal">struct</code> keywords following each of these struct definitions. This line is included for our convenience as programmers. Whenever we need to call on these structs, if the struct were not decorated with the <code class="literal">typedef</code> keyword, we would always need to precede calls to our struct with the <code class="literal">struct</code> keyword, like so:</p><p class="calibre7">    <code class="literal">struct CGRect rect;</code></p><p class="calibre7">Obviously, this would rapidly get tiresome. By applying a <code class="literal">typedef</code> to the struct name, we allow our callers to simply apply the struct name without the <code class="literal">struct</code> keyword, like so:</p><p class="calibre7">  <code class="literal">  CGRect rect;</code></p><p class="calibre7">This makes our code easier to write, but also makes it more concise and more readable in the long run.</p></div><p class="calibre7">Now we will take a look at the <code class="literal">EDSWaypoint</code> class from <a class="calibre1" title="Chapter 3. Lists: Linear Collections" href="part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3">Chapter 3</a>, <em class="calibre20">Lists: Linear Collections</em>, and determine whether we can convert that class to a C struct. Here's the original code:</p><pre class="programlisting">    @interface EDSWaypoint() 
    { 
        NSInteger _lat; 
        NSInteger _lon; 
        BOOL _active; 
    } 
 
    @end 
 
    @implementation EDSWaypoint 
 
    -(instancetype)initWithLatitude:(NSInteger)latitude andLongitude:(NSInteger)longitude 
    { 
        if (self = [super init]) 
        { 
            _lat = latitude; 
            _lon = longitude; 
            _active = YES; 
        } 
     
        return self; 
    } 
 
    -(BOOL)active 
    { 
        return _active; 
    } 
 
 
    -(void)reactivateWaypoint 
    { 
        _active = YES; 
    } 
 
    -(void)deactivateWaypoint 
    { 
        _active = NO; 
    } 
 
    @end 
</pre><p class="calibre7">Right away in the interface, we see a few problems with converting this class to a struct. Both the <code class="literal">_lat</code> and <code class="literal">_lon</code> ivars are <code class="literal">NSInteger</code> classes, which means they are invalid for use inside a struct and they will have to go or be changed to a value type. How about the <code class="literal">initWithLatitude:andLongitude:</code> initializer? Nope, you cannot define initializers in C structs either. So, now we need to deal with the <code class="literal">reactivateWaypoint</code> and <code class="literal">deactivateWaypoint</code> methods. Surely these simple properties and methods can pass muster for acceptance into a struct? No, they cannot. Everything here needs to go.</p><p class="calibre7">Therefore, the only real question that remains is what should we do with the <code class="literal">_active</code> value and the associated <code class="literal">-(BOOL)active</code> property. As it turns out, the <code class="literal">BOOL</code> type is perfectly acceptable to use within a structure, so we can actually leave the property where it is. However, <code class="literal">_active</code> does represent a mutable property within the <code class="literal">EDSWaypoint</code> struct and that is frowned upon, right? It may be frowned upon, but structs are not immutable in C. Here's an example using the Core Graphics struct, <code class="literal">CGPoint</code>:</p><pre class="programlisting">    CGPoint p = CGPointMake(9.0, 5.2); 
    p.x = 9.8; 
    p.y = 5.5; 
</pre><p class="calibre7">If you were to duplicate this code in your app, the compiler would not issue an error or even a warning because <code class="literal">CGPoint</code> is not immutable and the properties are not read only. Therefore, we can leave the <code class="literal">_active</code> value in our final struct definition. Unfortunately, the same cannot be said for the <code class="literal">-(BOOL)active</code> property? Property accessors such as this are forbidden in C structs so this needs to be removed, and that represents a significant change to how our application handles the active state of our <code class="literal">Waypoint</code> objects. So if we want to convert this class to a structure, we will be left with the following:</p><pre class="programlisting">    struct EDSWaypoint { 
        int lat; 
        int lon; 
        BOOL active; 
    }; 
    typedef struct EDSWaypoint EDSWaypoint; 
</pre><p class="calibre7">Strictly speaking, the <code class="literal">typedef</code> declaration is not required but it's bad enough that we will have to refactor our entire <code class="literal">EDSWaypointList</code> class to support these changes. Let's not add insult to injury by making our poor developers type eight extra characters every time they want to access one of these types.</p></div></div></div></div>

<div><div><div><div><div><div><h2 class="title2" id="calibre_pb_5"><a id="ch08lvl2sec44" class="calibre1"/>Swift</h2></div></div></div><p class="calibre7">As in other languages, structs in Swift are value types that encapsulate small groups of related properties. Similar to structs in C#, Swift structs resemble a regular class more than a C struct and share all of the following abilities with classes:</p><div><ul class="itemizedlist"><li class="listitem">Ability to define properties to store values</li><li class="listitem">Ability to contain methods that define extended functionality</li><li class="listitem">Ability to define subscripts to provide access to values using subscript notation</li><li class="listitem">Ability to define custom initializers</li><li class="listitem">Swift structs can be extended to provide additional functionality beyond their initialized state</li><li class="listitem">Finally, Swift structs can be defined to conform to protocols that provide customary functionality</li></ul></div><p class="calibre7">Note, however, that Swift structs do not support inheritance, meaning that they cannot inherit from classes or other structs, nor can they be used as a base for other structures or classes. Also, they do not support type casting to enable the compiler to check and interpret the type of an instance at runtime. These structs cannot be explicitly deinitialized like classes to free up their resources, nor do structs support automatic reference counting for memory management. These last two points are related to the fact that structs in Swift, as in other languages, are value types and not classes or reference types.</p><p class="calibre7">This final point in relation to Swift bears repeating. Structs are collections of values and, therefore, do not store references to objects like other collections such as arrays or dictionaries, for instance. Therefore, when you are passing a struct as a parameter to or from a method, it is passed by value and not by reference.</p><p class="calibre7">So when should you choose to use a struct over a class in Swift? Apple's documentation provides some general rules of thumb to help you make the decision. You should use struct when:</p><div><ul class="itemizedlist"><li class="listitem">Your object's primary purpose is to gather a few simple data values</li><li class="listitem">You anticipate that the object you create will be copied rather than referenced when you assign or send an instance of that object</li><li class="listitem">Any properties in your object are value types, not classes, and you also expect that their values will be copied rather than referenced</li><li class="listitem">Your object has no need to inherit properties or behavior from an existing object or type</li></ul></div><p class="calibre7">You will notice that this list is not quite as restrictive as the same list in C#, but it does represent an excellent common-sense approach to deciding whether or not the value added from using a struct outweighs the limited functionality in your object.</p><div><div><div><div><h3 class="title1"><a id="ch08lvl3sec10" class="calibre1"/>Creating structs in Swift</h3></div></div></div><p class="calibre7">If you have worked with Swift for more than five minutes, odds are you have already worked with some of the built-in structs such as <code class="literal">Int</code>, <code class="literal">String</code>, <code class="literal">Array</code>, <code class="literal">Dictionary</code>, and many others that are defined in the Swift framework. Here's a quick demonstration on how to define your own struct using Swift:</p><pre class="programlisting">    Public struct MyColor { 
        var red = 0 
        var green = 0 
        var blue = 0 
        var alpha = 0.0 
    } 
</pre><p class="calibre7">The preceding example defines a new structure called <code class="literal">MyColor</code>, which describes an RGBA-based color definition. This structure has four properties called <code class="literal">red</code>, <code class="literal">green</code>, <code class="literal">blue</code>, and <code class="literal">alpha</code>. Although these properties have all been defined as mutable variables using <code class="literal">var</code>, stored properties in Swift can also be defined as immutable using <code class="literal">let</code>. The first three properties in our struct are inferred to be the <code class="literal">Int</code> types by setting their default values to <code class="literal">0</code>, while the remaining property is inferred to be <code class="literal">Double</code> type by setting its default value to <code class="literal">0.0</code>. Since we have not defined any custom initializers for our method yet, we could initialize an instance of this object as follows:</p><pre class="programlisting">    var color = MyColor()  
    color.red = 139 
    color.green = 0 
    color.blue = 139 
    color.alpha = .5 
</pre><p class="calibre7">The preceding code initializes our struct and sets the values to represent something similar to dark magenta with a 50% alpha. This demonstration is fine, but the initialization is somewhat verbose for many developers' taste. What if we want to create a new object in one line? In that case, we need to modify our struct to include a custom initializer, as follows:</p><pre class="programlisting">    public struct MyColor { 
        var red = 0 
        var green = 0 
        var blue = 0 
        var alpha = 0.0 
     
        public init(R: Int, G: Int, B: Int, A: Double) 
        { 
            red = R 
            green = G 
            blue = B 
            alpha = A 
        } 
    } 
 
var color = MyColor(R: 139, G:0, B:139, A:0.5) 
</pre><p class="calibre7">Taking advantage of Swift allowing structs to define custom initializers, we have created an <code class="literal">init</code> method that accepts RGBA values and assigns them to the properties of our object, greatly simplifying our object creation.</p><p class="calibre7">Now we will take a look at the <code class="literal">Waypoint</code> class from <a class="calibre1" title="Chapter 3. Lists: Linear Collections" href="part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3">Chapter 3</a>, <em class="calibre20">Lists: Linear Collections</em>, and determine whether we can convert that class to a structure. Here's the original code:</p><pre class="programlisting">    public class Waypoint : Equatable 
    { 
        var lat: Int 
        var long: Int 
        public private(set) var active: Bool 
     
        public init(latitude: Int, longitude: Int) { 
            lat = latitude 
            long = longitude 
            active = true 
        } 
     
        public func DeactivateWaypoint() 
        { 
            active = false; 
        } 
     
        public func ReactivateWaypoint() 
        { 
            active = true; 
        } 
    } 
    
    public func == (lhs: Waypoint, rhs: Waypoint) -&gt; Bool { 
        return (lhs.lat == rhs.lat &amp;&amp; lhs.long == rhs.long) 
    } 
</pre><p class="calibre7">Now this is an interesting class object. We will tackle the elephant in the room first: the <code class="literal">Equatable</code> interface and the public function named <code class="literal">==</code> declared <em class="calibre20">outside</em> the class structure. Our class is required to implement the <code class="literal">Equatable</code> interface because several of the methods in <code class="literal">WaypointList</code> compare two <code class="literal">Waypoint</code> objects for equality. Without the interface and the associated <code class="literal">==</code> method implementation, this would not be possible and our code would not compile. Luckily, Swift structs are permitted to implement interfaces such as <code class="literal">Equatable</code>, so this really is not an issue and we can move on.</p><p class="calibre7">We have already discussed and demonstrated that Swift structs can define custom initializers, so our public <code class="literal">init</code> method is fine as it is. The <code class="literal">Waypoint</code> class also has two methods called <code class="literal">DeactivateWaypoint()</code> and <code class="literal">ActivateWaypoint()</code>. Since structs are intended to be immutable, the final change we need for our class to become a struct is the addition of the <code class="literal">mutating</code> keyword to each of these methods to denote that each one modifies, or mutates, one or more of the values in the instance. Here's the final version of our <code class="literal">Waypoint</code> class:</p><pre class="programlisting">    public struct Waypoint : Equatable 
    { 
        var lat: Int 
        var long: Int 
        public private(set) var active: Bool 
     
        public init(latitude: Int, longitude: Int) { 
            lat = latitude 
            long = longitude 
            active = true 
        } 
     
        public mutating func DeactivateWaypoint() 
        { 
            active = false; 
        } 
     
        public mutating func ReactivateWaypoint() 
        { 
            active = true; 
        } 
    } 
 
    public func == (lhs: Waypoint, rhs: Waypoint) -&gt; Bool { 
        return (lhs.lat == rhs.lat &amp;&amp; lhs.long == rhs.long) 
    } 
</pre><div><h3 class="title1"><a id="note33" class="calibre1"/>Note</h3><p class="calibre7">The addition of the <code class="literal">mutating</code> keyword to our instance methods will allow us to redefine <code class="literal">Waypoint</code> as a struct, but it will also introduce a new limitation to our implementation. Consider the following example:</p><p class="calibre7">   <code class="literal"> let point = Waypoint(latitude: 5, longitude: 10)</code></p><p class="calibre7">    <code class="literal">point.DeactivateWaypoint()</code></p><p class="calibre7">This code will fail to compile with the error <code class="literal">Immutable value of type 'Waypoint' has only mutating members named DeactivateWaypoint</code>. Wait. What now? By including the <code class="literal">mutating</code> keyword, we are also explicitly declaring that this struct is a mutable type. It's fine to declare this type as immutable, unless you try to call one of the mutating methods at which point the code will fail to compile. Whereas before this change we could declare any instance of <code class="literal">Waypoint</code> as either mutable using <code class="literal">var</code> or immutable using <code class="literal">let</code>, as we saw fit, we are now restricted to only declaring mutable instances of this object if we intend to utilize the <code class="literal">mutating</code> methods.</p></div></div></div></div></div>

<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec40" class="calibre1"/>Enums</h1></div></div></div><p class="calibre7">As discussed earlier, enums increase the level of abstraction in your application and allow the developer to focus on the meaning of the values rather than being concerned with how the values are stored in memory. This is because an <code class="literal">enum</code> type allows you to label specific integer numeric values with meaningful or easy to remember names.</p></div>

<div><div><div><div><div><h2 class="title2" id="calibre_pb_1"><a id="ch08lvl2sec45" class="calibre1"/>Case study: the Metro line</h2></div></div></div><p class="calibre7"><strong class="calibre16">Business problem</strong>: You work with an engineering team tasked with writing an application that keeps track of commuter trains along the Metro. One of the key business requirements is the ability to easily identify which station a train is currently located at or en route to. Each train station has a unique name, but the database tracks the stations by their ID values, such as 1100, 1200, 1300, and so on. Rather than track stations by name, which is both tedious and prone to change over time, your app will utilize the station IDs. However, the reason stations are labeled with names instead of IDs in the first place is to make it easier for commuters to identify them. This is also true for programmers, who would have a difficult time keeping the IDs of dozens or perhaps hundreds of stations in mind while writing code.</p><p class="calibre7">You decide to utilize the enum data structure to meet the needs of both your application and your developers. Your enum will provide a map between easy-to-remember station names and the station IDs they are associated with, so your application can utilize the IDs based on the station names while your programmers will use the names.</p><p class="calibre7"><strong class="calibre16">C#</strong></p><p class="calibre7">To avoid confusion where multiple train lines overlap at larger stations, we do not simply want to create an enum with all of the stations in the entire Metro line. Instead, we will create enums based on each line in the Metro. Here's the Silver Line defined as a C# enum:</p><pre class="programlisting">    public enum SilverLine 
    { 
        Wiehle_Reston_East = 1000, 
        Spring_Hill = 1100, 
        Greensboro = 1200, 
        Tysons_Corner = 1300, 
        McClean = 1400, 
        East_Falls_Church = 2000, 
        Ballston_MU = 2100, 
        Virginia_Sq_GMU = 2200, 
        Clarendon = 2300, 
        Courthouse = 2400, 
        Rosslyn = 3000, 
        Foggy_Bottom_GWU = 3100, 
        Farragut_West = 3200, 
        McPherson_Sq = 3300, 
        Metro_Center = 4000, 
        Federal_Triangle = 4100, 
        Smithsonian = 4200, 
        LEnfant_Plaza = 5000, 
        Federal_Center_SW = 5100, 
        Capital_South = 5200, 
        Eastern_Market = 5300, 
        Potomac_Ave = 5400, 
        Stadium_Armory = 6000, 
        Benning_Road = 6100, 
        Capital_Heights = 6200, 
        Addison_Road = 6300, 
        Morgan_Blvd = 6400, 
        Largo_Town_Center = 6500 
    } 
</pre><p class="calibre7">Now, wherever we want to use a value from the <code class="literal">SilverLine</code> enum, we simply need to declare a value type by the same name and assign a value, such as the following:</p><pre class="programlisting">    SilverLine nextStop = SilverLine.Federal_Triangle; 
    nextStop = SilverLine.Smithsonian; 
</pre><p class="calibre7">In the example we just saw, our code initializes a <code class="literal">SilverLine</code> value to show the Silver Line's next stop as station <code class="literal">4100</code>, using <code class="literal">SilverLine.Federal_Triangle</code>. Once the doors close on the platform, we need to update this value to show our train is moving to station <code class="literal">4200</code>, so we update the value to <code class="literal">SilverLine.Smithsonian</code>.</p><p class="calibre7"><strong class="calibre16">Java</strong></p><p class="calibre7">Although Java does not permit us to define structs explicitly, we can define enums. However, the definition may not appear as you expect:</p><pre class="programlisting">    public enum SilverLine 
    { 
        WIEHLE_RESTON_EAST, 
        SPRING_HILL, 
        GREENSBORO, 
        TYSONS_CORNER, 
        MCCLEAN, 
        EAST_FALLS_CHURCH, 
        BALLSTON_MU, 
        VIRGINIA_SQ_GMU, 
        CLARENDON, 
        COURTHOUSE, 
        ROSSLYN, 
        FOGGY_BOTTOM_GWU, 
        FARRAGUT_WEST, 
        MCPHERSON_SQ, 
        METRO_CENTER, 
        FEDERAL_TRIANGLE, 
        SMITHSONIAN, 
        LENFANT_PLAZA, 
        FEDERAL_CENTER_SW, 
        CAPITAL_SOUTH, 
        EASTERN_MARKET, 
        POTOMAC_AVE, 
        STADIUM_ARMORY, 
        BENNING_ROAD, 
        CAPITAL_HEIGHTS, 
        ADDISON_ROAD, 
        MORGAN_BLVD, 
        LARGO_TOWN_CENTER 
    } 
</pre><p class="calibre7">You may notice that we have not explicitly assigned integer values to each of these entries. This is because Java will not allow us to do so. Remember that Java does not support structs, so enums in this language are not really primitives at all but rather objects of their own type. Therefore, they do not play by the same rules as enums in other languages, and some argue that Java enums are more robust because of it.</p><p class="calibre7">Unfortunately for our planned use of this structure, this limitation will be a small hurdle because we cannot map the station names directly to their associated ID value. One option here would be to add a <code class="literal">public static</code> method, which will operate on the string value of <code class="literal">this</code>, and use that value to map the string to an integer value behind the scenes. This may be a somewhat verbose solution, but when you consider the fact that this is even possible, it opens a whole new world of alternative solutions to the overall business problem.</p><p class="calibre7"><strong class="calibre16">Objective-C</strong></p><p class="calibre7">Just as Objective-C does not support structures, it also does not directly support enums. Luckily, we can use the underlying C language enum in this case as well. Here's how:</p><pre class="programlisting">    typedef enum NSUInteger
    {
        Wiehle_Reston_East = 1000,
        Spring_Hill = 1100,
        Greensboro = 1200,
        Tysons_Corner = 1300,
        McClean = 1400,
        East_Falls_Church = 2000,
        Ballston_MU = 2100,
        Virginia_Sq_GMU = 2200,
        Clarendon = 2300,
        Courthouse = 2400,
        Rosslyn = 3000,
        Foggy_Bottom_GWU = 3100,
        Farragut_West = 3200,
        McPherson_Sq = 3300,
        Metro_Center = 4000,
        Federal_Triangle = 4100,
        Smithsonian = 4200,
        LEnfant_Plaza = 5000,
        Federal_Center_SW = 5100,
        Capital_South = 5200,
        Eastern_Market = 5300,
        Potomac_Ave = 5400,
        Stadium_Armory = 6000,
        Benning_Road = 6100,
        Capital_Heights = 6200,
        Addison_Road = 6300,
        Morgan_Blvd = 6400,
        Largo_Town_Center = 6500
    } SilverLine;
</pre><p class="calibre7">First, note that we have integrated the <code class="literal">typedef</code> keyword into this definition, which means that we will not need to add the declaration of the <code class="literal">SilverLine</code> enum as an object on a separate line in our code. Also note the <code class="literal">enum</code> keyword, which is required to declare an enum in C. Note that we are explicitly declaring that this enum is of value type <code class="literal">NSUInteger</code>. We are using <code class="literal">NSUInteger</code> here because we do not want to support signed values, but if we did, then we could just as easily have chosen <code class="literal">NSInteger</code> for this purpose. Finally, note that the actual name of the <code class="literal">enum</code> variable comes after the definition.</p><p class="calibre7">Otherwise, our enum definition is similar to that of most other C-based languages, with just a couple of caveats. First, enums must be declared in a header (<code class="literal">*.h</code>) file if you intend to use it <em class="calibre20">outside</em> the scope of the current file. In either case, the enum must also be declared them <em class="calibre20">outside</em> the <code class="literal">@interface</code> or <code class="literal">@implementation</code> tags or your code will not compile. Finally, the name of your enum must be unique among all other objects within the workspace.</p><p class="calibre7"><strong class="calibre16">Swift</strong></p><p class="calibre7">Structs in Swift have more in common with those of C# than those of Objective-C due to their wide flexibility. In our example here, we will not add any additional methods or <code class="literal">init</code> functions, but we could if we needed to:</p><pre class="programlisting">    public enum SilverLine : Int 
    { 
        case Wiehle_Reston_East = 1000 
        case Spring_Hill = 1100 
        case Greensboro = 1200 
        case Tysons_Corner = 1300 
        case McClean = 1400 
        case East_Falls_Church = 2000 
        case Ballston_MU = 2100 
        case Virginia_Sq_GMU = 2200 
        case Clarendon = 2300 
        case Courthouse = 2400 
        case Rosslyn = 3000 
        case Foggy_Bottom_GWU = 3100 
        case Farragut_West = 3200 
        case McPherson_Sq = 3300 
        case Metro_Center = 4000 
        case Federal_Triangle = 4100 
        case Smithsonian = 4200 
        case LEnfant_Plaza = 5000 
        case Federal_Center_SW = 5100 
        case Capital_South = 5200 
        case Eastern_Market = 5300 
        case Potomac_Ave = 5400 
        case Stadium_Armory = 6000 
        case Benning_Road = 6100 
        case Capital_Heights = 6200 
        case Addison_Road = 6300 
        case Morgan_Blvd = 6400 
        case Largo_Town_Center = 6500 
    } 
</pre><p class="calibre7">Note the inclusion of the <code class="literal">Int</code> declaration in our definition. This is not strictly required in most cases, unless we intend to explicitly set values for our entries as we have done here. This lets the compiler know in advance what types to expect for the purpose of type checking. If we had chosen to leave out the explicit values, we could have optionally left off the <code class="literal">Int</code> declaration as well.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec41" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, you learned the basic definition of the struct data structure, as well as how to create structs in applicable languages. We also examined some common applications of structs including the very common enum data type. Finally, we looked at some previous code examples to check whether we could improve on them using struct objects instead of custom classes.</p></div></body></html>