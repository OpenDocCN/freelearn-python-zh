# 第八章。更高级的函数

在 第七章 中，我们探讨了定义返回单个结果的函数的核心特性。即使函数在语句序列的末尾有一个隐式的 `return` 语句，或者一个没有表达式的 `return` 语句，也会返回一个结果：`None` 对象是默认的返回值。在本章中，我们将探讨返回多个结果的函数。生成器函数定义了一个可迭代对象：它可以与 `for` 语句一起使用。这意味着生成器不会产生一个包含所有结果项的单个对象；相反，它会单独产生每个结果项。

Python 提供了生成器表达式和推导式，这些与生成器函数的概念相辅相成。我们可以编写简单的表达式，表示一个一次生成一个值的值序列。我们可以使用生成器表达式通过推导式创建 `list`、`set` 或 `dict` 对象。

我们将回顾 `for` 语句及其与可迭代数据的关系。这将帮助我们理解生成器函数是如何工作的。我们还将查看一些既适用于集合对象也适用于生成器函数的函数。这包括内置的归约函数，如 `max()`、`min()` 和 `sum()`，以及高阶函数，如 `map()`、`filter()`、`functools.reduce()` 和 `itertools` 模块中的函数。

本章将简要介绍一些函数式编程的概念。关于 Python 中的函数式编程，可以写一本书。有关更多信息，请参阅[`www.packtpub.com/application-development/functional-python-programming`](https://www.packtpub.com/application-development/functional-python-programming)。我们将关注核心内容。

# 使用 `for` 语句与可迭代集合

Python 允许我们使用 `for` 语句与任何类型的集合一起使用。我们可以编写类似 `for x in coll` 的语句来处理 `list`、`set` 或 `dict` 的键。这是因为所有 Python 集合都有在 `collections.abc` 模块中定义的共同抽象基类。

这是通过基类 `Sequence`、`Set` 和 `Mapping` 的一个共同特性实现的。类中的 `Iterable` 混合是每个类定义的一部分。这个抽象实现的保证是所有内置的集合都将与 `for` 语句协同工作。

让我们打开内部结构，看看它是如何工作的。我们将使用这个复合 `for` 语句作为一个具体的例子：

```py
for x in coll:
    print(x)
```

从概念上讲，这个复合语句开始于一个非常类似于这个赋值的东西：`coll_i=iter(coll)`。这将获取 `coll` 集合的迭代器对象。这个 `iter()` 函数将利用特殊方法 `__iter__()` 来产生迭代器对象。我们可以用一条简单的规则来总结这个工作原理：如果变量 `coll` 不引用一个合适的集合，将引发 `TypeError` 异常。

给定结果迭代器对象 `coll_i`，`for` 语句可以评估 `x=next(coll_i)` 来从迭代器中获取每个项目。这将利用特殊方法 `coll_i.__next__()` 从原始集合中产生一个项目。

如果 `next(coll_i)` 的评估返回一个项目，这个项目将被分配给 `x`，并且语句序列将使用这个值绑定到 `x` 变量来执行。我们将看到 `x` 的值被打印出来。

如果 `next(coll_i)` 引发 `StopIteration` 异常，则底层集合已无项目，循环将正常结束。在引发任何其他异常的情况下，这简单地根据标准异常规则传播。（我们将在第九章异常中查看异常。）

## 迭代器和可迭代集合

当集合实现了 `__iter__()` 特殊方法时，它是可迭代的。几乎在所有情况下，这意味着它将是 `collections.abc` 模块中定义的 `Iterable` 类的子类。这个特殊方法的存在意味着在集合对象上评估 `iter()` 将返回一个迭代器对象。

集合的迭代器必须实现 `__next__()` 和 `__iter__()` 特殊方法。通常，一个迭代器对象通过返回自身作为结果来实现 `__iter__()` 方法。这种自洽的冗余意味着我们不仅可以创建一个显式的迭代器，还可以将其提供给 `for` 语句而不引发异常；`for` 语句的处理可以评估 `iter(object)` 而无需检查该对象是否已经是迭代器。

如果我们有一系列项目，其中包含我们想要忽略的标题，这种情况通常发生在源数据文件包含必须单独处理的标题行时。我们可以利用显式的迭代器对象来丢弃顺序集合中的项目。

我们可能会写一些像这样的事情：

```py
source_iter= iter(source)
heading= next(source_iter)
for data in source_iter:
    print(data)
```

在这个例子中，我们创建了一个基于源集合或生成器的迭代器，命名为 `source_iter`，这个名字缺乏想象力，叫作 `source`。当我们评估 `next(source_iter)` 时，我们从集合中消耗了第一个项目，然后将其分配给 `heading` 变量。然后我们可以使用迭代器对象在 `for` 语句中消耗该迭代器中的其余项目。

实际上，前面的例子几乎与这个相同：

```py
heading, *rest = source
for data in rest:
    print(data)
```

第二个示例实际上是对源集合进行了浅拷贝，并将这个拷贝赋值给 `rest` 变量。我们几乎加倍了使用的内存量。对于小列表来说，这无关紧要。对于更大的集合来说，这可能会成为一个问题。

如果源是一个打开的文件或基于打开文件的生成器，将 `rest` 集合中的数据实体化可能是不可行的。文件太大，无法放入内存，是它们自己独特问题的一部分，有时被称为“大数据”。显式使用 `iter()` 函数允许我们避免创建可能不适合内存的大型集合的风险尝试。

# 后果和下一步

有三个重要的后果是 `for` 语句使用 `coll_i= iter(x)` 和 `x=next(coll_i)` 的方式：

+   我们可以编写隐式具有所需接口的生成器表达式，以便作为 `Iterable` 类工作

+   Python 给我们提供了编写作为 `Iterable` 类工作的生成器函数的方法

+   我们可以创建自己的类，这些类实现了实现 `Iterable` 抽象基类所需的特殊方法名称

我们将开始编写生成器表达式。我们可以使用这些表达式来创建 `list`、`set` 和映射“推导式”。**推导式**是一个定义集合内容的表达式。

我们将探讨编写生成器函数。`yield` 语句改变了函数的语义，从“简单”的（或“普通”）变为生成器。

虽然 第十一章，*类定义* 是关于类定义的主题，但我们不会深入探讨如何创建我们自己的独特集合。Python 已经提供了如此多的集合，定义自己的并不是真的必要。

# 使用生成器表达式和推导式

我们可以将简单的生成器表达式视为一个有三个操作数的运算符。这三个操作数的语法与 `for` 语句平行：

```py
(expression for target in source)
```

我们指定一个 *表达式*，该表达式为从 *源* 分配给 *目标* 变量的每个值进行评估。还有更复杂的生成器，我们将在后面探讨。

生成器表达式在 Python 中可以自由使用。它们可以在任何有意义的序列或集合中使用。

重要的是要注意，生成器表达式是惰性的，或者说“非严格的”。它实际上不会计算任何东西，直到某个消耗操作要求它提供值。为了看到这一点，我们可以在 REPL 中尝试评估一个生成器表达式：

```py
>>> (2*x+1 for x in range(5))
<generator object <genexpr> at 0x1023981e0>
```

Python 只告诉我们我们创建了一个生成器对象。由于我们没有编写一个表达式来消耗这些值，我们看到的就是这个对象，被动地等待被评估。

探索生成器表达式的最佳方式是应用一个函数，例如 `list()` 或 `tuple()`，它将消耗生成器的值并从它们中构建一个集合对象。以下是一个示例：

```py
>>> tuple(2*x+1 for x in range(5))
(1, 3, 5, 7, 9)
```

在这个例子中，`tuple()` 函数从生成器对象中消耗值，并从这些值创建了一个 `tuple` 对象。而不是显示生成器对象，REPL 显示了我们从生成值创建的 `tuple`。

我们可以使用生成器表达式进行各种处理。`itertools` 模块中有几种模式。

## 生成器表达式的局限性

生成器表达式有一些局限性。最明显的局限性是，某些语言特性仅作为 Python 语句可用。如果我们需要执行异常处理、上下文管理或通过 `break` 语句提前退出循环，我们无法编写生成器表达式。我们必须求助于编写完整的生成器函数。

另一个不那么明显的局限性是，生成器表达式表现得非常像序列。但它只能这样做一次。在生成器第一次终止后，每次引用它时都表现得像空序列。这里有一个具体的例子：

```py
>>> x= (2*x+1 for x in range(20))
>>> sum(x)
400
>>> sum(x)
0
```

在这个例子中，我们将生成器表达式赋值给变量 `x`。当我们计算 `sum(x)` 时，`sum()` 函数消耗了生成器表达式产生的所有值：在这个例子中总和是 400。一旦我们使用了生成器，它仍然有效，但它不再生成值。所有后续的 `sum(x)` 评估都将产生 0。

没有特殊的异常来警告我们正在重用已经耗尽的迭代器。在某些情况下，程序可能看起来是损坏的，因为我们使用了生成器表达式而不是 `list` 或 `tuple` 序列。修复方法几乎总是将生成器转换为 `tuple` 对象，以便它可以被两次使用。我们可以将 `x= tuple(2*x+1 for x in range(20))` 改变以查看差异。

当与生成器函数或表达式一起工作时，`iter(some_function)` 将返回生成器对象，因为它是一个迭代器。在集合对象的情况下，`iter(some_collection)` 将创建一个具有集合引用的迭代器对象。结果将是一个不同的对象。一个函数可以使用 `iter(param) is iter(param)` 来检测生成器函数和具体集合之间的差异。

在某些情况下，我们可能会包含语句 `assert iter(param) is not iter(param), "Collection object required"` 以在将生成器函数作为参数传递给遍历集合超过一次的函数时引发异常。

## 使用多个循环和条件

生成器的主体可以包含多个 `for` 子句。这允许我们遍历多个维度。我们可以编写这样的表达式：

```py
>>> deck= list((r,s) for s in '♣♦♥♠' for r in range(1,14))
>>> deck # doctest: +ELLIPSIS
[(1, '♣'), (2, '♣'), (3, '♣'), ... (11, '♠'), (12, '♠'), (13, '♠')]
>>> len(deck)
52
```

生成器表达式有两个`for`子句：`for s in '♣♦♥♠'`和`for r in range(1,14)`。从结果中可以看出，右侧的`for`子句执行得最频繁。这遵循了如果我们将其重写为嵌套`for`语句时我们会看到的嵌套规则。右侧的`for`子句就像一个最内层的`for`语句。

此外，生成器的主体可以包含`if`子句。这些可以用来过滤由`for`子句创建的值。以下是一个生成器表达式中条件处理的例子：

```py
>>> list(x for x in range(36) if x%5 == 0 or x%7 == 0)
[0, 5, 7, 10, 14, 15, 20, 21, 25, 28, 30, 35]
```

在这个例子中，表达式仅仅是目标变量`x`。来源是`range(36)`，包括零和 35 的数字。我们包含了一个`if`子句，它只会传递那些是五或七的倍数的值。所有其他值将被拒绝。为了看到结果，我们将生成器的值收集到一个`list`对象中。

## 编写推导式

我们可以利用生成器表达式的变体来创建`list`、`set`或`dict`对象。这些被称为推导式，它们代表从惰性生成器构建的实体对象。

这里有一些简单的例子：

```py
[2*x+1 for x in range(5)]
{x for x in range(36) if x%5 == 0 or x%7 == 0}
{n: 2*n**2-3*n-14 for n in range(-5,6)}
```

第一个例子使用`[]`创建一个`list`推导式。这将创建一个从一到九的奇数值列表。第二个例子使用`{}`创建一个`set`推导式。这将基于五或七的倍数创建一个集合。

第三个例子创建一个`dict`推导式。`{}`用于括号表达式。使用`:`字符来分隔键和值，将`dict`推导式与`set`推导式区分开来。这个字典提供了从*n*的映射。

这个最后的例子可以用作对深度嵌套表达式的优化。在映射中查找值比反复重新计算要快。使用`@lru_cache`装饰器可以提供类似性能的好处。

# 使用`yield`语句定义生成器函数

生成器函数具有与生成器表达式相似的属性。生成器函数不是一个单独的表达式，而是一个完整的 Python 函数。它具有第七章中描述的函数的所有特性，*基本函数定义*。它还有一个额外的特性，即它是一个迭代器，能够生成一系列项目。

当我们使用`yield`语句时，函数的语义会发生变化。没有`yield`，函数将返回单个值。有`yield`语句时，函数将表现得像迭代器，向消费者提供多个值。

以下是一个生成器函数的例子，它将一系列值应用于模型以计算结果域。我们将对一系列输入值应用模型以计算每个输入的结果：

```py
def model_iter(until):
    for n in range(0, until):
        yield n*(n+1)//2
```

这个 `model_iter()` 函数接受一个参数，`until`，它表示该函数生成的值的数量。函数体包含一个 `for` 语句，该语句将 `n` 变量设置为 `range()` 对象定义的值。

该函数的基本特性是 `yield` 语句。由 `yield` 语句创建的每个值都将成为此语句产生的项目序列的一部分。

这是我们使用此函数的一种方法：

```py
>>> list(model_iter(6))
[0, 1, 3, 6, 10, 15]
```

在这个例子中，我们将结果收集到一个单独的 `list` 对象中。创建一个 `list` 对象只是我们可以做的许多事情之一。我们同样可以计算给定范围的平均值，将模型的结果相加。

```py
>>> mean = sum(model_iter(6))/6
>>> round(mean, 4)
5.8333
```

在这个例子中，我们将 `model_iter()` 生成器的结果传递给 `sum()` 函数。这样可以避免构建大量结果集合。`sum()` 函数将消费生成器函数产生的所有值。我们可以使用这种结构处理成千上百万的值，因为不会在内存中生成一个大的 `list` 或 `set`。只有单个项目被处理。

# 使用高阶函数

接受函数作为参数或返回函数作为结果的函数被称为**高阶函数**。Python 有许多高阶函数。这些函数中最常用的是 `map()`、`filter()` 和 `sorted()`。`itertools` 模块包含许多其他高阶函数。

`map()` 和 `filter()` 函数是生成器；它们的输出必须被消费。它们都将一个函数应用到值集合上。在 `map()` 的情况下，函数的结果被产生。在 `filter()` 的情况下，如果函数的结果为真，原始值被产生。

这是我们如何将一个非常简单的函数——简单到我们将其编码为 lambda——应用到一系列值：

```py
>>> mapping= map( lambda x: 2*x**2-2, range(5) )
>>> list(mapping)
[-2, 0, 6, 16, 30]
```

该函数只是一个表达式，`2*x**2-2`。我们已经将此函数应用于 `range()` 对象提供的值。结果是生成器，我们需要消费这些值。我们使用了 `list()` 来创建一个可以打印的集合。这些值是应用给定函数到源集合中每个值的计算结果。

这是我们如何使用 `filter()` 对值序列应用简单逻辑测试：

```py
>>> fb= filter( lambda n: n%5==0 or n%7==0, range(16) )
>>> [n for n in fb]
[0, 5, 7, 10, 14, 15]
```

我们定义了一个简单的函数作为 lambda；函数 `n%5==0 or n%7==0` 对于五的倍数或七的倍数是真实的。我们将这个过滤器应用于 `range()` 对象生成的值。结果只包括给定函数为 `True` 的值。所有其他值都被拒绝。

我们使用列表推导式将值收集到一个 `list` 对象中。这个列表推导式没有进行计算和过滤，因此它与 `list(fb)` 等效。

我们可以使用生成器表达式实现 `map()` 和 `filter()` 的简单版本：

+   `map(function, iterable)` 与 `(function(x) for x in iterable)` 相同

+   `filter(function, iterable)` 与 `(x for x in iterable if function(x))` 相同

`map()` 函数可以处理额外的可迭代对象，比生成器表达式提供更多的复杂性。

`sorted()` 函数类似于 `map()` 和 `filter()`。`sorted()` 函数对其参数遵循不同的设计模式。`map()` 和 `filter()` 函数首先接受一个函数，然后是一个要处理的项。`sorted()` 函数首先接受一个要排序的项，以及一个可选的函数，该函数定义了排序的键，以及一个可选的布尔值，用于反转键比较的意义。我们将在后面的 *三种排序序列的方法* 部分详细探讨排序。

`itertools` 模块包含大量可以组合以创建复杂处理的生成器函数。有关此模块如何工作的更多信息，书籍 *Functional Python Programming*，作者 *Steven Lott*，由 *Packt Publishing* 出版，为此主题奉献了两章（[`www.packtpub.com/application-development/functional-python-programming`](https://www.packtpub.com/application-development/functional-python-programming)）。

## 编写我们自己的高级函数

可能最简单的高级函数类型是基于生成器表达式。由于生成器表达式是惰性的，其行为更像是一个函数而不是包含相关数据的对象。返回生成器的函数依赖于其他编程片段来实际消费生成器产生的数据。

常见的文件输入需求是去除尾随标点符号并忽略空白行。我们将假设遵循 Python 注释规则的编程语言。

这里是一个返回生成器的函数的例子：

```py
def text_cleaner( source ):
    stripped = (line.strip() for line in source)
    partitioned = (line.partition("#") for line in stripped)
    decommented = (data.rstrip() for data, sharp, comment in partitioned)
    non_empty = (line for line in decommented if line)
    return non_empty
```

我们将处理分解为四个独立的生成器函数。函数的结果是这四个生成器中的第四个，但这取决于其他生成器来产生结果。由于生成器是惰性的，直到函数或语句消费生成器产生的数据之前，不会发生任何处理。我们必须使用 `for` 语句或 `list()` 或 `tuple()` 函数的结果来消费数据。

当消费过程迭代此函数的结果时，它将接收到来自 `non_empty` 生成器表达式的单个文本行。`non_empty` 生成器过滤由 `decommented` 生成器表达式创建的行。`decommented` 生成器反过来依赖于 `partitioned` 和 `stripped` 生成器表达式来移除注释和空白。

重要的是，处理流程的管道是 `text_cleaner()` 函数的返回值。这个函数不处理任何数据。这个函数返回一个生成器表达式，它将处理一些数据。

这些生成器也可以重写为使用 `map()` 或 `filter()`。我们将把这个作为读者的练习。

我们可以这样使用 `text_cleaner()` 函数：

```py
>>> text = '''
... # options
... db=name # database
...  task=delete # task
... '''.splitlines()
>>> for line in text_cleaner(text):
...    print(line)
db=name
task=delete
```

我们创建了一些带有注释和数据的文本。数据的格式看起来是 `name=value` 设置。`text_cleaner()` 函数对数据的格式不敏感，只对注释和空白敏感。我们应用了 `splitlines()` 函数，使文本块表现得像文件。

`text_cleaner()` 函数的结果是一个函数，它移除了注释、前导和尾随空格，只留下了文件的有意义内容。在这个例子中，我们使用了一个 `for` 语句来消费生成器函数产生的数据。

这可能是更复杂过程的一部分，该过程使用这些 `name=value` 行作为配置参数。

生成器函数的重要之处在于它们是完全懒加载的。它们不会在内存中创建巨大的数据结构。它们只处理满足消费者请求的最小数据量。这减少了开销。此外，每个生成器可以相对简单，从而可以从简单的部分构建出表达性的组合。

# 使用内置归约函数 – max、min 和 reduce

我们还有两个内置的高阶函数可以接受函数作为参数。这些可以描述为归约：它们将一组值归约为一个值。还有一个内置的归约函数 `sum`，但它不是一个正确的高阶函数：我们无法通过插入函数来定制其操作。

`max()` 和 `min()` 归约遵循 `sorted()` 函数的设计模式：它们首先接受一个可迭代对象，并且可以通过可选的键函数进行自定义。我们将首先展示默认行为，然后展示如何使用键函数进行自定义：

```py
>>> data = ["21", "3", "35", "4"]
>>> min(data)
'21'
>>> min(data, key=int)
'3'
```

在第一个例子中，字符串对象是通过字符串比较来比较的。这导致了一个异常，即看到 `"21"` 看起来小于 `"3"`。实际上，以 `"2"` 开头的字符串会排在以 `"3"` 开头的字符串之前，但这可能不是程序需要显示的输出。

在第二个例子中，我们为 `min` 函数提供了 `int()` 函数，用于比较项。这意味着字符串被作为整数比较，而不是作为字符串。这选择了具有最小整数值的字符串 `"3"`。

注意，我们没有写 `min(data, key=int())`。我们不是评估 `int` 函数。我们提供 `int` 函数作为对象，`min()` 函数将使用它。

此外，还有一个通用的 `functools.reduce()` 函数，可以用来构建新的归约类型。这个函数接受一个二元函数、一个可迭代对象和一个初始值。它可以计算各种归约。

# 排序序列的三种方法

Python 为我们提供了三种处理复杂项 `list` 排序的通用方法。

+   我们可以使用 `sorted()` 生成器函数进行排序。这会将对象作为排序的一部分进行复制。

+   我们可以使用列表的`sort()`方法和键函数对列表进行排序。这将使列表按请求的顺序进行修改。

+   我们可以创建一个中间序列的对象，这些对象可以很容易地进行排序。这有时被称为**包装-排序-解包**设计模式。

为了详细查看这些，我们需要一个可以排序的复杂对象集合。我们将使用基于*NIST 工程统计手册*案例研究的简单数据集，第 7.1.6 节。更多信息请见[`www.itl.nist.gov/div898/handbook`](http://www.itl.nist.gov/div898/handbook)。

我们已经整理和清理了一些度量数据，看起来是这样的：

```py
>>> data
[['2013-09-10', '289'], ['2013-09-11', '616'],
. . . ,
['2013-12-07', '752'], ['2013-12-08', '739']]
```

我们有一个包含 90 对的对列表结构。由于日期字符串格式良好，为`yyyy-mm-dd`，我们可以很容易地使用`sorted(data)`函数或`data.sort()`方法将其按日期顺序排序。请注意，`sorted(data)`将创建`data`对象的副本。`data.sort()`方法将就地修改`data`对象。

我们如何按计数对数据进行排序呢？我们可以将键函数应用于`sorted()`函数或`sort()`方法。我们首先看看这些。作为替代，我们可以使用包装-排序-解包设计模式。

## 通过键函数进行排序

按计数对度量数据进行排序需要我们使用一个函数来改变项目比较的方式。在这种情况下，我们需要一个更复杂的键函数来完成两件事。它必须选择每个两个数据点的第二个项目，并且必须将第二个项目转换为适当的整数值。

我们可以使用这两个示例中的任何一个按计数进行排序：

```py
>>> data.sort(key=lambda x: int(x[1]))
>>> by_count= sorted(data, key=lambda x: int(x[1]))
```

两个示例都使用了一个 lambda 表达式，该表达式对每个两元素列表中的第二个项目执行整数转换。第一个示例更新了数据对象。第二个示例创建了一个新的对象，它是数据对象的克隆，并已排序。

## 通过包装和解包进行排序

使用一对生成器表达式可以实现包装-排序-解包设计模式。第一个将创建从每个原始数据块中生成的两元组。每个新两元组中的第一个项目是适当的排序键。第二个生成器将选择这些两元组中的第二个项目以恢复原始对象。

整个序列看起来是这样的：

```py
>>> wrapped = [(int(x[1]), x) for x in data]
>>> wrapped.sort()
>>> by_count = [x[1] for x in wrapped]
```

在第一步中，我们将每条原始数据转换成了一个`(sort key, original item)`的两元组。我们使用列表推导式创建了一个新的对象，我们可以对其进行排序，而原始对象保持不变。一旦我们这样做，默认的排序操作就可以正确工作。一旦数据排序完成，我们就可以轻松地恢复原始项目。在这种情况下，我们使用列表推导式创建了另一个列表对象。

在这两种情况下，我们可以稍微调整一下，使用`map()`函数而不是生成器表达式。例如，我们可以使用`map(lambda item: (int(item[1]), item), data)`来包装项目。

注意，`map()`函数是一个生成器：它是惰性的。列表理解消耗数据并创建一个有形的对象。我们无法通过简单的复制粘贴从列表切换到生成器。我们需要从 map 生成器创建一个列表对象，或者使用`sorted()`，它从一个生成器创建列表。

当包装函数相当复杂时，通常会使用包装-排序-解包的方法。我们可能有一个执行数据库查询、文件合并或作为排序一部分的极其复杂的计算的生成器。在这些情况下，编写一个简单的 lambda 函数可能很困难。

# 函数式编程设计模式

Python 中高阶函数的存在使我们能够利用许多函数式编程设计模式。要了解更多关于这些设计模式的信息，一个好的起点是`itertools`模块。该模块中的函数提供了许多示例，说明了我们如何编写简单的函数来进行复杂的处理。

此外，我们还可以使用`functools`模块的一些功能。它包含通用的`reduce()`函数。它还包含一些可以帮助我们编写装饰器的函数。正如我们在第十三章 Metaprogramming and Decorators 中将要看到的，装饰器是一种高级函数：它修改原始函数的定义。这是函数式编程的另一个方面。

最重要的是，我们有两种方法来处理算法：

+   我们可以在大量数据集合中处理项目，创建副本、子集或转换的额外集合。

+   我们可以通过迭代大量数据集合，就像我们正在创建额外的集合一样来处理项目。实际上，我们不需要创建副本、子集或转换，我们可以使用迭代器、过滤函数和映射函数。

当我们有替代方案时，我们可以选择简洁且表达力强的变体。

# 摘要

在本章中，我们看到了函数的许多高级特性。我们研究了基本的生成器表达式以及它是如何作为理解的一部分使用的。列表理解从生成的值中组装列表。同样，集合理解创建集合。字典理解从生成器表达式中的键和值创建字典结构。

我们研究了使用`yield`语句创建生成器函数。这允许我们在创建生成器时使用所有各种 Python 语句功能。由于生成器是可迭代的，它可以与`for`循环一起使用，这样我们就可以编写一个简单的循环来处理由迭代器创建的多个值。

我们还研究了高阶函数。这些函数接受函数作为参数或产生函数作为结果。使用高阶函数，我们可以将我们的算法重构为可以组合以创建所需行为的函数。

在第九章，*异常*中，我们将探讨 Python 如何引发异常，我们如何捕获这些异常，以及我们需要编写什么样的异常处理。
