- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Network Web Services with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we were a consumer of the APIs provided by others.
    In *Chapter 3*, *APIs and Intent-Driven Networking*, we saw that we can use an
    `HTTP POST` request to NX-API at the `http://<your device ip>/ins` URL with the
    `CLI` command embedded in the `HTTP POST` body to execute commands remotely on
    the Cisco Nexus device; the device then returns the command execution output in
    its HTTP response return. In *Chapter 8*, *Network Monitoring with Python – Part
    2*, we used the `HTTP GET` method for our sFlow-RT at `http://<your host ip>:8008/version`
    with an empty body to retrieve the version of the sFlow-RT software. These request-response
    exchanges are examples of RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wikipedia ([https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)):'
  prefs: []
  type: TYPE_NORMAL
- en: ”Representational state transfer (REST) or RESTful web services is one way of
    providing interoperability between computer systems on the internet. REST-compliant
    web services allow requesting systems to access and manipulate the textual representation
    of web resources using a uniform and predefined set of stateless operations.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As noted, the use of RESTful web services using the HTTP protocol is only one
    of many methods of information exchange on the web; other forms of web services
    also exist. However, it is the most commonly used web service today, with the
    associated `GET`, `POST`, `PUT`, and `DELETE` verbs as a predefined way of exchanging
    information.
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering about HTTPS versus HTTP, for our discussion, we are treating
    HTTPS as a secure extension of HTTP ([https://en.wikipedia.org/wiki/HTTPS](https://en.wikipedia.org/wiki/HTTPS))
    and the same underlying protocol as a RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: On the provider side, one of the advantages of providing RESTful services to
    users is the ability to hide internal operations from the user. For example, in
    the case of sFlow-RT, if we were to log in to the device to see the version of
    the software installed instead of using its RESTful API, we would need more in-depth
    knowledge of the tool to know where to check. However, by providing the resources
    as a URL, the API provider abstracts the version-checking operations from the
    requester, making the operation much simpler. The abstraction also provides a
    layer of security as it can open up the endpoints only as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the master of our network universe, RESTful web services provide many notable
    benefits that we can enjoy, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can abstract the requester from learning about the internals of the network
    operations. For example, we can provide a web service to query the switch version
    without the requester knowing the exact CLI command or the switch API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can consolidate and customize operations that uniquely fit our network needs,
    such as a resource to upgrade all our top-of-rack switches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can provide better security by only exposing operations as needed. For example,
    we can provide read-only URLs (`GET`) to core network devices and read-write URLs
    (`GET`/`POST`/`PUT`/`DELETE`) to access-level switches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will use one of the most popular Python web frameworks,
    **Flask**, to create our RESTful web service for our network. In this chapter,
    we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Python web frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations involving static network content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations involving dynamic network operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our web app in containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by looking at the available Python web frameworks and why we chose
    Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Python web frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is known for its great many web frameworks. There is a running joke in
    the Python community about whether you can ever work as a full-time Python developer
    without working with any Python web frameworks. There are several Python web developer
    conferences, including DjangoCon US ([https://djangocon.us/](https://djangocon.us/)),
    DjangoCon EU ([https://djangocon.eu/](https://djangocon.eu/)), FlaskCon ([https://flaskcon.com/](https://flaskcon.com/)),
    Python Web Conference ([https://pythonwebconf.com/](https://pythonwebconf.com/)),
    and many local meetups. Each of the conferences attracts hundreds of attendees
    every year. Did I mention Python has a thriving web development community?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you sort the Python web frameworks at [https://hotframeworks.com/languages/python](https://hotframeworks.com/languages/python),
    you can see that there is no shortage of choices when it comes to Python and web
    frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18403_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Python Web Framework Rankings (source: https://hotframeworks.com/languages/python)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the most recent 2021 Python Developer Survey, Flask slightly edged Django
    as the most popular web framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B18403_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Python Developer Survey 2021 (source: https://lp.jetbrains.com/python-developers-survey-2021/)'
  prefs: []
  type: TYPE_NORMAL
- en: With so many options to choose from, which framework should we pick? Trying
    all the frameworks one by one would be time-consuming. The question of which web
    framework is better is also a passionate topic among web developers. If you ask
    this question on any of the forums, such as Quora, or search on Reddit, get ready
    for some highly opinionated answers and heated debates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of Quora and Reddit, here’s an interesting fact: both Quora and Reddit
    were written in Python. Reddit uses Pylons ([https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F](https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F)),
    while Quora started with Pylons but replaced a portion of the framework with its
    in-house code ([https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora](https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, I am biased toward programming languages (Python!) and web frameworks
    (Flask and Django!). In this section, I hope to convey my reasoning behind choosing
    one over the other for any particular project. Let’s pick the top two frameworks
    from the preceding HotFrameworks list and compare them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Django**: The self-proclaimed “web framework for perfectionists with deadlines”
    is a high-level Python web framework that encourages rapid development and clean,
    pragmatic design ([https://www.djangoproject.com/](https://www.djangoproject.com/)).
    It is a large framework with pre-built code that provides an administrative panel
    and built-in content management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flask**: This is a microframework for Python and is based on Werkzeug, Jinja2,
    and other applications ([https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/)).
    By being a microframework, Flask intends on keeping the core small and easy to
    extend when needed. The “micro” in microframework does not mean that Flask lacks
    functionality, nor does it mean it cannot work in a production environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I use Django for some of the larger projects while using Flask for quick prototypes.
    The Django framework has a strong opinion on how things should be done; any deviation
    from it would sometimes leave the user feeling that they are “fighting with the
    framework.” For example, if you look at the Django database documentation ([https://docs.djangoproject.com/en/4.0/ref/databases/](https://docs.djangoproject.com/en/4.0/ref/databases/))
    you will notice that the framework supports several different SQL databases. However,
    they are all variants of a SQL database such as MySQL, PostgreSQL, SQLite, and
    others.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to use a NoSQL database such as MongoDB or CouchDB? It might
    be possible, but it could leave us in our own hands because there is no official
    support from Django. Being an opinionated framework is certainly not a bad thing.
    It is just a matter of opinion (no pun intended).
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the core code small and extending it when needed is very appealing when
    we need something simple and fast. The initial example in the documentation to
    get Flask up and running consists of only six lines of code and is easy to understand,
    even if you don’t have any prior experience. Since Flask is built with extensions
    in mind, writing our extensions, such as a decorator, is relatively easy. Even
    though it is a microframework, the Flask core still includes the necessary components,
    such as a development server, debugger, integration with unit tests, RESTful request
    dispatching, and more, to get you started quickly.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Django and Flask are the two most popular Python web frameworks
    by almost all measures. We can’t really go wrong picking either as our starting
    point. The popularity that comes with both frameworks means both have extensive
    community contribution and support, and can quickly develop modern features.
  prefs: []
  type: TYPE_NORMAL
- en: For the ease of deployment, I feel Flask is an ideal choice for us when it comes
    to building network web services to start with.
  prefs: []
  type: TYPE_NORMAL
- en: Flask and lab setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will continue to use a virtual environment to isolate the
    Python environment and dependencies. We can start a new virtual environment, or
    we can continue to use the existing virtual environment that we have been using.
    My preference is to start a new virtual environment. I will call mine `ch09-venv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this chapter, we will install quite a few Python packages. To make life
    easier, I have included a `requirements.txt` file on this book’s GitHub repository;
    we can use it to install all the necessary packages (remember to activate your
    virtual environment). You should see packages being downloaded and successfully
    installed during the installation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For our network topology, we will use the `2_DC_Topology` that we have been
    using in the first few chapters, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Lab Topology'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at Flask in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, from here on out, I will assume that you will always execute
    from the virtual environment and that you have installed the necessary packages
    in the `requirements.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like most popular open source projects, Flask has very good documentation, which
    is available at [https://flask.palletsprojects.com/en/2.0.x/](https://flask.palletsprojects.com/en/2.0.x/).
    If you’d like to dig deeper into Flask, the project documentation would be a great
    place to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'I highly recommend Miguel Grinberg’s work ([https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/))
    related to Flask. His blog, book, and video training have taught me a lot about
    Flask. Miguel’s class, *Building Web APIs with Flask*, inspired me to build my
    first Flask-based API, and inspired the writing of this chapter. You can take
    a look at his published code on GitHub: [https://github.com/miguelgrinberg/](https://github.com/miguelgrinberg/).'
  prefs: []
  type: TYPE_NORMAL
- en: Flask versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As of the time of writing, the latest version of Flask is version 2.2.2\. Flask
    version 2.0.0 was released in May 2021 from version 1.1.4\. There were several
    big changes introduced in the release, thus the big number jump in release numbers.
    Some of the big changes are listed below:'
  prefs: []
  type: TYPE_NORMAL
- en: Flask 2.0 officially dropped the support for Python 2 and Python 3.5\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3 type hinting is supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP method decorator was introduced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These changes probably mean very little at this point because we are just getting
    started with Flask. For now, just keep in mind the big version change if we were
    searching for answers and examples. If possible, look for examples based on version
    2 and beyond.
  prefs: []
  type: TYPE_NORMAL
- en: Flask examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first Flask application is contained in one single file, `chapter9_1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple design pattern for Flask apps. We create an instance of the
    `Flask` class with the first argument as the name of the application’s module
    package. In this case, we used a single module that can be started as an application;
    later on, we will see how we can import it as a package. We then use the route
    decorator to tell Flask which URL should be handled by the `hello_networkers()`
    function; in this case, we indicated the root path. We end the file with the usual
    name scope, checking when the script is run by itself ([https://docs.python.org/3.10/library/__main__.html](https://docs.python.org/3.10/library/__main__.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also add the `host` and `debug` options, which allow more verbose output
    and allow us to listen on all the host interfaces. We can run this application
    using the development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you receive an error of **Address already in use** from the development server,
    change the port Flask Development Server runs on via the `port=xxxx` option, [https://flask.palletsprojects.com/en/2.2.x/server/](https://flask.palletsprojects.com/en/2.2.x/server/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a server running, let’s test the server response with an HTTP
    client.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTPie client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already installed `HTTPie` ([https://httpie.org/](https://httpie.org/))
    as part of the installation from the `requirements.txt` file. This book is printed
    in black and white, so the example does not show color highlighting, but in your
    installation, you can see `HTTPie` has better syntax highlighting for HTTP transactions.
    It also has a more intuitive command-line interaction with the RESTful HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it to test our first Flask application (more examples on `HTTPie`
    to follow). We will start a second terminal window on the management host, activate
    the virtual environment, and type the following in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As a comparison, if we are using `curl`, we will need to use the `-i` switch
    to achieve the same output: `curl -i http://192.168.2.126:5000`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `HTTPie` as our client for this chapter; it is worth taking a minute
    or two to take a look at its usage. We will use the free website HTTPBin ([https://httpbin.org/](https://httpbin.org/))
    to demonstrate the use of `HTTPie`. The usage of `HTTPie` follows this simple
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the preceding pattern, a `GET` request is very straightforward, as
    we have seen with our Flask development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON is the default implicit content type for `HTTPie`. If your HTTP body contains
    just strings, no other operation is needed. If you need to apply non-string JSON
    fields, use :`=` or other documented special characters. In the following example,
    we want the `"married"` variable to be a `Boolean` instead of a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `HTTPie` is a big improvement from the traditional curl syntax
    and makes testing the REST API a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: More usage examples are available at [https://httpie.io/docs/cli/usage](https://httpie.io/docs/cli/usage).
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to our Flask program, a large part of API building is based on
    the flow of URL routing. Let’s look deeper at the `app.route()` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: URL routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We added two additional functions and paired them up with the appropriate `app.route()`
    route in `chapter9_2.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is that different endpoints are passed to different functions. We
    can verify this with two `http` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As the requests are made from the client side, the server screen will see the
    requests coming in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the different endpoints correspond to different functions; whatever
    was returned from the function is what the server returns to the requester. Of
    course, the routing will be pretty limited if we have to keep it static all the
    time. There are ways to pass dynamic variables from the URL to Flask; we will
    look at an example of this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: URL variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can pass dynamic variables to the URL, as seen in the `chapter9_3.py` examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the two functions, we pass in dynamic information such as the hostname and
    interface number at the time when the client is making the request. Note that,
    in the `/routers/<hostname>` URL, we pass the `<hostname>` variable as a string;
    in `/routers/<hostname>/interface/<int:interface_number>` we specify the `int`
    variable should only be an integer. Let’s run the example and make some requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `int` variable is NOT an integer, an error will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The converter includes integers, float, and path (it accepts slashes).
  prefs: []
  type: TYPE_NORMAL
- en: Besides matching static routes with dynamic variables, we can also generate
    URLs upon application launch. This is very useful when we do not know the endpoint
    variable in advance or if the endpoint is based on other conditions, such as the
    values queried from a database. Let’s take a look at an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: URL generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `chapter9_4.py`, we wanted to dynamically create a URL during application
    launch in the form of `/<hostname>/list_interfaces`, where the hostname could
    be `r1`, `r2`, or `r3`. We already know we can statically configure three routes
    and three corresponding functions, but let’s see how we can do that upon application
    launch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon its execution, we will have a few nice, logical URLs that loop around
    the routers list without statically defining each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For now, you can think of `app.text_request_context()` as a dummy request object
    necessary for demonstration purposes. If you are interested in the local context,
    feel free to look at [https://werkzeug.palletsprojects.com/en/2.2.x/local/](https://werkzeug.palletsprojects.com/en/2.2.x/local/).
    The dynamic generation of URL endpoints greatly simplifies our code, saves time,
    and makes the code easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: The jsonify return
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another time-saver in Flask is the `jsonify()` return, which wraps `json.dumps()`
    and turns the JSON output into a response object with `application/json` as the
    content type in the HTTP header. We can tweak the `chapter9_3.py` script a bit,
    as illustrated in `chapter9_5.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With a few lines, the return result is now a `JSON` object with the appropriate
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Combine all the Flask features we have learned so far, and we are now ready
    to build an API for our network.
  prefs: []
  type: TYPE_NORMAL
- en: Network resource API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have network devices in production, each of the devices will have a
    certain state and information that you would like to keep in a persistent location
    so that you can easily retrieve them later on. This is often done in terms of
    storing data in a database. We saw many examples of such information storage in
    the monitoring chapters.
  prefs: []
  type: TYPE_NORMAL
- en: However, we would not normally give other non-network administrative users who
    might want this information direct access to the database; nor would they want
    to learn all the complex SQL query language. For these cases, we can leverage
    Flask and the **Flask-SQLAlchemy** extension of Flask to give them the necessary
    information via a network API.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Flask-SQLAlchemy at [https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/).
  prefs: []
  type: TYPE_NORMAL
- en: Flask-SQLAlchemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy and the Flask-SQLAlchemy extension are database abstraction and object-relational
    mappers, respectively. It’s a fancy way to use the `Python` object for a database.
    To make things simple, we will use SQLite as the database, which is a flat file
    that acts as a self-contained SQL database. We will look at the content of `chapter9_db_1.py`
    as an example of using Flask-SQLAlchemy to create a network database and insert
    a few table entries into the database. This is a multiple-step process, and we
    will look at the steps in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we will create a Flask application and load the configuration for
    SQLAlchemy, such as the database path and name, then create the `SQLAlchemy` object
    by passing the application to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a device `database` object and its associated primary key
    and various columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke the `database` object, create entries, and insert them into the
    database table. Keep in mind that anything we add to the session needs to be committed
    to the database in order to be permanent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will run the Python script and check for the existence of the database file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the interactive prompt to check the database table entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create new entries in the same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go ahead and delete the `network.db` file so it does not conflict with
    our other examples using the same `db` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to move on to build our network content API.
  prefs: []
  type: TYPE_NORMAL
- en: The network content API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into the code of building our API, let’s take a moment to think
    about the API structure we will create. Planning for an API is usually more an
    art than a science; it really depends on your situation and preference. What I
    suggest in this section is, by no means, the only way, but for now, stay with
    me for the purposes of getting started.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that, in our diagram, we have four Cisco IOSv devices. Let’s pretend
    that two of them, `lax-edg-r1` and `lax-edg-r2`, are in the network role of the
    spine. The other two devices, `nyc-edg-r1` and `nyc-edg-r2`, are in our network
    service as leaves. These are arbitrary choices and can be modified later on, but
    the point is that we want to serve data about our network devices and expose them
    via an API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things simple, we will create two APIs, a devices group API and a single-device
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated with medium confidence](img/B18403_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Network Content API'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first API will be our `http://192.168.2.126/devices/` endpoint, which supports
    two methods: `GET` and `POST`. The `GET` request will return the current list
    of devices, while the `POST` request with the proper JSON body will create the
    device. Of course, you can choose different endpoints for creation and querying,
    but in this design, we choose to differentiate the two by the HTTP methods.'
  prefs: []
  type: TYPE_NORMAL
- en: The second API will be specific to our device in the form of `http://192.168.2.126/devices/<device
    id>`. The API with the `GET` request will show the details of the device that
    we have entered into the database.
  prefs: []
  type: TYPE_NORMAL
- en: The `PUT` request will modify the entry with the update. Note that we use `PUT`
    instead of `POST`. This is typical of HTTP API usage; when we need to modify an
    existing entry, we will use `PUT` instead of `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a good idea about what your API will look like.
    To better visualize the final result, I will jump ahead and show the result quickly
    before we take a look at the code. If you want to follow the example, feel free
    to launch `chapter9_6.py` as the Flask server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `POST` request to the `/devices/` API will allow you to create an entry.
    In this case, I would like to create our network device with attributes such as
    hostname, loopback IP, management IP, role, vendor, and the operating system it
    runs on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I can repeat the preceding step for the three additional devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the same API endpoint with the `GET` request, we will be able to
    see the list of network devices that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, using the `GET` request for `/devices/<id>` will return specific
    information related to the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s pretend we have downgraded the `lax-edg-r1` operating system from `15.6`
    to `14.6`. We can use the `PUT` request to update the device record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s look at the code in `chapter9_6.py` that created the preceding APIs.
    What’s cool, in my opinion, is that all of these APIs were done in a single file,
    including the database interaction. Later on, when we outgrow the APIs at hand,
    we can always separate the components, such as having a separate file for the
    database class.
  prefs: []
  type: TYPE_NORMAL
- en: The devices API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `chapter9_6.py` file starts with the necessary imports. Note that the following
    request import is the `request` object from the client and not the `requests`
    package that we were using in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared a `database` object with `id` as the primary key and string fields
    for `hostname`, `loopback`, `mgmt_ip`, `role`, `vendor`, and `os`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_url()` function under the `Device` class returns a URL from the `url_for()`
    function. Note that the `get_device()` function that’s called is not defined just
    yet under the `/devices/<int:id>` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `export_data()` and `import_data()` functions are mirror images of each
    other. One is used to get the information from the database to the user `(export_data())`
    when we use the `GET` method. The other is to get information from the user to
    the database `(import_data())` when we use the `POST` or `PUT` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `database` object in place and the import and export functions created,
    the URL dispatch is straightforward for device operations. The `GET` request will
    return a list of devices by querying all the entries in the `devices` table and
    returning the URL of each entry. The `POST` method will use the `import_data()`
    function with the global `request` object as the input. It will then add the device
    and commit the information to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the `POST` method, the returned body is an empty JSON body,
    with the status code `201` (created), as well as extra headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at the API that queries and returns information for individual devices.
  prefs: []
  type: TYPE_NORMAL
- en: The device ID API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The route for individual devices specifies that the ID should be an integer,
    which can act as our first line of defense against a bad request. The two endpoints
    follow the same design pattern as our `/devices/` endpoint, where we use the same
    `import` and `export` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `query_or_404()` method provides a convenient way of returning
    `404 (not found)` if the database query returns negative for the ID passed in.
    This is a pretty elegant way of providing a quick check on the database query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last part of the code creates the database table and starts the
    Flask development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the longer Python scripts in this book, so we took more time
    to explain it in detail. The script provides a way to illustrate how we can utilize
    the database in the backend to keep track of the network devices and only expose
    them to the external world as APIs using Flask.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at how to use the API to perform asynchronous
    tasks on either individual devices or a group of devices.
  prefs: []
  type: TYPE_NORMAL
- en: Network dynamic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our API can now provide static information about the network; anything we can
    store in the database can be returned to the requester. It would be great if we
    could interact with our network directly, such as a query for device information
    or to push configuration changes to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start this process by leveraging a script we have already seen in *Chapter
    2*, *Low-Level Network Device Interactions*, for interacting with a device via
    Pexpect. We will modify the script slightly into a function we can repeatedly
    use in `chapter9_pexpect_1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test the new function via the interactive prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Make sure our Pexpect script works before proceeding. The following code assumes
    that we have entered the necessary database information from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a new API for querying the device version in `chapter9_7.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be returned to the requester:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add another endpoint that will allow us to perform a bulk action
    on multiple devices based on their common fields. In the following example, the
    endpoint will take the `device_role` attribute in the URL and match it up with
    the appropriate device(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Of course, looping through all the devices in `Device.query.all()` is not efficient,
    as in the preceding code. In production, we will use a SQL query that specifically
    targets the role of the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the RESTful API, we can see that all the spine, as well as leaf,
    devices can be queried at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated, the new API endpoints query the device(s) in real time and return
    the result to the requester. This works relatively well when you can guarantee
    a response from the operation within the timeout value of the transaction (30
    seconds, by default) or if you are OK with the HTTP session timing out before
    the operation is completed. One way to deal with the timeout issue is to perform
    the tasks asynchronously. We will look at how to do so in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous operations, when executing tasks out of the normal time sequence,
    are, in my opinion, an advanced topic of Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Miguel Grinberg ([https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/)),
    whose Flask work I am a big fan of, provides many posts and examples on his blog
    and his GitHub repository. For asynchronous operations, the example code in `chapter9_8.py`
    referenced Miguel’s GitHub code on the `Raspberry Pi` file ([https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py](https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py))
    for the background decorator. We will start by importing a few more modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The background decorator takes in a function and runs it as a background task
    using the thread and UUID for the task ID. It returns the status code `202` (accepted)
    and the location of the new resources for the requester to check. We will make
    a new URL for status checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we retrieve the resource, it is deleted. This is done by setting `app.config[''AUTO_DELETE_BG_TASKS'']`
    to `true` at the top of the app. We will add this decorator to our version endpoints
    without changing the other part of the code because all of the complexity is hidden
    in the decorator (how cool is that?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result is a two-part process. We will perform the `GET` request for
    the endpoint and receive the location header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then make a second request to the location to retrieve the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the status code `202` is returned when the resource is not ready,
    we will use the following script, `chapter9_request_1.py`, to immediately make
    a request to the new resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the result, the status code is returned while the resource
    is still being run in the background as `202`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Our APIs are coming along nicely! Because our network resource is valuable,
    we should secure API access to only authorized personnel. We will add basic security
    measures to our API in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For basic user authentication, we will use Flask’s `httpauth` ([https://flask-httpauth.readthedocs.io/en/latest/](https://flask-httpauth.readthedocs.io/en/latest/))
    extension, written by Miguel Grinberg, as well as the password functions in Werkzeug.
    The `httpauth` extension should have been installed as part of the `requirements.txt`
    installation at the beginning of this chapter. The new file illustrating the security
    feature is named `chapter9_9.py`. In the script, we will start with a few more
    module imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create an `HTTPBasicAuth` object as well as the `user database` object.
    Note that, during the user creation process, we will pass the password value;
    however, we are only storing `password_hash` instead of the cleartext `password`
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `auth` object has a `verify_password` decorator that we can use, along
    with Flask’s `g` global context object that was created when the user request
    started. Because `g` is global, if we save the user to the `g` variable, it will
    live through the entire transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a handy `before_request` handler that can be used before any API endpoint
    is called. We will combine the `auth.login_required` decorator with the `before_request`
    handler that will be applied to all the API routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we will use the `unauthorized` error handler to return a `response`
    object for the `401` unauthorized error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can test user authentication, we will need to create users in our
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you start your Flask development server, try to make a request, like we
    did previously. You should see that, this time, the server will reject the request
    with a `401` unauthorized error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now need to provide the authentication header for our requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We now have a decent RESTful API set up for our network. When our user wants
    to retrieve network device information, they can query for the static content
    of the network. They can also perform network operations for a single device or
    a group of devices. We also added basic security measures to ensure that only
    the users we created can retrieve the information from our API. The cool part
    is that this is all done within a single file in less than 250 lines of code (less
    than 200 if you subtract the comments)!
  prefs: []
  type: TYPE_NORMAL
- en: For more information on user session management, logging in, logging out, and
    remembering user sessions, I highly recommend using the Flask-Login ([https://flask-login.readthedocs.io/en/latest/](https://flask-login.readthedocs.io/en/latest/))
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: We have now abstracted the underlying vendor API away from our network and replaced
    them with our RESTful API. By providing the abstraction, we are free to use what
    is required in the backend, such as Pexpect, while providing a uniform frontend
    to our requester. We can even take a step forward and replace the underlying network
    device without impacting the users making API calls to us. Flask provides this
    abstraction in a compact and easy-to-use way for us. We can also run Flask with
    a smaller footprint, such as by using containers.
  prefs: []
  type: TYPE_NORMAL
- en: Running Flask in containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers have become very popular in the last few years. They offer more abstractions
    and virtualization beyond hypervisor-based virtual machines. For interested readers,
    we will offer a simple example of how we can run our Flask app in a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: We will build our example based on the free DigitalOcean Docker tutorial on
    building containers on Ubuntu 20.04 machines ([https://www.digitalocean.com/community/tutorials/how-to-build-and-deploy-a-flask-application-using-docker-on-ubuntu-20-04](https://www.digitalocean.com/community/tutorials/how-to-build-and-deploy-a-flask-application-using-docker-on-ubuntu-20-04)).
    If you are new to containers, I would highly recommend that you go through that
    tutorial and return to this section after.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make sure Docker is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We will make a directory named `TestApp` to house our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the directory, we will make another directory called `app` and create the
    `__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `app` directory is where we will contain the logic of our application.
    Since we have been using a single-file app up to this point, we can simply copy
    over the contents of our `chapter9_6.py` file to the `app/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also copy the SQLite database file we created to this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We will place the `requirements.txt` file in the `TestApp` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Due to a conflict with the `tiangolo/uwsgi-nginx-flask` image and some later
    versions of Flask packages, this requirements file is reverting to Flask 1.1.1\.
    The portion of code we worked on works in both version 1.1.1 and the latest Flask
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the `main.py` file as our entry point and an `ini` file for
    `uwsgi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use a pre-made Docker image and create a `Dockerfile` that builds the
    Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `start.sh` shell script will build the image, run it as a daemon in the
    background, then forward port `8000` to the Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `start.sh` script to build the image and launch our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Flask now runs in the container that can be viewed from our host machine
    port `8000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the **management host IP** displayed in the address bar as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Management Host IP Forwarding'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the **Flask API endpoint** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: API Endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are done, we can use the following commands to stop and delete the
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also delete the Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, running Flask in a container gives us even more flexibility and
    the option to deploy our API abstraction in production. Containers, of course,
    offer their complexity and add more management tasks, so we need to weigh up the
    benefits and overhead when it comes to our deployment methods. We are close to
    the end of this chapter, so let’s look at what we have done so far before looking
    forward to the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started to move on to the path of building RESTful APIs
    for our network. We looked at popular Python web frameworks, namely Django and
    Flask, and compared and contrasted the two. By choosing Flask, we can start small
    and expand on features by using Flask extensions.
  prefs: []
  type: TYPE_NORMAL
- en: In our lab, we used the virtual environment to separate the Flask installation
    base from our global site packages. The lab network consists of several IOSv nodes,
    two of which we have designated as spine routers while the other two as leaf routers.
    We took a tour of the basics of Flask and used the simple `HTTPie` client to test
    our API setup.
  prefs: []
  type: TYPE_NORMAL
- en: Among the different setups of Flask, we placed special emphasis on URL dispatch
    as well as URL variables because they are the initial logic between the requesters
    and our API system. We took a look at using Flask-SQLAlchemy and SQLite to store
    and return network elements that are static in nature. For operation tasks, we
    also created API endpoints while calling other programs, such as Pexpect, to accomplish
    configuration tasks. We improved the setup by adding asynchronous handling and
    user authentication to our API. We also looked at how to run our Flask API application
    in a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 10, Introduction to Async IO, we will shift gears to look at one
    of the newer features in Python 3, Async IO, and how it can be applied to network
    engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Join our book community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2903617220506617062.png)'
  prefs: []
  type: TYPE_IMG
