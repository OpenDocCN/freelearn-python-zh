- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Microservices and Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务和容器
- en: Up until now, we have been developing the complete application as one block
    of code (usually known as a **monolith**), which is typically designed, tested,
    and deployed as a single unit. Scaling also occurs in a similar manner, where
    either the whole application is scaled or not. However, as the application grows
    in size, it is natural to want to break the monolith into smaller chunks that
    can be separately managed and scaled. A solution to this is microservices. This
    chapter is all about microservices, and we will look at a few methodologies for
    creating and managing them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将完整的应用程序作为一个代码块（通常称为**单体**）来开发，它通常被设计、测试和部署为一个单一单元。扩展也以类似的方式进行，要么整个应用程序进行扩展，要么不扩展。然而，随着应用程序规模的扩大，自然希望将单体分解成更小的块，以便可以分别管理和扩展。解决这个问题的方案是微服务。本章全部关于微服务，我们将探讨创建和管理微服务的几种方法。
- en: Microservices comprise a method of developing and architecting software applications
    as a collection of multiple loosely coupled services. These services are designed
    and developed to help build single-function modules that have clear and fine-grained
    interfaces. The benefit of this modularity, if designed and architected properly,
    is that the overall application becomes easier to understand, develop, maintain,
    and test. Multiple small autonomous teams can work in parallel on multiple microservices,
    so the time to develop and deliver an application is effectively reduced. Each
    microservice can now be deployed and scaled separately, which allows for less
    downtime and cost-effective scaling since only the high-traffic services can be
    scaled based on predefined criteria. Other services can operate as usual.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种将软件应用程序作为多个松散耦合服务的集合来开发和架构的方法。这些服务被设计和开发出来，以帮助构建具有清晰和细粒度接口的单功能模块。如果设计和架构得当，这种模块化的好处是，整体应用程序更容易理解、开发、维护和测试。多个小型自主团队可以并行工作在多个微服务上，因此开发并交付应用程序的时间实际上得到了有效减少。现在，每个微服务都可以单独部署和扩展，这允许减少停机时间和实现成本效益的扩展，因为只有高流量服务可以根据预定义的标准进行扩展。其他服务可以按常规运行。
- en: This chapter will start with some of the common terminologies that you might
    hear whenever microservices are talked about – that is, containers and Docker.
    First, we will look at how to deploy a Flask application using Docker containers.
    Then, we will look at how multiple containers are scaled and managed effectively
    using Kubernetes, which is one of the best container orchestration tools available.
    Then, we will look at how to create fully-managed microservices using some cloud
    platforms such as **AWS Lambda** and **GCP Cloud Run**. Finally, we will look
    at how to stitch everything together into a seamless deployment pipeline using
    **GitHub Actions**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从一些常见的术语开始，这些术语可能在讨论微服务时都会听到——那就是，容器和 Docker。首先，我们将探讨如何使用 Docker 容器部署 Flask
    应用程序。然后，我们将探讨如何使用 Kubernetes（这是最好的容器编排工具之一）有效地扩展和管理多个容器。接着，我们将探讨如何使用一些云平台（如**AWS
    Lambda**和**GCP Cloud Run**）创建完全管理的微服务。最后，我们将探讨如何使用**GitHub Actions**将所有这些整合成一个无缝的部署管道。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Containerization with Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化
- en: Orchestrating containers with Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 编排容器
- en: Going serverless with Google Cloud Run
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google Cloud Run 进行无服务器部署
- en: Continuous deployment with GitHub Actions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 进行持续部署
- en: Containerization with Docker
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化
- en: A container can be thought of as a standardized package of code that is needed
    to run the application and all its dependencies, which allows the application
    to run uniformly across multiple environments and platforms. **Docker** is a tool
    that allows for a standard and easy method of creating, distributing, deploying,
    and running applications using containers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可以被视为一个标准化的代码包，其中包含了运行应用程序及其所有依赖项所需的代码，这使得应用程序可以在多个环境和平台上以统一的方式运行。**Docker**是一个工具，它允许通过标准且简单的方法创建、分发、部署和运行使用容器的应用程序。
- en: Docker is essentially a virtualization software, but instead of visualizing
    the whole operating system, it allows the application to use the underlying host
    OS and requires applications to package additional dependencies and components
    as needed. This makes Docker container images very lightweight and easy to distribute.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 实质上是一种虚拟化软件，但它不是可视化整个操作系统，而是允许应用程序使用底层主机操作系统，并要求应用程序根据需要打包额外的依赖项和组件。这使得
    Docker 容器镜像非常轻量级且易于分发。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The first step is to install Docker. Docker’s installation steps vary in terms
    of the operating system you use. The detailed steps for each operating system
    can be found at [https://docs.docker.com/install/](https://docs.docker.com/install/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装 Docker。Docker 的安装步骤因所使用的操作系统而异。每个操作系统的详细步骤可以在 [https://docs.docker.com/install/](https://docs.docker.com/install/)
    找到。
- en: Tip
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Docker is a fast-evolving software and has had multiple major releases in the
    last few years, where a lot of older releases have been deprecated. I would suggest
    that you always read the documentation thoroughly to avoid installing any legacy
    versions of Docker.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一种快速发展的软件，在过去的几年中已经发布了多个主要版本，其中许多旧版本已被弃用。我建议您始终仔细阅读文档，以避免安装任何 Docker
    的旧版本。
- en: 'Once Docker has been successfully installed, head over to the Terminal and
    run the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Docker 成功安装，请转到终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command is used to list all the running containers. If it runs
    without any errors and shows a row of headers that start with `CONTAINER ID`,
    then Docker has been successfully installed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令用于列出所有正在运行的容器。如果它没有错误地运行并显示以 `CONTAINER ID` 开头的标题行，那么 Docker 已成功安装。
- en: Information
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Different versions of Docker, whether old or current, have been called Docker
    Toolbox, Docker Machine, Docker Engine, Docker Desktop, and so on. These names
    will appear multiple times across the documentation and other resources on the
    internet. There is a great probability that these might change or evolve in the
    future as well. For the sake of simplicity, I will just call everything **Docker**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的不同版本，无论是旧版还是当前版本，都被称为 Docker Toolbox、Docker Machine、Docker Engine、Docker
    Desktop 等。这些名称将在文档和互联网上的其他资源中多次出现。有很大可能性，这些名称在未来也可能发生变化或发展。为了简单起见，我将只称所有这些为 **Docker**。
- en: 'A more fun way to verify the Docker installation would be to try out a `hello-world`
    container. Just run the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 Docker 安装的一个更有趣的方法是尝试运行一个 `hello-world` 容器。只需运行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command should give you the following output. It lists the steps
    that Docker took to execute this command. I recommend reading through this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令应该给你以下输出。它列出了 Docker 执行此命令所采取的步骤。我建议仔细阅读：
- en: "![Figure 12.1 – Testing D\uFEFFocker](img/B19111_12_1.jpg)"
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 测试 Docker](img/B19111_12_1.jpg)'
- en: Figure 12.1 – Testing Docker
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 测试 Docker
- en: How to do it…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will start with the catalog application from the *Managing and monitoring
    application performance with New Relic* recipe from [*Chapter 11*](B19111_11.xhtml#_idTextAnchor610):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 *使用 New Relic 管理和监控应用程序性能* 的配方中的目录应用程序开始，该配方位于 [*第 11 章*](B19111_11.xhtml#_idTextAnchor610)：
- en: 'The first step toward creating a container is to create an image for it. A
    Docker image can easily be created in a scripted manner by creating a file named
    `Dockerfile`. This file contains the steps that Docker needs to perform to build
    an image for our application’s container. A basic `Dockerfile` for our application
    would be as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建容器的第一步是为它创建一个镜像。可以通过创建一个名为 `Dockerfile` 的文件以脚本方式轻松创建 Docker 镜像。我们的应用程序的基本
    `Dockerfile` 可能如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each line in the preceding file is a command that is executed in a linear top-down
    approach. `FROM` specifies the base container image over which the new image for
    our application container will be built. I have taken the base image as `python:3`,
    which is a Linux image with `Python 3.11` installed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件中的每一行都是一个以线性自上而下的方式执行的命令。`FROM` 指定了新应用程序容器镜像将构建在其上的基础容器镜像。我选择了基础镜像 `python:3`，这是一个安装了
    `Python 3.11` 的 Linux 镜像。
- en: Information
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The `python:3` Docker base images come with `Python 3.11` pre-installed at the
    time of writing this book. This will change over time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 写这本书的时候，`python:3` Docker 基础镜像预装了 `Python 3.11`。这会随着时间的推移而改变。
- en: '`WORKDIR` indicates the default directory where the application will be installed.
    I have set it to `/usr/src/app`. Any commands that are run after this will be
    executed from inside this folder.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`指示应用程序将被安装的默认目录。我已经将其设置为`/usr/src/app`。在此之后运行的任何命令都将从这个文件夹内部执行。'
- en: '`COPY` simply copies the files specified on the local machine to the container
    filesystem. I have copied `requirements.txt` to `/usr/src/app`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`命令简单地将从本地机器上指定的文件复制到容器文件系统中。我已经将`requirements.txt`复制到了`/usr/src/app`。'
- en: This is followed by `RUN`, which executes the command provided. Here, we have
    installed all the requirements from `requirements.txt` using `pip`. Then, I simply
    copied all the files from my current local folder, which is essentially my application
    root folder, to `/usr/src/app`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这后面跟着`RUN`，它执行提供的命令。在这里，我们使用`pip`安装了`requirements.txt`中的所有依赖项。然后，我简单地从当前本地文件夹（本质上是我的应用程序根文件夹）复制了所有文件到`/usr/src/app`。
- en: Finally, an `ENTRYPOINT` is defined that indicates the default `CMD` command,
    which should be run when a container is started. Here, I have simply run my application
    by running `python run.py`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义了一个`ENTRYPOINT`，它指示了默认的`CMD`命令，当容器启动时应运行此命令。在这里，我简单地通过运行`python run.py`来运行我的应用程序。
- en: Information
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: A Dockerfile provides many other keywords, all of which can be used to create
    powerful scripts. Refer to [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    for more information.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile提供了许多其他关键字，所有这些都可以用来创建强大的脚本。有关更多信息，请参阅[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。
- en: Tip
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are multiple ways of running the application, as outlined in [*Chapter
    11*](B19111_11.xhtml#_idTextAnchor610), *Deployment and Post-Deployment*. I would
    urge you to use those methods while dockerizing the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序有多种方式，如[*第11章*](B19111_11.xhtml#_idTextAnchor610)中概述的，*部署和部署后*。我强烈建议你在将应用程序docker化时使用这些方法。
- en: 'For the Dockerfile to run, you must have a `requirements.txt` file in your
    application’s root folder. If you don’t have one, you can simply generate a `requirements.txt`
    file using the following command:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行Dockerfile，你必须在应用程序的根文件夹中有一个`requirements.txt`文件。如果你没有，你可以简单地使用以下命令生成一个`requirements.txt`文件：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is my `requirements.txt` file. I encourage you to generate your
    own instead of using the one that follows because the Python package versions
    will evolve and you will want to use the latest and most relevant ones:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我的`requirements.txt`文件。我鼓励你生成自己的文件，而不是使用下面的文件，因为Python包版本会演变，你将希望使用最新和最相关的版本：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have `mod_wsgi` in your `requirements.txt` file, you can remove it from
    the file unless you specifically want to run your application in a Docker container
    using `Apache`. `mod_wsgi` is an OS-specific package and the OS on your development
    machine might not match that on the Docker image, which would lead to installation
    failure.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的`requirements.txt`文件中有`mod_wsgi`，你可以从文件中删除它，除非你特别想使用`Apache`在Docker容器中运行你的应用程序。`mod_wsgi`是一个特定于操作系统的包，你开发机器上的操作系统可能与Docker镜像上的操作系统不匹配，这会导致安装失败。
- en: 'A small change needs to be made to `run.py`, after which it will look as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`run.py`中需要做一些小的修改，修改后它将如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I have added the `host` parameter to `app.run`. This allows the application
    to be accessed outside the Docker container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将`host`参数添加到了`app.run`中。这允许应用程序在Docker容器外部被访问。
- en: 'The creation of `Dockerfile` is followed by building a Docker container image,
    which can then be run like so:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`Dockerfile`之后，构建一个Docker容器镜像，然后可以像这样运行：
- en: '[PRE13]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we asked Docker to build an image using the Dockerfile at the same location.
    The `-t` argument sets the name/tag for the image that will be built. The final
    argument is a dot (`.`), which indicates that everything in the current folder
    needs to be packaged in the build. This command might take a while to process
    when it’s run for the first time because it will download the base image and then
    all of our application dependencies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求Docker使用同一位置的Dockerfile构建一个镜像。`-t`参数设置了将要构建的镜像的名称/标签。最后的参数是一个点（`.`），表示当前文件夹中的所有内容都需要打包到构建中。当第一次运行此命令时，可能需要一段时间来处理，因为它将下载基础镜像以及我们应用程序的所有依赖项。
- en: 'Let’s check the created image:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查创建的镜像：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, run this image to create a container:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行此镜像以创建一个容器：
- en: '[PRE15]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**92a7ee37e044cf59196f5ec4472d9ffb540c7f48ee3f4f1e5f978f7f93b301ba**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**92a7ee37e044cf59196f5ec4472d9ffb540c7f48ee3f4f1e5f978f7f93b301ba**'
- en: Here, we have asked Docker to run the container using the commands that were
    specified in the `Dockerfile` at the bottom. The `-d` argument asks Docker to
    run the container in detached mode in the background; otherwise, it will block
    control to the current shell window. `-p` maps the port from the host machine
    to the Docker container port. This means that we have asked Docker to map port
    `8000` on the local machine to port `8000` on the container. `8000` is the port
    on which we are running our Flask app (see `run.py`). The last argument is the
    name of the container image, which is a combination of `REPOSITORY` and `TAG`,
    as indicated by the `docker images` command. Alternatively, you can just provide
    an `IMAGE ID`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求 Docker 使用在底部的 `Dockerfile` 中指定的命令来运行容器。`-d` 参数要求 Docker 在后台以分离模式运行容器；否则，它将阻塞当前
    shell 窗口的控制。`-p` 将主机机的端口映射到 Docker 容器端口。这意味着我们要求 Docker 将本地机器上的端口 `8000` 映射到容器上的端口
    `8000`。`8000` 是我们运行 Flask 应用程序（见 `run.py`）的端口。最后一个参数是容器镜像的名称，它是 `REPOSITORY` 和
    `TAG` 的组合，如 `docker images` 命令所示。或者，你也可以只提供一个 `IMAGE ID`。
- en: How it works…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Head over to your browser and open `http://localhost:8000/` to see the application
    running.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并访问 `http://localhost:8000/` 来查看正在运行的应用程序。
- en: 'Now, run `docker ps` again to see the details of the running container:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行 `docker ps` 来查看正在运行的容器的详细信息：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关阅读
- en: You can learn more about Dockerfiles at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    上了解更多关于 Dockerfile 的信息。
- en: The definition of a container by Docker can be read at [https://www.docker.com/resources/what-container](https://www.docker.com/resources/what-container).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 对容器的定义可以在 [https://www.docker.com/resources/what-container](https://www.docker.com/resources/what-container)
    中阅读。
- en: You can read about microservices in general at [https://en.wikipedia.org/wiki/Microservices](https://en.wikipedia.org/wiki/Microservices).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [https://en.wikipedia.org/wiki/Microservices](https://en.wikipedia.org/wiki/Microservices)
    上了解有关微服务的一般信息。
- en: One of the first articles on microservices by Martin Fowler can be found at
    [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Martin Fowler 关于微服务的第一篇文章可以在 [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)
    找到。
- en: Orchestrating containers with Kubernetes
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 编排容器
- en: Docker containers are pretty easy and powerful, as we saw from the previous
    recipe, but without a strong container orchestration system, managing containers
    can become pretty intensive. **Kubernetes** (also written as **K8s**) is an open
    source container orchestration system that automates the management, deployment,
    and scaling of containerized applications. It was originally developed at Google
    and, over the years, has become the most popular container orchestration software.
    It is widely available across all major cloud providers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个菜谱所示，Docker 容器非常简单且强大，但如果没有强大的容器编排系统，管理容器可能会变得相当复杂。**Kubernetes**（也写作 **K8s**）是一个开源的容器编排系统，它自动化了容器化应用程序的管理、部署和扩展。它最初是在
    Google 开发的，经过多年的发展，已经成为最受欢迎的容器编排软件。它在所有主要云提供商中都有广泛的应用。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will see how we can leverage Kubernetes to automate the deployment
    and scaling of our application container, which we created in the previous recipe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何利用 Kubernetes 自动部署和扩展我们在上一个菜谱中创建的应用容器。
- en: Kubernetes is packaged along with the newer versions of the Docker Desktop installation
    and works in a pretty straightforward manner. However, we will be using **minikube**,
    which is a standard distribution that’s provided by Kubernetes itself. It’s quite
    popular and good for getting started. For this recipe, I will use Minikube, which
    will allow a single-node Kubernetes cluster to be run inside a VM on our local
    machine. You can choose to use other distributions of Kubernetes; refer to [https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)
    for more details.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 与 Docker Desktop 的新版本一起打包，并以非常直接的方式工作。然而，我们将使用 **minikube**，这是 Kubernetes
    本身提供的一个标准发行版。它相当受欢迎，适合入门。对于这个菜谱，我将使用 Minikube，它将允许在本地机器上的虚拟机中运行单个节点的 Kubernetes
    集群。你也可以选择使用其他 Kubernetes 发行版；有关更多详细信息，请参阅 [https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)。
- en: To install Minikube, follow the instructions outlined at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
    for your operating system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Minikube，请按照您操作系统的说明在 [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
    中进行操作。
- en: Information
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Kubernetes is a huge topic that spans multiple dimensions. There are multiple
    books dedicated just to Kubernetes, and many more are being written. In this recipe,
    we will cover a very basic implementation of Kubernetes, just to get you acquainted
    with it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个涵盖多个维度的巨大主题。有多个书籍仅专注于 Kubernetes，还有更多正在编写。在这个配方中，我们将介绍 Kubernetes
    的一个非常基本的实现，以便您熟悉它。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to understand how a local Kubernetes cluster can be created
    and used:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解如何创建和使用本地 Kubernetes 集群：
- en: 'After Minikube has been installed, create a Minikube cluster on your local
    machine:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Minikube 后，在您的本地机器上创建一个 Minikube 集群：
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the preceding command downloads a bunch of images to set up
    and run Minikube, which creates a VM on your local machine. After creating a VM
    using these images, a simple Kubernetes cluster with only one node will be launched.
    This process might take a bit of time when it’s run for the first time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的命令下载了一组镜像以设置和运行 Minikube，这将在您的本地机器上创建一个虚拟机。使用这些镜像创建虚拟机后，将启动一个仅有一个节点的简单
    Kubernetes 集群。这个过程在第一次运行时可能需要一些时间。
- en: 'Minikube provides a browser dashboard view as well. This can be initiated by
    running the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 还提供了一个浏览器仪表板视图。可以通过运行以下命令来启动：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Visit the URL mentioned in the output of the preceding command to view the dashboard.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 访问前面命令输出的 URL 来查看仪表板。
- en: In Kubernetes, containers are deployed in pods, where a pod can be defined as
    a group of one or more containers that are tied together for sharing resources
    and networking. In this recipe, we will have only one container inside a pod.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，容器在 pod 中部署，其中 pod 可以定义为共享资源和网络的一组一个或多个容器。在这个配方中，我们将在一个 pod 中只有一个容器。
- en: 'Whenever a deployment is created using Minikube, it will look for the Docker
    image on some cloud-based registries such as Docker Hub or Google Cloud Registry,
    or something custom. For this recipe, we intend to make a deployment using a local
    Docker image. Therefore, we will run the following command, which sets the `docker`
    environment to `minikube docker`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论何时使用 Minikube 创建部署，它都会在云基础镜像仓库中查找 Docker 镜像，例如 Docker Hub 或 Google Cloud Registry，或者某些自定义的仓库。对于这个配方，我们打算使用本地
    Docker 镜像来创建部署。因此，我们将运行以下命令，该命令将 `docker` 环境设置为 `minikube docker`：
- en: '[PRE30]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, rebuild the Docker image using the preceding `docker` environment set:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用前面设置的 `docker` 环境重新构建 Docker 镜像：
- en: '[PRE31]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For more details on building Docker images, refer to the previous recipe, *Containerization
    with Docker*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关于构建 Docker 镜像的更多细节，请参考之前的配方，*使用 Docker 容器化*。
- en: 'Next, create a file named `cookbook-deployment.yaml` in your application root
    folder:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的应用程序根目录中创建一个名为 `cookbook-deployment.yaml` 的文件：
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this file, we created a deployment named `cookbook-recipe`, which uses the
    `cookbook:latest` image. Take note of `imagePullPolicy`, which is set to `Never`
    – this signifies that kubectl should not try to fetch the image from online Docker
    repositories (such as Docker Hub or **Google Container Registry** (**GCR**); instead,
    it should always search for this image locally.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们创建了一个名为 `cookbook-recipe` 的部署，它使用 `cookbook:latest` 镜像。请注意 `imagePullPolicy`，它设置为
    `Never` – 这表示 kubectl 不应尝试从在线 Docker 仓库（如 Docker Hub 或 **Google Container Registry**
    （**GCR**））获取镜像；相反，它应始终在本地搜索此镜像。
- en: 'Now, `apply` the preceding file to create a Kubernetes deployment using kubectl:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 kubectl `apply` 之前文件以创建 Kubernetes 部署：
- en: '[PRE57]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can verify and get the status of the deployment that’s been created by
    running the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来验证和获取已创建部署的状态：
- en: '[PRE59]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Check the values for the `READY`, `UP-TO-DATE`, and `AVAILABLE` columns. These
    values represent the number of replicas of our application in the cluster.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `READY`、`UP-TO-DATE` 和 `AVAILABLE` 列的值。这些值代表集群中我们的应用程序副本的数量。
- en: 'Our application is now running but is currently not accessible outside the
    cluster. To expose the application outside the Kubernetes cluster, create a `LoadBalancer`
    type service:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序现在正在运行，但目前无法在集群外部访问。要使应用程序在 Kubernetes 集群外部可用，请创建一个 `LoadBalancer` 类型的服务：
- en: '[PRE60]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The deployment that we created in the last step exposed our application on port
    `8000`, which was internal to the cluster. The preceding command has exposed this
    internal `8000` port to any random port that can be accessed outside the cluster
    and hence via a browser.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步中创建的部署将我们的应用程序暴露在端口`8000`上，这是集群内部的。前面的命令已经将这个内部的`8000`端口暴露给集群外部的任何随机端口，因此可以通过浏览器访问。
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To open the application in a browser, run the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器中打开应用程序，请运行以下命令：
- en: '[PRE62]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '![Figure 12.2 – Service deployed using Kubernetes](img/B19111_12_2.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 使用 Kubernetes 部署的服务](img/B19111_12_2.jpg)'
- en: Figure 12.2 – Service deployed using Kubernetes
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 使用 Kubernetes 部署的服务
- en: Running the preceding command will open the application in a browser on a random
    port, such as `58764`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令将在随机端口（如`58764`）上的浏览器中打开应用程序。
- en: 'Scaling a deployment is very easy with Kubernetes. It is as simple as running
    a single command. By doing this, the application will be replicated in multiple
    pods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 扩展部署非常简单。这只需要运行一个命令。通过这样做，应用程序将在多个 Pod 中进行复制：
- en: '[PRE63]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, look at the status of deployment again:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次查看部署的状态：
- en: '[PRE64]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Check the replica values in the `READY`, `UP-TO-DATE`, and `AVAILABLE` columns,
    which will have increased from `1` to `3`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`READY`、`UP-TO-DATE`和`AVAILABLE`列中的副本值，这些值将从`1`增加到`3`。
- en: There’s more…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'You can look at the YAML configurations that Kubernetes automatically creates
    for the deployment and service:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看 Kubernetes 自动为部署和服务创建的 YAML 配置：
- en: '[PRE65]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The preceding code is the config for the service. You can choose to create/save
    and `apply` this config (instead of specifying configuration values in command
    lines) just like we did earlier for the deployment in *Step 5*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码是服务的配置。您可以选择创建/保存并`应用`这个配置（而不是像我们在*步骤 5*中为部署所做的那样，在命令行中指定配置值）。
- en: Information
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: What I have shown in this recipe is a very basic implementation of Kubernetes.
    The purpose of this is to get you acquainted with Kubernetes. This recipe does
    not intend to be a production-grade implementation. Ideally, the config files
    need to be created, and then the overall Kubernetes deployment can be built around
    them. I would urge you to build on the knowledge from this recipe and strive toward
    production-grade techniques with Kubernetes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我展示的是 Kubernetes 的一个非常基本的实现。这个目的在于让您熟悉 Kubernetes。这个菜谱并不打算成为一个生产级别的实现。理想情况下，需要创建配置文件，然后围绕这些文件构建整体的
    Kubernetes 部署。我敦促您基于这个菜谱的知识，努力追求 Kubernetes 的生产级技术。
- en: See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more, check out the following resources:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息，请查看以下资源：
- en: Start getting to know about Kubernetes at [https://kubernetes.io/docs/concepts/overview/](https://kubernetes.io/docs/concepts/overview/)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[https://kubernetes.io/docs/concepts/overview/](https://kubernetes.io/docs/concepts/overview/)开始了解
    Kubernetes。
- en: The basics of Kubernetes are available at [https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 的基础知识可在[https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)找到。
- en: A Minikube tutorial can be followed at [https://kubernetes.io/docs/tutorials/hello-minikube/](https://kubernetes.io/docs/tutorials/hello-minikube/)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以遵循[https://kubernetes.io/docs/tutorials/hello-minikube/](https://kubernetes.io/docs/tutorials/hello-minikube/)中的
    Minikube 教程。
- en: You can learn about the details of Minikube’s installation at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)了解
    Minikube 安装的详细信息。
- en: The complete Kubernetes documentation can be found at [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的 Kubernetes 文档可在[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)找到。
- en: Going serverless with Google Cloud Run
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Cloud Run 实现无服务器
- en: '**Serverless computing** is a cloud computing model where the cloud provider
    runs the server and dynamically manages the allocation of machine resources by
    scaling the resources up or down, depending on the consumption. Pricing is done
    based on the actual resources that are used. It also simplifies the overall process
    of deploying code, and it becomes relatively easy to maintain different executions
    for different environments, such as development, testing, staging, and production.
    These properties of serverless computing make this model a perfect candidate for
    developing and deploying tons of microservices without worrying about managing
    the overhead.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**无服务器计算**是一种云计算模型，其中云服务提供商运行服务器，并根据消费动态调整机器资源的分配，通过扩展或缩减资源来管理。计费基于实际使用的资源。它还简化了部署代码的整体流程，并且对于不同环境（如开发、测试、预生产和生产）维护不同的执行变得相对容易。无服务器计算的特性使这种模型成为开发部署大量微服务而不必担心管理开销的理想选择。'
- en: Trivia
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点
- en: Why is this model called “serverless” even though there is a server involved?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个模型被称为“无服务器”，尽管其中涉及服务器？
- en: Even though there is a server involved that hosts your application and serves
    the requests coming into your application, the lifespan of the server is as small
    as a single request. So, you can think of a server as something that lives to
    serve a single request. Hence, the lifespan of a server is typically in milliseconds.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管涉及一个服务器来托管你的应用程序并处理进入应用程序的请求，但服务器的生命周期与单个请求一样短。因此，你可以将服务器视为只为单个请求而存在的东西。因此，服务器的生命周期通常是毫秒级的。
- en: As Google explains, **Cloud Run** is a managed compute platform that lets you
    run containers directly on top of Google’s scalable infrastructure. Also, since
    Google Cloud provides loads of other services with which Cloud Run integrates
    very well, it allows us to build full-featured applications without a lot of moving
    parts from different cloud vendors.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如谷歌所述，**Cloud Run** 是一个托管计算平台，允许你直接在谷歌的可扩展基础设施上运行容器。此外，由于 Google Cloud 提供了大量与
    Cloud Run 非常好集成的其他服务，它允许我们构建具有许多不同云供应商部件的全功能应用程序。
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this recipe, I will interchangeably use the terms **Google Cloud**,
    **Google Cloud Platform**, and **GCP**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个菜谱中，我将交替使用 **Google Cloud**、**Google Cloud Platform** 和 **GCP** 这三个术语。
- en: Tip
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Deploying with serverless tools allows developers to focus more on writing code
    rather than worrying about the infrastructure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无服务器工具进行部署允许开发者更多地专注于编写代码，而不是担心基础设施。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you can deploy with Cloud Run, you need to set up the `gcloud` CLI on
    your machine from where you would deploy your application to Cloud Run. Go through
    the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够使用 Cloud Run 部署之前，你需要设置你的机器上的 `gcloud` CLI，从那里你将部署你的应用程序到 Cloud Run。按照以下步骤操作：
- en: First, create an account on Google Cloud Platform. Head over to [https://console.cloud.google.com/getting-started](https://console.cloud.google.com/getting-started)
    and create a new account if you don’t already have one. Then, create a project
    under which you will deploy your application.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Google Cloud Platform 上创建一个账户。如果你还没有账户，请访问 [https://console.cloud.google.com/getting-started](https://console.cloud.google.com/getting-started)
    并创建一个新的账户。然后，创建一个项目，你将在其中部署你的应用程序。
- en: Once you’ve created your account, make sure you have a billing account activated.
    Even though you will not be charged for the use case of this recipe, Google mandates
    you to have a billing account activated and linked to your project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了账户，请确保你有一个激活的计费账户。即使你不会为此菜谱的使用案例付费，谷歌也要求你激活一个计费账户并将其链接到你的项目。
- en: 'Next, install the `gcloud` CLI. This is highly OS-specific, so look for appropriate
    instructions here: [https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install).'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装 `gcloud` CLI。这非常依赖于操作系统，所以请在此处查找适当的说明：[https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install)。
- en: The `gcloud` CLI uses Python versions 3.5 to 3.9 for its installation. If you
    have a later version of Python such as 3.10 or 3.11, you don’t need to worry about
    it as `gcloud` will download its own Python version and create a virtual environment
    for itself.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcloud` CLI 使用 Python 3.5 到 3.9 版本进行安装。如果你有 Python 3.10 或 3.11 等后续版本，你不必担心，因为
    `gcloud` 将下载它自己的 Python 版本并为自身创建一个虚拟环境。'
- en: 'Once the `gcloud` installation is done, run the following command to initialize
    `gcloud` and go over some basic settings:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成 `gcloud` 的安装，运行以下命令以初始化 `gcloud` 并进行一些基本设置：
- en: '[PRE66]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The execution of this command will ask you for some details, such as which GCP
    account you would want to use to link to your `gcloud` CLI. On a desktop, it will
    open a browser and ask you to log into your GCP account. Make sure the user who
    logs in has enough permissions to deploy to Cloud Run. For this recipe, the `owner`
    permission should handle everything.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令将要求您提供一些详细信息，例如您想要使用哪个 GCP 账户来链接到您的 `gcloud` CLI。在桌面电脑上，它将打开浏览器并要求您登录您的
    GCP 账户。请确保登录的用户有足够的权限部署到 Cloud Run。对于这个食谱，`owner` 权限应该处理所有事情。
- en: Then, you will be asked about the GCP project that you want to use.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将需要选择您想要使用的 GCP 项目。
- en: You can always change this configuration by running the same command again.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过再次运行相同的命令来更改此配置。
- en: How to do it…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤操作：
- en: After setting up and initializing `gcloud`, the next step is to create and upload
    the container of your application to GCR. You can also use other container registries
    such as Docker Hub, but that is outside the scope of this recipe.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置和初始化 `gcloud` 之后，下一步是创建并将您的应用程序容器上传到 GCR。您还可以使用其他容器注册表，如 Docker Hub，但这超出了本食谱的范围。
- en: Important
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Cloud Run expects the application to run on port `8080`. So, update your `run.py`
    to run on `8080` instead of `8000` or `5000` like we have done so far in this
    book.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run 预期应用程序在端口 `8080` 上运行。因此，更新您的 `run.py` 以在 `8080` 上运行，而不是像我们在本书中迄今为止所做的那样在
    `8000` 或 `5000` 上运行。
- en: 'Run the following command from the root of your application where your `Dockerfile`
    is located:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的应用程序根目录（您的 `Dockerfile` 所在的位置）运行以下命令：
- en: '[PRE67]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding command created a Docker container using `Dockerfile`. Then,
    it uploaded the Docker container to GCR at the path provided in the command. On
    successful execution, you will get a response similar to the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令使用 `Dockerfile` 创建了一个 Docker 容器，然后将其上传到命令中提供的路径上的 GCR。执行成功后，您将获得类似于以下响应：
- en: '![Figure 12.3 – GCR image creation](img/B19111_12_3.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – GCR 镜像创建](img/B19111_12_3.jpg)'
- en: Figure 12.3 – GCR image creation
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – GCR 镜像创建
- en: 'Now, use the image you created to deploy your application to Cloud Run. Run
    the following command for the same:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您创建的镜像将您的应用程序部署到 Cloud Run。运行以下命令进行相同的操作：
- en: '[PRE68]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This command will ask for a region of deployment if one hasn’t been set already;
    then, it will take a few minutes to deploy the application successfully to Cloud
    Run. Once done, it will provide the Service URL on which the application can be
    accessed. See the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未设置部署区域，此命令将要求您输入一个区域；然后，它将花费几分钟将应用程序成功部署到 Cloud Run。完成后，它将提供可以访问应用程序的服务
    URL。请参阅以下截图：
- en: "![Fig\uFEFFure 12.4 – Deployment on Cloud Run](img/B19111_12_4.jpg)"
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – Cloud Run 上的部署](img/B19111_12_4.jpg)'
- en: Figure 12.4 – Deployment on Cloud Run
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – Cloud Run 上的部署
- en: How it works…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To check whether the application deployment is successful and is running as
    expected, open the Service URL provided, as shown in the previous screenshot.
    It should open the application home page.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查应用程序部署是否成功并且按预期运行，请打开之前截图所示的服务 URL。它应该打开应用程序的主页。
- en: See also
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more, check out the following resources:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息，请查看以下资源：
- en: You can read more about Cloud Run at [https://cloud.google.com/run/docs/overview/what-is-cloud-run](https://cloud.google.com/run/docs/overview/what-is-cloud-run).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 [https://cloud.google.com/run/docs/overview/what-is-cloud-run](https://cloud.google.com/run/docs/overview/what-is-cloud-run)
    了解更多关于 Cloud Run 的信息。
- en: There are other serverless tools and platforms such as Serverless, Zappa, AWS
    Beanstalk, AWS Lambda, and others. I urge you to explore them on your own. The
    underlying concept remains the same.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他无服务器工具和平台，如 Serverless、Zappa、AWS Beanstalk、AWS Lambda 等。我敦促您自己探索它们。基本概念保持不变。
- en: Continuous deployment with GitHub Actions
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 进行持续部署
- en: Continuous deployment is a deployment strategy that enables the deployment and
    release of software to its relevant environment (production, in most cases) whenever
    there is a committed code change. Usually, this is preceded by automated test
    cases; when those pass, the code is deployed automatically.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署是一种部署策略，它允许在提交代码更改时将软件部署和发布到其相关环境（在大多数情况下是生产环境）。通常，这之前会有自动测试用例；当这些测试通过时，代码会自动部署。
- en: '**GitHub Actions** is a continuous deployment platform provided by GitHub that
    allows you to trigger workflows on certain actions (such as code commit/merge/pull
    request). These workflows can be used to deploy to your choice of cloud provider.
    The best thing about GitHub Actions is that it integrates seamlessly with GitHub.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitHub Actions**是由GitHub提供的一个持续部署平台，允许您在特定的动作（如代码提交/合并/拉取请求）上触发工作流程。这些工作流程可以用于部署到您选择的云提供商。GitHub
    Actions最好的地方是它能够无缝集成到GitHub中。'
- en: Other tools can be used to perform continuous deployment but I will be focusing
    on GitHub Actions because it is one of the easiest ones to understand and adopt.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用其他工具执行持续部署，但我会专注于GitHub Actions，因为它是最容易理解和采用的之一。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, I am assuming that you have a GitHub account and know the basics
    of managing code and repositories on GitHub.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我假设您有一个GitHub账户并且了解GitHub上管理代码和仓库的基本知识。
- en: In this recipe, we will be building upon the application from the previous recipe.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将基于上一个配方中的应用程序进行构建。
- en: 'Two steps need to be done to get ready for this recipe:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行两个步骤才能为这个配方做好准备：
- en: In the previous recipe, the authentication step for Google Cloud was performed
    during `gcloud init`, where you were asked to log in to GCP. But when deploying
    from GitHub Actions, you won’t have this liberty; hence, you need to create a
    service account on Google Cloud that has permission to create a container image
    on GCR and then deploy it to Cloud Run.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个配方中，Google Cloud的认证步骤是在`gcloud init`期间执行的，当时你被要求登录到GCP。但是当从GitHub Actions部署时，你不会有这种自由；因此，你需要在Google
    Cloud上创建一个服务账户，它有权限在GCR上创建容器镜像并将其部署到Cloud Run。
- en: 'To create a service account, head over to your GCP console and open **IAM &
    Admin**. Next, create a service account and give it relevant permissions/roles.
    To test this recipe, **owner** permission should do. Once you have created and
    configured a service account, it should look like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务账户，请转到您的GCP控制台并打开**IAM & Admin**。接下来，创建一个服务账户并授予它相关的权限/角色。为了测试这个配方，**所有者**权限应该足够。一旦创建并配置了服务账户，它应该看起来像这样：
- en: '![](img/B19111_12_5.png)Figure 12.5 – Service account on GCP'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B19111_12_5.png)图12.5 – GCP上的服务账户'
- en: Download the service account file in JSON format when given the option. It cannot
    be downloaded again.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当有机会时，下载服务账户文件（JSON格式）。该文件无法再次下载。
- en: Next, configure your GitHub repository so that it stores secrets that will be
    read when the deployment runs. Head over to your GitHub repository by going to
    `RUN_PROJECT` and `RUN_SA_KEY`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，配置您的GitHub仓库，以便它在部署运行时存储将被读取的秘密。通过转到`RUN_PROJECT`和`RUN_SA_KEY`来访问您的GitHub仓库。
- en: '`RUN_PROJECT` is the project ID of your GCP project, while `RUN_SA_KEY` is
    the content of the service account JSON file that you downloaded in the previous
    step:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN_PROJECT`是您的GCP项目ID，而`RUN_SA_KEY`是您在上一步中下载的服务账户JSON文件的内容：'
- en: '![Figure 12.6 – GitHub repository secrets](img/B19111_12_6.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – GitHub仓库密钥](img/B19111_12_6.jpg)'
- en: Figure 12.6 – GitHub repository secrets
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – GitHub仓库密钥
- en: How to do it…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now, create a file called `.github/workflows/main.yml` in your application’s
    root folder. Make sure the path for the file is created properly. You will need
    to create two folders called `.github` and `workflows` inside it, followed by
    the `main.yml` file in the latter. The following is the content of the file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的应用程序根目录中创建一个名为`.github/workflows/main.yml`的文件。确保文件路径已正确创建。您需要在其中创建两个文件夹名为`.github`和`workflows`，然后在后者中创建`main.yml`文件。以下是该文件的内容：
- en: '[PRE71]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In this file, first, we specified the branch on which the GitHub action is
    triggered on code push. Then, we have some environment variables that will be
    used in the next steps in the file. A job named `Setup, Build,` `and Deploy` is
    then created that specifies the operating system, which is Ubuntu in our case.
    The job consists of four steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，首先，我们指定了GitHub动作在代码推送时触发的分支。然后，我们有一些环境变量将在文件中的下一步中使用。接着创建了一个名为“设置、构建和部署”的工作，它指定了操作系统，在我们的例子中是Ubuntu。该工作由四个步骤组成：
- en: '**Checkout**: Checks out code from the GitHub branch that was specified earlier.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检出**：检出之前指定的GitHub分支的代码。'
- en: '`gcloud` and authenticates using the service account credentials file.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gcloud`并使用服务账户凭证文件进行认证。'
- en: '`gcloud submit`.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gcloud submit`。'
- en: '**Deploy the image to Cloud Run**: Deploys the Docker image created in the
    preceding step to Cloud Run.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署镜像到Cloud Run**：将前一步创建的Docker镜像部署到Cloud Run。'
- en: Now, just commit and push your code to the relevant branch.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需将您的代码提交并推送到相关分支。
- en: How it works…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When the code is pushed to GitHub on the correct branch, the GitHub action
    is triggered. A successful GitHub action looks like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码推送到 GitHub 的正确分支时，GitHub 动作就会被触发。一个成功的 GitHub 动作看起来像这样：
- en: '![Figure 12.7 – Successful GitHub action execution](img/B19111_12_7.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 成功的 GitHub 动作执行](img/B19111_12_7.jpg)'
- en: Figure 12.7 – Successful GitHub action execution
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 成功的 GitHub 动作执行
- en: To see your application running, copy the service URL, as shown in the preceding
    screenshot, and open it in your browser.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您的应用程序正在运行，请复制服务 URL，如前一个屏幕截图所示，并在您的浏览器中打开它。
- en: Tip
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have followed this book since the beginning, this recipe would be a good
    place to think about how all the major pieces fall into place to complete the
    puzzle. We learned about creating a Flask application, then built more complexity
    into it, which was followed by unit test cases and, last but not least, deployment.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从本书开始就一直在跟随，那么这个菜谱就是一个思考所有主要部分如何拼凑在一起以完成拼图的好地方。我们学习了如何创建 Flask 应用程序，然后将其复杂性增加，接着是单元测试用例，最后但同样重要的是，部署。
- en: In this recipe, we automated deployment on code commits known as **continuous
    deployment**.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们自动化了被称为**持续部署**的代码提交部署。
- en: You can also modify your GitHub workflow to run test cases before building the
    image and exit on failure. This is called **continuous integration**.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以修改您的 GitHub 工作流程，在构建镜像之前运行测试用例，并在失败时退出。这被称为**持续集成**。
- en: See also
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can read more about GitHub Actions at [https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions](https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions](https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions)了解更多关于
    GitHub Actions 的信息。
