- en: Chapter 4. Working with a RESTful API and Pulse Width Modulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will interact with the board with HTTP requests and we
    will use pulse width modulation to generate different output voltages. We shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with the Tornado web server to build a RESTful API in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compose and send HTTP requests to print numbers in LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with pulse width modulation to control the output voltage in pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fade in and fade out LEDs connected to the board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use different tools to compose and send HTTP requests that interact with the
    board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a RESTful API to mix red, green and blue and generate millions of colors
    with an RGB LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `mraa` and `wiring-x86` libraries to control pulse width modulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing numbers in LEDs with a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tornado is a Python web framework and asynchronous networking library. It is
    well known for providing great scalability due to its non-blocking network I/O.
    We will take advantage of the fact that Tornado makes it really easy to build
    a RESTful API and make it possible for any client to consume this API and print
    numbers in LEDs connected to the board. The following is the web page for the
    Tornado web server: [http://www.tornadoweb.org](http://www.tornadoweb.org).'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Understanding and Setting up the Base IoT
    Hardware"), *Understanding and Setting up the Base IoT Hardware*, we installed
    the `pip` installer to easily install additional Python 2.7.3 packages in the
    Yocto Linux that we are running on the board. Now, we will use a `pip` installer
    to install Tornado 4.3\. We just need to run the following command in the SSH
    terminal to install the package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The last lines for the output will indicate that the `tornado` package has been
    successfully installed. Don't worry about the error messages related to building
    wheel and the insecure platform warning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will install HTTPie, a command-line HTTP client written in Python that
    makes it easy to send HTTP requests and uses a syntax that is easier than curl
    (also known as cURL). HTTPie displays colorized output and will make it easy for
    us to send HTTP requests to test our RESTful API. We just need to run the following
    command in the SSH terminal to install the package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The last lines for the output will indicate that the `httpie` package has been
    successfully installed. Don't worry about the insecure platform warning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use an `http` command to easily send HTTP requests to `localhost`
    and test the RESTful API built with Tornado. Obviously, after we test that the
    RESTful API is working OK locally, we want to send HTTP requests from a computer
    or device connected to our LAN. You can install HTTPie in your computer or use
    any other application that allows you to compose and send HTTP requests, such
    as the previously mentioned curl utility ([http://curl.haxx.se](http://curl.haxx.se))
    or Telerik Fiddler ([http://www.telerik.com/fiddler](http://www.telerik.com/fiddler))
    in case you are working on Windows. Telerik Fiddler is a free web debugging proxy
    with a GUI but it only runs on Windows. You can even use apps that can compose
    and send HTTP requests from mobile devices and test the RESTful API by using them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are working on either OS X or Linux, you can open a Terminal and start
    using curl from the command line. If you are working on Windows, you can easily
    install curl from the Cygwin package installation option, and execute it from
    the Cygwin terminal.
  prefs: []
  type: TYPE_NORMAL
- en: In order to build a RESTful API with Tornado, first we have to create subclasses
    of the `tornado.web.RequestHandler` class and override the necessary methods to
    handle the HTTP requests to the URL. For example, if we want to handle an HTTP
    `GET` request with a synchronous operation, we must create a new subclass of the
    `tornado.web.RequestHandler` class and define the `get` method with the required
    arguments, if any. If we want to handle an HTTP `PUT` request, we just need to
    define the `put` method with the required arguments. Then, we have to map the
    URL pattern in an instance of the `tornado.web.Application` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the new classes that we must add to our existing code
    with either the `mraa` or the `wiring-x86` libraries that made it possible to
    print numbers in LEDs in the previous chapter. We already had the `Led` and `NumberInLeds`
    classes and the code adds the following classes: `BoardInteraction`, `VersionHandler`,
    `PutNumberInLedsHandler`, `GetCurrentNumberHandler`. The code file for the sample
    is `iot_python_chapter_04_01.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BoardInteraction` class declares two class attributes: `number_in_leds`
    and `current_number`. The other classes define methods that work with these class
    attributes, to access a common `NumberInLeds` instance, saved in `number_in_leds`,
    and the current number that is being displayed with LEDs, saved in `current_number`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code declares the following three subclasses of `tornado.web.RequestHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VersionHandler`: Defines the parameter less `get` method that returns a response
    with the version number and the last build date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PutNumberInLedsHandler`: Defines the `put` method that requires a number argument
    that specifies the number that has to be printed with LEDs. The method calls the
    `print_number` method for the `NumberInLeds` instance stored in the `BoardInteraction.number_in_leds`
    class attribute with the desired number of LEDs to be turned on specified in the
    `number` attribute. Then, the code saves the number that is being printed with
    LEDs in the `BoardInteraction.current_number` class attribute and returns a response
    with the printed number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetCurrentNumberHandler`: Defines the parameter less `get` method that returns
    a response with the value of the `BoardInteraction.current_number` class attribute,
    that is, the number that is being printed with LEDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lines use the previously declared subclasses of `tornado.web.RequestHandler`
    to make up the web application with Tornado that represents the RESTful API and
    the new `__main__` method. The code file for the sample is `iot_python_chapter_04_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, the code creates an instance of the `tornado.web.Application` class named
    `application` with the list of request handlers that make up the web application.
    The code passes a list of tuples to the `Application` constructor. The list is
    composed of a regular expression (`regexp`) and a subclass of `tornado.web.RequestHandler`
    (`request_class`).
  prefs: []
  type: TYPE_NORMAL
- en: The `__main__` method prints a message indicating the port number in which the
    HTTP server is listening and uses the `NumberInLeds` instance saved in `BoardInteraction.number_in_leds`
    to print number 0, that is, to turn off the nine LEDs. The next line calls the
    `application.listen` method to build an HTTP server for the application with the
    defined rules on the specified port. The code passes `8888` for the `port` argument,
    that is, the default port value for the Tornado HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the call to `tornado.ioloop.IOLoop.instance().start()` starts the server
    created with `application.listen`. This way, whenever the web application receives
    a request, Tornado iterates over the list of request handlers that make up the
    web application and creates an instance of the first `tornado.web.RequestHandler`
    subclass whose associated regular expression matches the request path. Then, Tornado
    calls one of the following methods the corresponding parameters for the new instance
    based on the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`head`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table shows some HTTP requests that match the regular expressions
    defined in the preceding code. In this case, the HTTP requests use localhost because
    they are executed locally on the Yocto Linux running on the board. If we replace
    localhost with the board's assigned IP address, we can make the HTTP requests
    from any computer or device connected to our LAN.
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP verb and request URL | Tuple (`regexp`, `request_class`) that matches
    the request path | `RequestHandler` subclass and method that is called |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET http://localhost:8888/version` | `(r"/version", VersionHandler)])` |
    `VersionHandler.get()` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT http://localhost:8888/putnumberinleds/5` | `(r"/putnumberinleds/([0-9])",
    PutNumberInLedsHandler)` | `PutNumberInLedsHandler.put(5)` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT http://localhost:8888/putnumberinleds/8` | `(r"/putnumberinleds/([0-9])",
    PutNumberInLedsHandler)` | `PutNumberInLedsHandler.put(8)` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET http://localhost:8888/getcurrentnumber` | `(r"/getcurrentnumber", GetCurrentNumberHandler)`
    | `GetCurrentNumberHandler.get()` |'
  prefs: []
  type: TYPE_TB
- en: 'The `RequestHandler` class declares a `SUPPORTED_METHODS` class attribute with
    the following code. In this case, we haven''t overridden the class attribute,
    and therefore, we inherit superclass declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The default code declared in the superclass for the `get`, `head`, `post`, `delete`,
    `patch`, `put`, and `options` methods is a single line that raises an `HTTPError`.
    For example, the following line shows the code for the `get` method defined in
    the `RequestHandler` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the web application receives a request and matches the URL pattern,
    Tornado performs the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new instance of the `RequestHandler` subclass that has been mapped
    to the URL pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `initialize` method with the keyword arguments specified in the application
    configuration. We can override the `initialize` method to save the arguments into
    member variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No matter which is the HTTP request, call the `prepare` method. If we call either
    `finish` or `send_error`, Tornado won't call any additional methods. We can override
    the `prepare` method to execute code that is necessary for any HTTP request and
    then write the specific code in the `get`, `head`, `post`, `delete`, `patch`,
    `put` or `options` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the method according to the HTTP request with the arguments based on the
    URL regular expression that captured the different groups. As previously explained,
    we must override the methods we want our `RequestHandler` subclass to be able
    to process. For example, if there was an HTTP `GET` request, Tornado will call
    the `get` method with the different arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, we are working with synchronous handlers, and therefore, Tornado
    calls `on_finish` after the previous method called according to the HTTP request
    returned. We can override the `on_finish` method to perform cleanup or logging.
    It is very important to understand that Tornado calls `on_finish` after it sent
    the response to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following line will start the HTTP server and our RESTful API in the Yocto
    Linux running on the board. Don't forget that you need to transfer the Python
    source code file to the Yocto Linux with an SFTP client, as explained in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After we start the HTTP server, we will see the following output and all the
    LEDs on the board are going to be turned off.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Composing and sending HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP server is running in Yocto Linux and waiting for our HTTP requests
    to control the LEDs on connected to the Intel Galileo Gen 2 board. Now, we will
    compose and send HTTP requests locally in Yocto Linux and then from other computer
    or devices connected to our LAN.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPie supports curl-like shorthands for localhost. For example, `:8888` is
    a shorthand that expands to `http://localhost:8888`. We already have an SSH terminal
    running the HTTP server, and therefore, we can run the following command in another
    SSH terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://localhost:8888/version`. The request is the simplest case in our RESTful
    API because it will match and run the `VersionHandler.get` method that just receives
    `self` as a parameter because the URL pattern doesn''t include any parameters.
    The method creates a response dictionary and then calls the `self.write` method
    with `response` as a parameter. The `self.write` method writes the received chunk
    to the output buffer. Because the chunk (`response`) is a dictionary, `self.write`
    writes it as JSON and sets the `Content-Type` of the response to `application/json`.
    The following lines show an example response for the HTTP request, including the
    response headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can execute HTTPie with the `-b` option in case we don't want to include
    the header in the response. For example, the following line performs the same
    HTTP request but doesn't display the header in the response output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once we know that our request is running OK, we can open a new terminal, command-line
    or the GUI tool that we want to use to compose and send HTTP requests from a computer
    or any device connected to the LAN. We just need to use the IP address assigned
    to the board instead of `localhost` in our request URLs. Don't forget to replace
    `192.168.1.107` with your board's IP address in the next requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can run the following HTTPie command in a computer or device to use
    the RESTful API to make the board turn on the five LEDs. After you enter the command,
    you will notice the SSH terminal that displays the output for the Python code
    will display a message indicating that it is turning on 5 LEDs and the additional
    messages indicating the LEDs that are being turned on and off. In addition, you
    will see 5 LEDs turned on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://192.168.1.107:8888/putnumberinleds/5`. The request will match and run the
    `PutNumberInLedsHandler.put` method that receives `5` in its `number` parameter.
    The following lines show the response from the HTTP server with the number that
    has been printed in LEDs, that is, the number of LEDs that have been turned on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The following image shows two Terminal windows side-by-side on OS X. The Terminal
    window at the left-hand side is running on a computer that is generating the HTTP
    requests and the Terminal window at the right-hand side is the SSH terminal that
    is running the Tornado HTTP server in Yocto Linux and displays the output for
    our Python code. It is a good idea to use a similar configuration to check the
    output while we compose and send the HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing and sending HTTP requests](img/B05042_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Fiddler, click **Composer** or press *F9*, select **PUT** in the dropdown
    menu in the **Parsed** tab, and enter `192.168.1.107:8888/putnumberinleds/5` in
    the textbox at the right-hand side of the dropdown (don't forget to replace the
    IP with your board's IP). Then, click **Execute** and double-click on the 200
    result that appears on the capture log. If you want to see the raw response, just
    click on the **Raw** button below the **Request Headers** panel.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows a Fiddler window side-by-side with a Putty terminal
    window on Windows. The Fiddler window at the left-hand side is running on a computer
    that is generating the HTTP requests and the Putty terminal window at the right-hand
    side is the SSH terminal that is running the Tornado HTTP server in Yocto Linux
    and displays the output for our Python code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing and sending HTTP requests](img/B05042_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can run the following HTTPie command in a computer or device to use the RESTful
    API to tell us how many LEDs are turned on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://192.168.1.107:8888/getcurrentnumber`. The request will match and run the
    `GetCurrentNumber.get` method. The following lines show the response from the
    HTTP server with the number that has been printed in LEDs, that is, the number
    of LEDs that have been turned on with the last API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look again at the list of request handlers that make up the web
    application, we will notice that the entry for `putnumberinleds` specifies a regular
    expression that accepts numbers from 0 to 9 as its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we run the following HTTPie command in a computer or device to use the RESTful
    API to make the board turn on twelve LEDs, the request won't match any regular
    expression in the list of request handlers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, Tornado will return a `404: Not found` error as a result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The same will happen if we run the following HTTPie command in a computer or
    device because `x` isn't a number between 0 and 9.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The following HTTPie command will turn on 8 LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://192.168.1.107:8888/putnumberinleds/8`. The request will match and run the
    `PutNumberInLedsHandler.put` method that receives `8` in its `number` parameter.
    The following lines show the response from the HTTP server with the number that
    has been printed in LEDs, that is, the number of LEDs that have been turned on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The number of LEDs that are turned on changed from 5 to 8, and therefore, we
    can run the following HTTPie command in a computer or device to use the RESTful
    API to tell us how many LEDs are turned on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the response from the HTTP server with the number
    that has been printed in LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We created a very simple RESTful API that allows us to turn on LEDs and check
    which is the number that is currently printed in LEDs. Of course, we should add
    authentication and overall security to the RESTful API in order to make it complete.
    Our RESTful API makes it possible for us to print numbers in LEDs with any application,
    mobile app or web application that can compose and send HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring pins with PWM capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to control the output voltage to make it possible to fade in and fade
    out three LEDs of three different colors: red, green and blue. The lower the output
    voltage, the lower the brightness level for the LEDs. The higher the output voltage,
    the higher the brightness level for the LEDs. Thus, as the output voltage is nearer
    to 0V, the brightness for the LEDs is lower and when the output voltage is nearer
    the IOREF voltage, that is, 5V in our actual configuration, the brightness is
    higher for the LEDs. Specifically, we want to be able to set 256 brightness levels
    for each LED, from 0 to 255\. In this case, we will use three LEDs but we will
    move to a single RGB LED capable of mixing the three colors in a single electronic
    component later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: When we worked with GPIO pins configured as digital outputs, we could set an
    output voltage of 0V (low value) or the IOREF voltage, that is, 5V in our actual
    configuration (high value). Thus, we could just turn off or turn on the LED with
    its maximum brightness level (without burning it).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we connect our red, green and blue LEDs to three GPIO pins and we configure
    them as digital outputs, we won''t be able to set 256 brightness levels. We have
    to connect the three LEDs to three of the digital I/O pins that we can use as
    **PWM** (short for **Pulse Width Modulation**) output pins. In [Chapter 1](ch01.html
    "Chapter 1. Understanding and Setting up the Base IoT Hardware"), *Understanding
    and Setting up the Base IoT Hardware*, when we learned about the I/O pins included
    in the Intel Galileo Gen 2 board, we learned that the pins labeled with a tilde
    symbol (~) as a prefix for the number can be used as PWM output pins. Thus, we
    can use the following pins to connect the three LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: Pin **~6** to connect the red LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin **~5** to connect the green LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin **~3** to connect the blue LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we finish the necessary wirings, we will write Python code to create
    another RESTful API that will allow us to set the brightness for each of the three
    LEDs. We need the following parts to work with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: One red ultrabright 5mm LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One green ultrabright 5mm LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One blue ultrabright 5mm LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three 270Ω resistors with 5% tolerance (red violet brown gold)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_04_02.fzz` and the following
    image is the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring pins with PWM capabilities](img/B05042_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we wanted the three LEDs to be close to each other. This way,
    the three LEDs can project their light to a black surface and we can see how the
    intersection of the three colors generates a color that will be similar to a color
    selected in a color picker we will use later.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows the schematic with the electronic components represented
    as symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring pins with PWM capabilities](img/B05042_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the previous schematic, three PWM capable GPIO pins labeled **D3
    PWM**, **D5 PWM** and **D6 PWM** in the board's symbol is connected to a **270Ω**
    resistor, wired to an LED's anode, and each LED's cathode is connected to ground.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to insert the components in the breadboard and make all the
    necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the
    onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen
    2 board before adding or removing any wire from the board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: Using PWM to generate analog values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pulse width modulation, known as PWM, is a technique that makes it possible
    to generate an analog result with digital means through the usage of a digital
    on-off pattern. The pins that provide PWM capabilities use a digital control to
    create a square wave and it can simulate voltages between the configured **IOREF**
    voltage (5V in the default board configuration) and 0V by controlling the amount
    of time that the signal spends in the ON status (**IOREF** voltage) and the time
    the signal spends in the OFF status (0V). The pulse width is the duration of the
    signal in the ON status (**IOREF** voltage), and therefore, pulse width modulation
    means changing the pulse width to get perceived analog values.
  prefs: []
  type: TYPE_NORMAL
- en: When you repeat the signal in the ON status and the signal in the OFF status
    hundreds of times per second with a LED connected to the PWM pin, we can generate
    the same result as if the signal is a steady voltage between 0V and the **IOREF**
    voltage to control the LED's brightness level.
  prefs: []
  type: TYPE_NORMAL
- en: We can write floating point values from 0 to 1 to the PWM enabled pins configured
    as analog output, that is, from 0% duty cycle (always signal in the OFF status)
    to 100% duty cycle (always signal in the ON status). We want to represent 256
    brightness values (from 0 to 255 inclusive), and therefore, the following graph
    shows the brightness values in the abscissa axis (*x*-axis) and the corresponding
    floating point values that have to be written to the pin in the ordinate axis
    (*y*-axis).
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PWM to generate analog values](img/B05042_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The equation for the previous graph is the following: `y = x / 255`, specifically
    `value = brightness / 255`. We can run the following code in our Python interpreter
    to see the output with all the values that will be written for each brightness
    level from 0 to 255 inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can multiply the floating point values by 5 to calculate the voltage value
    for each brightness level. As we are working with the default settings for the
    board, the **IOREF** jumper is set to 5V, and therefore, a 1.0 value in the output
    means 5V (`1.0 x 5 = 5`). A value of 0.5 in the output means 2.5V (`0.5 x 5 =
    2.5`). The following graph shows the brightness values in the abscissa axis (x-axis)
    and the corresponding voltage values in the output that will generate the corresponding
    brightness value in the LEDs in the ordinate axis (*y*-axis).
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PWM to generate analog values](img/B05042_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The equation for the previous graph is the following: `y = x / 255 * 5`, specifically
    `voltage = brightness / 255 * 5`. We can run the following code in our Python
    interpreter to see the output with all the voltages that will be generated for
    each brightness level from 0 to 255 inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We will create a new `AnalogLed` class to represent an LED connected to our
    board that can have a brightness level from 0 to 255 inclusive. The following
    lines show the code for the new `AnalogLed` class. The code file for the sample
    is `iot_python_chapter_04_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify the pin number to which the LED is connected when we create
    an instance of the `AnalogLed` class in the `pin` required argument, and a name
    for the LED in the `name` required argument. The constructor, that is, the `__init__`
    method, creates a new `mraa.Pwm` instance with the received `pin` as its `pin`
    argument, saves its reference in the `pwm` attribute and calls its `period_us`
    method to configure the PWM period in 700 microseconds (700 µs). Thus, the output
    duty cycle will determine the percentage of the 700 microsecond period during
    which the signal is in the ON status. For example, a 0.5 (50%) output duty cycle
    means that the signal will be ON during 350 microseconds of the 700 microseconds
    period (700 * 0.5 = 350).
  prefs: []
  type: TYPE_NORMAL
- en: Then, the the code calls the `pwm.enable` method with `True` as a parameter
    to set the enable status of the PWM pin and allow us to start setting the output
    duty-cycle percentage for the PWM pin with calls to the `pwm.write` method.
  prefs: []
  type: TYPE_NORMAL
- en: The next line creates a `brightness_value` attribute initialized with 0 that
    will allow us to easily retrieve the last brightness value set to the LED connected
    to the pin. Finally, the constructor calls the `set_brightness` method with 0
    as the value for the `value` argument to set the brightness level for the LED
    connected to the configured pin to 0.
  prefs: []
  type: TYPE_NORMAL
- en: The class defines a `set_brightness` method that receives a brightness level
    value in the `value` argument. The first lines of code make sure that we always
    set a brightness level between 0 and 255 (inclusive). In case the `value` argument
    has a value that isn't included in that range, the code assigns the lower-level
    (0) or upper-level value (255) to the `brightness_value` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code calculates the necessary output duty-cycle percentage for the
    PWM pin to represent the brightness level as a floating point value between `1.0f`
    (100%) and `0.0f` (0%). The code saves the value in the `led_value` variable and
    then calls the `self.pwm.write` method with this variable for the percentage argument
    to set the output duty-cycle for the pin configured as PWM output to `led_value`.
    The next line saves the valid brightness level to the `brightness_value` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code prints details about the LED name, the pin number and the
    brightness level that has been set. This way, the method translates a brightness
    level from 0 to 255 (inclusive) into the appropriate output duty-cycle value for
    the pin and writes the output to control the connected LED's brightness level.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can write code that uses the new `AnalogLed` class to create one instance
    for each of the three LEDs and easily control their brightness levels. The following
    lines show the code for the `BoardInteraction` class. The code file for the sample
    is `iot_python_chapter_04_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BoardInteraction` class just declares three class attributes: `red_led`,
    `green_led` and `blue_led`. The three class attributes save new instances of the
    previously created `AnalogLed` class and represent the red, green and blue LEDs
    connected to pins **~6**, **~5** and **~3**. Now, we will create other classes
    that define methods that work with these class attributes to access common `AnalogLed`
    instances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next lines show the code that adds the following classes: `VersionHandler`,
    `PutRedBrightnessHandler`, `PutGreenBrightnessHandler` and `PutBlueBrightnessHandler`.
    The code file for the sample is `iot_python_chapter_04_02.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The code declares the following four subclasses of `tornado.web.RequestHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VersionHandler`: Defines the parameter less `get` method that returns a response
    with the version number and the last build date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PutRedBrightnessHandler`: Defines the `put` method that requires a value argument
    that specifies the desired brightness level for the red LED. The method calls
    the `set_brightness` method for the `AnalogNumber` instance stored in the `BoardInteraction.red_led`
    class attribute with the desired brightness level specified in the `value` argument.
    Then, the code returns a response with the brightness level that has been translated
    to an output duty cycle percentage in the PWM pin to which the red LED is connected
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PutGreenBrightnessHandler`: Defines the `put` method to set the desired brightness
    level for the green LED. It works as the previously described `PutRedBrightnessHandler`
    method but instead of using the `BoardInteraction.red_led` class attribute, the
    code uses `BoardInteraction.green_led` class attribute to control the brightness
    level for the green LED.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PutBlueBrightnessHandler`: Defines the `put` method to set the desired brightness
    level for the blue LED. It works as the previously described `PutRedBrightnessHandler`
    method but instead of using the `BoardInteraction.red_led` class attribute, the
    code uses `BoardInteraction.blue_led` class attribute to control the brightness
    level for the blue LED.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next lines show the code that adds the following classes: `GetRedBrightnessHandler`,
    `GetGreenBrightnessHandler` and `GetBlueBrightnessHandler`. The code file for
    the sample is `iot_python_chapter_04_02.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The code declares the following three subclasses of `tornado.web.RequestHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetRedBrightnessHandler`: Defines the parameter less `get` method that returns
    a response with the value of the `BoardInteraction.red_led.brightness_value` attribute,
    that is, the brightness value set to the red LED'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetGREENBrightnessHandler`: Defines the parameter less `get` method that returns
    a response with the value of the `BoardInteraction.green_led.brightness_value`
    attribute, that is, the brightness value set to the green LED'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetBlueBrightnessHandler`: Defines the parameter less `get` method that returns
    a response with the value of the `BoardInteraction.blue_led.brightness_value`
    attribute, that is, the brightness value set to the blue LED'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lines use the previously declared subclasses of `tornado.web.RequestHandler`
    to make up the web application with Tornado that represents a new RESTful API
    and the new `__main__` method. The code file for the sample is `iot_python_chapter_04_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As happened in our previous example, the code creates an instance of the `tornado.web.Application`
    class named `application` with the list of request handlers that make up the web
    application, that is, the tuples of regular expressions and subclasses of `tornado.web.RequestHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows some HTTP requests that match the regular expressions
    defined in the preceding code. In this case, the HTTP requests use `192.168.1.107`
    because they are executed from a computer connected to our LAN. Don't forget to
    replace `192.168.1.107` with your board's IP address in the next requests.
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP verb and request URL | Tuple (`regexp`, `request_class`) that matches
    the request path | `RequestHandler` subclass and method that is called |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT http:// 192.168.1.107:8888/putredbrightness/30` | `(r"/putredbrightness/([0-9]+)",
    PutRedBrightnessHandler)` | `PutRedBrightnessHandler.put(30)` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT http:// 192.168.1.107:8888/putgreenbrightness/128` | `(r"/putgreenbrightness/([0-9]+)",
    PutGreenBrightnessHandler)` | `PutGreenBrightnessHandler.put(128)` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT http:// 192.168.1.107:8888/putbluebrightness/255` | `(r"/putbluebrightness/([0-9]+)",
    PutBlueBrightnessHandler)` | `PutGreenBrightnessHandler.put(255)` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET http:// 192.168.1.107:8888/getredbrightness` | `(r"/getredbrightness",
    GetRedBrightnessHandler)` | `GetRedBrightnessHandler.get()` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET http:// 192.168.1.107:8888/getgreenbrightness` | `(r"/getgreenbrightness",
    GetGreenBrightnessHandler)` | `GetGreenBrightnessHandler.get()` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET http:// 192.168.1.107:8888/getbluebrightness` | `(r"/getbluebrightness",
    GetBlueBrightnessHandler)` | `GetBlueBrightnessHandler.get()` |'
  prefs: []
  type: TYPE_TB
- en: The following line will start the HTTP server and our RESTful API that allows
    us to control the brightness level for red, green and blue LEDs in the Yocto Linux
    running on the board. Don't forget that you need to transfer the Python source
    code file to the Yocto Linux with an SFTP client, as explained in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After we start the HTTP server, we will see the following output and all the
    red, green and blue LEDs are going to be turned off.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Generating analog values via HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP server is running in Yocto Linux and waiting for our HTTP requests
    to control the LEDs on connected to the Intel Galileo Gen 2 board. Now, we will
    compose and send HTTP requests from other computer or devices connected to our
    LAN and we will control the brightness levels for the red, green and blue LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new terminal, command-line or the GUI tool that we want to use to compose
    and send HTTP requests from a computer or any device connected to the LAN. Don't
    forget to replace `192.168.1.107` with your board's IP address in the next requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following HTTPie command in a computer or device to use the RESTful
    API to make the board set the brightness level for the red LED to 30\. After you
    enter the command, you will notice the SSH terminal that displays the output for
    the Python code will display the following message: **Red LED connected to PWM
    Pin #6 set to brightness 30**. In addition, you will see the red LED turned on
    with a very low brightness level.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://192.168.1.107:8888/putredbrightness/30`. The request will match and run
    the `PutRedBrightnessHandler.put` method that receives `30` in its `value` parameter.
    The following lines show the response from the HTTP server with the brightness
    level that has been set for the red LED by taking advantage of PWM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can run the following HTTPie command in a computer or device to use the RESTful
    API to tell us the current brightness level for the red LED.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://192.168.1.107:8888/getredbrightness`. The request will match and run the
    `GetRedBrightnessHandler.get` method. The following lines show the response from
    the HTTP server with the brightness level that has been previously set for the
    red LED with the API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following HTTPie command in a computer or device to use the RESTful
    API to make the board set the brightness level for the green LED to 128\. After
    you enter the command, you will notice the SSH terminal that displays the output
    for the Python code will display the following message: **Green LED connected
    to PWM Pin #5 set to brightness 128**. In addition, you will see the green LED
    turned on with a very low brightness level.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://192.168.1.107:8888/putgreenbrightness/128`. The request will match and
    run the `PutGreenBrightnessHandler.put` method that receives `128` in its `value`
    parameter. The following lines show the response from the HTTP server with the
    brightness level that has been set for the green LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we run the following HTTPie command in a computer or device to use
    the RESTful API to make the board set the brightness level for the blue LED to
    `255`, that is, its highest brightness level. After you enter the command, you
    will notice the SSH terminal that displays the output for the Python code will
    display the following message: **Blue LED connected to PWM Pin #3 set to brightness
    255**. In addition, you will see the blue LED turned on with its highest brightness
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://192.168.1.107:8888/putbluebrightness/255`. The request will match and run
    the `PutBlueBrightnessHandler.put` method that receives 255 in its `value` parameter.
    The following lines show the response from the HTTP server with the brightness
    level that has been set for the blue LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can run the following two HTTPie commands to use the RESTful API to
    tell us the current brightness levels for the green and blue LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the two responses from the HTTP server with the brightness
    levels that had been set for the green and blue LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We created a very simple RESTful API that allows us to set the desired brightness
    for red, green and blue LEDs, and check their current brightness levels. Our RESTful
    API makes it possible for us to generate different colors with the intersections
    of the three color and their different brightness levels with any application,
    mobile app or web application that can compose and send HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the RESTful API for Web application requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to develop a simple web application that displays a color picker to
    allow the user to choose a color. Once the user picks a color, we can obtain the
    red, green and blue components from 0 to 255 inclusive. We want to set the brightness
    level for the red, green and blue LEDs on the board based on the red, green and
    blue values for the selected color. Based on this requirement, it is convenient
    to add a new `PUT` method to our RESTful API to allow us to change the brightness
    levels for the three LEDs in single API call.
  prefs: []
  type: TYPE_NORMAL
- en: The next lines show the code that adds a new `PutRGBBrightnessHandler` class.
    The code file for the sample is `iot_python_chapter_04_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The code declares a new subclass of `tornado.web.RequestHandler` named `PutRGBBrightnessHandler`.
    The class defines the `put` method that requires three arguments that specify
    the desired brightness for each of the three LEDs: red, green and blue. The method
    calls the `set_brightness` method for the `AnalogNumber` instances stored in the
    `BoardInteraction.red_led`, `BoardInteraction.green_led` and `BoardInteraction.blue_led`
    class attributes with the desired brightness levels specified in the arguments.
    Then, the code returns a response with the brightness levels that have been translated
    to output duty cycle percentages in the PWM pins to which the red, green and blue
    LEDs are connected to.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is necessary to add the highlighted lines to the code that creates an
    instance of the `tornado.web.Application` class named `application` with the list
    of request handlers that make up the web application, that is, the tuples of regular
    expressions and subclasses of `tornado.web.RequestHandler`. The code file for
    the sample is `iot_python_chapter_04_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The following line will start the HTTP server and our new version of the RESTful
    API that allows us to control the brightness level for red, green and blue LEDs
    with a single API call in the Yocto Linux running on the board. Don't forget that
    you need to transfer the Python source code file to the Yocto Linux with an SFTP
    client, as explained in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: After we start the HTTP server, we will see the following output and all the
    red, green and blue LEDs are going to be turned off.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new RESTful API we can compose the following HTTP verb and request
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The previous request path will match the previously added tuple (`regexp`, `request_class`)
    `(r"/putrgbbrightness/r([0-9]+)g([0-9]+)b([0-9]+)", PutRGBBrightnessHandler)`
    and Tornado will call the `PutRGBBrightnessHandler.put` method with the values
    for `red`, `green` and `blue`, specifically `PutRGBBrightnessHandler.put(30, 128,
    255)`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following HTTPie command in a computer or device to use the RESTful
    API to make the board set the brightness level for the three LEDs with the previously
    analyzed request path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After you enter the command, you will notice the SSH terminal that displays
    the output for the Python code will display the following three messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red LED connected to PWM Pin #6 set to brightness 30**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green LED connected to PWM Pin #5 set to brightness 128**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blue LED connected to PWM Pin #3 set to brightness 255**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, you will see the three LEDs turned on with their different brightness
    levels. The following lines show the response from the HTTP server with the brightness
    levels that have been set for the three LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Using PWM plus a RESTful API to set colors for an RGB LED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will use the same source code to make it possible to change the color
    of an RGB LED, specifically, a common cathode RGB LED. This electronic component
    provides a common cathode and three anodes, that is, an anode for each of the
    three colors: red, green and blue. We can use our code to pulse width modulate
    the three colors and make the LED produce the mixed colors. We don''t need to
    use a black surface to see the intersection of the three colors because the RGB
    LED mixes the three colors for us.'
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows a common cathode RGB LED with one of the most common
    configurations for the pins, where the common cathode is the second pin and the
    longest one.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PWM plus a RESTful API to set colors for an RGB LED](img/B05042_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following table shows the pin configuration for the previous RGB LED, from
    left to right. However, always make sure that you check the datasheet for your
    RGB LED to check the right pins for the common cathode and the anode for each
    color.
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin number | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Anode pin for red LED |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Common cathode pin |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Anode pin for green LED |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Anode pin for blue LED |'
  prefs: []
  type: TYPE_TB
- en: 'Based on the previous table, we will connect the three anode pins to three
    of the digital I/O pins that we can use as **PWM** (short for **Pulse Width Modulation**)
    output pins. We will use the same PWM output pins that we used in our previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: Pin **~6** to connect the anode pin for red LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin **~5** to connect the anode pin for green LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin **~3** to connect the anode pin for blue LED.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we finish the necessary wirings, we will use the same Python code to
    run our RESTful API and mix colors by changing the brightness levels for red,
    green and blue. We need the following parts to work with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: One common cathode 5mm RGB LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three 270Ω resistors with 5% tolerance (red violet brown gold)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_python_chapter_04_03.fzz` and the following
    image is the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PWM plus a RESTful API to set colors for an RGB LED](img/B05042_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PWM plus a RESTful API to set colors for an RGB LED](img/B05042_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the previous schematic, three PWM capable GPIO pins labeled **D3
    PWM**, **D5 PWM** and **D6 PWM** in the board's symbol is connected to a **270Ω**
    resistor, wired to an anode pin for each LED color, and the common cathode is
    connected to ground.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to insert the components in the breadboard and make all the
    necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the
    onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen
    2 board before adding or removing any wire from the board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: After the board boots Yocto Linux, we have to start the HTTP server with our
    latest version of the RESTful API that allows us to control the brightness level
    for red, green and blue LEDs with a single API call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Run the following HTTPie command in a computer or device to use the RESTful
    API to make the board set the brightness level for the colors included in the
    RGB LED.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After you enter the command, you will notice the RGB LED displays a yellow
    light because we set both red and green to its maximum brightness level while
    we turned off the blue component. The following lines show the response from the
    HTTP server with the brightness levels that have been set for the three colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the following HTTPie command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After you enter the command, you will notice the RGB LED displays a pink or
    light magenta light because we set green to its maximum brightness level and blue
    to half its maximum brightness level while we turned off the green component.
    The following lines show the response from the HTTP server with the brightness
    levels that have been set for the three colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following HTTPie command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After you enter the command, you will notice the RGB LED displays a cyan light
    because we set both green and blue to its maximum brightness level while we turned
    off the red component. The following lines show the response from the HTTP server
    with the brightness levels that have been set for the three colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We can generate 256 * 256 * 256 different colors, which is 16,777,216 colors
    (more than 16 million colors) for the light generated by the RGB LED. We just
    need to use our RESTful API and change the values for the red, green and blue
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling PWM with the wiring-x86 library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using the `mraa` library to work with PWM and change the
    brightness level for the different LEDs and colors within an RGB LED. However,
    in the first chapter, we also installed the `wiring-x86` library. We can change
    just a few lines of our object-oriented code to replace the `mraa` library with
    the `wiring-x86` one to change the brightness levels for the red, green and blue
    components.
  prefs: []
  type: TYPE_NORMAL
- en: There is an important difference between the `mraa` library and the `wiring-x86`
    library when working with PWM. The former works with floating point values from
    0.0f to 1.0f to set the output duty cycle percentage, but the latter works with
    values from 0 to 255 inclusive to set this value. Thus, when working with the
    `wiring-x86` library, we don't need to translate the desired brightness level
    to an output duty cycle percentage and we can use the brightness level value to
    specify the value for PWM. As a result, the code is simpler in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines shows the code for a `Board` class followed by the new version
    of the `AnalogLed` class that works with the `wiring-x86` library instead of using
    `mraa`. The code file for the sample is `iot_python_chapter_04_04.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We just needed to change a few lines from the previous code of the `AnalogLed`
    class. The new lines that interact with the `wiring-x86` library are highlighted
    in the previous code. The constructor, that is, the `__init__` method, saves a
    reference to the `Board.gpio` class attribute in `self.gpio` and calls its `pinMode`
    method with the received `pin` as its `pin` argument and `self.gpio.PWM` as its
    `mode` argument. This way, we configure the pin to be an output PWM pin. All the
    `Led` instances will save a reference to the same `Board.gpio` class attribute
    that created an instance of the `GPIO` class, specifically, the `wiringx86.GPIOGalileoGen2`
    class with its `debug` argument set to `False` to avoid unnecessary debug information
    for the low-level communications.
  prefs: []
  type: TYPE_NORMAL
- en: The `set_brightness` method calls the `analogWrite` method for the GPIO instance
    (`self.gpio`) to set the output duty-cycle for the pin configured as PWM output
    to `brightness_value`. The `self.pin` attribute specifies the `pin` value for
    the `analogWrite` method call. Because `brightness_value` is already a value between
    0 and 255 (inclusive), it is valid value for the `analogWrite` method.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code for our RESTful API remains the same one that we have used
    for the previous example. There is no need to make changes to this class because
    it will automatically work with the new `AnalogLed` class and there were no changes
    in the arguments for its constructor or its `set_brightness` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the HTTP server and our new version of the RESTful
    API that works with the `wiring-x86` library. Don't forget that you need to transfer
    the Python source code file to the Yocto Linux with an SFTP client, as explained
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can make the same HTTP requests we made in our previous example to check
    that we can achieve exactly the same results with the `wiring-x86` library.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PWM stands for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pin Work Mode.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pulse Weight Modulation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pulse Width Modulation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Intel Galileo Gen 2 board, the pins labeled with the following symbol
    as a prefix for the number can be used as PWM output pins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hash sign (**#**).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Dollar sign (**$**).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tilde symbol (**~**).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A 100% duty cycle (always signal in the ON status) in a PWM pin will generate
    a steady voltage equal to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 0 V.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The voltage specified in the position in which the IOREF jumper is located.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 6 V.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A 0% duty cycle (always signal in the OFF status) in a PWM pin will generate
    a steady voltage equal to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 0 V.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The voltage specified in the position in which the IOREF jumper is located.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 6 V.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A 50% duty cycle in a PWM pin with a LED connected to it will generate the
    same result as a steady voltage equal to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 0 V.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Half the voltage specified in the position in which the IOREF jumper is located.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 6 V * 0.5 = 3 V.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked with Tornado web server, Python, the HTTPie command-line
    HTTP client, and the `mraa` and `wiring-x86` libraries. As in the previous chapters,
    we took advantage of Python's object-oriented features and we generated many versions
    of RESTful APIs that allowed us to interact with the board in computers and devices
    connected to the LAN.
  prefs: []
  type: TYPE_NORMAL
- en: We could compose and send HTTP requests that printed number in LEDs, changed
    the brightness levels for three LEDs and generated millions of colors with an
    RGB LED.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we created our first RESTful APIs that made is possible for computers
    and devices to interact with our IoT device, we can take advantage of additional
    features that allow us to read digital inputs and analog values, which is the
    topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
