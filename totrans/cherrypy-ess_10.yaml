- en: Chapter 10. Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 部署
- en: Our final chapter will explain in the first section how to configure CherryPy-based
    applications, and then review different methods to deploy such an application
    through the use of Apache and lighttpd. Finally, we will review how to make your
    CherryPy-based application SSL enabled via the built-in CherryPy HTTP server,
    as well as by using Apache and lighttpd capabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一章将在第一部分解释如何配置基于CherryPy的应用程序，然后回顾通过使用Apache和lighttpd部署此类应用程序的不同方法。最后，我们将回顾如何通过内置的CherryPy
    HTTP服务器以及使用Apache和lighttpd功能来使基于CherryPy的应用程序启用SSL。
- en: Configuration
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: While developing an application, you always need to parameterize it, so that
    it can be tuned as per the requirements of the hosting environment. For instance,
    the type of database used, PostgreSQL or MySQL, the directory in which the application
    resides, administrator contacts, etc.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，您始终需要对其进行参数化，以便根据宿主环境的需要对其进行调整。例如，使用的数据库类型，PostgreSQL或MySQL，应用程序所在的目录，管理员联系方式等。
- en: 'There are different levels of configuration settings required in a web application
    like our photoblog:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在像我们的照片博客这样的Web应用程序中，需要不同级别的配置设置：
- en: 'Web server: Settings linked to the HTTP server'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器：与HTTP服务器相关的设置
- en: 'Engine: Settings associated with the engine hosting the application'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎：与应用程序宿主引擎相关的设置
- en: 'Application: Settings our application will use'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序：我们的应用程序将使用的设置
- en: CherryPy—Web and Engine Configuration System
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CherryPy——Web和引擎配置系统
- en: Since our application is using CherryPy, we will use the CherryPy configuration
    capabilities for the web server and the engine. CherryPy uses a configuration
    based on the syntax of the INI format defined by Microsoft.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序正在使用CherryPy，我们将使用CherryPy的配置能力来配置Web服务器和引擎。CherryPy使用的是基于微软定义的INI格式语法的配置。
- en: 'The format of a CherryPy configuration file is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CherryPy配置文件的格式如下：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The main difference between the original INI format and the format used by
    CherryPy is the fact that values in the latter case are Python data types. For
    example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 原始INI格式与CherryPy使用的格式之间的主要区别在于，后者的值是Python数据类型。例如：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the exception of `[global]`, the sections of configuration files match
    a requested URI path segment, as illustrated in the following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`[global]`之外，配置文件的各个部分与请求的URI路径段相匹配，如下例所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When CherryPy tries to match the `/css/style.css` request, it will inspect the
    configuration settings for a matching section. If found, it will use the settings
    defined for that section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当CherryPy尝试匹配`/css/style.css`请求时，它将检查配置设置以查找匹配的部分。如果找到，它将使用该部分定义的设置。
- en: 'Before we explain how CherryPy differentiates between the web server and the
    engine settings, let''s see how the configuration settings can be defined in a
    Python dictionary instead. The following code snippet demonstrates the same settings:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释CherryPy如何区分Web服务器和引擎设置之前，让我们看看如何在Python字典中定义配置设置。以下代码片段展示了相同的设置：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Functionally, both methods will provide the same capabilities. Using a Python
    dictionary offers the advantage of residing within the code itself, and thus allows
    for more complex data types to be provided as values. Eventually, it is usually
    a matter of taste between the two options.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，这两种方法将提供相同的性能。使用Python字典的优点是它位于代码本身中，因此可以提供更复杂的数据类型作为值。最终，这通常取决于个人喜好。
- en: 'Now that we have presented how to declare configuration settings, let''s see
    how to pass them to their components. CherryPy API is quite straight forward in
    that respect:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何声明配置设置，让我们看看如何将它们传递给相应的组件。在这一点上，CherryPy API非常直接：
- en: '`cherrypy.config.update` (file or dictionary) is used to configure the CherryPy
    web server.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cherrypy.config.update`（文件或字典）用于配置CherryPy Web服务器。'
- en: '`cherrypy.tree.mount` (app, config file, or dictionary) is used to provide
    the settings for the mounted application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cherrypy.tree.mount`（应用程序、配置文件或字典）用于提供挂载应用程序的设置。'
- en: The `_cp_config` attribute is bound to the page handlers, or to the class containing
    the page handlers and calls a controller defined as a dictionary (in which case,
    the settings are propagated by CherryPy to all the page handlers of that controller).
    It is used to pass the settings directly to where they will be needed.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_cp_config`属性绑定到页面处理程序，或者绑定到包含页面处理程序的类，并调用定义为字典的控制器（在这种情况下，设置通过CherryPy传播到该控制器的所有页面处理程序）。它用于直接将设置传递到需要的地方。'
- en: 'We will review an example to understand how to use that API in our context:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾一个示例，以了解如何在我们的环境中使用该API：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see what we have done in our example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在示例中做了什么：
- en: 1\. First we declare an application with a page handler named `echo`. The purpose
    of this handler is to return the request body and repeat it as many times as defined
    by the configuration setting key `repeat`. To do so, we use the `_cp_config` attribute
    bound to the page handler. This value can also be passed from the main configuration
    dictionary. In that case, the value coming from the main dictionary takes precedence
    over the `_cp_config` attribute.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 首先，我们声明一个名为`echo`的页面处理程序的应用程序。这个处理程序的目的就是返回请求体，并按照配置设置键`repeat`定义的次数重复它。为此，我们使用绑定到页面处理程序上的`_cp_config`属性。这个值也可以从主配置字典中传递。在这种情况下，来自主字典的值将优先于`_cp_config`属性。
- en: '2\. Next we declare the web server settings in a dictionary and then we call
    `cherrypy.config.update()` with that dictionary. Note that the use of the key,
    named global, is not compulsory when using a dictionary. CherryPy does interpret
    it exactly the same way; so the semantic equivalent of the previous example can
    be written as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 接下来，我们在字典中声明Web服务器设置，然后使用该字典调用`cherrypy.config.update()`。请注意，当使用字典时，使用名为global的键不是强制性的。CherryPy确实以完全相同的方式解释它；因此，前一个示例的语义等效可以写成以下形式：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 3\. Finally we mount two applications on two distinct prefixes with two different
    configuration settings. It is important to notice that the key we use is the path
    to the page handler relatively to where the application is mounted. That is why
    we use `/echo`, and neither `/app0/echo` nor `/app1/echo`. This also means that
    configuration settings do not leak across mounted applications. CherryPy makes
    sure that each application receives only the settings it was declared with.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 最后，我们在两个不同的前缀上挂载两个不同的应用程序，并使用两种不同的配置设置。重要的是要注意，我们使用的键是页面处理程序相对于应用程序挂载位置的路径。这就是为什么我们使用`/echo`，而不是`/app0/echo`或`/app1/echo`。这也意味着配置设置不会泄漏到挂载的应用程序之间。CherryPy确保每个应用程序只接收它声明的设置。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is a common mistake to pass configuration settings associated with the application
    to the `cherrypy.config.update()` method. This will not propagate the settings
    to the mounted application. You must use the `config` attribute of `cherrypy.tree.mount()`
    to get the expected behavior.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将与应用程序相关的配置设置传递给`cherrypy.config.update()`方法是一个常见的错误。这不会将设置传播到挂载的应用程序。您必须使用`cherrypy.tree.mount()`的`config`属性来获得预期的行为。
- en: Photoblog Application Configuration System
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 照片博客应用程序配置系统
- en: Configuration settings of an application will not usually be passed through
    the CherryPy configuration system, which is at a lower level. An application would
    usually define entities from their domain level, store those values in a back-end
    storage along with the rest of its data, and ultimately provide a front-end interface
    to allow the administrator or a user to modify them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的配置设置通常不会通过位于较低级别的CherryPy配置系统传递。应用程序通常会从它们的领域级别定义实体，将这些值存储在后端存储中，与它们的其他数据一起，并最终提供一个前端界面，允许管理员或用户修改它们。
- en: The photoblog application will not go that far but will keep a fairly simple
    approach to providing configuration settings by using a pure INI file. We make
    this choice because in the photoblog application case the configuration settings
    will be simple, defined, and editable by the administrator of the application.
    We will therefore avoid the burden of developing a more complex solution than
    an INI file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 照片博客应用程序不会走那么远，但会通过使用纯INI文件来保持提供配置设置的相当简单的方法。我们做出这个选择是因为在照片博客应用程序的情况下，配置设置将是简单、定义明确的，并且可以被应用程序管理员编辑。因此，我们将避免开发比INI文件更复杂的解决方案。
- en: 'However, in order to simplify access to those settings, we will define a specific
    class that will turn the INI sections, keys, and values into a Python object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了简化对这些设置的访问，我们将定义一个特定的类，该类将INI部分、键和值转换为Python对象：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This class will simply go through the INI file and add attributes to the instance
    of the `Config` class on the fly. For instance, imagine you have the following
    INI file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此类将简单地遍历 INI 文件，并在运行时向 `Config` 类的实例添加属性。例如，假设您有以下 INI 文件：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the above class, we can make the following modifications:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述类，我们可以进行以下修改：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we have now modified the INI file into a tree of attributes
    bound to the instance of the `Config` class. The photoblog application will have
    one global instance of that class that will therefore be accessible from everywhere
    in the application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在已将 INI 文件修改为绑定到 `Config` 类实例的属性树。Photoblog 应用程序将有一个全局的此类实例，因此可以从应用程序的任何地方访问它。
- en: In this section, we have briefly reviewed the ways to parameterize a CherryPy
    application using its built-in configuration system. We have also introduced a
    simple configuration system using an INI file format allowing application settings.
    This approach hence provides an easy way to mock up the passing of parameters,
    before moving towards a system-based database, which can be more demanding.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要回顾了使用其内置配置系统参数化 CherryPy 应用程序的方法。我们还介绍了一个使用 INI 文件格式的简单配置系统，允许应用程序设置。这种方法因此提供了一种在转向基于系统的数据库之前，模拟传递参数的简单方法，该数据库可能要求更高。
- en: Deployment
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: Deploying a CherryPy-based application can be as easy as dropping the application
    in an environment, where all the required packages (CherryPy, Kid, simplejson,
    etc.) are available from the Python system path. However, in a shared web-hosted
    environment, it is quite likely that the CherryPy web server will reside behind
    a front-end server such as Apache or lighttpd, allowing the host provider to perform
    some filtering operations if needed, or for instance let that front end serve
    the static files in a more efficient fashion than CherryPy.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 部署基于 CherryPy 的应用程序可以像将应用程序放入一个环境中一样简单，其中所有必需的包（CherryPy、Kid、simplejson 等）都可通过
    Python 系统路径获取。然而，在共享的托管环境中，CherryPy 网络服务器很可能位于前端服务器（如 Apache 或 lighttpd）之后，这样主机提供商可以在需要时执行一些过滤操作，或者例如让前端以比
    CherryPy 更高效的方式提供静态文件。
- en: This section will present a few solutions to run a CherryPy application behind
    the Apache and lighttpd web servers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍一些在 Apache 和 lighttpd 网络服务器后面运行 CherryPy 应用程序的方法。
- en: 'Before explaining how to use CherryPy behind Apache or lighttpd, let''s define
    a simple application that we will use throughout the example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释如何在 Apache 或 lighttpd 后使用 CherryPy 之前，让我们定义一个简单的应用程序，我们将在整个示例中使用它：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As discussed earlier, there are several ways of deploying CherryPy-based applications.
    Now, we will discuss the different approaches to deployment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有几种方法可以部署基于 CherryPy 的应用程序。现在，我们将讨论不同的部署方法。
- en: Apache with mod_rewrite Module
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache 与 mod_rewrite 模块
- en: The first solution you can review when running behind the Apache web server
    is to use the `mod_rewrite` module. This module allows you to define a set of
    rules that the module will analyze to transform incoming HTTP requests and re-dispatch
    them towards the back-end server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Apache 网络服务器后面运行时，您可以审查的第一个解决方案是使用 `mod_rewrite` 模块。此模块允许您定义一组规则，该模块将分析这些规则以转换传入的
    HTTP 请求并将它们重新调度到后端服务器。
- en: 'In our example, we will make the following assumptions, which are in fact the
    requirements:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将做出以下假设，这些假设实际上是要求：
- en: You run Apache 2.2.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您运行 Apache 2.2。
- en: You have access to the Apache configuration that can usually be found in the
    file named `httpd.conf`. You can also stop and restart the apache process. These
    requirements imply either that you have administrator rights on the machine or
    that you have a local installation of Apache to play with.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以访问 Apache 配置，通常可以在名为 `httpd.conf` 的文件中找到。您还可以停止和重新启动 Apache 进程。这些要求意味着您要么有机器的管理员权限，要么您有一个用于实验的本地
    Apache 安装。
- en: You will use the `VirtualHost` directive that allows encapsulating directives
    targeting only one particular host. This allows distinct hosts to be handled by
    one single instance of Apache.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将使用 `VirtualHost` 指令，该指令允许封装仅针对特定主机的指令。这允许不同的主机由 Apache 的单个实例处理。
- en: 'We will also assume that you have [myapp.com](http://myapp.com) resolvable
    locally. To do so:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还假设您本地可以解析 [myapp.com](http://myapp.com)。为此：
- en: 'Under Linux, add the following line to the /etc/hosts file:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Linux 下，将以下行添加到 /etc/hosts 文件中：
- en: '`127.0.0.1 myapp.com myapp www.myapp.com`'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`127.0.0.1 myapp.com myapp www.myapp.com`'
- en: Your operating system should now resolve requests to the `myapp.com` host to
    your local environment.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的操作系统现在应该将 `myapp.com` 主机的请求解析到您的本地环境中。
- en: 'Let''s now explain how we must configure Apache:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释如何配置 Apache：
- en: '1\. Load the required Apache modules, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 加载所需的 Apache 模块，如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that you may need to provide the full path to the module itself in some
    environments.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，在某些环境中，您可能需要提供模块本身的完整路径。
- en: '2\. Next we declare the `VirtualHost`, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 接下来我们声明 `VirtualHost`，如下所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 3\. The next step is to stop and restart your Apache process so that these modifications
    are taken into account.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 下一步是停止并重新启动您的 Apache 进程，以便考虑这些修改。
- en: 4\. Then start your CherryPy application server.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 然后启动您的 CherryPy 应用程序服务器。
- en: The `mod_rewrite` module documentation explains in detail how to build rewriting
    rules. In the previous example, we defined the most generic one by mapping the
    request URI path to a new hostname.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod_rewrite` 模块文档详细说明了如何构建重写规则。在先前的示例中，我们通过将请求 URI 路径映射到新的主机名定义了最通用的规则。'
- en: 'When navigating to the URL [http://myapp.com](http://myapp.com), you should
    now see the following message:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当导航到 URL [http://myapp.com](http://myapp.com) 时，您现在应该看到以下消息：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we know how to map a host to our CherryPy application via Apache,
    we might want to retrieve the actual hostname and remote IP address instead of
    the local ones. The former is needed when generating links like:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何通过 Apache 将主机映射到我们的 CherryPy 应用程序，我们可能想要获取实际的主机名和远程 IP 地址而不是本地地址。在生成如下链接时需要前者：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are two options to achieve this, as they are independent from each other:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以实现这一点，因为它们是相互独立的：
- en: 1\. Use the `mod_proxy` module of Apache to forward the host.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 使用 Apache 的 `mod_proxy` 模块转发主机。
- en: 'First you need to load the module like this (consult your documentation):'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，您需要以这种方式加载模块（请参阅您的文档）：
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Add the following directive to `VirtualHost:`
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下指令添加到 `VirtualHost:`
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Restart Apache.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动 Apache。
- en: '2\. Use the CherryPy proxy tool as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 使用 CherryPy 代理工具，如下所示：
- en: 'Add the following entry to your global configuration:'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下条目添加到您的全局配置中：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Restart your CherryPy application.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动您的 CherryPy 应用程序。
- en: 'In both cases, you will now see the following message in your browser:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，您现在将在浏览器中看到以下消息：
- en: '**Hello there http://myapp.com from IP: 127.0.0.1**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**你好，来自 IP: 127.0.0.1 的 http://myapp.com**'
- en: The IP address stays the same because the test is being done from the same machine
    where the server is being hosted, on the local interface.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址保持不变，因为测试是在托管服务器的同一台机器上进行的，在本地接口上。
- en: Let's now explain how the previous recipe works. In the first case, by using
    the `ProxyPreserveHost` directive, we tell Apache to keep the `HTTP header host`
    field as it is and not to overwrite it with the local IP address. This means that
    CherryPy will receive the original value of the Host header.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释前面的配方是如何工作的。在第一种情况下，通过使用 `ProxyPreserveHost` 指令，我们告诉 Apache 保持 `HTTP
    header host` 字段不变，而不是用本地 IP 地址覆盖它。这意味着 CherryPy 将接收到 Host 头部的原始值。
- en: In the second case, we tell CherryPy to look for specific headers set by Apache
    when doing proxy with the original hostnames. The default header looked up by
    CherryPy is `X-Forwarded-Host.`
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们告诉 CherryPy 在使用原始主机名进行代理时查找 Apache 设置的特定头信息。CherryPy 默认查找的头信息是 `X-Forwarded-Host。`
- en: Lighttpd with mod_proxy Module
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有 mod_proxy 模块的 Lighttpd
- en: 'Lighttpd is another popular and very efficient HTTP server. The previous section
    can be translated to lighttpd in a similar fashion using `mod_proxy`. Here is
    an example on how you can configure lighttpd to proxy incoming requests to a CherryPy
    server:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Lighttpd 是另一个流行且非常高效的 HTTP 服务器。前一个部分可以使用 `mod_proxy` 以类似的方式翻译成 lighttpd。以下是一个配置
    lighttpd 以代理到 CherryPy 服务器的示例：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add this to the `lighttd.conf` file and restart the server. When browsing to
    [http://myapp.com](http://myapp.com), you will see the following message:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到 `lighttd.conf` 文件中，并重新启动服务器。当浏览到 [http://myapp.com](http://myapp.com)
    时，您将看到以下消息：
- en: '**Hello there http://myapp.com from IP: 127.0.0.1**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**你好，来自 IP: 127.0.0.1 的 http://myapp.com**'
- en: Apache with mod_python Module
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有 mod_python 模块的 Apache
- en: In the year 2000, Gregory Trubetskoy released the first version of `mod_python`.
    It is a module for Apache allowing the Python interpreter to be embedded within
    the Apache server providing a bridge between the Apache web server and Python
    applications. One of the strengths of `mod_python` is that unlike CGI where each
    request requires a Python process to be launched `mod_python` does not have any
    such requirement. Therefore, it gives the opportunity to the developer to benefit
    from the persistence of the Python process started by Apache when running the
    module (keeping a pool of database connections for instance).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2000 年，Gregory Trubetskoy 发布了 `mod_python` 的第一个版本。这是一个 Apache 的模块，允许 Python
    解释器嵌入到 Apache 服务器中，为 Apache 网络服务器和 Python 应用程序之间提供桥梁。`mod_python` 的一个优点是，与需要为每个请求启动
    Python 进程的 CGI 不同，`mod_python` 没有这样的要求。因此，它为开发者提供了利用 Apache 运行模块时启动的 Python 进程的持久性（例如保持数据库连接池）的机会。
- en: 'Before seeing how to configure Apache and `mod_python`, let''s review what
    are the requirements:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何配置 Apache 和 `mod_python` 之前，让我们回顾一下需要满足的要求：
- en: Apache 2.2
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache 2.2
- en: '`mod_python` 3.1.x or superior'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod_python` 3.1.x 或更高版本'
- en: We will assume that `mod_python` is properly installed in your environment.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设 `mod_python` 已正确安装在你的环境中。
- en: 'Now let''s explain how to configure `mod_python` to run a CherryPy-based application:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解释如何配置 `mod_python` 以运行基于 CherryPy 的应用程序：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will take you through the process sequentially:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按顺序带你完成这个过程：
- en: 1\. First we load the `mod_python` module.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 首先我们加载 `mod_python` 模块。
- en: 2\. We define a location directive specifying what Apache should do to the request
    starting with "/".
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 我们定义一个位置指令，指定 Apache 应对以 "/" 开头的请求执行的操作。
- en: '3\. Then we define several `mod_python` directives:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 然后我们定义几个 `mod_python` 指令：
- en: '`PythonPath` extends the system path and makes sure that our application modules
    will be found. For instance, here the `my_app.py` module resides in `/home/sylvain/app`.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PythonPath` 扩展了系统路径，并确保我们的应用程序模块可以被找到。例如，这里 `my_app.py` 模块位于 `/home/sylvain/app`。'
- en: '`SetHandler` indicates that all requests starting with the path provided in
    the location directive will be handled by `mod_python`.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetHandler` 指示所有以位置指令中提供的路径开头的请求将由 `mod_python` 处理。'
- en: '`PythonHandler` sets the generic handler that will be in charge of generating
    the output to return to the user agent. We use the built-in `mod_python` handler
    provided by CherryPy.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PythonHandler` 设置了通用的处理器，它将负责生成输出返回给用户代理。我们使用 CherryPy 提供的内置 `mod_python`
    处理器。'
- en: '`PythonOption` passes options to the generic handler. Here the option will
    be named `cherrypy.setup` and we bind it to the function `setup_app` that our
    application provides. We assume the application is saved in a Python module named
    `my_app.py`. The `setup_app` method must be the one mounting the application.'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PythonOption` 将选项传递给通用处理器。这里选项将被命名为 `cherrypy.setup`，并将其绑定到我们的应用程序提供的 `setup_app`
    函数。我们假设应用程序保存在一个名为 `my_app.py` 的 Python 模块中。`setup_app` 方法必须是挂载应用程序的那个方法。'
- en: '`PythonDebug` is enabled.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PythonDebug` 已启用。'
- en: '4\. Finally, we modify the application as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 最后，我们按照以下方式修改应用程序：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The difference is that we start the CherryPy engine in a non-blocking mode so
    that the Python process started via mod_python does not hang.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同之处在于我们以非阻塞模式启动 CherryPy 引擎，这样通过 mod_python 启动的 Python 进程就不会挂起。
- en: 'Now you can stop and restart the Apache process and navigate to the [http://myapp.com](http://myapp.com)
    URL and you should see the following content:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以停止并重新启动 Apache 进程，并导航到 [http://myapp.com](http://myapp.com) URL，你应该看到以下内容：
- en: '**Hello there http://myapp.com from IP: 127.0.0.1**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自 IP: 127.0.0.1 的 http://myapp.com，你好**！'
- en: mod_python with WSGI Application
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mod_python 与 WSGI 应用程序
- en: In the previous approach, we used the built-in `mod_python` handler that works
    fine on the applications usually hosted by CherryPy. If your application respects
    the WSGI interface, you may want to use the `ModPythonGateway` handler ([http://projects.amor.org/misc/wiki/ModPythonGateway](http://projects.amor.org/misc/wiki/ModPythonGateway))
    developed by Robert Brewer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的方法中，我们使用了内置的 `mod_python` 处理器，它在通常由 CherryPy 托管的程序上运行良好。如果你的应用程序遵循 WSGI
    接口，你可能想使用 Robert Brewer 开发的 `ModPythonGateway` 处理器 ([http://projects.amor.org/misc/wiki/ModPythonGateway](http://projects.amor.org/misc/wiki/ModPythonGateway))。
- en: 'First let''s see the CherryPy application in the `my_app.py` module:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `my_app.py` 模块中的 CherryPy 应用程序：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s review how to configure Apache to use the `ModPythonGateway` handler:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾如何配置 Apache 以使用 `ModPythonGateway` 处理器：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Thanks to the `ModPythonGateway` handler, you can use the richness of WSGI-based
    middlewares within the power of the Apache server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`ModPythonGateway`处理程序，你可以在Apache服务器的强大功能中使用基于WSGI的中间件的丰富性。
- en: SSL
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSL
- en: '**SSL** (**Secure Sockets Layer**) can be supported in CherryPy-based applications
    natively by CherryPy. To enable SSL support, you must meet the following requirements:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSL**（**安全套接字层**）可以通过CherryPy原生支持CherryPy应用程序。要启用SSL支持，你必须满足以下要求：'
- en: Have the `PyOpenSSL` package installed in your environment
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的环境中安装`PyOpenSSL`包
- en: Have an SSL certificate and private key on the server
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上拥有SSL证书和私钥
- en: In the rest of this chapter, we will assume that you have installed `PyOpenSSL`
    properly. Let us explain how to generate a pair of private key and certificate.
    To achieve this, we will use OpenSSL, a common open-source implementation of the
    SSL specification.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将假设你已经正确安装了`PyOpenSSL`。让我们解释如何生成一对私钥和证书。为了实现这一点，我们将使用OpenSSL，它是SSL规范的常见开源实现。
- en: Creating a Certificate and a Private Key
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建证书和私钥
- en: 'Let''s deal with the certificate and the private key:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理证书和私钥：
- en: '1\. First we need a private key:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 首先，我们需要一个私钥：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '2\. This key is not protected by a passphrase and therefore has a fairly weak
    protection. If you prefer providing a passphrase, you should issue a command like
    this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 此密钥没有密码短语保护，因此保护相当弱。如果你更喜欢提供密码短语，你应该发出如下命令：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The program will require a passphrase. If your version of OpenSSL allows you
    to provide an empty string, do so. Otherwise, enter a default passphrase and then
    remove it from the generated key as follows:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序将需要密码短语。如果你的OpenSSL版本允许你提供一个空字符串，请这样做。否则，输入默认密码短语，然后按照以下方式将其从生成的密钥中删除：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '3\. Now we create a certificate as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 现在，我们按照以下方式创建证书：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '4\. This process will request you to input some details. The previous step
    has generated a certificate but it is not yet signed by the private key. To do
    so, you must issue the following command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 此过程将要求你输入一些详细信息。上一步已生成证书，但它尚未由私钥签名。为此，你必须发出以下命令：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The newly signed certificate will be valid for 60 days.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 新签发的证书将有效期为60天。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, as the certificate is not signed by a recognized authority such as
    VeriSign, your browser will display a pop up when accessing the application, so
    that the user can accept or reject the certificate.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于证书未由VeriSign等认可的机构签名，当访问应用程序时，你的浏览器将显示一个弹出窗口，以便用户可以接受或拒绝证书。
- en: Now, we can have a look at the different approaches for creating the certificate
    and the key.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看创建证书和密钥的不同方法。
- en: Using the CherryPy SSL Support
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CherryPy SSL支持
- en: 'Let''s see how we can do it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何做到这一点：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The key is to provide the `server.ssl_certificate` and `server.ssl_private_key`
    values to the global CherryPy configuration. The next step is to start the server;
    if everything went well, you should see the following message on your screen:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是向全局CherryPy配置提供`server.ssl_certificate`和`server.ssl_private_key`值。下一步是启动服务器；如果一切顺利，你应该会在屏幕上看到以下消息：
- en: '**HTTP Serving HTTPS on https://localhost:8443/**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**在https://localhost:8443/**上通过HTTP服务HTTPS'
- en: 'By navigating to the application URL, you should see a message such as:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到应用程序URL，你应该会看到一个类似的消息：
- en: '![Using the CherryPy SSL Support](img/1848_10_01.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![使用CherryPy SSL支持](img/1848_10_01.jpg)'
- en: If you accept the certificate, you will be able to continue using the web application
    via HTTPS.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你接受证书，你将能够通过HTTPS继续使用Web应用程序。
- en: 'One caveat of the previous solution is that now your application cannot be
    reached via non-secured HTTP. Luckily CherryPy provides a fairly easy way to work
    around this problem by simply starting two HTTP servers at once. You can see how
    it is done:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前解决方案的一个缺点是现在你的应用程序不能通过非安全HTTP访问。幸运的是，CherryPy提供了一个相当简单的方法来解决这个问题，只需同时启动两个HTTP服务器即可。你可以看到它是如何完成的：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Upon starting the application, you should now see the following lines on your
    screen:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动应用程序后，你现在应该在屏幕上看到以下几行：
- en: '**HTTP Serving HTTPS on https://localhost:8443/**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**在https://localhost:8443/**上通过HTTP服务HTTPS'
- en: '**HTTP Serving HTTP on http://localhost:8080/**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**在http://localhost:8080/**上通过HTTP服务HTTP'
- en: Your application will now be reachable via HTTP and HTTPS.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序现在将通过HTTP和HTTPS可访问。
- en: Using the lighttpd SSL Support
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用lighttpd SSL支持
- en: 'Setting SSL support for lighttpd is as simple as adding the following to the
    global configuration of lighttpd:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在lighttpd中设置SSL支持就像在lighttpd的全局配置中添加以下内容一样简单：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `server.pem` file is the concatenation of the `server.key` and `server.crt`
    files that we have created before. For instance, under a UNIX System we issue
    the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.pem`文件是我们之前创建的`server.key`和`server.crt`文件的连接。例如，在UNIX系统下，我们执行以下命令：'
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By using those two lines and the proxy method, we have described in the previous
    section how to support SSL for the CherryPy application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前面章节中描述的这两行和代理方法，我们已经说明了如何为CherryPy应用程序提供SSL支持。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note, however, that the path between lighttpd and CherryPy will be HTTP not
    secured. SSL support will stop at the lighttpd level.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，从lighttpd到CherryPy的路径将是HTTP未加密的。SSL支持将在lighttpd级别停止。
- en: Using the Apache mod_ssl Support
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Apache mod_ssl支持
- en: This approach consists of using the `mod_ssl` module of Apache based on OpenSSL
    to handle the SSL exchange before forwarding the request to the CherryPy server,
    as we did with lighttpd.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法包括使用基于OpenSSL的Apache `mod_ssl`模块来处理在将请求转发到CherryPy服务器之前的SSL交换，就像我们在lighttpd中做的那样。
- en: 'To do so, you need to modify your Apache configuration as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，你需要按照以下方式修改你的Apache配置：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first line loads the `mod_ssl` module. The second line requests Apache to
    listen for incoming socket connections on a given IP address on port 443 (which
    requires administrator rights).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行加载了`mod_ssl`模块。第二行请求Apache在指定的IP地址上的443端口（需要管理员权限）监听传入的套接字连接。
- en: 'Then, we modify `VirtualHost`, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按照以下方式修改`VirtualHost`：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once you have restarted the Apache process, you should be able to navigate to
    the URL [https://myapp.com](http://https://myapp.com).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你重启了Apache进程，你应该能够导航到URL [https://myapp.com](http://https://myapp.com)。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have reviewed a few possibilities to configure and deploy
    the CherryPy-based applications using common products such as Apache and lighttpd.
    We have also dealt with SSL support. These should give you enough to start with
    and adapt for your own environment and requirements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了几种使用常见产品（如Apache和lighttpd）配置和部署基于CherryPy的应用程序的可能性。我们还处理了SSL支持。这些应该足够你开始并适应你自己的环境和需求。
- en: However, deployment goes beyond setting up web servers and this chapter does
    not cover the discussion of pushing the code into the production environment,
    neither does it explain how to update the application once in production. This
    is out of the scope of this chapter and hence not been discussed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，部署不仅限于设置Web服务器，本章没有涵盖将代码推送到生产环境的讨论，也没有解释如何在生产中更新应用程序。这超出了本章的范围，因此没有讨论。
- en: Author's View
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作者观点
- en: If you have read this book, I can only assume that you are interested in the
    CherryPy library as a candidate for your personal projects. However, my motive
    behind writing this book was two-fold. Firstly, I wanted to provide a solid reference
    for CherryPy 3 that could, well hopefully, fill the curiosity of developers using
    it and this is what I have tried to achieve in the first four chapters of the
    book.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了这本书，我只能假设你对CherryPy库作为个人项目的候选者感兴趣。然而，我写这本书的动机有两个。首先，我想提供一个坚实的CherryPy
    3参考，这样，希望如此，可以满足使用它的开发者的好奇心，这正是我在本书的前四章中努力实现的目标。
- en: Secondly, I wished to introduce you, my fellow reader to some of the different
    aspects of the development of web applications. I did not plan this book as a
    reference for all the subjects it gets onto, since it would have required ten
    other tomes. Instead, I have tried to provide you with some of the keys to make
    you understand that writing a web application is not any different from any other
    type of application in the process.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我希望向我的同行读者介绍一些关于网络应用程序发展的一些不同方面。我没有计划将这本书作为所有涉及主题的参考书，因为这需要另外十卷。相反，我试图提供一些关键信息，让你明白编写网络应用程序与其他类型的应用程序在过程上并没有什么不同。
- en: With that perspective in mind,[Chapter 5](ch05.html "Chapter 5. A Photoblog
    Application") taught us that the persistent mechanism like relational databases
    could be abstracted, thanks to object-relational mapping like Dejavu, SQLObject,
    or SQLAlchemy. This is a fundamental concept that allows you to design your application
    in a relaxed fashion with regards to the manipulated data. Thereafter,[Chapter
    6](ch06.html "Chapter 6. Web Services") reminded us that a web application could
    not only serve HTML pages but also expose an API referred to as a web service.
    This API is precisely what transforms our web application into an actual provider
    of valuable services. Does it mean we should forget about the actual user experience
    and be shallow on the designing of the interface of our application? Obviously
    not, and[Chapters 7](ch07.html "Chapter 7. The Presentation Layer") and[8](ch08.html
    "Chapter 8. Ajax") review the idea behind templating before moving to the additional
    feature of client-side scripting and Ajax. Eventually,[Chapter 9](ch09.html "Chapter 9. Testing")
    makes sure that we never forget that an application that has not been tested is
    a broken one, while[Chapter 10](ch10.html "Chapter 10. Deployment") provides a
    few tips to deploy our application in common environments.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个观点，[第5章](ch05.html "第5章. 照片博客应用")告诉我们，像关系数据库这样的持久化机制可以通过Dejavu、SQLObject或SQLAlchemy这样的对象关系映射进行抽象。这是一个基本概念，它允许你以轻松的方式设计你的应用程序，与操作的数据相关。此后，[第6章](ch06.html
    "第6章. 网络服务")提醒我们，网络应用程序不仅可以提供HTML页面，还可以暴露一个称为网络服务的API。这个API正是将我们的网络应用程序转变为实际提供有价值服务的提供者的关键。这意味着我们应该忘记实际的用户体验，在应用程序界面的设计上浅尝辄止吗？显然不是，[第7章](ch07.html
    "第7章. 表示层")和[第8章](ch08.html "第8章. Ajax")在转向客户端脚本和Ajax的附加功能之前，回顾了模板背后的理念。最终，[第9章](ch09.html
    "第9章. 测试")确保我们永远不会忘记一个未经测试的应用程序是一个有缺陷的应用程序，而[第10章](ch10.html "第10章. 部署")提供了一些在常见环境中部署我们的应用程序的技巧。
- en: I hope this book will tell you a story of web application development that goes
    beyond CherryPy itself or any of the products introduced. A story that reminds
    us that there is no right or wrong but some paths that have already been explored
    might be good and could be trusted and sometimes they should be pushed even further.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书能告诉你一个关于网络应用开发的故事，这个故事不仅超越了CherryPy本身或任何介绍的产品。这是一个让我们记住没有对错之分，但一些已经探索过的路径可能很好，可以信赖，有时甚至应该进一步推进的故事。
- en: As I have said before, I have not written this book as a reference but as an
    introduction. It is quite possible that you think there are alternatives or better
    ways to achieve some of the topics covered. In such a case, I would be pleased
    to discuss this with you on the CherryPy mailing-lists. If on the other hand you
    close this book and think about parts of its content, then I will reach my goal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，我写这本书并不是作为参考书，而是作为一本入门书。完全有可能你认为有一些替代方案或更好的方法来实现所涵盖的一些主题。在这种情况下，我很乐意在CherryPy邮件列表上与你讨论这个问题。另一方面，如果你关闭这本书并思考其内容的一部分，那么我就达到了我的目标。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Founded in 2003 by the original CherryPy creator, WebFaction is a reliable and
    affordable hosting provider for your CherryPy applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: WebFaction成立于2003年，由CherryPy的原始创建者创立，是CherryPy应用程序的可靠且经济实惠的托管提供商。
- en: You can get an exclusive 20% discount by using the promo code "CHERRYPYBOOK"
    when you sign up with WebFaction, visit [http://www.webfaction.com](http://www.webfaction.com)
    for more details.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过WebFaction注册并使用促销代码"CHERRYPYBOOK"时，你可以获得独家20%的折扣。有关更多详情，请访问[http://www.webfaction.com](http://www.webfaction.com)。
