- en: Chapter 10. Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our final chapter will explain in the first section how to configure CherryPy-based
    applications, and then review different methods to deploy such an application
    through the use of Apache and lighttpd. Finally, we will review how to make your
    CherryPy-based application SSL enabled via the built-in CherryPy HTTP server,
    as well as by using Apache and lighttpd capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing an application, you always need to parameterize it, so that
    it can be tuned as per the requirements of the hosting environment. For instance,
    the type of database used, PostgreSQL or MySQL, the directory in which the application
    resides, administrator contacts, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different levels of configuration settings required in a web application
    like our photoblog:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Web server: Settings linked to the HTTP server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Engine: Settings associated with the engine hosting the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application: Settings our application will use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CherryPy—Web and Engine Configuration System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since our application is using CherryPy, we will use the CherryPy configuration
    capabilities for the web server and the engine. CherryPy uses a configuration
    based on the syntax of the INI format defined by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of a CherryPy configuration file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference between the original INI format and the format used by
    CherryPy is the fact that values in the latter case are Python data types. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the exception of `[global]`, the sections of configuration files match
    a requested URI path segment, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When CherryPy tries to match the `/css/style.css` request, it will inspect the
    configuration settings for a matching section. If found, it will use the settings
    defined for that section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we explain how CherryPy differentiates between the web server and the
    engine settings, let''s see how the configuration settings can be defined in a
    Python dictionary instead. The following code snippet demonstrates the same settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Functionally, both methods will provide the same capabilities. Using a Python
    dictionary offers the advantage of residing within the code itself, and thus allows
    for more complex data types to be provided as values. Eventually, it is usually
    a matter of taste between the two options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have presented how to declare configuration settings, let''s see
    how to pass them to their components. CherryPy API is quite straight forward in
    that respect:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cherrypy.config.update` (file or dictionary) is used to configure the CherryPy
    web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cherrypy.tree.mount` (app, config file, or dictionary) is used to provide
    the settings for the mounted application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_cp_config` attribute is bound to the page handlers, or to the class containing
    the page handlers and calls a controller defined as a dictionary (in which case,
    the settings are propagated by CherryPy to all the page handlers of that controller).
    It is used to pass the settings directly to where they will be needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will review an example to understand how to use that API in our context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what we have done in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First we declare an application with a page handler named `echo`. The purpose
    of this handler is to return the request body and repeat it as many times as defined
    by the configuration setting key `repeat`. To do so, we use the `_cp_config` attribute
    bound to the page handler. This value can also be passed from the main configuration
    dictionary. In that case, the value coming from the main dictionary takes precedence
    over the `_cp_config` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '2\. Next we declare the web server settings in a dictionary and then we call
    `cherrypy.config.update()` with that dictionary. Note that the use of the key,
    named global, is not compulsory when using a dictionary. CherryPy does interpret
    it exactly the same way; so the semantic equivalent of the previous example can
    be written as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 3\. Finally we mount two applications on two distinct prefixes with two different
    configuration settings. It is important to notice that the key we use is the path
    to the page handler relatively to where the application is mounted. That is why
    we use `/echo`, and neither `/app0/echo` nor `/app1/echo`. This also means that
    configuration settings do not leak across mounted applications. CherryPy makes
    sure that each application receives only the settings it was declared with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a common mistake to pass configuration settings associated with the application
    to the `cherrypy.config.update()` method. This will not propagate the settings
    to the mounted application. You must use the `config` attribute of `cherrypy.tree.mount()`
    to get the expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Photoblog Application Configuration System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuration settings of an application will not usually be passed through
    the CherryPy configuration system, which is at a lower level. An application would
    usually define entities from their domain level, store those values in a back-end
    storage along with the rest of its data, and ultimately provide a front-end interface
    to allow the administrator or a user to modify them.
  prefs: []
  type: TYPE_NORMAL
- en: The photoblog application will not go that far but will keep a fairly simple
    approach to providing configuration settings by using a pure INI file. We make
    this choice because in the photoblog application case the configuration settings
    will be simple, defined, and editable by the administrator of the application.
    We will therefore avoid the burden of developing a more complex solution than
    an INI file.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in order to simplify access to those settings, we will define a specific
    class that will turn the INI sections, keys, and values into a Python object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This class will simply go through the INI file and add attributes to the instance
    of the `Config` class on the fly. For instance, imagine you have the following
    INI file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the above class, we can make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have now modified the INI file into a tree of attributes
    bound to the instance of the `Config` class. The photoblog application will have
    one global instance of that class that will therefore be accessible from everywhere
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have briefly reviewed the ways to parameterize a CherryPy
    application using its built-in configuration system. We have also introduced a
    simple configuration system using an INI file format allowing application settings.
    This approach hence provides an easy way to mock up the passing of parameters,
    before moving towards a system-based database, which can be more demanding.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying a CherryPy-based application can be as easy as dropping the application
    in an environment, where all the required packages (CherryPy, Kid, simplejson,
    etc.) are available from the Python system path. However, in a shared web-hosted
    environment, it is quite likely that the CherryPy web server will reside behind
    a front-end server such as Apache or lighttpd, allowing the host provider to perform
    some filtering operations if needed, or for instance let that front end serve
    the static files in a more efficient fashion than CherryPy.
  prefs: []
  type: TYPE_NORMAL
- en: This section will present a few solutions to run a CherryPy application behind
    the Apache and lighttpd web servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before explaining how to use CherryPy behind Apache or lighttpd, let''s define
    a simple application that we will use throughout the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As discussed earlier, there are several ways of deploying CherryPy-based applications.
    Now, we will discuss the different approaches to deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Apache with mod_rewrite Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first solution you can review when running behind the Apache web server
    is to use the `mod_rewrite` module. This module allows you to define a set of
    rules that the module will analyze to transform incoming HTTP requests and re-dispatch
    them towards the back-end server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will make the following assumptions, which are in fact the
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: You run Apache 2.2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have access to the Apache configuration that can usually be found in the
    file named `httpd.conf`. You can also stop and restart the apache process. These
    requirements imply either that you have administrator rights on the machine or
    that you have a local installation of Apache to play with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will use the `VirtualHost` directive that allows encapsulating directives
    targeting only one particular host. This allows distinct hosts to be handled by
    one single instance of Apache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also assume that you have [myapp.com](http://myapp.com) resolvable
    locally. To do so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under Linux, add the following line to the /etc/hosts file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`127.0.0.1 myapp.com myapp www.myapp.com`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your operating system should now resolve requests to the `myapp.com` host to
    your local environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now explain how we must configure Apache:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Load the required Apache modules, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that you may need to provide the full path to the module itself in some
    environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2\. Next we declare the `VirtualHost`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 3\. The next step is to stop and restart your Apache process so that these modifications
    are taken into account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Then start your CherryPy application server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `mod_rewrite` module documentation explains in detail how to build rewriting
    rules. In the previous example, we defined the most generic one by mapping the
    request URI path to a new hostname.
  prefs: []
  type: TYPE_NORMAL
- en: 'When navigating to the URL [http://myapp.com](http://myapp.com), you should
    now see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how to map a host to our CherryPy application via Apache,
    we might want to retrieve the actual hostname and remote IP address instead of
    the local ones. The former is needed when generating links like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two options to achieve this, as they are independent from each other:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Use the `mod_proxy` module of Apache to forward the host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First you need to load the module like this (consult your documentation):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Add the following directive to `VirtualHost:`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Restart Apache.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '2\. Use the CherryPy proxy tool as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following entry to your global configuration:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Restart your CherryPy application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In both cases, you will now see the following message in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hello there http://myapp.com from IP: 127.0.0.1**'
  prefs: []
  type: TYPE_NORMAL
- en: The IP address stays the same because the test is being done from the same machine
    where the server is being hosted, on the local interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now explain how the previous recipe works. In the first case, by using
    the `ProxyPreserveHost` directive, we tell Apache to keep the `HTTP header host`
    field as it is and not to overwrite it with the local IP address. This means that
    CherryPy will receive the original value of the Host header.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we tell CherryPy to look for specific headers set by Apache
    when doing proxy with the original hostnames. The default header looked up by
    CherryPy is `X-Forwarded-Host.`
  prefs: []
  type: TYPE_NORMAL
- en: Lighttpd with mod_proxy Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lighttpd is another popular and very efficient HTTP server. The previous section
    can be translated to lighttpd in a similar fashion using `mod_proxy`. Here is
    an example on how you can configure lighttpd to proxy incoming requests to a CherryPy
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this to the `lighttd.conf` file and restart the server. When browsing to
    [http://myapp.com](http://myapp.com), you will see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hello there http://myapp.com from IP: 127.0.0.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Apache with mod_python Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the year 2000, Gregory Trubetskoy released the first version of `mod_python`.
    It is a module for Apache allowing the Python interpreter to be embedded within
    the Apache server providing a bridge between the Apache web server and Python
    applications. One of the strengths of `mod_python` is that unlike CGI where each
    request requires a Python process to be launched `mod_python` does not have any
    such requirement. Therefore, it gives the opportunity to the developer to benefit
    from the persistence of the Python process started by Apache when running the
    module (keeping a pool of database connections for instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before seeing how to configure Apache and `mod_python`, let''s review what
    are the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Apache 2.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mod_python` 3.1.x or superior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will assume that `mod_python` is properly installed in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s explain how to configure `mod_python` to run a CherryPy-based application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will take you through the process sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First we load the `mod_python` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. We define a location directive specifying what Apache should do to the request
    starting with "/".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3\. Then we define several `mod_python` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PythonPath` extends the system path and makes sure that our application modules
    will be found. For instance, here the `my_app.py` module resides in `/home/sylvain/app`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetHandler` indicates that all requests starting with the path provided in
    the location directive will be handled by `mod_python`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PythonHandler` sets the generic handler that will be in charge of generating
    the output to return to the user agent. We use the built-in `mod_python` handler
    provided by CherryPy.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PythonOption` passes options to the generic handler. Here the option will
    be named `cherrypy.setup` and we bind it to the function `setup_app` that our
    application provides. We assume the application is saved in a Python module named
    `my_app.py`. The `setup_app` method must be the one mounting the application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PythonDebug` is enabled.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '4\. Finally, we modify the application as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that we start the CherryPy engine in a non-blocking mode so
    that the Python process started via mod_python does not hang.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you can stop and restart the Apache process and navigate to the [http://myapp.com](http://myapp.com)
    URL and you should see the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hello there http://myapp.com from IP: 127.0.0.1**'
  prefs: []
  type: TYPE_NORMAL
- en: mod_python with WSGI Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous approach, we used the built-in `mod_python` handler that works
    fine on the applications usually hosted by CherryPy. If your application respects
    the WSGI interface, you may want to use the `ModPythonGateway` handler ([http://projects.amor.org/misc/wiki/ModPythonGateway](http://projects.amor.org/misc/wiki/ModPythonGateway))
    developed by Robert Brewer.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s see the CherryPy application in the `my_app.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s review how to configure Apache to use the `ModPythonGateway` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `ModPythonGateway` handler, you can use the richness of WSGI-based
    middlewares within the power of the Apache server.
  prefs: []
  type: TYPE_NORMAL
- en: SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SSL** (**Secure Sockets Layer**) can be supported in CherryPy-based applications
    natively by CherryPy. To enable SSL support, you must meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Have the `PyOpenSSL` package installed in your environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have an SSL certificate and private key on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rest of this chapter, we will assume that you have installed `PyOpenSSL`
    properly. Let us explain how to generate a pair of private key and certificate.
    To achieve this, we will use OpenSSL, a common open-source implementation of the
    SSL specification.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Certificate and a Private Key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s deal with the certificate and the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. First we need a private key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '2\. This key is not protected by a passphrase and therefore has a fairly weak
    protection. If you prefer providing a passphrase, you should issue a command like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will require a passphrase. If your version of OpenSSL allows you
    to provide an empty string, do so. Otherwise, enter a default passphrase and then
    remove it from the generated key as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '3\. Now we create a certificate as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '4\. This process will request you to input some details. The previous step
    has generated a certificate but it is not yet signed by the private key. To do
    so, you must issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The newly signed certificate will be valid for 60 days.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, as the certificate is not signed by a recognized authority such as
    VeriSign, your browser will display a pop up when accessing the application, so
    that the user can accept or reject the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can have a look at the different approaches for creating the certificate
    and the key.
  prefs: []
  type: TYPE_NORMAL
- en: Using the CherryPy SSL Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see how we can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The key is to provide the `server.ssl_certificate` and `server.ssl_private_key`
    values to the global CherryPy configuration. The next step is to start the server;
    if everything went well, you should see the following message on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Serving HTTPS on https://localhost:8443/**'
  prefs: []
  type: TYPE_NORMAL
- en: 'By navigating to the application URL, you should see a message such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the CherryPy SSL Support](img/1848_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you accept the certificate, you will be able to continue using the web application
    via HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat of the previous solution is that now your application cannot be
    reached via non-secured HTTP. Luckily CherryPy provides a fairly easy way to work
    around this problem by simply starting two HTTP servers at once. You can see how
    it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon starting the application, you should now see the following lines on your
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Serving HTTPS on https://localhost:8443/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Serving HTTP on http://localhost:8080/**'
  prefs: []
  type: TYPE_NORMAL
- en: Your application will now be reachable via HTTP and HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Using the lighttpd SSL Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting SSL support for lighttpd is as simple as adding the following to the
    global configuration of lighttpd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `server.pem` file is the concatenation of the `server.key` and `server.crt`
    files that we have created before. For instance, under a UNIX System we issue
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By using those two lines and the proxy method, we have described in the previous
    section how to support SSL for the CherryPy application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note, however, that the path between lighttpd and CherryPy will be HTTP not
    secured. SSL support will stop at the lighttpd level.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Apache mod_ssl Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach consists of using the `mod_ssl` module of Apache based on OpenSSL
    to handle the SSL exchange before forwarding the request to the CherryPy server,
    as we did with lighttpd.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, you need to modify your Apache configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first line loads the `mod_ssl` module. The second line requests Apache to
    listen for incoming socket connections on a given IP address on port 443 (which
    requires administrator rights).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we modify `VirtualHost`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once you have restarted the Apache process, you should be able to navigate to
    the URL [https://myapp.com](http://https://myapp.com).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have reviewed a few possibilities to configure and deploy
    the CherryPy-based applications using common products such as Apache and lighttpd.
    We have also dealt with SSL support. These should give you enough to start with
    and adapt for your own environment and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: However, deployment goes beyond setting up web servers and this chapter does
    not cover the discussion of pushing the code into the production environment,
    neither does it explain how to update the application once in production. This
    is out of the scope of this chapter and hence not been discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Author's View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have read this book, I can only assume that you are interested in the
    CherryPy library as a candidate for your personal projects. However, my motive
    behind writing this book was two-fold. Firstly, I wanted to provide a solid reference
    for CherryPy 3 that could, well hopefully, fill the curiosity of developers using
    it and this is what I have tried to achieve in the first four chapters of the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, I wished to introduce you, my fellow reader to some of the different
    aspects of the development of web applications. I did not plan this book as a
    reference for all the subjects it gets onto, since it would have required ten
    other tomes. Instead, I have tried to provide you with some of the keys to make
    you understand that writing a web application is not any different from any other
    type of application in the process.
  prefs: []
  type: TYPE_NORMAL
- en: With that perspective in mind,[Chapter 5](ch05.html "Chapter 5. A Photoblog
    Application") taught us that the persistent mechanism like relational databases
    could be abstracted, thanks to object-relational mapping like Dejavu, SQLObject,
    or SQLAlchemy. This is a fundamental concept that allows you to design your application
    in a relaxed fashion with regards to the manipulated data. Thereafter,[Chapter
    6](ch06.html "Chapter 6. Web Services") reminded us that a web application could
    not only serve HTML pages but also expose an API referred to as a web service.
    This API is precisely what transforms our web application into an actual provider
    of valuable services. Does it mean we should forget about the actual user experience
    and be shallow on the designing of the interface of our application? Obviously
    not, and[Chapters 7](ch07.html "Chapter 7. The Presentation Layer") and[8](ch08.html
    "Chapter 8. Ajax") review the idea behind templating before moving to the additional
    feature of client-side scripting and Ajax. Eventually,[Chapter 9](ch09.html "Chapter 9. Testing")
    makes sure that we never forget that an application that has not been tested is
    a broken one, while[Chapter 10](ch10.html "Chapter 10. Deployment") provides a
    few tips to deploy our application in common environments.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this book will tell you a story of web application development that goes
    beyond CherryPy itself or any of the products introduced. A story that reminds
    us that there is no right or wrong but some paths that have already been explored
    might be good and could be trusted and sometimes they should be pushed even further.
  prefs: []
  type: TYPE_NORMAL
- en: As I have said before, I have not written this book as a reference but as an
    introduction. It is quite possible that you think there are alternatives or better
    ways to achieve some of the topics covered. In such a case, I would be pleased
    to discuss this with you on the CherryPy mailing-lists. If on the other hand you
    close this book and think about parts of its content, then I will reach my goal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Founded in 2003 by the original CherryPy creator, WebFaction is a reliable and
    affordable hosting provider for your CherryPy applications.
  prefs: []
  type: TYPE_NORMAL
- en: You can get an exclusive 20% discount by using the promo code "CHERRYPYBOOK"
    when you sign up with WebFaction, visit [http://www.webfaction.com](http://www.webfaction.com)
    for more details.
  prefs: []
  type: TYPE_NORMAL
