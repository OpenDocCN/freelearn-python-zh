- en: Chapter 2. Simple Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 简单数据类型
- en: 'Now we''ll look at a number of data types that are built-in as well as some
    that are part of Python''s standard library. We''ll start with Python''s numeric
    types. These include three built-in types: `int`, `float`, and `complex`, plus
    the standard library types `Fraction` and `Decimal`.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨一些既是内置类型又是Python标准库一部分的数据类型。我们将从Python的数值类型开始。这些包括三个内置类型：`int`，`float`和`complex`，以及标准库类型`Fraction`和`Decimal`。
- en: We'll also look at strings, `str`, and simple collections, `tuple`. These are
    more complex than numbers because they contain multiple items. Since their behavior
    is less complex than the kinds of objects we'll see in later chapters, they serve
    as a good introduction to the general concept of sequences in Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨字符串，`str`，以及简单的集合，`tuple`。这些比数字更复杂，因为它们包含多个项目。由于它们的行为比我们在后续章节中将要看到的对象类型要简单，因此它们可以作为Python中序列一般概念的良好介绍。
- en: Note the capitalization of the names of `Fraction` and `Decimal`. The built-in
    type names start with a lowercase letter. Types that we must import have a module
    name that starts with a lowercase letter, but the type name starts with a capital
    letter. This convention is widespread, but not universal.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Fraction`和`Decimal`名称的字母大小写。内置类型名称以小写字母开头。我们必须导入的类型有一个以小写字母开头的模块名称，但类型名称以大写字母开头。这种约定很普遍，但并非普遍适用。
- en: 'All of the types we''ll look at in this chapter have the common feature of
    immutability. This concept applies to the two collections we''ll look at: once
    built, a string or a tuple cannot be changed. Rather than change it, we create
    a new object. In [Chapter 6](ch06.html "Chapter 6. More Complex Data Types"),
    *More Complex Data Types*, we''ll look at collections which can be updated without
    creating a new object.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的所有类型都具有不可变性的共同特征。这个概念适用于我们将要查看的两个集合：一旦构建，字符串或元组就不能更改。我们不会更改它，而是创建一个新的对象。在[第六章](ch06.html
    "第六章 更复杂的数据类型")，*更复杂的数据类型*中，我们将查看可以更新而不需要创建新对象的集合。
- en: In this chapter, we'll look at the built-in functions for converting to and
    from string representations. This will help us when displaying output or converting
    input from a string to a useful Python object.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨内置的将字符串表示转换为其他表示以及从其他表示转换为字符串表示的函数。这有助于我们在显示输出或将字符串输入转换为有用的Python对象时。
- en: Note that we're continuing to play fast and loose with formal Python syntax.
    We'll defer a detailed examination of the syntax rules until [Chapter 3](ch03.html
    "Chapter 3. Expressions and Output"), *Expressions and Output*. For now, the kinds
    of simple expression statements we're focusing on must be restricted to a single
    line.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍在轻松地处理正式的Python语法。我们将推迟对语法规则的详细审查，直到[第三章](ch03.html "第三章 表达式和输出")，*表达式和输出*。现在，我们关注的简单表达式语句必须限制在单行内。
- en: Introducing the built-in operators
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍内置运算符
- en: 'Before looking at the various kinds of numbers available, we''ll introduce
    the Python operators. The operators fall into three broad groups:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看各种可用的数字类型之前，我们将介绍Python运算符。运算符分为三大类：
- en: '| Group | Operators |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 组 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Arithmetic | `+`, `-`, `*`, `**`, `/`, `//`, `%` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | `+`, `-`, `*`, `**`, `/`, `//`, `%` |'
- en: '| Bit-oriented | `<<`, `>>`, `&`, `&#124;`, `^`, `~` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 位运算 | `<<`, `>>`, `&`, `&#124;`, `^`, `~` |'
- en: '| Comparison | `<`, `>`, `<=`, `>=`, `==`, `!=` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `<`, `>`, `<=`, `>=`, `==`, `!=` |'
- en: The differences between these groups are partly subjective. There's only a small
    technical difference in the way the comparison operators work. Most of the operators
    are binary, only one (`~`) is unary, and a few (`+`, `-`, `*`, `**`) can be used
    in either context.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组之间的差异部分是主观的。比较运算符的工作方式在技术上只有细微差别。大多数运算符是二元的，只有一个（`~`）是一元的，而少数（`+`, `-`, `*`,
    `**`）可以在两种上下文中使用。
- en: The `+`, `-`, `*`, `/`, and `%` operators have meanings similar to those used
    other programming languages. There is an arithmetic meaning for `–` and `+`. Python
    adds the `**` operator when raising a number to a power. The `**` operator takes
    higher precedence than the unary form `-`; this means that `-2**4` is `-16`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`, `-`, `*`, `/` 和 `%` 运算符的含义与其他编程语言中使用的类似。`–` 和 `+` 有算术含义。Python在将一个数字提升到幂时使用
    `**` 运算符。`**` 运算符的优先级高于一元形式 `-`；这意味着 `-2**4` 的结果是 `-16`。'
- en: Bit-oriented operators apply only to integers. They also apply to sets. These
    are emphatically not logical operators. The actual logical operators are described
    in [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"), *Logic,
    Comparisons, and Conditions*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符仅适用于整数。它们也适用于集合。这些绝对不是逻辑运算符。实际的逻辑运算符在 [第 5 章](ch05.html "第 5 章。逻辑、比较和条件")，*逻辑、比较和条件*
    中描述。
- en: Making comparisons
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行比较
- en: The comparison operators (`<`, `>`, `==`, `!=`, `<=`, `>=`) have meanings similar
    to those used in other programming languages. The coercion rules apply to comparisons
    between numbers. If the objects are of mixed types, one of them will be coerced
    "up" the numeric tower from integer to float, or float to complex. The result
    of a comparison is a Boolean (`True` or `False`) irrespective of the types of
    the two operands.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符（`<`, `>`, `==`, `!=`, `<=`, `>=`）的含义与其他编程语言中使用的类似。强制类型转换规则适用于数字之间的比较。如果对象是混合类型，其中一个对象将被强制“向上”转换到数值塔中的浮点数，或者从浮点数到复数。比较的结果是一个布尔值（`True`
    或 `False`），无论两个操作数的类型如何。
- en: The various coercion rules do not apply to strings or other objects. Strings
    are not implicitly converted to numbers. `2 != '2'` is true because the integer
    `2` is not a string `'2'`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 各种强制类型转换规则不适用于字符串或其他对象。字符串不会隐式转换为数字。`2 != '2'` 是真的，因为整数 `2` 不是一个字符串 `'2'`。
- en: 'Some popular languages (for example, Java, C++) have primitive types such as
    `int` or `long` which are not proper objects—they''re not instances of a class—and
    the rules that apply to objects do not apply to them. Java allows the `==` comparison
    for `int` objects, but using the same comparison operator with string objects
    doesn''t compare the characters of the two strings, it only compares the references.
    This is emphatically not the case with Python. All Python objects are proper instances
    of a class: the `==` comparison in Python strings compares the two strings character
    by character.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的语言（例如 Java、C++）有原始类型，如 `int` 或 `long`，它们不是正确的对象——它们不是类的实例——并且适用于对象的规则不适用于它们。Java
    允许对 `int` 对象使用 `==` 比较操作，但使用相同的比较运算符与字符串对象比较并不比较两个字符串的字符，它只比较引用。这与 Python 完全不同。所有
    Python 对象都是类的正确实例：Python 字符串中的 `==` 比较是逐字符比较两个字符串。
- en: We'll look at comparisons in more detail in [Chapter 5](ch05.html "Chapter 5. Logic,
    Comparisons, and Conditions"), *Logic, Comparisons, and Conditions*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 5 章](ch05.html "第 5 章。逻辑、比较和条件")，*逻辑、比较和条件* 中更详细地研究比较。
- en: Using integers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用整数
- en: Python integers are objects of the class `int`. These objects have the largest
    number of operators, including all of the arithmetic, bit-oriented, and comparison
    operators.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的整数是 `int` 类的对象。这些对象具有最多的运算符，包括所有算术、位运算和比较运算符。
- en: 'Integer values are limited by available memory. This means they can be quite
    large. We can easily compute 1,000!, a number with over 2,500 digits. We''ll save
    the details for [Chapter 8](ch08.html "Chapter 8. More Advanced Functions"), *More
    Advanced Functions*. A number of similarly gargantuan size is:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 整数值受可用内存限制。这意味着它们可以非常大。我们可以轻松地计算 1,000!，一个超过 2,500 位的数。我们将细节留到 [第 8 章](ch08.html
    "第 8 章。更高级的功能")，*更高级的功能*。具有类似巨大规模的数有：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a very large number. We've elided most of it. It's easily represented
    in Python.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常大的数。我们省略了其中大部分。它很容易在 Python 中表示。
- en: 'Generally, we provide integer literals in decimal, base 10\. We can also write
    literals in three other bases: hexadecimal, octal, and binary.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们以十进制（基数 10）提供整数字面量。我们也可以用三种其他基数编写字面量：十六进制、八进制和二进制。
- en: 'The prefix of `0x` is the prefix for base 16 values: `0x10` is `16`. We can
    use the letters `a-f,` as is typical in many other programming languages; `0xdeadbeef`
    is valid. The prefix `0o` (zero and the letter o) is used for base eight; try
    to avoid using the maliciously confusing `0O` (zero and capital O) for octal values,
    for example, `0o33653337357`. We can write base two literal values using the `0b`
    prefix: `0b10` is `2`. The most common use case for non-decimal numbers is providing
    hexadecimal values for an array of bytes, and this is relatively rare.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x` 前缀是十六进制值的标志：`0x10` 是 `16`。我们可以使用字母 `a-f`，这在许多其他编程语言中很典型；`0xdeadbeef` 是有效的。前缀
    `0o`（零和字母 o）用于八进制；尽量避免使用恶意混淆的 `0O`（零和大写 O）作为八进制值，例如，`0o33653337357`。我们可以使用 `0b`
    前缀来编写二进制字面量值：`0b10` 是 `2`。非十进制数最常见的用途是提供字节数组的十六进制值，这相对较少。'
- en: Using the bit-oriented operators
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用位运算符
- en: Bit-oriented operators are defined for integers. They're not defined for complex
    or floating-point objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符是为整数定义的。它们不为复数或浮点对象定义。
- en: The `<<` and `>>` operators perform bit shifting. `1 << 8`, for example, is
    256\. We've shifted the value 1 to the left 8 bit positions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<`和`>>`运算符执行位移。例如，`1 << 8`是256。我们已经将值1向左移动了8位位置。'
- en: 'The `&`, `|`, and `^` operators compute the bitwise "and", bitwise "or", and
    bitwise "xor" of two integer values. Here are some examples:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`、`|`和`^`运算符计算两个整数值的按位“与”、“按位或”和按位“异或”。以下是一些示例：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To visualize these operators, we can use the `bin()` function to see the binary
    values involved.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化这些运算符，我们可以使用`bin()`函数来查看涉及的二进制值。
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `bin()` function can clarify how the bits of `9|5` combine to create
    the bits of `13`. The `~` operator is the bitwise two's complement of an integer
    value. `~14`, for example, is `-15`. These are emphatically not logical operators.
    Logical operators are described in [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons,
    and Conditions"), *Logic, Comparisons, and Conditions*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bin()`函数可以阐明`9|5`的位如何组合以创建`13`的位。`~`运算符是整数值的按位二进制补码。例如，`~14`是`-15`。这些绝对不是逻辑运算符。逻辑运算符在[第五章](ch05.html
    "第五章。逻辑、比较和条件")中描述，*逻辑、比较和条件*。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Do not confuse `a & b` with `a and b`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆`a & b`与`a and b`：
- en: '`a & b` computes a bitwise "and" of the bits in the integers *a* and *b*.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a & b`计算整数*a*和*b*中位的按位“与”。'
- en: '`a and b` computes the Boolean "and" based on the truth values of *a* and *b*.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a and b`基于*a*和*b*的真值计算布尔“与”。'
- en: Using rational numbers
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用有理数
- en: 'Rational numbers are fractions composed of two integer values. Python doesn''t
    have a built-in rational number type. We must import the `Fraction` class using
    this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数是由两个整数值组成的分数。Python没有内置的有理数类型。我们必须使用以下方式导入`Fraction`类：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will introduce the `Fraction` class definition to our global environment.
    Once we have this, we can create objects of the class `Fraction` as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引入`Fraction`类的定义到我们的全局环境中。一旦我们有了这个，我们就可以创建`Fraction`类的对象，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Arithmetic and comparison operators apply to fractions. When doing mixed-type
    expressions, fractions fit into the numeric tower above integers and below floating-point
    values. Here''s an example of an integer coerced to a fraction:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 算术和比较运算符适用于分数。在进行混合类型表达式时，分数适合于整数之上的数值塔和浮点值之下。以下是将整数强制转换为分数的示例：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Performing an operation that involves a `Fraction` value and an `int` value
    requires that the `int` object is coerced up to the `Fraction` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行涉及`Fraction`值和`int`值的操作需要将`int`对象强制转换为`Fraction`类。
- en: 'We can extract the numerator and denominator of a fraction using their attribute
    names. Here''s an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它们的属性名称提取分数的分子和分母。以下是一个示例：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've created a `Fraction` object, `a`, from an expression involving a `Fraction`
    object and an integer. We've then extracted the `numerator` and `denominator`
    attributes of the variable `a`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个涉及`Fraction`对象和整数的表达式中创建了一个`Fraction`对象`a`。然后我们提取了变量`a`的`numerator`（分子）和`denominator`（分母）属性。
- en: Using decimal numbers
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用十进制数
- en: 'For currency calculations, we generally use `Decimal` numbers. Python doesn''t
    have a built-in decimal number type. We import the `Decimal` class using this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于货币计算，我们通常使用`Decimal`数。Python没有内置的十进制数类型。我们使用以下方式导入`Decimal`类：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will introduce the `Decimal` class definition to our global environment.
    We can now create `Decimal` objects. It's important to avoid accidentally mixing
    `Decimal` and `float` values, because `float` values are only an approximation.
    To be sure that `Decimal` values are exact, we must use only integers or strings.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引入`Decimal`类的定义到我们的全局环境中。我们现在可以创建`Decimal`对象。重要的是要避免意外地将`Decimal`和`float`值混合，因为`float`值只是近似值。为了确保`Decimal`值是精确的，我们必须只使用整数或字符串。
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ve created a `Decimal` value from a string. The resulting `Decimal` object
    will represent this exactly, carefully preserving the appropriate decimal places
    and rounding up or down as required. For common financial calculations, `Decimal`
    is required. Here''s an example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个字符串创建了一个`Decimal`值。生成的`Decimal`对象将精确地表示这个值，仔细保留适当的十进制位数，并根据需要向上或向下舍入。对于常见的金融计算，`Decimal`是必需的。以下是一个示例：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've added two prices, $512.97 and $5.97 and computed a sales tax of 7.5%.
    The tax is $38.92050, to be precise. This is generally rounded to $38.92.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个价格，$512.97和$5.97，并计算了7.5%的销售税。税额精确为$38.92050。这通常四舍五入到$38.92。
- en: 'If we try this kind of financial calculation with floating-point values, we
    have a bit of a problem:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用浮点数进行此类财务计算，我们会遇到一些问题：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The floating-point approximations don't produce an exact answer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点近似值不会产生精确答案。
- en: Python coercion rules work well with `Decimal` and `int` values. We can calculate
    `Decimal('3.99')*3` and get `Decimal('11.97')` as the answer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python的强制转换规则与`Decimal`和`int`值配合良好。我们可以计算`Decimal('3.99')*3`并得到`Decimal('11.97')`作为答案。
- en: 'The coercion rules aren''t implemented by the `Decimal` and `float` classes.
    It might make some sense for `Decimal` values to be coerced up to `float` values.
    On the other hand, this might indicate a profound programming error when mixing
    exact currency values and floating-point approximations. Since this is ambiguous,
    and debatable, the general approach followed by Python is summarized by this line
    from Tim Peters'' *The Zen of Python*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换规则不是由`Decimal`和`float`类实现的。对于`Decimal`值强制转换为`float`值可能有些道理。另一方面，这可能在混合精确货币值和浮点近似值时表明一个深刻的编程错误。由于这是模糊的，并且有争议的，Python遵循的一般方法可以用Tim
    Peters的*Python之禅*中的一句话来总结：
- en: '*In the face of ambiguity, refuse the temptation to guess.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*面对歧义，拒绝猜测的诱惑。*'
- en: Consequently, mixing `Decimal` and `float` leads to `TypeError` exceptions instead
    of following coercion up the numeric tower and switching from exact to approximate
    values. We must explicitly convert `Decimal` to `float` to do mixed-type expressions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，混合`Decimal`和`float`会导致`TypeError`异常，而不是遵循强制转换到数值塔的规则，并从精确值转换为近似值。我们必须显式地将`Decimal`转换为`float`来进行混合类型表达式。
- en: Using floating-point numbers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用浮点数
- en: Floating-point values are instances of the class `float`. These objects work
    with arithmetic and comparison operators. They don't participate in the bit-oriented
    operators.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值是`float`类的一个实例。这些对象使用算术和比较运算符。它们不参与位操作符。
- en: The details of Python floating-point implementations can vary. CPython depends
    on the standard C libraries, which should provide reasonably consistent results
    on a wide variety of hardware and OS platforms. C libraries generally use IEEE
    754 floating-point values; Python's `float` type is the C language `double`. This
    means that a float will be a 64-bit value with (effectively) a 53-bit fraction
    and an 11-bit exponent. The exponent range is from ![Using floating-point numbers](img/B03671_02_01.jpg)to
    ![Using floating-point numbers](img/B03671_02_02.jpg).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python浮点实现的细节可能有所不同。CPython依赖于标准C库，这些库应该在广泛的硬件和操作系统平台上提供合理一致的结果。C库通常使用IEEE 754浮点值；Python的`float`类型是C语言的`double`。这意味着浮点数将是一个64位值，具有（实际上）53位的分数和11位的指数。指数范围从![使用浮点数](img/B03671_02_01.jpg)到![使用浮点数](img/B03671_02_02.jpg)。
- en: 'We can write floating-point numbers two ways: as digits with a decimal point,
    as well as in "scientific" notation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两种方式写浮点数：作为带小数点的数字，以及用“科学”表示法：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `E` notation shows a power of 10\. That means 6.335437E3 is ![Using floating-point
    numbers](img/B03671_02_03.jpg).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`E`表示法表示10的幂。这意味着6.335437E3是![使用浮点数](img/B03671_02_03.jpg)。'
- en: 'It''s very important to note that floating-point values are an approximation.
    We can''t emphasize enough that they''re not exact and should not be used for
    currency calculations. Here''s an example of what happens when working with floating-point
    approximations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，浮点值是一个近似值。我们无法强调它们不是精确的，并且不应该用于货币计算。以下是一个使用浮点近似值工作时的例子：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This should not be surprising in any way. Mathematically, ![Using floating-point
    numbers](img/B03671_02_04.jpg). Since values like 1/6 don't have exact binary
    representations, this kind of expression reveals the consequences of working with
    approximations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这在任何方面都不应该令人惊讶。从数学上讲，![使用浮点数](img/B03671_02_04.jpg)。由于像1/6这样的值没有精确的二进制表示，这种表达式揭示了使用近似值工作的后果。
- en: The fact that floating-point numbers use a binary representation leads to interesting
    complications. A number such as 1/6 has no exact decimal representation; we can
    use .1666... to indicate that the decimal positions repeat infinitely. However,
    a number such as 1/5 has an exact decimal representation, 0.2\. Neither of these
    numbers has an exact binary representation. Since we must use a finite number
    of bits, we'll notice slight discrepancies between idealized values and the finite
    values produced on a digital computer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数使用二进制表示的事实导致了一些有趣的复杂情况。例如，1/6 这样的数没有精确的十进制表示；我们可以用 .1666... 来表示小数位无限重复。然而，例如
    1/5 这样的数有一个精确的十进制表示，0.2。这两个数都没有精确的二进制表示。由于我们必须使用有限数量的位，我们会在理想化的值和数字计算机产生的有限值之间注意到细微的差异。
- en: Note that exact equality comparisons between floating-point numbers, while permitted,
    is generally not a good idea. In [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons,
    and Conditions"), *Logic, Comparisons, and Conditions*, we'll address how to use
    a narrow range instead of exact equality. Instead of `a == b`, we need to focus
    on `abs(a-b) < ε`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然允许进行浮点数的精确相等比较，但这通常不是一个好主意。在 [第五章](ch05.html "第五章。逻辑、比较和条件")，*逻辑、比较和条件*
    中，我们将讨论如何使用一个狭窄的范围而不是精确相等。我们不需要 `a == b`，而需要关注 `abs(a-b) < ε`。
- en: Using complex numbers
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用复数
- en: 'The top of Python''s number tower is of the `complex` type. It can be thought
    of as expressions built from a pair of floating-point numbers: one is a real value,
    the other is an imaginary value. The imaginary value is multiplied by ![Using
    complex numbers](img/B03671_02_05.jpg). We write `(2+3j)` to mean ![Using complex
    numbers](img/B03671_02_06.jpg).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的数值塔顶是 `complex` 类型。它可以被视为由一对浮点数构成的表达式：一个是实数，另一个是虚数。虚数乘以 ![使用复数](img/B03671_02_05.jpg)。我们用
    `(2+3j)` 来表示 ![使用复数](img/B03671_02_06.jpg)。
- en: When working with complex numbers, we often import the `cmath` library instead
    of the `math` library. The `math.sqrt()` function is constrained to work only
    with `float` values, and will raise an exception rather than provide an imaginary
    value. The `cmath.sqrt()` function will provide a proper imaginary value, if required.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理复数时，我们通常导入 `cmath` 库而不是 `math` 库。`math.sqrt()` 函数仅限于与 `float` 值一起工作，并且会引发异常而不是提供一个虚数值。如果需要，`cmath.sqrt()`
    函数将提供一个适当的虚数值。
- en: 'This library shows us that ![Using complex numbers](img/B03671_02_07.jpg) is
    essentially true:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库向我们展示了 ![使用复数](img/B03671_02_07.jpg) 是本质上正确的：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that we used `1j` to represent ![Using complex numbers](img/B03671_02_05.jpg).
    If we try to use the identifier `j` (without a number in front of it) it is seen
    as a simple variable. The value `1j` is a complex literal because it starts with
    a digit and ends with `j`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了 `1j` 来表示 ![使用复数](img/B03671_02_05.jpg)。如果我们尝试使用标识符 `j`（前面没有数字），它会被视为一个简单的变量。`1j`
    的值是一个复数字面量，因为它以数字开头并以 `j` 结尾。
- en: Since floating-point values have about 53 bits, which is about 16 decimal digits,
    we can expect `float` approximations of irrational values like `π` and `e` to
    be off by about ![Using complex numbers](img/B03671_02_08.jpg).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点值大约有 53 位，大约是 16 个十进制数字，我们可以预期 `float` 对无理数如 `π` 和 `e` 的近似会有大约 ![使用复数](img/B03671_02_08.jpg)
    的误差。
- en: The numeric tower
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值塔
- en: 'We''ve seen Python''s three built-in numeric types: `int`, `float`, `complex`,
    plus two more types—`Fraction` and `Decimal`—imported from the standard library.
    The numbers module in the standard library provides four base class definitions
    for the numeric types. We rarely need to use this module explicitly; it''s a convention
    that we need when we have to implement our own numeric types.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Python 的三种内置数值类型：`int`、`float`、`complex`，以及从标准库中导入的两种更多类型——`Fraction`
    和 `Decimal`。标准库中的 numbers 模块提供了四种数值类型的基类定义。我们很少需要显式地使用这个模块；当我们需要实现自己的数值类型时，这是一个惯例。
- en: The numeric types form a kind of "tower" that parallels the various kinds of
    numbers seen in conventional mathematics. The foundation of the tower is integers.
    Rational numbers are above integers. Floating-point values are still further up,
    and complex numbers are at the top of the tower.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类型形成了一种类似于传统数学中看到的各种数字的“塔”。塔的底部是整数。有理数在整数之上。浮点值更上一层楼，而复数位于塔顶。
- en: A common expectation is that a language will automatically coerce numeric values
    to permit expressions such as `2*2.718` to work properly and produce a useful
    result. When multiplying an integer by a float value, we expect integers to be
    coerced to a floating-point value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的期望是，一种语言将自动强制转换数值，以允许表达式如`2*2.718`正常工作并产生有用的结果。当乘以一个浮点值时，我们期望整数被强制转换为浮点值。
- en: 'In order for this to work, there are two general rules applied to the result
    of a binary arithmetic operation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这成为可能，有两个一般规则应用于二进制算术运算的结果：
- en: If both operands are of the same type, the result has that type. For example,
    `2 ** 1024` does not produce a floating-point result. It produces an immense integer.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个操作数是同一类型，结果也将具有该类型。例如，`2 ** 1024`不会产生浮点结果。它会产生一个巨大的整数。
- en: If the operands are mixed, one of them will be coerced "up" the numeric tower
    from integer → rational → floating-point → complex.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作数是混合的，其中一个将会被强制“向上”转换到数值塔，从整数 → 有理数 → 浮点数 → 复数。
- en: 'There is one notable exception to the preceding rules. The `/` and `//` operators
    define two different kinds of division. The `/` operator provides true division:
    even integer operands will yield a floating-point result. For example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述规则有一个显著的例外。`/`和`//`运算符定义了两种不同的除法。`/`运算符提供真正的除法：即使是整数操作数也会产生浮点结果。例如：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `//` operator provides floor division: the result will be truncated as
    if it were an integer-only division. The resulting type won''t be coerced, but
    the answer will be truncated. For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`//`运算符提供向下取整除法：结果将被截断，就像它是一个仅包含整数的除法。结果类型不会被强制转换，但答案将被截断。例如：'
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The presence of the `//` operator means that an expression which is designed
    with integers in mind will also work correctly with floating-point values. Similarly,
    we may write an expression with an informal expectation of floating-point values;
    by using `/`, it will also work with integers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`//`运算符的存在意味着一个以整数设计的表达式也将正确地与浮点值一起工作。同样，我们可能编写一个带有非正式浮点值期望的表达式；通过使用`/`，它也将与整数一起工作。'
- en: Note that these coercion rules for numeric types do not apply to strings or
    other objects. Strings are not implicitly converted to numbers. The expression
    `'2'+2` results in a `TypeError` exception. We'll look at explicit conversions
    later, in the *Using the built-in conversion functions* section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些数值类型的强制转换规则不适用于字符串或其他对象。字符串不会隐式转换为数字。表达式`'2'+2`会导致一个`TypeError`异常。我们将在*使用内置转换函数*部分稍后查看显式转换。
- en: The tower metaphor provides a handy way to remember the coercion rules. Given
    two values from different levels, the lower-level value is coerced up the tower
    to the higher-level values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 桥楼隐喻提供了一个方便的记忆强制转换规则的方法。给定来自不同层级的两个值，较低层级的值将被强制转换到塔的较高层级。
- en: The math libraries
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学库
- en: The Python library has six modules relevant to mathematical work. These are
    described in *Chapter 9*, *Numeric and Mathematical Modules*, of the *Python Standard
    Library* document. Beyond this, we have external libraries such as NumPy ([http://www.numpy.org](http://www.numpy.org))
    and SciPy ([http://www.scipy.org](http://www.scipy.org)). These libraries include
    vast collections of sophisticated algorithms. For an even more sophisticated toolset,
    the Anaconda project ([https://store.continuum.io/cshop/anaconda/](https://store.continuum.io/cshop/anaconda/))
    combines NumPy, SciPy, and 18 more packages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python库有六个与数学工作相关的模块。这些在*Python标准库*文档的*第9章*，*数值和数学模块*中进行了描述。除此之外，我们还有外部库，如NumPy
    ([http://www.numpy.org](http://www.numpy.org)) 和SciPy ([http://www.scipy.org](http://www.scipy.org))。这些库包括大量的复杂算法。对于更复杂的工具集，Anaconda项目
    ([https://store.continuum.io/cshop/anaconda/](https://store.continuum.io/cshop/anaconda/))
    结合了NumPy、SciPy和另外18个包。
- en: 'These are the relevant built-in numeric packages:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是相关的内置数值包：
- en: '`numbers`: This module defines the essential numeric abstractions. We rarely
    need this unless we''re going to invent an entirely new kind of number.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numbers`：此模块定义了基本的数值抽象。除非我们要发明一种全新的数字类型，否则我们很少需要它。'
- en: '`math`: This module has a large collection of functions. It includes basic
    `sqrt()`, the various trigonometric functions (sine, cosine, and so on) and the
    various log-related functions. It has functions for working with the internals
    of floating-point numbers. It also has the gamma function and the error function.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`math`：这个模块包含大量函数。它包括基本的`sqrt()`，各种三角函数（正弦、余弦等）以及各种与对数相关的函数。它有处理浮点数内部结构的函数。它还包括伽玛函数和误差函数。'
- en: '`cmath`: This module is the complex version of the `math` library. We use the
    `cmath` library so that we can seamlessly move between `float` and `complex` values.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmath`：这个模块是`math`库的复数版本。我们使用`cmath`库，以便可以在`float`和`complex`值之间无缝切换。'
- en: '`decimal`: Import the `Decimal` class from this module to work with currency
    values accurately.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal`：从这个模块导入`Decimal`类以准确处理货币值。'
- en: '`fractions`: Import the `Fraction` class to work with a precise rational fraction
    value.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fractions`：导入`Fraction`类以处理精确的有理分数值。'
- en: '`random`: This module contains the essential random number generator. It has
    a number of other functions to produce random values in various ranges or with
    various constraints. For example `random.gauss()` produces a Gaussian, normal
    distribution of floating-point values.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random`：这个模块包含基本的随机数生成器。它有许多其他函数可以产生各种范围或具有各种约束的随机值。例如`random.gauss()`产生高斯、正态分布的浮点数值。'
- en: 'The three main ways of importing from these libraries are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些库中导入的主要方式如下：
- en: '`import random`: We use this when we want to be perfectly explicit about the
    origin of a name elsewhere in our code. We''ll be writing code similar to `random.gauss()`
    and `random.randint()` using the module name as an explicit qualifier.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import random`：当我们想明确指出代码中某个名称的来源时，我们会使用这个。我们将编写类似于`random.gauss()`和`random.randint()`的代码，使用模块名称作为明确的限定符。'
- en: '`from random import gauss, randint`: This introduces two selected names from
    the `random` module into the global namespace. We can use `gauss()` and `randint()`
    without a qualifying module name.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from random import gauss, randint`：这将从`random`模块中引入两个选定的名称到全局命名空间。我们可以使用`gauss()`和`randint()`而不需要限定模块名称。'
- en: '`from random import *`: This will introduce all of the available names in the
    `random` module as globals in our application. This is helpful for exploring and
    experimenting at the `>>>` prompt. This may not be appropriate in a larger program
    because it can introduce a large number of irrelevant names.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from random import *`：这将把`random`模块中所有可用的名称引入我们的应用程序的全局命名空间。这在探索和实验`>>>`提示符时很有帮助。这可能不适合在更大的程序中使用，因为它可能会引入大量无关的名称。'
- en: A less-commonly used feature allows us to rename objects brought in via the
    `import` statement. We might want to use `from cmath import sqrt as csqrt` to
    rename the `cmath.sqrt()` function to `csqrt()`. We have to be careful to avoid
    ambiguity and confusion when using this `import-as` renaming feature.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不太常用的功能允许我们重命名通过`import`语句引入的对象。我们可能想使用`from cmath import sqrt as csqrt`来将`cmath.sqrt()`函数重命名为`csqrt()`。在使用这个`import-as`重命名功能时，我们必须小心避免歧义和混淆。
- en: Using bits and Boolean values
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位和布尔值
- en: As noted earlier, the bit-oriented operators `&`, `|`, `^`, and `~` have nothing
    to do with Python's actual Boolean operators `and`, `or`, `not`, and `if-else`.
    We'll look at Boolean values, logic operators, and related programming in [Chapter
    5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"), *Logic, Comparisons,
    and Conditions*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，位运算符`&`、`|`、`^`和`~`与Python的实际布尔运算符`and`、`or`、`not`和`if-else`没有任何关系。我们将在[第5章](ch05.html
    "第5章。逻辑、比较和条件")中探讨布尔值、逻辑运算符和相关编程，*逻辑、比较和条件*。
- en: 'If we misuse the bit-oriented operators `&` or `|` in place of a logical `and`
    or `or`, things may appear very peculiar:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用位运算符`&`或`|`代替逻辑运算符`and`或`or`，事情可能会显得非常奇怪：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first example is clearly wrong. Why? This is because the `&` operator has
    relatively high priority. It''s not a logical connective, it''s more like an arithmetic
    operator. The `&` operator is performed first: `6&3` evaluates to 2\. Given this,
    the resulting expression, `5 > 2 > 1`, is `True`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子显然是错误的。为什么？这是因为`&`运算符的优先级相对较高。它不是一个逻辑连接符，更像是一个算术运算符。`&`运算符首先执行：`6&3`的结果是2。因此，结果表达式`5
    > 2 > 1`是`True`。
- en: When we group the comparisons to perform them first, we'll get a `False` for
    `5>6`, and a `True` for `3>1`. When we apply the `&` operator the result will
    be `False`, which is what we expected. Using bit operators inappropriately as
    logical connectives can work if we use parentheses to be sure that the bit operators
    are performed last. It's a very bad idea, however.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将比较分组以首先执行时，我们将得到`5>6`的`False`和`3>1`的`True`。当我们应用`&`运算符时，结果将是`False`，这正是我们所期望的。如果我们使用括号确保位运算符最后执行，那么不适当地将位运算符用作逻辑连接词可能会工作。然而，这是一个非常糟糕的想法。
- en: It's easier, clearer, and altogether better to use the proper Boolean operators
    shown in [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"),
    *Logic, Comparisons, and Conditions*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[第5章](ch05.html "第5章。逻辑、比较和条件")中展示的正确布尔运算符更容易、更清晰，总体上更好。
- en: Working with sequences
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与序列一起工作
- en: In this chapter, we'll introduce Python sequence collections. We'll look at
    strings and tuples as the first two examples of this class. Python offers a number
    of other sequence collections; we'll look at them in [Chapter 6](ch06.html "Chapter 6. More
    Complex Data Types"), *More Complex Data Types*. All of these sequences have common
    features.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Python序列集合。我们将以字符串和元组作为此类的前两个示例。Python提供了一系列其他序列集合；我们将在[第6章](ch06.html
    "第6章。更复杂的数据类型")中探讨它们，*更复杂的数据类型*。所有这些序列都有共同的特征。
- en: 'Python sequences identify the individual elements by position. Position numbers
    start with zero. Here''s a `tuple` collection with five elements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python序列通过位置标识单个元素。位置数字从零开始。以下是一个包含五个元素的`tuple`集合：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In addition to the expected ascending numbers, Python also offers reverse numbering.
    Position `-1` is the end of the sequence:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预期的升序数字外，Python还提供了反向编号。位置`-1`是序列的末尾：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that position 3 (or -2) has a value of `None`. The REPL doesn''t display
    the `None` object, so the value of `t[-2]` appears to be missing. For more visible
    evidence that this value is `None`, use this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，位置3（或-2）的值为`None`。REPL不会显示`None`对象，所以`t[-2]`的值看起来是缺失的。为了更明显地证明这个值是`None`，请使用以下方法：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The sequences use an extra comparison operator, `in`. We can ask if a given
    value occurs in a collection:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 序列使用一个额外的比较运算符`in`。我们可以询问给定值是否出现在集合中：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Slicing and dicing a sequence
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片和切块序列
- en: 'We can extract a subsequence, called a **slice**, from a sequence using more
    complex subscript expressions. Here''s a substring of a longer string:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更复杂的下标表达式从序列中提取一个子序列，称为**切片**。以下是一个较长字符串的子字符串：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `[5:10]` expression is a slice which starts at position 5 and extends to
    the position before 10\. Python generally relies on "half-open" intervals. The
    starting position of a slice is included whereas the stop position is excluded.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`[5:10]`表达式是一个从位置5开始并延伸到位置10之前的切片。Python通常依赖于“半开”区间。切片的起始位置包括在内，而停止位置不包括在内。'
- en: We can omit the starting position from a slice, writing `[:pos]`. If the start
    value of a slice is omitted, it's 0\. We can omit the ending, also, writing it
    as `[pos:]`. If the stop value of a slice is omitted, it's the length of the sequence,
    given by the `len()` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从切片中省略起始位置，写作`[:pos]`。如果省略切片的起始值，则默认为0。我们也可以省略结束，写作`[pos:]`。如果省略切片的停止值，则默认为序列的长度，由`len()`函数给出。
- en: 'The way that Python uses these half-open intervals means that we can partition
    a string with very tidy syntax:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用这些半开区间的方式意味着我们可以用非常整洁的语法对字符串进行分区：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, we've taken the first five characters in the first slice. We've
    taken everything after the first five characters in the second slice. Since the
    numbers are both five, we can be completely sure that the entire string is accounted
    for.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在第一个切片中取了前五个字符。我们在第二个切片中取了第一个五个字符之后的所有内容。由于这两个数字都是五，我们可以完全确信整个字符串都被考虑在内。
- en: 'And yes, we can omit both values from the slice: `"word"[:]` will create a
    copy of the entire string. This is an odd but sometimes useful construct for duplicating
    an object.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以从切片中省略两个值：`"word"[:]`将创建整个字符串的副本。这是一个奇特但有时有用的结构，用于复制对象。
- en: 'There''s a third parameter to a slice. We generally call the positions **start**,
    **stop**, and **step**. The step size is 1 by default. We can use a form such
    as `"abcdefg"[::2]` to provide an explicit step, and pick characters in positions
    0, 2, 4, and 6\. The form `"abcdefg"[1::2]` will pick the odd positions: 1, 3,
    and 5.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 切片有一个第三个参数。我们通常称这些位置为**起始位置**、**结束位置**和**步长**。默认步长为1。我们可以使用类似`"abcdefg"[::2]`的形式来提供一个显式的步长，并选择位置为0、2、4和6的字符。形式`"abcdefg"[1::2]`将选择奇数位置：1、3和5。
- en: The step size can also be negative. This will enumerate the index values in
    reverse order. The value of `"word"[::-1] is 'drow'`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 步长也可以是负数。这将按相反的顺序枚举索引值。`"word"[::-1]`的值是`'drow'`。
- en: Using string and bytes values
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符串和字节值
- en: 'Python string values are similar—in some respects—to simple numeric types.
    There are a few arithmetic-like operators available and all of the comparisons
    are defined. Strings are immutable: we cannot change a string. We can, however,
    easily build new strings from existing strings, making the mutability question
    as irrelevant for string objects as it is for number objects. Python has two kinds
    of string values:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串值在某些方面与简单的数值类型相似。有一些类似算术的运算符可用，所有的比较操作都定义了。字符串是不可变的：我们无法更改字符串。然而，我们可以轻松地从现有字符串构建新的字符串，使得字符串对象的可变性问题和数字对象的可变性问题一样无关紧要。Python有两种字符串值：
- en: '**Unicode**: These strings use the entire Unicode character set. These are
    the default strings Python uses. The input-output libraries are all capable of
    a wide variety of Unicode encoding and decoding. The name for this type is `str`.
    It''s a built-in type, so it starts with a lowercase letter.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unicode**：这些字符串使用整个Unicode字符集。这是Python默认使用的字符串。输入输出库都支持广泛的Unicode编码和解码。这种类型的名称是`str`。它是一个内置类型，因此以小写字母开头。'
- en: '**Bytes**: Many file formats and network protocols are defined over bytes,
    not Unicode characters. Python uses ASCII encoding for bytes. Special arrangements
    must be made to process bytes. The internal type name is `bytes`.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字节**：许多文件格式和网络协议是基于字节定义的，而不是基于Unicode字符。Python使用ASCII编码来处理字节。处理字节时必须做出特殊安排。内部类型名称是`bytes`。'
- en: We can easily encode Unicode into a sequence of bytes. We can just as easily
    decode a sequence of bytes to see the Unicode characters. We'll show these two
    methods in the *Converting between Unicode and bytes* section, after we've looked
    at literals and operators.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将Unicode编码成一系列字节。我们同样可以轻松地将一系列字节解码以查看Unicode字符。我们将在查看字面量和运算符之后，在*在Unicode和字节之间转换*部分展示这两种方法。
- en: Writing string literals
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写字符串字面量
- en: 'String literals are characters surrounded by string delimiters. Python offers
    a variety of string delimiters to solve a variety of problems. The most common
    literals create Unicode strings:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量是由字符串分隔符包围的字符。Python提供了各种字符串分隔符来解决各种问题。最常见的字面量创建Unicode字符串：
- en: '**Short string**: Use either `"` or `''` to surround the string. For example:
    `"Don''t Touch"` has an embedded apostrophe. `''Speak "friend" and enter''` has
    embedded quotes. In the rare cases where we have both, we can use `\` to avoid
    a quote: `''"Don\''t touch," he said.''` uses apostrophes as delimiters, and an
    escaped apostrophe within the string. While a string literal must be complete
    on a single line, a `''\n''` will expand into a proper newline character internally.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短字符串**：使用`"`或`''`来包围字符串。例如：`"Don''t Touch"`包含一个嵌入的撇号。`''Speak "friend" and
    enter''`包含嵌入的引号。在罕见的情况下，如果我们两者都有，我们可以使用`\`来避免引号：`''"Don\''t touch," he said.''`使用撇号作为分隔符，并在字符串内部使用转义撇号。虽然字符串字面量必须在单行上完整，但`''\n''`在内部会扩展成一个正确的换行符。'
- en: '**Long string**: Use either `"""` or `''''''` to surround a multi-line string.
    The string can span as many lines as necessary. A long string can include any
    characters except for the terminating triple-quote or triple-apostrophe.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长字符串**：使用`"""`或`''''''`来包围多行字符串。字符串可以跨越必要的行数。长字符串可以包含任何字符，除了终止的三重引号或三重撇号。'
- en: Python has a moderate number of `\` escape sequences to allow us to enter characters
    that aren't possible from a keyboard. If we use ordinary `str` literals, Python
    replaces all the escape sequences with proper Unicode characters. In an ordinary
    `bytes` literal, each escape sequence becomes a one-byte ASCII character.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Python有适量的`\`转义序列，允许我们输入无法从键盘输入的字符。如果我们使用普通的`str`字面量，Python会将所有转义序列替换为正确的Unicode字符。在一个普通的`bytes`字面量中，每个转义序列都变成一个单字节ASCII字符。
- en: 'Many Python programs are saved as pure ASCII text, but this is not a requirement.
    When saving a file in ASCII, escapes will be required for non-ASCII Unicode characters.
    When saving files in Unicode, then relatively few escapes are required, since
    any Unicode character available on our keyboard can be entered directly. Here
    are two examples of the same string:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python程序以纯ASCII文本保存，但这不是必需的。当以ASCII保存文件时，需要转义非ASCII Unicode字符。当以Unicode保存文件时，则需要相对较少的转义，因为键盘上可用的任何Unicode字符都可以直接输入。以下是相同字符串的两个示例：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first string uses Unicode characters; the file must be saved in the appropriate
    encoding, such as UTF-8, for this to work. The second string uses escape sequences
    to describe the Unicode characters. The `\u` sequence is followed by a four-digit
    hex value. The `\N{...}` escape allows the name of the character. A `\U` escape—not
    shown in the example—requires an 8-digit hex value. The second example can be
    saved in any encoding, including ASCII.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一字符串使用Unicode字符；为了使此功能正常工作，文件必须以适当的编码保存，例如UTF-8。第二个字符串使用转义序列来描述Unicode字符。`\u`序列后面跟着一个四位十六进制值。`\N{...}`转义允许字符的名称。`\U`转义（在示例中没有显示）需要一个八位十六进制值。第二个示例可以保存为任何编码，包括ASCII。
- en: The most commonly-used escape sequences are `\"`, `\'`, `\n`, `\t`, and `\\`
    to create a quote inside a quoted string, an apostrophe inside an apostrophe delimited
    string, a newline, a tab, and a `\` character. There are a few others, but their
    meanings are so obscure that numeric codes usually make more sense. For example,
    `\v`, should probably be written as `\x0b` or `\u000b`; the original meaning behind
    `\v` is largely lost to history.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的转义序列是`\"`、`\'`、`\n`、`\t`和`\\`，用于在引号字符串内创建引号，在单引号分隔的字符串内创建撇号，换行，制表符和一个`\`字符。还有一些其他的，但它们的含义如此晦涩，通常数字代码更有意义。例如，`\v`可能应该写成`\x0b`或`\u000b`；`\v`背后的原始含义在很大程度上已经失传。
- en: Note that `'\u000b'` is replaced by the actual Unicode character. We also have
    `'\u240b'` which is a Unicode glyph, '![Writing string literals](img/B03671_02_09.jpg)',
    that symbolizes that vertical tab character. Most of the non-printing ASCII control
    characters also have these symbolic glyphs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`'\u000b'`被替换为实际的Unicode字符。我们还有`'\u240b'`，这是一个Unicode符号，'![写入字符串字面量](img/B03671_02_09.jpg)'，表示垂直制表符字符。大多数非打印ASCII控制字符也有这些符号表示。
- en: Using raw string literals
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原始字符串字面量
- en: Sometimes, we need to provide strings in which the `\` character is not an escape
    character. When preparing regular expressions, for example, we prefer not be forced
    to write `\\` to represent a single `\` character. Similarly, when working with
    Windows filenames, we don't want `"C:\temp"` to have an ASCII horizontal tab character
    (`'\u0008'`) replace the `'\t'` sequence of characters in the middle of the string
    literal. We could write `"C:\\temp"` but it seems error-prone.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要提供`\`字符不是转义字符的字符串。例如，在准备正则表达式时，我们宁愿不被迫写`\\`来表示单个`\`字符。同样，当与Windows文件名一起工作时，我们不希望`"C:\temp"`中的ASCII水平制表符字符（`'\u0008'`）替换字符串字面量中间的`'\t'`序列。我们可以写成`"C:\\temp"`，但这似乎容易出错。
- en: 'To avoid this escape processing, Python offers the **raw string**. We can prefix
    any of the previous four flavors of delimiters with the letter `r` or `R`. For
    example, `r''\b[a-zA-Z_]\w+\b''`, is a raw string. The `\` characters will be
    left intact by Python: the ''`\b`'' sequences are not translated to ''`\u0008`''
    characters.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种转义处理，Python提供了**原始字符串**。我们可以将前四种分隔符中的任何一种前缀加上字母`r`或`R`。例如，`r'\b[a-zA-Z_]\w+\b'`是一个原始字符串。Python将保留`\`字符：`\b`序列不会被转换为`\u0008`字符。
- en: 'If we do this *without* using the `r"` character as the raw string delimiter,
    we''ll create a string literal equivalent to this: `''\x08[a-zA-Z_]\\w+\x08''`.
    This shows how a ''`\b`'' characters are transformed to ''`\x08`'' in a non-raw
    string. Omitting the leading `r''` leads to a string that does not represent the
    regular expression we intended.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用`r"`字符作为原始字符串的分隔符来做这件事，我们将创建一个与以下等效的字符串字面量：`'\x08[a-zA-Z_]\\w+\x08'`。这显示了在非原始字符串中`\b`字符是如何转换为`\x08`的。省略开头的`r'`会导致一个不表示我们意图的正则表达式的字符串。
- en: Using byte string literals
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字节字符串字面量
- en: We may need to include byte strings in our programs as well as Unicode strings.
    In order to do this, we use a prefix of `b` or `B` in front of the string delimiter.
    A byte string is limited to ASCII characters and escape sequences that produce
    single-byte ASCII characters.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要在我们的程序中包含字节字符串以及Unicode字符串。为了做到这一点，我们在字符串分隔符前使用`b`或`B`前缀。字节字符串限于ASCII字符和产生单个字节ASCII字符的转义序列。
- en: Generally, byte strings focus on the hexadecimal escape, `\xhh`, with two hex
    digits for byte strings. We can also use the octal escape, `\odd`, with octal
    digits.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，字节字符串关注十六进制转义，`\xhh`，对于字节字符串使用两个十六进制数字。我们也可以使用八进制转义，`\odd`，使用八进制数字。
- en: 'We can also prepare raw byte strings using any combination of `r` or `R` paired
    with `b` or `B` as a prefix to the string. Here''s a regular expression in ASCII
    bytes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`r`或`R`与`b`或`B`结合作为字符串前缀的任何组合来准备原始字节字符串。以下是一个ASCII字节中的正则表达式：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output is in Python's canonical notation using lengthy escapes for the '`\\`'
    regular expression pattern.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出使用Python的规范表示法，使用长转义序列表示`'\\'`正则表达式模式。
- en: To be fastidious, we are also able to use a `u"` prefix to indicate that a given
    string is explicitly Unicode. This is relatively rare because it restates the
    default assumption. It can come in handy in a program where byte strings predominate;
    the use of `u"some string"` can make the Unicode literal stand out from numerous
    `b"bytes"` literals.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了严谨，我们还可以使用`u"`前缀来明确表示给定的字符串是Unicode。这相对较少见，因为它重申了默认假设。在以字节字符串为主体的程序中，使用`u"some
    string"`可以使Unicode字面量从众多的`b"bytes"`字面量中脱颖而出。
- en: Using the string operators
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字符串运算符
- en: 'Two of the arithmetic operators, `+` and `*`, are defined for both classes
    of string objects, `str` and `bytes`. We can use the `+` operator to concatenate
    two string objects, creating a longer string. Interestingly, we can use the `*`
    operator to multiply a string and an integer to create a longer string: `"="*3`
    is `''===''`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 两个算术运算符`+`和`*`在字符串对象的两类`str`和`bytes`中都有定义。我们可以使用`+`运算符来连接两个字符串对象，创建一个更长的字符串。有趣的是，我们可以使用`*`运算符将字符串与整数相乘以创建一个更长的字符串：`"="*3`是`'==='`。
- en: 'Additionally, adjacent string literals are combined into a larger string during
    code parsing. Here''s an example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，相邻的字符串字面量在代码解析期间合并为一个更大的字符串。以下是一个示例：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since this happens at parse time, it only works for string literals. For variables
    or other expressions, there must be a proper `+` operator.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这发生在解析时间，它仅适用于字符串字面量。对于变量或其他表达式，必须使用正确的`+`运算符。
- en: All of the comparison operators work for strings. The comparison operators compare
    two strings, character by character. We'll look at this in detail in [Chapter
    5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"), *Logic, Comparisons,
    and Conditions*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有比较运算符都适用于字符串。比较运算符逐字符比较两个字符串。我们将在[第五章](ch05.html "第五章。逻辑、比较和条件")中详细探讨这一点，*逻辑、比较和条件*。
- en: We cannot use string operators with mixed types of operands. Using `"hello"
    + b"world"` will raise a `TypeError` exception. We must either encode the Unicode
    `str` into `bytes`, or decode the `bytes` into a Unicode `str` object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用混合类型的操作数与字符串运算符。使用`"hello" + b"world"`将引发`TypeError`异常。我们必须将Unicode `str`编码为`bytes`，或者将`bytes`解码为Unicode
    `str`对象。
- en: 'Strings are sequence collections. We can extract characters and slices from
    them. Strings also work with the `in` operator. We can ask if a particular character
    or a substring occurs in a string like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是序列集合。我们可以从中提取字符和切片。字符串还与`in`运算符一起工作。我们可以询问特定的字符或子字符串是否出现在字符串中，如下所示：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first example shows the typical use for the `in` operator: checking to
    see if a given item is in the collection. This use of `in` applies to many other
    kinds of collections. The second example shows a feature that is unique to strings:
    we''re looking for a given substring in a longer string.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子显示了`in`运算符的典型用法：检查给定项是否在集合中。这种`in`的用法适用于许多其他类型的集合。第二个例子显示了字符串特有的功能：我们在较长的字符串中寻找给定的子字符串。
- en: Converting between Unicode and bytes
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Unicode和字节之间转换
- en: Most of the Python I/O libraries are aware of OS file encodings. When working
    with text files, we rarely need to explicitly provide encoding. We'll examine
    the details of Python's input-output capabilities in [Chapter 10](ch10.html "Chapter 10. Files,
    Databases, Networks, and Contexts"), *Files, Databases, Networks, and Contexts*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python I/O库都了解操作系统文件编码。当处理文本文件时，我们很少需要显式提供编码。我们将在[第10章](ch10.html "第10章。文件、数据库、网络和上下文")*文件、数据库、网络和上下文*中检查Python输入输出能力的细节。
- en: 'When we need to encode Unicode characters as a string of bytes, we use the
    `encode()` method of a string. Here''s an example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要将Unicode字符编码为字节字符串时，我们使用字符串的`encode()`方法。以下是一个示例：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've provided a literal Unicode string, and encoded this into UTF-8 bytes.
    Python has numerous encoding schemes, all defined in the `codecs` module.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个字面Unicode字符串，并将其编码为UTF-8字节。Python有众多的编码方案，所有这些都在`codecs`模块中定义。
- en: 'To decode the Unicode string represented by a string of bytes, we use the `decode()`
    method of the bytes. Here''s an example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解码由字节字符串表示的Unicode字符串，我们使用字节的`decode()`方法。以下是一个示例：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We've provided a byte string with eleven individually hex-encoded bytes. We
    decoded this to include six Unicode characters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个包含十一个单独十六进制编码字节的字节字符串。我们将这些解码以包含六个Unicode字符。
- en: Note that there are several aliases for the supported encodings. We've used
    `"utf-8"` and `"UTF-8"`. There are still more explained in the `codecs` chapter
    of the *Python Standard Library*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于支持的编码有多个别名。我们使用了`"utf-8"`和`"UTF-8"`。在*Python标准库*的`codecs`章节中还有更多解释。
- en: The `ASCII` codec is the most commonly used of these. In addition to `ASCII`,
    many strings and text files are encoded in `UTF-8`. When downloading data from
    the Internet, there's often a header or other indicator that provides the encoding,
    in the rare case that it's not `UTF-8`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`ASCII`编解码器是这些中最常用的。除了`ASCII`之外，许多字符串和文本文件都编码为`UTF-8`。在从互联网下载数据时，通常有一个标题或其他指示符提供编码，在极少数情况下，它不是`UTF-8`。'
- en: In some cases, we have a document which in bytes, written in traditional ASCII.
    To work with ASCII files, we convert the bytes from the ASCII encoding to Unicode
    characters. Similarly, we can encode a subset of Unicode characters using the
    ASCII encoding instead of UTF-8.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们有一个以字节形式编写的文档，使用传统的ASCII。为了处理ASCII文件，我们将从ASCII编码的字节转换为Unicode字符。同样，我们可以使用ASCII编码而不是UTF-8来编码Unicode字符的子集。
- en: 'It''s possible that a given sequences of bytes does not properly encode Unicode
    characters. This may be because the wrong encoding was used to decode the bytes.
    Or it could be because the bytes are incorrect. The `decode()` method has additional
    parameters to define what to do when the bytes cannot be decoded. The values for
    the errors argument are strings:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在这样的情况，即给定的字节序列未能正确编码Unicode字符。这可能是因为使用了错误的编码来解码字节。或者可能是字节本身不正确。`decode()`方法有额外的参数来定义当字节无法解码时应该做什么。错误参数的值是字符串：
- en: '`"strict"` means that exceptions are raised. This is the default.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"strict"`表示将引发异常。这是默认值。'
- en: '`"ignore"` means that invalid bytes will be skipped.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"ignore"`表示将跳过无效的字节。'
- en: '`"replace"` means that a default character will be inserted. This is defined
    in the `codecs` module. The `''\ufffd''` character is the default replacement.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"replace"`表示将插入默认字符。这在`codecs`模块中定义。`''\ufffd''`字符是默认替换字符。'
- en: The choice of error handling is highly application-specific.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理的选项非常特定于应用程序。
- en: Using string methods
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字符串方法
- en: 'A string object has a large number of method functions. Most of these apply
    both to `str` and `bytes` objects. These can be separated into four groups:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象有大量的方法函数。其中大部分既适用于`str`对象也适用于`bytes`对象。这些可以分成四组：
- en: '**Transformers**: which create new strings from old strings'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换器**：从旧字符串创建新字符串'
- en: '**Creators**: which create a string from a non-string object(s)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建器**：从非字符串对象（或多个对象）创建字符串'
- en: '**Accessors**: which access a string and return a fact about that string'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问器**：访问字符串并返回有关该字符串的事实'
- en: '**Parsers**: which examine a string and decompose the string, or create new
    data objects from the string'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析器**：检查字符串并将其分解，或从字符串创建新的数据对象'
- en: 'The transformer group of method functions includes `capitalize()`, `center()`,
    `expandtabs()`, `ljust()`, `lower()`, `rjust()`, `swapcase()`, `title()`, `upper()`,
    and `zfill()`. These methods all make general changes to the characters of a string
    to create a transformed result. Methods such as `lower()` and `upper()` are used
    frequently to normalize case for comparisons:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 方法函数的转换器组包括 `capitalize()`、`center()`、`expandtabs()`、`ljust()`、`lower()`、`rjust()`、`swapcase()`、`title()`、`upper()`
    和 `zfill()`。这些方法都对字符串中的字符进行一般性更改以创建转换后的结果。例如，`lower()` 和 `upper()` 方法经常用于比较时规范化大小写：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using this technique allows us to write programs which are more tolerant of
    character strings with minor errors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术可以让我们编写对字符字符串中的小错误更加宽容的程序。
- en: Additional transformers include functions such as `strip()`, `rstrip()`, `lstrip()`,
    and `replace()`. The functions in the strip family remove whitespace. It's common
    to use `rstrip()` on input lines to remove any trailing spaces and the trailing
    newline character which might be present.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其他转换器包括 `strip()`、`rstrip()`、`lstrip()` 和 `replace()` 等函数。strip 家族的函数用于删除空白字符。通常在输入行上使用
    `rstrip()` 来删除任何尾随空格和可能存在的尾随换行符。
- en: The `replace()` function replaces any substring with another substring. If we
    want to do multiple independent replacements, we can do something like this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace()` 函数用于将任何子字符串替换为另一个子字符串。如果我们想进行多次独立的替换，我们可以这样做。'
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will create an intermediate string with the "`$`" removed. It will create
    a second intermediate string from that with the `,` character removed. This kind
    of processing is handy for cleaning up raw data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个中间字符串，其中已移除 "`$`"。它将从这个中间字符串中创建第二个中间字符串，其中已移除 `,` 字符。这种处理对于清理原始数据很有用。
- en: Accessing the details of a string
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问字符串的详细信息
- en: We use accessor methods to determine facts about the string; the results may
    be Boolean or integer values. For example, the `count()` method returns a count
    of the number of places an argument substring or character was found in the object
    string.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用访问器方法来确定有关字符串的事实；结果可能是布尔值或整数值。例如，`count()` 方法返回在对象字符串中找到的参数子字符串或字符的次数。
- en: Some widely-used methods include the `find()`, `rfind()`, `index()`, and `rindex()`
    methods which will find the position of a substring in the object string. The
    `find()` methods return a special value of `-1` if the substring isn't found.
    The `index()` methods raise a `ValueError` exception if the substring isn't found.
    The "r" versions find the right-most occurrence of the target substring. All of
    these methods are available for both `str` and `bytes` objects.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的方法包括 `find()`、`rfind()`、`index()` 和 `rindex()` 方法，这些方法将在对象字符串中查找子字符串的位置。如果找不到子字符串，`find()`
    方法返回特殊值 `-1`。如果找不到子字符串，`index()` 方法会引发 `ValueError` 异常。带有 "r" 的版本查找目标子字符串的最右侧出现。所有这些方法都适用于
    `str` 和 `bytes` 对象。
- en: 'The `endswith()` and `startswith()` methods are Boolean functions; they examine
    the beginning or ending of a string. Here are some examples:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`endswith()` 和 `startswith()` 方法是布尔函数；它们检查字符串的开始或结束。以下是一些示例：'
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first example shows how we can check the ending of a string with the `endswith()`
    method. The second example shows how the `find()` method locates the offset of
    a given substring in a longer string. The third example shows show the `find()`
    method returns a signal value of -1 if the substring can't be found.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例显示了如何使用 `endswith()` 方法检查字符串的结尾。第二个示例显示了 `find()` 方法如何在较长的字符串中定位给定子字符串的偏移量。第三个示例显示了如果找不到子字符串，`find()`
    方法返回信号值 -1。
- en: Additionally, there are seven Boolean pattern-matching functions. These are
    `isalnum()`, `isalpha()`, `isdigit()`, `islower()`, `isspace()`, `istitle()`,
    and `isupper()`. These will return `True` if the function matches a given pattern.
    For example, `"13210".isdigit()` is `True`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有七个布尔模式匹配函数。这些是 `isalnum()`、`isalpha()`、`isdigit()`、`islower()`、`isspace()`、`istitle()`
    和 `isupper()`。如果函数与给定的模式匹配，则返回 `True`。例如，`"13210".isdigit()` 返回 `True`。
- en: Parsing strings into substrings
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字符串解析为子字符串
- en: There are a few method functions which we can use to decompose a string into
    substrings. We'll hold off on looking at `split()`, `join()`, and `partition()`
    in detail until [Chapter 3](ch03.html "Chapter 3. Expressions and Output"), *Expressions
    and Output*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法函数我们可以用来将字符串分解为子字符串。我们将在第 3 章[表达式和输出](ch03.html "第 3 章。表达式和输出")中详细查看 `split()`、`join()`
    和 `partition()`。
- en: As a quick overview, we'll note that `split()` splits a string into a sequence
    of strings based on locating a possibly repeating separator substring. We might
    use an expression such as `'01.03.05.15'.split('.')` to create the sequence `['01',
    '03', '05', '15']` from the longer string, by splitting on the '`.`' character.
    The `join()` method is the inverse of `split()`. That means that `"-".join(['01',
    '03', '05', '15'])` will create a new string from the individual strings and the
    separator; the result is `'01-03-05-15'`. The partition can be viewed as a single-item
    split to separate the head of a string from the tail.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速概述，我们将指出 `split()` 方法根据定位一个可能重复的分隔符子字符串将字符串分割成一系列字符串。我们可能使用这样的表达式 `'01.03.05.15'.split('.')`
    来从较长的字符串中创建序列 `['01', '03', '05', '15']`，通过在 '`.`' 字符上分割。`join()` 方法是 `split()`
    的逆操作。这意味着 `"-".join(['01', '03', '05', '15'])` 将从单个字符串和分隔符创建一个新的字符串；结果是 `'01-03-05-15'`。分区可以看作是一个单元素分割，用于将字符串的头部与尾部分开。
- en: Python's assignment statement deals very gracefully with such a method that
    returns more than one value. In [Chapter 4](ch04.html "Chapter 4. Variables, Assignment
    and Scoping Rules"), *Variables, Assignment and Scoping Rules*, we'll look at
    multiple assignment more closely.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的赋值语句处理返回多个值的这种方法非常优雅。在 [第 4 章](ch04.html "第 4 章。变量、赋值和作用域规则")，*变量、赋值和作用域规则*，我们将更详细地研究多重赋值。
- en: The `split()` method should not be used to parse filenames, nor should the `join()`
    method be used to build filenames. There's a separate module, `os.path`, which
    handles this properly by applying OS-specific rules.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 不应使用 `split()` 方法解析文件名，也不应使用 `join()` 方法构建文件名。有一个单独的模块 `os.path`，它通过应用 OS 特定的规则正确地处理这个问题。
- en: Using the tuple collection
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `tuple` 集合
- en: The `tuple` is one of the simplest collections available in Python. It is one
    of the many kinds of Python sequences. A tuple has a fixed number of items. For
    example, we might work with (*x*, *y*) coordinates or (*r*, *g*, *b*) colors.
    In these cases, the number of elements in each tuple is fixed by the problem domain.
    We don't want the flexibility of a collection that can vary in length.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple` 是 Python 中可用的最简单的集合之一。它是 Python 序列的多种类型之一。`tuple` 有一个固定数量的项。例如，我们可能处理
    (*x*, *y*) 坐标或 (*r*, *g*, *b*) 颜色。在这些情况下，每个 `tuple` 中的元素数量由问题域固定。我们不希望有一个长度可变的集合的灵活性。'
- en: 'Generally, we''ll include `()` around a `tuple` to set it apart from the surrounding
    syntax. This isn''t *always* required; Python creates `tuple` objects implicitly
    in some common contexts. However, it is always a good idea. If we write an assignment
    statement like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会在 `tuple` 的周围加上 `()` 来将其与周围的语法区分开来。这并不总是必需的；Python 在某些常见上下文中会隐式地创建 `tuple`
    对象。然而，这始终是一个好主意。如果我们编写一个这样的赋值语句：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This statement will implicitly create a 2-tuple, `(2, 3)`, and assign the object
    to the variable `a`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句将隐式地创建一个二元组 `(2, 3)`，并将对象赋值给变量 `a`。
- en: The `tuple` class is part of Python's family of `Sequence` classes; we can extract
    the items of a `tuple` using their positional indices. The `str` and `byte` classes
    are also examples of Sequence. In addition to simple index values, we can use
    slice notation to pick items from a `tuple`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple` 类是 Python 的 `Sequence` 类族的一部分；我们可以使用它们的索引位置提取 `tuple` 的项。`str` 和 `byte`
    类也是序列的例子。除了简单的索引值外，我们还可以使用切片符号从 `tuple` 中选择项。'
- en: 'The value `()` is a zero-length tuple. To create a singleton tuple, we must
    use `()` and include a `,` character: this means that `(12,)` is a singleton tuple.
    If we omit the `,` character we''ve written an expression, not a singleton tuple.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 值 `()` 是一个零长度的 `tuple`。要创建单元素 `tuple`，我们必须使用 `()` 并包含一个逗号字符：这意味着 `(12,)` 是一个单元素
    `tuple`。如果我们省略逗号字符，我们写的是一个表达式，而不是单元素 `tuple`。
- en: 'A trailing comma is *required* for a singleton tuple. An extra comma at the
    end of a tuple is quietly ignored everywhere else: `(1, 1, 2)` is equal to `(1,
    1, 2,)`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 单元素 `tuple` 必须有一个尾随的逗号。在 `tuple` 的末尾多出的逗号在其它地方会被静默忽略：`(1, 1, 2)` 等于 `(1, 1,
    2,)`。
- en: 'The `tuple` class offers only two method functions: `count()` and `index()`.
    We can count the number of occurrences of a given item in a `tuple`, and we can
    locate the position of an item in a `tuple`.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple` 类仅提供两种方法函数：`count()` 和 `index()`。我们可以计算一个给定项在 `tuple` 中出现的次数，并且可以定位一个项在
    `tuple` 中的位置。'
- en: The None object
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`None` 对象'
- en: One very simple kind of Python object is the `None` object. It has few methods,
    and there's only a single instance of this object available. It is a handy way
    to identify something as missing or not applicable. It's often used as a default
    value for optional parameters to a function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Python中非常简单的一种对象类型是`None`对象。它有几个方法，并且只有一个此类对象的实例可用。这是一个方便的方式来标识某些内容缺失或不适用。它通常用作函数可选参数的默认值。
- en: 'The `None` object is a singleton; there can be only one. This object is immutable:
    we can''t change it in any way.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`对象是一个单例；只能有一个。这个对象是不可变的：我们无法以任何方式更改它。'
- en: 'With the interactive use of Python, the REPL doesn''t print the `None` object.
    For example, when we evaluate the `print()` function, the proper result of this
    function is always `None`. The side-effect of this function is to print things
    on our console. Looking forward to [Chapter 3](ch03.html "Chapter 3. Expressions
    and Output"), *Expressions and Output*, we''ll give this quick example of a function
    that returns `None`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的交互式使用中，REPL不会打印`None`对象。例如，当我们评估`print()`函数时，此函数的正确结果始终是`None`。此函数的副作用是在我们的控制台上打印内容。展望[第3章](ch03.html
    "第3章。表达式和输出")，我们将给出一个返回`None`的函数的快速示例：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We've evaluated the `print()` function and saved the result of the print function
    in the `a` variable. The visible side-effect of printing is to see the string
    value displayed on the console. The result is the `None` object, which is not
    printed. We can, however, use the `is` comparison operator to see that the value
    of `a` really is the `None` object.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经评估了`print()`函数，并将打印函数的结果保存在`a`变量中。打印的可见副作用是在控制台上看到字符串值。结果是`None`对象，它不会被打印。然而，我们可以使用`is`比较运算符来查看`a`的值确实是`None`对象。
- en: The consequences of immutability
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性的后果
- en: 'Python has two broad flavors of objects: mutable and immutable. A mutable object
    has an internal state that can be updated by using operators or method functions.
    An immutable object''s state cannot be changed.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两种广泛的对象类型：可变和不可变。可变对象有一个内部状态，可以通过使用运算符或方法函数来更新。不可变对象的状态不能被更改。
- en: The canonical examples of immutable objects are the numbers. The number `2`
    must always have a single, immutable value midway between 1 and 3\. We can't change
    the state of `2` to make it `3` without making a mockery of the idea of mathematical
    truth.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象的典范例子是数字。数字`2`必须始终在1和3之间有一个单一的、不可变的价值。我们不能改变`2`的状态使其变为`3`，否则就是对数学真理概念的嘲讽。
- en: In [Chapter 6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex
    Data Types*, we'll look at a number of mutable data structures. The most important
    three mutable collections are `set`, `list`, and `dict`. These objects can have
    items added, and removed; we can change the state of the object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。更复杂的数据类型")中，我们将探讨许多可变数据结构。最重要的三个可变集合是`set`、`list`和`dict`。这些对象可以添加和删除项目；我们可以改变对象的状态。
- en: 'In addition to numbers being immutable, three other common structures are also
    immutable: `str`, `bytes`, and `tuple`. Because strings and bytes are immutable,
    the string manipulation methods will always create a new string object from one
    or more existing string objects.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数字是不可变的之外，还有三种其他常见的数据结构也是不可变的：`str`、`bytes`和`tuple`。因为字符串和字节是不可变的，所以字符串操作方法总是会从一个或多个现有的字符串对象创建一个新的字符串对象。
- en: 'This means we cannot mutate characters or substrings within a longer string.
    We might think we need to attempt something like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们无法在较长的字符串中修改字符或子字符串。我们可能会认为需要尝试类似以下操作：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But this can''t work because a string object is immutable. We always build
    new strings from the old string''s parts. We do it like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但这行不通，因为字符串对象是不可变的。我们总是从旧字符串的部分构建新的字符串。我们这样做：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This works by extracting pieces of the original string and including new characters
    mixed with the old.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过提取原始字符串的片段并包含新旧字符的混合来实现。
- en: Using the built-in conversion functions
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置的转换函数
- en: 'We have a number of conversion functions in the various types of data we''ve
    seen in this chapter. Each of the built-in numeric types has a proper constructor
    function. As with many Python functions, each of these has a number of different
    kinds of arguments it can handle:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了各种数据类型中的许多转换函数。每个内置的数值类型都有一个合适的构造函数。与许多Python函数一样，这些函数可以处理多种不同类型的参数：
- en: '`int()`: Creates an `int` from a wide variety of other objects'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int()`: 从各种其他对象创建`int`'
- en: '`int(3.718)` for another number'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int(3.718)`用于另一个数字'
- en: '`int(''48879'')` for a string in base 10'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int(''48879'')`用于十进制基数的字符串'
- en: '`int(''beef'', 16)` for a string in the given base—16 in this example'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int(''beef'', 16)`用于给定基数的字符串——在这个例子中是16'
- en: 'The `int()` function can ignore the extra prefix characters on numbers written
    in Python literal syntax: `int(''0b1010'',2)`, `int(''0xbeef'',16)`, and `int(''0o123'',8)`'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int()`函数可以忽略用Python字面量语法编写的数字上的额外前缀字符：`int(''0b1010'',2)`，`int(''0xbeef'',16)`，和`int(''0o123'',8)`'
- en: '`float()`: Creates a `float` from other objects'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float()`：从其他对象创建`float`'
- en: '`float(7331)` for another number'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float(7331)`用于另一个数字'
- en: '`float(''4.8879e5'')` for a decimal string'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float(''4.8879e5'')`用于十进制字符串'
- en: '`complex()`: Creates `complex` values from a variety of objects'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complex()`：从各种对象创建`complex`值'
- en: '`complex(23)` creates `(23+0j)`'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complex(23)`创建`(23+0j)`'
- en: '`complex(23, 3)` creates `(23+3j)`'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complex(23, 3)`创建`(23+3j)`'
- en: '`complex(''23+2j'')` creates `(23+2j)`'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complex(''23+2j'')`创建`(23+2j)`'
- en: 'We can convert single numbers, pairs of numbers, and even some strings into
    `Fraction` objects:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将单个数字、数字对，甚至某些字符串转换为`Fraction`对象：
- en: '`Fraction(2,3)`: This is the most common way to create `Fraction` objects.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fraction(2,3)`：这是创建`Fraction`对象最常见的方式。'
- en: '`Fraction(2.718)`: This creates a value `Fraction(765048986699563, 281474976710656)`.
    This shows how floating-point values are actually approximations. If we wanted
    a more accurate value, we should do a meaningful conversion ourselves, using `Fraction(2718,1000)`,
    which would avoid the error bits present in many floating-point values.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fraction(2.718)`：这创建了一个值`Fraction(765048986699563, 281474976710656)`。这表明浮点值实际上是近似值。如果我们想要一个更精确的值，我们应该自己进行有意义的转换，使用`Fraction(2718,1000)`，这将避免许多浮点值中存在的错误位。'
- en: '`Fraction("3/4")`: This also works very nicely to create a proper `Fraction`
    object.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fraction("3/4")`：这也非常好地创建了一个合适的`Fraction`对象。'
- en: When we convert a `float` value to a `Fraction`, the results look unusual. However,
    considering that float values are an approximation, the `Fraction` value reveals
    the nature of the approximation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将浮点值转换为`Fraction`时，结果看起来很奇怪。然而，考虑到浮点值是近似值，`Fraction`值揭示了近似值的本质。
- en: 'We can also convert integers, strings, and floats to `Decimal` objects:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将整数、字符串和浮点数转换为`Decimal`对象：
- en: '`Decimal(2)`: Interestingly, this produces `Decimal(''2'')` as the result.
    This shows us that the preferred format for `Decimal` values is strings.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decimal(2)`：有趣的是，这会产生`Decimal(''2'')`作为结果。这表明`Decimal`值的首选格式是字符串。'
- en: '`Decimal(''2.718'')`: This will produce the expected value. This is generally
    how we create `Decimal` objects.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decimal(''2.718'')`：这将产生预期的值。这通常是我们创建`Decimal`对象的方式。'
- en: '`Decimal(2.718)`: This will produce a value that reflects floating-point approximations:
    `Decimal(''2.717999999999999971578290569595992565155029296875'')`. Because of
    this, we generally avoid creating `Decimal` objects from `float` objects.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decimal(2.718)`：这将产生一个反映浮点近似值的值：`Decimal(''2.717999999999999971578290569595992565155029296875'')`。正因为如此，我们通常避免从`float`对象创建`Decimal`对象。'
- en: 'We have a number of additional conversions from numbers to various kinds of
    strings: `bin()`, `oct()`, `hex()`, and `str()` produce strings in base 2, 8,
    16, and 10 respectively. We can also use various formatting features of numbers
    using `"{0:b}".format(x)` for binary, `"{0:o}".format(x)` for octal, and `"{0:x}".format(x)`
    for hexadecimal. If we include the "`#`" modifier in the format string, we have
    considerable flexibility in the strings produced. For example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从数字到各种类型的字符串有几种额外的转换：`bin()`，`oct()`，`hex()`和`str()`分别产生2，8，16和10的基字符串。我们还可以使用数字的多种格式化功能，使用`"{0:b}".format(x)`进行二进制，`"{0:o}".format(x)`进行八进制，和`"{0:x}".format(x)`进行十六进制。如果我们包括格式字符串中的"`#`"修饰符，我们在产生的字符串中就有相当大的灵活性。例如：
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These functions show many different ways to create numbers from strings and
    create formatted strings from numbers.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数展示了从字符串创建数字以及从数字创建格式化字符串的许多不同方式。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've looked at some core data types available in Python. We've looked at five
    different kinds of numbers, including integers, floating-point, complex, `Fraction`
    and `Decimal`. Each fills a different niche. Three of these are built-in, the
    other two must be imported from the standard library.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了一些Python中可用的核心数据类型。我们查看了几种不同类型的数字，包括整数、浮点数、复数、`Fraction`和`Decimal`。每个都填补了不同的领域。其中三个是内置的，另外两个必须从标准库中导入。
- en: We've also looked at three different kinds of collections. The `tuple` is a
    simple sequence of items with relatively few methods. `str` is a Unicode string,
    which has several methods for creating new strings as transformations of existing
    strings. `bytes` is a byte string, which also has a variety of methods. We can
    decode bytes to create Unicode strings. We can encode Unicode strings into bytes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了三种不同类型的集合。`tuple`是一个相对简单且方法较少的项序列。`str`是一个Unicode字符串，它有几种方法可以创建新的字符串，作为现有字符串的转换。`bytes`是一个字节字符串，它也有各种方法。我们可以将字节解码为Unicode字符串。我们也可以将Unicode字符串编码为字节。
- en: We've touched on how the `import` statement is used to introduce new types and
    new modules. This will add features from the standard library.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何使用`import`语句来引入新的类型和模块。这将添加标准库中的功能。
- en: We've also looked at a number of functions to convert various numeric types.
    Many of these functions also convert strings to numbers. We'll make heavy use
    of `int()` and `float()` to convert strings to numbers. The reverse—converting
    numbers to strings—can be done with the `str()` function. It can be done better,
    however, with the formatting tools we'll look at in the next chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了多个函数，用于转换各种数值类型。许多这些函数也将字符串转换为数字。我们将大量使用`int()`和`float()`函数将字符串转换为数字。然而，使用`str()`函数进行反向转换——将数字转换为字符串——可以做得更好。然而，在下一章中，我们将探讨的格式化工具可以做得更好。
- en: In [Chapter 3](ch03.html "Chapter 3. Expressions and Output"), *Expressions
    and Output*, we'll build on these basic concepts. We'll look in more depth at
    Python language syntax. We'll also look at functions for creating nicely formatted
    output. This will allow us to write simple programs. In [Chapter 4](ch04.html
    "Chapter 4. Variables, Assignment and Scoping Rules"), *Variables, Assignment
    and Scoping Rules*, we'll add even more essential language features so that we
    can write more sophisticated programs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。表达式和输出")中，我们将在此基础上构建基本概念。我们将更深入地研究Python语言的语法。我们还将研究用于创建格式化输出的函数。这将使我们能够编写简单的程序。在第4章[第4章](ch04.html
    "第4章。变量、赋值和作用域规则")中，我们将添加更多基本语言特性，以便我们可以编写更复杂的程序。
