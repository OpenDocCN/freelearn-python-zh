- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python Data Types and Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data structures and algorithms are important components in the development of
    any software system. An algorithm can be defined as a set of step-by-step instructions
    to solve any given problem; an algorithm processes the data and produces the output
    results based on the specific problem. The data used by the algorithm to solve
    the problem has to be stored and organized efficiently in the computer memory
    for the efficient implementation of the software. The performance of the system
    depends upon the efficient access and retrieval of the data, and that depends
    upon how well the data structures that store and organize the data in the system
    are chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures deal with how the data is stored and organized in the memory
    of the computer that is going to be used in a program. Computer scientists should
    understand how efficient an algorithm is and which data structure should be used
    in its implementation. The Python programming language is a robust, powerful,
    and widely used language to develop software-based systems. Python is a high-level,
    interpreted, and object-oriented language that is very convenient to learn and
    understand the concepts of data structures and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we briefly review the Python programming language components
    that we will be using to implement the various data structures discussed in this
    book. For a more detailed discussion on the Python language in broader terms,
    take a look at the Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/reference/index.html](https://docs.python.org/3/reference/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/tutorial/index.html](https://docs.python.org/3/tutorial/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Python 3.10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Python development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of data types and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python’s collections module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Python 3.10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is an interpreted language: the statements are executed line by line.
    It follows the concepts of object-oriented programming. Python is dynamically
    typed, which makes it an ideal candidate among languages for scripting and fast-paced
    development on many platforms. Its source code is open source, and there is a
    very big community that is using and developing it continuously, at a very fast
    pace. Python code can be written in any text editor and saved with the `.py` file
    extension. Python is easy to use and learn because of its compactness and elegant
    syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the Python language will be used to write the algorithms, an explanation
    is provided of how to set up the environment to run the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is preinstalled on Linux- and Mac-based operating systems. However, you
    will want to install the latest version of Python, which can be done on different
    operating systems as per the following instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Windows operating system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Windows, Python can be installed through an executable `.exe` file.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.python.org/downloads/](https://www.python.org/downloads/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the latest version of Python—currently, it is 3.10.0—according to your
    architecture. If you have a 32-bit version of Windows, choose the 32-bit installer;
    otherwise, choose the 64-bit installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `.exe` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `python-3.10.0.exe` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to check **Add Python 3.10.0 to PATH**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Install Now** and then wait until the installation is complete; you
    can now use Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify that Python is installed correctly, open the Command Prompt and type
    the `python -–version` command. It should output `Python 3.10.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Linux-based operating systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Python on a Linux machine, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether you have Python preinstalled by entering the `python --version`
    command in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you do have not a version of Python, then install it through the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, verify that you have installed Python correctly by typing the `python3.10
    --version` command in the terminal. It should output `Python 3.10.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mac operating system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Python on a Mac, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.python.org/downloads/](https://www.python.org/downloads/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and open the installer file for `Python 3.10.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Install Now**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify that Python is installed correctly, open the terminal and type `python
    –version`. It should output `Python 3.10.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up a Python development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have installed Python successfully for your respective OS, you can
    start this hands-on approach with data structures and algorithms. There are two
    popular methods to set up the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setup via the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first method to set up the Python executing environment is via the command
    line, after installation of the Python package on your respective operating system.
    It can be set up using the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal on Mac/Linux OS or Command Prompt on Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the Python 3 command to start Python, or simply type `py` to start Python
    in the Windows Command Prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commands can be executed on the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Text, letter  Description automatically generated](img/B17217_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Screenshot of the command-line interface for Python'
  prefs: []
  type: TYPE_NORMAL
- en: The User Interface for the command-line execution environment is shown in *Figure
    1.1.*
  prefs: []
  type: TYPE_NORMAL
- en: Setup via Jupyter Notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second method to run the Python program is through Jupyter Notebook, which
    is a browser-based interface where we can write the code. The User Interface of
    Jupyter Notebook is shown in *Figure 1.2*. The place where we can write the code
    is called a “cell.”
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Screenshot of the Jupyter Notebook interface'
  prefs: []
  type: TYPE_NORMAL
- en: Once Python is installed, on Windows, Jupyter Notebook can be easily installed
    and set up using a scientific Python distribution called Anaconda by taking the
    following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Download the Anaconda distribution from [https://www.anaconda.com/products/individual](https://www.anaconda.com/products/individual).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install it according to the installation instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, on Windows, we can run the notebook by executing the `jupyter
    notebook` command at the Command Prompt. Alternatively, following installation,
    the `Jupyter Notebook` app can be searched for and run from the taskbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On Linux/Mac operating systems, Jupyter Notebook can be installed using `pip3`
    by running the following code in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After installation of Jupyter Notebook, we can run it by executing the following
    command at the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On some systems, this command does not work, depending upon the operating system
    or system configuration. In that case, Jupyter Notebook should start by executing
    the following command on the terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important to note that we will be using Jupyter Notebook to execute all
    the commands and programs throughout the book, but the code will also function
    in the command line if you’d prefer to use that.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of data types and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a problem, we can plan to solve it by writing a computer program or software.
    The first step is to develop an algorithm, essentially a step-by-step set of instructions
    to be followed by a computer system, to solve the problem. An algorithm can be
    converted into computer software using any programming language. It is always
    desired that the computer software or program be as efficient and fast as possible;
    the performance or efficiency of the computer program also depends highly on how
    the data is stored in the memory of a computer, which is then going to be used
    in the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data to be used in an algorithm has to be stored in variables, which differ
    depending upon what kind of values are going to be stored in those variables.
    These are called *data types*: an integer variable can store only integer numbers,
    and a float variable can store real numbers, characters, and so on. The variables
    are containers that can store the values, and the values are the contents of different
    data types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In most programming languages, variables and their data types must initially
    be declared, and then only that type of data can be statically stored in those
    variables. However, in Python, this is not the case. Python is a dynamically typed
    language; the data type of the variables is not required to be explicitly defined.
    The Python interpreter implicitly binds the value of the variable with its type
    at runtime. In Python, data types of the variable type can be checked using the
    function `type()`, which returns the type of variable passed. For example, if
    we enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example, demonstrates a variable that has a `var` float value,
    which is substituted for a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, every item of data is an object of a specific type. Consider the
    preceding example; here, when a variable `var` is assigned a value of `13.2`,
    the interpreter initially creates a float object having a value of `13.2`; a variable
    `var` then points to that object as shown in *Figure 1.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_01_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Variable assignment'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is an easy-to-learn object-oriented language, with a rich set of built-in
    data types. The principal built-in types are as follows and will be discussed
    in more detail in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Numeric types: `Integer (int)`, `float`, `complex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boolean types: `bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sequence types: `String (str)`, `range`, `list`, `tuple`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mapping types: `dictionary (dict)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set types: `set`, `frozenset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will divide these into basic (numeric, Boolean, and sequence) and complex
    (mapping and set) data types. In subsequent sections, we will discuss them one
    by one in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Basic data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic data types are numeric and Boolean types. We’ll cover those first,
    followed by sequence data types.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Numeric data type variables store numeric values. Integer, float, and complex
    values belong to this data type. Python supports three types of numeric types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer** (**int**): In Python, the interpreter takes a sequence of decimal
    digits as a decimal value, such as the integers `45`, `1000`, or `-25`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float**: Python considers a value having a floating-point value as a float
    type; it is specified with a decimal point. It is used to store floating-point
    numbers such as `2.5` and `100.98`. It is accurate up to `15` decimal points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex**: A complex number is represented using two floating-point values.
    It contains an ordered pair, such as a + *i*b. Here, a and b denote real numbers
    and *i* denotes the imaginary component. The complex numbers take the form of
    `3.0 + 1.3i`, `4.0i`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This provides a value of either `True` or `False`, checking whether any statement
    is true or false. `True` can be represented by any non-zero value, whereas `False`
    can be represented by 0\. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, the numeric values can be used as bool values using the built-in
    `bool()` function. Any number (integer, float, complex) having a value of zero
    is regarded as `False`, and a non-zero value is regarded as `True`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output of the above code will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Sequence data types are also a very basic and common data type, which we’ll
    look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sequence data types are used to store multiple values in a single variable
    in an organized and efficient way. There are four basic sequence types: string,
    range, lists, and tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A string is an immutable sequence of characters represented in single, double,
    or triple quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable means that once a data type has been assigned some value, it can’t
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The string type in Python is called `str`. A triple quote string can span into
    multiple lines that include all the whitespace in the string. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `+` operator concatenates strings, which returns a string after concatenating
    the operands, joining them together. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*` operator can be used to create multiple copies of a string. When it
    is applied with an integer (*n*, let’s say) and a string, the `*` operator returns
    a string consisting of *n* concatenated copies of the string. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Range
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `range` data type represents an immutable sequence of numbers. It is mainly
    used in `for` and `while` loops. It returns a sequence of numbers starting from
    a given number up to a number specified by the function argument. It is used as
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `start` argument specifies the start of the sequence, the `stop`
    argument specifies the end limit of the sequence, and the `step` argument specifies
    how the sequence should increase or decrease. This example Python code demonstrates
    the working of the range function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python lists are used to store multiple items in a single variable. Duplicate
    values are allowed in a list, and elements can be of different types: for example,
    you can have both numeric and string data in a Python list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The items stored in the list are enclosed within square brackets, `[]`, and
    separated with a comma, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The output of the above code will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The data element of the list is shown in *Figure 1.4*, showing the index value
    of each of the list items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17217_01_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Data elements of a sample list'
  prefs: []
  type: TYPE_NORMAL
- en: The characteristics of a list in Python are as follows. Firstly, the list elements
    can be accessed by its index, as shown in *Figure 1.4*. The list elements are
    ordered and dynamic. It can contain any arbitrary objects that are so desired.
    In addition, the `list` data structure is mutable, whereas most of the other data
    types, such as `integer` and `float` are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing as a list is a mutable data type, once created, the list elements can
    be added, deleted, shifted, and moved within the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the properties of lists are explained in *Table 1.1* below for greater
    clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| **Ordered** | The list elements are ordered in a sequence in which they are
    specified in the list at the time of defining them. This order does not need to
    change and remains innate for its lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Dynamic** | The list is dynamic. It can grow or shrink as needed by adding
    or removing list items. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **List elements can be any arbitrary set of objects** | List elements can
    be of the same type or varying data types. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **List elements can be accessed through an index** | Elements can be accessed
    using zero-based indexing in square brackets, similar to a string. Accessing elements
    in a list is similar to strings; negative list indexing also works in lists. A
    negative list index counts from the end of the list.Lists also support slicing.
    If `abc` is a list, the expression `abc[x:y]` will return the portion of elements
    from index `x` to index `y` (not including index `y`) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mutable** | Single list value: Elements in a list can be updated through
    indexing and simple assignment.Modifying multiple list values is also possible
    through slicing. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Other operators** | Several operators and built-in functions can also be
    applied in lists, such as `in`, `not in`, concatenation (`+`), and replication
    (`*`) operators. Moreover, other built-in functions, such as `len()`, `min()`,
    and `max()`, are also available. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1.1: Characteristics of list data structures with examples'
  prefs: []
  type: TYPE_NORMAL
- en: Now, while discussing list data types, we should first understand different
    operators, such as membership, identity, and logical operators, before discussing
    them and how they can be used in list data types or any other data types. In the
    coming section, we discuss how these operators work and are used in various data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Membership, identity, and logical operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python supports membership, identity, and logical operators. Several data types
    in Python support them. In order to understand how these operators work, we’ll
    discuss each of these operations in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Membership operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These operators are used to validate the membership of an item. Membership means
    we wish to test if a given value is stored in the sequence variable, such as a
    string, list, or tuple. Membership operators are to test for membership in a sequence;
    that is, a string, list, or tuple. Two common membership operators used in Python
    are `in` and `not` `in`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `in` operator is used to check whether a value exists in a sequence. It
    returns `True` if it finds the given variable in the specified sequence, and `False`
    if it does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The ‘`not in`'' operator returns to `True` if it does not find a variable in
    the specified sequence and `False` if it is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Identity operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Identity operators are used to compare objects. The different types of identity
    operators are `is` and `is` `not`, which are defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `is` operator is used to check whether two variables refer to the same
    object. This is different from the equality (`==`) operator. In the equality operator,
    we check whether two variables are equal. It returns `True` if both side variables
    point to the same object; if not, then it returns `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `is` `not` operator is used to check whether two variables point to the
    same object or not. `True` is returned if both side variables point to different
    objects, otherwise, it returns `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This section was about identity operators. Next, let us discuss logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These operators are used to combine conditional statements (`True` or `False`).
    There are three types of logical operators: `AND`, `OR`, and `NOT`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The logical `AND` operator returns True if both the statements are true, otherwise
    it returns False. It uses the following syntax: A and B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The logical `OR` operator returns True if any of the statements are true, otherwise
    it returns False. It uses the following syntax: A or B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The logical `NOT` operator is a Boolean operator, which can be applied to any
    object. It returns `True` if the object/operand is false, otherwise it returns
    `False`. Here, the operand is the unary expression/statement on which the operator
    is applied. It uses the following syntax: `not` `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we learned about different operators available in Python,
    and also saw how membership and identity operators can be applied to list data
    types. In the next section, we will continue discussing a final sequence data
    type: tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples are used to store multiple items in a single variable. It is a read-only
    collection where data is ordered (zero-based indexing) and unchangeable/immutable
    (items cannot be added, modified, removed). Duplicate values are allowed in a
    tuple, and elements can be of different types, similar to lists. Tuples are used
    instead of lists when we wish to store the data that should not be changed in
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples are written with round brackets and items are separated by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Tuples support `+` (concatenation) and `*` (repetition) operations, similar
    to strings in Python. In addition, a membership operator and iteration operation
    are also available in a tuple. Different operations that tuples support are listed
    in *Table 1.2:*
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Result** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '| Length |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '| Concatenation |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '| Repetition |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '| Membership |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '| Iteration |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.2: Example of tuple operations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples in Python support zero-based indexing, negative indexing, and slicing.
    To understand it, let’s take a sample tuple, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see examples of zero-based indexing, negative indexing, and slicing
    operations in *Table 1.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Result** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '| Zero-based indexing means that indexing starts from 0 rather than 1, and
    hence in this example, the first index refers to the second member of the tuple.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '| Negative: counting from the right-hand side. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '| Slicing fetches a section. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.3: Example of tuple indexing and slicing'
  prefs: []
  type: TYPE_NORMAL
- en: Complex data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed basic data types. Next, we discuss complex data types, which
    are mapping data types, in other words, dictionary, and set data types, namely,
    set and frozenset. We will discuss these data types in detail in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, a dictionary is another of the important data types, similar to a
    list, in the sense that it is also a collection of objects. It stores the data
    in unordered {key-value} pairs; a key must be of a hashable and immutable data
    type, and value can be any arbitrary Python object. In this context, an object
    is hashable if it has a hash value that does not change during its lifetime in
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Items in the dictionary are enclosed in curly braces, `{}`, separated by a
    comma, and can be created using the `{key:value}` syntax, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Keys in dictionaries are case-sensitive, they should be unique, and cannot
    be duplicated; however, the values in the dictionary can be duplicated. For example,
    the following code can be used to create a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 1.5* shows the `{key-value}` pairs created by the preceding piece of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_01_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Example dictionary data structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values in a dictionary can be fetched based on the key. For example: `my_dict[''1'']`
    gives `data` as the output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dictionary` data type is mutable and dynamic. It differs from lists in
    the sense that dictionary elements can be accessed using keys, whereas the list
    elements are accessed via indexing. *Table 1.4* shows different characteristics
    of the dictionary data structure with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Item** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Creating a dictionary, and accessing elements from a dictionary |'
  prefs: []
  type: TYPE_TB
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `in` and `not` `in` operators |'
  prefs: []
  type: TYPE_TB
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Length of the dictionary |'
  prefs: []
  type: TYPE_TB
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1.4: Characteristics of dictionary data structures with examples'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python also includes the dictionary methods as shown in *Table 1.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `mydict.clear()` | Removes all elements from a dictionary. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `mydict.get(<key>)` | Searches the dictionary for a key and returns the corresponding
    value, if it is found; otherwise, it returns `None`. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `mydict.items()` | Returns a list of dictionary items in (key, value) pairs.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `mydict.keys()` | Returns a list of dictionary keys. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `mydict.values()` | Returns a list of dictionary values. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `mydict.pop()` | If a given key is present in the dictionary, then this function
    will remove the key and return the associated value. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `mydict.popitem()` | This method removes the last key-value pair added in
    the dictionary and returns it as a tuple. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `mydict.update(<obj>)` | Merges one dictionary with another. Firstly, it
    checks whether a key of the second dictionary is present in the first dictionary;
    the corresponding value is then updated. If the key is not present in the first
    dictionary, then the key-value pair is added. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1.5: List of methods of dictionary data structures'
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A set is an unordered collection of hashable objects. It is iterable, mutable,
    and has unique elements. The order of the elements is also not defined. While
    the addition and removal of items are allowed, the items themselves within the
    set must be immutable and hashable. Sets support membership testing operators
    (`in, not in`), and operations such as intersection, union, difference, and symmetric
    difference. Sets cannot contain duplicate items. They are created by using the
    built-in `set()` function or curly braces `{}.` A `set()` returns a set object
    from an iterable. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that sets are unordered data structures, and the order
    of items in sets is not preserved. Therefore, your outputs in this section may
    be slightly different than those displayed here. However, this does not affect
    the function of the operations we will be demonstrating in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets are generally used to perform mathematical operations, such as intersection,
    union, difference, and complement. The `len()` method gives the number of items
    in a set, and the `in` and `not in` operators can be used in sets to test for
    membership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The most commonly used methods and operations that can be applied to `set`
    data structures are as follows. The union of the two sets, say, `x1` and `x2`,
    is a set that consists of all elements in either set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 1.6* shows a Venn diagram demonstrating the relationship between the
    two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram, venn diagram  Description automatically generated](img/B17217_01_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Venn diagram of sets'
  prefs: []
  type: TYPE_NORMAL
- en: 'A description of the various operations that can be applied on set type variables
    is shown, with examples, in *Table 1.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | **Example sample code** |'
  prefs: []
  type: TYPE_TB
- en: '| Union of two sets, `x1` and `x2`. It can be done using two methods, (1) using
    the `&#124;` operator, (2) using the `union` method. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Intersection of sets: to compute the intersection of two sets, an `&` operator
    and the `intersection()` method can be used, which returns a set of items common
    to both sets, `x1` and `x2`. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| The difference between sets can be obtained using `.difference()` and the
    subtraction operator, `-`, which returns a set of all elements that are in `x1`,
    but not in `x2`. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symmetric difference can be obtained using `.symmetric_difference()` , while
    `^` returns a set of all data items that are present in either `x1` or `x2`, but
    not both. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| To test whether a set is a subset of another, use `.issubset()` and the operator
    `<=`. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1.6: Description of various operations applicable to set type variables'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Python, `frozenset` is another built-in type data structure, which is, in
    all respects, exactly like a set, except that it is immutable, and so cannot be
    changed after creation. The order of the elements is also undefined. A `frozenset`
    is created by using the built-in function `frozenset()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Frozensets are useful when we want to use a set but require the use of an immutable
    object. Moreover, it is not possible to use set elements in the set, since they
    must also be immutable. Consider an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now with frozenset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, we create a set `x` of frozensets (`a1`, `a2`, and `a3`),
    which is possible because the frozensets are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the most important and popular data types available in Python.
    Python also provides a collection of other important methods and modules, which
    we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s collections module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `collections` module provides different types of containers, which are objects
    that are used to store different objects and provide a way to access them. Before
    accessing these, let’s consider briefly the role and relationships between modules,
    packages, and scripts.
  prefs: []
  type: TYPE_NORMAL
- en: A module is a Python script with the `.py` extension that contains a collection
    of functions, classes, and variables. A package is a directory that contains collections
    of modules; it has an `__init__.py` file, which lets the interpreter know that
    it is a package. A module can be called into a Python script, which can in turn
    make use of the module’s functions and variables in its code. In Python, we can
    import these to a script using the `import` statement. Whenever the interpreter
    encounters the `import` statement, it imports the code of the specified module.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 1.7* provides the data types and operations of the collections module
    and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Container data type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `namedtuple` | Creates a `tuple` with named fields similar to regular tuples.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `deque` | Doubly-linked lists that provide efficient adding and removing
    of items from both ends of the list. |'
  prefs: []
  type: TYPE_TB
- en: '| `defaultdict` | A `dictionary` subclass that returns default values for missing
    keys. |'
  prefs: []
  type: TYPE_TB
- en: '| `ChainMap` | A `dictionary` that merges multiple dictionaries. |'
  prefs: []
  type: TYPE_TB
- en: '| `Counter` | A `dictionary` that returns the counts corresponding to their
    objects/key. |'
  prefs: []
  type: TYPE_TB
- en: '| `UserDict UserList UserString` | These data types are used to add more functionalities
    to their base data structure, such as a `dictionary`, `list`, and `string`. And
    we can create subclasses from them for custom `dict`/`list`/`string`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.7: Different container data type of the collections module'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider these types in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Named tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `namedtuple` of `collections` provides an extension of the built-in tuple
    data type. `namedtuple` objects are immutable, similar to standard tuples. Thus,
    we can’t add new fields or modify existing ones after the `namedtuple` instance
    is created. They contain keys that are mapped to a particular value, and we can
    iterate through named tuples either by index or key. The `namedtuple` function
    is mainly useful when several tuples are used in an application and it is important
    to keep track of each of the tuples in terms of what they represent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation, namedtuple presents a more readable and self-documenting
    method. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the above code, we firstly imported `namedtuple` from the `collections`
    module. `Book` is a named tuples, “`class`,” and then, `Book1` is created, which
    is an instance of `Book`. We also see that the data elements can be accessed using
    index and key methods.
  prefs: []
  type: TYPE_NORMAL
- en: Deque
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `deque` is a double-ended queue (deque) that supports append and pop elements
    from both sides of the list. Deques are implemented as double-linked lists, which
    are very efficient for inserting and deleting elements in O(1) time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use some of the following predefined functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `my_queue.append(''age'')` | Insert `''age''` at the right end of the list.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `my_queue.appendleft(''age'')` | Insert `''age''` at the left end of the
    list. |'
  prefs: []
  type: TYPE_TB
- en: '| `my_queue.pop()` | Delete the rightmost value. |'
  prefs: []
  type: TYPE_TB
- en: '| `my_queue.popleft()` | Delete the leftmost value. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.8: Description of different queue functions'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we showed the use of the `deque` method of the `collections`
    module, and how elements can be added and deleted from the `queue`.
  prefs: []
  type: TYPE_NORMAL
- en: Ordered dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An ordered dictionary is a dictionary that preserves the order of the keys
    that are inserted. If the key order is important for any application, then `OrderedDict`
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'An example could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we create a dictionary, `od`, using the `OrderedDict` module.
    We can observe that the order of the keys is the same as the order when we created
    the key.
  prefs: []
  type: TYPE_NORMAL
- en: Default dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default dictionary (`defaultdict`) is a subclass of the built-in dictionary
    class (`dict)` that has the same methods and operations as that of the `dictionary`
    class, with the only difference being that it never raises a `KeyError`, as a
    normal dictionary would. `defaultdict` is a convenient way to initialize dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'An example could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, if an ordinary dictionary had been used, then Python would
    have shown `KeyError` while the first key was added. `int`, which we supplied
    as an argument to `defaultdict`, is really the `int()` function, which simply
    returns a zero.
  prefs: []
  type: TYPE_NORMAL
- en: ChainMap object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ChainMap` is used to create a list of dictionaries. The `collections.ChainMap`
    data structure combines several dictionaries into a single mapping. Whenever a
    key is searched in the `chainmap`, it looks through all the dictionaries one by
    one, until the key is not found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'An example could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we create two dictionaries, namely, `dict1` and `dict2`,
    and then we can combine both of these dictionaries using the `ChainMap` method.
  prefs: []
  type: TYPE_NORMAL
- en: Counter objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed earlier, a hashable object is one whose hash value will remain
    the same during its lifetime in the program. `counter` is used to count the number
    of hashable objects. Here, the dictionary key is a hashable object, while the
    corresponding value is the count of that object. In other words, `counter` objects
    create a hash table in which the elements and their count are stored as dictionary
    keys and value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '`Dictionary` and `counter` objects are similar in the sense that data is stored
    in `a {key, value}` pair, but in `counter` objects, the value is the count of
    the key whereas it can be anything in the case of `dictionary`. Thus, when we
    only want to see how many times each unique word is occurring in a string, we
    use the `counter` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, the `inventory` variable is created, which holds the counts
    of all the characters using the `counter` module. The count values of these characters
    can be accessed using dictionary-like key access (`[key]`).
  prefs: []
  type: TYPE_NORMAL
- en: UserDict
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python supports a container, `UserDict`, present in the collections module,
    that wraps the dictionary objects. We can add customized functions to the dictionary.
    This is very useful for applications where we want to add/update/modify the functionalities
    of the dictionary. Consider the example code below where pushing/adding a new
    data element is not allowed in the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, a customized push function in the `MyDict` class is created
    to add the customized functionality, which does not allow you to insert an element
    into the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: UserList
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `UserList` is a container that wraps list objects. It can be used to extend
    the functionality of the `list` data structure. Consider the example code below,
    where pushing/adding a new data element is not allowed in the `list` data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, a customized `push` function in the `MyList` class is created
    to add the functionality to not allow you to insert an element into the `list`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: UserString
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strings can be considered as an array of characters. In Python, a character
    is a string of one length and acts as a container that wraps a string object.
    It can be used to create strings with customized functionalities. An example could
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: In the above example code, a customized append function in the `MyString` class
    is created to add the functionality to append a string.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed different built-in data types supported by
    Python. We have also looked at a few basic Python functions, libraries, and modules,
    such as the collections module. The main objective of this chapter was to give
    an overview of Python and make a user acquainted with the language so that it
    is easy to implement the advanced algorithms of data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this chapter has provided an overview of several data structures available
    in Python that are pivotal for understanding the internals of data structures.
    In the next chapter, we will introduce the basic concepts of algorithm design
    and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1421249772551223062.png)'
  prefs: []
  type: TYPE_IMG
