<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing Object-Oriented Programs</h1>
                </header>
            
            <article>
                
<p>Skilled Python programmers agree that testing is one of the most important aspects of software development. Even though this chapter is placed near the end of the book, it is not an afterthought; everything we have studied so far will help us when writing tests. <span>In this chapter, we'll look at the following topics</span>:</p>
<ul>
<li>The importance of unit testing and test-driven development</li>
<li>The standard <kbd>unittest</kbd> module</li>
<li>The <kbd>pytest</kbd> automated testing suite</li>
<li>The <kbd>mock</kbd> module</li>
<li>Code coverage</li>
<li>Cross-platform testing with <kbd>tox</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why test?</h1>
                </header>
            
            <article>
                
<p>Many programmers already know how important it is to test their code. If you're among them, feel free to skim this section. You'll find the next section–where we actually see how to create tests in Python–much more scintillating. If you're not convinced of the importance of testing, I promise that your code is broken, you just don't know it. Read on!</p>
<p>Some people argue that testing is more important in Python code because of its dynamic nature; compiled languages such as Java and C++ are occasionally thought to be somehow <em>safer</em> because they enforce type checking at compile time. However, Python tests rarely check types. They check values. They make sure that the right attributes have been set at the right time or that the sequence has the right length, order, and values. These higher-level concepts need to be tested in any language. The real reason Python programmers test more than programmers of other languages is that it is so easy to test in Python!</p>
<p>But why test? Do we really need to test? What if we didn't test? To answer those questions, write a tic-tac-toe game from scratch without any testing at all. Don't run it until it is completely written, start to finish. Tic-tac-toe is fairly simple to implement if you make both players human players (no artificial intelligence). You don't even have to try to calculate who the winner is. Now run your program. And fix all the errors. How many were there? I recorded eight in my tic-tac-toe implementation, and I'm not sure I caught them all. Did you?</p>
<p>We need to test our code to make sure it works. Running the program, as we just did, and fixing the errors is one crude form of testing. Python's interactive interpreter and near-zero compile times makes it easy to write a few lines of code and run the program to make sure those lines are doing what is expected. But changing a few lines of code can affect parts of the program that we haven't realized will be influenced by the changes, and therefore neglect to test those parts. Furthermore, as a program grows, the number of paths that the interpreter can take through that code also grow, and it quickly becomes impossible to manually test all of them.</p>
<p>To handle this, we write automated tests. These are programs that automatically run certain inputs through other programs or parts of programs. We can run these test programs in seconds and cover far more potential input situations than one programmer would think to test every time they change something.</p>
<p>There are four main reasons to write tests:</p>
<ul>
<li>To ensure that code is working the way the developer thinks it should</li>
<li>To ensure that code continues working when we make changes</li>
<li>To ensure that the developer understood the requirements</li>
<li>To ensure that the code we are writing has a maintainable interface</li>
</ul>
<p>The first point really doesn't justify the time it takes to write a test; we can test the code directly in the interactive interpreter in the same time or less. But when we have to perform the same sequence of test actions multiple times, it takes less time to automate those steps once and then run them whenever necessary. It is a good idea to run tests every time we change code, whether it is during initial development or maintenance releases. When we have a comprehensive set of automated tests, we can run them after code changes and know that we didn't inadvertently break anything that was tested.</p>
<p>The last two of the preceding points are more interesting. When we write tests for code, it helps us design the API, interface, or pattern that code takes. Thus, if we misunderstood the requirements, writing a test can help highlight that misunderstanding. From the other side, if we're not certain how we want to design a class, we can write a test that interacts with that class so we have an idea of the most natural way to interface with it. In fact, it is often beneficial to write the tests before we write the code we are testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test-driven development</h1>
                </header>
            
            <article>
                
<p><em>Write tests first</em> is the mantra of test-driven development. Test-driven development takes the <em>untested code is broken code</em> concept one step further and suggests that only unwritten code should be untested. We don't write any code until we have written the tests that will prove it works. The first time we run a test it should fail, since the code hasn't been written. Then, we write the code that ensures the test passes, then write another test for the next segment of code.</p>
<p>Test-driven development is fun; it allows us to build little puzzles to solve. Then, we implement the code to solve those puzzles. Then, we make a more complicated puzzle, and we write code that solves the new puzzle without unsolving the previous one.</p>
<p>There are two goals to the test-driven methodology. The first is to ensure that tests really get written. It's so very easy, after we have written code, to say:</p>
<div class="packt_quote">"Hmm, it seems to work. I don't have to write any tests for this. It was just a small change; nothing could have broken."</div>
<p>If the test is already written before we write the code, we will know exactly when it works (because the test will pass), and we'll know in the future if it is ever broken by a change we or someone else has made.</p>
<p>Secondly, writing tests first forces us to consider exactly how the code will be used. It tells us what methods objects need to have and how attributes will be accessed. It helps us break up the initial problem into smaller, testable problems, and then to recombine the tested solutions into larger, also tested, solutions. Writing tests can thus become a part of the design process. Often, when we're writing a test for a new object, we discover anomalies in the design that force us to consider new aspects of the software.</p>
<p>As a concrete example, imagine writing code that uses an object-relational mapper to store object properties in a database. It is common to use an automatically assigned database ID in such objects. Our code might use this ID for various purposes. If we are writing a test for such code, before we write it, we may realize that our design is faulty because objects do not have IDs assigned until they have been saved to the database. If we want to manipulate an object without saving it in our test, it will highlight this problem before we have written code based on the faulty premise.</p>
<p>Testing makes software better. Writing tests before we release the software makes it better before the end user sees or purchases the buggy version (I have worked for companies that thrive on the <em>users can test it</em> philosophy; it's not a healthy business model). Writing tests before we write software makes it better the first time it is written.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing</h1>
                </header>
            
            <article>
                
<p>Let's start our exploration with Python's built-in test library. This library provides a common object-oriented interface for <strong>unit tests</strong>. Unit tests focus on testing the least amount of code possible in any one test. Each one tests a single unit of the total amount of available code.</p>
<p>The Python library for this is called, unsurprisingly, <kbd>unittest</kbd>. It provides several tools for creating and running unit tests, the most important being the <kbd>TestCase</kbd> class. This class provides a set of methods that allow us to compare values, set up tests, and clean up when they have finished.</p>
<p>When we want to write a set of unit tests for a specific task, we create a subclass of <kbd>TestCase</kbd> and write individual methods to do the actual testing. These methods must all start with the name <kbd>test</kbd>. When this convention is followed, the tests automatically run as part of the test process. Normally, the tests set some values on an object and then run a method, and use the built-in comparison methods to ensure that the right results were calculated. Here's a very simple example:</p>
<pre>import unittest<br/><br/><br/>class CheckNumbers(unittest.TestCase):<br/>    def test_int_float(self):<br/>        self.assertEqual(1, 1.0)<br/><br/><br/>if __name__ == "__main__":<br/>    unittest.main()</pre>
<p>This code simply subclasses the <kbd>TestCase</kbd> class and adds a method that calls the <kbd>TestCase.assertEqual</kbd> method. This method will either succeed or raise an exception, depending on whether the two parameters are equal. If we run this code, the <kbd>main</kbd> function from <kbd>unittest</kbd> will give us the following output:</p>
<pre><strong>.</strong>
<strong>--------------------------------------------------------------</strong>
<strong>Ran 1 test in 0.000s</strong>

<strong>OK</strong>  </pre>
<p>Did you know that floats and integers can be compared as equal? Let's add a failing test, as follows:</p>
<pre>    def test_str_float(self): 
        self.assertEqual(1, "1") </pre>
<p>The output of this <span>code</span> is more sinister, as integers and strings are not<br/>
considered equal:</p>
<pre><strong>.F</strong>
<strong>============================================================</strong>
<strong>FAIL: test_str_float (__main__.CheckNumbers)</strong>
<strong>--------------------------------------------------------------</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "first_unittest.py", line 9, in test_str_float</strong>
<strong>    self.assertEqual(1, "1")</strong>
<strong>AssertionError: 1 != '1'</strong>

<strong>--------------------------------------------------------------</strong>
<strong>Ran 2 tests in 0.001s</strong>

<strong>FAILED (failures=1)</strong>  </pre>
<p>The dot on the first line indicates that the first test (the one we wrote before) passed successfully; the letter <kbd>F</kbd> after it shows that the second test failed. Then, at the end, it gives us some informative output telling us how and where the test failed, along with a summary of the number of failures.</p>
<p>We can have as many test methods on one <kbd>TestCase</kbd> class as we like. As long as the method name begins with <kbd>test</kbd>, the test runner will execute each one as a separate, isolated test. Each test should be completely independent of other tests. Results or calculations from a previous test should have no impact on the current test. The key to writing good unit tests is keeping each test method as short as possible, testing a small unit of code with each test case. If our code does not seem to naturally break up into such testable units, it's probably a sign that the code needs to be redesigned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Assertion methods</h1>
                </header>
            
            <article>
                
<p>The general layout of a test case is to set certain variables to known values, run one or more functions, methods, or processes, and then <em>prove</em> that correct expected results were returned or calculated by using <kbd>TestCase</kbd> assertion methods.</p>
<p>There are a few different assertion methods available to confirm that specific results have been achieved. We just saw <kbd>assertEqual</kbd>, which will cause a test failure if the two parameters do not pass an equality check. The inverse, <kbd>assertNotEqual</kbd>, will fail if the two parameters do compare as equal. The <kbd>assertTrue</kbd> and <kbd>assertFalse</kbd> methods each accept a single expression, and fail if the expression does not pass an <kbd>if</kbd> test. These tests do not check for the Boolean values <kbd>True</kbd> or <kbd>False</kbd>. Rather, they test the same condition as though an <kbd>if</kbd> statement were used: <kbd>False</kbd>, <kbd>None</kbd>, <kbd>0</kbd>, or an empty list, dictionary, string, set, or tuple would pass a call to the <kbd>assertFalse</kbd> method. Nonzero numbers, containers with values in them, or the value <kbd>True</kbd> would succeed when calling the <kbd>assertTrue</kbd> method.</p>
<p>There is an <kbd>assertRaises</kbd> method that can be used to ensure that a specific function call raises a specific exception or, optionally, it can be used as a context manager to wrap inline code. The test passes if the code inside the <kbd>with</kbd> statement raises the proper exception; otherwise, it fails. The following code snippet is an example of both versions:</p>
<pre>import unittest<br/><br/><br/>def average(seq):<br/>    return sum(seq) / len(seq)<br/><br/><br/>class TestAverage(unittest.TestCase):<br/>    def test_zero(self):<br/>        self.assertRaises(ZeroDivisionError, average, [])<br/><br/>    def test_with_zero(self):<br/>        with self.assertRaises(ZeroDivisionError):<br/>            average([])<br/><br/><br/>if __name__ == "__main__":<br/>    unittest.main()</pre>
<p>The context manager allows us to write the code the way we would normally write it (by calling functions or executing code directly), rather than having to wrap the function call in another function call.</p>
<p>There are also several other assertion methods, summarized in the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Methods</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertGreater</kbd></p>
<p><kbd>assertGreaterEqual</kbd></p>
<p><kbd>assertLess</kbd></p>
<p><kbd>assertLessEqual</kbd></p>
</td>
<td>
<p>Accept two comparable objects and ensure the named inequality holds.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertIn</kbd></p>
<p><kbd>assertNotIn</kbd></p>
</td>
<td>
<p>Ensure an element is (or is not) an element in a container object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertIsNone</kbd></p>
<p><kbd>assertIsNotNone</kbd></p>
</td>
<td>
<p>Ensure an element is (or is not) the exact <kbd>None</kbd> value (but not another falsey value).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertSameElements</kbd></p>
</td>
<td>
<p>Ensure two container objects have the same elements, ignoring the order.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertSequenceEqualassertDictEqual</kbd></p>
<p><kbd>assertSetEqual</kbd></p>
<p><kbd>assertListEqual</kbd></p>
<p><kbd>assertTupleEqual</kbd></p>
</td>
<td>
<p>Ensure two containers have the same elements in the same order. If there's a failure, show a code difference comparing the two lists to see where they differ. The last four methods also test the type of the list.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>
<p> </p>
<p>Each of the assertion methods accepts an optional argument named <kbd>msg.</kbd> If supplied, it is included in the error message if the assertion fails. This can be useful for clarifying what was expected or explaining where a bug may have occurred to cause the assertion to fail. I rarely use this syntax, however, preferring to use descriptive names for the test method instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducing boilerplate and cleaning up</h1>
                </header>
            
            <article>
                
<p>After writing a few small tests, we often find that we have to write the same setup code for several related tests. For example, the following <kbd>list</kbd> subclass has three methods for statistical calculations:</p>
<pre>from collections import defaultdict 
 
class StatsList(list): 
    def mean(self): 
        return sum(self) / len(self) 
 
    def median(self): 
        if len(self) % 2: 
            return self[int(len(self) / 2)] 
        else: 
            idx = int(len(self) / 2) 
            return (self[idx] + self[idx-1]) / 2 
 
    def mode(self): 
        freqs = defaultdict(int) 
        for item in self: 
            freqs[item] += 1 
        mode_freq = max(freqs.values()) 
        modes = [] 
        for item, value in freqs.items(): 
            if value == mode_freq: 
                modes.append(item) 
        return modes </pre>
<p>Clearly, we're going to want to test situations with each of these three methods that have very similar inputs. We'll want to see what happens with empty lists, with lists containing non-numeric values, or with lists containing a normal dataset, for example. We can use the <kbd>setUp</kbd> method on the <kbd>TestCase</kbd> class to perform initialization for each test. This method accepts no arguments, and allows us to do arbitrary setup before each test is run. For example, we can test all three methods on identical lists of integers as follows:</p>
<pre>from stats import StatsList<br/>import unittest<br/><br/><br/>class TestValidInputs(unittest.TestCase):<br/>    def setUp(self):<br/>        self.stats = StatsList([1, 2, 2, 3, 3, 4])<br/><br/>    def test_mean(self):<br/>        self.assertEqual(self.stats.mean(), 2.5)<br/><br/>    def test_median(self):<br/>        self.assertEqual(self.stats.median(), 2.5)<br/>        self.stats.append(4)<br/>        self.assertEqual(self.stats.median(), 3)<br/><br/>    def test_mode(self):<br/>        self.assertEqual(self.stats.mode(), [2, 3])<br/>        self.stats.remove(2)<br/>        self.assertEqual(self.stats.mode(), [3])<br/><br/><br/>if __name__ == "__main__":<br/>    unittest.main()</pre>
<p>If we run this example, it indicates that all tests pass. Notice first that the <kbd>setUp</kbd> method is never explicitly called inside the three <kbd>test_*</kbd> methods. The test suite does this on our behalf. More importantly, notice how <kbd>test_median</kbd> alters the list, by adding an additional <kbd>4</kbd> to it, yet when the subsequent <kbd>test_mode</kbd> is called, the list has returned to the values specified in <kbd>setUp</kbd>. If it had not, there would be two fours in the list, and the <kbd>mode</kbd> method would have returned three values. This demonstrates that <kbd>setUp</kbd> is called individually before each test, ensuring the test class starts with a clean slate. Tests can be executed in any order, and the results of one test must never depend on any other tests.</p>
<p>In addition to the <kbd>setUp</kbd> method, <kbd>TestCase</kbd> offers a no-argument <kbd>tearDown</kbd> method, which can be used for cleaning up after each and every test on the class has run. This method is useful if cleanup requires anything other than letting an object be garbage collected.</p>
<p>For example, if we are testing code that does file I/O, our tests may create new files as a side effect of testing. The <kbd>tearDown</kbd> method can remove these files and ensure the system is in the same state it was before the tests ran. Test cases should never have side effects. In general, we group test methods into separate <kbd>TestCase</kbd> subclasses depending on what setup code they have in common. Several tests that require the same or similar setup will be placed in one class, while tests that require unrelated setup go in another class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Organizing and running tests</h1>
                </header>
            
            <article>
                
<p>It doesn't take long for a collection of unit tests to grow very large and unwieldy. It can quickly become complicated to load and run all the tests at once. This is a primary goal of unit testing: trivially run all tests on our program and get a quick <em>yes or no</em> answer to the question, <em>did my recent changes break anything?</em>.</p>
<p>As with normal program code, we should divide our test classes into modules and packages that keep them organized. If you name each test module starting with the four characters <em>test</em>, there's an easy way to find and run them all. Python's <kbd>discover</kbd> module looks for any modules in the current folder or subfolders with names that start with <kbd>test</kbd>. If it finds any <kbd>TestCase</kbd> objects in these modules, the tests are executed. It's a painless way to ensure we don't miss running any tests. To use it, ensure your test modules are named <kbd>test_&lt;something&gt;.py</kbd> and then run the <kbd>python3</kbd><kbd>-m</kbd><kbd>unittest</kbd><kbd>discover </kbd>command.</p>
<p>Most Python programmers choose to put their tests in a separate package (usually named <kbd>tests/</kbd> alongside their source directory). This is not required, however. Sometimes it makes sense to put the test modules for different packages in a subpackage next to that package, for example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ignoring broken tests</h1>
                </header>
            
            <article>
                
<p>Sometimes, a test is known to fail, but we don't want the test suite to report the failure. This may be because a broken or unfinished feature has tests written, but we aren't currently focusing on improving it. More often, it happens because a feature is only available on a certain platform, Python version, or for advanced versions of a specific library. Python provides us with a few decorators to mark tests as expected to fail or to be skipped under known conditions.</p>
<p><span>These decorators are as follows</span>:</p>
<ul>
<li><kbd>expectedFailure()</kbd></li>
<li><kbd>skip(reason)</kbd></li>
<li><kbd>skipIf(condition, reason)</kbd></li>
<li><kbd>skipUnless(condition, reason)</kbd></li>
</ul>
<p>These are applied using the Python decorator syntax. The first one accepts no arguments, and simply tells the test runner not to record the test as a failure when it fails. The <kbd>skip</kbd> method goes one step further and doesn't even bother to run the test. It expects a single string argument describing why the test was skipped. The other two decorators accept two arguments, one a Boolean expression that indicates whether or not the test should be run, and a similar description. In use, these three decorators might be applied <span>as they are in the following code</span>:</p>
<pre>import unittest<br/>import sys<br/><br/><br/>class SkipTests(unittest.TestCase):<br/>    @unittest.expectedFailure<br/>    def test_fails(self):<br/>        self.assertEqual(False, True)<br/><br/>    @unittest.skip("Test is useless")<br/>    def test_skip(self):<br/>        self.assertEqual(False, True)<br/><br/>    @unittest.skipIf(sys.version_info.minor == 4, "broken on 3.4")<br/>    def test_skipif(self):<br/>        self.assertEqual(False, True)<br/><br/>    @unittest.skipUnless(<br/>        sys.platform.startswith("linux"), "broken unless on linux"<br/>    )<br/>    def test_skipunless(self):<br/>        self.assertEqual(False, True)<br/><br/><br/>if __name__ == "__main__":<br/>    unittest.main()</pre>
<p>The first test fails, but it is reported as an expected failure; the second test is never run. The other two tests may or may not be run depending on the current Python version and operating system. On my Linux system, running Python 3.7, the output looks as follows:</p>
<pre><strong>xssF</strong><br/><strong>======================================================================</strong><br/><strong>FAIL: test_skipunless (__main__.SkipTests)</strong><br/><strong>----------------------------------------------------------------------</strong><br/><strong>Traceback (most recent call last):</strong><br/><strong>  File "test_skipping.py", line 22, in test_skipunless</strong><br/><strong>    self.assertEqual(False, True)</strong><br/><strong>AssertionError: False != True</strong><br/><br/><strong>----------------------------------------------------------------------</strong><br/><strong>Ran 4 tests in 0.001s</strong><br/><br/><strong>FAILED (failures=1, skipped=2, expected failures=1)</strong></pre>
<p>The <kbd>x</kbd> on the first line indicates an expected failure; the two <kbd>s</kbd> characters represent skipped tests, and the <kbd>F</kbd> indicates a real failure, since the conditional to <kbd>skipUnless</kbd> was <kbd>True</kbd> on my system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing with pytest</h1>
                </header>
            
            <article>
                
<p>The Python <kbd>unittest</kbd> module requires a lot of boilerplate code to set up and initialize tests. It is based on the very popular JUnit testing framework for Java. It even uses the same method names (you may have noticed they don't conform to the PEP-8 naming standard, which suggests snake_case rather than CamelCase to indicate a method name) and test layout. While this is effective for testing in Java, it's not necessarily the best design for Python testing. I actually find the <kbd>unittest</kbd> framework to be an excellent example of overusing object-oriented principles.</p>
<p>Because Python programmers like their code to be elegant and simple, other test frameworks have been developed, outside the standard library. Two of the more popular ones are <kbd>pytest</kbd> and <kbd>nose</kbd>. The former is more robust and has had Python 3 support for much longer, so we'll discuss it here.</p>
<p>Since <kbd>pytest</kbd> is not part of the standard library, you'll need to download and install it yourself. You can get it from the <kbd>pytest</kbd> home page at <a href="http://pytest.org/"><span class="URLPACKT">http://pytest.org/</span></a>. The website has comprehensive installation instructions for a variety of interpreters and platforms, but you can usually get away with the more common Python package installer, pip. Just type <kbd>pip install pytest</kbd> on your command line and you'll be good to go.</p>
<p><kbd>pytest</kbd> has a substantially different layout from the <kbd>unittest</kbd> module. It doesn't require test cases to be classes. Instead, it takes advantage of the fact that Python functions are objects, and allows any properly named function to behave like a test. Rather than providing a bunch of custom methods for asserting equality, it uses the <kbd>assert</kbd> statement to verify results. This makes tests more readable and maintainable.</p>
<p>When we run <kbd>pytest</kbd>, it starts in the current folder and searches for any modules or subpackages with names beginning with the characters <kbd>test_</kbd>. If any functions in this module also start with <kbd>test</kbd>, they will be executed as individual tests. Furthermore, if there are any classes in the module whose name starts with <kbd>Test</kbd>, any methods on that class that start with <kbd>test_</kbd> will also be executed in the test environment.</p>
<p><span>Using the following code, let's</span> port the simplest possible <kbd>unittest</kbd> example we wrote earlier to <kbd>pytest</kbd>:</p>
<pre>def test_int_float(): 
    assert 1 == 1.0 </pre>
<p>For the exact same test, we've written two lines of more readable code, in comparison to the six lines required in our first <kbd>unittest</kbd> example.</p>
<p>However, we are not forbidden from writing class-based tests. Classes can be useful for grouping related tests together or for tests that need to access related attributes or methods on the class. The following example shows an extended class with a passing and a failing test; we'll see that the error output is more comprehensive than that provided by the <kbd>unittest</kbd> module:</p>
<pre>class TestNumbers: 
    def test_int_float(self): 
        assert 1 == 1.0 
 
    def test_int_str(self): 
        assert 1 == "1" </pre>
<p>Notice that the class doesn't have to extend any special objects to be picked up as a test (although <kbd>pytest</kbd> will run standard <kbd>unittest TestCases</kbd> just fine). If we run <kbd>pytest &lt;filename&gt;</kbd>, the output looks <span>as follows</span>:</p>
<pre><strong>============================== test session starts ==============================</strong><br/><strong>platform linux -- Python 3.7.0, pytest-3.8.0, py-1.6.0, pluggy-0.7.1</strong><br/><strong>rootdir: /home/dusty/Py3OOP/Chapter 12: Testing Object-oriented Programs, inifile:</strong><br/><strong>collected 3 items</strong><br/><br/><strong>test_with_pytest.py ..F [100%]</strong><br/><br/><strong>=================================== FAILURES ====================================</strong><br/><strong>___________________________ TestNumbers.test_int_str ____________________________</strong><br/><br/><strong>self = &lt;test_with_pytest.TestNumbers object at 0x7fdb95e31390&gt;</strong><br/><br/><strong>    def test_int_str(self):</strong><br/><strong>&gt; assert 1 == "1"</strong><br/><strong>E AssertionError: assert 1 == '1'</strong><br/><br/><strong>test_with_pytest.py:10: AssertionError</strong><br/><strong>====================== 1 failed, 2 passed in 0.03 seconds =======================</strong></pre>
<p>The output starts with some useful information about the platform and interpreter. This can be useful for sharing or discussing bugs across disparate systems. The third line tells us the name of the file being tested (if there are multiple test modules picked up, they will all be displayed), followed by the familiar <kbd>.F</kbd> we saw in the <kbd>unittest</kbd> module; the <kbd>.</kbd> character indicates a passing test, while the letter <kbd>F</kbd> demonstrates a failure.</p>
<p>After all tests have run, the error output for each of them is displayed. It presents a summary of local variables (there is only one in this example: the <kbd>self</kbd> parameter passed into the function), the source code where the error occurred, and a summary of the error message. In addition, if an exception other than an <kbd>AssertionError</kbd> is raised, <kbd>pytest</kbd> will present us with a complete traceback, including source code references.</p>
<p>By default, <kbd>pytest</kbd> suppresses output from <kbd>print</kbd> statements if the test is successful. This is useful for test debugging; when a test is failing, we can add <kbd>print</kbd> statements to the test to check the values of specific variables and attributes as the test runs. If the test fails, these values are output to help with diagnosis. However, once the test is successful, the <kbd>print</kbd> statement output is not displayed, and they are easily ignored. We don't have to <em>clean up</em> output by removing <kbd>print</kbd> statements. If the tests ever fail again, due to future changes, the debugging output will be immediately available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One way to do setup and cleanup</h1>
                </header>
            
            <article>
                
<p><kbd>pytest</kbd> supports setup and teardown methods similar to those used in <kbd>unittest</kbd>, but it provides even more flexibility. We'll discuss these briefly, since they are familiar, but they are not used as extensively as in the <kbd>unittest</kbd> module, as <kbd>pytest</kbd> provides us with a powerful fixtures facility, which we'll discuss in the next section.</p>
<p>If we are writing class-based tests, we can use two methods called <kbd>setup_method</kbd> and <kbd>teardown_method</kbd> in the same way that <kbd>setUp</kbd> and <kbd>tearDown</kbd> are called in <kbd>unittest</kbd>. They are called before and after each test method in the class to perform setup and cleanup duties. There is one difference from the <kbd>unittest</kbd> methods though. Both methods accept an argument: the function object representing the method being called.</p>
<p>In addition, <kbd>pytest</kbd> provides other setup and teardown functions to give us more control over when setup and cleanup code is executed. The <kbd>setup_class</kbd> and <kbd>teardown_class</kbd> methods are expected to be class methods; they accept a single argument (there is no <kbd>self</kbd> argument) representing the class in question. These methods are only run when the class is initiated rather than on each test run.</p>
<p>Finally, we have the <kbd>setup_module</kbd> and <kbd>teardown_module</kbd> functions, which are run immediately before and after all tests (in functions or classes) in that module. These can be useful for <em>one time</em> setup, such as creating a socket or database connection that will be used by all tests in the module. Be careful with this one, as it can accidentally introduce dependencies between tests if the object stores state that isn't correctly cleaned up between tests.</p>
<p>That short description doesn't do a great job of explaining exactly when these methods are called, so let's look at an example that illustrates exactly when it happens:</p>
<pre>def setup_module(module):<br/>    print("setting up MODULE {0}".format(module.__name__))<br/><br/><br/>def teardown_module(module):<br/>    print("tearing down MODULE {0}".format(module.__name__))<br/><br/><br/>def test_a_function():<br/>    print("RUNNING TEST FUNCTION")<br/><br/><br/>class BaseTest:<br/>    def setup_class(cls):<br/>        print("setting up CLASS {0}".format(cls.__name__))<br/><br/>    def teardown_class(cls):<br/>        print("tearing down CLASS {0}\n".format(cls.__name__))<br/><br/>    def setup_method(self, method):<br/>        print("setting up METHOD {0}".format(method.__name__))<br/><br/>    def teardown_method(self, method):<br/>        print("tearing down METHOD {0}".format(method.__name__))<br/><br/><br/>class TestClass1(BaseTest):<br/>    def test_method_1(self):<br/>        print("RUNNING METHOD 1-1")<br/><br/>    def test_method_2(self):<br/>        print("RUNNING METHOD 1-2")<br/><br/><br/>class TestClass2(BaseTest):<br/>    def test_method_1(self):<br/>        print("RUNNING METHOD 2-1")<br/><br/>    def test_method_2(self):<br/>        print("RUNNING METHOD 2-2")</pre>
<p>The sole purpose of the <kbd>BaseTest</kbd> class is to extract four methods that are otherwise identical to the test classes, and use inheritance to reduce the amount of duplicate code. So, from the point of view of <kbd>pytest</kbd>, the two subclasses have not only two test methods each, but also two setup and two teardown methods (one at the class level, one at the method level).</p>
<p>If we run these tests using <kbd>pytest</kbd> with the <kbd>print</kbd> function output suppression disabled (by passing the <kbd>-s</kbd> or <kbd>--capture=no</kbd> flag), they show us when the various functions are called in relation to the tests themselves:</p>
<pre><strong>setup_teardown.py</strong>
<strong>setting up MODULE setup_teardown</strong>
<strong>RUNNING TEST FUNCTION</strong>
<strong>.setting up CLASS TestClass1</strong>
<strong>setting up METHOD test_method_1</strong>
<strong>RUNNING METHOD 1-1</strong>
<strong>.tearing down  METHOD test_method_1</strong>
<strong>setting up METHOD test_method_2</strong>
<strong>RUNNING METHOD 1-2</strong>
<strong>.tearing down  METHOD test_method_2</strong>
<strong>tearing down CLASS TestClass1</strong>
<strong>setting up CLASS TestClass2</strong>
<strong>setting up METHOD test_method_1</strong>
<strong>RUNNING METHOD 2-1</strong>
<strong>.tearing down  METHOD test_method_1</strong>
<strong>setting up METHOD test_method_2</strong>
<strong>RUNNING METHOD 2-2</strong>
<strong>.tearing down  METHOD test_method_2</strong>
<strong>tearing down CLASS TestClass2</strong>

<strong>tearing down MODULE setup_teardown</strong>  </pre>
<p>The setup and teardown methods for the module are executed at the beginning and end of the session. Then the lone module-level test function is run. Next, the setup method for the first class is executed, followed by the two tests for that class. These tests are each individually wrapped in separate <kbd>setup_method</kbd> and <kbd>teardown_method</kbd> calls. After the tests have executed, the teardown method on the class is called. The same sequence happens for the second class, before the <kbd>teardown_module</kbd> method is finally called, exactly once.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A completely different way to set up variables</h1>
                </header>
            
            <article>
                
<p>One of the most common uses for the various setup and teardown functions is to ensure certain class or module variables are available with a known value before each test method is run.</p>
<p><kbd>pytest</kbd> offers a completely different way of doing this, using what are known as <strong>fixtures</strong>. Fixtures are basically named variables that are predefined in a test configuration file. This allows us to separate configuration from the execution of tests, and allows fixtures to be used across multiple classes and modules.</p>
<p>To use them, we add parameters to our test function. The names of the parameters are used to look up specific arguments in specially named functions. For example, if we wanted to test the <kbd>StatsList</kbd> class we used while demonstrating <kbd>unittest</kbd>, we would again want to repeatedly test a list of valid integers. But we can write our tests <span>as follows</span> instead of using a setup method:</p>
<pre>import pytest<br/>from stats import StatsList<br/><br/><br/>@pytest.fixture<br/>def valid_stats():<br/>    return StatsList([1, 2, 2, 3, 3, 4])<br/><br/><br/>def test_mean(valid_stats):<br/>    assert valid_stats.mean() == 2.5<br/><br/><br/>def test_median(valid_stats):<br/>    assert valid_stats.median() == 2.5<br/>    valid_stats.append(4)<br/>    assert valid_stats.median() == 3<br/><br/><br/>def test_mode(valid_stats):<br/>    assert valid_stats.mode() == [2, 3]<br/>    valid_stats.remove(2)<br/>    assert valid_stats.mode() == [3]</pre>
<p>Each of the three test methods accepts a parameter named <kbd>valid_stats</kbd>; this parameter is created by calling the <kbd>valid_stats</kbd> function, which was decorated with <kbd>@pytest.fixture</kbd>.</p>
<p>Fixtures can do a lot more than return basic variables. A <kbd>request</kbd> object can be passed into the fixture factory to provide extremely useful methods and attributes to modify the funcarg's behavior. The <kbd>module</kbd>, <kbd>cls</kbd>, and <kbd>function</kbd> attributes allow us to see exactly which test is requesting the fixture. The <kbd>config</kbd> attribute allows us to check command-line arguments and a great deal of other configuration data.</p>
<p>If we implement the fixture as a generator, we can run cleanup code after each test is run. This provides the equivalent of a teardown method, except on a per-fixture basis. We can use it to clean up files, close connections, empty lists, or reset queues. For example, the following code tests the <kbd>os.mkdir</kbd> functionality by creating a temporary directory fixture:</p>
<pre>import pytest<br/>import tempfile<br/>import shutil<br/>import os.path<br/><br/><br/>@pytest.fixture<br/>def temp_dir(request):<br/>    dir = tempfile.mkdtemp()<br/>    print(dir)<br/>    yield dir<br/>    shutil.rmtree(dir)<br/><br/><br/>def test_osfiles(temp_dir):<br/>    os.mkdir(os.path.join(temp_dir, "a"))<br/>    os.mkdir(os.path.join(temp_dir, "b"))<br/>    dir_contents = os.listdir(temp_dir)<br/>    assert len(dir_contents) == 2<br/>    assert "a" in dir_contents<br/>    assert "b" in dir_contents</pre>
<p>The fixture creates a new empty temporary directory for files to be created in. It yields this for use in the test, but removes that directory (using <kbd>shutil.rmtree</kbd>, which recursively removes a directory and anything inside it) after the test has completed. The filesystem is then left in the same state in which it started.</p>
<p>We can pass a <kbd>scope</kbd> parameter to create a fixture that lasts longer than one test. This is useful when setting up an expensive operation that can be reused by multiple tests, as long as the resource reuse doesn't break the atomic or unit nature of the tests (so that one test does not rely on, and is not impacted by, a previous one). For example, if we were to test the following echo server, we may want to run only one instance of the server in a separate process, and then have multiple tests connect to that instance:</p>
<pre>import socket 
 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 
s.bind(('localhost',1028)) 
s.listen(1) 
 
    while True: 
        client, address = s.accept() 
        data = client.recv(1024) 
        client.send(data) 
        client.close() </pre>
<p>All this code does is listen on a specific port and wait for input from a client socket. When it receives input, it sends the same value back. To test this, we can start the server in a separate process and cache the result for use in multiple tests. Here's how the test code might look:</p>
<pre>import subprocess<br/>import socket<br/>import time<br/>import pytest<br/><br/><br/>@pytest.fixture(scope="session")<br/>def echoserver():<br/>    print("loading server")<br/>    p = subprocess.Popen(["python3", "echo_server.py"])<br/>    time.sleep(1)<br/>    yield p<br/>    p.terminate()<br/><br/><br/>@pytest.fixture<br/>def clientsocket(request):<br/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>    s.connect(("localhost", 1028))<br/>    yield s<br/>    s.close()<br/><br/><br/>def test_echo(echoserver, clientsocket):<br/>    clientsocket.send(b"abc")<br/>    assert clientsocket.recv(3) == b"abc"<br/><br/><br/>def test_echo2(echoserver, clientsocket):<br/>    clientsocket.send(b"def")<br/>    assert clientsocket.recv(3) == b"def"</pre>
<p>We've created two fixtures here. The first runs the echo server in a separate process, and yields the process object, cleaning it up when it's finished. The second instantiates a new socket object for each test, and closes the socket when the test has completed.</p>
<p class="mce-root">The first fixture is the one we're currently interested in. From the <kbd>scope="session"</kbd> keyword argument passed into the decorator's constructor, <kbd>pytest</kbd> knows that we only want this fixture to be initialized and terminated once for the duration of the unit test session.</p>
<p class="mce-root"><span>The scope can be one of the strings</span> <kbd>class</kbd><span>,</span> <kbd>module</kbd><span>, </span><kbd>package</kbd><span>,  or</span> <kbd>session</kbd><span>. It determines just how long the argument will be cached. We set it to</span> <kbd>session</kbd><span> in this example, so it is cached for the duration of the entire</span> <kbd>pytest</kbd> <span>run. The process will not be terminated or restarted until all tests have run. The</span> <kbd>module</kbd><span> scope, of course, caches it only for tests in that module, and the</span> <kbd>class</kbd><span> scope treats the object more like a normal class setup and teardown.</span></p>
<div class="packt_infobox">At the time the third edition of this book went to print, the <kbd>package</kbd> scope was labeled experimental in <kbd>pytest</kbd>. Be careful with it, and they request that you supply bug reports.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Skipping tests with pytest</h1>
                </header>
            
            <article>
                
<p>As with the <kbd>unittest</kbd> module, it is frequently necessary to skip tests in <kbd>pytest</kbd>, for a similar variety of reasons: the code being tested hasn't been written yet, the test only runs on certain interpreters or operating systems, or the test is time-consuming and should only be run under certain circumstances.</p>
<p>We can skip tests at any point in our code, using the <kbd>pytest.skip</kbd> function. It accepts a single argument: a string describing why it has been skipped. This function can be called anywhere. If we call it inside a test function, the test will be skipped. If we call it at the module level, all the tests in that module will be skipped. If we call it inside a fixture, all tests that call that funcarg will be skipped.</p>
<p>Of course, in all these locations, it is often desirable to skip tests only if certain conditions are or are not met. Since we can execute the <kbd>skip</kbd> function at any place in Python code, we can execute it inside an <kbd>if</kbd> statement. So we may write a test that looks <span>as follows</span>:</p>
<pre>import sys 
import pytest 
 
def test_simple_skip(): 
    if sys.platform != "fakeos": 
        pytest.skip("Test works only on fakeOS") 
     
    fakeos.do_something_fake() 
    assert fakeos.did_not_happen </pre>
<p>That's some pretty silly code, really. There is no Python platform named <kbd>fakeos</kbd>, so this test will skip on all operating systems. It shows how we can skip conditionally, and since the <kbd>if</kbd> statement can check any valid conditional, we have a lot of power over when tests are skipped. Often, we check <kbd>sys.version_info</kbd> to check the Python interpreter version, <kbd>sys.platform</kbd> to check the operating system, or <kbd>some_library.__version__</kbd> to check whether we have a recent enough version of a given API.</p>
<p>Since skipping an individual test method or function based on a certain conditional is one of the most common uses of test skipping, <kbd>pytest</kbd> provides a convenience decorator that allows us to do this in one line. The decorator accepts a single string, which can contain any executable Python code that evaluates to a Boolean value. For example, the following test will only run on Python 3 or higher:</p>
<pre>@pytest.mark.skipif("sys.version_info &lt;= (3,0)") 
def test_python3(): 
    assert b"hello".decode() == "hello" </pre>
<p>The <kbd>pytest.mark.xfail</kbd> decorator behaves similarly, except that it marks a test as expected to fail, similar to <kbd>unittest.expectedFailure()</kbd>. If the test is successful, it will be recorded as a failure. If it fails, it will be reported as expected behavior. In the case of <kbd>xfail</kbd>, the conditional argument is optional. If it is not supplied, the test will be marked as expected to fail under all conditions.</p>
<p>The <kbd>pytest</kbd> has a ton of other features besides those described here and the developers are constantly adding innovative new ways to make your testing experience more enjoyable. They have thorough documentation on their website at <a href="https://docs.pytest.org/">https://docs.pytest.org/</a>.</p>
<div class="packt_tip">The <kbd>pytest</kbd> can find and run tests defined using the standard <kbd>unittest</kbd> library in addition to its own testing infrastructure. This means that if you want to migrate from <kbd>unittest</kbd> to <kbd>pytest</kbd>, you don't have to rewrite all your old tests.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Imitating expensive objects</h1>
                </header>
            
            <article>
                
<p>Sometimes, we want to test code that requires an object be supplied that is either expensive or difficult to construct. In some cases, this may mean your API needs rethinking to have a more testable interface (which typically means a more usable interface). But we sometimes find ourselves writing test code that has a ton of boilerplate to set up objects that are only incidentally related to the code under test.</p>
<p>For example, imagine we have some code that keeps track of flight statuses in an external key-value store (such as <kbd>redis</kbd> or <kbd>memcache</kbd>), such that we can store the timestamp and the most recent status. A basic version of such code might look as follows:</p>
<pre>import datetime<br/>import redis<br/><br/><br/>class FlightStatusTracker:<br/>    ALLOWED_STATUSES = {"CANCELLED", "DELAYED", "ON TIME"}<br/><br/>    def __init__(self):<br/>        self.redis = redis.StrictRedis()<br/><br/>    def change_status(self, flight, status):<br/>        status = status.upper()<br/>        if status not in self.ALLOWED_STATUSES:<br/>            raise ValueError("{} is not a valid status".format(status))<br/><br/>        key = "flightno:{}".format(flight)<br/>        value = "{}|{}".format(<br/>            datetime.datetime.now().isoformat(), status<br/>        )<br/>        self.redis.set(key, value)</pre>
<p>There are a lot of things we ought to test for that <kbd>change_status</kbd> method. We should check that it raises the appropriate error if a bad status is passed in. We need to ensure that it converts statuses to uppercase. We can see that the key and value have the correct formatting when the <kbd>set()</kbd> method is called on the <kbd>redis</kbd> object.</p>
<p>One thing we don't have to check in our unit tests, however, is that the <kbd>redis</kbd> object is properly storing the data. This is something that absolutely should be tested in integration or application testing, but at the unit test level, we can assume that the py-redis developers have tested their code and that this method does what we want it to. As a rule, unit tests should be self-contained and shouldn't rely on the existence of outside resources, such as a running Redis instance.</p>
<p>Instead, we only need to test that the <kbd>set()</kbd> method was called the appropriate number of times and with the appropriate arguments. We can use <kbd>Mock()</kbd> objects in our tests to replace the troublesome method with an object we can introspect. The following example illustrates the use of <kbd>Mock</kbd>:</p>
<pre>from flight_status_redis import FlightStatusTracker<br/>from unittest.mock import Mock<br/>import pytest<br/><br/><br/>@pytest.fixture<br/>def tracker():<br/>    return FlightStatusTracker()<br/><br/><br/>def test_mock_method(tracker):<br/><strong>    tracker.redis.set = Mock()</strong><br/>    with pytest.raises(ValueError) as ex:<br/>        tracker.change_status("AC101", "lost")<br/>    assert ex.value.args[0] == "LOST is not a valid status"<br/><strong>    assert tracker.redis.set.call_count == 0</strong><br/><br/></pre>
<p>This test, written using <kbd>pytest</kbd> syntax, asserts that the correct exception is raised when an inappropriate argument is passed in. In addition, it creates a <kbd>Mock</kbd> object for the <kbd>set</kbd> method and makes sure that it is never called. If it was, it would mean there was a bug in our exception handling code.</p>
<p>Simply replacing the method worked fine in this case, since the object being replaced was destroyed in the end. However, we often want to replace a function or method only for the duration of a test. For example, if we want to test the timestamp formatting in the <kbd>Mock</kbd> method, we need to know exactly what <kbd>datetime.datetime.now()</kbd> is going to return. However, this value changes from run to run. We need some way to pin it to a specific value so we can test it deterministically.</p>
<p>Temporarily setting a library function to a specific value is one of the few valid use cases for monkey-patching. The mock library provides a patch context manager that allows us to replace attributes on existing libraries with mock objects. When the context manager exits, the original attribute is automatically restored so as not to impact other test cases. Here's an example:</p>
<pre>import datetime<br/>from unittest.mock import patch<br/><br/>def test_patch(tracker):<br/>    tracker.redis.set = Mock()<br/>    fake_now = datetime.datetime(2015, 4, 1)<br/><strong>    with patch("datetime.datetime") as dt:</strong><br/>        dt.now.return_value = fake_now<br/>        tracker.change_status("AC102", "on time")<br/>    dt.now.assert_called_once_with()<br/>    tracker.redis.set.assert_called_once_with(<br/>        "flightno:AC102", "2015-04-01T00:00:00|ON TIME"<br/>    )</pre>
<p>In the preceding example, we first construct a value called <kbd>fake_now</kbd>, which we will set as the return value of the <kbd>datetime.datetime.now</kbd> function. We have to construct this object before we patch <kbd>datetime.datetime</kbd>, because otherwise we'd be calling the patched <kbd>now</kbd> function before we constructed it.</p>
<p>The <kbd>with</kbd> statement invites the patch to replace the <kbd>datetime.datetime</kbd> module with a mock object, which is returned as the <kbd>dt </kbd>value. The neat thing about mock objects is that any time you access an attribute or method on that object, it returns another mock object. Thus, when we access <kbd>dt.now</kbd>, it gives us a new mock object. We set the <kbd>return_value</kbd> of that object to our <kbd>fake_now</kbd> object. Now, whenever the <kbd>datetime.datetime.now</kbd> function is called, it will return our object instead of a new mock object. But when the interpreter exits the context manager, the original <kbd>datetime.datetime.now()</kbd> functionality is restored.</p>
<p>After calling our <kbd>change_status</kbd> method with known values, we use the <kbd>assert_called_once_with</kbd> function of the <kbd>Mock</kbd><span> class </span>to ensure that the <kbd>now</kbd> function was indeed called exactly once with no arguments. We then call it a second time to prove that the <kbd>redis.set</kbd> method was called with arguments that were formatted as we expected them to be.</p>
<div class="packt_tip">Mocking dates so you can have deterministic test results is a common patching scenario. If you are in a situation where you are doing a lot of this, you might appreciate the <kbd>freezegun</kbd> and <kbd>pytest-freezegun</kbd> projects available in the Python Package Index.</div>
<p>The previous example is a good indication of how writing tests can guide our API design. The <kbd>FlightStatusTracker</kbd> object looks sensible at first glance; we construct a <kbd>redis</kbd> connection when the object is constructed, and we call into it when we need it. When we write tests for this code, however, we discover that even if we mock out that <kbd>self.redis</kbd> variable on a <kbd>FlightStatusTracker</kbd>, the <kbd>redis</kbd> connection still has to be constructed. This call actually fails if there is no Redis server running, and our tests also fail.</p>
<p>We could solve this problem by mocking out the <kbd>redis.StrictRedis</kbd> class to return a mock in a <kbd>setUp</kbd> method. A better idea, however, might be to rethink our implementation. Instead of constructing the <kbd>redis</kbd> instance inside<kbd>__init__</kbd>, perhaps we should allow the user to pass one in, as in the following example:</p>
<pre>    def __init__(self, redis_instance=None): 
        self.redis = redis_instance if redis_instance else redis.StrictRedis() </pre>
<p>This allows us to pass a mock in when we are testing, so the <kbd>StrictRedis</kbd> method never gets constructed. Additionally, it allows any client code that talks to <kbd>FlightStatusTracker</kbd> to pass in their own <kbd>redis</kbd> instance. There are a variety of reasons they might want to do this: they may have already constructed one for other parts of their code; they may have created an optimized implementation of the <kbd>redis</kbd> API; perhaps they have one that logs metrics to their internal monitoring systems. By writing a unit test, we've uncovered a use case that makes our API more flexible from the start, rather than waiting for clients to demand we support their exotic needs.</p>
<p>This has been a brief introduction to the wonders of mocking code. Mocks are part of the standard <kbd>unittest</kbd> library since Python 3.3, but as you see from these examples, they can also be used with <kbd>pytest</kbd> and other libraries. Mocks have other more advanced features that you may need to take advantage of as your code gets more complicated. For example, you can use the <kbd>spec</kbd> argument to invite a mock to imitate an existing class so that it raises an error if code tries to access an attribute that does not exist on the imitated class. You can also construct mock methods that return different arguments each time they are called by passing a list as the <kbd>side_effect</kbd> argument. The <kbd>side_effect</kbd> parameter is quite versatile; you can also use it to execute arbitrary functions when the mock is called or to raise an exception.</p>
<p>In general, we should be quite stingy with mocks. If we find ourselves mocking out multiple elements in a given unit test, we may end up testing the mock framework rather than our real code. This serves no useful purpose whatsoever; after all, mocks are well-tested already! If our code is doing a lot of this, it's probably another sign that the API we are testing is poorly designed. Mocks should exist at the boundaries between the code under test and the libraries they interface with. If this isn't happening, we may need to change the API so that the boundaries are redrawn in a different place.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How much testing is enough?</h1>
                </header>
            
            <article>
                
<p>We've already established that untested code is broken code. But how can we tell how well our code is tested? How do we know how much of our code is actually being tested and how much is broken? The first question is the more important one, but it's hard to answer. Even if we know we have tested every line of code in our application, we do not know that we have tested it properly. For example, if we write a stats test that only checks what happens when we provide a list of integers, it may still fail spectacularly if used on a list of floats, strings, or self-made objects. The onus of designing complete test suites still lies with the programmer.</p>
<p>The second question–how much of our code is actually being tested–is easy to verify. <strong>Code coverage</strong> is an estimate of the number of lines of code that are executed by a program. If we know that number and the number of lines that are in the program, we can get an estimate of what percentage of the code was really tested, or covered. If we additionally have an indicator as to which lines were not tested, we can more easily write new tests to ensure those lines are less broken.</p>
<p>The most popular tool for testing code coverage is called, memorably enough, <kbd>coverage.py</kbd>. It can be installed like most other third-party libraries, using the <kbd>pip install coverage </kbd>command.</p>
<p>We don't have space to cover all the details of the coverage API, so we'll just look at a few typical examples. If we have a Python script that runs all our unit tests for us (for example, using <kbd>unittest.main</kbd>,  <kbd>discover</kbd>, <kbd>pytest</kbd>, or a custom test runner), we can use the following command to perform a coverage analysis:</p>
<pre><strong>$coverage run coverage_unittest.py</strong>  </pre>
<p>This command will exit normally, but it creates a file named <kbd>.coverage</kbd>, which holds the data from the run. We can now use the <kbd>coverage</kbd><kbd>report</kbd> command to get an analysis of the code coverage:</p>
<pre><strong>$coverage report</strong>  </pre>
<p>The <span>resulting output should be</span> as follows:</p>
<pre><strong>Name                           Stmts   Exec  Cover</strong>
<strong>--------------------------------------------------</strong>
<strong>coverage_unittest                  7      7   100%</strong>
<strong>stats                             19      6    31%</strong>
<strong>--------------------------------------------------</strong>
<strong>TOTAL                             26     13    50%</strong>  </pre>
<p>This basic report lists the files that were executed (our unit test and a module it imported). The number of lines of code in each file, and the number that were executed by the test are also listed. The two numbers are then combined to estimate the amount of code coverage. If we pass the <kbd>-m</kbd> option to the <kbd>report</kbd> command, it will additionally add a column that looks as follows:</p>
<pre><strong>Missing</strong>
<strong>-----------</strong>
<strong>8-12, 15-23</strong>  </pre>
<p>The ranges of lines listed here identify lines in the <kbd>stats</kbd> module that were not executed during the test run.</p>
<p>The example we just ran the code coverage tool on uses the same stats module we created earlier in the chapter. However, it deliberately uses a single test that fails to test a lot of code in the file. Here's the test:</p>
<pre>from stats import StatsList 
import unittest 
 
class TestMean(unittest.TestCase): 
    def test_mean(self): 
        self.assertEqual(StatsList([1,2,2,3,3,4]).mean(), 2.5) 
 
if __name__ == "__main__": 
 
    unittest.main() </pre>
<p>This code doesn't test the median or mode functions, which correspond to the line numbers that the coverage output told us were missing.</p>
<p>The textual report provides sufficient information, but if we use the <kbd>coverage html</kbd> command, we can get an even more useful interactive HTML report, which we can view in a web browser. The web page even highlights which lines in the source code were and were not tested. Here's how it looks:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/27269204-aae4-40d5-9455-96a15d846345.png" style="width:29.00em;height:35.17em;"/></div>
<p>We can use the <kbd>coverage.py</kbd> module with <kbd>pytest</kbd> as well. We'll need to install the <kbd>pytest</kbd> plugin for code coverage, using <kbd>pip install pytest-coverage</kbd>. The plugin adds several command-line options to <kbd>pytest</kbd>, the most useful being <kbd>--cover-report</kbd>, which can be set to <kbd>html</kbd>, <kbd>report</kbd>, or <kbd>annotate</kbd> (the latter actually modifies the original source code to highlight any lines that were not covered).</p>
<p>Unfortunately, if we could somehow run a coverage report on this section of the chapter, we'd find that we have not covered most of what there is to know about code coverage! It is possible to use the coverage API to manage code coverage from within our own programs (or test suites), and <kbd>coverage.py</kbd> accepts numerous configuration options that we haven't touched on. We also haven't discussed the difference between statement coverage and branch coverage (the latter is much more useful, and the default in recent versions of <kbd>coverage.py</kbd>), or other styles of code coverage.</p>
<p>Bear in mind that while 100 percent code coverage is a lofty goal that we should all strive for, 100 percent coverage is not enough! Just because a statement was tested does not mean that it was tested properly for all possible inputs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study</h1>
                </header>
            
            <article>
                
<p>Let's walk through test-driven development by writing a small, tested, cryptography application. Don't worry–you won't need to understand the mathematics behind complicated modern encryption algorithms such as AES or RSA. Instead, we'll be implementing a sixteenth-century algorithm known as the Vigenère cipher. The application simply needs to be able to encode and decode a message, given an encoding keyword, using this cipher.</p>
<div class="packt_infobox">If you want a deep dive into how the RSA algorithm works, I wrote one on my blog at <a href="https://dusty.phillips.codes/">https://dusty.phillips.codes/</a>.</div>
<p>First, we need to understand how the cipher works if we apply it manually (without a computer). We start with a table <span>like the following one</span>:</p>
<pre><strong>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
B C D E F G H I J K L M N O P Q R S T U V W X Y Z A 
C D E F G H I J K L M N O P Q R S T U V W X Y Z A B 
D E F G H I J K L M N O P Q R S T U V W X Y Z A B C 
E F G H I J K L M N O P Q R S T U V W X Y Z A B C D 
F G H I J K L M N O P Q R S T U V W X Y Z A B C D E 
G H I J K L M N O P Q R S T U V W X Y Z A B C D E F 
H I J K L M N O P Q R S T U V W X Y Z A B C D E F G 
I J K L M N O P Q R S T U V W X Y Z A B C D E F G H 
J K L M N O P Q R S T U V W X Y Z A B C D E F G H I 
K L M N O P Q R S T U V W X Y Z A B C D E F G H I J 
L M N O P Q R S T U V W X Y Z A B C D E F G H I J K 
M N O P Q R S T U V W X Y Z A B C D E F G H I J K L 
N O P Q R S T U V W X Y Z A B C D E F G H I J K L M 
O P Q R S T U V W X Y Z A B C D E F G H I J K L M N 
P Q R S T U V W X Y Z A B C D E F G H I J K L M N O 
Q R S T U V W X Y Z A B C D E F G H I J K L M N O P 
R S T U V W X Y Z A B C D E F G H I J K L M N O P Q 
S T U V W X Y Z A B C D E F G H I J K L M N O P Q R 
T U V W X Y Z A B C D E F G H I J K L M N O P Q R S 
U V W X Y Z A B C D E F G H I J K L M N O P Q R S T 
V W X Y Z A B C D E F G H I J K L M N O P Q R S T U 
W X Y Z A B C D E F G H I J K L M N O P Q R S T U V 
X Y Z A B C D E F G H I J K L M N O P Q R S T U V W 
Y Z A B C D E F G H I J K L M N O P Q R S T U V W X 
Z A B C D E F G H I J K L M N O P Q R S T U V W X Y</strong> </pre>
<p>Given a keyword, TRAIN, we can encode the message ENCODED IN PYTHON as follows:</p>
<ol>
<li>Repeat the keyword and message together, such that it is easy to map letters from one to the other:</li>
</ol>
<pre style="padding-left: 60px"><strong>E N C O D E D I N P Y T H O N</strong><br/><strong>T R A I N T R A I N T R A I N</strong> </pre>
<ol start="2">
<li>For each letter in the plaintext, find the row that begins with that letter in the table.</li>
<li>Find the column with the letter associated with the keyword letter for the chosen plaintext letter.</li>
<li>The encoded character is at the intersection of this row and column.</li>
</ol>
<p>For example, the row starting with E intersects the column starting with T at character X. So, the first letter in the ciphertext is X. The row starting with N intersects the column starting with R at character E, leading to the ciphertext XE. C intersects A at C, and O intersects I at W. D and N map to Q, while E and T map to X. The full encoded message is XECWQXUIVCRKHWA.</p>
<p>Decoding follows the opposite procedure. First, find the row with the character for the shared keyword (the T row), then find the location in that row where the encoded character (the X) is located. The plaintext character is at the top of the column for that row (the E).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing it</h1>
                </header>
            
            <article>
                
<p>Our program will need an <kbd>encode</kbd> method that takes a keyword and plaintext and returns the ciphertext, and a <kbd>decode</kbd> method that accepts a keyword and ciphertext and returns the original message.</p>
<p>But rather than just writing those methods, let's follow a test-driven development strategy. We'll be using <kbd>pytest</kbd> for our unit testing. We need an <kbd>encode</kbd> method, and we know what it has to do; let's write a test for that method first<span>, as follows</span>:</p>
<pre>def test_encode():<br/>    cipher = VigenereCipher("TRAIN")<br/>    encoded = cipher.encode("ENCODEDINPYTHON")<br/>    assert encoded == "XECWQXUIVCRKHWA"</pre>
<p>This test fails, naturally, because we aren't importing a <kbd>VigenereCipher</kbd> class anywhere. Let's create a new module to hold that class.</p>
<p>Let's start with the following <kbd>VigenereCipher</kbd> class:</p>
<pre>class VigenereCipher:<br/>    def __init__(self, keyword):<br/>        self.keyword = keyword<br/><br/>    def encode(self, plaintext):<br/>        return "XECWQXUIVCRKHWA"<br/><br/></pre>
<p>If we add a <kbd>from</kbd><kbd>vigenere_cipher</kbd><kbd>import</kbd><kbd>VigenereCipher</kbd> line to the top of our test class and run <kbd>pytest</kbd>, the preceding test will pass! We've finished our first test-driven development cycle.</p>
<p>This may seem like a ridiculously silly thing to test, but it's actually verifying a lot. The first time I implemented it, I mispelled cipher as <em>cypher</em> in the class name. Even my basic unit test helped catch a bug. Even so, returning a hardcoded string is obviously not the most sensible implementation of a cipher class, so let's add a second test<span>, as follows</span>:</p>
<pre>def test_encode_character(): 
    cipher = VigenereCipher("TRAIN") 
    encoded = cipher.encode("E") 
    assert encoded == "X" </pre>
<p>Ah, now that test will fail. It looks like we're going to have to work harder. But I just thought of something: what if someone tries to encode a string with spaces or lowercase characters? Before we start implementing the encoding, let's add some tests for these cases, so we don't forget them. The expected behavior will be to remove spaces, and to convert lowercase letters to capitals<span>, as follows</span>:</p>
<pre>def test_encode_spaces(): 
    cipher = VigenereCipher("TRAIN") 
    encoded = cipher.encode("ENCODED IN PYTHON") 
    assert encoded == "XECWQXUIVCRKHWA" 
 
def test_encode_lowercase(): 
    cipher = VigenereCipher("TRain") 
    encoded = cipher.encode("encoded in Python") 
    assert encoded == "XECWQXUIVCRKHWA" </pre>
<p>If we run the new test suite, we find that the new tests pass (they expect the same hardcoded string). But they ought to fail later if we forget to account for these cases.</p>
<p>Now that we have some test cases, let's think about how to implement our encoding algorithm. Writing code to use a table like we used in the earlier manual algorithm is possible, but seems complicated, considering that each row is just an alphabet rotated by an offset number of characters. It turns out (I asked Wikipedia) that we can use modular arithmetic to combine the characters instead of doing a table lookup.</p>
<p>Given plaintext and keyword characters, if we convert the two letters to their numerical values (according to their position in the alphabet, with A being 0 and Z being 25), add them together, and take the remainder mod 26, we get the ciphertext character! This is a straightforward calculation, but since it happens on a character-by-character basis, we should probably put it in its own function. Before we do that, then, we should write a test for the new function<span>, as follows</span>:</p>
<pre>from vigenere_cipher import combine_character 
def test_combine_character(): 
    assert combine_character("E", "T") == "X" 
    assert combine_character("N", "R") == "E" </pre>
<p>Now we can write the code to make this function work. In all honesty, I had to run the test several times before I got this function completely correct. First, I accidentally returned an integer, and then I forgot to shift the character back up to the normal ASCII scale from the zero-based scale. Having the test available made it easy to test and debug these errors. This is another bonus of test-driven development. The final, working version of the code looks like the following:<br/></p>
<pre>def combine_character(plain, keyword): 
    plain = plain.upper() 
    keyword = keyword.upper() 
    plain_num = ord(plain) - ord('A') 
    keyword_num = ord(keyword) - ord('A') 
    return chr(ord('A') + (plain_num + keyword_num) % 26) </pre>
<p>Now that <kbd>combine_characters</kbd> is tested, I thought we'd be ready to implement our <kbd>encode</kbd> function. However, the first thing we want inside that function is a repeating version of the keyword string that is as long as the plaintext. Let's implement a function for that first. Oops, I mean let's implement the test first, as follows:</p>
<pre>def test_extend_keyword(): cipher = VigenereCipher("TRAIN") extended = cipher.extend_keyword(16) assert extended == "TRAINTRAINTRAINT" </pre>
<p>Before writing this test, I expected to write <kbd>extend_keyword</kbd> as a standalone function that accepted a keyword and an integer. But as I started drafting the test, I realized it made more sense to use it as a helper method on the <kbd>VigenereCipher</kbd> class so it could access the <kbd>self.keyword</kbd> attribute. This shows how test-driven development can help design more sensible APIs. <span>The following is</span> the method implementation:</p>
<pre>    def extend_keyword(self, number):<br/>        repeats = number // len(self.keyword) + 1<br/>        return (self.keyword * repeats)[:number]</pre>
<p>Once again, this took a few runs of the test to get right. I ended up adding an amended copy of the test, one with fifteen and one with sixteen letters, to make sure it works if the integer division has an even number.</p>
<p>Now we're finally ready to write our <kbd>encode</kbd> method, as follows:</p>
<pre>    def encode(self, plaintext): 
        cipher = [] 
        keyword = self.extend_keyword(len(plaintext)) 
        for p,k in zip(plaintext, keyword): 
            cipher.append(combine_character(p,k)) 
        return "".join(cipher) </pre>
<p>That looks correct. Our test suite should pass now, right?</p>
<p>Actually, if we run it, we'll find that two tests are still failing. The previously failing encode test is actually passing, but we totally forgot about the spaces and lowercase characters! It is a good thing we wrote those tests to remind us. We'll have to add the following line at the beginning of the method:</p>
<pre>        plaintext = plaintext.replace(" ", "").upper() </pre>
<div class="packt_tip">If we have an idea about a corner case in the middle of implementing something, we can create a test describing that idea. We don't even have to implement the test; we can just run <kbd>assert False</kbd> to remind us to implement it later. The failing test will never let us forget the corner case and it can't be ignored as easily as a ticket in an issue tracker. If it takes a while to get around to fixing the implementation, we can mark the test as an expected failure.</div>
<p>Now all the tests pass successfully. This chapter is pretty long, so we'll condense the examples for decoding. <span>The following are a couple of tests</span>:</p>
<pre>def test_separate_character(): 
    assert separate_character("X", "T") == "E" 
    assert separate_character("E", "R") == "N" 
 
def test_decode(): 
    cipher = VigenereCipher("TRAIN") 
    decoded = cipher.decode("XECWQXUIVCRKHWA") 
    assert decoded == "ENCODEDINPYTHON" </pre>
<p>And the following is the <kbd>separate_character</kbd> function:</p>
<pre>def separate_character(cypher, keyword): 
    cypher = cypher.upper() 
    keyword = keyword.upper() 
    cypher_num = ord(cypher) - ord('A') 
    keyword_num = ord(keyword) - ord('A') 
    return chr(ord('A') + (cypher_num - keyword_num) % 26) </pre>
<p>Now we can add the <kbd>decode</kbd> method:</p>
<pre>    def decode(self, ciphertext): 
        plain = [] 
        keyword = self.extend_keyword(len(ciphertext)) 
        for p,k in zip(ciphertext, keyword): 
            plain.append(separate_character(p,k)) 
        return "".join(plain) </pre>
<p>These methods have a lot of similarity to those used for encoding. The great thing about having all these tests written and passing is that we can now go back and modify our code, knowing it is still safely passing the tests. For example, if we replace our existing <kbd>encode</kbd> and <kbd>decode</kbd> methods with the following refactored methods, our tests still pass:</p>
<pre>    def _code(self, text, combine_func): 
        text = text.replace(" ", "").upper() 
        combined = [] 
        keyword = self.extend_keyword(len(text)) 
        for p,k in zip(text, keyword): 
            combined.append(combine_func(p,k)) 
        return "".join(combined) 
 
    def encode(self, plaintext): 
        return self._code(plaintext, combine_character) 
 
    def decode(self, ciphertext): 
        return self._code(ciphertext, separate_character) </pre>
<p>This is the final benefit of test-driven development, and the most important. Once the tests are written, we can improve our code as much as we like and be confident that our changes didn't break anything we have been testing for. Furthermore, we know exactly when our refactor is finished: when the tests all pass.</p>
<p>Of course, our tests may not comprehensively test everything we need them to; maintenance or code refactoring can still cause undiagnosed bugs that don't show up in testing. Automated tests are not foolproof. If bugs do occur, however, it is still possible to follow a test-driven plan, as follows:</p>
<ol>
<li>Write a test (or multiple tests) that duplicates or <em>proves</em> that the bug in question is occurring. This will, of course, fail.</li>
<li>Then write the code to make the tests stop failing. If the tests were comprehensive, the bug will be fixed, and we will know if it ever happens again, as soon as we run the test suite.</li>
</ol>
<p>Finally, we can try to determine how well our tests operate on this code. With the <kbd>pytest</kbd> coverage plugin installed, <kbd>pytest -coverage-report=report</kbd> tells us that our test suite has 100 percent code coverage. This is a great statistic, but we shouldn't get too cocky about it. Our code hasn't been tested when encoding messages that have numbers, and its behavior with such inputs is thus undefined.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>Practice test-driven development. That is your first exercise. It's easier to do this if you're starting a new project, but if you have existing code you need to work on, you can start by writing tests for each new feature you implement. This can become frustrating as you become more enamored with automated tests. The old, untested code will start to feel rigid and tightly coupled, and will become uncomfortable to maintain; you'll start feeling like changes you make are breaking the code and you have no way of knowing, for lack of tests. But if you start small, adding tests to the code base improves it over time.</p>
<p class="mce-root"/>
<p>So, to get your feet wet with test-driven development, start a fresh project. Once you've started to appreciate the benefits (you will) and realize that the time spent writing tests is quickly regained in terms of more maintainable code, you'll want to start writing tests for existing code. This is when you should start doing it, not before. Writing tests for code that we <em>know</em> works is boring. It is hard to get interested in the project until you realize just how broken the code we thought was working really is.</p>
<p>Try writing the same set of tests using both the built-in <kbd>unittest</kbd> module and <kbd>pytest</kbd>. Which do you prefer? <kbd>unittest</kbd> is more similar to test frameworks in other languages, while <kbd>pytest</kbd> is arguably more Pythonic. Both allow us to write object-oriented tests and to test object-oriented programs with ease.</p>
<p>We used <kbd>pytest</kbd> in our case study, but we didn't touch on any features that wouldn't have been easily testable using <kbd>unittest</kbd>. Try adapting the tests to use test skipping or fixtures (an instance of <kbd>VignereCipher</kbd> would be helpful). Try the various setup and teardown methods, and compare their use to funcargs. Which feels more natural to you?</p>
<p>Try running a coverage report on the tests you've written. Did you miss testing any lines of code? Even if you have 100 percent coverage, have you tested all the possible inputs? If you're doing test-driven development, 100 percent coverage should follow quite naturally, as you will write a test before the code that satisfies that test. However, if writing tests for existing code, it is more likely that there will be edge conditions that go untested.</p>
<p>Think carefully about the values that are somehow different, <span>such as the following, for example</span>:</p>
<ul>
<li>Empty lists when you expect full ones</li>
<li>Negative numbers, zero, one, or infinity compared to positive integers</li>
<li>Floats that don't round to an exact decimal place</li>
<li>Strings when you expected numerals</li>
<li>Unicode strings when you expected ASCII</li>
<li>The ubiquitous <kbd>None</kbd> value when you expected something meaningful</li>
</ul>
<p>If your tests cover such edge cases, your code will be in good shape.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have finally covered the most important topic in Python programming: automated testing. Test-driven development is considered a best practice. The standard library <kbd>unittest</kbd> module provides a great out-of-the-box solution for testing, while the <kbd>pytest</kbd> framework has some more Pythonic syntaxes. Mocks can be used to emulate complex classes in our tests. Code coverage gives us an estimate of how much of our code is being run by our tests, but it does not tell us that we have tested the right things.</p>
<p>In the next chapter, we'll jump into a completely different topic: concurrency.</p>


            </article>

            
        </section>
    </body></html>