<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Hashing and Symbol Tables</h1>
            </header>

            <article>
                
<p>We have previously looked at lists, where items are stored in sequence and accessed by index number. Index numbers work well for computers. They are integers so they are fast and easy to manipulate. However, they don't always work so well for us. If we have an address book entry, for example, with index number 56, that number doesn't tell us much. There is nothing to link a particular contact with number 56. It just happens to be the next available position in the list.</p>
<p>In this chapter, we are going to look at a similar structure: a dictionary. A dictionary uses a keyword instead of an index number. So, if that contact was called <em>James</em>, we would probably use the keyword <em>James</em> to locate the contact. That is, instead of accessing the contact by calling <em>contacts [56]</em>, we would use <em>contacts ["james"]</em>.</p>
<p>Dictionaries are often built using hash tables. As the name suggests, hash tables rely on a concept called <strong>hashing</strong>. That is where we are going to begin our discussion.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Hashing</li>
<li>Hash tables</li>
<li>Different functions with elements</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Hashing</h1>
            </header>

            <article>
                
<p>Hashing is the concept of converting data of arbitrary size into data of fixed size. A little bit more specifically, we are going to use this to turn strings (or possibly other data types) into integers. This possibly sounds more complex than it is so let's look at an example. We want to hash the expression <kbd>hello world</kbd>, that is, we want to get a numeric value that we could say <em>represents</em> the string.</p>
<p>By using the <kbd>ord()</kbd> function, we can get the ordinal value of any character. For example, the <kbd>ord('f')</kbd> function gives 102. To get the hash of the whole string, we could just sum the ordinal numbers of each character in the string:</p>
<pre>
<strong>&gt;&gt;&gt; sum(map(ord, 'hello world'))</strong><br/><strong>1116</strong>
</pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="62" src="assets/image_07_001.jpg" width="363"/></div>
<p>This works fine. However, note that we could change the order of the characters in the string and get the same hash:</p>
<pre>
<strong>&gt;&gt;&gt; sum(map(ord, 'world hello'))</strong><br/><strong>1116</strong>
</pre>
<p>And the sum of the ordinal values of the characters would be the same for the string <kbd>gello xorld</kbd> as well, since <kbd>g</kbd> has an ordinal value which is one less than that of <kbd>h</kbd>, and x has an ordinal value that is one greater than that of <kbd>w</kbd>, hence:</p>
<pre>
<strong>&gt;&gt;&gt; sum(map(ord, 'gello xorld'))</strong><br/><strong>1116</strong>
</pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="80" src="assets/image_07_002.jpg" width="343"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Perfect hashing functions</h1>
            </header>

            <article>
                
<p>A perfect hashing function is one in which each string (as we are limiting the discussion to strings for now) is guaranteed to be unique. In practice, hashing functions normally need to be very fast, so trying to create a function that will give each string a unique hash value is normally not possible. Instead, we live with the fact that we sometimes get collisions (two or more strings having the same hash value), and when that happens, we come up with a strategy for resolving them.</p>
<p>In the meantime, we can at least come up with a way to avoid some of the collisions. We could, for example, add a multiplier, so that the hash value for each character becomes the multiplier value, multiplied by the ordinal value of the character. The multiplier then increases as we progress through the string. This is shown in the following function:</p>
<pre>
    def myhash(s): <br/>        mult = 1 <br/>        hv = 0 <br/>        for ch in s: <br/>            hv += mult * ord(ch) <br/>            mult += 1 <br/>        return hv 
</pre>
<p>We can test this function on the strings that we used earlier:</p>
<pre>
    for item in ('hello world', 'world hello', 'gello xorld'): <br/>        print("{}: {}".format(item, myhash(item))) 
</pre>
<p>Running the program, we get the following output:</p>
<pre>
<strong>% python hashtest.py</strong><br/><br/><strong>hello world: 6736</strong><br/><strong>world hello: 6616</strong><br/><strong>gello xorld: 6742</strong>
</pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="101" src="assets/image_07_003.jpg" width="456"/></div>
<p>Note that the last row is the result of multiplying the values in rows 2 and 3 such that 104 x 1 equals 104, as an example.</p>
<p>This time we get different hash values for our strings. Of course, this doesn't mean that we have a perfect hash. Let us try the strings <kbd>ad</kbd> and <kbd>ga</kbd>:</p>
<pre>
<strong>% python hashtest.py<br/></strong><br/><strong>ad: 297</strong><br/><strong>ga: 297</strong>
</pre>
<p>There we still get the same hash value for two different strings. As we have said before, this doesn't have to be a problem, but we need to devise a strategy for resolving collisions. We shall look at that shortly, but first we will study an implementation of a hash table.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Hash table</h1>
            </header>

            <article>
                
<p>A <strong>hash table</strong> is a form of list where elements are accessed by a keyword rather than an index number. At least, this is how the client code will see it. Internally, it will use a slightly modified version of our hashing function in order to find the index position in which the element should be inserted. This gives us fast lookups, since we are using an index number which corresponds to the hash value of the key.</p>
<p>We start by creating a class to hold hash table items. These need to have a key and a value, since our hash table is a key-value store:</p>
<pre>
    class HashItem: <br/>        def __init__(self, key, value): <br/>            self.key = key <br/>            self.value = value 
</pre>
<p>This gives us a very simple way to store items. Next, we start working on the hash table class itself. As usual, we start off with a constructor:</p>
<pre>
    class HashTable: <br/>        def __init__(self): <br/>            self.size = 256 <br/>            self.slots = [None for i in range(self.size)] <br/>            self.count = 0 
</pre>
<p>The hash table uses a standard Python list to store its elements. We could equally well have used the linked list that we developed previously, but right now our focus is on understanding the hash table, so we shall use what is at our disposal.</p>
<p>We set the size of the hash table to 256 elements to start with. Later, we will look at strategies for how to grow the table as we begin filling it up. We now initialize a list containing 256 elements. These elements are often referred to as slots or buckets. Finally, we add a counter for the number of actual hash table elements we have:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="70" src="assets/image_07_004.jpg" width="462"/></div>
<p>It is important to notice the difference between the size and count of a table. Size of a table refers to the total number of slots in the table (used or unused). Count of the table, on the other hand, simply refers to the number of slots that are filled, or put another way, the number of actual key-value pairs we have added to the table.</p>
<p>Now, we are going to add our hashing function to the table. It will be similar to what we evolved in the section on hashing functions, but with a slight difference: we need to ensure that our hashing function returns a value between 1 and 256 (the size of the table). A good way of doing so is to return the remainder of dividing the hash by the size of the table, since the remainder is always going to be an integer value between 0 and 255.</p>
<p>As the hashing function is only meant to be used internally by the class, we put an underscore(<kbd>_</kbd>) at the beginning of the name to indicate this. This is a normal Python convention for indicating that something is meant for internal use:</p>
<pre>
    def _hash(self, key): <br/>        mult = 1 <br/>        hv = 0 <br/>        for ch in key: <br/>            hv += mult * ord(ch) <br/>            mult += 1 <br/>        return hv % self.size 
</pre>
<p>For the time being, we are going to assume that keys are strings. We shall discuss how one can use non-string keys later. For now, just bear in mind that the <kbd>_hash()</kbd> function is going to generate the hash value of a string.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Putting elements</h1>
            </header>

            <article>
                
<p>We add elements to the hash with the <kbd>put()</kbd> function and retrieve with the <kbd>get()</kbd> function. First, we will look at the implementation of the <kbd>put()</kbd> function. We start by embedding the key and the value into the <kbd>HashItem</kbd> class and computing the hash of the key:</p>
<pre>
    def put(self, key, value): <br/>        item = HashItem(key, value) <br/>        h = self._hash(key) 
</pre>
<p>Now we need to find an empty slot. We start at the slot that corresponds to the hash value of the key. If that slot is empty, we insert our item there.</p>
<p>However, if the slot is not empty and the key of the item is not the same as our current key, then we have a collision. This is where we need to figure out a way to handle a conflict. We are going to do this by adding one to the previous hash value we had and getting the remainder of dividing this value by the size of the hash table. This is a linear way of resolving collisions and it is quite simple:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="218" src="assets/image_07_005.jpg" width="368"/></div>
<pre>
    while self.slots[h] is not None: <br/>        if self.slots[h].key is key: <br/>            break <br/>        h = (h + 1) % self.size 
</pre>
<p>We have found our insertion point. If this is a new element (that is, it contained <kbd>None</kbd> previously), then we increase the count by one. Finally, we insert the item into the list at the required position:</p>
<pre>
    if self.slots[h] is None: <br/>        self.count += 1 <br/>    self.slots[h] = item  
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting elements</h1>
            </header>

            <article>
                
<p>The implementation of the <kbd>get()</kbd> method should return the value that corresponds to a key. We also have to decide what to do in the event that the key does not exist in the table. We start by calculating the hash of the key:</p>
<pre>
    def get(self, key): <br/>        h = self._hash(key)
</pre>
<p>Now, we simply start looking through the list for an element that has the key we are searching for, starting at the element which has the hash value of the key that was passed in. If the current element is not the correct one, then, just like in the <kbd>put()</kbd> method, we add one to the previous hash value and get the remainder of dividing this value by the size of the list. This becomes our new index. If we find an element that contains <kbd>None</kbd>, we stop looking. If we find our key, we return the value:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="202" src="assets/image_07_006.jpg" width="376"/></div>
<pre>
        while self.slots[h] is not None: <br/>            if self.slots[h].key is key: <br/>                return self.slots[h].value <br/>            h = (h+ 1) % self.size 
</pre>
<p>Finally, we decide what to do if the key was not found in the table. Here we will choose to return <kbd>None</kbd>. Another good alternative may be to raise an exception:</p>
<pre>
        return None 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Testing the hash table</h1>
            </header>

            <article>
                
<p>To test our hash table, we create a <kbd>HashTable</kbd>, put a few elements in it, then try to retrieve these. We will also try to <kbd>get()</kbd> a key that does not exist. Remember the two strings ad and ga which returned the same hash value by our hashing function? For good measure, we throw those in as well, just to see that the collision is properly resolved:</p>
<pre>
    ht = HashTable() <br/>    ht.put("good", "eggs") <br/>    ht.put("better", "ham") <br/>    ht.put("best", "spam") <br/>    ht.put("ad", "do not") <br/>    ht.put("ga", "collide") <br/><br/>    for key in ("good", "better", "best", "worst", "ad", "ga"): <br/>        v = ht.get(key) <br/>        print(v) 
</pre>
<p>Running this returns the following:</p>
<pre>
<strong>% python hashtable.py<br/></strong><br/><strong>eggs</strong><br/><strong>ham</strong><br/><strong>spam</strong><br/><strong>None</strong><br/><strong>do not</strong><br/><strong>collide</strong>  
</pre>
<p>As you can see, looking up the key worst returns <kbd>None</kbd>, since the key does not exist. The keys <kbd>ad</kbd> and <kbd>ga</kbd> also return their corresponding values, showing that the collision between them is dealt with.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using [] with the hash table</h1>
            </header>

            <article>
                
<p>Using the <kbd>put()</kbd> and <kbd>get()</kbd> methods doesn't look very good, however. We want to be able to treat our hash table as a list, that is, we would like to be able to use <kbd>ht["good"]</kbd> instead of <kbd>ht.get("good")</kbd>. This is easily done with the special methods <kbd>__setitem__()</kbd> and <kbd>__getitem__()</kbd>:</p>
<pre>
    def __setitem__(self, key, value): <br/>        self.put(key, value) <br/><br/>    def __getitem__(self, key): <br/>        return self.get(key) 
</pre>
<p>Our test code can now look like this instead:</p>
<pre>
    ht = HashTable() <br/>    ht["good"] = "eggs" <br/>    ht["better"] = "ham" <br/>    ht["best"] = "spam" <br/>    ht["ad"] = "do not" <br/>    ht["ga"] = "collide" <br/><br/>    for key in ("good", "better", "best", "worst", "ad", "ga"): <br/>        v = ht[key] <br/>        print(v) <br/><br/>    print("The number of elements is: {}".format(ht.count)) 
</pre>
<p>Notice that we also print the number of elements in the hash table. This is useful for our next discussion.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Non-string keys</h1>
            </header>

            <article>
                
<p>In most cases, it makes more sense to just use strings for the keys. However, if necessary, you could use any other Python type. If you create your own class that you want to use as a key, you will probably want to override the special <kbd>__hash__()</kbd> function for that class, so that you get reliable hash values.</p>
<p>Note that you would still have to calculate the modulo (%) of the hash value and the size of the hash table to get the slot. That calculation should happen in the hash table and not in the key class, since the table knows its own size (the key class should not know anything about the table that it belongs to).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Growing a hash table</h1>
            </header>

            <article>
                
<p>In our example, the hash table's size was set to 256. Obviously, as we add elements to the list, we begin to fill up the empty slots. At some point, all the slots will be filled up and the table will be full. To avoid this, we can grow the table when it is getting full.</p>
<p>To do this, we compare the size and the count. Remember that <kbd>size</kbd> held the total number of slots and <kbd>count</kbd> the number of those slots that contained elements? Well, if <kbd>count</kbd> equals <kbd>size</kbd> then we have filled up the table.</p>
<p>The hash table's load factor gives us an indication of how large a portion of the available slots are being used. It is defined as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="92" src="assets/image_07_007.jpg" width="249"/></div>
<p>As the load factor approaches 1, we need to grow the table. In fact, we should do it before it gets there in order to avoid gets becoming too slow. A value of 0.75 may be a good value in which to grow the table.</p>
<p>The next question is how much to grow the table by. One strategy would be to simply double the size of the table.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Open addressing</h1>
            </header>

            <article>
                
<p>The collision resolution mechanism we used in our example, linear probing, is an example of an open addressing strategy. Linear probing is really simple since we use a fixed interval between our probes. There are other open addressing strategies as well but they all share the idea that there is an array of slots. When we want to insert a key, we check whether the slot already has an item or not. If it does, we look for the next available slot.</p>
<p>If we have a hash table that contains 256 slots, then 256 is the maximum number of elements in that hash. Moreover, as the load factor increases, it will take longer to find the insertion point for the new element.</p>
<p>Because of these limitations, we may prefer to use a different strategy to resolve collisions, such as chaining.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Chaining</h1>
            </header>

            <article>
                
<p>Chaining is a strategy for resolving conflicts and avoiding the limit to the number of elements in a hash table. In chaining, the slots in the hash table are initialized with empty lists:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="152" src="assets/image_07_008.jpg" width="298"/></div>
<p>When an element is inserted, it will be appended to the list that corresponds to that element's hash value. That is, if you have two elements that both have the hash value 1167, these two elements will both be added to the list that exists in slot 1167 of the hash table:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="83" src="assets/image_07_009.jpg" width="626"/></div>
<p>The preceding diagram shows a list of entries with hash value 51.</p>
<p>Chaining then avoids conflict by allowing multiple elements to have the same hash value. It also avoids the problem of insertions as the load factor increases, since we don't have to look for a slot. Moreover, the hash table can hold more values than the number of available slots, since each slot holds a list that can grow.</p>
<p>Of course, if a particular slot has many items, searching them can get very slow, since we have to do a linear search through the list until we find the element that has the key we want. This can slow down retrieval, which is not good, since hash tables are meant to be efficient:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="85" src="assets/image_07_010.jpg" width="600"/></div>
<p>The preceding diagram demonstrates a linear search through list items until we find a match.</p>
<p>Instead of using lists in the table slots, we could use another structure that allows for fast searching. We have already looked at <strong>binary search trees</strong> (<strong>BSTs</strong>). We could simply put an (initially empty) BST in each slot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="150" src="assets/image_07_011.jpg" width="531"/></div>
<p>Slot 51 holds a BST which we search for the key.</p>
<p>But we would still have a potential problem: depending on the order in which the items were added to the BST, we could end up with a search tree that is as inefficient as a list. That is, each node in the tree has exactly one child. To avoid this, we would need to ensure that our BST is self-balancing.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Symbol tables</h1>
            </header>

            <article>
                
<p>Symbol tables are used by compilers and interpreters to keep track of the symbols that have been declared and information about them. Symbol tables are often built using hash tables, since it is important to efficiently retrieve a symbol in the table.</p>
<p>Let us look at an example. Suppose we have the following Python code:</p>
<pre>
    name = "Joe" <br/>    age = 27 
</pre>
<p>Here we have two symbols, name and age. They belong to a namespace, which could be <kbd>__main__</kbd>, but it could also be the name of a module if you placed it there. Each symbol has a value; name has the value <kbd>Joe</kbd> and age has the value <kbd>27</kbd>. A symbol table allows the compiler or the interpreter to look these values up. The symbols name and age become the keys in our hash table. All the other information associated with it, such as the value, become part of the value of the symbol table entry.</p>
<p>Not only variables are symbols, but functions and classes as well. They will all be added to our symbol table, so that when any one of them needs to be accessed, they are accessible from the symbol table:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="187" src="assets/image_07_012.jpg" width="514"/></div>
<p>In Python, each module that is loaded has its own symbol table. The symbol table is given the name of that module. This way, modules act as namespaces. We can have multiple symbols called age, as long as they exist in different symbol tables. To access either one, we access it through the appropriate symbol table:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="82" src="assets/image_07_013.jpg" width="412"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we have looked at hash tables. We looked at how to write a hashing function to turn string data into integer data. Then we looked at how we can use hashed keys to quickly and efficiently look up the value that corresponds to a key.</p>
<p>We also noticed how hashing functions are not perfect and that several strings can end up having the same hash value. This led us to look at collision resolution strategies.</p>
<p>We looked at growing a hash table and how to look at the load factor of the table in order to determine exactly when to grow the hash.</p>
<p>In the last section of the chapter, we studied symbol tables, which often are built using hash tables. Symbol tables allow a compiler or an interpreter to look up a symbol (variable, function, class, and so on) that has been defined and retrieve all information about it.</p>
<p>In the next chapter, we will talk about graphs and other algorithms.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>