<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Logic, Comparisons, and Conditions</h1></div></div></div><p>Our exploration of the Python language started with expression statements and the assignment statement. We can view output using the <code class="literal">print()</code> function as a simple statement. We can gather input using the <code class="literal">input()</code> function in an assignment statement. In order to process data conditionally, we need the <code class="literal">if</code> statement.</p><p>In order to look at the <code class="literal">if</code> statement, we'll need to look at Boolean data and Boolean operators. The <code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">not</code>, and <code class="literal">if-else</code> Boolean operators have a "short-circuit" behavior: if the result is defined by just the left-hand operand, the right-hand side is not evaluated. This is an important feature of these logic operators. (The <code class="literal">if-else</code> operator is formally called<a class="indexterm" id="id283"/> the <strong>Boolean expression</strong>, but it behaves like the Boolean operators.)</p><p>We'll also look at the comparison operators. A comparison is a common way to create the Boolean values used to choose between suites of statements within an <code class="literal">if</code> statement.</p><p>We'll<a class="indexterm" id="id284"/> introduce the <code class="literal">pass</code> statement here. This statement does nothing. It's a place-holder to use when an empty suite of statements is all we need.</p><p>The <code class="literal">assert</code> statement<a class="indexterm" id="id285"/> can be used to demonstrate that a particular logical condition is true at some point in the program's execution. This can clarify a potentially confusing algorithm. It can also serve as a handy debugging tool to make a program crash when something has gone awry.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Boolean data and the bool() function</h1></div></div></div><p>All objects<a class="indexterm" id="id286"/> can <a class="indexterm" id="id287"/>have a mapping to the Boolean domain of values: <code class="literal">True</code> and <code class="literal">False</code>. All of the built-in classes have this mapping defined. When we define our own classes, we need to consider this Boolean mapping as a design feature.</p><p>The built-in classes operate on a simple principle: if there's clearly no data, the object should map to <code class="literal">False</code>. Otherwise, it should map to <code class="literal">True</code>. Here are some detailed examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">None</code> object maps to <code class="literal">False</code>.</li><li class="listitem" style="list-style-type: disc">For all of the various kinds of numbers, a zero value maps to <code class="literal">False</code>. All non-zero values are <code class="literal">True</code>.</li><li class="listitem" style="list-style-type: disc">For all of the collections (including <code class="literal">str</code>, <code class="literal">bytes</code>, <code class="literal">tuple</code>, <code class="literal">list</code>, <code class="literal">dict</code>, <code class="literal">set</code>, and so on) an empty collection is <code class="literal">False</code>. A non-empty collection is <code class="literal">True</code>.</li></ul></div><p>We can<a class="indexterm" id="id288"/> use the <code class="literal">bool()</code> function to see this mapping between<a class="indexterm" id="id289"/> object and a Boolean:</p><div><pre class="programlisting">&gt;&gt;&gt; red_violet= (192, 68, 143)
&gt;&gt;&gt; bool(red_violet)
True
&gt;&gt;&gt; empty = ()
&gt;&gt;&gt; type(empty)
&lt;class 'tuple'&gt;
&gt;&gt;&gt; bool(empty)
False</pre></div><p>We've created a simple sequence, a <code class="literal">tuple</code> of three values, and assigned it to the <code class="literal">red_violet</code> variable. Since this is non-empty, it maps to <code class="literal">True</code>. On the other hand, the empty tuple, assigned to the <code class="literal">empty</code> variable, maps to <code class="literal">False</code>.</p><p>One important consequence of this built-in mapping is that any object can be used in a Boolean construct. Looking ahead, we'll often see programs with constructs that echo this idiomatic pattern:</p><div><pre class="programlisting">for input from some_file:
    if not input.strip(): continue</pre></div><p>Some details of this example will have to wait for <a class="link" href="ch10.html" title="Chapter 10. Files, Databases, Networks, and Contexts">Chapter 10</a>, <em>Files, Databases, Networks, and Contexts</em>. What's important about this example is that we can read a line from a file, strip whitespace with the <code class="literal">strip()</code> method, and use a simple Boolean expression to see if the result is an empty string. If it is an empty string, we can easily ignore it by using the <code class="literal">continue</code> statement.</p><p>This construct works because strings map to Boolean values. An empty string maps to <code class="literal">False</code>, allowing us to check for the absence of content with a very simple and elegant expression.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Comparison operators</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Simple Data Types">Chapter 2</a>, <em>Simple Data Types</em>, we looked at the six essential comparison operators: <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">==</code>, <code class="literal">!=</code>, <code class="literal">&lt;=</code>, and <code class="literal">&gt;=</code>. The minimum of <code class="literal">==</code> and <code class="literal">!=</code> are defined by default for all classes, so that we <a class="indexterm" id="id290"/>can always compare objects for simple equality. For the numeric types, the ordering operators are also defined. Furthermore, Python's type coercion rules are implemented by the numeric types so that the expression <code class="literal">2 &lt; 3.0</code> will have the <code class="literal">int</code> coerced to <code class="literal">float</code>.</p><p>For sequences, including <code class="literal">str</code>, <code class="literal">bytes</code>, <code class="literal">tuple</code>, and <code class="literal">list</code>, the two operands are compared item-by-item. This tends to put strings into alphabetical order. This works well for words. It also usually puts tuples into the expected order. However, for number-like strings, the sorting may seem a little odd. Here's the example:</p><div><pre class="programlisting">&gt;&gt;&gt; "11" &lt; "2"
True</pre></div><p>The strings <code class="literal">"11"</code> and <code class="literal">"2"</code> are not numbers. They're only characters. It's a common confusion to imagine these values as numbers and hope that <code class="literal">"11"</code> comes after <code class="literal">"2"</code>. If this is the desired behavior, we'll need to convert these number-like strings to proper numbers using the <code class="literal">int()</code> function.</p><p>For <code class="literal">set</code> objects, the comparison operators map to the superset and subset relationships. Python's <code class="literal">&lt;</code> operator is implemented as the proper subset relationship. The <code class="literal">&lt;=</code> operator is implemented as the subset relationship. We'll look at this in detail in <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <em>More Complex Data Types</em>.</p><p>For other types, comparisons become less meaningful. Orderings between mappings is not a simple concept. How do we order two mappings: do we compare keys only, values only, or some combination of both? If we try to compare both keys and values, what are the rules for missing keys? Since there's no simple answer, Python doesn't define the ordering operators for mappings.</p><p>For types outside the numeric tower, there are no coercion rules. The equality comparisons simply compare the object IDs to see if the two operands are references to same object.</p><p>In general, ordering operators are not implemented by default and will raise <code class="literal">TypeError</code> exceptions. This is a common expectation for many classes. </p><p>If we try to compare two file objects, what attribute of the file should we be comparing? Size? Creation date? Rather than create confusion, comparison operators are simply not implemented for many classes.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Combining comparisons to simplify the logic</h2></div></div></div><p>In some cases, we may need to see if a value lies within a given range. One handy syntax simplification <a class="indexterm" id="id291"/>is to combine ordering comparisons into a simplified expression. We can meaningfully write expressions like this:</p><div><pre class="programlisting">5 &gt; a &gt;= 0</pre></div><p>In this kind <a class="indexterm" id="id292"/>of expression, Python interprets the combined operators to mean <code class="literal">5 &gt; a</code> and <code class="literal">a &gt;= 0</code>. We aren't forced to repeat the middle expression, <code class="literal">a</code>, to decompose the ordering test into two binary comparisons.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec44"/>Testing float values</h2></div></div></div><p>One <a class="indexterm" id="id293"/>important feature of float values is that they are <a class="indexterm" id="id294"/>only approximations. We can easily write calculations which seem mathematically exact, but produce odd-looking results. Specific examples vary a bit from implementation to implementation. Here's one example:</p><div><pre class="programlisting">&gt;&gt;&gt; a=1
&gt;&gt;&gt; b=(a/105)*3*5*7
&gt;&gt;&gt; a == b
False
&gt;&gt;&gt; abs(a-b)
2.220446049250313e-16</pre></div><p>In an abstract mathematical sense, <code class="literal">(a/105)*3*5*7</code>, must equal the original value of the <code class="literal">a</code> variable. We can see, however, that the floating-point approximation created by the true division operator has a small error. In this case, the error value is approximately <code class="literal">2.22e-16</code>, which is <code class="literal">2**-52</code>: the least significant bit of a 52-bit value is incorrect after this chain of floating-point operations.</p><p>Because of the presence of these small error terms, we should avoid trivial <code class="literal">==</code> tests with floating-point values. A simple equality test can often turn out to be false when the two values differ by a tiny amount.</p><p>Generally, we should use <code class="literal">abs(a-b) &lt; ε</code> instead of <code class="literal">a == b</code>. We can set the <code class="literal">ε</code> value to be small enough to detect what is equal. If, for example, we're going to display a value with three decimal places, there's little reason to compute anything past the 5th decimal place. In that case, <code class="literal">ε=10e-5</code> can be used to define the acceptable tolerance for floating-point equality.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>Avoid <code class="literal">float == float</code> comparisons; use <code class="literal">abs(float-float) &lt; ε</code> instead.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Comparing object IDs with the is operator</h2></div></div></div><p>To <a class="indexterm" id="id295"/>determine if two <a class="indexterm" id="id296"/>variables are actually referencing the same object, we have a special comparison operator: <code class="literal">is</code>. This is different from the somewhat more complex equality test. The <code class="literal">is</code> operator is a very simple test comparing the internal identifiers for two objects.</p><p>If <code class="literal">a is b</code>, then <code class="literal">a == b</code> must also be true, as the two variables refer to the same underlying object. However, if <code class="literal">a == b</code>, then <code class="literal">a is b</code> may not necessarily be true. Two distinct<a class="indexterm" id="id297"/> objects can have the <a class="indexterm" id="id298"/>same value. Here's an example using floating-point values:</p><div><pre class="programlisting">&gt;&gt;&gt; a = 3.14
&gt;&gt;&gt; b = 3.14
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a is b
False</pre></div><p>This example works nicely for floating-point objects. We can see that two seemingly-equal objects are actually distinct instances which represent the same numeric value.</p><p>An example like this doesn't work for small integer values, however. For a narrow range of integer values, Python tends to reuse a small pool of internal objects. This avoids the proliferation of copies of ubiquitous values. If we try to set <code class="literal">a=1</code> and <code class="literal">b=1</code>, we'll see that <code class="literal">a is b</code>: Python reused the same object.</p><p>With a little experimentation, we can see that the reuse of small integers is true for numbers between -5 and 256. Implementation details will vary. What's important is that some immutable objects are implicitly allocated from a pool.</p><p>Object identity is revealed with the <code class="literal">id()</code> function. This shows the unique, internal object identifier. For example:</p><div><pre class="programlisting">&gt;&gt;&gt; id(a)
4298491200
&gt;&gt;&gt; id(b)
4298491224</pre></div><p>We can see that these are two distinct objects which happen to be equal in value.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Equality and object hash values</h2></div></div></div><p>An important <a class="indexterm" id="id299"/>part of equality comparison in Python is the hash value comparison. A hash is a small integer value that summarizes <a class="indexterm" id="id300"/>a larger, more complex value. A hash should not change; mutable objects should not provide a hash value.</p><p>Any object that we're going to collect into a set or use as a key to a mapping must provide both a hash value and a proper equality comparison. All of the built-in immutable types we've seen—numbers, <code class="literal">tuple</code>, <code class="literal">str</code>, and <code class="literal">bytes</code>—offer the necessary implementations of these methods. The built-in mutable types that we'll look at in <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <em>More Complex Data Types</em>, such as <code class="literal">list</code>, <code class="literal">set</code>, and <code class="literal">dict</code>, don't provide a hash value and can't be used as keys in a mapping.</p><p>A hash function reduces a complex value to a small number. In Python, hash values generally use 61 bits. For a complex object, the hash value summarizes the object as a whole. It <a class="indexterm" id="id301"/>might be a sum of all the individual bytes, computed <img alt="Equality and object hash values" src="img/B03671_05_01.jpg"/>. It might be a sum of hash values for other internal objects. Comparing hash values makes for significantly less work than comparing each individual item in a complex object.</p><p>For immutable<a class="indexterm" id="id302"/> objects, the hash value is computed once and will be as immutable as the object itself. For mutable objects, a hash value could be computed. However, if the hash value changes, then the object won't behave well as an item in a set or as a key to a mapping. A changing hash value for a mutable object is not a very good idea.</p><p>When putting items into a set, for example, Python does a quick equality check using the hash values. If the hash values are different, the underlying objects must be different, and no more comparison needs to be done. If the hash values match, however, then the detailed equality test must be used to see if the objects really are equal or only happen to have the same hash value.</p><p>In some implementations of Python, you can use this kind of test to see if two different numbers happen to have the same hash value:</p><div><pre class="programlisting">&gt;&gt;&gt; hash(12)
12
&gt;&gt;&gt; hash(12*2**61)
12</pre></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Implementations vary; this was Mac OS X, v3.3.4:7ff62415e426, your results may be different.</p></div></div><p>If we tried to put these two values into a set, Python would do a hash check to see that they are <em>potentially</em> equal, followed by a detailed comparison to see that they're not equal.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Logic operators – and, or, not, if-else</h1></div></div></div><p>Python offers us four logical operators: <code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">not</code>, and <code class="literal">if-else</code>. These work with Boolean<a class="indexterm" id="id303"/> values to create Boolean results. They're entirely<a class="indexterm" id="id304"/> distinct <a class="indexterm" id="id305"/>from the bit-wise<a class="indexterm" id="id306"/> operators of <code class="literal">&amp;</code>, <code class="literal">|</code>, <code class="literal">^</code>, and <code class="literal">~</code>, that we looked at in <a class="link" href="ch02.html" title="Chapter 2. Simple Data Types">Chapter 2</a>, <em>Simple Data Types</em>.</p><p>The <code class="literal">and</code>, <code class="literal">or</code>, and <code class="literal">not</code> operators <a class="indexterm" id="id307"/>are common in all programming languages. They fit the widely-used definitions from Boolean algebra.</p><p>The <code class="literal">if-else</code> Boolean expression has three operands. In the middle, it uses a Boolean condition, but the other two operands can be objects of any types. Here's an example:</p><div><pre class="programlisting">selection = "yankee" if wind &lt; 15 else "stays'l"</pre></div><p>The <code class="literal">if-else</code> operator has a Boolean condition in the middle. In this example, it's the comparison, <code class="literal">wind &lt; 15</code>. If the condition is <code class="literal">True</code>, then the left-most expression is the result, the string <code class="literal">"yankee"</code>. If the condition is <code class="literal">False</code>, then the right-most expression is the result; here, it's <code class="literal">"stays'l"</code>.</p><p>The logical <a class="indexterm" id="id308"/>operators implicitly apply the <code class="literal">bool()</code> function to their operands. This means that we can do things like the following:</p><div><pre class="programlisting">valid= line and line[0] != "#"</pre></div><p>The <code class="literal">and</code> expression involves two Boolean operands. When Python implicitly evaluates <code class="literal">bool(line)</code>, a non-empty line will be <code class="literal">True</code>; a zero-length line will be <code class="literal">False</code>. The <code class="literal">valid</code> variable will be <code class="literal">False</code> for empty lines; it will also be <code class="literal">False</code> for non-empty lines where <code class="literal">line[0]</code> is not the <code class="literal">"#"</code> character.</p><p>This implicit use of <code class="literal">bool()</code> also means this is true:</p><div><pre class="programlisting">&gt;&gt;&gt; not 12
False</pre></div><p>The value of <code class="literal">not 12</code> is evaluated as <code class="literal">not bool(12)</code>. The <code class="literal">bool()</code> value of a non-zero numeric value is <code class="literal">True</code>; the final result of this expression is therefore <code class="literal">False</code>.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Short-circuit (or non-strict) evaluation</h2></div></div></div><p>Consider <a class="indexterm" id="id309"/>the following:</p><div><pre class="programlisting">&gt;&gt;&gt; total= 0
&gt;&gt;&gt; count= 0
&gt;&gt;&gt; average = total != 0 and total/count
&gt;&gt;&gt; average
False</pre></div><p>What just<a class="indexterm" id="id310"/> happened? Or, more precisely, what didn't happen? Why doesn't this raise a <code class="literal">ZeroDivisionError</code> exception? The first two assignment statements are unsurprising; they assign zero to two variables, <code class="literal">total</code> and <code class="literal">count</code>. The logical expression, however, has a number of interesting features. Firstly, Python evaluates expressions left-to-right. This means that the <code class="literal">total != 0</code> subexpression is evaluated first. The result of this comparison is <code class="literal">False</code>.</p><p>Secondly, and perhaps more importantly, the <code class="literal">and</code> operator breaks the strict evaluation rules. If the left side value is equivalent to <code class="literal">False</code>, the overall result is <code class="literal">False</code>. The right side is not evaluated at all. If the left side value is equivalent to <code class="literal">True</code>, the result is simply the right side value.</p><p>This is sometimes called a short-circuit evaluation rule. There's no reason to evaluate the right side if <a class="indexterm" id="id311"/>the result is known from the left side.</p><p>The result is not necessarily a Boolean; it's simply one of the operands given to the <code class="literal">and</code> operator. Here are some examples:</p><div><pre class="programlisting">&gt;&gt;&gt; 0 and 12
0
&gt;&gt;&gt; () and "non-false"
()
&gt;&gt;&gt; 12 and ()
()</pre></div><p>In the<a class="indexterm" id="id312"/> first example, <code class="literal">0</code> is equivalent to <code class="literal">False</code>, and that<a class="indexterm" id="id313"/> object is the entire result of the <code class="literal">and</code> operator. In the second example, the empty tuple, <code class="literal">()</code>, is equivalent to <code class="literal">False</code>; it is the result of the operator.</p><p>In the third example, the left hand side, <code class="literal">12</code>, is non-zero, and therefore, equivalent to <code class="literal">True</code>. This means that the right side must be evaluated. The right side is the result of the <code class="literal">and</code> operator; in this case, it is an empty tuple, <code class="literal">()</code>.</p><p>The <code class="literal">or</code> operator is similar; if the left side is equivalent to <code class="literal">True</code>, there's no reason to evaluate the right side. We can use this feature to apply default values.</p><p>We can write expressions like the following.</p><div><pre class="programlisting">x = parameter or 42</pre></div><p>If the value of the <code class="literal">parameter</code> variable is a <code class="literal">True</code> value, the value of the <code class="literal">or</code> operator will be that equivalent-to-true value. If the value of the <code class="literal">parameter</code> variable is not a <code class="literal">True</code> value (for example, it might be <code class="literal">None</code>), then the result will be the literal value 42.</p><p>We can, of course, also use the <code class="literal">if-else</code> operator for this. Here's an example:</p><div><pre class="programlisting">x = 42 if parameter is None else parameter</pre></div><p>If the value of the <code class="literal">parameter</code> variable is the <code class="literal">None</code> object, the left side operand—the literal 42—is the result. If the value of the <code class="literal">parameter</code> variable is not the <code class="literal">None</code> object, then the right side operator—the value of the <code class="literal">parameter</code> variable—is the result.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>The if-elif-else statement</h1></div></div></div><p>Our central<a class="indexterm" id="id314"/> tool for conditional processing is the <code class="literal">if</code> statement. This is a compound statement which is built from a number of clauses. The initial clause starts with the <code class="literal">if</code> keyword. Any number of <code class="literal">elif</code> (short for "else if") clauses can be used. Each of these clauses has a conditional expression and an indented suite of statements. We can also add a single catch-all <code class="literal">else</code> clause at the end; this doesn't have a condition, but does have a suite of statements.</p><p>The minimal <code class="literal">if</code> statement, with a single clause, might look like this:</p><div><pre class="programlisting">if abs(a-b) &lt; ε:
    print("{a} \N{ALMOST EQUAL TO} {b}".format(a=a, b=b))</pre></div><p>The <code class="literal">if</code> statement contains a single expression. If the expression is <code class="literal">True</code>, the suite of statements is executed. In this case, the suite is a single expression statement, using the <code class="literal">print()</code> function.</p><p>The <code class="literal">else</code> clause <a class="indexterm" id="id315"/>can be used in simple <code class="literal">if</code> statements.</p><div><pre class="programlisting">if count == 0:
    print("Insufficient Data")
else:
    print("Mean = {0:.2f}".format(total/count))</pre></div><p>In this case, we have two conditions. We've formally stated the <code class="literal">count == 0</code> condition for one <code class="literal">print()</code> function. We have an unstated condition for the other <code class="literal">print()</code> function. It's relatively easy—in this simple case—to deduce the implied condition.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec48"/>Adding elif clauses</h2></div></div></div><p>In some cases, we<a class="indexterm" id="id316"/> can decompose complex situations into a list of cases. For example, we might have some conditions like this:</p><div><pre class="programlisting">if y % 400 == 0:
    leap = True
elif y % 100 == 0:
    leap = False
elif y % 4 == 0:
    leap = True
else:
    leap = False</pre></div><p>We've written a rather complex chain of logic here. We've specified four distinct conditions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">y</code> is a multiple of 400, in which case, the <code class="literal">leap</code> variable will be set to <code class="literal">True</code>. For example, the year 2000 was a leap year.</li><li class="listitem" style="list-style-type: disc"><code class="literal">y</code> is a multiple of 100 (and not a multiple of 400), in which case, the <code class="literal">leap</code> variable will be set to <code class="literal">False</code>. The year 2100 will not be a leap year.</li><li class="listitem" style="list-style-type: disc"><code class="literal">y</code> is a multiple of 4 (and neither a multiple of 100 nor of 400), which sets the <code class="literal">leap</code> variable to <code class="literal">True</code>. The year 2016 will be a leap year.</li><li class="listitem" style="list-style-type: disc"><code class="literal">y</code> is not a multiple of 4, 100, or 400, the <code class="literal">leap</code> variable is set to <code class="literal">False</code>. The year 2015 is not a leap year.</li></ul></div><p>Since Python evaluates the clauses in a strict order, each <code class="literal">elif</code> clause has an implicit "and not any of the previous clauses". This means that the conditions in each <code class="literal">elif</code> can be written very succinctly, but they also need the previous clauses as part of their context.</p><p>As the<a class="indexterm" id="id317"/> number of <code class="literal">elif</code> clauses grows, the possibility of introducing a subtle logic bug also grows. This can create the situation where the implied condition for the <code class="literal">else</code> clause is very hard to deduce correctly. Consequently, some programs include logic that looks like this:</p><div><pre class="programlisting">if y % 400 == 0:
    leap = True
elif y % 400 != 0 and y % 100 == 0:
    leap = False
elif y % 400 != 0 and y % 100 != 0 and y % 4 == 0:
    leap = True
elif y % 400 != 0 and y % 100 != 0 and y % 4 != 0:
    leap = False
else:
    raise Exception("Logic Error")</pre></div><p>This example shows each implied condition written out fully. It also shows the <code class="literal">else</code> clause used to raise an exception in the unlikely case that a condition was overlooked or misstated. Some developers argue that this is simply a waste of time. Others recognize that anything which is merely implied is a possible source of errors, and prefer to state conditions explicitly.</p><p>For simple sets of conditions, this may be needless over-engineering. In other cases, this long-winded variation is more reliable because it removes all assumptions and implicit conditions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>The pass statement as a placeholder</h1></div></div></div><p>In some<a class="indexterm" id="id318"/> algorithms, an <code class="literal">else</code> clause may be more important than an <code class="literal">if</code> clause. This happens when an algorithm is designed to handle a certain set of conditions—the happy path—by default. All of the other non-happy-path conditions require some exceptional processing.</p><p>When the default condition is relatively clear and easy to write, but there's no processing required for the condition, we have a syntax issue in Python. The interesting processing belongs to an <code class="literal">else</code> clause, but we have no real code for the initial <code class="literal">if</code> clause. Here's a typical pattern shown with invalid syntax:</p><div><pre class="programlisting">if happy_path(x):
    # nothing special required
else:
    some_special_processing(x)
# Processing Continues</pre></div><p>The <code class="literal">happy_path()</code> condition confirms that the default processing will work. There's no actual processing do be done when this is true. Since we don't want to do anything, what do we write in the <code class="literal">if</code> clause?</p><p>The<a class="indexterm" id="id319"/> preceding code is invalid Python. We can't have an empty suite in the <code class="literal">if</code> clause. Since we can't write the code that's shown, we have to find alternative syntax that works.</p><p>One obvious choice is to negate the logic of the <code class="literal">happy_path()</code> condition. We can simply use the <code class="literal">not</code> operator.</p><div><pre class="programlisting">if not happy_path(x):
    some_special_processing(x)</pre></div><p>This has the desired effect. However, the <code class="literal">not</code> operator may be hard to see. When the <code class="literal">happy_path()</code> condition is a complex logic expression, the extra <code class="literal">not</code> can be confusing.</p><p>This is where the Python <code class="literal">pass</code> statement might be clearer than the <code class="literal">not</code> operator. It would look like this:</p><div><pre class="programlisting">if happy_path(x):
    pass # nothing special required
else:
    some_special_processing(x)
# Processing Continues</pre></div><p>We've filled the syntactic void in the <code class="literal">if</code> clause with a "do nothing" statement. We have used <code class="literal">pass</code> to create a proper suite in the <code class="literal">if</code> clause. We left the comment in place because that kind of information might be helpful.</p><p>There are a few other uses for the <code class="literal">pass</code> statement. We'll look at them in <a class="link" href="ch11.html" title="Chapter 11. Class Definitions">Chapter 11</a>, <em>Class Definitions</em>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>The assert statement</h1></div></div></div><p>The <code class="literal">assert</code> statement is a highly specialized form of <code class="literal">if</code> statement. This statement confirms that <a class="indexterm" id="id320"/>a given condition is true. If the condition is not true, the <code class="literal">assert</code> statement raises an exception. In the simplest case, the script stops running because the exception is not handled in our programming.</p><p>It looks like this:</p><div><pre class="programlisting">assert a &gt; b &gt;= 0</pre></div><p>We have used an <code class="literal">assert</code> statement to provide documentation of a relationship between variables that must be true at a given point in our Python script, function, or method. If the condition, <code class="literal">a &gt; b &gt;= 0</code>, is false, then the <code class="literal">AssertionError</code> exception is raised.</p><p>We can customize the exception which is raised by providing a second argument to the <code class="literal">assert</code> statement:</p><div><pre class="programlisting">assert a &gt; b &gt;= 0, "a={0} and b={1}".format(a, b)</pre></div><p>We've provided a string which includes information about the assertion. This string will be an argument to the exception object which is created.</p><p>An exception <a class="indexterm" id="id321"/>has two interesting features. Firstly, it's an object with arguments that we can set when we raise it. Secondly, and more importantly, it interrupts the normal sequential execution of statements. A <code class="literal">try</code>/<code class="literal">except</code> statement can be written to handle exceptions: the execution stops in the <code class="literal">try</code> clause and begins in an <code class="literal">except</code> clause that matches the exception. Without a <code class="literal">try</code> statement that matches the exception, raising an exception stops the program. We'll look at exceptions in detail in <a class="link" href="ch09.html" title="Chapter 9. Exceptions">Chapter 9</a>, <em>Exceptions</em>.</p><p>Note that the <code class="literal">assert</code> statement can be disabled. When we run Python3 with the <code class="literal">-O</code>, optimize, command-line option, then the <code class="literal">assert</code> statements are not included in the internal Python byte code.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>The logic of the None object</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Simple Data Types">Chapter 2</a>, <em>Simple Data Types</em>, we introduced the <code class="literal">None</code> object. It is a unique, immutable object, often used to indicate that a parameter should have a default value or that an input is<a class="indexterm" id="id322"/> not available. Some languages have a special null object or null pointer that have similar semantics to the Python <code class="literal">None</code> object.</p><p>The <code class="literal">None</code> object has no arithmetic operators defined. It's equivalent to <code class="literal">False</code>. The <code class="literal">==</code> and <code class="literal">!=</code> operators are generally defined for <code class="literal">None</code>. However, these operators aren't always appropriate because other objects might exhibit similar behavior.</p><p>Generally, we'll use the <code class="literal">is</code> comparison when trying to determine if a variable is set to <code class="literal">None</code>. The <code class="literal">==</code> test can be redefined by a class that implements the <code class="literal">__eq__</code> special method; the <code class="literal">is</code> test cannot be overridden.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>Because <code class="literal">==</code> can be reimplemented, always use <code class="literal">is None</code> instead of <code class="literal">== None</code>.</p></div></div><p>Since <code class="literal">bool(None) == False</code>, we can use a variable which may be <code class="literal">None</code> in an <code class="literal">if</code> condition. Nevertheless, we should generally use <code class="literal">is None</code> or <code class="literal">is not None</code> to be clearer.</p><p>Here's an example:</p><div><pre class="programlisting">if not a:
    print("a could be None")</pre></div><p>This relies on the way Python implicitly evaluates <code class="literal">bool(a)</code> to see if the value of the <code class="literal">a</code> variable is equivalent to <code class="literal">True</code>. It's often better to be perfectly explicit:</p><div><pre class="programlisting">if a is None:
    print("a is None")</pre></div><p>This <a class="indexterm" id="id323"/>shows that we're matching the value of the <code class="literal">a</code> variable against the <code class="literal">None</code> object.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Summary</h1></div></div></div><p>We've looked closely at Python's Boolean data type, which only has two values (<code class="literal">True</code> and <code class="literal">False</code>) and four operators: <code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">not</code>, and <code class="literal">if-else</code>. The Boolean operators and the <code class="literal">if</code> statement will both implicitly coerce values to a Boolean. This means that non-empty strings will behave in the same as the <code class="literal">True</code> value.</p><p>We've looked at the comparison operators. These work with other objects and create Boolean results. </p><p>In the case of numeric comparisons, the numeric coercion rules are used to allow us to compare <code class="literal">float</code> against <code class="literal">int</code> values without having to write explicit conversions. For string or tuple values, we've seen that items are compared in order.</p><p>We've also seen how the logical operators of <code class="literal">or</code> and <code class="literal">and</code> are not strict about evaluating their operands. If the left-hand side of <code class="literal">and</code> is <code class="literal">False</code>, the right-hand side isn't evaluated. Similarly, if the left-hand side of <code class="literal">or</code> is <code class="literal">True</code>, the right-hand side isn't evaluated.</p><p>We looked at several kinds of Python statements, including the <code class="literal">if-elif-else</code> statement, the <code class="literal">pass</code> statement, and the <code class="literal">assert</code> statement. These statements allow us to write somewhat more sophisticated scripts.</p><p>In <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <em>More Complex Data Types</em>, we'll look at the <code class="literal">list</code>, <code class="literal">set</code>, and <code class="literal">dict</code> collections. We'll see how we can use the <code class="literal">for</code> statement to process all items in a given collection. This will give us the ability to write scripts of considerable sophistication.</p></div></body></html>