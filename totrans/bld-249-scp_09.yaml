- en: Chapter 9. Expanding your Toolset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is less about rendering and more about making life easier for the
    day-to-day use of Blender by extending its functionality. It uses some external
    libraries that need to be installed, and at some point the Python scripting used
    is perhaps a little bit harder to read for a novice. Also, from an artist's point
    of view, it might be a little less visually pleasing as these scripts don't lend
    themselves to pretty illustrations. Nevertheless, these scripts do add genuine
    useful functionality, especially for a script developer, so please read on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Expanding your Toolset](img/0400-09-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: List and archive assets such as image maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish a rendered image automatically with FTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend the functionality of the built-in editor with regular expression searches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed up computations by using Psyco—a just-in-time compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add version control to your scripts with Subversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the Web and beyond—publish a finished render with FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can save a rendered image to any location as long as it is visible in the
    filesystem, but not all platforms offer the possibility to make a remote FTP server
    accessible via a local directory (folder). This script offers us a simple option
    to store a rendered image on a remote FTP server and remembers the server name,
    the username, and (optionally) the password for later reuse.
  prefs: []
  type: TYPE_NORMAL
- en: The **File** **Transfer** **Protocol** (**FTP)** that we will be using is somewhat
    more complicated than, for instance, the `HTTP` protocol as it uses more than
    one connection. Fortunately for us, all the intricacies of an FTP client are nicely
    encapsulated in the standard Python module `ftplib`. We not only import this module's
    `FTP` class but a number of other standard Python modules as well, notably those
    for pathname manipulation (`os.path`) and for reading the standard `.netrc` file
    (which enables us to store passwords outside our script if we need passwords to
    log in to the FTP server). We will discuss each module where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Python is almost as platform independent as it gets, but of course, sometimes
    there are intricacies that are not fully covered. For example, we want to use
    usernames and passwords stored in a `.netrc` file that is commonly used by FTP
    programs (and others) and the FTP client expects this file to reside in the user's
    home directory, which it hopes to find in an environment variable `HOME`. On Windows,
    however, the concept of a home directory isn't that well defined and different
    schemes exist to store data that is restricted to a single user; not every implementation
    of Python resolves this in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We, therefore, define a small utility function that checks if there is a `HOME`
    variable present in the environment (always the case on Unix-like operating systems
    and on some versions of Windows). If not, it checks whether the `USERPROFILE`
    variable is present (present on most versions of Windows including XP where it
    typically points to a directory `C:\Documents and Settings\<yourusername>`). If
    it is present it sets the `HOME` variable to the contents of this `USERPROFILE`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our next task is to find out which FTP server the user wants to upload the rendered
    result to. We store this in a Blender registry key so that we don't have to bother
    the user with a prompt each time he wants to upload a render. The `getftphost()`
    function takes an argument `reuse` that may be used to clear this key if set to
    `False` (to allow for the possibility of choosing a different FTP server), but
    rewriting the user interface to offer the user such an option is left as an exercise
    to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: The actual code starts with retrieving the key from the registry (from disk
    if necessary, hence the `True` argument, highlighted). If there isn't a key present
    or it doesn't contain a host entry, we prompt the user for the name of the FTP
    server with a pop up. If the user does not specify, one we bail out by raising
    an exception. Otherwise, we store the hostname in the host entry—first create
    the dictionary if it is not present and store this dictionary in Blender's registry.
    Finally, we return the stored hostname.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We need another utility function to make sure that a Blender image is stored
    on disk as the last rendered image is present as an image with the name `Render`
    `Result`, but this image isn''t written to disk automatically. The function `imagefilename()`
    takes a Blender image as an argument and first checks if it has a valid filename
    associated with it (highlighted). If not, it creates a filename from the name
    of the image by appending a `.tga` extension (images can be saved as TARGA files
    only). The full path is then constructed from this filename and the path of the
    `temp` directory. Now when there is a valid filename present it is saved to call
    the `save()` method and return the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we upload a file to an FTP server we want to make sure that we do not overwrite
    any existing file. If we do find that a file with a given name is already present
    we'd like to have a function that creates a new filename in a predictable fashion—much
    like the way Blender behaves when creating names for Blender objects. We'd like
    to preserve the extension of the filename so we cannot simply stick to a numerical
    suffix. The `nextfile()` function, therefore, starts by splitting the pathname
    and extension parts of the filename. It uses the `split()` and `splitext()` functions
    from the `os.path` module to leave us with the bare `name`.
  prefs: []
  type: TYPE_NORMAL
- en: If the name already ends in a suffix consisting of a dot and some number (for
    example, `.42`) we'd like to increment this number. This is exactly what the rather
    daunting highlighted lines accomplish. The `sub()` function of Python's `re` module
    takes a regular expression as a first argument (we use a raw string here so we
    don't have to escape any backslashes) and checks whether this regular expression
    matches its third argument (`name` in this case). The regular expression used
    here (`\.(\d+)$`) matches a dot followed by one or more decimal digits if and
    only if these digits are the last characters. If this pattern does match it is
    replaced by the second argument of the `sub()` function. In this case the replacement
    is not a simple string but a `lambda` (that is, unnamed) function that will be
    passed a `match` object and is expected to return a string.
  prefs: []
  type: TYPE_NORMAL
- en: As we surrounded the digits part of our regular expression with parentheses,
    we can retrieve just these digits—without the leading dot—with a call to the `match`
    object's `group()` method. We pass it a `1` as argument, as the first opening
    parenthesis marks the first group (group 0 would be the whole pattern). We convert
    this string of digits to an integer by using the built-in `int()` function, add
    1 to it, and convert it back again to a string with the `str()` function. Before
    this result is automatically returned from the `lambda` function we prepend a
    dot again to conform to our desired pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We finish by checking if the resulting name is different from the original
    one. If they are the same the original name did not match our pattern and we just
    append `.1` to the name. Finally, we reconstruct the full filename by adding the
    extension and calling the `join()` function from `os.path` to add the path in
    a platform-independent way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are all set to do the real work of uploading a file to an FTP server.
    First, we make sure that our environment has a suitable `HOME` variable by calling
    the `sethome()` function . Then, we retrieve the hostname of the FTP server we
    want to upload to (it is perfectly valid, by the way, to enter an IP address instead
    of a hostname):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we retrieve the user''s credentials for the selected host from the `.netrc`
    file if there is one present (highlighted). This may fail for various reasons
    (there might not be a **.**`netrc` file or the given host has no entry in this
    file); in which case an exception will be raised. If this happens we inform the
    user and ask for a username and password instead with suitable pop ups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The rendered image will have been stored as a Blender `Image` object with the
    name `Render` `Result`. The next thing we do is retrieve a reference to this image
    and make sure it is stored on disk. The `imagefilename()` function that we defined
    earlier will return the filename of the stored image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to connect to the FTP server by using the hostname and credentials
    we retrieved earlier (highlighted). Once the connection is established we retrieve
    a list of filenames with the `nlst()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because we want to make sure that we do not overwrite any files on the FTP server,
    we strip the path from the filename of our stored image with the `basename()`
    function and compare the result to the list of filenames retrieved from the server
    (highlighted). If the filename is already present we generate a new filename with
    the `nextfile()` function and check again and keep on doing that until we finally
    have a filename that isn't used yet on the FTP server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we upload our image file by calling the `storbinary()` method. This method
    will take the destination filename prefixed with `STOR` as the first argument
    and an open file descriptor as the second argument. We provide the latter by calling
    Python''s built-in `open()` function with the name of our image file as the single
    argument. (For more details on the rather outlandish behavior of the `ftplib`
    module, refer to its documentation on [http://docs.python.org/library/ftplib.html.](http://docs.python.org/library/ftplib.html.))
    We gracefully end the connection to the FTP server by calling the `quit()` method
    and inform the user about the completion of the task by showing a message that
    mentions the destination filename as this might be different than expected if
    a similarly named file exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available as `ftp.py` in `ftp.blend`. It may be run from the
    text editor but in this case it is certainly far more convenient to put `ftp.py`
    in Blender's `scripts` directory. The script is configured to make itself available
    in the **File | Export** menu.
  prefs: []
  type: TYPE_NORMAL
- en: Spring cleaning—archive unused images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a while, any long-running project gathers a lot of cruft. For example,
    texture images that were tried once but were discarded in favor of better ones.
    This script will help us retain a bit of order by finding all files in a selected
    directory that are not referenced by our `.blend` file and packing them into a
    **ZIP** **archive**.
  prefs: []
  type: TYPE_NORMAL
- en: We will take care not to move any `.blend` files to the ZIP archive (after all,
    those we normally want to be able to render) nor the ZIP archive itself (to prevent
    endless recursion). Any file that we archive we subsequently try to remove, and
    if removing a file leaves an empty directory, we remove that directory as well
    unless it is the directory our `.blend` file resides in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file manipulation functions are provided by Python''s `os` and `os.path`
    modules and ZIP files that can be used both on Windows and open platforms can
    be manipulated with the use of the `zipfile` module. The `zipfile` that we move
    the unused files to we will name `Attic.zip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first challenge is to generate a list of all files in the directory where
    our `.blend` file sits. The function `listfiles()` uses the `walk()` function
    from Python's `os` module to recursively descend into the tree of directories
    and produces a list of files along the way.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `walk()` function traverses the directory tree's depth first
    that allows us to alter the list of directories on the fly. This feature is used
    here to remove any directories that start with a dot (highlighted). This isn't
    necessary for the current and parent directories (represented by **..** and **.**
    respectively) because `walk()` already filters them out, but this allows us, for
    example, to also filter out any `.svn` directories that we may encounter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line containing the `yield` statement returns the results one file at a
    time so our function may be used as an iterator. (For more on iterators, refer
    to the online documentation at [http://docs.python.org/reference/simple_stmts.html#yield](http://docs.python.org/reference/simple_stmts.html#yield))
    We join the filename proper and the path to form a complete filename and normalize
    it (that is, remove double path separators and the like); although normalizing
    here isn''t strictly necessary because `walk()` is expected to return any paths
    in normalized form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can compare the list of files our `.blend` file uses to the list
    of files present in the directory, we make sure any packed file is unpacked to
    its original file location. This isn''t strictly necessary but ensures that we
    don''t move any files to the archive that are not directly used but do have a
    copy inside the `.blend` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `GetPaths()` function from the Blender module produces a list of all files
    used by the `.blend` file (except for the `.blend` file itself). We pass it an
    absolute argument set to `True` to retrieve filenames with a full path instead
    of paths relative to the current directory in order to compare these properly
    with the list produced by the `listfiles()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we normalize these filenames as well. The highlighted line shows how
    we retrieve the absolute path of the current directory by passing the shorthand
    for the current Bender directory ( `//` ) to the `expandpath()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we create a `ZipFile` object in *write* mode. This will truncate any existing
    archive with the same name and enables us to add files to the archive. The full
    name of the archive is constructed by joining the current Blender directory and
    the name we want to use for the archive. The use of the `join()` function from
    the `os.path` module ensures that we construct the full name in a platform-independent
    way. We set the `debug` argument of the `ZipFile` object to `3` to report anything
    unusual to the console when creating the archive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `removefiles` variable will record the names of the files we want to remove
    after we have constructed the archive. We can only safely remove files and directories
    after we have created the archive or we might refer to directories that no longer
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The archive is constructed by looping over the list of all the files in the
    current Blender directory and comparing them to the list of files used by our
    `.blend` file. Any file with an extension such as `.blend` or `.blend1` is skipped
    (highlighted) as is the archive itself. The files are added to the ZIP file using
    the `write()` method, which accepts as a parameter, the filename with a path relative
    to the archive (and hence the current directory). That way it is easier to unpack
    the archive in a new location. Any references to files outside the current directory
    tree are unaffected by the `relpath()` function. Any file we add to the archive
    is marked for removal by adding it to the `removefiles` list. Finally, we close
    the archive—an important step because omitting it may leave us with a corrupted
    archive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The last task left is to remove the files we moved to the archive. The `remove()`
    function from Python's `os` module will accomplish that but we also want to remove
    any directory that ends up empty after removing the files. Therefore, for each
    file we remove we determine the name of its directory. We also check if this directory
    doesn't point to the current directory because we want to make absolutely sure
    we do not remove it as this is where our `.blend` files reside. Although an unlikely
    scenario, it is possible to open a `.blend` file in Blender and remove the `.blend`
    file itself that might leave an empty directory. If we remove this directory any
    subsequent (auto) save would fail. The `relpath()` function will return a dot
    if the directory passed as its first argument points to the same directory as
    the directory passed as its second argument. (The `samefile()` function is more
    robust and direct but not available on Windows.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If we made certain we are not referring to the current directory we use the
    `removedirs()` function to remove the directory. If the directory is not empty
    this will fail with an `OSError` exception (that is, the file we removed was not
    the last file in the directory), which we ignore. The `removedirs()` function
    will also remove all parent directories leading to the directory iff they are
    empty, which is exactly what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available as `zip.py` in `attic.blend`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the editor—searching with regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **editor** already provides basic search and replace functionality but if
    you are used to other editors you might miss the possibility to search using **regular
    expressions**. This plug-in provides this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions are very powerful and many programmers love their versatility
    (and many others loathe their poor readability). Whether you love or hate them,
    they are very expressive: matching any decimal number can simply be expressed
    as `\d+` for example (one or more digits). If you are looking for a word that
    is spelled differently in British or American English, such as colour/color, you
    can match any of them with the expression `colou?r` (color with an optional *u*).'
  prefs: []
  type: TYPE_NORMAL
- en: The following code will show that Blender's built-in editor can be equipped
    with this useful search tool with just a few lines of code. The script provided
    should be installed in Blender's `scripts` directory and can then be invoked from
    the text editor menu as **Text | Text Plugins | Regular Expression Search** or
    by a hot key *Alt + Ctrl + R*. It will pop up a small input widget where the user
    may enter a regular expression (this pop up will remember the last regular expression
    entered) and if the user clicks on the **OK** button or hits *Enter* the cursor
    will be positioned at the first occurrence that matches the regular expression,
    highlighting the extent of the match.
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the editor—searching with regular expressions](img/0400-09-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To register the script as a text plug-in with the designated hot key the first
    lines of the script consist of the customary headers augmented with a `Shortcut:`
    entry (highlighted below):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to import the necessary modules. Python supplies us with a
    standard `re` module, which is well documented (the online docs are sufficient
    even for novice users unfamiliar with regular expressions), and we import Blender''s
    `bpy` module. In this book we do not often use this module as it is marked as
    experimental, but in this case we need it to find out which text buffer is the
    active one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To signal any error conditions, such as an illegal regular expression or when
    nothing matches, we define a simple `popup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we want to remember the last regular expression the user entered we
    will be using Blender''s registry and, therefore, we define a key to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run()` function ties all functionality together; it retrieves the active
    text buffer and bails out if there isn''t one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Subsequently, it retrieves the cursor position within this buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Before presenting the user with a pop up to enter a regular expression we check
    if we stored one earlier in the registry. We simply retrieve it and if it fails
    we set the default expression to the empty string (highlighted). Note that we
    do not pass any extra parameters to the `GetKey()` function because we do want
    to store any information on disk in this case. If the user enters an empty string
    we simply return without searching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We compile the regular expression to see if it''s valid and if this fails we
    show a message and return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know the regular expression is correct, we iterate over all lines
    of the text buffer starting at the line the cursor is on (highlighted). For each
    line we match our compiled regular expression to the string (or the part after
    the cursor if it is the first line).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If there is a match we note the start of the match within the line and the length
    of the match (suitably set off if it's the first line) and set the cursor position
    to the current line and the start of the match (highlighted). We also set the
    "select position" to the position of the match plus the length of the match so
    our match will be highlighted and then returned. If there is no match within the
    line we increment the row index and continue the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is nothing left to iterate over, we signal the user that we did not
    find any match. In all cases, we store the regular expression in the registry
    for reuse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available as `regex.py` in `regex.blend` but should be installed
    in Blender's `scripts` directory with a suitable name, such as `textplugin_regex.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the editor—interacting with Subversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: W hen actively developing scripts it can be difficult to keep track of changes
    or to revert to previous versions. This is not unique to writing Python scripts
    in Blender and over the years a number of **version control** systems have evolved.
    One of the better known, and widely used ones is **Subversion** ([http://subversion.tigris.org](http://subversion.tigris.org)).
    In this section, we show how the editor can be augmented to commit or update a
    text file from a repository.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with a Subversion repository is not provided by a bundled Python
    module so we have to get that from somewhere else. The **Downloads** section of
    [http://pysvn.tigris.org](http://pysvn.tigris.org) contains both source and binary
    distributions for many platforms. Be sure to get the right one since both the
    supported version of Subversion and the version of Python may differ. The scripts
    we develop here are tested against Subversion 1.6.x and Python 2.6.x but should
    work with earlier versions of Subversion as well.
  prefs: []
  type: TYPE_NORMAL
- en: We will be implementing the functionality to commit a text file to a repository
    and to update a file (that is, get the latest revision from the repository). If
    we try to commit a file that is not part of the repository yet we will add it,
    but we will not implement tools to create a repository or check out a working
    copy. A tool such as **TortoiseSVN** on Windows ([http://tortoisesvn.tigris.org/](http://tortoisesvn.tigris.org/))
    or any number of tools for open platforms are far better equipped for that. We
    just assume a checked-out working directory where we store our Blender text files.
    (This working directory might be completely different from your Blender project
    directory.)
  prefs: []
  type: TYPE_NORMAL
- en: Committing a file to the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Committing a text buffer to the repository is a two-step process. First, we
    have to save the contents of the text buffer to a file and then we commit this
    file to the repository. We have to check whether the text block has an associated
    filename and prompt the user to save the file first if it hasn't got one yet.
    The user must save the file to a checked out directory in order to commit the
    file to a repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the extension that allowed us to search with regular expressions,
    this one starts with a suitable header to identify it as a text editor plug-in
    and to assign a keyboard shortcut. We define the mnemonic *Ctrl + Alt + C* for
    committing (highlighted) as we will define *Ctrl + Alt + U* for updating in its
    companion script. We also import the necessary modules, notably the `pysvn` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `run()` function first tries to get the active text buffer and will return
    without a croak if there isn't one. Then it checks if there is a filename defined
    for this text buffer (highlighted). If not, it reminds the user to save the file
    first (thus defining a filename and placing the file in a checked out directory)
    and returns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a `pysvn` client object that will enable us to interact
    with a repository. Its `info()` method allows us to retrieve information about
    the repository status of a file (highlighted). If there is no information the
    file will not have been added to the repository yet—a situation that we correct
    by calling the `add()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we write out the current contents of the text buffer by joining all the
    lines in it to a single chunk of data and writing that to the file object we opened
    on the filename associated with the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This file will be committed to the repository with the `checkin()` method to
    which we pass a rather uninformative commit message. It might be a good idea to
    prompt the user for a more sensible message. Finally, we inform the user of the
    resulting revision.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Subversion revision numbers are not associated with a file but with
    a repository, so this number may differ by more than one from the previous file
    commit if meanwhile other files were committed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available as `textplugin_commit` in `svn.blend` but should
    be installed in Blender's `scripts` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a file from the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The whole purpose of a repository is being able to collaborate, which means
    that others may change the files we are working on as well and we must be able
    to retrieve those committed changes. This is called updating a file and means
    that we copy the latest version that resides in the repository to our working
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Besides checking whether the text buffer is saved and the file is already added
    to the repository, we must also check whether our current version is newer or
    altered from the version in the repository. If so, we offer the user the choice
    of discarding these changes and reverting to the version in the repository or
    to commit the version residing in the text buffer. (A third option, merging the
    differences is not provided here; although Subversion is certainly able to do
    that, at least for text files, but this is better left to more versatile tools
    such as TortoiseSVN.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the script is very similar to the commit script. The main
    difference is a different shortcut key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run()` function also starts off quite similar as it retrieves the active
    text buffer (if any) and checks whether the text buffer has an associated filename
    (highlighted). It also checks if the filename was already added to the repository
    and if not, corrects this by calling the `add()` method and informs the user with
    a pop up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After writing the contents of the text buffer to its associated file it calls
    the `status()` method to see if the file we have written (and therefore the contents
    of the text buffer) is modified compared to the version in the repository (highlighted).
    The `status()` method may be passed a *list* of filenames as well and always returns
    a list of results, even when we pass it just a single filename—hence the `[0]`
    index. If our text buffer is modified we inform the user and offer a choice: either
    discard the changes and retrieve the version stored in the repository or commit
    the current version. It is also possible to cancel the action altogether by clicking
    outside the menu, in which case `PupMenu()` will return `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After retrieving the version from the repository we refresh the contents of
    our text buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we inform the user with a pop up what the revision number is of the
    content in the text buffer by calling the `status()` method again and fetching
    the `commit_revision` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available as `textplugin_svnupdate` in `svn.blend`, and like
    its commit counterpart it should be installed in Blender's `scripts` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although a full tutorial on working with Subversion is out of scope of this
    book, it might be useful to sketch a workflow for a Blender project where scripted
    components are versioned.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that a Blender project itself does not have to
    be under version control. We may organize our Blender project in any way that
    makes sense and have a `scripts` directory within it that is under version control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have created a repository for scripts on a network storage device and
    created a Blender project directory on our local machine. In order to bring our
    scripts under version control we have to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the script's repository within our Blender project directory (this
    is called the **working copy** of the repository).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a script within our `.blend` file with the built-in editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save this script to the working copy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time we change something, we press *Ctrl + Alt + C* to commit our changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time we start working on our script again we press *Ctrl + Alt + U* first
    to see if someone else has changed anything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that there is nothing against bringing all assets, such as textures or
    `.blend` files that act as libraries under version control but we have to use
    a separate client to commit changes. It would be an interesting exercise to create
    some scripts that commit or update all files in the current Blender directory.
  prefs: []
  type: TYPE_NORMAL
- en: The need for speed—using Psyco
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is an interpreted language: all instructions in a script are interpreted
    and executed again and again when they are encountered. This may sound inefficient
    but for a developer of a program the advantage of being able to quickly develop
    and test a program may outweigh the disadvantage of a slower running program.
    And interpreting might be inefficient but that is not identical to slow. Python
    is a very high-level language so a single language element might be equivalent
    to a lot of low-level instructions. Besides, given modern hardware even a slow
    script might be finished faster than a user expects a result.'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, there are situations where any speed increase is welcome. From
    all the examples we have seen in this book Pynodes are probably the most computationally
    intensive as the instructions are run for every visible pixel in a texture or
    shader and often even many more times per pixel if oversampling is taken into
    account. Saving a few milliseconds from a script that takes less than a second
    to execute doesn't amount to much, but saving 20% of the rendering time amounts
    to a significant amount of time saved when rendering a 500 frame shot.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter** **Psyco**: Psyco is a Python extension that tries to speed up the
    execution of a script by compiling frequently used parts of a script to machine
    instructions and storing them for reuse. This process is often called **just-in-time
    compilation** and is akin to just-in-time compilation in other languages such
    as Java. (The implementation is similar in concept but quite different in implementation
    due to Python''s dynamic typing. This is of no concern to developers of Python
    scripts.) What matters is that Psyco may be used in any script without any changes
    in the code except for adding a few lines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Psyco is available as a binary package for Windows and can be compiled from
    source on other platforms. Full instructions are available on the Psyco website:
    [http://psyco.sourceforge.net/](http://psyco.sourceforge.net/).'
  prefs: []
  type: TYPE_NORMAL
- en: Do verify that you install the version that fits your Python installation because
    although the site states that the version compiled for Python 2.5 should work
    for 2.6 as well, it still might fail, so rather use the version specifically compiled
    for 2.6\. Now, what speed increase might we expect? That is difficult to estimate
    but easy enough to measure! Just render a frame and note the time it took, then
    import psyco in your code, render again, and note the difference. If it is significant
    leave the code in, otherwise you might remove it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table some results are listed for the test scene provided
    in `pysco.blend` but your mileage may vary. Also note that the test scene is a
    rather optimistic scenario as most of the render is covered by a texture generated
    by a Pynode. If this were less, the gain in speed would be less, but this does
    give an estimate of what is possible with Psyco. A factor two for the relevant
    code is readily achievable. The following table lists some illustrating sample
    timings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Time in seconds | Without Psyco | With Psyco |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Netbook | 52.7 | 26.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Desktop | 14.01 | 6.98 |'
  prefs: []
  type: TYPE_TB
- en: Enabling Psyco
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code shows the additional lines needed to enable psyco on our
    previously encountered `raindrops` Pynode. Changes are indicated in bold.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So basically, only a few lines are added after the definition of the Pynode.
    Make sure to click on the **Update** button on the Pynode otherwise the code will
    not be recompiled and changes will not be visible.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code just tries to import the `psyco` module. If this fails (for
    any reason) an informative message is printed on the console but the code will
    run correctly, nevertheless. If it is imported we instruct Psyco to optimize the
    `__call__()` method by calling the `bind()` function with a reference to this
    `__call__` method as an argument and inform the user on the console that we successfully
    configured Psyco.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we looked beyond 3D and rendering and saw how to make life
    happier for a Python developer and artist alike by providing some scripts to help
    in some common housekeeping tasks by extending the functionality of the built-in
    editor with regular expression searches and version control and showed how to
    save valuable rendering time in some situations by using Psyco. Specifically,
    we learned:'
  prefs: []
  type: TYPE_NORMAL
- en: How to list and archive assets such as image maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to publish a rendered image automatically with FTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extend the functionality of the built-in editor with regular expression
    searches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to speed up computations using Psyco—a just-in-time compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add version control to your scripts with Subversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
