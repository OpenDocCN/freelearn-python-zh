["```py\n>>> square = [(1,1), (1,2), (2,2), (2,1)] \n```", "```py\n>>> from math import hypot\n>>> def distance(p_1, p_2):\n...     return hypot(p_1[0]-p_2[0], p_1[1]-p_2[1])\n>>> def perimeter(polygon):\n...     pairs = zip(polygon, polygon[1:]+polygon[:1])\n...     return sum(\n...         distance(p1, p2) for p1, p2 in pairs\n...     ) \n```", "```py\n>>> perimeter(square)\n4.0 \n```", "```py\nfrom __future__ import annotations\nfrom math import hypot\nfrom typing import Tuple, List\nPoint = Tuple[float, float]\ndef distance(p_1: Point, p_2: Point) -> float:\n    return hypot(p_1[0] - p_2[0], p_1[1] - p_2[1])\nPolygon = List[Point]\ndef perimeter(polygon: Polygon) -> float:\n    pairs = zip(polygon, polygon[1:] + polygon[:1])\n    return sum(distance(p1, p2) for p1, p2 in pairs) \n```", "```py\nfrom math import hypot\nfrom typing import Tuple, List, Optional, Iterable\nclass Point:\n    def __init__(self, x: float, y: float) -> None:\n        self.x = x\n        self.y = y\n    def distance(self, other: \"Point\") -> float:\n        return hypot(self.x - other.x, self.y - other.y)\nclass Polygon:\n    def __init__(self) -> None:\n        self.vertices: List[Point] = []\n    def add_point(self, point: Point) -> None:\n        self.vertices.append((point))\n    def perimeter(self) -> float:\n        pairs = zip(\n            self.vertices, self.vertices[1:] + self.vertices[:1])\n        return sum(p1.distance(p2) for p1, p2 in pairs) \n```", "```py\n>>> square = Polygon()\n>>> square.add_point(Point(1,1))\n>>> square.add_point(Point(1,2))\n>>> square.add_point(Point(2,2))\n>>> square.add_point(Point(2,1))\n>>> square.perimeter()\n4.0 \n```", "```py\n>>> square = [(1,1), (1,2), (2,2), (2,1)]\n>>> perimeter(square)\n4.0 \n```", "```py\nclass Polygon_2:\n    def __init__(self, vertices: Optional[Iterable[Point]] = None) -> None:\n        self.vertices = list(vertices) if vertices else []\n    def perimeter(self) -> float:\n        pairs = zip(\n            self.vertices, self.vertices[1:] + self.vertices[:1])\n        return sum(p1.distance(p2) for p1, p2 in pairs) \n```", "```py\n>>> square = Polygon_2(\n... [Point(1,1), Point(1,2), Point(2,2), Point(2,1)]\n... )\n>>> square.perimeter()\n4.0 \n```", "```py\nPair = Tuple[float, float]\nPoint_or_Tuple = Union[Point, Pair]\nclass Polygon_3:\n    def __init__(self, vertices: Optional[Iterable[Point_or_Tuple]] = None) -> None:\n        self.vertices: List[Point] = []\n        if vertices:\n            for point_or_tuple in vertices:\n                self.vertices.append(self.make_point(point_or_tuple))\n    @staticmethod\n    def make_point(item: Point_or_Tuple) -> Point:\n        return item if isinstance(item, Point) else Point(*item) \n```", "```py\nclass Color:\n    def __init__(self, rgb_value: int, name: str) -> None:\n        self._rgb_value = rgb_value\n        self._name = name\n    def set_name(self, name: str) -> None:\n        self._name = name\n    def get_name(self) -> str:\n        return self._name\n    def set_rgb_value(self, rgb_value: int) -> None:\n        self._rgb_value = rgb_value\n    def get_rgb_value(self) -> int:\n        return self._rgb_value \n```", "```py\n>>> c = Color(0xff0000, \"bright red\")\n>>> c.get_name()\n'bright red'\n>>> c.set_name(\"red\")\n>>> c.get_name()\n'red' \n```", "```py\nclass Color_Py:\n    def __init__(self, rgb_value: int, name: str) -> None:\n        self.rgb_value = rgb_value\n        self.name = name \n```", "```py\n>>> c = Color_Py(0xff0000, \"bright red\")\n>>> c.name\n'bright red'\n>>> c.name = \"red\"\n>>> c.name\n'red' \n```", "```py\nclass Color_V:\n    def __init__(self, rgb_value: int, name: str) -> None:\n        self._rgb_value = rgb_value\n        if not name:\n            raise ValueError(f\"Invalid name {name!r}\")\n        self._name = name\n    def set_name(self, name: str) -> None:\n        if not name:\n            raise ValueError(f\"Invalid name {name!r}\")\n        self._name = name \n```", "```py\nclass Color_VP:\n    def __init__(self, rgb_value: int, name: str) -> None:\n        self._rgb_value = rgb_value\n        if not name:\n            raise ValueError(f\"Invalid name {name!r}\")\n        self._name = name\n    def _set_name(self, name: str) -> None:\n        if not name:\n            raise ValueError(f\"Invalid name {name!r}\")\n        self._name = name\n    def _get_name(self) -> str:\n        return self._name\n    **name = property(_get_name, _set_name)** \n```", "```py\n>>> c = Color_VP(0xff0000, \"bright red\")\n>>> c.name\n'bright red'\n>>> c.name = \"red\"\n>>> c.name\n'red'\n>>> c.name = \"\"\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"setting_name_property.py\", line 8, in _set_name\n    raise ValueError(f\"Invalid name {name!r}\")\nValueError: Invalid name '' \n```", "```py\nclass NorwegianBlue:\n    def __init__(self, name: str) -> None:\n        self._name = name\n        self._state: str\n    def _get_state(self) -> str:\n        print(f\"Getting {self._name}'s State\")\n        return self._state\n    def _set_state(self, state: str) -> None:\n        print(f\"Setting {self._name}'s State to {state!r}\")\n        self._state = state\n    def _del_state(self) -> None:\n        print(f\"{self._name} is pushing up daisies!\")\n        del self._state\n    silly = property(\n        _get_state, _set_state, _del_state, \n        \"This is a silly property\") \n```", "```py\n>>> p = NorwegianBlue(\"Polly\")\n>>> p.silly = \"Pining for the fjords\"\nSetting Polly's State to 'Pining for the fjords'\n>>> p.silly\nGetting Polly's State\n'Pining for the fjords'\n>>> del p.silly\nPolly is pushing up daisies! \n```", "```py\nHelp on class NorwegianBlue in module colors:\nclass NorwegianBlue(builtins.object)\n |  NorwegianBlue(name: str) -> None\n |  \n |  Methods defined here:\n |  \n |  __init__(self, name: str) -> None\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  __dict__\n |      dictionary for instance variables (if defined)\n |  \n |  __weakref__\n |      list of weak references to the object (if defined)\n |  \n |  silly\n |      This is a silly property \n```", "```py\nclass NorwegianBlue_P:\n    def __init__(self, name: str) -> None:\n        self._name = name\n        self._state: str\n    @property\n    def silly(self) -> str:\n        print(f\"Getting {self._name}'s State\")\n        return self._state \n```", "```py\nclass NorwegianBlue_P:\n    def __init__(self, name: str) -> None:\n        self._name = name\n        self._state: str\n    @property\n    def silly(self) -> str:\n        \"\"\"This is a silly property\"\"\"\n        print(f\"Getting {self._name}'s State\")\n        return self._state\n    @silly.setter\n    def silly(self, state: str) -> None:\n        print(f\"Setting {self._name}'s State to {state!r}\")\n        self._state = state \n```", "```py\n@silly.deleter\ndef silly(self) -> None:\n    print(f\"{self._name} is pushing up daisies!\")\n    del self._state \n```", "```py\nfrom urllib.request import urlopen\nfrom typing import Optional, cast\nclass WebPage:\n    def __init__(self, url: str) -> None:\n        self.url = url\n        self._content: Optional[bytes] = None\n    @property\n    def content(self) -> bytes:\n        if self._content is None:\n            print(\"Retrieving New Page...\")\n            with urlopen(self.url) as response:\n                self._content = response.read()\n        return self._content \n```", "```py\nimport time\nwebpage = WebPage(\"http://ccphillips.net/\")\nnow = time.perf_counter()\ncontent1 = webpage.content\nfirst_fetch = time.perf_counter() - now\nnow = time.perf_counter()\ncontent2 = webpage.content\nsecond_fetch = time.perf_counter() - now\nassert content2 == content1, \"Problem: Pages were different\"\nprint(f\"Initial Request     {first_fetch:.5f}\")\nprint(f\"Subsequent Requests {second_fetch:.5f}\") \n```", "```py\n% python src/colors.py\nRetrieving New Page...\nInitial Request     1.38836\nSubsequent Requests 0.00001 \n```", "```py\nclass AverageList(List[int]):\n    @property\n    def average(self) -> float:\n        return sum(self) / len(self) \n```", "```py\n>>> a = AverageList([10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5])\n>>> a.average\n9.0 \n```", "```py\nfrom __future__ import annotations\nimport fnmatch\nfrom pathlib import Path\nimport re\nimport zipfile\nclass ZipReplace:\n    def __init__(\n            self,\n            archive: Path,\n            pattern: str,\n            find: str,\n            replace: str\n    ) -> None:\n        self.archive_path = archive\n        self.pattern = pattern\n        self.find = find\n        self.replace = replace \n```", "```py\n def find_and_replace(self) -> None:\n        input_path, output_path = self.make_backup()\n        with zipfile.ZipFile(output_path, \"w\") as output:\n            with zipfile.ZipFile(input_path) as input:\n                self.copy_and_transform(input, output) \n```", "```py\ndef make_backup(self) -> tuple[Path, Path]:\n    input_path = self.archive_path.with_suffix(\n        f\"{self.archive_path.suffix}.old\")\n    output_path = self.archive_path\n    self.archive_path.rename(input_path)\n    return input_path, output_path\ndef copy_and_transform(\n    self, input: zipfile.ZipFile, output: zipfile.ZipFile\n) -> None:\n    for item in input.infolist():\n        extracted = Path(input.extract(item))\n        if (not item.is_dir() \n                and fnmatch.fnmatch(item.filename, self.pattern)):\n            print(f\"Transform {item}\")\n            input_text = extracted.read_text()\n            output_text = re.sub(self.find, self.replace, input_text)\n            extracted.write_text(output_text)\n        else:\n            print(f\"Ignore    {item}\")\n        output.write(extracted, item.filename)\n        extracted.unlink()\n        for parent in extracted.parents:\n            if parent == Path.cwd():\n                break\n            parent.rmdir() \n```", "```py\nif __name__ == \"__main__\":\n    sample_zip = Path(\"sample.zip\")\n    zr = ZipReplace(sample_zip, \"*.md\", \"xyzzy\", \"plover's egg\")\n    zr.find_and_replace() \n```", "```py\n% python -m pip install pillow \n```", "```py\nfrom abc import ABC, abstractmethod\nclass ZipProcessor(ABC):\n    def __init__(self, archive: Path) -> None:\n        self.archive_path = archive\n        self._pattern: str\n    def process_files(self, pattern: str) -> None:\n        self._pattern = pattern\n        input_path, output_path = self.make_backup()\n        with zipfile.ZipFile(output_path, \"w\") as output:\n            with zipfile.ZipFile(input_path) as input:\n                self.copy_and_transform(input, output)\n    def make_backup(self) -> tuple[Path, Path]:\n        input_path = self.archive_path.with_suffix(\n            f\"{self.archive_path.suffix}.old\")\n        output_path = self.archive_path\n        self.archive_path.rename(input_path)\n        return input_path, output_path\n    def copy_and_transform(\n        self, input: zipfile.ZipFile, output: zipfile.ZipFile\n    ) -> None:\n        for item in input.infolist():\n            extracted = Path(input.extract(item))\n            if self.matches(item):\n                print(f\"Transform {item}\")\n                self.transform(extracted)\n            else:\n                print(f\"Ignore    {item}\")\n            output.write(extracted, item.filename)\n            self.remove_under_cwd(extracted)\n    def matches(self, item: zipfile.ZipInfo) -> bool:\n        return (\n            not item.is_dir() \n            and fnmatch.fnmatch(item.filename, self._pattern))\n    def remove_under_cwd(self, extracted: Path) -> None:\n        extracted.unlink()\n        for parent in extracted.parents:\n            if parent == Path.cwd():\n                break\n            parent.rmdir()\n    @abstractmethod\n    def transform(self, extracted: Path) -> None:\n        ... \n```", "```py\nclass TextTweaker(ZipProcessor):\n    def __init__(self, archive: Path) -> None:\n        super().__init__(archive)\n        self.find: str\n        self.replace: str\n    def find_and_replace(self, find: str, replace: str) -> \"TextTweaker\":\n        self.find = find\n        self.replace = replace\n        return self\n    def transform(self, extracted: Path) -> None:\n        input_text = extracted.read_text()\n        output_text = re.sub(self.find, self.replace, input_text)\n        extracted.write_text(output_text) \n```", "```py\nTextTweaker(zip_data)\\\n.find_and_replace(\"xyzzy\", \"plover's egg\")\\\n.process_files(\"*.md\") \n```", "```py\nfrom PIL import Image  # type: ignore [import]\nclass ImgTweaker(ZipProcessor):\n    def transform(self, extracted: Path) -> None:\n        image = Image.open(extracted)\n        scaled = image.resize(size=(640, 960))\n        scaled.save(extracted) \n```", "```py\nclass SampleReader:\n    \"\"\"\n    See iris.names for attribute ordering in bezdekIris.data file\n    \"\"\"\n    target_class = Sample\n    header = [\n        \"sepal_length\", \"sepal_width\", \n        \"petal_length\", \"petal_width\", \"class\"\n    ]\n    def __init__(self, source: Path) -> None:\n        self.source = source\n    def sample_iter(self) -> Iterator[Sample]:\n        target_class = self.target_class\n        with self.source.open() as source_file:\n            reader = csv.DictReader(source_file, self.header)\n            for row in reader:\n                try:\n                    sample = target_class(\n                        sepal_length=float(row[\"sepal_length\"]),\n                        sepal_width=float(row[\"sepal_width\"]),\n                        petal_length=float(row[\"petal_length\"]),\n                        petal_width=float(row[\"petal_width\"]),\n                    )\n                except ValueError as ex:\n                    raise BadSampleRow(f\"Invalid {row!r}\") from ex\n                yield sample \n```", "```py\nclass BadSampleRow(ValueError):\n    pass \n```", "```py\nclass Purpose(enum.IntEnum):\n    Classification = 0\n    Testing = 1\n    Training = 2 \n```", "```py\nclass KnownSample(Sample):\n    def __init__(\n        self,\n        sepal_length: float,\n        sepal_width: float,\n        petal_length: float,\n        petal_width: float,\n        purpose: int,\n        species: str,\n    ) -> None:\n        purpose_enum = Purpose(purpose)\n        if purpose_enum not in {Purpose.Training, Purpose.Testing}:\n            raise ValueError(\n                f\"Invalid purpose: {purpose!r}: {purpose_enum}\"\n            )\n        super().__init__(\n            sepal_length=sepal_length,\n            sepal_width=sepal_width,\n            petal_length=petal_length,\n            petal_width=petal_width,\n        )\n        self.purpose = purpose_enum\n        self.species = species\n        self._classification: Optional[str] = None\n    def matches(self) -> bool:\n        return self.species == self.classification \n```", "```py\n @property\n    def classification(self) -> Optional[str]:\n        if self.purpose == Purpose.Testing:\n            return self._classification\n        else:\n            raise AttributeError(f\"Training samples have no classification\") \n```", "```py\n>>> from model import KnownSample, Purpose\n>>> s2 = KnownSample(\n...     sepal_length=5.1, \n...     sepal_width=3.5, \n...     petal_length=1.4, \n...     petal_width=0.2, \n...     species=\"Iris-setosa\", \n...     purpose=Purpose.Testing.value)\n>>> s2\nKnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, purpose=1, species='Iris-setosa')\n>>> s2.classification is None\nTrue \n```", "```py\n @classification.setter\n    def classification(self, value: str) -> None:\n        if self.purpose == Purpose.Testing:\n            self._classification = value\n        else:\n            raise AttributeError(\n                f\"Training samples cannot be classified\") \n```"]