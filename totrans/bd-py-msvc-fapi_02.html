<html><head></head><body>
		<div id="_idContainer015">
			<h1 id="_idParaDest-34" class="chapter-number"><a id="_idTextAnchor033"/>2</h1>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Exploring the Core Features</h1>
			<p>In the previous chapter, we found out how easy it is to install and start developing REST APIs using the <strong class="bold">FastAPI</strong> framework. Handling requests, cookies, and form data was fast, easy, and straightforward with FastAPI, as was building the different HTTP path operations.</p>
			<p>To learn about the framework’s features further, this chapter will guide us on how to upgrade our REST APIs by adding some essential FastAPI features to the implementation. These include some handlers that can help minimize unchecked exceptions, JSON encoders that can directly manage endpoint responses, background jobs that can create audit trails and logs, and multiple threads to run some API methods asynchronously with the <strong class="bold">uvicorn</strong>’s main thread. Moreover, issues such as managing source files, modules, and packages for huge enterprise projects will also be addressed in this chapter. This chapter will use and dissect an <em class="italic">intelligent tourist system</em> prototype to assist with elaborating upon and exemplifying FastAPI’s core modules.</p>
			<p>Based on these aforementioned features, this chapter will discuss the following major concepts that can help us extend our learning about this framework:</p>
			<ul>
				<li>Structuring and organizing huge projects</li>
				<li>Managing API-related exceptions</li>
				<li>Converting objects to JSON-compatible types</li>
				<li>Managing API responses</li>
				<li>Creating background processes</li>
				<li>Using asynchronous path operations</li>
				<li>Applying middleware to filter path operations</li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Technical requirements</h1>
			<p>This chapter will implement a prototype of an intelligent tourist system designed to provide booking information and reservation about tourist spots. It can provide user details, tourist spot details, and location grids. It also allows users or tourists to comment on tours and rate them. The prototype has an administrator account for adding and removing all the tour details, managing users, and providing some listings. The application will not use any database management system yet, so all the data is temporarily stored in Python collections. The code is all uploaded at <a href="https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch02">https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch02</a>.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Structuring and organizing huge projects</h1>
			<p>In FastAPI, big <a id="_idIndexMarker078"/>projects are organized and structured by <a id="_idIndexMarker079"/>adding <em class="italic">packages</em> and <em class="italic">modules </em>without destroying the setup, configuration, and purpose. The project should always be flexible and scalable in case of additional features and requirements. One component must correspond to one package, with several modules equivalent to a <em class="italic">blueprint</em> in a Flask framework.</p>
			<p>In this prototypical intelligent tourist system, the application has several modules such as the login, administration, visit, destination, and feedback-related functionalities. The two most crucial are the <em class="italic">visit</em> module, which <a id="_idIndexMarker080"/>manages all the travel bookings of the users, and the <em class="italic">feedback</em> module, which<a id="_idIndexMarker081"/> enables clients to post their feedback regarding their experiences at every destination. These modules should be separated from the rest since they provide the core transactions. <em class="italic">Figure 2.1</em> shows how to group implementations and separate a module from <a id="_idIndexMarker082"/>the rest using <strong class="bold">packages</strong>:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_2.1_B17975.jpg" alt="Figure 2.1 – The FastAPI project structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The FastAPI project structure</p>
			<p>Each <a id="_idIndexMarker083"/>package in <em class="italic">Figure 2.1</em> contains all the modules <a id="_idIndexMarker084"/>where the API services and some dependencies are implemented. All the aforementioned modules now have their own respective packages that make it easy to test, debug, and expand the application. Testing FastAPI components will be discussed in the upcoming chapters.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">FastAPI does not require adding the <strong class="source-inline">__init__.py</strong> file into each Python package when using <em class="italic">VS Code Editor</em> and <em class="italic">Python 3.8</em> during development, unlike in Flask. The <strong class="source-inline">__pycache__</strong> folder generated inside a package during compilation contains binaries of the module scripts accessed and utilized by other modules. The main folder will also become a package since it will have its own <strong class="source-inline">__pycache__</strong> folder together with the others. But we must exclude <strong class="source-inline">__pycache__</strong> when deploying the application to the repository, since it may take up a lot of space. </p>
			<p>On the<a id="_idIndexMarker085"/> other hand, what remains in the main folder <a id="_idIndexMarker086"/>are the core components such as the <em class="italic">background tasks</em>, <em class="italic">custom exception handlers</em>, <em class="italic">middleware,</em> and the <strong class="source-inline">main.py</strong> file. Now, let us learn about how FastAPI can bundle all these packages as one huge application when deployed. </p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Implementing the API services</h2>
			<p>For these <a id="_idIndexMarker087"/>module packages to function, the <strong class="source-inline">main.py</strong> file must call and register all their API implementations through the FastAPI instance. The scripts inside each package are already REST API implementations of the microservices, except that they are built by <strong class="source-inline">APIRouter</strong> instead of the <strong class="source-inline">FastAPI</strong> object. <strong class="source-inline">APIRouter</strong> also has the same path operations, query and request parameter setup, handling of form data, generation of responses, and parameter injection of model objects. What is lacking in <strong class="source-inline">APIRouter</strong> is the support for an exception handler, middleware declaration, and customization:</p>
			<pre class="source-code">
from fastapi import <strong class="bold">APIRouter</strong>
from login.user import Signup, User, Tourist, 
      pending_users, <strong class="bold">approved_users</strong>
<strong class="bold">router = APIRouter()</strong>
@<strong class="bold">router</strong>.get("/ch02/admin/tourists/list")
def list_all_tourists():
    return <strong class="bold">approved_users</strong></pre>
			<p>The <strong class="source-inline">list_all_tourists()</strong> API method operation here is part of the <strong class="source-inline">manager.py</strong> module in the <strong class="source-inline">admin</strong> package, implemented using <strong class="source-inline">APIRouter</strong> due to project structuring. The<a id="_idIndexMarker088"/> method returns a list of tourist records that are allowed to access the application, which can only be provided by the <strong class="source-inline">user.py</strong> module in the <strong class="source-inline">login</strong> package.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Importing the module components</h2>
			<p>Module scripts can <a id="_idIndexMarker089"/>share their <em class="italic">containers</em>, <strong class="source-inline">BaseModel</strong> <em class="italic">classes</em>, and other <em class="italic">resource objects</em> to other modules using Python’s <strong class="source-inline">from… import</strong> statement. Python’s <strong class="source-inline">from… import</strong> statement is better since it allows us to import specific components from a module, instead of including unnecessary ones:</p>
			<pre class="source-code">
from fastapi import APIRouter, status
from places.destination import <strong class="bold">Tour</strong>, <strong class="bold">TourBasicInfo</strong>, 
    TourInput, <strong class="bold">TourLocation</strong>, tours, tours_basic_info, 
    tours_locations
<strong class="bold">router = APIRouter()</strong>
<strong class="bold">@router.put("/ch02/admin/destination/update", </strong>
            <strong class="bold">status_code=status.HTTP_202_ACCEPTED)</strong>
def update_tour_destination(tour: <strong class="bold">Tour</strong>):
    try:
        tid = tour.id
        tours[tid] = tour
        tour_basic_info = <strong class="bold">TourBasicInfo</strong>(id=tid, 
           name=tour.name, type=tour.type, 
           amenities=tour.amenities, ratings=tour.ratings)
        tour_location = <strong class="bold">TourLocation</strong>(id=tid, 
           name=tour.name, city=tour.city, 
           country=tour.country, location=tour.location )
        tours_basic_info[tid] = tour_basic_info
        tours_locations[tid] = tour_location
        return { "message" : "tour updated" }
    except:
        return { "message" : "tour does not exist" } </pre>
			<p>The <strong class="source-inline">update_tour_destination()</strong> operation here will not work without importing the <strong class="source-inline">Tour</strong>, <strong class="source-inline">TourBasicInfo</strong>, and <strong class="source-inline">TourLocation</strong> model classes from <strong class="source-inline">destination.py</strong> in the <strong class="source-inline">places</strong> package. It shows the dependency between modules that happens when structuring is imposed on big enterprise web projects.</p>
			<p>Module scripts<a id="_idIndexMarker090"/> can also import components from the main project folder when needed by the implementation. One such example is accessing the <em class="italic">middleware</em>, <em class="italic">exception</em> <em class="italic">handlers</em>, and <em class="italic">tasks</em> from the <strong class="source-inline">main.py</strong> file.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Avoid cycles when dealing with the <strong class="source-inline">from… import</strong> statement. A <strong class="bold">cycle</strong> happens when a module script, <strong class="source-inline">a.py</strong>, accesses components<a id="_idIndexMarker091"/> from <strong class="source-inline">b.py</strong> that import resource objects from <strong class="source-inline">a.py</strong>. FastAPI does not accept this scenario and will issue an error message.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Implementing the new main.py file</h2>
			<p>Technically, the <a id="_idIndexMarker092"/>project’s packages and its module scripts will not be recognized by the framework unless their respective <strong class="source-inline">router</strong> object is added or injected into the application’s core through the <strong class="source-inline">main.py</strong> file. <strong class="source-inline">main.py</strong>, just as the other project-level scripts do, uses <strong class="source-inline">FastAPI</strong> and not <strong class="source-inline">APIRouter</strong> to create and register components, as well as the package’s modules. The FastAPI class has an <strong class="source-inline">include_router()</strong> method that adds all these routers and injects them into the framework to make them part of the project structure. Beyond registering the routers, this method can also <a id="_idIndexMarker093"/>add other attributes and components to the router such as <em class="italic">URL prefixes</em>, <em class="italic">tags</em>, <em class="italic">dependencies such as exception handlers</em>, and <em class="italic">status codes</em>:</p>
			<pre class="source-code">
from fastapi import FastAPI, Request
<strong class="bold">from admin import manager</strong>
<strong class="bold">from login import user</strong>
<strong class="bold">from feedback import post</strong>
<strong class="bold">from places import destination</strong>
<strong class="bold">from tourist import visit</strong>
app = <strong class="bold">FastAPI</strong>()
app.include_router(<strong class="bold">manager.router</strong>)
app.include_router(<strong class="bold">user.router</strong>)
app.include_router(<strong class="bold">destination.router</strong>)
app.include_router(<strong class="bold">visit.router</strong>)
app.include_router(
    <strong class="bold">post.router</strong>,
    prefix="/ch02/post"
)</pre>
			<p>This code is the <strong class="source-inline">main.py</strong> implementation of the intelligent tourist system prototype tasked to import all the registers of the module’s scripts from the different packages, before adding them as components to the framework. Run the application using the following command:</p>
			<p class="source-code">uvicorn main:app –-reload</p>
			<p>This will allow you to access all the APIs of these modules at <strong class="source-inline">http://localhost:8000/docs</strong>.</p>
			<p>What happens to the<a id="_idIndexMarker094"/> application when API services encounter runtime problems during execution? Is there a way to manage these problems besides applying Python’s <strong class="source-inline">try-except</strong> block? Let us explore implementing API services with exception-handling mechanisms further.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Managing API-related exceptions</h1>
			<p>The FastAPI framework <a id="_idIndexMarker095"/>has a built-in exception handler derived from its Starlette toolkit that always returns default JSON responses whenever <strong class="source-inline">HTTPException</strong> is encountered during the execution of the REST API operation. For instance, accessing the API at <strong class="source-inline">http://localhost:8000/ch02/user/login</strong> without providing the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> will give us the default JSON output depicted in <em class="italic">Figure 2.2</em>:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_2.2_B17975.jpg" alt="Figure 2.2 – The default exception result"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The default exception result</p>
			<p>In some rare cases, the framework sometimes chooses to return the HTTP response status instead of the default JSON content. But developers can still opt to override these default handlers to choose which responses to return whenever a specific exception cause happens. </p>
			<p>Let us now explore how to formulate a standardized and appropriate way of managing runtime errors in our API implementation.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>A single status code response</h2>
			<p>One way of managing<a id="_idIndexMarker096"/> the exception-handling mechanism of your application is to apply a <strong class="source-inline">try-except</strong> block to manage the return responses of your API when it encounters an exception or none. After applying <strong class="source-inline">try-block</strong>, the operation should trigger a single <strong class="bold">status code</strong>, most often <strong class="bold">Status Code 200</strong> (<strong class="bold">SC 200</strong>). The path operation of <strong class="source-inline">FastAPI</strong> and <strong class="source-inline">APIRouter</strong> has a <strong class="source-inline">status_code</strong> parameter that we can use to indicate the type of status code we want to raise.</p>
			<p>In FastAPI, status codes are integer constants that are found in the <strong class="source-inline">status</strong> module. It also allows integer literals to indicate the needed status code if they are a valid status code number.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">A status code<a id="_idIndexMarker097"/> is a 3-digit number that indicates a reason for, information on, or status of the HTTP response of a REST API operation. The status code range 200 to 299 denotes a successful response, 300 to 399 pertains to redirection, 400-499 pertains to client-related problems, and 500 to 599 is related to server errors.</p>
			<p>This <a id="_idIndexMarker098"/>technique is rarely used because there are times that an operation needs to be clear in recognizing every exception that it encounters, which can only be done by returning <strong class="source-inline">HTTPException</strong> instead of a custom error message wrapped in a JSON object:</p>
			<pre class="source-code">
from fastapi import APIRouter, <strong class="bold">status</strong>
@router.put("/ch02/admin/destination/update", 
              <strong class="bold">status_code=status.HTTP_202_ACCEPTED</strong>)
def update_tour_destination(tour: Tour):
    <strong class="bold">try:</strong>
        tid = tour.id
        tours[tid] = tour
        tour_basic_info = TourBasicInfo(id=tid, 
           name=tour.name, type=tour.type, 
           amenities=tour.amenities, ratings=tour.ratings)
        tour_location = TourLocation(id=tid, 
           name=tour.name, city=tour.city, 
           country=tour.country, location=tour.location )
        tours_basic_info[tid] = tour_basic_info
        tours_locations[tid] = tour_location
        <strong class="bold">return { "message" : "tour updated" }</strong>
    <strong class="bold">except:</strong>
        <strong class="bold">return { "message" : "tour does not exist" }</strong>
@router.get("/ch02/admin/destination/list", 
            <strong class="bold">status_code=200</strong>)
def list_all_tours():
    return tours</pre>
			<p>The <strong class="source-inline">list_all_tours()</strong> method shown here is the kind of REST API service that should emit Status Code 200 – it gives an error-free result just by rendering the Python collection with data. Observe that the literal integer value, <strong class="source-inline">200</strong>, or <em class="italic">SC 200</em>, assigned to the <strong class="source-inline">status_code</strong> parameter of the <strong class="source-inline">GET</strong> path operation always raises an <em class="italic">OK</em> status. On the other hand, the <strong class="source-inline">update_tour_destination()</strong> method shows another<a id="_idIndexMarker099"/> approach in emitting status codes by using a <strong class="source-inline">try-except</strong> block, wherein both blocks return a custom JSON response. Whichever scenario happens, it will always trigger <em class="italic">SC 202</em>, which may not apply to some REST implementations. After the <strong class="source-inline">status</strong> module is imported, its <strong class="source-inline">HTTP_202_ACCEPTED</strong> constant is used to set the value of the <strong class="source-inline">status_code</strong> parameter.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Multiple status codes</h2>
			<p>If we need each <a id="_idIndexMarker100"/>block in <strong class="source-inline">try-except</strong> to return their respective status code, we need to avoid using the <strong class="source-inline">status_code</strong> parameter of the path operations and use <strong class="source-inline">JSONResponse</strong> instead. <strong class="source-inline">JSONResponse</strong> is one of the FastAPI classes used to render a JSON response to the client. It is instantiated, constructor-injected with values for its <strong class="source-inline">content</strong> and <strong class="source-inline">status_code</strong> parameters, and returned by the path operations. By default, the framework uses this API to help path operations render responses as JSON types. Its <strong class="source-inline">content</strong> parameter should be a JSON-type object, while the <strong class="source-inline">status_code</strong> parameter can be an integer constant and a valid status code number, or it can be a constant from the<a id="_idIndexMarker101"/> module status:</p>
			<pre class="source-code">
from fastapi.responses import <strong class="bold">JSONResponse</strong>
<strong class="bold">@router.post("/ch02/admin/destination/add")</strong>
add_tour_destination(input: TourInput):
    <strong class="bold">try:</strong>
        tid = uuid1()
        tour = Tour(id=tid, name=input.name,
           city=input.city, country=input.country, 
           type=input.type, location=input.location,
           amenities=input.amenities, feedbacks=list(), 
           ratings=0.0, visits=0, isBooked=False)
        tour_basic_info = TourBasicInfo(id=tid, 
           name=input.name, type=input.type, 
           amenities=input.amenities, ratings=0.0)
        tour_location = TourLocation(id=tid, 
           name=input.name, city=input.city, 
           country=input.country, location=input.location )
        tours[tid] = tour
        tours_basic_info[tid] = tour_basic_info
        tours_locations[tid] = tour_location
        tour_json = jsonable_encoder(tour)
        <strong class="bold">return JSONResponse(content=tour_json, </strong>
            <strong class="bold">status_code=status.HTTP_201_CREATED)</strong>
    <strong class="bold">except:</strong>
        <strong class="bold">return JSONResponse(</strong>
         <strong class="bold">content={"message" : "invalid tour"}, </strong>
         <strong class="bold">status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)</strong></pre>
			<p>The <strong class="source-inline">add_tour_destination()</strong> operation here has a <strong class="source-inline">try-except</strong> block where its <strong class="source-inline">try</strong> block<a id="_idIndexMarker102"/> returns the tour details and <em class="italic">SC 201</em>, while its <strong class="source-inline">catch</strong> block returns an error message inside a JSON-type object with a server error of <em class="italic">SC 500</em>.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Raising HTTPException</h2>
			<p>Another way of<a id="_idIndexMarker103"/> managing possible errors is by letting the REST API throw the <strong class="source-inline">HTTPException</strong> object. <strong class="source-inline">HTTPException</strong> is a FastAPI class that has required constructor parameters: <strong class="source-inline">detail</strong>, which needs an error message in the <strong class="source-inline">str</strong> type, and <strong class="source-inline">status_code</strong>, which asks for a valid integer value. The <strong class="source-inline">detail</strong> part is converted to JSON-type and returned to the user as a response after the <strong class="source-inline">HTTPException</strong> instance is thrown by the operation. </p>
			<p>To throw <strong class="source-inline">HTTPException</strong>, a validation process using any variations of <strong class="source-inline">if</strong> statements is more appropriate than using the <strong class="source-inline">try-except</strong> block because the cause of the error needs to be identified before throwing the <strong class="source-inline">HTTPException</strong> object using the <strong class="source-inline">raise</strong> statement. Once <strong class="source-inline">raise</strong> is executed, the whole operation will halt and send the HTTP error message in JSON-type to the client with the specified status code:</p>
			<pre class="source-code">
from fastapi import APIRouter, <strong class="bold">HTTPException</strong>, status
<strong class="bold">@router.post("/ch02/tourist/tour/booking/add")</strong>
def create_booking(tour: TourBasicInfo, touristId: UUID):
    if approved_users.get(touristId) == None:
         <strong class="bold">raise HTTPException(status_code=500,</strong>
            <strong class="bold">detail="details are missing")</strong>
    booking = Booking(id=uuid1(), destination=tour,
      booking_date=datetime.now(), tourist_id=touristId)
    approved_users[touristId].tours.append(tour)
    approved_users[touristId].booked += 1
    tours[tour.id].isBooked = True
    tours[tour.id].visits += 1
    return booking</pre>
			<p>The <strong class="source-inline">create_booking()</strong> operation here simulates a booking process for a <em class="italic">tourist</em> account, but <a id="_idIndexMarker104"/>before the procedure starts, it first checks whether the <em class="italic">tourist</em> is still a valid user; otherwise, it will raise <strong class="source-inline">HTTPException</strong>, halting all the operations in order to return an error message.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Custom exceptions</h2>
			<p>It is also possible to create a<a id="_idIndexMarker105"/> user-defined <strong class="source-inline">HTTPException</strong> object to handle business-specific problems. This custom exception requires a custom handler needed to manage its response to the client whenever an operation raises it. These custom components should be available to all API methods across the project structure; thus, they must be implemented at the project-folder level.</p>
			<p>In our application, there are two custom exceptions created in <strong class="source-inline">handler_exceptions.py</strong>, the <strong class="source-inline">PostFeedbackException</strong> and <strong class="source-inline">PostRatingFeedback</strong> exceptions, which handle problems related to posting feedback and ratings on a particular tour:</p>
			<pre class="source-code">
from fastapi import FastAPI, Request, status, <strong class="bold">HTTPException</strong>
class PostFeedbackException(<strong class="bold">HTTPException</strong>):
    def __init__(self, detail: str, status_code: int):
        <strong class="bold">self.status_code = status_code</strong>
        <strong class="bold">self.detail = detail</strong>
        
class PostRatingException(<strong class="bold">HTTPException</strong>):
    def __init__(self, detail: str, status_code: int):
        <strong class="bold">self.status_code = status_code</strong>
        <strong class="bold">self.detail = detail</strong></pre>
			<p>A valid FastAPI exception is a subclass of an <strong class="source-inline">HTTPException</strong> object inheriting the essential attributes, namely the <strong class="source-inline">status_code</strong> and <strong class="source-inline">detail</strong> attributes. We need to supply values to these attributes before the path operation raises the exception. After creating these custom exceptions, a specific handler is implemented and mapped to an exception.</p>
			<p>The FastAPI <strong class="source-inline">@app</strong> decorator in <strong class="source-inline">main.py</strong> has an <strong class="source-inline">exception_handler()</strong> method, used to define a custom handler and map it to the appropriate custom exception. A handler is simply a Python function with two local parameters, <strong class="source-inline">Request</strong> and the <em class="italic">custom exception</em> that it manages. The purpose of the <strong class="source-inline">Request</strong> object is to retrieve cookies, payloads, headers, query parameters, and path parameters from the path operation if the handler expects any of this request data. Now, once the custom exception is raised, the<a id="_idIndexMarker106"/> handler is set to generate a JSON-type response to the client containing the <strong class="source-inline">detail</strong> and the <strong class="source-inline">status_code</strong> attributes provided by the path operation that raised the exception:</p>
			<pre class="source-code">
from fastapi.responses import <strong class="bold">JSONResponse</strong>
from fastapi import FastAPI, <strong class="bold">Request</strong>, status, HTTPException
@app.exception_handler(<strong class="bold">PostFeedbackException</strong>)
def feedback_exception_handler(<strong class="bold">req: Request</strong>, 
          <strong class="bold">ex: PostFeedbackException</strong>):
    return <strong class="bold">JSONResponse(</strong>
        <strong class="bold">status_code=ex.status_code,</strong>
        <strong class="bold">content={"message": f"error: {ex.detail}"}</strong>
        <strong class="bold">)</strong>
    
@app.exception_handler(<strong class="bold">PostRatingException</strong>)
def rating_exception_handler(<strong class="bold">req: Request</strong>, 
             <strong class="bold">ex: PostRatingException</strong>):
     return <strong class="bold">JSONResponse(</strong>
        <strong class="bold">status_code=ex.status_code,</strong>
        <strong class="bold">content={"message": f"error: {ex.detail}"}</strong>
        <strong class="bold">)</strong></pre>
			<p>When an operation in <strong class="source-inline">post.py</strong> raises <strong class="source-inline">PostFeedbackException</strong>, the <strong class="source-inline">feedback_exception_handler()</strong> given here will trigger its execution to generate a response that can provide details about what has caused the feedback problem. The same<a id="_idIndexMarker107"/> thing will happen to <strong class="source-inline">PostRatingException</strong> and its <strong class="source-inline">rating_exception_handler()</strong>:</p>
			<pre class="source-code">
from <strong class="bold">handlers</strong> import <strong class="bold">PostRatingException</strong>,
                         <strong class="bold">PostFeedbackException</strong>
    
@router.post("/feedback/add")
def post_tourist_feedback(touristId: UUID, tid: UUID, 
      post: Post, bg_task: BackgroundTasks):
    <strong class="bold">if approved_users.get(touristId) == None and </strong>
          <strong class="bold">tours.get(tid) == None:</strong>
        <strong class="bold">raise PostFeedbackException(detail='tourist and </strong>
                <strong class="bold">tour details invalid', status_code=403)</strong>
    assessId = uuid1()
    assessment = Assessment(id=assessId, post=post, 
          tour_id= tid, tourist_id=touristId) 
    feedback_tour[assessId] = assessment
    tours[tid].ratings = (tours[tid].ratings + 
                            post.rating)/2
    bg_task.add_task(log_post_transaction, 
           str(touristId), message="post_tourist_feedback")
    assess_json = jsonable_encoder(assessment)
    return JSONResponse(content=assess_json, 
                         status_code=200)
@router.post("/feedback/update/rating")
def update_tour_rating(assessId: UUID, 
               new_rating: StarRating):
    <strong class="bold">if feedback_tour.get(assessId) == None:</strong>
        <strong class="bold">raise PostRatingException(</strong>
         <strong class="bold">detail='tour assessment invalid', status_code=403)</strong>
    tid = feedback_tour[assessId].tour_id
    tours[tid].ratings = (tours[tid].ratings + 
                            new_rating)/2
    tour_json = jsonable_encoder(tours[tid])
    return JSONResponse(content=tour_json, status_code=200)</pre>
			<p><strong class="source-inline">post_tourist_feedback()</strong> and <strong class="source-inline">update_tour_rating()</strong> here are the API <a id="_idIndexMarker108"/>operations that will raise the <strong class="source-inline">PostFeedbackException</strong> and <strong class="source-inline">PostRatingException</strong> custom exceptions, respectively, triggering the execution of their handlers. The <strong class="source-inline">detail</strong> and <strong class="source-inline">status_code</strong> values injected into the constructor are passed to the handlers to create the response.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>A default handler override</h2>
			<p>The optimum <a id="_idIndexMarker109"/>way to override the exception-handling mechanism of your application is to replace the global exception handler of the FastAPI framework that manages its core Starlette’s <strong class="source-inline">HTTPException</strong> and the <strong class="source-inline">RequestValidationError</strong> triggered by <strong class="bold">Pydantic</strong>’s request validation process. For instance, if we want to change the response format of the global exception sent to the client using <strong class="source-inline">raise</strong> from JSON-type to plain text, we can create custom handlers for each of the aforementioned core exceptions that will pursue the format conversion. The following snippets of <strong class="source-inline">main.py</strong> show these types of custom handlers:</p>
			<pre class="source-code">
from fastapi.responses import <strong class="bold">PlainTextResponse</strong> 
from <strong class="bold">starlette.exceptions</strong> import HTTPException as 
         <strong class="bold">GlobalStarletteHTTPException</strong>
from fastapi.exceptions import <strong class="bold">RequestValidationError</strong>
<strong class="bold">from handler_exceptions import PostFeedbackException</strong>, 
        <strong class="bold">PostRatingException</strong>
@app.exception_handler(<strong class="bold">GlobalStarletteHTTPException</strong>)
def global_exception_handler(req: Request, 
                 ex: str
    return <strong class="bold">PlainTextResponse(f"Error message:</strong> 
       <strong class="bold">{ex}", status_code=ex.status_code)</strong>
@app.exception_handler(<strong class="bold">RequestValidationError</strong>)
def validationerror_exception_handler(req: Request, 
                 ex: str
    return <strong class="bold">PlainTextResponse(f"Error message:</strong> 
       <strong class="bold">{str(ex)}", status_code=400)</strong></pre>
			<p>Both the <strong class="source-inline">global_exception_handler()</strong> and <strong class="source-inline">validationerror_exception_handler()</strong> handlers are implemented to change the framework’s JSON-type exception response to <strong class="source-inline">PlainTextResponse</strong>. An alias, <strong class="source-inline">GlobalStarletteHTTPException</strong>, is assigned to Starlette’s <strong class="source-inline">HTTPException</strong> class to distinguish it from FastAPI’s <strong class="source-inline">HTTPException</strong>, which we previously used to build custom exceptions. On the other hand, <strong class="source-inline">PostFeedbackException</strong> and <strong class="source-inline">PostRatingException</strong> are both implemented in the <strong class="source-inline">handler_exceptions.py</strong> module.</p>
			<p>JSON objects <a id="_idIndexMarker110"/>are all over the FastAPI framework’s REST API implementation, from the incoming request to the outgoing responses. However, what if the JSON data involved in the process is not a FastAPI JSON-compatible type? The following discussion will expound more upon this kind of object.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Converting objects to JSON-compatible types</h1>
			<p>It is easier for<a id="_idIndexMarker111"/> FastAPI to process JSON-compatible <a id="_idIndexMarker112"/>types such as <strong class="source-inline">dict</strong>, <strong class="source-inline">list</strong>, and <strong class="source-inline">BaseModel</strong> objects because they can be easily converted to JSON by the framework using its default JSON editor. However, there are circumstances in which runtime exceptions are raised when processing BaseModel, data model, or JSON objects containing data. One of the many reasons for this is that these data objects have attributes that are not supported by JSON rules, such as UUID and non-built-in date types. Regardless, using a framework’s module classes, these objects can still be utilized by converting them into JSON-compatible ones.</p>
			<p>When it comes to the direct handling of the API operation’s responses, FastAPI has a built-in method that can encode typical model objects to convert them to JSON-compatible types before persisting them to any datastore or passing them to the <strong class="source-inline">detail</strong> parameter of <strong class="source-inline">JSONResponse</strong>. This method, <strong class="source-inline">jsonable_encoder()</strong>, returns a <strong class="source-inline">dict</strong> type with all the keys and values compatible with JSON:</p>
			<pre class="source-code">
from fastapi.encoders import <strong class="bold">jsonable_encoder</strong>
from fastapi.responses import JSONResponse
class Tourist(BaseModel):
    id: UUID
    login: User
    <strong class="bold">date_signed: datetime</strong>
    booked: int
    tours: List[TourBasicInfo]
    
@router.post("/ch02/user/signup/")
async def signup(signup: Signup):
    try:
        userid = uuid1()
        login = User(id=userid, username=signup.username, 
               password=signup.password)
        tourist = Tourist(id=userid, login=login, 
          date_signed=datetime.now(), booked=0, 
          tours=list() )
        <strong class="bold">tourist_json = jsonable_encoder(tourist)</strong>
        pending_users[userid] = tourist_json
        return JSONResponse(content=tourist_json, 
            status_code=status.HTTP_201_CREATED)
    except:
        return JSONResponse(content={"message": 
         "invalid operation"}, 
         status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)</pre>
			<p>Our<a id="_idIndexMarker113"/> application has a <strong class="source-inline">POST</strong> operation, <strong class="source-inline">signup()</strong>, shown here that captures the profile of a newly created user to be <a id="_idIndexMarker114"/>approved by the administrator. If you observe the <strong class="source-inline">Tourist</strong> model class, it has a <strong class="source-inline">date_signed</strong> attribute that is declared as <strong class="source-inline">datettime</strong>, and temporal types are not always JSON-friendly. Having model objects with non-JSON-friendly components in FastAPI-related operations can cause serious exceptions. To avoid these Pydantic validation issues, it is always advisable to use <strong class="source-inline">jsonable_encoder()</strong> to manage the conversion of all the attributes of our model object into JSON-types.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <strong class="source-inline">json</strong> module with its <strong class="source-inline">dumps()</strong> and <strong class="source-inline">loads()</strong> utility methods can be used instead of <strong class="source-inline">jsonable_encoder()</strong> but a custom JSON encoder should be created to successfully map the <strong class="source-inline">UUID</strong> type, the formatted <strong class="source-inline">date</strong> type, and other complex attribute types to <strong class="source-inline">str</strong>.</p>
			<p><a href="B17975_09.xhtml#_idTextAnchor266"><em class="italic">Chapter 9</em></a>, <em class="italic">Utilizing Other Advanced Features</em>, will discuss other JSON encoders that can encode and decode JSON responses faster than the <strong class="source-inline">json</strong> module.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Managing API responses</h1>
			<p>The use of <strong class="source-inline">jsonable_encoder()</strong> can help an API method not only with data persistency problems <a id="_idIndexMarker115"/>but also with the integrity and correctness of its response. In the <strong class="source-inline">signup()</strong> service method, <strong class="source-inline">JSONResponse</strong> returns the encoded <strong class="source-inline">Tourist</strong> model instead of the original object to ensure that the client always received a JSON response. Aside from raising status codes and providing error messages, <strong class="source-inline">JSONResponse</strong> can also do some tricks in handling the API responses to the client. Although optional in many circumstances, applying the encoder method when generating responses is recommended to avoid runtime errors:</p>
			<pre class="source-code">
from fastapi.encoders import <strong class="bold">jsonable_encoder</strong>
from fastapi.responses import <strong class="bold">JSONResponse</strong>
@router.get("/ch02/destinations/details/{id}")
def check_tour_profile(id: UUID):
    <strong class="bold">tour_info_json = jsonable_encoder(tours[id])</strong>
    return <strong class="bold">JSONResponse(content=tour_info_json)</strong></pre>
			<p><strong class="source-inline">check_tour_profile()</strong> here uses <strong class="source-inline">JSONResponse</strong> to ensure that its response is JSON-compatible and is fetched from the purpose of managing its exceptions. Moreover, it can<a id="_idIndexMarker116"/> also be used to return headers together with the JSON-type response:</p>
			<pre class="source-code">
@router.get("/ch02/destinations/list/all")
def list_tour_destinations():
    tours_json = jsonable_encoder(tours)
    <strong class="bold">resp_headers = {'X-Access-Tours': 'Try Us', </strong>
       <strong class="bold">'X-Contact-Details':'1-900-888-TOLL', </strong>
       <strong class="bold">'Set-Cookie':'AppName=ITS; Max-Age=3600; Version=1'}</strong>
    return JSONResponse(content=tours_json, 
          <strong class="bold">headers=resp_headers</strong>)</pre>
			<p>The application’s <strong class="source-inline">list_tour_destinations()</strong> here returns three cookies: <strong class="source-inline">AppName</strong>, <strong class="source-inline">Max-Age</strong>, and <strong class="source-inline">Version</strong>, and two user-defined response headers. Headers that have names beginning with <strong class="source-inline">X-</strong> are custom headers. Besides <strong class="source-inline">JSONResponse</strong>, the <strong class="source-inline">fastapi</strong> module also has a <strong class="source-inline">Response</strong> class that can create response headers:</p>
			<pre class="source-code">
from fastapi import APIRouter, <strong class="bold">Response</strong>
@router.get("/ch02/destinations/mostbooked")
def check_recommended_tour(resp: <strong class="bold">Response</strong>):
    <strong class="bold">resp.headers['X-Access-Tours'] = 'TryUs'</strong>
    <strong class="bold">resp.headers['X-Contact-Details'] = '1900888TOLL'</strong>
    <strong class="bold">resp.headers['Content-Language'] = 'en-US'</strong>
    ranked_desc_rates = sort_orders = sorted(tours.items(),
         key=lambda x: x[1].ratings, reverse=True)
    return ranked_desc_rates;</pre>
			<p>Our prototype’s <strong class="source-inline">check_recommend_tour()</strong> uses <strong class="source-inline">Response</strong> to create two custom response<a id="_idIndexMarker117"/> headers and a <a id="_idIndexMarker118"/>known <strong class="bold">Content-Language</strong>. Always remember that headers are all <strong class="source-inline">str</strong> types and are stored in the browser for many reasons, such as creating an identity for the application, leaving user trails, dropping advertisement-related data, or leaving an error message to the browser when an API encounters one:</p>
			<pre class="source-code">
@router.get("/ch02/tourist/tour/booked")
def show_booked_tours(touristId: UUID):
    if approved_users.get(touristId) == None:
         raise <strong class="bold">HTTPException</strong>(
         status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, 
         detail="details are missing", 
         <strong class="bold">headers={"X-InputError":"missing tourist ID"})</strong>
    return approved_users[touristId].tours</pre>
			<p><strong class="source-inline">HTTPException</strong>, as <a id="_idIndexMarker119"/>shown in the <strong class="source-inline">show_booked_tours()</strong> service method here, not only contains the status code and error message but also some headers in case the operation needs to leave some error information to the browser once it is raised. </p>
			<p>Let us now explore the capability of FastAPI to create and manage transactions that are designed to run in the background using some server threads.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Creating background processes</h1>
			<p>The FastAPI <a id="_idIndexMarker120"/>framework is also capable of running background jobs as part of an API service execution. It can even run more than one job almost simultaneously without intervening in the main service execution. The class responsible for this is <strong class="source-inline">BackgroundTasks</strong>, which is part of the <strong class="source-inline">fastapi</strong> module. Conventionally, we declare this at the end of the parameter list of the API service method for the framework to inject the <strong class="source-inline">BackgroundTask</strong> instance.</p>
			<p>In our <a id="_idIndexMarker121"/>application, the task is to create audit logs of all API service executions and store them in an <strong class="source-inline">audit_log.txt</strong> file. This operation is part of the <strong class="source-inline">background.py</strong> script that is part of the main project folder, and the code is shown here:</p>
			<pre class="source-code">
from datetime import datetime
def audit_log_transaction(touristId: str, message=""):
    with open("audit_log.txt", mode="a") as logfile:
        content = f"tourist {touristId} executed {message} 
            at {datetime.now()}"
        logfile.write(content)</pre>
			<p>Here, <strong class="source-inline">audit_log_transaction()</strong> must be injected into the application using <strong class="source-inline">BackgroundTasks</strong>’s <strong class="source-inline">add_task()</strong> method to become a background process that will be executed by the framework later:</p>
			<pre class="source-code">
from fastapi import APIRouter, status, <strong class="bold">BackgroundTasks</strong>
<strong class="bold">@router.post("/ch02/user/login/")</strong>
async def login(login: User, <strong class="bold">bg_task:BackgroundTasks</strong>):
    try:
        signup_json = 
           jsonable_encoder(approved_users[login.id]) 
        <strong class="bold">bg_task.add_task(audit_log_transaction,</strong>
            <strong class="bold">touristId=str(login.id), message="login")</strong>
        return JSONResponse(content=signup_json, 
            status_code=status.HTTP_200_OK)
    except:
        return JSONResponse(
         content={"message": "invalid operation"}, 
         status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
<strong class="bold">@router.get("/ch02/user/login/{username}/{password}")</strong>
async def login(username:str, password: str, 
                    <strong class="bold">bg_task:BackgroundTasks</strong>):
     tourist_list = [ tourist for tourist in 
        approved_users.values() 
          if tourist['login']['username'] == username and 
              tourist['login']['password'] == password] 
     if len(tourist_list) == 0 or tourist_list == None:
        return JSONResponse(
           content={"message": "invalid operation"}, 
           status_code=status.HTTP_403_FORBIDDEN)
     else:
        tourist = tourist_list[0]
        tour_json = jsonable_encoder(tourist)
        <strong class="bold">bg_task.add_task(audit_log_transaction, </strong>
          <strong class="bold">touristId=str(tourist['login']['id']), message="login")</strong>
        return JSONResponse(content=tour_json, 
            status_code=status.HTTP_200_OK)</pre>
			<p>The <strong class="source-inline">login()</strong> service method is just one of the services of our application that logs its details. It uses the <strong class="source-inline">bg_task</strong> object to add <strong class="source-inline">audit_log_transaction()</strong> into the framework to <a id="_idIndexMarker122"/>be processed later. Transactions such as logging, <em class="italic">SMTP</em>-/<em class="italic">FTP</em>-related requirements, events, and some database-related triggers are the best candidates for background jobs.     </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Clients will always get their response from the REST API method despite the execution time of the background task. Background tasks are for processes that will take enough time that including them in the API operation could cause performance degradation.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Using asynchronous path operations</h1>
			<p>When it comes to improving <a id="_idIndexMarker123"/>performance, FastAPI is an asynchronous framework, and it uses Python’s <strong class="bold">AsyncIO</strong> principles and concepts to create a REST API implementation that can run separately and independently from the application’s main thread. The idea also applies to how a background task is executed. Now, to create an asynchronous REST endpoint, attach <strong class="source-inline">async</strong> to the <strong class="source-inline">func</strong> signature of the service:</p>
			<pre class="source-code">
@router.get("/feedback/list")
<strong class="bold">async</strong> def show_tourist_post(touristId: UUID):
    tourist_posts = [assess for assess in feedback_tour.values() 
            if assess.tourist_id == touristId]
    tourist_posts_json = jsonable_encoder(tourist_posts) 
    return JSONResponse(content=tourist_posts_json,
                   status_code=200)</pre>
			<p>Our application has a <strong class="source-inline">show_tourist_post()</strong> service that can retrieve all the feedback posted by a certain <strong class="source-inline">touristId</strong> about a vacation tour that they have experienced. The application will not be affected no matter how long the service will take because its execution will be simultaneous to the <strong class="source-inline">main</strong> thread.  </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <strong class="source-inline">feedback</strong> APIRouter uses a <strong class="source-inline">/ch02/post</strong> prefix indicated in its <strong class="source-inline">main.py</strong>’s <strong class="source-inline">include_router()</strong> registration. So, to run <strong class="source-inline">show_tourist_post()</strong>, the URL should be <strong class="source-inline">http://localhost:8000/ch02/post</strong>.</p>
			<p>An <a id="_idIndexMarker124"/>asynchronous API endpoint can invoke both synchronous and asynchronous Python functions that can be DAO (Data Access Object), native services, or utility. Since FastAPI also follows the <strong class="source-inline">Async/Await</strong> design pattern, the asynchronous endpoint can call an asynchronous non-API operation using the <strong class="source-inline">await</strong> keyword, which halts the API operation until the non-API transaction is done processing a promise:</p>
			<pre class="source-code">
from utility import <strong class="bold">check_post_owner</strong>
<strong class="bold">@router.delete("/feedback/delete")</strong>
<strong class="bold">async</strong> def delete_tourist_feedback(assessId: UUID, 
              touristId: UUID ):
    if approved_users.get(touristId) == None and 
            feedback_tour.get(assessId):
        raise PostFeedbackException(detail='tourist and 
              tour details invalid', status_code=403)    post_delete = [access for access in feedback_tour.values()
               if access.id == assessId]
    for key in post_delete:
        <strong class="bold">is_owner = await check_post_owner(feedback_tour, </strong>
                       <strong class="bold">access.id, touristId)</strong>
        if is_owner:
            del feedback_tour[access.id]
    return JSONResponse(content={"message" : f"deleted
          posts of {touristId}"}, status_code=200)</pre>
			<p><strong class="source-inline">delete_tourist_feedback()</strong> here is an asynchronous REST API endpoint that calls an asynchronous Python function, <strong class="source-inline">check_post_owner()</strong>, from the <strong class="source-inline">utility.py</strong> script. For the two components to have a handshake, the API service invokes <strong class="source-inline">check_post_owner()</strong>, using an <strong class="source-inline">await</strong> keyword for the former to wait for the latter to finish its validation, and retrieves the promise that it can get from <strong class="source-inline">await</strong>. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <strong class="source-inline">await</strong> keyword can only be used with the <strong class="source-inline">async</strong> REST API and native transactions, not with synchronous ones. </p>
			<p>To<a id="_idIndexMarker125"/> improve performance, you can add more threads within the <strong class="source-inline">uvicorn</strong> thread pool by including the <strong class="source-inline">--workers</strong> option when running the server. Indicate your preferred number of threads after calling the option:</p>
			<p class="source-code">uvicorn main:app --workers 5 --reload</p>
			<p><a href="B17975_08.xhtml#_idTextAnchor229"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Coroutines, Events, and Message-Driven Transactions</em>, will discuss the <em class="italic">AsyncIO</em> platform and the use of <em class="italic">coroutines</em> in more detail. </p>
			<p>And now, the last, most important core feature that FastAPI can provide is the middleware or the "request-response filter."    </p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Applying middleware to filter path operations</h1>
			<p>There are FastAPI <a id="_idIndexMarker126"/>components that are inherently <a id="_idIndexMarker127"/>asynchronous and one of them is the middleware. It is an asynchronous function that acts as a filter for the REST API services. It filters out the incoming request to pursue validation, authentication, logging, background processing, or content generation from the cookies, headers, request parameters, query parameters, form data, or authentication details of the request body before it reaches the API service method. Equally, it takes the outgoing response body to pursue rendition change, response header updates and additions, and other kinds of transformation that could possibly be applied to the response before it reaches the client. Middleware should be implemented at the project level and can even be part of <strong class="source-inline">main.py</strong>:</p>
			<pre class="source-code">
<strong class="bold">@app.middleware("http")</strong>
<strong class="bold">async</strong> def log_transaction_filter(<strong class="bold">request: Request</strong>, 
             <strong class="bold">call_next</strong>):
    start_time = datetime.now()
    method_name= request.method
    qp_map = request.query_parasms
    pp_map = request.path_params
    with open("request_log.txt", mode="a") as reqfile:
        content = f"method: {method_name}, query param: 
            {qp_map}, path params: {pp_map} received at 
            {datetime.now()}"
        reqfile.write(content)
    <strong class="bold">response = await call_next(request)</strong>
    process_time = datetime.now() - start_time
    response.headers["X-Time-Elapsed"] = str(process_time)
    return response</pre>
			<p>To <a id="_idIndexMarker128"/>implement middleware, first, create an <strong class="source-inline">async</strong> function that has two local parameters: the first one is <strong class="source-inline">Request</strong> and the<a id="_idIndexMarker129"/> second one is a function called <strong class="source-inline">call_next()</strong>, which takes the <strong class="source-inline">Request</strong> parameter as its argument to return the response. Then, decorate the method with <strong class="source-inline">@app.middleware("http")</strong> to inject the component into the framework.</p>
			<p>The tourist application has one middleware implemented by the asynchronous <strong class="source-inline">add_transaction_filter()</strong> here that logs the necessary request data of a particular API method before its execution and modifies its response object by adding a response header, <strong class="source-inline">X-Time-Elapsed</strong>, which carries the running time of the execution. </p>
			<p>The execution of <strong class="source-inline">await call_next(request)</strong> is the most crucial part of the middleware because it explicitly controls the execution of the REST API service. It is the area of the component where <strong class="source-inline">Request</strong> passes through to the API execution for processing. Equally, it is where <strong class="source-inline">Response</strong> tunnels out, going to the client.</p>
			<p>Besides logging, middleware can also be used for implementing one-way or two-way authentication, checking user roles and permissions, global exception handling, and other filtering-related operations right before the execution of <strong class="source-inline">call_next()</strong>. When it comes to controlling the outgoing <strong class="source-inline">Response</strong>, it can be used to modify the content type of the response, remove some existing browser cookies, modify the response detail and status code, redirections, and other response transformation-related transactions. <a href="B17975_09.xhtml#_idTextAnchor266"><em class="italic">Chapter 9</em></a>,<em class="italic"> Utilizing Other Advanced Features</em>, will discuss<a id="_idIndexMarker130"/> the types of middleware, middleware<a id="_idIndexMarker131"/> chaining, and other means to customize middleware to help build a better microservice.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The FastAPI framework has some built-in middleware that is ready to be injected into the application such as <strong class="source-inline">GzipMiddleware</strong>, <strong class="source-inline">ServerErrorMiddleware</strong>, <strong class="source-inline">TrustedHostMiddleware</strong>, <strong class="source-inline">ExceptionMiddleware</strong>, <strong class="source-inline">CORSMiddleware</strong>, <strong class="source-inline">SessionMiddleware</strong>, and <strong class="source-inline">HTTPSRedirectionMiddleware</strong>. </p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Summary</h1>
			<p>Exploring the core details of a framework always helps us create a comprehensive plan and design to build quality applications to the required standards. We have learned that FastAPI injects all its incoming form data, request parameters, query parameters, cookies, request headers, and authentication details into the <strong class="source-inline">Request</strong> object, and the outgoing cookies, response headers, and response data are carried out to the client by the <strong class="source-inline">Response</strong> object. When managing the response data, the framework has a built-in <strong class="source-inline">jsonable_encoder()</strong> function that can convert the model into JSON types to be rendered by the <strong class="source-inline">JSONResponse</strong> object. Its middleware is one powerful feature of FastAPI because we can customize it to handle the <strong class="source-inline">Request</strong> object before it reaches the API execution and the <strong class="source-inline">Response</strong> object before the client receives it.</p>
			<p>Managing the exceptions is always the first step to consider before creating a practical and sustainable solution for the resiliency and health of a microservice architecture. Alongside its robust default <strong class="bold">Starlette</strong> global exception handler and <strong class="bold">Pydantic</strong> model validator, FastAPI allows exception-handling customization that provides the flexibility needed when business processes become intricate.</p>
			<p>FastAPI follows Python’s <strong class="bold">AsyncIO</strong> principles and standards for creating async REST endpoints, which makes implementation easy, handy, and reliable. This kind of platform is helpful for building complex architectures that require more threads and asynchronous transactions. </p>
			<p>This chapter is a great leap toward fully learning about the principles and standards of how FastAPI manages its web containers. The features highlighted in this chapter hitherto open up a new level of knowledge that we need to explore further if we want to utilize FastAPI to build great microservices. In the next chapter, we will be discussing FastAPI dependency injection and how this design pattern affects our FastAPI projects.</p>
		</div>
		<div>
			<div id="_idContainer016">
			</div>
		</div>
	</body></html>