- en: 'Chapter 8. Structs: Complex Types'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。结构体：复杂类型
- en: A **struct** is a collection of data variables or values that are grouped together
    under a single memory block, whereas a data structure is typically some sort of
    collection of objects that are related to one another in some way. Therefore,
    a struct, also known as a structure, is less of a data structure and more of a
    complex data type. This definition sounds pretty simple, but appearances are deceiving
    in this case. The topic of structs is a complex one, and each of the languages
    we are examining has unique qualities in how structs are supported, if they are
    supported at all.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构体**是一组数据变量或值的集合，这些变量或值被组织在单个内存块下，而数据结构通常是某种以某种方式相互关联的对象集合。因此，结构体，也称为结构，更多的是一种复杂的数据类型，而不是数据结构。这个定义听起来很简单，但在这个情况下，外表是欺骗性的。结构体的主题是复杂的，我们正在检查的每种语言在支持结构体方面都有其独特的特点，如果它们支持的话。'
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Definition of the struct data structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构数据结构的定义
- en: Creating structs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建结构体
- en: Common applications of structs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体的常见应用
- en: Examples of structs in each language
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种语言中结构体的示例
- en: Enums
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: The essentials
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: Due to varying support from language to language, we're will take a different
    approach in this chapter. Instead of examining structs as a whole and then examining
    a case study, we will examine structs and case studies simultaneously for each
    language. This will give us the opportunity to examine the nuances of structs
    in each language within the proper context.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语言之间的支持不同，我们将在本章采取不同的方法。我们不会将结构体作为一个整体来检查，然后再检查一个案例研究，而是将每种语言的结构体和案例研究同时进行检查。这将给我们机会在适当的环境中检查每种语言中结构体的细微差别。
- en: C#
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#
- en: In C#, a struct is defined as a value type that encapsulates small groups of
    related fields, which sounds very similar to the underlying C language implementation.
    However, C# structs are in fact quite different from those found in C, and they
    more closely resemble a regular class than a struct from that language. For instance,
    a C# struct can have methods, fields, properties, constants, indexers, operator
    methods, nested types, and events as well as defined constructors (but not default
    constructors, which are defined automatically). Structs can also implement one
    or more interfaces, all of which make the C# variety much more flexible than C.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，结构体被定义为封装相关字段的小组值的值类型，这听起来与底层C语言实现非常相似。然而，C#结构体实际上与C中的结构体有很大不同，它们更类似于那种语言的常规类。例如，C#结构体可以有方法、字段、属性、常量、索引器、运算符方法、嵌套类型和事件，以及定义的构造函数（但不包括默认构造函数，它是自动定义的）。结构体还可以实现一个或多个接口，所有这些都使得C#版本比C更加灵活。
- en: However, it would be a mistake to think of structs as lightweight classes. C#
    structs do not support inheritance, meaning they cannot inherit from classes or
    other structs, nor can they be used as a base for other structures or classes.
    Structure members cannot be declared as abstract, protected, or virtual. Unlike
    classes, structs can be instantiated without using the `new` keyword, although
    doing so prevents the resulting object from being used until every field has been
    assigned. Finally, and perhaps most importantly, structs are value types while
    classes are reference types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将结构体视为轻量级类是错误的。C#结构体不支持继承，这意味着它们不能从类或其他结构体继承，也不能用作其他结构或类的基类。结构体成员不能声明为抽象的、受保护的或虚拟的。与类不同，结构体可以在不使用`new`关键字的情况下实例化，尽管这样做会阻止结果对象在所有字段被分配之前被使用。最后，也许最重要的是，结构体是值类型，而类是引用类型。
- en: This final point cannot be overemphasized because it represents the key advantage
    to choosing a struct in place of a class. Structs are collections of values and,
    therefore, do not store references to objects such as arrays, for instance. Therefore,
    when you are passing a struct off to a method, it is passed by value rather than
    reference. Additionally, according to the MSDN documentation, being a value type
    means that structs do not require allocation to the heap memory and, therefore,
    do not carry the overhead that a class does in terms of memory and processing
    requirements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后一点不能过分强调，因为它代表了选择结构体而不是类的主要优势。结构体是值的集合，因此不存储诸如数组之类的对象的引用。因此，当你将结构体传递给方法时，它是按值传递而不是按引用传递。此外，根据MSDN文档，作为值类型，结构体不需要分配堆内存，因此不携带类在内存和处理需求方面的开销。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What does this mean and why is this beneficial? When you create a new class
    by using the new operator, the object that is returned will be allocated on the
    heap. When you instantiate a struct, on the other hand, it gets created directly
    on the stack and that nets a performance gain because the stack provides much
    faster memory access than the heap. As long as you don't overload the stack and
    cause a stack overflow, using structs strategically can be a great way to improve
    performance in your application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？为什么这有益？当你使用new运算符创建一个新的类时，返回的对象将在堆上分配。另一方面，当你实例化一个结构体时，它直接在堆栈上创建，这带来了性能提升，因为堆栈提供的内存访问速度比堆快得多。只要你不过度使用堆栈并导致堆栈溢出，有策略地使用结构体可以极大地提高你应用程序的性能。
- en: 'Now you might be saying to yourself, *Why do we even have classes if structs
    are so awesome?* For starters, the applications for structs in C# are very limited.
    According to Microsoft, you should only consider using a struct instead of a class
    if the instances of the type will be small and short-lived or they are typically
    embedded in other objects. Furthermore, you should not define a struct unless
    it meets at least three of the following criteria:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能自己在想，*如果结构体这么棒，我们为什么还要有类呢？* 首先，C#中结构体的应用非常有限。根据微软的说法，你应该只在类型的实例很小且生命周期短暂，或者它们通常嵌入在其他对象中时，才考虑使用结构体而不是类。此外，除非结构体至少满足以下三个标准之一，否则不应定义结构体：
- en: The struct will logically represent a single value similar to a primitive type
    such as an integer, double, and so on
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体将逻辑上表示一个类似于整数、双精度浮点数等原始类型的单个值
- en: Each instance of the struct will be smaller than 16 bytes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体的每个实例都将小于16字节
- en: The data in the struct will be immutable once it has been instantiated
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体中的数据一旦实例化后将是不可变的
- en: The struct will not need to be boxed and unboxed repeatedly
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体不需要反复装箱和拆箱
- en: 'Those are some pretty strict requirements! The outlook gets slightly worse
    when you consider what you can actually do with structs. Here''s a hint--not much.
    Let''s examine struct capabilities in comparison to a class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求相当严格！当你考虑你可以实际用结构体做什么时，前景会稍微变得糟糕一些。这里有一个提示--不多。让我们比较一下结构体和类的能力：
- en: You can set and access individual components--classes can do that too.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以设置和访问单个组件--类也可以这样做。
- en: You can pass structs to functions--yes, you can do that with a class.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将结构体传递给函数--是的，您也可以用类这样做。
- en: You can assign the contents of one struct to another using the assignment (`=`)
    operator--nothing special here.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用赋值运算符（`=`）将一个结构体的内容赋值给另一个结构体--这里没有特别之处。
- en: You can return a struct from a function, which actually creates a copy of the
    struct so now you have two on the stack. Classes? Check. However, classes are
    superior in this regard because, when a function returns an instance of a class,
    the object gets passed by reference so there is no need to create an additional
    copy.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从函数中返回一个结构体，这实际上会创建结构体的一个副本，因此现在堆栈上有两个。类？检查。然而，在这方面类更优越，因为当一个函数返回类的实例时，对象是通过引用传递的，因此不需要创建额外的副本。
- en: Structs *cannot* test for equality using the equality (`==`) operator, because
    structs may contain other bits of data. Classes can compare using the equality
    operator, however. In fact, if you want the same functionality in a struct you
    have to compare fields component, by component which is tedious.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体*不能*使用等号运算符（`==`）进行相等性测试，因为结构体可能包含其他数据。然而，类可以使用等号运算符进行比较。事实上，如果您想在结构体中实现相同的功能，您必须逐个字段比较，这是很繁琐的。
- en: 'If someone were to score this match-up, I think the result would look something
    like *structs: 4, classes: 5 (maybe 6)*. So obviously, classes are more flexible
    in terms of functionality and convenience, which is why higher-level languages
    with their roots in C typically provide mechanisms to implement these more complex
    objects.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人要对这场对决进行评分，我认为结果可能看起来像*结构体：4，类：5（也许6）*。所以很明显，在功能和便利性方面，类更加灵活，这就是为什么以C为基础的高级语言通常提供机制来实现这些更复杂对象的原因。
- en: That is not to say that structs do not have their value. Although their usefulness
    falls into very niche scenarios, there are times when a struct is the right tool
    for the job.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着结构体没有其价值。尽管它们的实用性局限于非常狭窄的场景，但在某些时候，结构体是完成这项工作的正确工具。
- en: Creating structs in C#
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在C#中创建结构体
- en: 'Creating a struct in C# is a fairly simple process. Our only two requirements
    are `using System` and declaring our object using the `struct` keyword. Here''s
    an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中创建结构体是一个相当简单的过程。我们只有两个要求：使用`using System`和用`struct`关键字声明我们的对象。以下是一个示例：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see from the preceding example, our struct is declared with a private
    backing field, a public accessor and one instance method named `WriteXToConsole()`,
    all perfectly legitimate characteristics of a struct in C#. Note the two instances
    of `MyStruct`. The first is instantiated using the `new` keyword, while the second
    is not. Again, both of these operations are perfectly valid in C#, although the
    latter requires you to populate all of the member properties before you can use
    the object in any way. If you were to change the `struct` keyword in our definition
    to class, the second initializer would not compile.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们的结构体使用私有后置字段、公共访问器和名为`WriteXToConsole()`的一个实例方法声明，这些都是C#中结构体的完全合法特性。注意`MyStruct`的两个实例。第一个使用`new`关键字实例化，而第二个没有。再次强调，这两个操作在C#中都是完全有效的，尽管后者要求你在以任何方式使用对象之前必须填充所有成员属性。如果你将定义中的`struct`关键字改为`class`，第二个初始化器将无法编译。
- en: 'Next, we''ll examine an example from [Chapter 3](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 3. Lists: Linear Collections"), *Lists: Linear Collections*. In that
    chapter''s case study, we built a data structure that stores a list of `Waypoint`
    objects. Here''s what the `Waypoint` class looks like in C#:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从[第3章](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "第3章。列表：线性集合")的例子中进行分析，*列表：线性集合*。在该章节的案例研究中，我们构建了一个存储`Waypoint`对象列表的数据结构。以下是C#中`Waypoint`类的样子：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, this class is pretty simple. It is so simple that it begs the
    question as to whether or not such a simple collection of values is worthy of
    the overhead and resources afforded to a class, especially when you consider that
    our list could contain hundreds of these `Waypoint` objects. Can we improve performance
    by converting the class to a struct without requiring significant refactoring
    to support this change? First, we need to determine whether it is recommended
    or even possible to do so, and we can make that decision by examining our struct
    criteria rules.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个类非常简单。简单到让人质疑这样一个简单的值集合是否值得分配给类所提供的开销和资源，尤其是当你考虑到我们的列表可能包含数百个这样的`Waypoint`对象时。我们能否通过将类转换为结构体来提高性能，而无需进行重大的重构以支持这种更改？首先，我们需要确定这样做是否推荐，甚至是否可行，我们可以通过检查我们的结构体准则规则来做出这个决定。
- en: 'Rule 1: The struct will logically represent a single value'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则1：结构体将逻辑上表示单个值
- en: In this case, our class has three fields, namely `lat`, `lon`, and `active`.
    Three is definitely not singular, but since the rule is that a struct must *logically
    represent* a single value, our plan to convert the class to a struct is still
    valid. This is because the `Waypoint` object represents a *single* location in
    2-dimensional space, and we require at least two values to represent a 2D coordinate,
    so there is no violation there. Also, the active property denotes a state of the
    waypoint, so this is characteristically acceptable as well. Before you cry foul
    on this interpretation, allow me to point out that even Microsoft plays fast and
    loose with this rule. For instance, `System.Drawing.Rectangle` is defined as a
    structure, and that type stores *four* integers representing both the size and
    location of a rectangle. Size and location are two properties of one object, and
    that is considered acceptable, so I believe `Waypoint` is fine here.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的类有三个字段，即`lat`、`lon`和`active`。三个显然不是单个，但根据规则，结构体必须逻辑上表示单个值，因此我们将类转换为结构体的计划仍然是有效的。这是因为`Waypoint`对象代表二维空间中的单个位置，而我们至少需要两个值来表示二维坐标，所以这里没有违反规则。此外，活动属性表示航点的状态，因此这也符合特征性可接受。在你对这种解释提出异议之前，让我指出，即使是微软也对此规则不太严格。例如，`System.Drawing.Rectangle`被定义为结构体，该类型存储表示矩形大小和位置的四个整数。大小和位置是单个对象的两个属性，这被认为是可接受的，所以我相信`Waypoint`在这里是合适的。
- en: 'Rule 2: Each instance of the struct must be under 16 bytes'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则2：结构体的每个实例必须小于16字节
- en: 'Our `Waypoint` class is easily within the margin of safety for this rule. Referring
    to [Chapter 1](part0015_split_000.html#E9OE2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 1. Data Types: Foundational Structures"), *Data Types: Foundational Structures*,
    the `Int32` structures are 4 bytes in length and Boolean primitives are only 1
    byte in length. This means that a single instance of `Waypoint` will weigh in
    at a grand total of only nine bytes, leaving us seven bytes to spare.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Waypoint`类很容易符合这一安全规则。参考[第1章](part0015_split_000.html#E9OE2-77f2b5b248f04368a6f723b0e9357ef3
    "第1章。数据类型：基础结构")，*数据类型：基础结构*，`Int32`结构体长度为4字节，布尔原始类型长度仅为1字节。这意味着单个`Waypoint`实例的总重量仅为九字节，我们还有七个字节的空间。
- en: 'Rule 3: The data must be immutable'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则3：数据必须是不可变的
- en: The reason that structs should, ideally, be immutable has to do with their status
    as value types. As mentioned previously, whenever a value type is passed around,
    you end up with a copy of that value rather than a reference to the original value
    itself. This means that when you change a value within the struct, you are only
    changing that struct and none of the others that happen to be hanging around in
    the stack.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体应该理想上是不可变的，这与它们作为值类型的状态有关。如前所述，每当传递一个值类型时，你最终得到的是该值的副本，而不是原始值的引用。这意味着当你更改结构体内的值时，你只是在更改该结构体，而不会影响到堆栈中可能存在的其他任何结构体。
- en: This requirement may represent a problem for us and it is not a trivial one.
    In our application, we have chosen to store the active state of the `Waypoint`
    value on the object itself, and this field is definitely not immutable. We could
    move the property out of the `Waypoint` class somehow, but doing so would require
    much more refactoring than if we simply left it alone. Since we want to avoid
    a significant refactor for the time being, we will leave the field alone and count
    this rule as a strike against our plan. Our only recourse is to examine our usage
    of the `Waypoint` objects in our code to ensure that we never create a situation
    where an instance of `Waypoint` is passed in such a way that we lose focus on
    the correct instance. Technically speaking, so long as `Waypoint` passes the next
    requirement, we are still in business.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求可能对我们来说是一个问题，而且不是一个小问题。在我们的应用程序中，我们选择在对象本身上存储`Waypoint`值的活跃状态，而这个字段肯定不是不可变的。我们可以以某种方式将属性移出`Waypoint`类，但这样做需要比如果我们简单地让它保持原样进行更多的重构。由于我们目前想要避免重大的重构，我们将保持该字段不变，并将此规则视为对我们计划的打击。我们唯一的补救办法是检查我们代码中对`Waypoint`对象的使用，以确保我们永远不会创建一个`Waypoint`实例以这种方式传递，以至于我们失去了对正确实例的关注。从技术上来说，只要`Waypoint`通过下一个要求，我们仍然在业务中。
- en: 'Rule 4: The struct will not require repeated boxing'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则4：结构体不需要重复装箱
- en: Since the `Waypoint` object is used as-is once it has been instantiated, each
    instance will rarely, if ever, be boxed or unboxed. Therefore, our class passes
    this test and qualifies for conversion to a struct.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Waypoint`对象一旦实例化后就是直接使用的，因此每个实例很少，如果不是从未，会被装箱或解箱。因此，我们的类通过了这个测试，并符合转换为结构体的条件。
- en: Conversion
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换
- en: 'The next question is, *Can the Waypoint class be converted to a struct?* There
    are three points of concern in our class that may need to be addressed. First,
    we have that mutable `active` field to deal with. In its current form, this field
    is not very struct-like since it really should be immutable. Since we really have
    no recourse at this stage, we will have to deal with it in another manner. Predominantly,
    this means we will need to very strictly monitor our usage of `Waypoint` objects
    to ensure that we are not working on copies of a struct when we believe we are
    working with the original struct. Although this may become tedious, it is not
    unreasonable. Our next concern is the defined constructor, but since this is not
    without a parameter or a default constructor, everything is fine here and we can
    move on. Finally, our class has two public methods named `DeactivateWaypoint()`
    and `ReactivateWaypoint()`. Since C# also allows for public methods in a struct,
    these two are fine where they are as well. In fact, the only thing we really need
    to do to convert this class to a struct is to change the `class` keyword to a
    `struct` keyword! Here''s our resulting code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是，*能否将Waypoint类转换为结构体？* 在我们的类中有三个需要注意的点可能需要解决。首先，我们有一个可变的`active`字段需要处理。在其当前形式下，这个字段并不太像结构体，因为它实际上应该是不可变的。由于在这个阶段我们真的没有其他办法，我们不得不以另一种方式处理它。主要来说，这意味着我们需要非常严格地监控我们对`Waypoint`对象的使用，以确保当我们认为我们在处理原始结构体时，我们实际上并没有在处理结构体的副本。尽管这可能会变得繁琐，但这并不不合理。我们的下一个关注点是定义的构造函数，但由于这不是没有参数或默认构造函数，所以这里一切正常，我们可以继续前进。最后，我们的类有两个名为`DeactivateWaypoint()`和`ReactivateWaypoint()`的公共方法。由于C#也允许在结构体中使用公共方法，这两个方法在这里也是可以的。事实上，我们真正需要做的，将这个类转换为结构体，就是将`class`关键字改为`struct`关键字！以下是我们的结果代码：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Lastly, we need to know if this change will represent any improvement in our
    app as a whole. Without extensive testing and analysis of the app at runtime,
    it is impossible to say for sure, but odds are this modification will net a positive
    impact on the overall performance of our off-road biking application without introducing
    any further refactoring requirements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要知道这个更改是否会在整体上代表我们应用的任何改进。没有对应用在运行时的广泛测试和分析，我们无法确定地说，但可能性很大，这个修改将对我们越野骑行应用的整体性能产生积极影响，而不会引入任何进一步的重构需求。
- en: Java
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java
- en: This is going to be a short discussion, since Java does not support structs.
    Apparently, the authors of Java decided that, when the language finally crawled
    out of the C programming swamp, it would not be lugging around these non-object-oriented
    structures. Therefore, our only recourse in Java is to create a class with public
    properties that will mimic the behavior of a struct, but without any of the performance
    benefits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个简短的讨论，因为Java不支持结构体。显然，Java的作者们决定，当这种语言最终从C编程的泥潭中爬出来时，它不会带着这些非面向对象的结构体四处奔波。因此，在Java中我们唯一的办法是创建一个具有公共属性的类来模拟结构体的行为，但没有任何性能上的优势。
- en: Objective-C
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Objective-C
- en: Objective-C does not support structs directly; however, you can implement and
    use simple C structs in your code. C structs are similar to their C# counterpart,
    in that they allow you to frame several primitive values into a single more complex
    value type. However, C structs do not permit the addition of methods or initializers
    nor any other cool object-oriented programming features that C# structs enjoy.
    Additionally, C structs cannot contain any objects that inherit from `NSObject`,
    as these are classes and not value types.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C不支持直接使用结构体；然而，你可以在代码中实现和使用简单的C结构体。C结构体与它们的C#对应物类似，因为它们允许你将几个原始值组合成一个更复杂的值类型。但是，C结构体不允许添加方法或初始化器，也不允许C#结构体所享有的任何其他酷炫的面向对象编程特性。此外，C结构体不能包含从`NSObject`继承的对象，因为这些是类而不是值类型。
- en: That being said, structs are actually found very frequently in Objective-C applications.
    One of the most common applications for structs is in the definition of **enumerations**,
    or **enums**. Enums are lists of constants representing integer values whose purpose
    is to create higher levels of abstraction in your code so that developers can
    focus on what the values symbolize without worrying about how they are implemented
    in the background. We will examine enums in more detail later in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在Objective-C应用程序中，结构体实际上是非常常见的。结构体最常见的一个应用是在**枚举**或**枚举类型**的定义中。枚举是一系列表示整数值的常量列表，其目的是在代码中创建更高层次的抽象，这样开发者就可以专注于值的含义，而不必担心它们在后台的实现方式。我们将在本章后面更详细地探讨枚举。
- en: Creating structs in Objective-C
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Objective-C中创建结构体
- en: 'Another common source of structs in Objective-C can be found in the **Core
    Graphics framework**, which contains four useful structures. We''ll examine these
    structures in detail in order to demonstrate how structures are defined in Objective-C:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中结构体的另一个常见来源可以在**Core Graphics框架**中找到，该框架包含四个有用的结构体。我们将详细研究这些结构体，以展示如何在Objective-C中定义结构体：
- en: '`CGPoint`: This structure contains a simple two-point coordinate system consisting
    of two `CGFloat` values. Here''s what the `CGPoint` struct definition looks like:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGPoint`：这个结构体包含一个简单的二维坐标系，由两个`CGFloat`值组成。下面是`CGPoint`结构体的定义：'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`CGSize`: This structure is simply a container for a width and height, consisting
    of two `CGFloat` values. Here''s what the `CGSize` struct definition looks like:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGSize`：这个结构体只是一个宽度和高度的容器，由两个`CGFloat`值组成。下面是`CGSize`结构体的定义：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`CGRect`: This is a structure that defines both the location and size of a
    rectangle, consisting of one `CGPoint` value and one `CGSize` value. Here''s what
    the `CGRect` struct definition looks like:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGRect`：这是一个定义矩形位置和大小的结构体，由一个`CGPoint`值和一个`CGSize`值组成。下面是`CGRect`结构体的定义：'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`CGVector`: This is a structure that simply contains a 2-dimensional vector,
    consisting of two `CGFloat` values. Here''s what the `CGVector` struct definition
    looks like:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGVector`：这是一个仅包含二维向量的结构体，由两个`CGFloat`值组成。下面是`CGVector`结构体的定义：'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You should note the `typedef` and `struct` keywords following each of these
    struct definitions. This line is included for our convenience as programmers.
    Whenever we need to call on these structs, if the struct were not decorated with
    the `typedef` keyword, we would always need to precede calls to our struct with
    the `struct` keyword, like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意在每个结构体定义之后跟随的`typedef`和`struct`关键字。这一行是为了我们程序员的方便而包含的。无论何时我们需要调用这些结构体，如果结构体没有用`typedef`关键字装饰，我们都需要在调用结构体之前始终加上`struct`关键字，如下所示：
- en: '`struct CGRect rect;`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct CGRect rect;`'
- en: 'Obviously, this would rapidly get tiresome. By applying a `typedef` to the
    struct name, we allow our callers to simply apply the struct name without the
    `struct` keyword, like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这会很快变得令人厌烦。通过将`typedef`应用于结构体名称，我们允许调用者简单地使用结构体名称，而不需要`struct`关键字，如下所示：
- en: '`  CGRect rect;`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`  struct CGRect rect;`'
- en: This makes our code easier to write, but also makes it more concise and more
    readable in the long run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的代码更容易编写，但同时也使得代码在长期来看更加简洁和易于阅读。
- en: 'Now we will take a look at the `EDSWaypoint` class from [Chapter 3](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 3. Lists: Linear Collections"), *Lists: Linear Collections*, and determine
    whether we can convert that class to a C struct. Here''s the original code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看[第3章](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "第3章。列表：线性集合"，*列表：线性集合*)中的`EDSWaypoint`类，并确定我们是否可以将该类转换为C结构体。以下是原始代码：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Right away in the interface, we see a few problems with converting this class
    to a struct. Both the `_lat` and `_lon` ivars are `NSInteger` classes, which means
    they are invalid for use inside a struct and they will have to go or be changed
    to a value type. How about the `initWithLatitude:andLongitude:` initializer? Nope,
    you cannot define initializers in C structs either. So, now we need to deal with
    the `reactivateWaypoint` and `deactivateWaypoint` methods. Surely these simple
    properties and methods can pass muster for acceptance into a struct? No, they
    cannot. Everything here needs to go.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻在接口中，我们就看到了将这个类转换为结构体的一些问题。`_lat` 和 `_lon` ivars 都是 `NSInteger` 类，这意味着它们在结构体中使用是无效的，它们必须被移除或改为值类型。那么
    `initWithLatitude:andLongitude:` 初始化器呢？不行，你也不能在 C 结构体中定义初始化器。所以，现在我们需要处理 `reactivateWaypoint`
    和 `deactivateWaypoint` 方法。当然，这些简单的属性和方法肯定可以通过接受进入结构体的考验？不，它们不能。这里的一切都需要被移除。
- en: 'Therefore, the only real question that remains is what should we do with the
    `_active` value and the associated `-(BOOL)active` property. As it turns out,
    the `BOOL` type is perfectly acceptable to use within a structure, so we can actually
    leave the property where it is. However, `_active` does represent a mutable property
    within the `EDSWaypoint` struct and that is frowned upon, right? It may be frowned
    upon, but structs are not immutable in C. Here''s an example using the Core Graphics
    struct, `CGPoint`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，唯一剩下的问题就是我们应该如何处理 `_active` 值和相关的 `-(BOOL)active` 属性。实际上，`BOOL` 类型在结构体中使用是完全可以接受的，所以我们可以实际上保留这个属性。然而，`_active`
    在 `EDSWaypoint` 结构体中确实代表了一个可变属性，这是不被提倡的，对吧？虽然不被提倡，但在 C 中结构体并不是不可变的。以下是一个使用 Core
    Graphics 结构体 `CGPoint` 的例子：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you were to duplicate this code in your app, the compiler would not issue
    an error or even a warning because `CGPoint` is not immutable and the properties
    are not read only. Therefore, we can leave the `_active` value in our final struct
    definition. Unfortunately, the same cannot be said for the `-(BOOL)active` property?
    Property accessors such as this are forbidden in C structs so this needs to be
    removed, and that represents a significant change to how our application handles
    the active state of our `Waypoint` objects. So if we want to convert this class
    to a structure, we will be left with the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此代码复制到你的应用程序中，编译器不会发出错误或警告，因为 `CGPoint` 不是不可变的，属性也不是只读的。因此，我们可以在最终的 struct
    定义中保留 `_active` 值。不幸的是，对于 `-(BOOL)active` 属性来说，情况并非如此？像这样的属性访问器在 C 结构体中是禁止的，所以这个属性需要被移除，这代表了对我们应用程序处理
    `Waypoint` 对象活动状态方式的重大改变。因此，如果我们想将这个类转换为结构体，我们将得到以下内容：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Strictly speaking, the `typedef` declaration is not required but it's bad enough
    that we will have to refactor our entire `EDSWaypointList` class to support these
    changes. Let's not add insult to injury by making our poor developers type eight
    extra characters every time they want to access one of these types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`typedef` 声明不是必需的，但我们必须重构整个 `EDSWaypointList` 类以支持这些更改已经足够糟糕了。我们不应该再让我们的开发者每次想要访问这些类型之一时都要多输入八个额外的字符。
- en: Swift
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift
- en: 'As in other languages, structs in Swift are value types that encapsulate small
    groups of related properties. Similar to structs in C#, Swift structs resemble
    a regular class more than a C struct and share all of the following abilities
    with classes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在其他语言中一样，Swift 中的结构体是值类型，它们封装了一组相关的属性。与 C# 中的结构体类似，Swift 结构体比 C 结构体更像是一个常规类，并且与类共享以下所有能力：
- en: Ability to define properties to store values
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够定义属性以存储值
- en: Ability to contain methods that define extended functionality
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够包含定义扩展功能的方法
- en: Ability to define subscripts to provide access to values using subscript notation
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够定义下标以使用下标符号访问值
- en: Ability to define custom initializers
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够定义自定义初始化器
- en: Swift structs can be extended to provide additional functionality beyond their
    initialized state
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 结构体可以被扩展以提供超出其初始化状态的额外功能
- en: Finally, Swift structs can be defined to conform to protocols that provide customary
    functionality
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，Swift 结构体可以被定义为符合提供常规功能的协议
- en: Note, however, that Swift structs do not support inheritance, meaning that they
    cannot inherit from classes or other structs, nor can they be used as a base for
    other structures or classes. Also, they do not support type casting to enable
    the compiler to check and interpret the type of an instance at runtime. These
    structs cannot be explicitly deinitialized like classes to free up their resources,
    nor do structs support automatic reference counting for memory management. These
    last two points are related to the fact that structs in Swift, as in other languages,
    are value types and not classes or reference types.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，Swift 的结构体不支持继承，这意味着它们不能从类或其他结构体继承，也不能作为其他结构体或类的基类。此外，它们不支持类型转换，以使编译器能够在运行时检查和解释实例的类型。这些结构体不能像类那样显式地被销毁以释放其资源，结构体也不支持自动引用计数进行内存管理。最后两点与
    Swift 中的结构体（与其他语言一样）是值类型而不是类或引用类型的事实相关。
- en: This final point in relation to Swift bears repeating. Structs are collections
    of values and, therefore, do not store references to objects like other collections
    such as arrays or dictionaries, for instance. Therefore, when you are passing
    a struct as a parameter to or from a method, it is passed by value and not by
    reference.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Swift 的这一点需要再次强调。结构体是值的集合，因此它们不会像数组或字典等其他集合那样存储对象的引用。因此，当你将结构体作为参数传递给或从方法中返回时，它是按值传递而不是按引用传递。
- en: 'So when should you choose to use a struct over a class in Swift? Apple''s documentation
    provides some general rules of thumb to help you make the decision. You should
    use struct when:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在 Swift 中何时应该选择使用结构体而不是类呢？Apple 的文档提供了一些一般性规则，以帮助你做出决定。你应该在以下情况下使用结构体：
- en: Your object's primary purpose is to gather a few simple data values
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的对象的主要目的是收集一些简单的数据值
- en: You anticipate that the object you create will be copied rather than referenced
    when you assign or send an instance of that object
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你预计你创建的对象在分配或发送该对象的实例时将被复制而不是被引用
- en: Any properties in your object are value types, not classes, and you also expect
    that their values will be copied rather than referenced
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对象中的任何属性都是值类型，而不是类，你也期望它们的值会被复制而不是被引用
- en: Your object has no need to inherit properties or behavior from an existing object
    or type
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的对象没有必要从现有对象或类型继承属性或行为
- en: You will notice that this list is not quite as restrictive as the same list
    in C#, but it does represent an excellent common-sense approach to deciding whether
    or not the value added from using a struct outweighs the limited functionality
    in your object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，这个列表并不像 C# 中的相同列表那样严格，但它确实代表了一种很好的常识方法，用于决定使用结构体带来的价值是否超过了对象中有限的功能。
- en: Creating structs in Swift
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Swift 中创建结构体
- en: 'If you have worked with Swift for more than five minutes, odds are you have
    already worked with some of the built-in structs such as `Int`, `String`, `Array`,
    `Dictionary`, and many others that are defined in the Swift framework. Here''s
    a quick demonstration on how to define your own struct using Swift:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Swift 超过五分钟，那么你很可能已经使用过一些内置的结构体，例如 `Int`、`String`、`Array`、`Dictionary`
    以及 Swift 框架中定义的许多其他结构体。以下是一个使用 Swift 定义你自己的结构体的快速演示：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding example defines a new structure called `MyColor`, which describes
    an RGBA-based color definition. This structure has four properties called `red`,
    `green`, `blue`, and `alpha`. Although these properties have all been defined
    as mutable variables using `var`, stored properties in Swift can also be defined
    as immutable using `let`. The first three properties in our struct are inferred
    to be the `Int` types by setting their default values to `0`, while the remaining
    property is inferred to be `Double` type by setting its default value to `0.0`.
    Since we have not defined any custom initializers for our method yet, we could
    initialize an instance of this object as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了一个名为 `MyColor` 的新结构体，它描述了一个基于 RGBA 的颜色定义。这个结构体有四个属性，分别称为 `red`、`green`、`blue`
    和 `alpha`。尽管这些属性都已被定义为可变变量使用 `var`，但 Swift 中的存储属性也可以使用 `let` 定义为不可变。我们结构体中的前三个属性通过将其默认值设置为
    `0` 被推断为 `Int` 类型，而剩余的属性通过将其默认值设置为 `0.0` 被推断为 `Double` 类型。由于我们尚未为我们的方法定义任何自定义初始化器，我们可以如下初始化这个对象的实例：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code initializes our struct and sets the values to represent
    something similar to dark magenta with a 50% alpha. This demonstration is fine,
    but the initialization is somewhat verbose for many developers'' taste. What if
    we want to create a new object in one line? In that case, we need to modify our
    struct to include a custom initializer, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码初始化了我们的结构体，并将值设置为类似于50%透明度的深洋红色。这个演示是好的，但初始化对于许多开发者的口味来说有点冗长。如果我们想在一行中创建一个新对象怎么办？在这种情况下，我们需要修改我们的结构体以包含一个自定义初始化器，如下所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Taking advantage of Swift allowing structs to define custom initializers, we
    have created an `init` method that accepts RGBA values and assigns them to the
    properties of our object, greatly simplifying our object creation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Swift 允许结构体定义自定义初始化器的优势，我们创建了一个接受 RGBA 值并将它们分配给对象属性的 `init` 方法，极大地简化了对象创建。
- en: 'Now we will take a look at the `Waypoint` class from [Chapter 3](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 3. Lists: Linear Collections"), *Lists: Linear Collections*, and determine
    whether we can convert that class to a structure. Here''s the original code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看 [第3章](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "第3章。列表：线性集合"，*列表：线性集合*) 中的 `Waypoint` 类，并确定我们是否可以将该类转换为结构体。以下是原始代码：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now this is an interesting class object. We will tackle the elephant in the
    room first: the `Equatable` interface and the public function named `==` declared
    *outside* the class structure. Our class is required to implement the `Equatable`
    interface because several of the methods in `WaypointList` compare two `Waypoint`
    objects for equality. Without the interface and the associated `==` method implementation,
    this would not be possible and our code would not compile. Luckily, Swift structs
    are permitted to implement interfaces such as `Equatable`, so this really is not
    an issue and we can move on.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个有趣的类对象。我们首先解决房间里的大象：`Equatable` 接口和名为 `==` 的公共函数被声明在类结构**外部**。我们的类必须实现
    `Equatable` 接口，因为 `WaypointList` 中的几个方法需要比较两个 `Waypoint` 对象的相等性。没有这个接口和相关的 `==`
    方法实现，这是不可能的，我们的代码也无法编译。幸运的是，Swift 结构体可以实施接口，如 `Equatable`，所以这根本不是问题，我们可以继续前进。
- en: 'We have already discussed and demonstrated that Swift structs can define custom
    initializers, so our public `init` method is fine as it is. The `Waypoint` class
    also has two methods called `DeactivateWaypoint()` and `ActivateWaypoint()`. Since
    structs are intended to be immutable, the final change we need for our class to
    become a struct is the addition of the `mutating` keyword to each of these methods
    to denote that each one modifies, or mutates, one or more of the values in the
    instance. Here''s the final version of our `Waypoint` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论并演示了 Swift 结构体可以定义自定义初始化器，所以我们的公共 `init` 方法就很好。`Waypoint` 类还有两个名为 `DeactivateWaypoint()`
    和 `ActivateWaypoint()` 的方法。由于结构体旨在不可变，我们需要对类进行最后的更改，以将 `mutating` 关键字添加到每个方法中，以表示每个方法修改或突变实例中的一个或多个值。以下是我们的
    `Waypoint` 类的最终版本：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The addition of the `mutating` keyword to our instance methods will allow us
    to redefine `Waypoint` as a struct, but it will also introduce a new limitation
    to our implementation. Consider the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `mutating` 关键字添加到我们的实例方法中，将允许我们将 `Waypoint` 重新定义为结构体，但它也会给我们的实现引入一个新的限制。考虑以下示例：
- en: '`let point = Waypoint(latitude: 5, longitude: 10)`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`let point = Waypoint(latitude: 5, longitude: 10)`'
- en: '`point.DeactivateWaypoint()`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`point.DeactivateWaypoint()`'
- en: This code will fail to compile with the error `Immutable value of type 'Waypoint'
    has only mutating members named DeactivateWaypoint`. Wait. What now? By including
    the `mutating` keyword, we are also explicitly declaring that this struct is a
    mutable type. It's fine to declare this type as immutable, unless you try to call
    one of the mutating methods at which point the code will fail to compile. Whereas
    before this change we could declare any instance of `Waypoint` as either mutable
    using `var` or immutable using `let`, as we saw fit, we are now restricted to
    only declaring mutable instances of this object if we intend to utilize the `mutating`
    methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将无法编译，并出现错误 `不可变的类型 'Waypoint' 只包含名为 DeactivateWaypoint 的 mutating 成员`。等等。现在怎么办？通过包含
    `mutating` 关键字，我们也是明确地声明这个结构体是可变的类型。声明这个类型为不可变是可以的，除非你尝试调用其中一个 mutating 方法，这时代码将无法编译。在此之前，我们可以根据需要将
    `Waypoint` 的任何实例声明为可变的 `var` 或不可变的 `let`，但现在，如果我们打算使用 `mutating` 方法，我们只能将这个对象声明为可变的实例。
- en: Enums
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: As discussed earlier, enums increase the level of abstraction in your application
    and allow the developer to focus on the meaning of the values rather than being
    concerned with how the values are stored in memory. This is because an `enum` type
    allows you to label specific integer numeric values with meaningful or easy to
    remember names.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，枚举增加了应用程序的抽象级别，并允许开发者关注值的含义，而不是担心值在内存中的存储方式。这是因为`enum`类型允许你用有意义的或易于记忆的名称标记特定的整数数值。
- en: 'Case study: the Metro line'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：地铁线路
- en: '**Business problem**: You work with an engineering team tasked with writing
    an application that keeps track of commuter trains along the Metro. One of the
    key business requirements is the ability to easily identify which station a train
    is currently located at or en route to. Each train station has a unique name,
    but the database tracks the stations by their ID values, such as 1100, 1200, 1300,
    and so on. Rather than track stations by name, which is both tedious and prone
    to change over time, your app will utilize the station IDs. However, the reason
    stations are labeled with names instead of IDs in the first place is to make it
    easier for commuters to identify them. This is also true for programmers, who
    would have a difficult time keeping the IDs of dozens or perhaps hundreds of stations
    in mind while writing code.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**商业问题**：你与一个负责编写应用程序以跟踪地铁通勤列车团队的工程师合作。其中一个关键的业务需求是能够轻松识别列车当前位于哪个车站或正在前往哪个车站。每个车站都有一个独特的名称，但数据库通过其ID值（如1100、1200、1300等）跟踪车站。而不是通过名称跟踪车站，因为名称既繁琐又容易随时间变化，你的应用程序将利用车站ID。然而，最初用名称而不是ID标记车站的原因是为了使通勤者更容易识别它们。这也适用于程序员，他们在编写代码时很难记住几十个甚至几百个车站的ID。'
- en: You decide to utilize the enum data structure to meet the needs of both your
    application and your developers. Your enum will provide a map between easy-to-remember
    station names and the station IDs they are associated with, so your application
    can utilize the IDs based on the station names while your programmers will use
    the names.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你决定利用枚举数据结构来满足你的应用程序和开发者的需求。你的枚举将提供易于记忆的车站名称与它们关联的车站ID之间的映射，因此你的应用程序可以根据车站名称利用ID，而你的程序员将使用名称。
- en: '**C#**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'To avoid confusion where multiple train lines overlap at larger stations, we
    do not simply want to create an enum with all of the stations in the entire Metro
    line. Instead, we will create enums based on each line in the Metro. Here''s the
    Silver Line defined as a C# enum:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在大型车站多个列车线路重叠时产生混淆，我们不想简单地创建一个包含整个地铁线路所有车站的枚举。相反，我们将根据地铁的每条线路创建枚举。以下是一个定义为C#枚举的Silver
    Line：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, wherever we want to use a value from the `SilverLine` enum, we simply
    need to declare a value type by the same name and assign a value, such as the
    following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论我们想在何处使用`SilverLine`枚举的值，我们只需声明一个同名的值类型并分配一个值，如下所示：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the example we just saw, our code initializes a `SilverLine` value to show
    the Silver Line's next stop as station `4100`, using `SilverLine.Federal_Triangle`.
    Once the doors close on the platform, we need to update this value to show our
    train is moving to station `4200`, so we update the value to `SilverLine.Smithsonian`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚才看到的示例中，我们的代码初始化一个`SilverLine`值，以显示Silver Line的下一站为车站`4100`，使用`SilverLine.Federal_Triangle`。一旦车门在站台关闭，我们需要更新这个值以显示我们的列车正在前往车站`4200`，因此我们将值更新为`SilverLine.Smithsonian`。
- en: '**Java**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Although Java does not permit us to define structs explicitly, we can define
    enums. However, the definition may not appear as you expect:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java不允许我们显式地定义结构体，但我们可以定义枚举。然而，定义可能不会像你预期的那样：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You may notice that we have not explicitly assigned integer values to each of
    these entries. This is because Java will not allow us to do so. Remember that
    Java does not support structs, so enums in this language are not really primitives
    at all but rather objects of their own type. Therefore, they do not play by the
    same rules as enums in other languages, and some argue that Java enums are more
    robust because of it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们没有明确地为这些条目中的每一个分配整数值。这是因为Java不允许我们这样做。记住，Java不支持结构体，所以在这个语言中的枚举实际上不是原语，而是它们自己类型的对象。因此，它们不遵循其他语言中枚举的规则，有些人认为Java枚举因此更加健壮。
- en: Unfortunately for our planned use of this structure, this limitation will be
    a small hurdle because we cannot map the station names directly to their associated
    ID value. One option here would be to add a `public static` method, which will
    operate on the string value of `this`, and use that value to map the string to
    an integer value behind the scenes. This may be a somewhat verbose solution, but
    when you consider the fact that this is even possible, it opens a whole new world
    of alternative solutions to the overall business problem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们计划使用此结构的情况，这个限制将是一个小障碍，因为我们不能直接将站点名称映射到它们关联的ID值。这里的一个选择是添加一个`public static`方法，它将操作`this`的字符串值，并使用该值在幕后将字符串映射到整数值。这可能是一个相当冗长的解决方案，但当你考虑到这是可能的这一事实时，它为解决整体业务问题开辟了一个全新的解决方案世界。
- en: '**Objective-C**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Just as Objective-C does not support structures, it also does not directly
    support enums. Luckily, we can use the underlying C language enum in this case
    as well. Here''s how:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Objective-C不支持结构体一样，它也不直接支持枚举。幸运的是，在这种情况下，我们也可以使用底层的C语言枚举。下面是如何做的：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, note that we have integrated the `typedef` keyword into this definition,
    which means that we will not need to add the declaration of the `SilverLine` enum
    as an object on a separate line in our code. Also note the `enum` keyword, which
    is required to declare an enum in C. Note that we are explicitly declaring that
    this enum is of value type `NSUInteger`. We are using `NSUInteger` here because
    we do not want to support signed values, but if we did, then we could just as
    easily have chosen `NSInteger` for this purpose. Finally, note that the actual
    name of the `enum` variable comes after the definition.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，我们已经将`typedef`关键字集成到这个定义中，这意味着我们不需要在我们的代码中单独一行添加`SilverLine`枚举对象的声明。还要注意`enum`关键字，它是C中声明枚举所必需的。请注意，我们明确声明这个枚举是`NSUInteger`类型的值。我们在这里使用`NSUInteger`是因为我们不希望支持有符号值，但如果我们这样做，我们同样可以轻松地选择`NSInteger`来达到这个目的。最后，请注意，`enum`变量的实际名称在定义之后。
- en: Otherwise, our enum definition is similar to that of most other C-based languages,
    with just a couple of caveats. First, enums must be declared in a header (`*.h`)
    file if you intend to use it *outside* the scope of the current file. In either
    case, the enum must also be declared them *outside* the `@interface` or `@implementation`
    tags or your code will not compile. Finally, the name of your enum must be unique
    among all other objects within the workspace.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们的枚举定义与其他大多数基于C的语言的枚举定义相似，只是有几个注意事项。首先，如果你打算在当前文件的作用域之外使用枚举，则必须在头文件（`*.h`）中声明枚举。在任何情况下，枚举也必须在`@interface`或`@implementation`标签之外声明，否则你的代码将无法编译。最后，你的枚举名称必须在工作区内的所有其他对象中是唯一的。
- en: '**Swift**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Structs in Swift have more in common with those of C# than those of Objective-C
    due to their wide flexibility. In our example here, we will not add any additional
    methods or `init` functions, but we could if we needed to:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的结构体与C#的结构体比Objective-C的结构体有更多的共同之处，这得益于它们的广泛灵活性。在我们的示例中，我们不会添加任何额外的方法或`init`函数，但如果我们需要，我们可以这样做：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the inclusion of the `Int` declaration in our definition. This is not strictly
    required in most cases, unless we intend to explicitly set values for our entries
    as we have done here. This lets the compiler know in advance what types to expect
    for the purpose of type checking. If we had chosen to leave out the explicit values,
    we could have optionally left off the `Int` declaration as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的定义中包含了`Int`声明。在大多数情况下，这并不是严格必要的，除非我们打算像我们在这里所做的那样明确地为条目设置值。这可以让编译器提前知道预期的类型，以便进行类型检查。如果我们选择省略显式值，我们也可以选择省略`Int`声明。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the basic definition of the struct data structure,
    as well as how to create structs in applicable languages. We also examined some
    common applications of structs including the very common enum data type. Finally,
    we looked at some previous code examples to check whether we could improve on
    them using struct objects instead of custom classes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了结构体数据结构的基本定义，以及如何在适用语言中创建结构体。我们还考察了一些结构体的常见应用，包括非常常见的枚举数据类型。最后，我们查看了一些之前的代码示例，以检查我们是否可以使用结构体对象而不是自定义类来改进它们。
