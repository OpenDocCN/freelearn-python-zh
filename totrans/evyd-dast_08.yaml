- en: 'Chapter 8. Structs: Complex Types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **struct** is a collection of data variables or values that are grouped together
    under a single memory block, whereas a data structure is typically some sort of
    collection of objects that are related to one another in some way. Therefore,
    a struct, also known as a structure, is less of a data structure and more of a
    complex data type. This definition sounds pretty simple, but appearances are deceiving
    in this case. The topic of structs is a complex one, and each of the languages
    we are examining has unique qualities in how structs are supported, if they are
    supported at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of the struct data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common applications of structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of structs in each language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to varying support from language to language, we're will take a different
    approach in this chapter. Instead of examining structs as a whole and then examining
    a case study, we will examine structs and case studies simultaneously for each
    language. This will give us the opportunity to examine the nuances of structs
    in each language within the proper context.
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, a struct is defined as a value type that encapsulates small groups of
    related fields, which sounds very similar to the underlying C language implementation.
    However, C# structs are in fact quite different from those found in C, and they
    more closely resemble a regular class than a struct from that language. For instance,
    a C# struct can have methods, fields, properties, constants, indexers, operator
    methods, nested types, and events as well as defined constructors (but not default
    constructors, which are defined automatically). Structs can also implement one
    or more interfaces, all of which make the C# variety much more flexible than C.
  prefs: []
  type: TYPE_NORMAL
- en: However, it would be a mistake to think of structs as lightweight classes. C#
    structs do not support inheritance, meaning they cannot inherit from classes or
    other structs, nor can they be used as a base for other structures or classes.
    Structure members cannot be declared as abstract, protected, or virtual. Unlike
    classes, structs can be instantiated without using the `new` keyword, although
    doing so prevents the resulting object from being used until every field has been
    assigned. Finally, and perhaps most importantly, structs are value types while
    classes are reference types.
  prefs: []
  type: TYPE_NORMAL
- en: This final point cannot be overemphasized because it represents the key advantage
    to choosing a struct in place of a class. Structs are collections of values and,
    therefore, do not store references to objects such as arrays, for instance. Therefore,
    when you are passing a struct off to a method, it is passed by value rather than
    reference. Additionally, according to the MSDN documentation, being a value type
    means that structs do not require allocation to the heap memory and, therefore,
    do not carry the overhead that a class does in terms of memory and processing
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does this mean and why is this beneficial? When you create a new class
    by using the new operator, the object that is returned will be allocated on the
    heap. When you instantiate a struct, on the other hand, it gets created directly
    on the stack and that nets a performance gain because the stack provides much
    faster memory access than the heap. As long as you don't overload the stack and
    cause a stack overflow, using structs strategically can be a great way to improve
    performance in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you might be saying to yourself, *Why do we even have classes if structs
    are so awesome?* For starters, the applications for structs in C# are very limited.
    According to Microsoft, you should only consider using a struct instead of a class
    if the instances of the type will be small and short-lived or they are typically
    embedded in other objects. Furthermore, you should not define a struct unless
    it meets at least three of the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: The struct will logically represent a single value similar to a primitive type
    such as an integer, double, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each instance of the struct will be smaller than 16 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data in the struct will be immutable once it has been instantiated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The struct will not need to be boxed and unboxed repeatedly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those are some pretty strict requirements! The outlook gets slightly worse
    when you consider what you can actually do with structs. Here''s a hint--not much.
    Let''s examine struct capabilities in comparison to a class:'
  prefs: []
  type: TYPE_NORMAL
- en: You can set and access individual components--classes can do that too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pass structs to functions--yes, you can do that with a class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can assign the contents of one struct to another using the assignment (`=`)
    operator--nothing special here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can return a struct from a function, which actually creates a copy of the
    struct so now you have two on the stack. Classes? Check. However, classes are
    superior in this regard because, when a function returns an instance of a class,
    the object gets passed by reference so there is no need to create an additional
    copy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs *cannot* test for equality using the equality (`==`) operator, because
    structs may contain other bits of data. Classes can compare using the equality
    operator, however. In fact, if you want the same functionality in a struct you
    have to compare fields component, by component which is tedious.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If someone were to score this match-up, I think the result would look something
    like *structs: 4, classes: 5 (maybe 6)*. So obviously, classes are more flexible
    in terms of functionality and convenience, which is why higher-level languages
    with their roots in C typically provide mechanisms to implement these more complex
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: That is not to say that structs do not have their value. Although their usefulness
    falls into very niche scenarios, there are times when a struct is the right tool
    for the job.
  prefs: []
  type: TYPE_NORMAL
- en: Creating structs in C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a struct in C# is a fairly simple process. Our only two requirements
    are `using System` and declaring our object using the `struct` keyword. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding example, our struct is declared with a private
    backing field, a public accessor and one instance method named `WriteXToConsole()`,
    all perfectly legitimate characteristics of a struct in C#. Note the two instances
    of `MyStruct`. The first is instantiated using the `new` keyword, while the second
    is not. Again, both of these operations are perfectly valid in C#, although the
    latter requires you to populate all of the member properties before you can use
    the object in any way. If you were to change the `struct` keyword in our definition
    to class, the second initializer would not compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll examine an example from [Chapter 3](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 3. Lists: Linear Collections"), *Lists: Linear Collections*. In that
    chapter''s case study, we built a data structure that stores a list of `Waypoint`
    objects. Here''s what the `Waypoint` class looks like in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this class is pretty simple. It is so simple that it begs the
    question as to whether or not such a simple collection of values is worthy of
    the overhead and resources afforded to a class, especially when you consider that
    our list could contain hundreds of these `Waypoint` objects. Can we improve performance
    by converting the class to a struct without requiring significant refactoring
    to support this change? First, we need to determine whether it is recommended
    or even possible to do so, and we can make that decision by examining our struct
    criteria rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 1: The struct will logically represent a single value'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, our class has three fields, namely `lat`, `lon`, and `active`.
    Three is definitely not singular, but since the rule is that a struct must *logically
    represent* a single value, our plan to convert the class to a struct is still
    valid. This is because the `Waypoint` object represents a *single* location in
    2-dimensional space, and we require at least two values to represent a 2D coordinate,
    so there is no violation there. Also, the active property denotes a state of the
    waypoint, so this is characteristically acceptable as well. Before you cry foul
    on this interpretation, allow me to point out that even Microsoft plays fast and
    loose with this rule. For instance, `System.Drawing.Rectangle` is defined as a
    structure, and that type stores *four* integers representing both the size and
    location of a rectangle. Size and location are two properties of one object, and
    that is considered acceptable, so I believe `Waypoint` is fine here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 2: Each instance of the struct must be under 16 bytes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `Waypoint` class is easily within the margin of safety for this rule. Referring
    to [Chapter 1](part0015_split_000.html#E9OE2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 1. Data Types: Foundational Structures"), *Data Types: Foundational Structures*,
    the `Int32` structures are 4 bytes in length and Boolean primitives are only 1
    byte in length. This means that a single instance of `Waypoint` will weigh in
    at a grand total of only nine bytes, leaving us seven bytes to spare.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 3: The data must be immutable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason that structs should, ideally, be immutable has to do with their status
    as value types. As mentioned previously, whenever a value type is passed around,
    you end up with a copy of that value rather than a reference to the original value
    itself. This means that when you change a value within the struct, you are only
    changing that struct and none of the others that happen to be hanging around in
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: This requirement may represent a problem for us and it is not a trivial one.
    In our application, we have chosen to store the active state of the `Waypoint`
    value on the object itself, and this field is definitely not immutable. We could
    move the property out of the `Waypoint` class somehow, but doing so would require
    much more refactoring than if we simply left it alone. Since we want to avoid
    a significant refactor for the time being, we will leave the field alone and count
    this rule as a strike against our plan. Our only recourse is to examine our usage
    of the `Waypoint` objects in our code to ensure that we never create a situation
    where an instance of `Waypoint` is passed in such a way that we lose focus on
    the correct instance. Technically speaking, so long as `Waypoint` passes the next
    requirement, we are still in business.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 4: The struct will not require repeated boxing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the `Waypoint` object is used as-is once it has been instantiated, each
    instance will rarely, if ever, be boxed or unboxed. Therefore, our class passes
    this test and qualifies for conversion to a struct.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next question is, *Can the Waypoint class be converted to a struct?* There
    are three points of concern in our class that may need to be addressed. First,
    we have that mutable `active` field to deal with. In its current form, this field
    is not very struct-like since it really should be immutable. Since we really have
    no recourse at this stage, we will have to deal with it in another manner. Predominantly,
    this means we will need to very strictly monitor our usage of `Waypoint` objects
    to ensure that we are not working on copies of a struct when we believe we are
    working with the original struct. Although this may become tedious, it is not
    unreasonable. Our next concern is the defined constructor, but since this is not
    without a parameter or a default constructor, everything is fine here and we can
    move on. Finally, our class has two public methods named `DeactivateWaypoint()`
    and `ReactivateWaypoint()`. Since C# also allows for public methods in a struct,
    these two are fine where they are as well. In fact, the only thing we really need
    to do to convert this class to a struct is to change the `class` keyword to a
    `struct` keyword! Here''s our resulting code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we need to know if this change will represent any improvement in our
    app as a whole. Without extensive testing and analysis of the app at runtime,
    it is impossible to say for sure, but odds are this modification will net a positive
    impact on the overall performance of our off-road biking application without introducing
    any further refactoring requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is going to be a short discussion, since Java does not support structs.
    Apparently, the authors of Java decided that, when the language finally crawled
    out of the C programming swamp, it would not be lugging around these non-object-oriented
    structures. Therefore, our only recourse in Java is to create a class with public
    properties that will mimic the behavior of a struct, but without any of the performance
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objective-C does not support structs directly; however, you can implement and
    use simple C structs in your code. C structs are similar to their C# counterpart,
    in that they allow you to frame several primitive values into a single more complex
    value type. However, C structs do not permit the addition of methods or initializers
    nor any other cool object-oriented programming features that C# structs enjoy.
    Additionally, C structs cannot contain any objects that inherit from `NSObject`,
    as these are classes and not value types.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, structs are actually found very frequently in Objective-C applications.
    One of the most common applications for structs is in the definition of **enumerations**,
    or **enums**. Enums are lists of constants representing integer values whose purpose
    is to create higher levels of abstraction in your code so that developers can
    focus on what the values symbolize without worrying about how they are implemented
    in the background. We will examine enums in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating structs in Objective-C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common source of structs in Objective-C can be found in the **Core
    Graphics framework**, which contains four useful structures. We''ll examine these
    structures in detail in order to demonstrate how structures are defined in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CGPoint`: This structure contains a simple two-point coordinate system consisting
    of two `CGFloat` values. Here''s what the `CGPoint` struct definition looks like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`CGSize`: This structure is simply a container for a width and height, consisting
    of two `CGFloat` values. Here''s what the `CGSize` struct definition looks like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`CGRect`: This is a structure that defines both the location and size of a
    rectangle, consisting of one `CGPoint` value and one `CGSize` value. Here''s what
    the `CGRect` struct definition looks like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`CGVector`: This is a structure that simply contains a 2-dimensional vector,
    consisting of two `CGFloat` values. Here''s what the `CGVector` struct definition
    looks like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should note the `typedef` and `struct` keywords following each of these
    struct definitions. This line is included for our convenience as programmers.
    Whenever we need to call on these structs, if the struct were not decorated with
    the `typedef` keyword, we would always need to precede calls to our struct with
    the `struct` keyword, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct CGRect rect;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, this would rapidly get tiresome. By applying a `typedef` to the
    struct name, we allow our callers to simply apply the struct name without the
    `struct` keyword, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`  CGRect rect;`'
  prefs: []
  type: TYPE_NORMAL
- en: This makes our code easier to write, but also makes it more concise and more
    readable in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will take a look at the `EDSWaypoint` class from [Chapter 3](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 3. Lists: Linear Collections"), *Lists: Linear Collections*, and determine
    whether we can convert that class to a C struct. Here''s the original code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Right away in the interface, we see a few problems with converting this class
    to a struct. Both the `_lat` and `_lon` ivars are `NSInteger` classes, which means
    they are invalid for use inside a struct and they will have to go or be changed
    to a value type. How about the `initWithLatitude:andLongitude:` initializer? Nope,
    you cannot define initializers in C structs either. So, now we need to deal with
    the `reactivateWaypoint` and `deactivateWaypoint` methods. Surely these simple
    properties and methods can pass muster for acceptance into a struct? No, they
    cannot. Everything here needs to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the only real question that remains is what should we do with the
    `_active` value and the associated `-(BOOL)active` property. As it turns out,
    the `BOOL` type is perfectly acceptable to use within a structure, so we can actually
    leave the property where it is. However, `_active` does represent a mutable property
    within the `EDSWaypoint` struct and that is frowned upon, right? It may be frowned
    upon, but structs are not immutable in C. Here''s an example using the Core Graphics
    struct, `CGPoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to duplicate this code in your app, the compiler would not issue
    an error or even a warning because `CGPoint` is not immutable and the properties
    are not read only. Therefore, we can leave the `_active` value in our final struct
    definition. Unfortunately, the same cannot be said for the `-(BOOL)active` property?
    Property accessors such as this are forbidden in C structs so this needs to be
    removed, and that represents a significant change to how our application handles
    the active state of our `Waypoint` objects. So if we want to convert this class
    to a structure, we will be left with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Strictly speaking, the `typedef` declaration is not required but it's bad enough
    that we will have to refactor our entire `EDSWaypointList` class to support these
    changes. Let's not add insult to injury by making our poor developers type eight
    extra characters every time they want to access one of these types.
  prefs: []
  type: TYPE_NORMAL
- en: Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in other languages, structs in Swift are value types that encapsulate small
    groups of related properties. Similar to structs in C#, Swift structs resemble
    a regular class more than a C struct and share all of the following abilities
    with classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to define properties to store values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to contain methods that define extended functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to define subscripts to provide access to values using subscript notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to define custom initializers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift structs can be extended to provide additional functionality beyond their
    initialized state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, Swift structs can be defined to conform to protocols that provide customary
    functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, however, that Swift structs do not support inheritance, meaning that they
    cannot inherit from classes or other structs, nor can they be used as a base for
    other structures or classes. Also, they do not support type casting to enable
    the compiler to check and interpret the type of an instance at runtime. These
    structs cannot be explicitly deinitialized like classes to free up their resources,
    nor do structs support automatic reference counting for memory management. These
    last two points are related to the fact that structs in Swift, as in other languages,
    are value types and not classes or reference types.
  prefs: []
  type: TYPE_NORMAL
- en: This final point in relation to Swift bears repeating. Structs are collections
    of values and, therefore, do not store references to objects like other collections
    such as arrays or dictionaries, for instance. Therefore, when you are passing
    a struct as a parameter to or from a method, it is passed by value and not by
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'So when should you choose to use a struct over a class in Swift? Apple''s documentation
    provides some general rules of thumb to help you make the decision. You should
    use struct when:'
  prefs: []
  type: TYPE_NORMAL
- en: Your object's primary purpose is to gather a few simple data values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You anticipate that the object you create will be copied rather than referenced
    when you assign or send an instance of that object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any properties in your object are value types, not classes, and you also expect
    that their values will be copied rather than referenced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your object has no need to inherit properties or behavior from an existing object
    or type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will notice that this list is not quite as restrictive as the same list
    in C#, but it does represent an excellent common-sense approach to deciding whether
    or not the value added from using a struct outweighs the limited functionality
    in your object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating structs in Swift
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have worked with Swift for more than five minutes, odds are you have
    already worked with some of the built-in structs such as `Int`, `String`, `Array`,
    `Dictionary`, and many others that are defined in the Swift framework. Here''s
    a quick demonstration on how to define your own struct using Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example defines a new structure called `MyColor`, which describes
    an RGBA-based color definition. This structure has four properties called `red`,
    `green`, `blue`, and `alpha`. Although these properties have all been defined
    as mutable variables using `var`, stored properties in Swift can also be defined
    as immutable using `let`. The first three properties in our struct are inferred
    to be the `Int` types by setting their default values to `0`, while the remaining
    property is inferred to be `Double` type by setting its default value to `0.0`.
    Since we have not defined any custom initializers for our method yet, we could
    initialize an instance of this object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code initializes our struct and sets the values to represent
    something similar to dark magenta with a 50% alpha. This demonstration is fine,
    but the initialization is somewhat verbose for many developers'' taste. What if
    we want to create a new object in one line? In that case, we need to modify our
    struct to include a custom initializer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Taking advantage of Swift allowing structs to define custom initializers, we
    have created an `init` method that accepts RGBA values and assigns them to the
    properties of our object, greatly simplifying our object creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will take a look at the `Waypoint` class from [Chapter 3](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 3. Lists: Linear Collections"), *Lists: Linear Collections*, and determine
    whether we can convert that class to a structure. Here''s the original code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this is an interesting class object. We will tackle the elephant in the
    room first: the `Equatable` interface and the public function named `==` declared
    *outside* the class structure. Our class is required to implement the `Equatable`
    interface because several of the methods in `WaypointList` compare two `Waypoint`
    objects for equality. Without the interface and the associated `==` method implementation,
    this would not be possible and our code would not compile. Luckily, Swift structs
    are permitted to implement interfaces such as `Equatable`, so this really is not
    an issue and we can move on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already discussed and demonstrated that Swift structs can define custom
    initializers, so our public `init` method is fine as it is. The `Waypoint` class
    also has two methods called `DeactivateWaypoint()` and `ActivateWaypoint()`. Since
    structs are intended to be immutable, the final change we need for our class to
    become a struct is the addition of the `mutating` keyword to each of these methods
    to denote that each one modifies, or mutates, one or more of the values in the
    instance. Here''s the final version of our `Waypoint` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The addition of the `mutating` keyword to our instance methods will allow us
    to redefine `Waypoint` as a struct, but it will also introduce a new limitation
    to our implementation. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`let point = Waypoint(latitude: 5, longitude: 10)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`point.DeactivateWaypoint()`'
  prefs: []
  type: TYPE_NORMAL
- en: This code will fail to compile with the error `Immutable value of type 'Waypoint'
    has only mutating members named DeactivateWaypoint`. Wait. What now? By including
    the `mutating` keyword, we are also explicitly declaring that this struct is a
    mutable type. It's fine to declare this type as immutable, unless you try to call
    one of the mutating methods at which point the code will fail to compile. Whereas
    before this change we could declare any instance of `Waypoint` as either mutable
    using `var` or immutable using `let`, as we saw fit, we are now restricted to
    only declaring mutable instances of this object if we intend to utilize the `mutating`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, enums increase the level of abstraction in your application
    and allow the developer to focus on the meaning of the values rather than being
    concerned with how the values are stored in memory. This is because an `enum` type
    allows you to label specific integer numeric values with meaningful or easy to
    remember names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case study: the Metro line'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Business problem**: You work with an engineering team tasked with writing
    an application that keeps track of commuter trains along the Metro. One of the
    key business requirements is the ability to easily identify which station a train
    is currently located at or en route to. Each train station has a unique name,
    but the database tracks the stations by their ID values, such as 1100, 1200, 1300,
    and so on. Rather than track stations by name, which is both tedious and prone
    to change over time, your app will utilize the station IDs. However, the reason
    stations are labeled with names instead of IDs in the first place is to make it
    easier for commuters to identify them. This is also true for programmers, who
    would have a difficult time keeping the IDs of dozens or perhaps hundreds of stations
    in mind while writing code.'
  prefs: []
  type: TYPE_NORMAL
- en: You decide to utilize the enum data structure to meet the needs of both your
    application and your developers. Your enum will provide a map between easy-to-remember
    station names and the station IDs they are associated with, so your application
    can utilize the IDs based on the station names while your programmers will use
    the names.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid confusion where multiple train lines overlap at larger stations, we
    do not simply want to create an enum with all of the stations in the entire Metro
    line. Instead, we will create enums based on each line in the Metro. Here''s the
    Silver Line defined as a C# enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, wherever we want to use a value from the `SilverLine` enum, we simply
    need to declare a value type by the same name and assign a value, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the example we just saw, our code initializes a `SilverLine` value to show
    the Silver Line's next stop as station `4100`, using `SilverLine.Federal_Triangle`.
    Once the doors close on the platform, we need to update this value to show our
    train is moving to station `4200`, so we update the value to `SilverLine.Smithsonian`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Java does not permit us to define structs explicitly, we can define
    enums. However, the definition may not appear as you expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that we have not explicitly assigned integer values to each of
    these entries. This is because Java will not allow us to do so. Remember that
    Java does not support structs, so enums in this language are not really primitives
    at all but rather objects of their own type. Therefore, they do not play by the
    same rules as enums in other languages, and some argue that Java enums are more
    robust because of it.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately for our planned use of this structure, this limitation will be
    a small hurdle because we cannot map the station names directly to their associated
    ID value. One option here would be to add a `public static` method, which will
    operate on the string value of `this`, and use that value to map the string to
    an integer value behind the scenes. This may be a somewhat verbose solution, but
    when you consider the fact that this is even possible, it opens a whole new world
    of alternative solutions to the overall business problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as Objective-C does not support structures, it also does not directly
    support enums. Luckily, we can use the underlying C language enum in this case
    as well. Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, note that we have integrated the `typedef` keyword into this definition,
    which means that we will not need to add the declaration of the `SilverLine` enum
    as an object on a separate line in our code. Also note the `enum` keyword, which
    is required to declare an enum in C. Note that we are explicitly declaring that
    this enum is of value type `NSUInteger`. We are using `NSUInteger` here because
    we do not want to support signed values, but if we did, then we could just as
    easily have chosen `NSInteger` for this purpose. Finally, note that the actual
    name of the `enum` variable comes after the definition.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, our enum definition is similar to that of most other C-based languages,
    with just a couple of caveats. First, enums must be declared in a header (`*.h`)
    file if you intend to use it *outside* the scope of the current file. In either
    case, the enum must also be declared them *outside* the `@interface` or `@implementation`
    tags or your code will not compile. Finally, the name of your enum must be unique
    among all other objects within the workspace.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Structs in Swift have more in common with those of C# than those of Objective-C
    due to their wide flexibility. In our example here, we will not add any additional
    methods or `init` functions, but we could if we needed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note the inclusion of the `Int` declaration in our definition. This is not strictly
    required in most cases, unless we intend to explicitly set values for our entries
    as we have done here. This lets the compiler know in advance what types to expect
    for the purpose of type checking. If we had chosen to leave out the explicit values,
    we could have optionally left off the `Int` declaration as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basic definition of the struct data structure,
    as well as how to create structs in applicable languages. We also examined some
    common applications of structs including the very common enum data type. Finally,
    we looked at some previous code examples to check whether we could improve on
    them using struct objects instead of custom classes.
  prefs: []
  type: TYPE_NORMAL
