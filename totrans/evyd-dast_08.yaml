- en: 'Chapter 8. Structs: Complex Types'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。结构体：复杂类型
- en: A **struct** is a collection of data variables or values that are grouped together
    under a single memory block, whereas a data structure is typically some sort of
    collection of objects that are related to one another in some way. Therefore,
    a struct, also known as a structure, is less of a data structure and more of a
    complex data type. This definition sounds pretty simple, but appearances are deceiving
    in this case. The topic of structs is a complex one, and each of the languages
    we are examining has unique qualities in how structs are supported, if they are
    supported at all.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构体**是一组数据变量或值的集合，这些变量或值被组织在单个内存块下，而数据结构通常是某种以某种方式相互关联的对象集合。因此，结构体，也称为结构，更多的是一种复杂的数据类型，而不是数据结构。这个定义听起来很简单，但在这个情况下，外表是欺骗性的。结构体的主题是复杂的，我们正在检查的每种语言在支持结构体方面都有其独特的特点，如果它们支持的话。'
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Definition of the struct data structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构数据结构的定义
- en: Creating structs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建结构体
- en: Common applications of structs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体的常见应用
- en: Examples of structs in each language
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种语言中结构体的示例
- en: Enums
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: The essentials
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: Due to varying support from language to language, we're will take a different
    approach in this chapter. Instead of examining structs as a whole and then examining
    a case study, we will examine structs and case studies simultaneously for each
    language. This will give us the opportunity to examine the nuances of structs
    in each language within the proper context.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语言之间的支持不同，我们将在本章采取不同的方法。我们不会将结构体作为一个整体来检查，然后再检查一个案例研究，而是将每种语言的结构体和案例研究同时进行检查。这将给我们机会在适当的环境中检查每种语言中结构体的细微差别。
- en: C#
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#
- en: In C#, a struct is defined as a value type that encapsulates small groups of
    related fields, which sounds very similar to the underlying C language implementation.
    However, C# structs are in fact quite different from those found in C, and they
    more closely resemble a regular class than a struct from that language. For instance,
    a C# struct can have methods, fields, properties, constants, indexers, operator
    methods, nested types, and events as well as defined constructors (but not default
    constructors, which are defined automatically). Structs can also implement one
    or more interfaces, all of which make the C# variety much more flexible than C.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，结构体被定义为封装相关字段的小组值的值类型，这听起来与底层C语言实现非常相似。然而，C#结构体实际上与C中的结构体有很大不同，它们更类似于那种语言的常规类。例如，C#结构体可以有方法、字段、属性、常量、索引器、运算符方法、嵌套类型和事件，以及定义的构造函数（但不包括默认构造函数，它是自动定义的）。结构体还可以实现一个或多个接口，所有这些都使得C#版本比C更加灵活。
- en: However, it would be a mistake to think of structs as lightweight classes. C#
    structs do not support inheritance, meaning they cannot inherit from classes or
    other structs, nor can they be used as a base for other structures or classes.
    Structure members cannot be declared as abstract, protected, or virtual. Unlike
    classes, structs can be instantiated without using the `new` keyword, although
    doing so prevents the resulting object from being used until every field has been
    assigned. Finally, and perhaps most importantly, structs are value types while
    classes are reference types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将结构体视为轻量级类是错误的。C#结构体不支持继承，这意味着它们不能从类或其他结构体继承，也不能用作其他结构或类的基类。结构体成员不能声明为抽象的、受保护的或虚拟的。与类不同，结构体可以在不使用`new`关键字的情况下实例化，尽管这样做会阻止结果对象在所有字段被分配之前被使用。最后，也许最重要的是，结构体是值类型，而类是引用类型。
- en: This final point cannot be overemphasized because it represents the key advantage
    to choosing a struct in place of a class. Structs are collections of values and,
    therefore, do not store references to objects such as arrays, for instance. Therefore,
    when you are passing a struct off to a method, it is passed by value rather than
    reference. Additionally, according to the MSDN documentation, being a value type
    means that structs do not require allocation to the heap memory and, therefore,
    do not carry the overhead that a class does in terms of memory and processing
    requirements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后一点不能过分强调，因为它代表了选择结构体而不是类的主要优势。结构体是值的集合，因此不存储诸如数组之类的对象的引用。因此，当你将结构体传递给方法时，它是按值传递而不是按引用传递。此外，根据MSDN文档，作为值类型，结构体不需要分配堆内存，因此不携带类在内存和处理需求方面的开销。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does this mean and why is this beneficial? When you create a new class
    by using the new operator, the object that is returned will be allocated on the
    heap. When you instantiate a struct, on the other hand, it gets created directly
    on the stack and that nets a performance gain because the stack provides much
    faster memory access than the heap. As long as you don't overload the stack and
    cause a stack overflow, using structs strategically can be a great way to improve
    performance in your application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you might be saying to yourself, *Why do we even have classes if structs
    are so awesome?* For starters, the applications for structs in C# are very limited.
    According to Microsoft, you should only consider using a struct instead of a class
    if the instances of the type will be small and short-lived or they are typically
    embedded in other objects. Furthermore, you should not define a struct unless
    it meets at least three of the following criteria:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The struct will logically represent a single value similar to a primitive type
    such as an integer, double, and so on
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each instance of the struct will be smaller than 16 bytes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data in the struct will be immutable once it has been instantiated
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The struct will not need to be boxed and unboxed repeatedly
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those are some pretty strict requirements! The outlook gets slightly worse
    when you consider what you can actually do with structs. Here''s a hint--not much.
    Let''s examine struct capabilities in comparison to a class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: You can set and access individual components--classes can do that too.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pass structs to functions--yes, you can do that with a class.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can assign the contents of one struct to another using the assignment (`=`)
    operator--nothing special here.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can return a struct from a function, which actually creates a copy of the
    struct so now you have two on the stack. Classes? Check. However, classes are
    superior in this regard because, when a function returns an instance of a class,
    the object gets passed by reference so there is no need to create an additional
    copy.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs *cannot* test for equality using the equality (`==`) operator, because
    structs may contain other bits of data. Classes can compare using the equality
    operator, however. In fact, if you want the same functionality in a struct you
    have to compare fields component, by component which is tedious.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If someone were to score this match-up, I think the result would look something
    like *structs: 4, classes: 5 (maybe 6)*. So obviously, classes are more flexible
    in terms of functionality and convenience, which is why higher-level languages
    with their roots in C typically provide mechanisms to implement these more complex
    objects.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: That is not to say that structs do not have their value. Although their usefulness
    falls into very niche scenarios, there are times when a struct is the right tool
    for the job.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Creating structs in C#
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a struct in C# is a fairly simple process. Our only two requirements
    are `using System` and declaring our object using the `struct` keyword. Here''s
    an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see from the preceding example, our struct is declared with a private
    backing field, a public accessor and one instance method named `WriteXToConsole()`,
    all perfectly legitimate characteristics of a struct in C#. Note the two instances
    of `MyStruct`. The first is instantiated using the `new` keyword, while the second
    is not. Again, both of these operations are perfectly valid in C#, although the
    latter requires you to populate all of the member properties before you can use
    the object in any way. If you were to change the `struct` keyword in our definition
    to class, the second initializer would not compile.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll examine an example from [Chapter 3](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 3. Lists: Linear Collections"), *Lists: Linear Collections*. In that
    chapter''s case study, we built a data structure that stores a list of `Waypoint`
    objects. Here''s what the `Waypoint` class looks like in C#:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, this class is pretty simple. It is so simple that it begs the
    question as to whether or not such a simple collection of values is worthy of
    the overhead and resources afforded to a class, especially when you consider that
    our list could contain hundreds of these `Waypoint` objects. Can we improve performance
    by converting the class to a struct without requiring significant refactoring
    to support this change? First, we need to determine whether it is recommended
    or even possible to do so, and we can make that decision by examining our struct
    criteria rules.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 1: The struct will logically represent a single value'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, our class has three fields, namely `lat`, `lon`, and `active`.
    Three is definitely not singular, but since the rule is that a struct must *logically
    represent* a single value, our plan to convert the class to a struct is still
    valid. This is because the `Waypoint` object represents a *single* location in
    2-dimensional space, and we require at least two values to represent a 2D coordinate,
    so there is no violation there. Also, the active property denotes a state of the
    waypoint, so this is characteristically acceptable as well. Before you cry foul
    on this interpretation, allow me to point out that even Microsoft plays fast and
    loose with this rule. For instance, `System.Drawing.Rectangle` is defined as a
    structure, and that type stores *four* integers representing both the size and
    location of a rectangle. Size and location are two properties of one object, and
    that is considered acceptable, so I believe `Waypoint` is fine here.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 2: Each instance of the struct must be under 16 bytes'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `Waypoint` class is easily within the margin of safety for this rule. Referring
    to [Chapter 1](part0015_split_000.html#E9OE2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 1. Data Types: Foundational Structures"), *Data Types: Foundational Structures*,
    the `Int32` structures are 4 bytes in length and Boolean primitives are only 1
    byte in length. This means that a single instance of `Waypoint` will weigh in
    at a grand total of only nine bytes, leaving us seven bytes to spare.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Waypoint`类很容易符合这一安全规则。参考[第1章](part0015_split_000.html#E9OE2-77f2b5b248f04368a6f723b0e9357ef3
    "第1章。数据类型：基础结构")，*数据类型：基础结构*，`Int32`结构体长度为4字节，布尔原始类型长度仅为1字节。这意味着单个`Waypoint`实例的总重量仅为九字节，我们还有七个字节的空间。
- en: 'Rule 3: The data must be immutable'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则3：数据必须是不可变的
- en: The reason that structs should, ideally, be immutable has to do with their status
    as value types. As mentioned previously, whenever a value type is passed around,
    you end up with a copy of that value rather than a reference to the original value
    itself. This means that when you change a value within the struct, you are only
    changing that struct and none of the others that happen to be hanging around in
    the stack.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体应该理想上是不可变的，这与它们作为值类型的状态有关。如前所述，每当传递一个值类型时，你最终得到的是该值的副本，而不是原始值的引用。这意味着当你更改结构体内的值时，你只是在更改该结构体，而不会影响到堆栈中可能存在的其他任何结构体。
- en: This requirement may represent a problem for us and it is not a trivial one.
    In our application, we have chosen to store the active state of the `Waypoint`
    value on the object itself, and this field is definitely not immutable. We could
    move the property out of the `Waypoint` class somehow, but doing so would require
    much more refactoring than if we simply left it alone. Since we want to avoid
    a significant refactor for the time being, we will leave the field alone and count
    this rule as a strike against our plan. Our only recourse is to examine our usage
    of the `Waypoint` objects in our code to ensure that we never create a situation
    where an instance of `Waypoint` is passed in such a way that we lose focus on
    the correct instance. Technically speaking, so long as `Waypoint` passes the next
    requirement, we are still in business.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求可能对我们来说是一个问题，而且不是一个小问题。在我们的应用程序中，我们选择在对象本身上存储`Waypoint`值的活跃状态，而这个字段肯定不是不可变的。我们可以以某种方式将属性移出`Waypoint`类，但这样做需要比如果我们简单地让它保持原样进行更多的重构。由于我们目前想要避免重大的重构，我们将保持该字段不变，并将此规则视为对我们计划的打击。我们唯一的补救办法是检查我们代码中对`Waypoint`对象的使用，以确保我们永远不会创建一个`Waypoint`实例以这种方式传递，以至于我们失去了对正确实例的关注。从技术上来说，只要`Waypoint`通过下一个要求，我们仍然在业务中。
- en: 'Rule 4: The struct will not require repeated boxing'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则4：结构体不需要重复装箱
- en: Since the `Waypoint` object is used as-is once it has been instantiated, each
    instance will rarely, if ever, be boxed or unboxed. Therefore, our class passes
    this test and qualifies for conversion to a struct.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Waypoint`对象一旦实例化后就是直接使用的，因此每个实例很少，如果不是从未，会被装箱或解箱。因此，我们的类通过了这个测试，并符合转换为结构体的条件。
- en: Conversion
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换
- en: 'The next question is, *Can the Waypoint class be converted to a struct?* There
    are three points of concern in our class that may need to be addressed. First,
    we have that mutable `active` field to deal with. In its current form, this field
    is not very struct-like since it really should be immutable. Since we really have
    no recourse at this stage, we will have to deal with it in another manner. Predominantly,
    this means we will need to very strictly monitor our usage of `Waypoint` objects
    to ensure that we are not working on copies of a struct when we believe we are
    working with the original struct. Although this may become tedious, it is not
    unreasonable. Our next concern is the defined constructor, but since this is not
    without a parameter or a default constructor, everything is fine here and we can
    move on. Finally, our class has two public methods named `DeactivateWaypoint()`
    and `ReactivateWaypoint()`. Since C# also allows for public methods in a struct,
    these two are fine where they are as well. In fact, the only thing we really need
    to do to convert this class to a struct is to change the `class` keyword to a
    `struct` keyword! Here''s our resulting code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是，*能否将Waypoint类转换为结构体？* 在我们的类中有三个需要注意的点可能需要解决。首先，我们有一个可变的`active`字段需要处理。在其当前形式下，这个字段并不太像结构体，因为它实际上应该是不可变的。由于在这个阶段我们真的没有其他办法，我们不得不以另一种方式处理它。主要来说，这意味着我们需要非常严格地监控我们对`Waypoint`对象的使用，以确保当我们认为我们在处理原始结构体时，我们实际上并没有在处理结构体的副本。尽管这可能会变得繁琐，但这并不不合理。我们的下一个关注点是定义的构造函数，但由于这不是没有参数或默认构造函数，所以这里一切正常，我们可以继续前进。最后，我们的类有两个名为`DeactivateWaypoint()`和`ReactivateWaypoint()`的公共方法。由于C#也允许在结构体中使用公共方法，这两个方法在这里也是可以的。事实上，我们真正需要做的，将这个类转换为结构体，就是将`class`关键字改为`struct`关键字！以下是我们的结果代码：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Lastly, we need to know if this change will represent any improvement in our
    app as a whole. Without extensive testing and analysis of the app at runtime,
    it is impossible to say for sure, but odds are this modification will net a positive
    impact on the overall performance of our off-road biking application without introducing
    any further refactoring requirements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要知道这个更改是否会在整体上代表我们应用的任何改进。没有对应用在运行时的广泛测试和分析，我们无法确定地说，但可能性很大，这个修改将对我们越野骑行应用的整体性能产生积极影响，而不会引入任何进一步的重构需求。
- en: Java
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java
- en: This is going to be a short discussion, since Java does not support structs.
    Apparently, the authors of Java decided that, when the language finally crawled
    out of the C programming swamp, it would not be lugging around these non-object-oriented
    structures. Therefore, our only recourse in Java is to create a class with public
    properties that will mimic the behavior of a struct, but without any of the performance
    benefits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个简短的讨论，因为Java不支持结构体。显然，Java的作者们决定，当这种语言最终从C编程的泥潭中爬出来时，它不会带着这些非面向对象的结构体四处奔波。因此，在Java中我们唯一的办法是创建一个具有公共属性的类来模拟结构体的行为，但没有任何性能上的优势。
- en: Objective-C
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Objective-C
- en: Objective-C does not support structs directly; however, you can implement and
    use simple C structs in your code. C structs are similar to their C# counterpart,
    in that they allow you to frame several primitive values into a single more complex
    value type. However, C structs do not permit the addition of methods or initializers
    nor any other cool object-oriented programming features that C# structs enjoy.
    Additionally, C structs cannot contain any objects that inherit from `NSObject`,
    as these are classes and not value types.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C不支持直接使用结构体；然而，你可以在代码中实现和使用简单的C结构体。C结构体与它们的C#对应物类似，因为它们允许你将几个原始值组合成一个更复杂的值类型。但是，C结构体不允许添加方法或初始化器，也不允许C#结构体所享有的任何其他酷炫的面向对象编程特性。此外，C结构体不能包含从`NSObject`继承的对象，因为这些是类而不是值类型。
- en: That being said, structs are actually found very frequently in Objective-C applications.
    One of the most common applications for structs is in the definition of **enumerations**,
    or **enums**. Enums are lists of constants representing integer values whose purpose
    is to create higher levels of abstraction in your code so that developers can
    focus on what the values symbolize without worrying about how they are implemented
    in the background. We will examine enums in more detail later in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Creating structs in Objective-C
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common source of structs in Objective-C can be found in the **Core
    Graphics framework**, which contains four useful structures. We''ll examine these
    structures in detail in order to demonstrate how structures are defined in Objective-C:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`CGPoint`: This structure contains a simple two-point coordinate system consisting
    of two `CGFloat` values. Here''s what the `CGPoint` struct definition looks like:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`CGSize`: This structure is simply a container for a width and height, consisting
    of two `CGFloat` values. Here''s what the `CGSize` struct definition looks like:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`CGRect`: This is a structure that defines both the location and size of a
    rectangle, consisting of one `CGPoint` value and one `CGSize` value. Here''s what
    the `CGRect` struct definition looks like:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`CGVector`: This is a structure that simply contains a 2-dimensional vector,
    consisting of two `CGFloat` values. Here''s what the `CGVector` struct definition
    looks like:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should note the `typedef` and `struct` keywords following each of these
    struct definitions. This line is included for our convenience as programmers.
    Whenever we need to call on these structs, if the struct were not decorated with
    the `typedef` keyword, we would always need to precede calls to our struct with
    the `struct` keyword, like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '`struct CGRect rect;`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, this would rapidly get tiresome. By applying a `typedef` to the
    struct name, we allow our callers to simply apply the struct name without the
    `struct` keyword, like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`  CGRect rect;`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: This makes our code easier to write, but also makes it more concise and more
    readable in the long run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will take a look at the `EDSWaypoint` class from [Chapter 3](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 3. Lists: Linear Collections"), *Lists: Linear Collections*, and determine
    whether we can convert that class to a C struct. Here''s the original code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Right away in the interface, we see a few problems with converting this class
    to a struct. Both the `_lat` and `_lon` ivars are `NSInteger` classes, which means
    they are invalid for use inside a struct and they will have to go or be changed
    to a value type. How about the `initWithLatitude:andLongitude:` initializer? Nope,
    you cannot define initializers in C structs either. So, now we need to deal with
    the `reactivateWaypoint` and `deactivateWaypoint` methods. Surely these simple
    properties and methods can pass muster for acceptance into a struct? No, they
    cannot. Everything here needs to go.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the only real question that remains is what should we do with the
    `_active` value and the associated `-(BOOL)active` property. As it turns out,
    the `BOOL` type is perfectly acceptable to use within a structure, so we can actually
    leave the property where it is. However, `_active` does represent a mutable property
    within the `EDSWaypoint` struct and that is frowned upon, right? It may be frowned
    upon, but structs are not immutable in C. Here''s an example using the Core Graphics
    struct, `CGPoint`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you were to duplicate this code in your app, the compiler would not issue
    an error or even a warning because `CGPoint` is not immutable and the properties
    are not read only. Therefore, we can leave the `_active` value in our final struct
    definition. Unfortunately, the same cannot be said for the `-(BOOL)active` property?
    Property accessors such as this are forbidden in C structs so this needs to be
    removed, and that represents a significant change to how our application handles
    the active state of our `Waypoint` objects. So if we want to convert this class
    to a structure, we will be left with the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Strictly speaking, the `typedef` declaration is not required but it's bad enough
    that we will have to refactor our entire `EDSWaypointList` class to support these
    changes. Let's not add insult to injury by making our poor developers type eight
    extra characters every time they want to access one of these types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Swift
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in other languages, structs in Swift are value types that encapsulate small
    groups of related properties. Similar to structs in C#, Swift structs resemble
    a regular class more than a C struct and share all of the following abilities
    with classes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Ability to define properties to store values
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to contain methods that define extended functionality
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to define subscripts to provide access to values using subscript notation
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to define custom initializers
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift structs can be extended to provide additional functionality beyond their
    initialized state
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, Swift structs can be defined to conform to protocols that provide customary
    functionality
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, however, that Swift structs do not support inheritance, meaning that they
    cannot inherit from classes or other structs, nor can they be used as a base for
    other structures or classes. Also, they do not support type casting to enable
    the compiler to check and interpret the type of an instance at runtime. These
    structs cannot be explicitly deinitialized like classes to free up their resources,
    nor do structs support automatic reference counting for memory management. These
    last two points are related to the fact that structs in Swift, as in other languages,
    are value types and not classes or reference types.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: This final point in relation to Swift bears repeating. Structs are collections
    of values and, therefore, do not store references to objects like other collections
    such as arrays or dictionaries, for instance. Therefore, when you are passing
    a struct as a parameter to or from a method, it is passed by value and not by
    reference.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'So when should you choose to use a struct over a class in Swift? Apple''s documentation
    provides some general rules of thumb to help you make the decision. You should
    use struct when:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Your object's primary purpose is to gather a few simple data values
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You anticipate that the object you create will be copied rather than referenced
    when you assign or send an instance of that object
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any properties in your object are value types, not classes, and you also expect
    that their values will be copied rather than referenced
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your object has no need to inherit properties or behavior from an existing object
    or type
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will notice that this list is not quite as restrictive as the same list
    in C#, but it does represent an excellent common-sense approach to deciding whether
    or not the value added from using a struct outweighs the limited functionality
    in your object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Creating structs in Swift
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have worked with Swift for more than five minutes, odds are you have
    already worked with some of the built-in structs such as `Int`, `String`, `Array`,
    `Dictionary`, and many others that are defined in the Swift framework. Here''s
    a quick demonstration on how to define your own struct using Swift:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding example defines a new structure called `MyColor`, which describes
    an RGBA-based color definition. This structure has four properties called `red`,
    `green`, `blue`, and `alpha`. Although these properties have all been defined
    as mutable variables using `var`, stored properties in Swift can also be defined
    as immutable using `let`. The first three properties in our struct are inferred
    to be the `Int` types by setting their default values to `0`, while the remaining
    property is inferred to be `Double` type by setting its default value to `0.0`.
    Since we have not defined any custom initializers for our method yet, we could
    initialize an instance of this object as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code initializes our struct and sets the values to represent
    something similar to dark magenta with a 50% alpha. This demonstration is fine,
    but the initialization is somewhat verbose for many developers'' taste. What if
    we want to create a new object in one line? In that case, we need to modify our
    struct to include a custom initializer, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Taking advantage of Swift allowing structs to define custom initializers, we
    have created an `init` method that accepts RGBA values and assigns them to the
    properties of our object, greatly simplifying our object creation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will take a look at the `Waypoint` class from [Chapter 3](part0022_split_000.html#KVCC1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 3. Lists: Linear Collections"), *Lists: Linear Collections*, and determine
    whether we can convert that class to a structure. Here''s the original code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now this is an interesting class object. We will tackle the elephant in the
    room first: the `Equatable` interface and the public function named `==` declared
    *outside* the class structure. Our class is required to implement the `Equatable`
    interface because several of the methods in `WaypointList` compare two `Waypoint`
    objects for equality. Without the interface and the associated `==` method implementation,
    this would not be possible and our code would not compile. Luckily, Swift structs
    are permitted to implement interfaces such as `Equatable`, so this really is not
    an issue and we can move on.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already discussed and demonstrated that Swift structs can define custom
    initializers, so our public `init` method is fine as it is. The `Waypoint` class
    also has two methods called `DeactivateWaypoint()` and `ActivateWaypoint()`. Since
    structs are intended to be immutable, the final change we need for our class to
    become a struct is the addition of the `mutating` keyword to each of these methods
    to denote that each one modifies, or mutates, one or more of the values in the
    instance. Here''s the final version of our `Waypoint` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The addition of the `mutating` keyword to our instance methods will allow us
    to redefine `Waypoint` as a struct, but it will also introduce a new limitation
    to our implementation. Consider the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '`let point = Waypoint(latitude: 5, longitude: 10)`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`point.DeactivateWaypoint()`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: This code will fail to compile with the error `Immutable value of type 'Waypoint'
    has only mutating members named DeactivateWaypoint`. Wait. What now? By including
    the `mutating` keyword, we are also explicitly declaring that this struct is a
    mutable type. It's fine to declare this type as immutable, unless you try to call
    one of the mutating methods at which point the code will fail to compile. Whereas
    before this change we could declare any instance of `Waypoint` as either mutable
    using `var` or immutable using `let`, as we saw fit, we are now restricted to
    only declaring mutable instances of this object if we intend to utilize the `mutating`
    methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, enums increase the level of abstraction in your application
    and allow the developer to focus on the meaning of the values rather than being
    concerned with how the values are stored in memory. This is because an `enum` type
    allows you to label specific integer numeric values with meaningful or easy to
    remember names.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Case study: the Metro line'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Business problem**: You work with an engineering team tasked with writing
    an application that keeps track of commuter trains along the Metro. One of the
    key business requirements is the ability to easily identify which station a train
    is currently located at or en route to. Each train station has a unique name,
    but the database tracks the stations by their ID values, such as 1100, 1200, 1300,
    and so on. Rather than track stations by name, which is both tedious and prone
    to change over time, your app will utilize the station IDs. However, the reason
    stations are labeled with names instead of IDs in the first place is to make it
    easier for commuters to identify them. This is also true for programmers, who
    would have a difficult time keeping the IDs of dozens or perhaps hundreds of stations
    in mind while writing code.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: You decide to utilize the enum data structure to meet the needs of both your
    application and your developers. Your enum will provide a map between easy-to-remember
    station names and the station IDs they are associated with, so your application
    can utilize the IDs based on the station names while your programmers will use
    the names.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid confusion where multiple train lines overlap at larger stations, we
    do not simply want to create an enum with all of the stations in the entire Metro
    line. Instead, we will create enums based on each line in the Metro. Here''s the
    Silver Line defined as a C# enum:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, wherever we want to use a value from the `SilverLine` enum, we simply
    need to declare a value type by the same name and assign a value, such as the
    following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the example we just saw, our code initializes a `SilverLine` value to show
    the Silver Line's next stop as station `4100`, using `SilverLine.Federal_Triangle`.
    Once the doors close on the platform, we need to update this value to show our
    train is moving to station `4200`, so we update the value to `SilverLine.Smithsonian`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Java does not permit us to define structs explicitly, we can define
    enums. However, the definition may not appear as you expect:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You may notice that we have not explicitly assigned integer values to each of
    these entries. This is because Java will not allow us to do so. Remember that
    Java does not support structs, so enums in this language are not really primitives
    at all but rather objects of their own type. Therefore, they do not play by the
    same rules as enums in other languages, and some argue that Java enums are more
    robust because of it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately for our planned use of this structure, this limitation will be
    a small hurdle because we cannot map the station names directly to their associated
    ID value. One option here would be to add a `public static` method, which will
    operate on the string value of `this`, and use that value to map the string to
    an integer value behind the scenes. This may be a somewhat verbose solution, but
    when you consider the fact that this is even possible, it opens a whole new world
    of alternative solutions to the overall business problem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as Objective-C does not support structures, it also does not directly
    support enums. Luckily, we can use the underlying C language enum in this case
    as well. Here''s how:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, note that we have integrated the `typedef` keyword into this definition,
    which means that we will not need to add the declaration of the `SilverLine` enum
    as an object on a separate line in our code. Also note the `enum` keyword, which
    is required to declare an enum in C. Note that we are explicitly declaring that
    this enum is of value type `NSUInteger`. We are using `NSUInteger` here because
    we do not want to support signed values, but if we did, then we could just as
    easily have chosen `NSInteger` for this purpose. Finally, note that the actual
    name of the `enum` variable comes after the definition.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, our enum definition is similar to that of most other C-based languages,
    with just a couple of caveats. First, enums must be declared in a header (`*.h`)
    file if you intend to use it *outside* the scope of the current file. In either
    case, the enum must also be declared them *outside* the `@interface` or `@implementation`
    tags or your code will not compile. Finally, the name of your enum must be unique
    among all other objects within the workspace.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Structs in Swift have more in common with those of C# than those of Objective-C
    due to their wide flexibility. In our example here, we will not add any additional
    methods or `init` functions, but we could if we needed to:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the inclusion of the `Int` declaration in our definition. This is not strictly
    required in most cases, unless we intend to explicitly set values for our entries
    as we have done here. This lets the compiler know in advance what types to expect
    for the purpose of type checking. If we had chosen to leave out the explicit values,
    we could have optionally left off the `Int` declaration as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basic definition of the struct data structure,
    as well as how to create structs in applicable languages. We also examined some
    common applications of structs including the very common enum data type. Finally,
    we looked at some previous code examples to check whether we could improve on
    them using struct objects instead of custom classes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
