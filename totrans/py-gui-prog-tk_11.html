<html><head></head><body>
  <div id="_idContainer199">
    <h1 class="chapterNumber">11</h1>
    <h1 id="_idParaDest-281" class="chapterTitle">Creating Automated Tests with unittest</h1>
    <p class="normal">With the size and complexity of your application rapidly expanding, you've become nervous about making changes. What if you break something? How will you know? You can, of course, run through all the features of the program manually with various input and watch for errors, but this approach gets harder and more time consuming as you add more features. What you really need is a fast and reliable way to make sure your program is working properly whenever you make a code change.</p>
    <p class="normal">Fortunately, there is a way: automated testing. In this chapter, you'll learn about automated testing in the following topics:</p>
    <ul>
      <li class="bullet">In <em class="italic">Automated testing basics</em>, you'll discover the fundamentals of automated testing in Python using <code class="Code-In-Text--PACKT-">unittest</code>.</li>
      <li class="bullet">In <em class="italic">Testing Tkinter code</em>, we'll discuss specific strategies for testing Tkinter applications.</li>
      <li class="bullet">In <em class="italic">Writing tests for our application</em>, we'll apply this knowledge to the ABQ Data Entry application.</li>
    </ul>
    <h1 id="_idParaDest-282" class="title">Automated testing basics</h1>
    <p class="normal">Up until now, testing our application has been a process of launching it, running it through a few basic procedures, and verifying that it did what we expected it to do. This approach works <a id="_idIndexMarker1045"/>acceptably on a very small script, but, as our application grows, it becomes an increasingly time-consuming and error-prone process to verify the application's behavior.</p>
    <p class="normal">Using automated testing, we can consistently verify our application logic within seconds. There are several forms of automated testing, but the two most common are <strong class="keyword">unit testing</strong> and <strong class="keyword">integration testing</strong>. Unit tests work with discrete pieces of code in isolation, allowing us to <a id="_idIndexMarker1046"/>quickly verify the behavior of specific sections. Integration tests <a id="_idIndexMarker1047"/>verify the interactions of multiple units of code. We'll be writing both kinds of tests to verify the behavior of our application.</p>
    <h2 id="_idParaDest-283" class="title">A simple unit test</h2>
    <p class="normal">At its most basic, a unit test is just a short program that runs a unit of code under different conditions <a id="_idIndexMarker1048"/>and compares its output against expected results.</p>
    <p class="normal">Consider the following calculation class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># unittest_demo/mycalc.py</span>
<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyCalc</span><span class="hljs-class">:</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, a, b</span><span class="hljs-function">):</span>
    self.a = a
    self.b = b
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">add</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">return</span> self.a + self.b
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">mod_divide</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">if</span> self.b == <span class="hljs-number">0</span>:
      <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"Cannot divide by zero"</span>)
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>(self.a / self.b), self.a % self.b)
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">rand_between</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">return</span> (
      (random.random() * <span class="hljs-built_in">abs</span>(self.a - self.b))
      + <span class="hljs-built_in">min</span>(self.a, self.b)
    )
</code></pre>
    <p class="normal">This class is initialized with two numbers on which it can subsequently perform a variety of mathematical operations.</p>
    <p class="normal">Suppose we want to write some code to test if this class works as it should. A naive approach might look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># unittest_demo/test_mycalc_no_unittest.py</span>
<span class="hljs-keyword">from</span> mycalc <span class="hljs-keyword">import</span> MyCalc
mc1 = MyCalc(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)
mc2 = MyCalc(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>)
<span class="hljs-keyword">try</span>:
  <span class="hljs-keyword">assert</span> mc1.add() == <span class="hljs-number">101</span>, <span class="hljs-string">"Test of add() failed."</span>
  <span class="hljs-keyword">assert</span> mc2.mod_divide() == (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), <span class="hljs-string">"Test of mod_divide() failed."</span>
<span class="hljs-keyword">except</span> AssertionError <span class="hljs-keyword">as</span> e:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Test failed: "</span>, e)
<span class="hljs-keyword">else</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Tests succeeded!"</span>)
</code></pre>
    <p class="normal">This test code creates a <code class="Code-In-Text--PACKT-">MyCalc</code> object and then uses <code class="Code-In-Text--PACKT-">assert</code> statements to check the output of <code class="Code-In-Text--PACKT-">add()</code> and <code class="Code-In-Text--PACKT-">mod_divide()</code> against expected values. The <code class="Code-In-Text--PACKT-">assert</code> keyword in Python is a special <a id="_idIndexMarker1049"/>statement that raises an <code class="Code-In-Text--PACKT-">AssertionError</code> exception if the expression that follows it evaluates to <code class="Code-In-Text--PACKT-">False</code>. The message string after the comma is the error string that will be passed to the <code class="Code-In-Text--PACKT-">AssertionError</code> exception's initializer.</p>
    <p class="normal">In other words, the statement <code class="Code-In-Text--PACKT-">assert expression, "message"</code> is equivalent to:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> expression:
  <span class="hljs-keyword">raise</span> AssertionError(<span class="hljs-string">"message"</span>)
</code></pre>
    <p class="normal">Currently, all tests pass if you run the test script for <code class="Code-In-Text--PACKT-">MyCalc</code>. Let's try changing the <code class="Code-In-Text--PACKT-">add()</code> method to make it fail:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">add</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
  <span class="hljs-keyword">return</span> self.a - self.b
</code></pre>
    <p class="normal">Now, running the test gives this error:</p>
    <pre class="programlisting con"><code class="hljs-con">Test failed: Test of add() failed.
</code></pre>
    <p class="normal">What is the value of such tests? With such a simple function, it seems pointless. But suppose someone decides to refactor our <code class="Code-In-Text--PACKT-">mod_divide()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">mod_divide</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
  <span class="hljs-comment">#...</span>
  <span class="hljs-keyword">return</span> (self.a // self.b, self.a % self.b)
</code></pre>
    <p class="normal">This method is a little more complex, and you may or may not be familiar with all the operators involved. However, since this passes our tests, we have some evidence that this algorithm is correct, even if we didn't completely understand the code. If there were a problem with the <a id="_idIndexMarker1050"/>refactor, our tests could help us identify the problem quickly.</p>
    <p class="normal">Testing pure mathematical functions is fairly simple; unfortunately, testing real application code presents us with some challenges that demand a more sophisticated approach.</p>
    <p class="normal">Consider these issues:</p>
    <ul>
      <li class="bullet">Code units often rely on a pre-existing state that must be set up before the test and cleared up afterward.</li>
      <li class="bullet">Code may have side effects that change objects outside the code unit.</li>
      <li class="bullet">Code may interact with resources that are slow, unreliable, or unpredictable.</li>
      <li class="bullet">Real applications contain many functions and classes that require testing, and ideally we'd like to be alerted to all problems at once. Our test script, as written, would stop on the first failed assertion, so we'd only get alerted to one problem at a time.</li>
    </ul>
    <p class="normal">To address these issues and others, programmers rely on <strong class="keyword">testing frameworks</strong> to make writing and executing <a id="_idIndexMarker1051"/>automated tests as simple, efficient, and reliable as possible.</p>
    <h2 id="_idParaDest-284" class="title">The unittest module</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">unittest</code> module is the Python standard library's automated testing framework. It provides us with <a id="_idIndexMarker1052"/>some powerful tools to make testing our code reasonably easy, and is based on some standard unit testing concepts found in many test frameworks. These concepts include:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Test</strong>: A test is a single method that will either finish or raise an exception. Tests generally focus on <a id="_idIndexMarker1053"/>one unit of code, such as a function, method, or process. A test can either pass, meaning the test was successful; fail, meaning the code failed the test; or error, meaning the test itself encountered a problem.</li>
      <li class="bullet"><strong class="keyword">Test case</strong>: A test case is a collection of tests that should be run together and contain similar setup <a id="_idIndexMarker1054"/>and tear-down requirements, typically corresponding to a class or module. Test cases can have <strong class="keyword">fixtures</strong>, which are items that need to <a id="_idIndexMarker1055"/>be set up before each test and torn down after each test to provide a clean, predictable environment in which the test can run.</li>
      <li class="bullet"><strong class="keyword">Test suite</strong>: A test suite is a collection <a id="_idIndexMarker1056"/>of test cases that cover all the code for an application or module.</li>
      <li class="bullet"><strong class="keyword">Mock</strong>: A mock is an object that stands in for another object. Typically, they're used to replace an <a id="_idIndexMarker1057"/>external resource, such as a file, database, or library module. Mocks are patched over those resources during the test to provide a fast and predictable stand-in with no side effects.</li>
    </ul>
    <p class="normal">To explore these concepts in depth, let's test our <code class="Code-In-Text--PACKT-">MyCalc</code> class using <code class="Code-In-Text--PACKT-">unittest</code>.</p>
    <h3 id="_idParaDest-285" class="title">Writing a test case</h3>
    <p class="normal">Let's create a test case <a id="_idIndexMarker1058"/>for the <code class="Code-In-Text--PACKT-">MyCalc</code> class. Create a new file called <code class="Code-In-Text--PACKT-">test_mycalc.py</code>, and enter this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># unittest_demo/test_mycalc.py</span>
<span class="hljs-keyword">import</span> mycalc
<span class="hljs-keyword">import</span> unittest
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestMyCalc</span><span class="hljs-class">(</span><span class="hljs-params">unittest.TestCase</span><span class="hljs-class">):</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_add</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    mc = mycalc.MyCalc(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
    <span class="hljs-keyword">assert</span> mc.add() == <span class="hljs-number">11</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
  unittest.main()
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The names of both your test modules and your test methods should be prefixed with <code class="Code-In-Text--PACKT-">test_</code>. Doing so allows the <code class="Code-In-Text--PACKT-">unittest</code> runner to automatically find test modules and distinguish test methods from other methods in your test case classes. </p>
    </div>
    <p class="normal">As you probably guessed, the <code class="Code-In-Text--PACKT-">TestCase</code> class represents a test case. To make our test case for <code class="Code-In-Text--PACKT-">MyCalc</code>, we have subclassed <code class="Code-In-Text--PACKT-">TestCase</code> and added a <code class="Code-In-Text--PACKT-">test_</code> method that will test some aspect of our class. Inside the <code class="Code-In-Text--PACKT-">test_add()</code> method, we created a <code class="Code-In-Text--PACKT-">MyCalc</code> object, then made an assertion about the output of <code class="Code-In-Text--PACKT-">add()</code>.</p>
    <p class="normal">At the end of the file, we've added a call to <code class="Code-In-Text--PACKT-">unittest.main()</code>, which will cause all test cases in the file to be executed.</p>
    <p class="normal">If you run your test file at the command line, you should get the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">.
---------------------------------------------------------------------
Ran 1 test in 0.000s
OK
</code></pre>
    <p class="normal">The single dot on <a id="_idIndexMarker1059"/>the first line represents our one test (<code class="Code-In-Text--PACKT-">test_add()</code>). For each test method, <code class="Code-In-Text--PACKT-">unittest.main()</code> will output one of the following:</p>
    <ul>
      <li class="bullet">A dot, which means the test passed</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">F</code>, which means it failed</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">E</code>, meaning the test caused an error</li>
    </ul>
    <p class="normal">At the end, we get a summary of what happened, including the number of tests run and how long it took. The <code class="Code-In-Text--PACKT-">OK</code> indicates that all tests passed successfully.</p>
    <p class="normal">To see what happens when a test fails, let's alter our test so that it intentionally fails:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_add</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
  mc = mycalc.MyCalc(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
  <span class="hljs-keyword">assert</span> mc.add() == <span class="code-highlight"><strong class="hljs-slc">12</strong></span>
</code></pre>
    <p class="normal">Now when you run the test module, you should see output like this:</p>
    <pre class="programlisting con"><code class="hljs-con">F
=====================================================================
FAIL: test_add (__main__.TestMyCalc)
---------------------------------------------------------------------Traceback (most recent call last):
File "test_mycalc.py", line 8, in test_add
assert mc.add() == 12
AssertionError
---------------------------------------------------------------------Ran 1 test in 0.000s
FAILED (failures=1)
</code></pre>
    <p class="normal">Note the single <code class="Code-In-Text--PACKT-">F</code> at the top, representing our failed test. After all the tests have run, we get the full traceback of any failed tests, so that we can easily locate the failing code and correct it.</p>
    <p class="normal">This traceback output isn't very ideal, though; we can see that <code class="Code-In-Text--PACKT-">mc.add()</code> didn't return <code class="Code-In-Text--PACKT-">12</code>, but we don't know <a id="_idIndexMarker1060"/>what it <em class="italic">did</em> return. We could add a comment string to our <code class="Code-In-Text--PACKT-">assert</code> call, but <code class="Code-In-Text--PACKT-">unittest</code> provides a nicer approach: <code class="Code-In-Text--PACKT-">TestCase</code> assertion methods.</p>
    <h3 id="_idParaDest-286" class="title">TestCase assertion methods</h3>
    <p class="normal"><code class="Code-In-Text--PACKT-">TestCase</code> objects have a number of assertion methods that provide a cleaner and more robust way to <a id="_idIndexMarker1061"/>run various tests on our code output.</p>
    <p class="normal">For example, there is the <code class="Code-In-Text--PACKT-">TestCase.assertEqual()</code> method to test equality, which we can use as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_add</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    mc = mycalc.MyCalc(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
    <span class="code-highlight"><strong class="hljs-slc">self.assertEqual(mc.add(), 12)</strong></span>
</code></pre>
    <p class="normal">When we run our test case with this code, you can see that the traceback is improved:</p>
    <pre class="programlisting con"><code class="hljs-con">Traceback (most recent call last):
File "test_mycalc.py", line 11, in test_add
self.assertEqual(mc.add(), 12)
AssertionError: 11 != 12
</code></pre>
    <p class="normal">Now, we can see the value that <code class="Code-In-Text--PACKT-">mc.add()</code> returned, which is much more helpful for debugging. <code class="Code-In-Text--PACKT-">TestCase</code> contains more than 20 assertion methods that can simplify testing for a variety of conditions such as class inheritance, raised exceptions, and sequence membership.</p>
    <p class="normal">Some more commonly used ones are listed in the following table:</p>
    <table id="table001-7" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Method</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Tests</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">assertEqual(a</code>,<code class="Code-In-Text--PACKT-"> b)</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">a</code> <code class="Code-In-Text--PACKT-">==</code> <code class="Code-In-Text--PACKT-">b</code></p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">assertTrue(a)</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">a</code> <code class="Code-In-Text--PACKT-">is</code> <code class="Code-In-Text--PACKT-">True</code></p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">assertFalse(a)</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">a</code> <code class="Code-In-Text--PACKT-">is</code> <code class="Code-In-Text--PACKT-">False</code></p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">assertIn(item</code>,<code class="Code-In-Text--PACKT-"> sequence)</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">item</code> <code class="Code-In-Text--PACKT-">in</code> <code class="Code-In-Text--PACKT-">sequence</code></p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">assertRaises(exception</code>,<code class="Code-In-Text--PACKT-"> callable</code>,<code class="Code-In-Text--PACKT-"> *args)</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">callable</code> raises <code class="Code-In-Text--PACKT-">exception</code> when called with <code class="Code-In-Text--PACKT-">args</code></p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">assertGreater(a</code>,<code class="Code-In-Text--PACKT-"> b)</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">a</code> is greater than <code class="Code-In-Text--PACKT-">b</code></p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">assertLess(a</code>,<code class="Code-In-Text--PACKT-"> b)</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">a</code> is less than <code class="Code-In-Text--PACKT-">b</code></p>
          </td>
        </tr>
      </tbody>
    </table>
    <div class="note">
      <p class="Information-Box--PACKT-">A full list of <a id="_idIndexMarker1062"/>the available assertion methods can be found in the <code class="Code-In-Text--PACKT-">unittest</code> documentation at <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase"><span class="url">https://docs.python.org/3/library/unittest.html#unittest.TestCase</span></a>.</p>
    </div>
    <p class="normal">Let's use an assertion method to test that <code class="Code-In-Text--PACKT-">mod_divide()</code> raises a <code class="Code-In-Text--PACKT-">ValueError</code> exception when <code class="Code-In-Text--PACKT-">b</code> is <code class="Code-In-Text--PACKT-">0</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_mod_divide</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    mc = mycalc.MyCalc(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
    self.assertRaises(ValueError, mc.mod_divide)
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">assertRaises()</code> <em class="italic">passes</em> if the function raises the given exception when called. If we need to pass any <a id="_idIndexMarker1063"/>arguments into the tested function, they can be specified as additional arguments to <code class="Code-In-Text--PACKT-">assertRaises()</code>.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">assertRaises()</code> can also be used as a context manager like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_mod_divide</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    mc = mycalc.MyCalc(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">with</span> self.assertRaises(ValueError):
      mc.mod_divide()
</code></pre>
    <p class="normal">This code accomplishes the exact same thing, but is a little clearer and more flexible, since it allows us to put multiple lines of code in the block.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">You can easily add your own custom assertion methods to your test case as well; it's simply a matter of creating a method that raises an <code class="Code-In-Text--PACKT-">AssertionError</code> exception under some condition.</p>
    </div>
    <h3 id="_idParaDest-287" class="title">Fixtures</h3>
    <p class="normal">It should be clear that each test in our test case is going to need access to a <code class="Code-In-Text--PACKT-">MyCalc</code> object. It would be <a id="_idIndexMarker1064"/>nice if we didn't have to do this manually in each test method. To help us avoid this tedious task, the <code class="Code-In-Text--PACKT-">TestCase</code> object offers a <code class="Code-In-Text--PACKT-">setUp()</code> method. This method is run before every test case is run, and by overriding it we can take care of any setup that needs to be done for each test.</p>
    <p class="normal">For example, we can use it to create <code class="Code-In-Text--PACKT-">MyCalc</code> objects, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">setUp</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.mycalc1_0 = mycalc.MyCalc(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
    self.mycalc36_12 = mycalc.MyCalc(<span class="hljs-number">36</span>, <span class="hljs-number">12</span>)
</code></pre>
    <p class="normal">Now, every test case can use these objects to run its tests rather than creating their own. Understand that the <code class="Code-In-Text--PACKT-">setUp()</code> method will be rerun before <em class="italic">every</em> test, so these objects will always <a id="_idIndexMarker1065"/>be reset between test methods. If we have items that need to be cleaned up after each test, we can override the <code class="Code-In-Text--PACKT-">tearDown()</code> method as well, which is run after each test (in this case, it's not necessary).</p>
    <p class="normal">Now that we have a <code class="Code-In-Text--PACKT-">setUp()</code> method, our <code class="Code-In-Text--PACKT-">test_add()</code> method can be much simpler:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_add</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.assertEqual(self.mycalc1_0.add(), <span class="hljs-number">1</span>)
    self.assertEqual(self.mycalc36_12.add(), <span class="hljs-number">48</span>)
</code></pre>
    <p class="normal">In addition to the instance methods <code class="Code-In-Text--PACKT-">setUp()</code> and <code class="Code-In-Text--PACKT-">tearDown()</code>, <code class="Code-In-Text--PACKT-">TestCase</code> also has class methods for setup and tear-down of the object itself as well; these are <code class="Code-In-Text--PACKT-">setUpClass()</code> and <code class="Code-In-Text--PACKT-">tearDownClass()</code>. These two methods can be used for slower operations that can be run when the test case is created and destroyed, rather than needing to be refreshed between each test; for example, you might use them to create complex objects that are required for your tests, but won't be altered by any of them.</p>
    <h3 id="_idParaDest-288" class="title">Using Mock and patch</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">MyCalc.rand_between()</code> method generates a random number between <code class="Code-In-Text--PACKT-">a</code> and <code class="Code-In-Text--PACKT-">b</code>. Because we can't possibly <a id="_idIndexMarker1066"/>predict its output, we can't provide a fixed value to <a id="_idIndexMarker1067"/>test it against. How can we test this method?</p>
    <p class="normal">A naive approach might look something like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_rand_between</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
  rv = self.mycalc1_0.rand_between()
  self.assertLessEqual(rv, <span class="hljs-number">1</span>)
  self.assertGreaterEqual(rv, <span class="hljs-number">0</span>)
</code></pre>
    <p class="normal">This test passes if our code is correct, but it doesn't necessarily fail if the code is wrong; in fact, if the code is wrong, it may pass or fail unpredictably since the return value of <code class="Code-In-Text--PACKT-">rand_between()</code> is random. For example, if <code class="Code-In-Text--PACKT-">MyCalc(1,10).rand_between()</code> was incorrectly returning values between 2 and 11, the test would pass if it returned 2 through 10, and only fail if it returned 11. Thus, even though the code is wrong, there would be only a 10% chance that the test would fail on each run of the test suite.</p>
    <p class="normal">For the purposes of our tests, we can safely assume that a standard library function such as <code class="Code-In-Text--PACKT-">random()</code> works correctly; so our unit test should really test whether <em class="italic">our</em> method correctly handles the number provided to it by <code class="Code-In-Text--PACKT-">random()</code>. If we could temporarily replace <code class="Code-In-Text--PACKT-">random()</code> with a function that returns a predictable fixed value, it would be simple to test the correctness of our subsequent calculations.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">unittest.mock</code> module provides us with the <code class="Code-In-Text--PACKT-">Mock</code> class for this purpose. <code class="Code-In-Text--PACKT-">Mock</code> objects can be used <a id="_idIndexMarker1068"/>to predictably simulate the behavior of another class, method, or <a id="_idIndexMarker1069"/>library. We can give our <code class="Code-In-Text--PACKT-">Mock</code> objects return values, side effects, properties, methods, and other features needed to fake the behavior of another class, object, function, or module, then drop them in place before running our tests.</p>
    <p class="normal">To see this in action, let's create a fake <code class="Code-In-Text--PACKT-">random()</code> function using <code class="Code-In-Text--PACKT-">Mock</code>, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> Mock
  <span class="hljs-comment">#... inside TestMyCalc</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_rand_between</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    fakerandom = Mock(return_value=<span class="hljs-number">.5</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Mock</code> object's <code class="Code-In-Text--PACKT-">return_value</code> argument allows us to hard-code a value to be returned whenever it's called as a function. Here, our mock object <code class="Code-In-Text--PACKT-">fakerandom</code> will behave like a function that always returns <code class="Code-In-Text--PACKT-">0.5</code>.</p>
    <p class="normal">Now we can put <code class="Code-In-Text--PACKT-">fakerandom</code> in place of <code class="Code-In-Text--PACKT-">random()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-comment">#...</span>
    orig_random = mycalc.random.random
    mycalc.random.random = fakerandom
    rv = self.mycalc1_0.rand_between()
    self.assertEqual(rv, <span class="hljs-number">0.5</span>)
    mycalc.random.random = orig_random
</code></pre>
    <p class="normal">We start by saving a reference to <code class="Code-In-Text--PACKT-">mycalc.random.random</code> before replacing it. Note that we're specifically replacing <em class="italic">only</em> the version of <code class="Code-In-Text--PACKT-">random</code> being used in <code class="Code-In-Text--PACKT-">mycalc.py</code> so that we don't affect calls to <code class="Code-In-Text--PACKT-">random()</code> anywhere else. It's a best practice to be as specific as possible when patching libraries to avoid unforeseen side effects.</p>
    <p class="normal">With <code class="Code-In-Text--PACKT-">fakerandom</code> in place, we can call <code class="Code-In-Text--PACKT-">rand_between()</code> and test the output. Because <code class="Code-In-Text--PACKT-">fakerandom()</code> will always return <code class="Code-In-Text--PACKT-">0.5</code>, we know that the answer when <code class="Code-In-Text--PACKT-">a</code> is <code class="Code-In-Text--PACKT-">1</code> and <code class="Code-In-Text--PACKT-">b</code> is <code class="Code-In-Text--PACKT-">0</code> should be <code class="Code-In-Text--PACKT-">(0.5 × 1 + 0) = 0.5</code>. Any other value would indicate an error in our algorithm. At the end of the test code, we revert <code class="Code-In-Text--PACKT-">random</code> to the original standard library function so that other tests (or the classes or functions they call) don't accidentally use the mock.</p>
    <p class="normal">Having to store or revert the original library each time is an annoyance we can do without, so <code class="Code-In-Text--PACKT-">unittest.mock</code> provides a cleaner approach using <code class="Code-In-Text--PACKT-">patch()</code>. The <code class="Code-In-Text--PACKT-">patch()</code> function can be used <a id="_idIndexMarker1070"/>as either a context manager or a decorator, and either approach <a id="_idIndexMarker1071"/>makes patching a <code class="Code-In-Text--PACKT-">Mock</code> object into our code much cleaner.</p>
    <p class="normal">Swapping in <code class="Code-In-Text--PACKT-">fakerandom()</code> using <code class="Code-In-Text--PACKT-">patch()</code> as a context manager looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_mycalc.py</span>
<span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> patch
<span class="hljs-comment">#... inside TestMyCalc</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_rand_between</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">with</span> patch(<span class="hljs-string">'mycalc.random.random'</span>) <span class="hljs-keyword">as</span> fakerandom:
      fakerandom.return_value = <span class="hljs-number">0.5</span>
      rv = self.mycalc1_0.rand_between()
      self.assertEqual(rv, <span class="hljs-number">0.5</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">patch()</code> command takes an import path string and provides us with a new <code class="Code-In-Text--PACKT-">Mock</code> object that it has patched in place of the object at that path. Inside the context manager block, we can set methods and properties on the <code class="Code-In-Text--PACKT-">Mock</code> object, then run our actual tests. The patched function will be reverted to its original version when the block ends.</p>
    <p class="normal">Using <code class="Code-In-Text--PACKT-">patch()</code> as a decorator is similar:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">  @patch(</span><span class="hljs-string">'mycalc.random.random'</span><span class="hljs-meta">)</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_rand_between2</span><span class="hljs-function">(</span><span class="hljs-params">self, fakerandom</span><span class="hljs-function">):</span>
    fakerandom.return_value = <span class="hljs-number">0.5</span>
    rv = self.mycalc1_0.rand_between()
    self.assertEqual(rv, <span class="hljs-number">0.5</span>)
</code></pre>
    <p class="normal">In this case, the <code class="Code-In-Text--PACKT-">Mock</code> object created by <code class="Code-In-Text--PACKT-">patch()</code> is passed as an argument to our test method and will remain patched for the duration of the decorated function. This approach works well if we plan to use the mock multiple times in a test method.</p>
    <h3 id="_idParaDest-289" class="title">Running multiple unit tests</h3>
    <p class="normal">While we can run our unit tests by including a call to <code class="Code-In-Text--PACKT-">unittest.main()</code> at the end of the file, that approach doesn't <a id="_idIndexMarker1072"/>scale well. As our application grows, we're going to write many test files, which we'll want to run in groups or all at once.</p>
    <p class="normal">Fortunately, <code class="Code-In-Text--PACKT-">unittest</code> can discover and run all tests in a project with one command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ python -m unittest
</code></pre>
    <p class="normal">So long as you have <a id="_idIndexMarker1073"/>followed the recommended naming scheme of prefixing your test modules with <code class="Code-In-Text--PACKT-">test_</code>, running this command in your project's root directory should run all your test scripts.</p>
    <h1 id="_idParaDest-290" class="title">Testing Tkinter code</h1>
    <p class="normal">Testing Tkinter code presents us with a few particular challenges. First, Tkinter handles many callbacks and methods asynchronously, meaning that we can't count on the results of some <a id="_idIndexMarker1074"/>code to be apparent immediately. Also, testing GUI behaviors often relies on external factors such as window management or visual cues that our tests cannot detect.</p>
    <p class="normal">In this section, we're going to learn some tools and strategies to address these issues and help you craft tests for your Tkinter code.</p>
    <h2 id="_idParaDest-291" class="title">Managing asynchronous code</h2>
    <p class="normal">Whenever you interact with a Tkinter UI – whether it's clicking a button, typing in a field, or raising a <a id="_idIndexMarker1075"/>window, for example – the response is not executed immediately in place.</p>
    <p class="normal">Instead, these actions are placed in a sort of to-do list, called an <strong class="keyword">event queue</strong>, to be handled later while <a id="_idIndexMarker1076"/>code execution continues. While these actions seem instant to users, test code cannot count on a requested action being completed before the next line of code is run.</p>
    <p class="normal">To solve this problem, Tkinter widgets have some methods that allow us to manage the event queue:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">wait_visibility()</code>: This method causes the code to wait until a widget is fully drawn on-screen before executing the next line of code.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">update_idletasks()</code>: This method forces Tkinter to process any idle tasks currently outstanding on the widget. Idle tasks are low-priority tasks such as drawing and rendering.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">update()</code>: This method forces Tkinter to process all events that are outstanding on a widget, including calling callbacks, redraws, and geometry management. It includes everything that <code class="Code-In-Text--PACKT-">update_idletasks()</code> does and more.</li>
    </ul>
    <div class="note">
      <p class="Information-Box--PACKT-">The event queue will be discussed in more detail in <em class="chapterRef">Chapter 14</em>, <em class="italic">Asynchronous Programming with Thread and Queue</em>.</p>
    </div>
    <h2 id="_idParaDest-292" class="title">Simulating user actions</h2>
    <p class="normal">When automating GUI tests, we may wish to know what happens when a user clicks on a certain widget, or types <a id="_idIndexMarker1077"/>a certain keystroke. When these actions happen in the GUI, Tkinter generates an <code class="Code-In-Text--PACKT-">Event</code> object for the widget and passes it to the event queue. We can do the same thing in code, using a widget's <code class="Code-In-Text--PACKT-">event_generate()</code> method.</p>
    <h3 id="_idParaDest-293" class="title">Specifying an event sequence</h3>
    <p class="normal">As we learned in <em class="chapterRef">Chapter 6</em>, <em class="italic">Planning for the Expansion of Our Application</em>, we can cause an event to be registered <a id="_idIndexMarker1078"/>on a widget by passing an event <strong class="keyword">sequence string</strong> to <code class="Code-In-Text--PACKT-">event_generate()</code> in the format <code class="Code-In-Text--PACKT-">&lt;EventModifier-EventType-EventDetail&gt;</code>. Let's look at sequence <a id="_idIndexMarker1079"/>strings in more detail.</p>
    <p class="normal">The core part of a sequence string is the <strong class="keyword">event type</strong>. It specifies the kind of event we're sending, such as <a id="_idIndexMarker1080"/>a keystroke, mouse click, windowing event, and so on.</p>
    <p class="normal">Tkinter has around 30 event types, but you will typically only need to work with the following:</p>
    <table id="table002-7" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Event types</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Action represented</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">ButtonPress</code> or <code class="Code-In-Text--PACKT-">Button</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Mouse-button click</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">ButtonRelease</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Lifting off a mouse button</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">KeyPress</code> or <code class="Code-In-Text--PACKT-">Key</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Pressing a keyboard key</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">KeyRelease</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Lifting off a keyboard key</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">FocusIn</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Giving focus to a widget, such as a button or input widget</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">FocusOut</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Exiting a focused widget</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Enter</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The mouse cursor entering a widget</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Leave</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The mouse cursor moving off a widget</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Configure</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A change in the widget's configuration, for example, a <code class="Code-In-Text--PACKT-">config()</code> call, or the user resizing the window, and so on</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal"><strong class="keyword">Event modifiers</strong> are optional words that can alter the event type; for example, <code class="Code-In-Text--PACKT-">Control</code>, <code class="Code-In-Text--PACKT-">Alt</code>, and <code class="Code-In-Text--PACKT-">Shift</code> can be used to indicate that one of those modifier keys is held down; <code class="Code-In-Text--PACKT-">Double</code> or <code class="Code-In-Text--PACKT-">Triple</code> can be used with <code class="Code-In-Text--PACKT-">Button</code> to indicate a double- or triple-click of the described button. Multiple modifiers can be strung together if required.</p>
    <p class="normal"><strong class="keyword">Event detail</strong>, only valid for keyboard or mouse events, describes which key or button was pressed. For example, <code class="Code-In-Text--PACKT-">&lt;Button-1&gt;</code> refers to the left mouse button, while <code class="Code-In-Text--PACKT-">&lt;Button-3&gt;</code> refers to <a id="_idIndexMarker1081"/>the right. For letter and number keys, the literal letter or number can be used, such as <code class="Code-In-Text--PACKT-">&lt;Control-KeyPress-a&gt;</code>; most symbols, however, are described by a word (<code class="Code-In-Text--PACKT-">minus</code>, <code class="Code-In-Text--PACKT-">colon</code>, <code class="Code-In-Text--PACKT-">semicolon</code>, and so on) to avoid syntactic clashes.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">For button presses and keypresses, the event type is technically optional; for example, you could use <code class="Code-In-Text--PACKT-">&lt;Control-a&gt;</code> instead of <code class="Code-In-Text--PACKT-">&lt;Control-KeyPress-a&gt;</code>. However, it's probably a good idea to leave it in for the sake of clarity. For example, <code class="Code-In-Text--PACKT-">&lt;1&gt;</code> is a valid event, but does it refer to pressing the left mouse button or the <span class="keyStroke">1</span> key? You may be surprised to find that it's the mouse button.</p>
    </div>
    <p class="normal">The following table <a id="_idIndexMarker1082"/>shows some examples of valid event sequences:</p>
    <table id="table003-6" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Sequence</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Meaning</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">&lt;Double-Button-3&gt;</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Double-clicking the right mouse button</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">&lt;Alt-KeyPress-exclam&gt;</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Holding <span class="keyStroke">Alt</span> and typing an exclamation point</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">&lt;Control-Alt-Key-m&gt;</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Holding <span class="keyStroke">Control</span> and <span class="keyStroke">Alt</span> and pressing the <span class="keyStroke">M</span> key</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">&lt;KeyRelease-minus&gt;</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Lifting off a pressed minus key</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">In addition to the sequence, we can pass other arguments to <code class="Code-In-Text--PACKT-">event_generate()</code> that describe various aspects of the event. Many of these are redundant, but, in some cases, we need to provide extra information for the event to have any meaning; for example, mouse button events need to include an <code class="Code-In-Text--PACKT-">x</code> and a <code class="Code-In-Text--PACKT-">y</code> argument that specify the coordinates of the click.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Single brackets around a sequence indicate a built-in event type. Double brackets are <a id="_idIndexMarker1083"/>used for custom events, such as those we have been <a id="_idIndexMarker1084"/>using in our main menu and elsewhere.</p>
    </div>
    <h2 id="_idParaDest-294" class="title">Managing focus and grab</h2>
    <p class="normal"><strong class="keyword">Focus</strong> refers to the widget or window <a id="_idIndexMarker1085"/>that is currently receiving keyboard input. Widgets can also <strong class="keyword">grab focus</strong>, preventing mouse <a id="_idIndexMarker1086"/>movements or keystrokes outside their bounds.</p>
    <p class="normal">Tkinter gives us these widget methods for managing focus and grab, some of which are useful for running tests:</p>
    <table id="table004-4" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Method</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Description</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">focus_set()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Focuses the widget whenever its window next gains focus</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">focus_force()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Focuses a widget and the window it's in, immediately</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">grab_set()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The widget grabs all events for the application</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">grab_set_global()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The widget grabs all screen events</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">grab_release()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The widget relinquishes its grab</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">In a test environment, we can use these methods to make sure that our generated keyboard and mouse events are going to the correct widget or window. </p>
    <p class="normal">Most of the time the <code class="Code-In-Text--PACKT-">focus_set()</code> method will be adequate, but depending on the behavior of your application and your operating system's windowing environment, you may need the more extreme enforcement of <code class="Code-In-Text--PACKT-">focus_force()</code> or <code class="Code-In-Text--PACKT-">grab_set()</code>.</p>
    <h2 id="_idParaDest-295" class="title">Getting widget information</h2>
    <p class="normal">Tkinter widgets have a set of <code class="Code-In-Text--PACKT-">winfo_</code> methods that give us access to information about the widget. While the <a id="_idIndexMarker1087"/>available functionality leaves much to be desired, these methods include some information we can use in tests to provide feedback about the state of a given widget.</p>
    <p class="normal">The following are a few <code class="Code-In-Text--PACKT-">winfo_</code> methods that we will find useful:</p>
    <table id="table005-2" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Method</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Description</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">winfo_height()</code>, <code class="Code-In-Text--PACKT-">winfo_width()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Get the height and width of the widget</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">winfo_children()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Get a list of child widgets</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">winfo_geometry()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Get the size and location of the widget</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">winfo_ismapped()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Determine whether the widget is mapped (that is, it's been added to a layout using a geometry manager)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">winfo_viewable()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Determine whether a widget is viewable (that is, it and all its parents have been mapped)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">winfo_x()</code>, <code class="Code-In-Text--PACKT-">winfo_y()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Get the <em class="italic">x</em> or <em class="italic">y</em> coordinate of the widget's top-left corner</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h1 id="_idParaDest-296" class="title">Writing tests for our application</h1>
    <p class="normal">Let's put our knowledge of <code class="Code-In-Text--PACKT-">unittest</code> and Tkinter to work and write some automated tests for our application. To get started, we <a id="_idIndexMarker1088"/>need to create a test module. Make a directory called <code class="Code-In-Text--PACKT-">test</code> inside the <code class="Code-In-Text--PACKT-">abq_data_entry</code> package, and create the customary empty <code class="Code-In-Text--PACKT-">__init__.py</code> file inside. We'll create all of our test modules inside this directory.</p>
    <h2 id="_idParaDest-297" class="title">Testing the data model</h2>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">CSVModel</code> class is fairly self-contained apart from its need to read and write files. We'll need to mock out this functionality so that the tests don't disturb the filesystem. Since file operations <a id="_idIndexMarker1089"/>are one of the more common things that need to be mocked out in a test, the <code class="Code-In-Text--PACKT-">mock</code> module provides <code class="Code-In-Text--PACKT-">mock_open()</code>, a <code class="Code-In-Text--PACKT-">Mock</code> subclass ready-made to replace Python's <code class="Code-In-Text--PACKT-">open()</code> method. When called, a <code class="Code-In-Text--PACKT-">mock_open</code> object returns a mock file handle object, complete with support for the <code class="Code-In-Text--PACKT-">read()</code>, <code class="Code-In-Text--PACKT-">write()</code>, and <code class="Code-In-Text--PACKT-">readlines()</code> methods.</p>
    <p class="normal">Create a new file in the <code class="Code-In-Text--PACKT-">test</code> directory called <code class="Code-In-Text--PACKT-">test_models.py</code>. This will be our test module for our data model classes. Begin it with some module imports:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_models.py</span>
<span class="hljs-keyword">from</span> .. <span class="hljs-keyword">import</span> models
<span class="hljs-keyword">from</span> unittest <span class="hljs-keyword">import</span> TestCase
<span class="hljs-keyword">from</span> unittest <span class="hljs-keyword">import</span> mock
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
</code></pre>
    <p class="normal">In addition to the <code class="Code-In-Text--PACKT-">models</code> module, we'll need <code class="Code-In-Text--PACKT-">TestCase</code> and <code class="Code-In-Text--PACKT-">mock</code>, of course, as well as the <code class="Code-In-Text--PACKT-">Path</code> class since our <code class="Code-In-Text--PACKT-">CSVModel</code> works with <code class="Code-In-Text--PACKT-">Path</code> objects internally.</p>
    <p class="normal">Now, we'll begin a test case for the <code class="Code-In-Text--PACKT-">CSVModel</code> class, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestCSVModel</span><span class="hljs-class">(</span><span class="hljs-params">TestCase</span><span class="hljs-class">):</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">setUp</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.file1_open = mock.mock_open(
      read_data=(
        <span class="hljs-string">"Date,Time,Technician,Lab,Plot,Seed Sample,"</span>
        <span class="hljs-string">"Humidity,Light,Temperature,Equipment Fault,"</span>
        <span class="hljs-string">"Plants,Blossoms,Fruit,Min Height,Max Height,"</span>
        <span class="hljs-string">"Med Height,Notes\r\n"</span>
        <span class="hljs-string">"2021-06-01,8:00,J Simms,A,2,AX478,24.47,1.01,21.44,"</span>
        <span class="hljs-string">"False,14,27,1,2.35,9.2,5.09,\r\n"</span>
        <span class="hljs-string">"2021-06-01,8:00,J Simms,A,3,AX479,24.15,1,20.82,"</span>
        <span class="hljs-string">"False,18,49,6,2.47,14.2,11.83,\r\n"</span>
      )
    )
    self.file2_open = mock.mock_open(read_data=<span class="hljs-string">''</span>)
    self.model1 = models.CSVModel(<span class="hljs-string">'file1'</span>)
    self.model2 = models.CSVModel(<span class="hljs-string">'file2'</span>)
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">setUp()</code> method for this case, we've created two mocked data files. The first contains a CSV header and two rows of CSV data, while the second is empty. The <code class="Code-In-Text--PACKT-">mock_open</code> object's <code class="Code-In-Text--PACKT-">read_data</code> argument allows us to specify a string that will be returned when code attempts to read data from it.</p>
    <p class="normal">We've also created <a id="_idIndexMarker1090"/>two <code class="Code-In-Text--PACKT-">CSVModel</code> objects, one with a filename of <code class="Code-In-Text--PACKT-">file1</code> and the other with a filename of <code class="Code-In-Text--PACKT-">file2</code>. It's worth mentioning that there's no actual connection between our models and our <code class="Code-In-Text--PACKT-">mock_open</code> objects; the filenames given are arbitrary, since we won't actually be opening a file, and the choice of which <code class="Code-In-Text--PACKT-">mock_open</code> object we use will be made in our test methods using <code class="Code-In-Text--PACKT-">patch()</code>.</p>
    <h3 id="_idParaDest-298" class="title">Testing file reading in get_all_records()</h3>
    <p class="normal">To see how <a id="_idIndexMarker1091"/>we use these, let's start a test for the <code class="Code-In-Text--PACKT-">get_all_records()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_models.py, inside TestCSVModel</span>
<span class="hljs-meta">  @mock.patch(</span><span class="hljs-string">'abq_data_entry.models.Path.exists'</span><span class="hljs-meta">)</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_get_all_records</span><span class="hljs-function">(</span><span class="hljs-params">self, mock_path_exists</span><span class="hljs-function">):</span>
    mock_path_exists.return_value = <span class="hljs-literal">True</span>
</code></pre>
    <p class="normal">Since our filenames don't <a id="_idIndexMarker1092"/>actually exist, we're using the decorator version of <code class="Code-In-Text--PACKT-">patch()</code> to replace <code class="Code-In-Text--PACKT-">Path.exists()</code> with a mock function that always returns <code class="Code-In-Text--PACKT-">True</code>. We can later change the <code class="Code-In-Text--PACKT-">return_value</code> value property of this object if we want to test a scenario where the file doesn't exist.</p>
    <p class="normal">To run the <code class="Code-In-Text--PACKT-">get_all_records()</code> method against one of our <code class="Code-In-Text--PACKT-">mock_open</code> objects, we'll use the context manager form of <code class="Code-In-Text--PACKT-">patch()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">with</span> mock.patch(
      <span class="hljs-string">'abq_data_entry.models.open'</span>,
      self.file1_open
    ):
      records = self.model1.get_all_records()
</code></pre>
    <p class="normal">Any call to <code class="Code-In-Text--PACKT-">open()</code> in <code class="Code-In-Text--PACKT-">models.py</code> initiated by code inside this context manager block will be replaced <a id="_idIndexMarker1093"/>by our <code class="Code-In-Text--PACKT-">mock_open</code> object, and the file <a id="_idIndexMarker1094"/>handle returned will contain the <code class="Code-In-Text--PACKT-">read_data</code> string we specified.</p>
    <p class="normal">Now we can start making assertions about the records that have been returned:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_models.py, inside TestCSVModel.test_get_all_records()</span>
    self.assertEqual(<span class="hljs-built_in">len</span>(records), <span class="hljs-number">2</span>)
    self.assertIsInstance(records, <span class="hljs-built_in">list</span>)
    self.assertIsInstance(records[<span class="hljs-number">0</span>], <span class="hljs-built_in">dict</span>)
</code></pre>
    <p class="normal">Here, we're checking that <code class="Code-In-Text--PACKT-">records</code> contains two lines (since our read data contained two CSV records), that it's a <code class="Code-In-Text--PACKT-">list</code> object, and that its first member is a <code class="Code-In-Text--PACKT-">dict</code> object (or a subclass of <code class="Code-In-Text--PACKT-">dict</code>).</p>
    <p class="normal">Next, let's make sure all our fields made it through and that our Boolean conversion worked:</p>
    <pre class="programlisting code"><code class="hljs-code">    fields = (
      <span class="hljs-string">'Date'</span>, <span class="hljs-string">'Time'</span>, <span class="hljs-string">'Technician'</span>, <span class="hljs-string">'Lab'</span>, <span class="hljs-string">'Plot'</span>,
      <span class="hljs-string">'Seed Sample'</span>, <span class="hljs-string">'Humidity'</span>, <span class="hljs-string">'Light'</span>,
      <span class="hljs-string">'Temperature'</span>, <span class="hljs-string">'Equipment Fault'</span>, <span class="hljs-string">'Plants'</span>,
      <span class="hljs-string">'Blossoms'</span>, <span class="hljs-string">'Fruit'</span>, <span class="hljs-string">'Min Height'</span>, <span class="hljs-string">'Max Height'</span>,
      <span class="hljs-string">'Med Height'</span>, <span class="hljs-string">'Notes'</span>)
    <span class="hljs-keyword">for</span> field <span class="hljs-keyword">in</span> fields:
      self.assertIn(field, records[<span class="hljs-number">0</span>].keys())
    self.assertFalse(records[<span class="hljs-number">0</span>][<span class="hljs-string">'Equipment Fault'</span>])
</code></pre>
    <p class="normal">By iterating over a tuple of all our field names, we can check that all our fields are present in the <a id="_idIndexMarker1095"/>record output. Don't be afraid to use loops in a test this way to check a large amount of content quickly.</p>
    <p class="normal">A <code class="Code-In-Text--PACKT-">Mock</code> object <a id="_idIndexMarker1096"/>can do more than just stand in for another class or function; it also has its own assertion methods that can tell us if it's been called, how many times, and with what arguments.</p>
    <p class="normal">For example, we can check our <code class="Code-In-Text--PACKT-">mock_open</code> object to make sure it was called with the expected arguments:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.file1_open.assert_called_with(
      Path(<span class="hljs-string">'file1'</span>), <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">'utf-8'</span>, newline=<span class="hljs-string">''</span>
    )
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">assert_called_with()</code> takes any number of positional and keyword arguments and checks if the last call to the mock object included those exact arguments. We expected <code class="Code-In-Text--PACKT-">file1_open()</code> to be called with a <code class="Code-In-Text--PACKT-">Path</code> object containing the filename <code class="Code-In-Text--PACKT-">file1</code>, a mode of <code class="Code-In-Text--PACKT-">r</code>, a <code class="Code-In-Text--PACKT-">newline</code> set to a blank string, and an <code class="Code-In-Text--PACKT-">encoding</code> value of <code class="Code-In-Text--PACKT-">utf-8</code>. By confirming that a mocked function was called with the correct arguments, and assuming the correctness of the real function (the built-in <code class="Code-In-Text--PACKT-">open()</code> function, in this case), we can avoid having to test the actual outcome.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Note that the order in which the keyword arguments are passed does not matter for this method.</p>
    </div>
    <h3 id="_idParaDest-299" class="title">Testing file saving in save_record()</h3>
    <p class="normal">To demonstrate <a id="_idIndexMarker1097"/>how to test file-writing with <code class="Code-In-Text--PACKT-">mock_open</code>, let's <a id="_idIndexMarker1098"/>test <code class="Code-In-Text--PACKT-">save_record()</code>. Begin by creating a test method that defines some data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">  @mock.patch(</span><span class="hljs-string">'abq_data_entry.models.Path.exists'</span><span class="hljs-meta">)</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_save_record</span><span class="hljs-function">(</span><span class="hljs-params">self, mock_path_exists</span><span class="hljs-function">):</span>
    record = {
      <span class="hljs-string">"Date"</span>: <span class="hljs-string">'2021-07-01'</span>, <span class="hljs-string">"Time"</span>: <span class="hljs-string">'12:00'</span>,
      <span class="hljs-string">"Technician"</span>: <span class="hljs-string">'Test Technician'</span>, <span class="hljs-string">"Lab"</span>: <span class="hljs-string">'C'</span>,
      <span class="hljs-string">"Plot"</span>: <span class="hljs-string">'17'</span>, <span class="hljs-string">"Seed Sample"</span>: <span class="hljs-string">'test sample'</span>,
      <span class="hljs-string">"Humidity"</span>: <span class="hljs-string">'10'</span>, <span class="hljs-string">"Light"</span>: <span class="hljs-string">'99'</span>,
      <span class="hljs-string">"Temperature"</span>: <span class="hljs-string">'20'</span>, <span class="hljs-string">"Equipment Fault"</span>: <span class="hljs-literal">False</span>,
      <span class="hljs-string">"Plants"</span>: <span class="hljs-string">'10'</span>, <span class="hljs-string">"Blossoms"</span>: <span class="hljs-string">'200'</span>,
      <span class="hljs-string">"Fruit"</span>: <span class="hljs-string">'250'</span>, <span class="hljs-string">"Min Height"</span>: <span class="hljs-string">'40'</span>,
      <span class="hljs-string">"Max Height"</span>: <span class="hljs-string">'50'</span>, <span class="hljs-string">"Med Height"</span>: <span class="hljs-string">'55'</span>,
      <span class="hljs-string">"Notes"</span>: <span class="hljs-string">'Test Note\r\nTest Note\r\n'</span>
    }
    record_as_csv = (
      <span class="hljs-string">'2021-07-01,12:00,Test Technician,C,17,test sample,10,99,'</span>
      <span class="hljs-string">'20,False,10,200,250,40,50,55,"Test Note\r\nTest Note\r\n"'</span>
      <span class="hljs-string">'\r\n'</span>)
</code></pre>
    <p class="normal">This method begins <a id="_idIndexMarker1099"/>by once again mocking <code class="Code-In-Text--PACKT-">Path.exists</code> and <a id="_idIndexMarker1100"/>creating a dictionary of data, and the same data represented as a row of CSV data.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">You may be tempted to generate either the record or its expected CSV output using code, but it's always better to stick to literal values in tests; doing so makes the expectations of the test explicit and avoids logic errors in your tests.</p>
    </div>
    <p class="normal">Now, for our first test scenario, let's simulate writing to an empty but existing file by using <code class="Code-In-Text--PACKT-">file2_open</code> and <code class="Code-In-Text--PACKT-">model2</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    mock_path_exists.return_value = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">with</span> mock.patch(<span class="hljs-string">'abq_data_entry.models.open'</span>, self.file2_open):
      self.model2.save_record(record, <span class="hljs-literal">None</span>)
</code></pre>
    <p class="normal">Setting our <code class="Code-In-Text--PACKT-">mock_path_exists.return_value</code> to <code class="Code-In-Text--PACKT-">True</code> to tell our method that the file already exists, we then patch over <code class="Code-In-Text--PACKT-">open()</code> with our second <code class="Code-In-Text--PACKT-">mock_open</code> object (the one representing an empty file) and call the <code class="Code-In-Text--PACKT-">CSVModel.save_record()</code> method. Since we passed in a record with no row number (which indicates a record insert), this should result in our code trying to open <code class="Code-In-Text--PACKT-">file2</code> in append mode and writing in the CSV-formatted record.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">assert_called_with()</code> will test that assumption as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">      self.file2_open.assert_called_with(
        Path(<span class="hljs-string">'file2'</span>), <span class="hljs-string">'a'</span>, encoding=<span class="hljs-string">'utf-8'</span>, newline=<span class="hljs-string">''</span>
      )
</code></pre>
    <p class="normal">While this method can tell us that <code class="Code-In-Text--PACKT-">file2_open</code> was called with the expected parameters, how do we access its actual file handler so that we can see what was written to it?</p>
    <p class="normal">It turns out we can just call our <code class="Code-In-Text--PACKT-">mock_open</code> object and retrieve the mock file handle object, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">      file2_handle = self.file2_open()
      file2_handle.write.assert_called_with(record_as_csv)
</code></pre>
    <p class="normal">Once we have <a id="_idIndexMarker1101"/>the mock file handle (which is itself a <code class="Code-In-Text--PACKT-">Mock</code> object), we can run test methods on its <code class="Code-In-Text--PACKT-">write()</code> member to find out if it was called with <a id="_idIndexMarker1102"/>the CSV data as expected. In this case, the file handle's <code class="Code-In-Text--PACKT-">write()</code> method should have been called with the CSV-format record string.</p>
    <p class="normal">Let's do a similar set of tests, passing in a row number to simulate a record update:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">with</span> mock.patch(<span class="hljs-string">'abq_data_entry.models.open'</span>, self.file1_open):
      self.model1.save_record(record, <span class="hljs-number">1</span>)
      self.file1_open.assert_called_with(
        Path(<span class="hljs-string">'file1'</span>), <span class="hljs-string">'w'</span>, encoding=<span class="hljs-string">'utf-8'</span>
      )
</code></pre>
    <p class="normal">Checking that our update was done correctly presents a problem: <code class="Code-In-Text--PACKT-">assert_called_with()</code> only checks the <em class="italic">last</em> call made to the mock function. When we update our CSV file, the entire CSV file is updated, with one <code class="Code-In-Text--PACKT-">write()</code> call per row. We can't just check that the last call was correct; we need to make sure the <code class="Code-In-Text--PACKT-">write()</code> calls for <em class="italic">all</em> the rows were correct. To accomplish this, <code class="Code-In-Text--PACKT-">Mock</code> contains a method called <code class="Code-In-Text--PACKT-">assert_has_calls()</code>, which we can use to test the history of calls made to the object.</p>
    <p class="normal">To use it, we need to create a list of <code class="Code-In-Text--PACKT-">Call</code> objects. Each <code class="Code-In-Text--PACKT-">Call</code> object represents a call to the mock object. We create <code class="Code-In-Text--PACKT-">Call</code> objects using the <code class="Code-In-Text--PACKT-">mock.call()</code> function as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">      file1_handle = self.file1_open()
      file1_handle.write.assert_has_calls([
        mock.call(
          <span class="hljs-string">'Date,Time,Technician,Lab,Plot,Seed Sample,'</span>
          <span class="hljs-string">'Humidity,Light,Temperature,Equipment Fault,Plants,'</span>
          <span class="hljs-string">'Blossoms,Fruit,Min Height,Max Height,Med Height,Notes'</span>
          <span class="hljs-string">'\r\n'</span>),
        mock.call(
          <span class="hljs-string">'2021-06-01,8:00,J Simms,A,2,AX478,24.47,1.01,21.44,'</span>
          <span class="hljs-string">'False,14,27,1,2.35,9.2,5.09,\r\n'</span>),
        mock.call(
          <span class="hljs-string">'2021-07-01,12:00,Test Technician,C,17,test sample,'</span>
          <span class="hljs-string">'10,99,20,False,10,200,250,40,50,55,'</span>
          <span class="hljs-string">'"Test Note\r\nTest Note\r\n"\r\n'</span>)
        ])
</code></pre>
    <p class="normal">The arguments to <code class="Code-In-Text--PACKT-">mock.call()</code> represent the arguments that should have been passed to the function call, which in our cases should just be single strings of CSV row data. The list of <code class="Code-In-Text--PACKT-">Call</code> objects <a id="_idIndexMarker1103"/>we pass to <code class="Code-In-Text--PACKT-">assert_has_calls()</code> represents each call that should have been made to the mocked file handle's <code class="Code-In-Text--PACKT-">write()</code> method, <em class="italic">in order</em>. The <code class="Code-In-Text--PACKT-">assert_has_calls()</code> method's <code class="Code-In-Text--PACKT-">in_order</code> argument can also <a id="_idIndexMarker1104"/>be set to <code class="Code-In-Text--PACKT-">False</code>, in which case the order won't need to match. In our case, order matters, since a wrong order would result in a corrupt CSV file.</p>
    <h3 id="_idParaDest-300" class="title">More tests on the models</h3>
    <p class="normal">Testing the remainder of the <code class="Code-In-Text--PACKT-">CSVModel</code> class and the <code class="Code-In-Text--PACKT-">SettingsModel</code> class methods should be essentially along the same lines as these two methods. A few more tests are included in the sample code, but see if you can come up with some of your own as well.</p>
    <h2 id="_idParaDest-301" class="title">Testing our Application object</h2>
    <p class="normal">We've implemented our application as a Tk object that acts not only as a main window but also as a controller, patching together models and views defined elsewhere in the application. As you may <a id="_idIndexMarker1105"/>expect, then, <code class="Code-In-Text--PACKT-">patch()</code> is going to figure heavily into our testing code as we mock out all of those other components to isolate the <code class="Code-In-Text--PACKT-">Application</code> object.</p>
    <p class="normal">Open a new file under the <code class="Code-In-Text--PACKT-">test</code> directory called <code class="Code-In-Text--PACKT-">test_application.py</code>, and we'll begin with our imports:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_application.py</span>
<span class="hljs-keyword">from</span> unittest <span class="hljs-keyword">import</span> TestCase
<span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> patch
<span class="hljs-keyword">from</span> .. <span class="hljs-keyword">import</span> application
</code></pre>
    <p class="normal">Now, let's begin our test case class like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestApplication</span><span class="hljs-class">(</span><span class="hljs-params">TestCase</span><span class="hljs-class">):</span>
  records = [
    {<span class="hljs-string">'Date'</span>: <span class="hljs-string">'2018-06-01'</span>, <span class="hljs-string">'Time'</span>: <span class="hljs-string">'8:00'</span>, <span class="hljs-string">'Technician'</span>: <span class="hljs-string">'J Simms'</span>,
     <span class="hljs-string">'Lab'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'Plot'</span>: <span class="hljs-string">'1'</span>, <span class="hljs-string">'Seed Sample'</span>: <span class="hljs-string">'AX477'</span>,
     <span class="hljs-string">'Humidity'</span>: <span class="hljs-string">'24.09'</span>, <span class="hljs-string">'Light'</span>: <span class="hljs-string">'1.03'</span>, <span class="hljs-string">'Temperature'</span>: <span class="hljs-string">'22.01'</span>,
     <span class="hljs-string">'Equipment Fault'</span>: <span class="hljs-literal">False</span>,  <span class="hljs-string">'Plants'</span>: <span class="hljs-string">'9'</span>, <span class="hljs-string">'Blossoms'</span>: <span class="hljs-string">'21'</span>,
     <span class="hljs-string">'Fruit'</span>: <span class="hljs-string">'3'</span>, <span class="hljs-string">'Max Height'</span>: <span class="hljs-string">'8.7'</span>, <span class="hljs-string">'Med Height'</span>: <span class="hljs-string">'2.73'</span>,
     <span class="hljs-string">'Min Height'</span>: <span class="hljs-string">'1.67'</span>, <span class="hljs-string">'Notes'</span>: <span class="hljs-string">'\n\n'</span>,
    },
    {<span class="hljs-string">'Date'</span>: <span class="hljs-string">'2018-06-01'</span>, <span class="hljs-string">'Time'</span>: <span class="hljs-string">'8:00'</span>, <span class="hljs-string">'Technician'</span>: <span class="hljs-string">'J Simms'</span>,
     <span class="hljs-string">'Lab'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'Plot'</span>: <span class="hljs-string">'2'</span>, <span class="hljs-string">'Seed Sample'</span>: <span class="hljs-string">'AX478'</span>,
     <span class="hljs-string">'Humidity'</span>: <span class="hljs-string">'24.47'</span>, <span class="hljs-string">'Light'</span>: <span class="hljs-string">'1.01'</span>, <span class="hljs-string">'Temperature'</span>: <span class="hljs-string">'21.44'</span>,
     <span class="hljs-string">'Equipment Fault'</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">'Plants'</span>: <span class="hljs-string">'14'</span>, <span class="hljs-string">'Blossoms'</span>: <span class="hljs-string">'27'</span>,
     <span class="hljs-string">'Fruit'</span>: <span class="hljs-string">'1'</span>, <span class="hljs-string">'Max Height'</span>: <span class="hljs-string">'9.2'</span>, <span class="hljs-string">'Med Height'</span>: <span class="hljs-string">'5.09'</span>,
     <span class="hljs-string">'Min Height'</span>: <span class="hljs-string">'2.35'</span>, <span class="hljs-string">'Notes'</span>: <span class="hljs-string">''</span>
     }
  ]
  settings = {
    <span class="hljs-string">'autofill date'</span>: {<span class="hljs-string">'type'</span>: <span class="hljs-string">'bool'</span>, <span class="hljs-string">'value'</span>: <span class="hljs-literal">True</span>},
    <span class="hljs-string">'autofill sheet data'</span>: {<span class="hljs-string">'type'</span>: <span class="hljs-string">'bool'</span>, <span class="hljs-string">'value'</span>: <span class="hljs-literal">True</span>},
    <span class="hljs-string">'font size'</span>: {<span class="hljs-string">'type'</span>: <span class="hljs-string">'int'</span>, <span class="hljs-string">'value'</span>: <span class="hljs-number">9</span>},
    <span class="hljs-string">'font family'</span>: {<span class="hljs-string">'type'</span>: <span class="hljs-string">'str'</span>, <span class="hljs-string">'value'</span>: <span class="hljs-string">''</span>},
    <span class="hljs-string">'theme'</span>: {<span class="hljs-string">'type'</span>: <span class="hljs-string">'str'</span>, <span class="hljs-string">'value'</span>: <span class="hljs-string">'default'</span>}
  }
</code></pre>
    <p class="normal">As our <code class="Code-In-Text--PACKT-">TestApplication</code> class will be using mocks in place of our data and settings models, we've created some class properties here to store samples of the data that <code class="Code-In-Text--PACKT-">Application</code> expects to <a id="_idIndexMarker1106"/>retrieve from those models. The <code class="Code-In-Text--PACKT-">setUp()</code> method is going to patch out all the external classes with mocks, configure the mocked models to return our sample data, and then create an <code class="Code-In-Text--PACKT-">Application</code> instance that our tests can use.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that while the Boolean values in the test records are <code class="Code-In-Text--PACKT-">bool</code> objects, the numeric values are strings. This is actually how <code class="Code-In-Text--PACKT-">CSVModel</code> returns the data, since no actual data type conversion is done at this point in the model.</p>
    </div>
    <p class="normal">Now, let's create our <code class="Code-In-Text--PACKT-">setUp()</code> method, which looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_application.py, inside TestApplication class</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">setUp</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">with</span> \
      patch(
        <span class="hljs-string">'abq_data_entry.application.m.CSVModel'</span>
      ) <span class="hljs-keyword">as</span> csvmodel,\
      patch(
        <span class="hljs-string">'abq_data_entry.application.m.SettingsModel'</span>
      ) <span class="hljs-keyword">as</span> settingsmodel,\
      patch(
       <span class="hljs-string">'abq_data_entry.application.Application._show_login'</span>
      ) <span class="hljs-keyword">as</span> show_login,\
      patch(<span class="hljs-string">'abq_data_entry.application.v.DataRecordForm'</span>),\
      patch(<span class="hljs-string">'abq_data_entry.application.v.RecordList'</span>),\
      patch(<span class="hljs-string">'abq_data_entry.application.ttk.Notebook'</span>),\
      patch(<span class="hljs-string">'abq_data_entry.application.get_main_menu_for_os'</span>)\
    :
      show_login.return_value = <span class="hljs-literal">True</span>
      settingsmodel().fields = self.settings
      csvmodel().get_all_records.return_value = self.records
      self.app = application.Application()
</code></pre>
    <p class="normal">Here, we've created a <code class="Code-In-Text--PACKT-">with</code> block using seven <code class="Code-In-Text--PACKT-">patch()</code> context managers, one for each class, method, or function that we're mocking out, including:</p>
    <ul>
      <li class="bullet">The CSV and Settings models. These have been patched out with aliases, so that we can configure them to return the appropriate data.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">show_login()</code> method, whose return value we hard-code to <code class="Code-In-Text--PACKT-">True</code> so login will always succeed. Note that if we were going to write full test coverage of this class, we'd want <a id="_idIndexMarker1107"/>to test this function too, but for now we'll just mock it out.</li>
      <li class="bullet">The record form and record list classes, since we don't want issues in those classes to cause errors in our <code class="Code-In-Text--PACKT-">Application</code> test code. Those classes will have their own test cases, so we aren't interested in testing them in this case. We don't need to configure anything about them, so we have not aliased these mock objects.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Notebook</code> class. Without mocking this, we'd be passing <code class="Code-In-Text--PACKT-">Mock</code> objects to its <code class="Code-In-Text--PACKT-">add()</code> method, causing an unnecessary error. We can assume Tkinter classes work correctly, so we mock this out.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">get_main_menu_for_os</code> class, since we don't want to deal with an actual menu object. Like the record form and record list, our menu classes will have their own test cases, so we are better off just taking them out of the equation here.</li>
    </ul>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Since Python 3.2, you can create a block with multiple context managers by separating each context manager call with a comma. Unfortunately, in Python 3.9 or lower, you can't put them in parentheses, so we're using the comparatively ugly escaped-newline method of breaking this gigantic call into multiple lines. If you're using Python 3.10 or later, you can use parentheses around your list of context managers for a cleaner layout.</p>
    </div>
    <p class="normal">Notice that we're creating instances of our <code class="Code-In-Text--PACKT-">settingsmodel</code> and <code class="Code-In-Text--PACKT-">csvmodel</code> objects and configuring methods on the <em class="italic">return values</em> from the mock objects rather than the mocks themselves. Remember that our mocks are replacing the <em class="italic">classes</em>, not the <em class="italic">objects</em>, and it is the objects that will contain the methods our <code class="Code-In-Text--PACKT-">Application</code> object will be calling. Therefore, we need to call <a id="_idIndexMarker1108"/>the mocked classes to access the actual <code class="Code-In-Text--PACKT-">Mock</code> object that will be used by <code class="Code-In-Text--PACKT-">Application</code> as the data or settings model.</p>
    <p class="normal">Unlike the actual class that it stands in for, a <code class="Code-In-Text--PACKT-">Mock</code> object called as a function will return the same object every time it's called. Thus, we don't have to save a reference to the object created by calling a mocked class; we can just call the mocked class repeatedly to access that object. Note, however, that a unique <code class="Code-In-Text--PACKT-">Mock</code> object is created by the <code class="Code-In-Text--PACKT-">Mock</code> <em class="italic">class</em> itself each time.</p>
    <p class="normal">Because <code class="Code-In-Text--PACKT-">Application</code> is a subclass of Tk, it's a good idea for us to safely dispose of it after each use; even though we're reassigning its variable name, the Tcl/Tk object will go on existing and cause problems with our tests. To solve this, create a <code class="Code-In-Text--PACKT-">tearDown()</code> method in <code class="Code-In-Text--PACKT-">TestApplication</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">tearDown</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.app.update()
    self.app.destroy()
</code></pre>
    <p class="normal">Notice the call to <code class="Code-In-Text--PACKT-">app.update()</code>. If we don't call this before destroying <code class="Code-In-Text--PACKT-">app</code>, there may be tasks in the event queue that will try to access it after it's gone. This won't break our code, but it will clutter up our test output with error messages.</p>
    <p class="normal">Now that our fixtures are taken care of, let's write a test:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_show_recordlist</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.app._show_recordlist()
    self.app.notebook.select.assert_called_with(self.app.recordlist)
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">Application._show_recordlist()</code> contains one line of code, which is merely a call to <code class="Code-In-Text--PACKT-">self.notebook.select()</code>. Because we made <code class="Code-In-Text--PACKT-">recordlist</code> a mock object, all of its members (including <code class="Code-In-Text--PACKT-">select</code>) are also mock objects. Thus we can use the mock assertion methods to check that <code class="Code-In-Text--PACKT-">select()</code> was called and with what arguments.</p>
    <p class="normal">We can use a similar technique to check <code class="Code-In-Text--PACKT-">_populate_recordlist()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_populate_recordlist</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.app._populate_recordlist()
    self.app.model.get_all_records.assert_called()
    self.app.recordlist.populate.assert_called_with(self.records)
</code></pre>
    <p class="normal">In this case, we're also <a id="_idIndexMarker1109"/>using the <code class="Code-In-Text--PACKT-">assert_called()</code> method to see if <code class="Code-In-Text--PACKT-">CSVModel.get_all_records()</code> was called, which it should have been as part of populating the recordlist. Unlike <code class="Code-In-Text--PACKT-">assert_called_with()</code>, <code class="Code-In-Text--PACKT-">assert_called()</code> merely checks to see if a function was called, and as such is useful for functions that take no arguments.</p>
    <p class="normal">Under some circumstances, <code class="Code-In-Text--PACKT-">get_all_records()</code> can raise an exception, in which case we're supposed to show an error message box. But since we've mocked out our data model, how can we get the <code class="Code-In-Text--PACKT-">Mock</code> object to raise an exception? The solution is to use mock's <code class="Code-In-Text--PACKT-">side_effect</code> property as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.app.model.get_all_records.side_effect = Exception(
      <span class="hljs-string">'Test message'</span>
    )
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">side_effect</code> can be used to simulate more complex functionality in a mocked function or method. It can be set to a function, in which case the mock will run that function and return the results when called; it can be set to an iterable, in which case the mock will return the next item in the iterable each time it's called; or, as in this case, it can be set to an exception, which will be raised when the mock is called.</p>
    <p class="normal">Before we can use this, we'll need to patch out <code class="Code-In-Text--PACKT-">messagebox</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">with</span> patch(<span class="hljs-string">'abq_data_entry.application.messagebox'</span>):
      self.app._populate_recordlist()
      application.messagebox.showerror.assert_called_with(
        title=<span class="hljs-string">'Error'</span>, message=<span class="hljs-string">'Problem reading file'</span>,
        detail=<span class="hljs-string">'Test message'</span>
      )
</code></pre>
    <p class="normal">This time when we call <code class="Code-In-Text--PACKT-">_populate_recordlist()</code>, our mocked <code class="Code-In-Text--PACKT-">CSVModel</code> object raises an exception, which should result in the method calling <code class="Code-In-Text--PACKT-">messagebox.showerror()</code>. Since we've mocked <code class="Code-In-Text--PACKT-">showerror()</code>, we can assert that it was called with the expected arguments using <code class="Code-In-Text--PACKT-">assert_called_with()</code>.</p>
    <p class="normal">Clearly, the hardest part of testing our <code class="Code-In-Text--PACKT-">Application</code> object is patching in all the mocked components and making sure they behave enough like the real thing to satisfy <code class="Code-In-Text--PACKT-">Application</code>. Once we've done that, writing the actual tests is fairly straightforward.</p>
    <h2 id="_idParaDest-302" class="title">Testing our widgets</h2>
    <p class="normal">So far, we've done well testing our components with <code class="Code-In-Text--PACKT-">patch()</code>, <code class="Code-In-Text--PACKT-">Mock</code>, and the default <code class="Code-In-Text--PACKT-">TestCase</code> class, but testing our widgets module is going to present some new challenges. To begin with, our widgets will need a Tk instance to be their root window. We can create this in <a id="_idIndexMarker1110"/>each case's <code class="Code-In-Text--PACKT-">setUp()</code> method, but this will slow down the tests considerably, and it isn't really necessary to do it over and over again: our tests aren't going to modify the root window, so one root window will suffice for each test case. To keep things running at a reasonable pace, we can take advantage of the <code class="Code-In-Text--PACKT-">setUpClass()</code> method to create a single instance of Tk just once when the test case instance is created.</p>
    <p class="normal">Secondly, we have a large number of widgets to test, each of which will need its own <code class="Code-In-Text--PACKT-">TestCase</code> class. As a result, we'll need to create a large number of test cases requiring this same Tk setup and tear down. To address this, we'll create a custom <code class="Code-In-Text--PACKT-">TestCase</code> base class to handle the root window setup and tear-down, then subclass it for each of our widget test cases. Open a new file under the <code class="Code-In-Text--PACKT-">test</code> directory called <code class="Code-In-Text--PACKT-">test_widgets.py</code>, and begin with this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py</span>
<span class="hljs-keyword">from</span> .. <span class="hljs-keyword">import</span> widgets
<span class="hljs-keyword">from</span> unittest <span class="hljs-keyword">import</span> TestCase
<span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> Mock
<span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk
<span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> ttk
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TkTestCase</span><span class="hljs-class">(</span><span class="hljs-params">TestCase</span><span class="hljs-class">):</span>
  <span class="hljs-string">"""A test case designed for Tkinter widgets and views"""</span>
<span class="hljs-meta">  @classmethod</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">setUpClass</span><span class="hljs-function">(</span><span class="hljs-params">cls</span><span class="hljs-function">):</span>
    cls.root = tk.Tk()
    cls.root.wait_visibility()
<span class="hljs-meta">  @classmethod</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">tearDownClass</span><span class="hljs-function">(</span><span class="hljs-params">cls</span><span class="hljs-function">):</span>
    cls.root.update()
    cls.root.destroy()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">setUpClass()</code> method creates the Tk object and calls <code class="Code-In-Text--PACKT-">wait_visibility()</code> just to make sure the root window is visible and completely drawn before our tests start working with it. We've also supplied a complementary tear-down method that updates the Tk instance (to finish out any events in the queue) and destroys it.</p>
    <p class="normal">Now, for each widget test case, we will subclass <code class="Code-In-Text--PACKT-">TkTestCase</code> to ensure we have a proper testing environment for the widget.</p>
    <h3 id="_idParaDest-303" class="title">Unit testing the ValidatedSpinbox widget</h3>
    <p class="normal"><code class="Code-In-Text--PACKT-">ValidatedSpinbox</code> is one<a id="_idIndexMarker1111"/> of the more complicated widgets we created for our application, so it's a <a id="_idIndexMarker1112"/>good place to start writing tests.</p>
    <p class="normal">Subclass the <code class="Code-In-Text--PACKT-">TkTestCase</code> class to create a test case for <code class="Code-In-Text--PACKT-">ValidatedSpinbox</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestValidatedSpinbox</span><span class="hljs-class">(</span><span class="hljs-params">TkTestCase</span><span class="hljs-class">):</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">setUp</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.value = tk.DoubleVar()
    self.vsb = widgets.ValidatedSpinbox(
      self.root,
      textvariable=self.value,
      from_=-<span class="hljs-number">10</span>, to=<span class="hljs-number">10</span>, increment=<span class="hljs-number">1</span>
    )
    self.vsb.pack()
    self.vsb.wait_visibility()
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">tearDown</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.vsb.destroy()
</code></pre>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">setUp()</code> method creates a control variable in which to store the widget's value, then creates an instance of the <code class="Code-In-Text--PACKT-">ValidatedSpinbox</code> widget with some basic settings: a minimum value of <code class="Code-In-Text--PACKT-">-10</code>, a maximum of <code class="Code-In-Text--PACKT-">10</code>, and an increment of <code class="Code-In-Text--PACKT-">1</code>. After creating it, we pack it and wait for it to become visible. For our tear-down method, we simply destroy the widget.</p>
    <p class="normal">Now, let's begin writing tests. We'll start with a unit test of the <code class="Code-In-Text--PACKT-">_key_validate()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_key_validate</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):
      x = <span class="hljs-built_in">str</span>(x)
      p_valid = self.vsb._key_validate(x, <span class="hljs-string">'end'</span>, <span class="hljs-string">''</span>, x, <span class="hljs-string">'1'</span>)
      n_valid = self.vsb._key_validate(x, <span class="hljs-string">'end'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'-'</span> + x, <span class="hljs-string">'1'</span>)
      self.assertTrue(p_valid)
      self.assertTrue(n_valid)
</code></pre>
    <p class="normal">In this test, we're simply iterating from 0 to 9 and testing both the positive and negative of the number against <code class="Code-In-Text--PACKT-">_key_validate()</code>, which should return <code class="Code-In-Text--PACKT-">True</code> for all of these values.</p>
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">_key_validate()</code> method takes a lot of positional arguments, and most of them are redundant; it might be <a id="_idIndexMarker1113"/>nice to have a wrapper method that makes it easier<a id="_idIndexMarker1114"/> to call, since a proper test of this function will likely need to call it dozens of times.</p>
    <p class="normal">Let's call that method <code class="Code-In-Text--PACKT-">key_validate()</code> and add it to our <code class="Code-In-Text--PACKT-">TestValidatedSpinbox</code> class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">key_validate</span><span class="hljs-function">(</span><span class="hljs-params">self, new, current=</span><span class="hljs-string">''</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">return</span> self.vsb._key_validate(
      new,  <span class="hljs-comment"># inserted char</span>
      <span class="hljs-string">'end'</span>,  <span class="hljs-comment"># position to insert</span>
      current,  <span class="hljs-comment"># current value</span>
      current + new,  <span class="hljs-comment"># proposed value</span>
      <span class="hljs-string">'1'</span>  <span class="hljs-comment"># action code (1 == insert)</span>
    )
</code></pre>
    <p class="normal">This will make future calls to the method shorter and less error-prone. Let's use this method now to test some invalid input, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_key_validate_letters</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    valid = self.key_validate(<span class="hljs-string">'a'</span>)
    self.assertFalse(valid)
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_key_validate_increment</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    valid = self.key_validate(<span class="hljs-string">'1'</span>, <span class="hljs-string">'0.'</span>)
    self.assertFalse(valid)
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_key_validate_high</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    valid = self.key_validate(<span class="hljs-string">'0'</span>, <span class="hljs-string">'10'</span>)
    self.assertFalse(valid))
</code></pre>
    <p class="normal">In the first example, we're entering the letter <code class="Code-In-Text--PACKT-">a</code>; in the second, a <code class="Code-In-Text--PACKT-">1</code> character when <code class="Code-In-Text--PACKT-">0.</code> is already in the box (resulting in a proposed value of <code class="Code-In-Text--PACKT-">0.1</code>); in the third, a <code class="Code-In-Text--PACKT-">0</code> character when <code class="Code-In-Text--PACKT-">10</code> is in the box (resulting in a proposed value of <code class="Code-In-Text--PACKT-">100</code>). All of these scenarios should fail the validation method, causing it to return <code class="Code-In-Text--PACKT-">False</code>.</p>
    <h3 id="_idParaDest-304" class="title">Integration testing the ValidatedSpinbox widget</h3>
    <p class="normal">In the preceding tests, we weren't actually entering any data into the widget; we were simply calling the key validation method directly and evaluating its output. This is good unit testing, but as <a id="_idIndexMarker1115"/>a test of our widget's functionality it isn't very<a id="_idIndexMarker1116"/> satisfying, is it? Since our custom widget is so deeply interactive with Tkinter's validation API, we'd like to test that we've actually interfaced with this API correctly. After all, <em class="italic">that</em> aspect of the code was more challenging than the actual logic in our validation methods.</p>
    <p class="normal">We can accomplish this by creating some integration tests that simulate actual user actions and then check the results of those actions. To do this cleanly, we'll first need to create some supporting methods.</p>
    <p class="normal">First of all, we'll need a way to simulate typing text into the widget. Let's start a new <code class="Code-In-Text--PACKT-">type_in_widget()</code> method in the <code class="Code-In-Text--PACKT-">TkTestCase</code> class that will do this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py, in TkTestCase</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">type_in_widget</span><span class="hljs-function">(</span><span class="hljs-params">self, widget, string</span><span class="hljs-function">):</span>
    widget.focus_force()
</code></pre>
    <p class="normal">The first thing this method does is force the focus to the widget; recall that <code class="Code-In-Text--PACKT-">focus_force()</code> gives the widget focus even if the containing window is not in focus; we need to use this because our test Tk window is unlikely to be in focus when the test is being run.</p>
    <p class="normal">Once we have focus, we'll need to iterate through the characters in the string and translate the raw character into the appropriate key symbols for our event sequence. Recall that some characters, particularly symbols, must be represented as name strings, such as <code class="Code-In-Text--PACKT-">minus</code> or <code class="Code-In-Text--PACKT-">colon</code>. To make this work, we'll need a way to translate between characters and their key symbols. We can do this with a dictionary added as a class property, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py, in TkTestCase</span>
  keysyms = {
    <span class="hljs-string">'-'</span>: <span class="hljs-string">'minus'</span>,
    <span class="hljs-string">' '</span>: <span class="hljs-string">'space'</span>,
    <span class="hljs-string">':'</span>: <span class="hljs-string">'colon'</span>,
  }
</code></pre>
    <p class="normal">More key symbols can be found at <a href="http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm"><span class="url">http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm</span></a>, but these should do for now. Let's finish the <code class="Code-In-Text--PACKT-">type_in_widget()</code> method like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py, in TkTestCase.type_in_widget()</span>
    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> string:
      char = self.keysyms.get(char, char)
      widget.event_generate(<span class="hljs-string">f'&lt;KeyPress-</span><span class="hljs-subst">{char}</span><span class="hljs-string">&gt;'</span>)
      self.root.update_idletasks()
</code></pre>
    <p class="normal">In this loop, we start by checking to see if our <code class="Code-In-Text--PACKT-">char</code> value has a name string in <code class="Code-In-Text--PACKT-">keysyms</code>. Then we generate <a id="_idIndexMarker1117"/>a <code class="Code-In-Text--PACKT-">KeyPress</code> event on the widget with the given<a id="_idIndexMarker1118"/> character or key symbol. Note that we call <code class="Code-In-Text--PACKT-">self.root.update_idletasks()</code> after generating the keypress event. This ensures that the typed characters register after being generated.</p>
    <p class="normal">In addition to simulating keyboard input, we'll need to be able to simulate mouse clicks. We can create a similar method, <code class="Code-In-Text--PACKT-">click_on_widget()</code>, for simulating mouse button clicks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">click_on_widget</span><span class="hljs-function">(</span><span class="hljs-params">self, widget, x, y, button=</span><span class="hljs-number">1</span><span class="hljs-function">):</span>
    widget.focus_force()
    widget.event_generate(<span class="hljs-string">f'&lt;ButtonPress-</span><span class="hljs-subst">{button}</span><span class="hljs-string">&gt;'</span>, x=x, y=y)
    self.root.update_idletasks()
</code></pre>
    <p class="normal">This method takes a widget, an <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code> coordinate for the click, and optionally a mouse button that will be clicked (defaulting to <code class="Code-In-Text--PACKT-">1</code>, which is the left mouse button). Just as we did with our keystroke method, we first force focus, generate our events, then update the application. The <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code> coordinates for the mouse click specify where the widget is clicked, relative to its upper-left corner.</p>
    <p class="normal">With these methods in place, return to the <code class="Code-In-Text--PACKT-">TestValidatedSpinbox</code> class and write a new test:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py, in TestValidatedSpinbox</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test__key_validate_integration</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.vsb.delete(<span class="hljs-number">0</span>, <span class="hljs-string">'end'</span>)
    self.type_in_widget(self.vsb, <span class="hljs-string">'10'</span>)
    self.assertEqual(self.vsb.get(), <span class="hljs-string">'10'</span>)
</code></pre>
    <p class="normal">This method starts by clearing the widget, then simulates some valid input with <code class="Code-In-Text--PACKT-">type_in_widget()</code>. Then we retrieve the value from the widget using <code class="Code-In-Text--PACKT-">get()</code>, checking that it matches the expected value. Note that in these integration tests we'll need to clear the <a id="_idIndexMarker1119"/>widget each time because we are simulating keystrokes<a id="_idIndexMarker1120"/> in an actual widget and triggering all the side effects of that action.</p>
    <p class="normal">Next, let's test some invalid input; add the following to the test method:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.vsb.delete(<span class="hljs-number">0</span>, <span class="hljs-string">'end'</span>)
    self.type_in_widget(self.vsb, <span class="hljs-string">'abcdef'</span>)
    self.assertEqual(self.vsb.get(), <span class="hljs-string">''</span>)
    self.vsb.delete(<span class="hljs-number">0</span>, <span class="hljs-string">'end'</span>)
    self.type_in_widget(self.vsb, <span class="hljs-string">'200'</span>)
    self.assertEqual(self.vsb.get(), <span class="hljs-string">'2'</span>)
</code></pre>
    <p class="normal">This time, we've simulated typing non-numeric or out-of-range values into the widget and check the widget to make sure it has properly rejected the invalid keystrokes. In the first example, the <code class="Code-In-Text--PACKT-">ValidatedSpinbox</code> should reject all the keystrokes since they are letters; in the second, only the initial <code class="Code-In-Text--PACKT-">2</code> should be accepted since the subsequent <code class="Code-In-Text--PACKT-">0</code> keystrokes would put the number out of range.</p>
    <p class="normal">We can use our mouse click method to test the functionality of the <code class="Code-In-Text--PACKT-">ValidatedSpinbox</code> widget's arrow buttons as well. To make this simpler, we could create a helper method in our test case class to click on the arrow we want. Of course, to click a particular arrow, we have to figure out how to locate that element within the widget.</p>
    <p class="normal">One approach would be to just estimate a hard-coded number of pixels. In most default themes, the arrows are on the right side of the box, and the box is about 20 pixels high. So, something like this method could work:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py, inside TestValidatedSpinbox</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">click_arrow_naive</span><span class="hljs-function">(</span><span class="hljs-params">self, arrow=</span><span class="hljs-string">'inc'</span><span class="hljs-params">, times=</span><span class="hljs-number">1</span><span class="hljs-function">):</span>
    x = self.vsb.winfo_width() – <span class="hljs-number">5</span>
    y = <span class="hljs-number">5</span> <span class="hljs-keyword">if</span> arrow == <span class="hljs-string">'inc'</span> <span class="hljs-keyword">else</span> <span class="hljs-number">15</span>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(times):
      self.click_on_widget(self.vsb, x=x, y=y)
</code></pre>
    <p class="normal">This approach actually works fairly well and may be sufficient for your needs. However, it's a little brittle as it makes assumptions about your theme and screen resolution. For more complex custom widgets, you may have a hard time locating elements this way. What would be better is a way to find the actual coordinates of widget elements.</p>
    <p class="normal">Unfortunately, Tkinter widgets don't offer us a way to locate the <em class="italic">x</em> and <em class="italic">y</em> coordinates of elements within a widget; Ttk elements, however, do offer us a way to see which element is at <a id="_idIndexMarker1121"/>a given set of coordinates, using the <code class="Code-In-Text--PACKT-">identify()</code> method. Using<a id="_idIndexMarker1122"/> this, we can write a method that scans through a widget looking for a particular element and returns the first set of <em class="italic">x</em> and <em class="italic">y</em> coordinates where it can be found.</p>
    <p class="normal">Let's add this as a static method to the <code class="Code-In-Text--PACKT-">TkTestCase</code> class, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py, inside TkTestCase</span>
<span class="hljs-meta">  @staticmethod</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">find_element</span><span class="hljs-function">(</span><span class="hljs-params">widget, element</span><span class="hljs-function">):</span>
    widget.update_idletasks()
    x_coords = <span class="hljs-built_in">range</span>(widget.winfo_width())
    y_coords = <span class="hljs-built_in">range</span>(widget.winfo_height())
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> x_coords:
      <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> y_coords:
        <span class="hljs-keyword">if</span> widget.identify(x, y) == element:
          <span class="hljs-keyword">return</span> (x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">f'</span><span class="hljs-subst">{element}</span><span class="hljs-string"> was not found in widget'</span>)
</code></pre>
    <p class="normal">The method begins by updating the widget's idle tasks. Without this call, it's possible that all the elements are not yet drawn, and <code class="Code-In-Text--PACKT-">identify()</code> will return an empty string. Next, we get a list of all the <em class="italic">x</em> and <em class="italic">y</em> coordinates in the widget by passing its width and height into the <code class="Code-In-Text--PACKT-">range()</code> function. We iterate through these lists, calling <code class="Code-In-Text--PACKT-">widget.identify()</code> on each pixel coordinate in the widget. If the returned element name matches the element name we're looking for, we return the current coordinates as a tuple. If we make it all the way through the widget without returning, we raise an exception stating that the element was not found.</p>
    <p class="normal">Note that we add 1 to each of the <em class="italic">x</em> and <em class="italic">y</em> coordinates; that's because this element returns the upper-left corner coordinate of the widget. In some cases, clicking on these corner coordinates doesn't register as a click on the widget. To be sure we're actually clicking <em class="italic">in</em> the widget, we return coordinates 1 pixel right and down from the corner.</p>
    <p class="normal">Of course, there's a snag here: what is the name of the element we're looking for? Recall from <em class="chapterRef">Chapter 9</em>, <em class="italic">Improving the Look with Styles and Themes</em>, that the elements that compose a widget are determined by the theme, and that different themes may have completely different elements. For example, if you're looking for the increment arrow element, the default theme on Windows calls it <code class="Code-In-Text--PACKT-">Spinbox.uparrow</code>. The default theme on Linux, however, calls it simply <code class="Code-In-Text--PACKT-">uparrow</code>, and the default theme on macOS doesn't even have a separate element for it (both arrows are a single element called <code class="Code-In-Text--PACKT-">Spinbox.spinbutton</code>)!</p>
    <p class="normal">To address this, we need to force<a id="_idIndexMarker1123"/> our test window to a specific theme so that we can rely on the <a id="_idIndexMarker1124"/>names being consistent. In the <code class="Code-In-Text--PACKT-">TestValidatedSpinbox.setUp()</code> method, we'll add some code to force an explicit theme:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py, inside TestValidatedSpinbox.setUp()</span>
    ttk.Style().theme_use(<span class="hljs-string">'classic'</span>)
    self.vsb.update_idletasks()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">classic</code> theme should be available on all platforms, and it uses the simple element names <code class="Code-In-Text--PACKT-">uparrow</code> and <code class="Code-In-Text--PACKT-">downarrow</code> for the <code class="Code-In-Text--PACKT-">Spinbox</code> arrow elements. We've added a call to <code class="Code-In-Text--PACKT-">update_idletasks()</code> to make sure the theme changes have taken effect in the widget before our tests start.</p>
    <p class="normal">Now, we can write a better <code class="Code-In-Text--PACKT-">click_arrow()</code> method for <code class="Code-In-Text--PACKT-">TestValidatedSpinbox</code> that relies on element names instead of hard-coded pixel values. Add this method to the class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py, inside TestValidatedSpinbox</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">click_arrow</span><span class="hljs-function">(</span><span class="hljs-params">self, arrow, times=</span><span class="hljs-number">1</span><span class="hljs-function">):</span>
    element = <span class="hljs-string">f'</span><span class="hljs-subst">{arrow}</span><span class="hljs-string">arrow'</span>
    x, y = self.find_element(self.vsb, element)
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(times):
      self.click_on_widget(self.vsb, x=x, y=y)
</code></pre>
    <p class="normal">Just as with our naive version, this method takes an arrow direction and a number of times. We use the arrow direction to build an element name, then use our <code class="Code-In-Text--PACKT-">find_element()</code> method to locate the appropriate arrow inside the <code class="Code-In-Text--PACKT-">ValidatedSpinbox</code> widget. Once we have the coordinates, we can use the <code class="Code-In-Text--PACKT-">click_on_widget()</code> method we wrote to click on it.</p>
    <p class="normal">Let's put this method to work and test our arrow key functionality in a new test method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py, inside TestValidatedSpinbox</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_arrows</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.value.<span class="hljs-built_in">set</span>(<span class="hljs-number">0</span>)
    self.click_arrow(<span class="hljs-string">'up'</span>, times=<span class="hljs-number">1</span>)
    self.assertEqual(self.vsb.get(), <span class="hljs-string">'1'</span>)
    self.click_arrow(<span class="hljs-string">'up'</span>, times=<span class="hljs-number">5</span>)
    self.assertEqual(self.vsb.get(), <span class="hljs-string">'6'</span>)
    self.click_arrow(arrow=<span class="hljs-string">'down'</span>, times=<span class="hljs-number">1</span>)
    self.assertEqual(self.vsb.get(), <span class="hljs-string">'5'</span>)
</code></pre>
    <p class="normal">By setting the <a id="_idIndexMarker1125"/>value of the widget, then clicking the appropriate<a id="_idIndexMarker1126"/> arrow a specified number of times, we can test that the arrows did their jobs according to the rules we created in our widget class.</p>
    <h2 id="_idParaDest-305" class="title">Testing our mixin class</h2>
    <p class="normal">One additional challenge we haven't approached yet is testing our mixin class. Unlike our other widget classes, our mixin cannot really exist on its own: it depends on methods and <a id="_idIndexMarker1127"/>properties found in the Ttk widget with which it's combined.</p>
    <p class="normal">One approach to testing this class would be to mix it with a <code class="Code-In-Text--PACKT-">Mock</code> object that mocks out any inherited methods. This approach has merit, but a simpler (if less theoretically pure) approach is to subclass it with the simplest possible <code class="Code-In-Text--PACKT-">Ttk</code> widget and test the resulting child class.</p>
    <p class="normal">We'll create a test case that uses the latter approach. Start it in <code class="Code-In-Text--PACKT-">test_widgets.py</code>, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># test_widgets.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestValidatedMixin</span><span class="hljs-class">(</span><span class="hljs-params">TkTestCase</span><span class="hljs-class">):</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">setUp</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestClass</span><span class="hljs-class">(</span><span class="hljs-params">widgets.ValidatedMixin, ttk.Entry</span><span class="hljs-class">):</span>
      <span class="hljs-keyword">pass</span>
    self.vw1 = TestClass(self.root)
</code></pre>
    <p class="normal">Here, the <code class="Code-In-Text--PACKT-">setUp()</code> method creates just a basic child class of <code class="Code-In-Text--PACKT-">ValidatedMixin</code> and <code class="Code-In-Text--PACKT-">ttk.Entry</code> with no other modifications, then creates an instance of it.</p>
    <p class="normal">Now let's write a test case for the <code class="Code-In-Text--PACKT-">_validate()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test__validate</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    args = {
      <span class="hljs-string">'proposed'</span>: <span class="hljs-string">'abc'</span>,
      <span class="hljs-string">'current'</span>: <span class="hljs-string">'ab'</span>,
      <span class="hljs-string">'char'</span>: <span class="hljs-string">'c'</span>,
      <span class="hljs-string">'event'</span>: <span class="hljs-string">'key'</span>,
      <span class="hljs-string">'index'</span>: <span class="hljs-string">'2'</span>,
      <span class="hljs-string">'action'</span>: <span class="hljs-string">'1'</span>
    }
    self.assertTrue(
      self.vw1._validate(**args)
    )
</code></pre>
    <p class="normal">Because we're sending a key event to <code class="Code-In-Text--PACKT-">_validate()</code>, it routes the request to <code class="Code-In-Text--PACKT-">_key_validate()</code>, which <a id="_idIndexMarker1128"/>simply returns <code class="Code-In-Text--PACKT-">True</code> by default. We'll need to verify that <code class="Code-In-Text--PACKT-">_validate()</code> does what is needed when <code class="Code-In-Text--PACKT-">_key_validate()</code> returns <code class="Code-In-Text--PACKT-">False</code> as well.</p>
    <p class="normal">We'll employ <code class="Code-In-Text--PACKT-">Mock</code> to do this:</p>
    <pre class="programlisting code"><code class="hljs-code">    fake_key_val = Mock(return_value=<span class="hljs-literal">False</span>)
    self.vw1._key_validate = fake_key_val
    self.assertFalse(
      self.vw1._validate(**args)
    )
    fake_key_val.assert_called_with(**args)
</code></pre>
    <p class="normal">By testing that <code class="Code-In-Text--PACKT-">False</code> is returned and that <code class="Code-In-Text--PACKT-">_key_validate()</code> was called with the correct arguments, we've demonstrated that <code class="Code-In-Text--PACKT-">_validate()</code> is properly routing events to the right validation methods.</p>
    <p class="normal">By updating the <code class="Code-In-Text--PACKT-">event</code> value in args, we can check that focus-out events also work:</p>
    <pre class="programlisting code"><code class="hljs-code">    args[<span class="hljs-string">'event'</span>] = <span class="hljs-string">'focusout'</span>
    self.assertTrue(self.vw1._validate(**args))
    fake_focusout_val = Mock(return_value=<span class="hljs-literal">False</span>)
    self.vw1._focusout_validate = fake_focusout_val
    self.assertFalse(self.vw1._validate(**args))
    fake_focusout_val.assert_called_with(event=<span class="hljs-string">'focusout'</span>)
</code></pre>
    <p class="normal">We've taken an identical approach here, just mocking out <code class="Code-In-Text--PACKT-">_focusout_validate()</code> to make it return <code class="Code-In-Text--PACKT-">False</code>.</p>
    <p class="normal">As you can see, once we've <a id="_idIndexMarker1129"/>created our test class, testing <code class="Code-In-Text--PACKT-">ValidatedMixin</code> is like testing any other widget class. There are other test method examples in the included source code; these should be enough to get you started with creating a complete test suite.</p>
    <h1 id="_idParaDest-306" class="title">Summary</h1>
    <p class="normal">In this chapter, you learned about the benefits of automated testing and the capabilities provided by Python's <code class="Code-In-Text--PACKT-">unittest</code> library. You learned how to isolate units of code by using <code class="Code-In-Text--PACKT-">Mock</code> and <code class="Code-In-Text--PACKT-">patch()</code> to replace external modules, classes, and functions. You learned strategies for controlling Tkinter's event queue and simulating user input to automate tests of our GUI components, and wrote both unit tests and integration tests against sections of the ABQ application.</p>
    <p class="normal">In the next chapter, we'll upgrade our backend to use a relational database. In the process, you'll learn about relational database design and data normalization. You'll also learn to work with the PostgreSQL database server and Python's <code class="Code-In-Text--PACKT-">psycopg2</code> PostgreSQL interface library.</p>
  </div>
</body></html>