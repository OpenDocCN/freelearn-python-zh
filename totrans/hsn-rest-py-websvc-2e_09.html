<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developing RESTful APIs with Pyramid 1.10</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will work with Pyramid 1.10 to create a RESTful Web API that performs CRUD operations on a simple data source. We will look at the following topics:</p>
<ul>
<li>Design a RESTful API to interact with a simple data source</li>
<li>Understand the tasks performed by each HTTP method</li>
<li>Set up the virtual environment with Pyramid 1.10</li>
<li>Create a new Pyramid project based on a template</li>
<li>Create the model</li>
<li>Use a dictionary as a repository</li>
<li>Create a Marshmallow schema to validate, serialize, and deserialize the model</li>
<li>Work with view callables and view configurations</li>
<li>Understand and configure view handlers</li>
<li>Make HTTP requests to the API with command-line tools</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing a RESTful API to interact with a simple data source</h1>
                </header>
            
            <article>
                
<p>A surfer who won dozens of international surfing competitions became a surfing coach and wants to build a new tool to help surfers train for the Olympic Games. The development team that works with the surfing coach has years of experience working with the Pyramid web framework, and therefore, he wants us to build a simple RESTful API with Pyramid to work with the data provided by an IoT board connected to multiple sensors in the surfboards.</p>
<p>Each IoT board will provide the following data:</p>
<ul>
<li><strong>Status</strong>: Many wearable wireless sensors embedded in each surfer's wetsuit and other sensors included in the surfboard will provide data, and the IoT board will perform a real-time analysis to indicate ...</li></ul></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up the virtual environment with Pyramid 1.10</h1>
                </header>
            
            <article>
                
<p>In <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservices with Flask 1.0.2</em>, we learned that, throughout this book, we were going to work with the lightweight virtual environments that were introduced and improved on in Python 3.4. Now, we will follow many steps to create a new lightweight virtual environment to work with Pyramid 1.10. It is highly recommended to read the section named <em>Working with lightweight virtual environments</em> in <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservices with Flask 1.0.2</em>, if you don't have experience with lightweight virtual environments in modern Python. This chapter includes all the detailed explanations about the effects of the steps we are going to follow.</p>
<p>The following commands assume that you have Python 3.6.6 installed on Linux, macOS, or Windows.</p>
<p>First, we have to select the target folder or directory for our lightweight virtual environment. The following is the path we will use in the example for Linux and macOS:</p>
<pre>    <strong>~/HillarPythonREST2/Pyramid01</strong>  </pre>
<p>The target folder for the virtual environment will be the <kbd>HillarPythonREST2/Pyramid01</kbd> folder within our home directory. For example, if our home directory in macOS or Linux is <kbd>/Users/gaston</kbd>, the virtual environment will be created within <kbd>/Users/gaston/HillarPythonREST2/Pyramid01</kbd>. You can replace the specified path with your desired path in each command.</p>
<p>The following is the path we will use in the example for Windows:</p>
<pre>    <strong>%USERPROFILE%\HillarPythonREST2\Pyramid01</strong></pre>
<p>The target folder for the virtual environment will be the <kbd>HillarPythonREST2\Pyramid01</kbd> folder within our user profile folder. For example, if our user profile folder is <kbd>C:\Users\gaston</kbd>, the virtual environment will be created within <kbd>C:\Users\gaston\HillarPythonREST2\Pyramid01</kbd>. Of course, you can replace the specified path with your desired path in each command.</p>
<p>In Windows PowerShell, the previous path would be the following:</p>
<pre>    <strong>$env:userprofile\HillarPythonREST2\Pyramid01</strong></pre>
<p>Now, we have to use the <kbd>-m</kbd> option followed by the <kbd>venv</kbd> module name and the desired path to make Python run this module as a script and create a virtual environment at the specified path. The instructions are different depending on the platform in which we are creating the virtual environment. Thus, make sure you follow the instructions for your operating system:</p>
<ol>
<li>Open a Terminal in Linux or macOS and execute the following command to create a virtual environment:</li>
</ol>
<pre style="padding-left: 60px"><strong>python3 -m venv ~/HillarPythonREST2/Pyramid01</strong></pre>
<ol start="2">
<li>In Windows, execute the following command in the Command Prompt to create a virtual environment:</li>
</ol>
<pre style="padding-left: 60px"><strong>python -m venv %USERPROFILE%\HillarPythonREST2\Pyramid01</strong></pre>
<ol start="3">
<li>If you want to work with Windows PowerShell, execute the following command to create a virtual environment:</li>
</ol>
<pre style="padding-left: 60px"><strong>python -m venv $env:userprofile\HillarPythonREST2\Pyramid01</strong> </pre>
<p style="padding-left: 60px">The previous commands don't produce any output. Now that we have created a virtual environment, we will run a platform-specific script to activate it. After we activate the virtual environment, we will install packages that will only be available in this virtual environment.</p>
<ol start="4">
<li>If your Terminal is configured to use the <kbd>bash</kbd> shell in macOS or Linux, run the following command to activate the virtual environment. The command also works for the <kbd>zsh</kbd> shell:</li>
</ol>
<pre style="padding-left: 60px"><strong>source ~/HillarPythonREST2/Pyramid01/bin/activate</strong></pre>
<ol start="5">
<li>If your Terminal is configured to use either the <kbd>csh</kbd> or <kbd>tcsh</kbd> shell, run the following command to activate the virtual environment:</li>
</ol>
<pre style="padding-left: 60px"><strong>source ~/HillarPythonREST2/Pyramid01/bin/activate.csh</strong>  </pre>
<ol start="6">
<li>If your Terminal is configured to use the <kbd>fish</kbd> shell, run the following command to activate the virtual environment:</li>
</ol>
<pre style="padding-left: 60px"><strong>source ~/HillarPythonREST2/Pyramid01/bin/activate.fish</strong>  </pre>
<ol start="7">
<li>In Windows, you can run either a batch file in the Command Prompt or a Windows PowerShell script to activate the virtual environment. If you prefer the Command Prompt, run the following command in the Windows command line to activate the virtual environment:</li>
</ol>
<pre style="padding-left: 60px"><strong>%USERPROFILE%\HillarPythonREST2\Pyramid01\Scripts\activate.bat</strong></pre>
<ol start="8">
<li>If you prefer Windows PowerShell, launch it and run the following commands to activate the virtual environment. However, notice that you should have script execution enabled in Windows PowerShell to be able to run the script:</li>
</ol>
<pre style="padding-left: 60px"><strong>cd $env:USERPROFILE</strong>
<strong>HillarPythonREST2\Pyramid01\Scripts\Activate.ps1</strong></pre>
<p>After you activate the virtual environment, the command prompt will display the virtual environment's root folder name, enclosed in parenthesis as a prefix of the default prompt, to remind us that we are working in the virtual environment. In this case, we will see <span class="ScreenTextPACKT0">(<kbd>Pyramid01</kbd>)</span> as a prefix for the Command Prompt because the root folder for the activated virtual environment is <kbd>Pyramid01</kbd>.</p>
<p>We have followed the necessary steps to create and activate a virtual environment. Now, we will create a <kbd>requirements.txt</kbd> file to specify the set of packages that our application requires to be installed on any supported platform. This way, it will be extremely easy to repeat the installation of the specified packages with their versions in any new virtual environment.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Use your favorite editor to create a new text file named <kbd>requirements.txt</kbd> within the root folder for the recently created virtual environment. The following lines show the contents for the file that declares the packages and the versions that our API requires. The code file for the sample is included in the <kbd>restful_python_2_11_01</kbd> folder, in the <kbd>Pyramid01/requirements.txt</kbd> file:</p>
<pre>pyramid==1.10 
cookiecutter==1.6.0 
httpie==1.0.2 </pre>
<p>Each line in the <kbd>requirements.txt</kbd> file indicates the package and the version that needs to be installed. In this case, we are working with exact versions by using the <kbd>==</kbd> operator because we want to make sure that the specified version is installed. The following table summarizes the packages and the version numbers that we specified as requirements:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Package name</p>
</td>
<td>
<p>Version to be installed</p>
</td>
</tr>
<tr>
<td>
<p><kbd>pyramid</kbd></p>
</td>
<td>
<p>1.10.1</p>
</td>
</tr>
<tr>
<td>
<p><kbd>cookiecutter</kbd></p>
</td>
<td>
<p>1.6.0</p>
</td>
</tr>
<tr>
<td>
<p><kbd>httpie</kbd></p>
</td>
<td>
<p>1.0.2</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>cookiecutter</kbd> package installs a command-line utility that makes it possible to create Pyramid projects from project templates. We will use this utility to create a basic Pyramid 1.10 project and then make the necessary changes to build our RESTful API without writing all the code from scratch. Notice that we will install additional packages later by specifying additional required packages in the Pyramid <kbd>setup.py</kbd> file.</p>
<p>Go to the root folder for the virtual environment: <kbd>Pyramid01</kbd>. In macOS or Linux, enter the following command:</p>
<pre>    <strong>cd ~/HillarPythonREST2/Pyramid01</strong></pre>
<p>In Windows Command Prompt, enter the following command:</p>
<pre>    <strong>cd /d %USERPROFILE%\HillarPythonREST2\Pyramid01</strong>
  </pre>
<p>In Windows PowerShell, enter the following command:</p>
<pre>    <strong>cd $env:USERPROFILE</strong>
    <strong>cd HillarPythonREST2\Pyramid01</strong></pre>
<p>Now, we must run the following command on macOS, Linux, or Windows to install the packages and the versions explained in the previous table with <kbd>pip</kbd> by using the recently created <kbd>requirements.txt</kbd> file. Make sure you are located in the folder that contains the <kbd>requirements.txt</kbd> file before running the command (<kbd>Pyramid01</kbd>):</p>
<pre><strong>pip install -r requirements.txt</strong> </pre>
<p>The last lines for the output will indicate that <kbd>pyramid</kbd>, <kbd>cookiecutter</kbd>, <kbd>httpie</kbd>, and their dependencies have been successfully installed:</p>
<pre><strong>Installing collected packages: translationstring, plaster, PasteDeploy, plaster-pastedeploy, zope.deprecation, venusian, zope.interface, webob, hupper, pyramid, future, six, python-dateutil, arrow, MarkupSafe, jinja2, jinja2-time, click, chardet, binaryornot, poyo, urllib3, certifi, idna, requests, whichcraft, cookiecutter, Pygments, httpie</strong>
    <strong>  Running setup.py install for future ... done</strong>
    <strong>  Running setup.py install for arrow ... done</strong>
<strong>Successfully installed MarkupSafe-1.1.0 PasteDeploy-1.5.2 Pygments-2.2.0 arrow-0.12.1 binaryornot-0.4.4 certifi-2018.10.15 chardet-3.0.4 click-7.0 cookiecutter-1.6.0 future-0.17.1 httpie-1.0.2 hupper-1.4 idna-2.7 jinja2-2.10 jinja2-time-0.2.0 plaster-1.0 plaster-pastedeploy-0.6 poyo-0.4.2 pyramid-1.10.1 python-dateutil-2.7.5 requests-2.20.0 six-1.11.0 translationstring-1.3 urllib3-1.24.1 venusian-1.1.0 webob-1.8.3 whichcraft-0.5.2 zope.deprecation-4.3.0 zope.interface-4.6.0</strong>
  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a new Pyramid project based on a template</h1>
                </header>
            
            <article>
                
<p>Now, we will generate a Pyramid project by using an app template, also known as <strong>scaffold</strong>. Notice that you need Git installed on your development computer to use the next command. You can visit the following web page for more information about Git: <a href="https://git-scm.com"><span class="URLPACKT">https://git-scm.com</span></a>.</p>
<p>Run the following command to use <kbd>cookiecutter</kbd> to generate a new project based on the <kbd>pyramid-cookiecutter-starter</kbd> template. We use the <kbd>--checkout 1.10-branch</kbd> option to use a specific branch that makes sure that the template is compatible with Pyramid 1.10:</p>
<pre><strong>cookiecutter gh:Pylons/pyramid-cookiecutter-starter --checkout 1.10-branch</strong>  </pre>
<p>The command will ask you for the project's name. Enter <kbd>metrics</kbd> and press <em><span class="KeyPACKT">Enter</span></em>. You will see a ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the model</h1>
                </header>
            
            <article>
                
<p>Now, we will create a simple <kbd>SurfboardMetricModel</kbd> class that we will use to represent metrics. Remember that we won't be persisting the model in any database or file, and therefore, in this case, our class will just provide the required attributes and no mapping information.</p>
<p>Create a new <kbd>models</kbd> subfolder within the <kbd>metrics/metrics</kbd> folder. Then, create a new <kbd>metrics.py</kbd> file in the <kbd>metrics/metrics/models</kbd> subfolder. The following lines show the code that declares the necessary imports that we will require for many classes. This will then create a <kbd>SurfboardMetricModel</kbd> class in this file. The code file for the sample is included in the <kbd>restful_python_2_09_01</kbd> folder, in the <kbd>Pyramid01/metrics/metrics/models/metrics.py</kbd> file:</p>
<pre>from enum import Enum 
from marshmallow import Schema, fields 
from marshmallow_enum import EnumField 
 
 
class SurfboardMetricModel: 
    def __init__(self, status, speed_in_mph, altitude_in_feet, water_temperature_in_f): 
        # We will automatically generate the new id 
        self.id = 0 
        self.status = status 
        self.speed_in_mph = speed_in_mph 
        self.altitude_in_feet = altitude_in_feet 
        self.water_temperature_in_f = water_temperature_in_f </pre>
<p>The <kbd>SurfboardMetricModel</kbd> class just declares a constructor; that is, the <kbd>__init__</kbd> method. This method receives many arguments and uses them to initialize the attributes with the same names: <kbd>status</kbd>, <kbd>speed_in_mph</kbd>, <kbd>altitude_in_feet</kbd>, and <kbd>water_temperature_in_f</kbd>. The <kbd>id</kbd> attribute is set to <kbd>0</kbd>. We will automatically increment the identifier for each new surfboard metric generated with an API call.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using a dictionary as a repository</h1>
                </header>
            
            <article>
                
<p>Now, we will create a <kbd>SurfboardMetricManager</kbd> class that we will use to persist the <kbd>SurfboardMetricModel</kbd> instances in an in-memory dictionary. Our API methods will call methods for the <kbd>SurfboardMetricManager</kbd> class to retrieve, insert, and delete <kbd>SurfboardMetricModel</kbd> instances.</p>
<p>Stay in the <kbd>metrics.py</kbd> file in the <kbd>metrics/metrics/models</kbd> subfolder. Add the following lines to declare the <kbd>SurfboardMetricManager</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_09_01</kbd> folder, in the <kbd>Pyramid01/metrics/metrics/models/metrics.py</kbd> file:</p>
<pre>class SurfboardMetricManager(): last_id = 0 def __init__(self): self.metrics = {} def insert_metric(self, metric): self.__class__.last_id += 1 metric.id = self.__class__.last_id ...</pre></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a Marshmallow schema to validate, serialize, and deserialize the model</h1>
                </header>
            
            <article>
                
<p>Now, we will create a simple Marshmallow schema that we will use to validate, serialize, and deserialize the previously declared <kbd>SurfboardMetricModel</kbd> model.</p>
<p>Stay in the <kbd>metrics.py</kbd> file in the <kbd>metrics/metrics/models</kbd> subfolder. Add the following lines to declare <kbd>SurferStatus Enum</kbd> and the <kbd>SurfboardMetricSchema</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_09_01</kbd> folder, in the <kbd>Pyramid01/metrics/metrics/models/metrics.py</kbd> file:</p>
<pre>class SurferStatus(Enum): 
    IDLE = 0 
    PADDLING = 1 
    RIDING = 2 
    RIDE_FINISHED = 3 
    WIPED_OUT = 4 
 
 
class SurfboardMetricSchema(Schema): 
    id = fields.Integer(dump_only=True) 
    status = EnumField(SurferStatus, required=True) 
    speed_in_mph = fields.Integer(required=True) 
    altitude_in_feet = fields.Integer(required=True) 
    water_temperature_in_f = fields.Integer(required=True) </pre>
<p>First, the code declares the <kbd>SurferStatus Enum</kbd> that we will use to map description to an integer for the surfer status. We want the users of the API to be able to specify the status as a string that matches one of the <kbd>Enum</kbd> descriptions. For example, if the user wants to create a new metric with its status set to <kbd>SurferStatus.PADDLING</kbd>, they should use <kbd>'PADDLING'</kbd> as the value for the status key in the provided JSON body.</p>
<p>Then, the code declares the <kbd>SurfboardMetricSchema</kbd> class as a subclass of the <kbd>marshmallow.Schema</kbd> class. We declare the attributes that represent fields as instances of the appropriate classes declared in the <kbd>marshmallow.fields</kbd> module. Whenever we specify the <kbd>True</kbd> value for the <kbd>dump_only</kbd> argument, it means that we want the field to be read-only. For example, we won't be able to provide a value for the <kbd>id</kbd> field in the schema. The value for this field will be automatically generated by the <kbd>SurfboardMetricManager</kbd> class.</p>
<p>The <kbd>SurfboardMetricSchema</kbd> class declares the <kbd>status</kbd> attribute as an instance of the <kbd>marshmallow_enum.EnumField</kbd> class. The <kbd>enum</kbd> argument is set to <kbd>SurferStatus</kbd> to specify that only the members of this <kbd>Enum</kbd> will be considered valid values. As a result of this setting, only a string that matches the descriptions in <kbd>SurferStatus Enum</kbd> will be accepted as a valid value for this field during deserialization. In addition, whenever this field is serialized, the string representation of the <kbd>Enum</kbd> description will be used.</p>
<p>The <kbd>speed_in_mph</kbd>, <kbd>altitude_in_feet</kbd>, and <kbd>water_temperature_in_f</kbd> attributes are instances of the <kbd>fields.Integer</kbd> class, with the <kbd>required</kbd> argument set to <kbd>True</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with view callables and view configurations</h1>
                </header>
            
            <article>
                
<p>Our RESTful API won't be using the two modules included in the <kbd>metrics/metrics/views</kbd> subfolder that was generated by the app template. Thus, we must delete the <kbd>metrics/metrics/views/default.py</kbd> and <kbd>metrics/metrics/views/notfound.py</kbd> files.</p>
<p>Pyramid uses view callables as the main building blocks for a RESTful API. Whenever a request arrives, Pyramid finds and invokes the appropriate view callable to process the request and return an appropriate response.</p>
<div class="packt_tip">View callables are callable Python objects such as functions, classes, or instances that implement a <kbd>__call__</kbd> method. Any view callable receives an argument named <kbd>request</kbd> that will provide the <kbd>pyramid.request.Request</kbd> instance that represents ...</div></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding and configuring view handlers</h1>
                </header>
            
            <article>
                
<p>The following table shows the function that we want to be executed for each combination of HTTP verb and scope, and the route name that identifies each resource:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>HTTP verb</p>
</td>
<td>
<p>Scope</p>
</td>
<td>
<p>Route name</p>
</td>
<td>
<p>Function</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of metrics</p>
</td>
<td>
<p><kbd>'metrics'</kbd></p>
</td>
<td>
<p><kbd>metrics_collection</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Metric</p>
</td>
<td>
<p><kbd>'metric'</kbd></p>
</td>
<td>
<p><kbd>metric</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Collection of metrics</p>
</td>
<td>
<p><kbd>'metrics'</kbd></p>
</td>
<td>
<p><kbd>metrics_collection</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>Metric</p>
</td>
<td>
<p><kbd>'metrics'</kbd></p>
</td>
<td>
<p><kbd>metric</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We must make the necessary resource routing configurations to call the appropriate functions, pass them all the necessary arguments by defining the appropriate routes, and match the appropriate view callable with the route.</p>
<p>First, we will check how the application template we used configures and returns a Pyramid WSGI application that will run our RESTful API. The following lines show the code for the <kbd>__init__.py</kbd> file within the <kbd>metrics/metrics</kbd> folder:</p>
<pre>from pyramid.config import Configurator 
 
 
def main(global_config, **settings): 
    """ This function returns a Pyramid WSGI application. 
    """ 
    with Configurator(settings=settings) as config: 
      <strong>  config.include('pyramid_jinja2')</strong> 
        config.include('.routes') 
        config.scan() 
    return config.make_wsgi_app() </pre>
<p>We have already removed the usage of the <kbd>jinja2</kbd> template, and therefore remove the highlighted line from the previous code. The code file for the sample is included in the <kbd>restful_python_2_09_01</kbd> folder, in the <kbd>Pyramid01/metrics/metrics/__init__.py</kbd> file.</p>
<p>The code defines a <kbd>main</kbd> function that creates a <kbd>pyramid.config.Configurator</kbd> instance named <kbd>config</kbd>, with the <kbd>settings</kbd> received as an argument. The <kbd>main</kbd> function calls the <kbd>config.include</kbd> method with <kbd>'.routes'</kbd> as an argument to include the configuration callable that accepts a single argument named <kbd>config</kbd> from the <kbd>routes</kbd> module. This callable will receive the instance of <kbd>Configurator</kbd> in the <kbd>config</kbd> argument and will be able to call its methods to perform the appropriate configuration for routes. We will replace the existing code for the <kbd>routes</kbd> module after we finish analyzing the previous code.</p>
<p>Then, the code calls the <kbd>config.scan</kbd> method to scan the Python packages and subpackages for callables that have specific decorator objects that perform configurations, such as the functions that we declared with the <kbd>@view.config</kbd> decorator.</p>
<p>Finally, the code calls the <kbd>config.make_wsgi_app</kbd> method to commit any pending configuration statements and return the Pyramid WSGI application that represent the committed configuration state. This way, Pyramid completes with the configuration process and launches the server.</p>
<p class="mce-root"/>
<p>Open the existing <kbd>routes.py</kbd> file within the <kbd>metrics/metrics</kbd> folder and replace the existing code with the following lines. The code file for the sample is included in the <kbd>restful_python_2_09_01</kbd> folder, in the <kbd>Pyramid01/metrics/metrics/routes.py</kbd> file:</p>
<pre>from metrics.views.metrics import metric, metrics_collection 
 
 
def includeme(config): 
    # Define the routes for metrics 
    config.add_route('metrics', '/metrics/') 
    config.add_route('metric', '/metrics/{id:\d+}/')         
    # Match the metrics views with the appropriate routes 
    config.add_view(metrics_collection,  
        route_name='metrics',  
        renderer='json') 
    config.add_view(metric,  
        route_name='metric',  
        renderer='json') </pre>
<p>The code defines an <kbd>includeme</kbd> function which receives the previously explained <kbd>pyramid.config.Configurator</kbd> instances in the <kbd>config</kbd> argument. First, the code calls the <kbd>config.add_route</kbd> method twice to associate the route named <kbd>'metrics'</kbd> with the <kbd>'/metrics/'</kbd> pattern and the route named <kbd>'metric'</kbd> with the <kbd>'metrics/{id:\d+}/'</kbd> pattern. Notice that the semicolon (<kbd>:</kbd>) after <kbd>id</kbd> is followed by a regular expression that makes sure that <kbd>id</kbd> is only composed of digits.</p>
<p>Then, the code calls the <kbd>config.add_view</kbd> method twice to specify the view callable <kbd>metrics_collection</kbd> as the function that must be called when the route name is equal to <kbd>'metrics'</kbd> and the view callable <kbd>metric</kbd> as the function that must be called when the route name is equal to <kbd>'metric'</kbd>. In both cases, the <kbd>config.add_view</kbd> method specifies that we want to use <kbd>'json'</kbd> as the renderer for the responses.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP requests to the API with command-line tools</h1>
                </header>
            
            <article>
                
<p>The <kbd>metrics/development.ini</kbd> file is a settings file that defines the Pyramid app and server configuration for the development environment. As happens in most <kbd>.ini</kbd> files, the configuration settings are organized in sections. For example, the <kbd>[server:main]</kbd> section specifies the value for the listen setting as <kbd>localhost:6543</kbd> to make the <kbd>waitress</kbd> server <kbd>listen</kbd> on port <kbd>6543</kbd> and bind it to the localhost address.</p>


<p>This file was included when we created a new app based on a template. Open the <kbd>metrics/development.ini</kbd> file and locate the following line that specifies the <kbd>bool</kbd> value for the <kbd>pyramid.debug_routematch</kbd> setting. The code file for the sample is included in the <kbd>restful_python_2_09_01 ...</kbd></p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>In Pyramid, view callables are which of the following?
<ol>
<li>Python objects such as functions, classes, or instances that implement a <kbd>__call__</kbd> method</li>
<li>Classes that inherit from the <kbd>pyramid.views.Callable</kbd> superclass</li>
<li>Instances of the <kbd>pyramid.views.Callable</kbd> <span>class</span></li>
</ol>
</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>The <kbd>request</kbd> argument that any view callable receives represents an HTTP request, and is an instance of which of the following classes?
<ol>
<li><kbd>pyramid.web.Request</kbd></li>
<li><kbd>pyramid.request.Request</kbd></li>
<li><kbd>pyramid.callable.Request</kbd></li>
</ol>
</li>
</ol>
<ol start="3">
<li>Which of the following attributes allows us to specify the status code for the response in a <kbd>pyramid.response.Response</kbd> instance?
<ol>
<li><kbd>status</kbd></li>
<li><kbd>http_status_code</kbd></li>
<li><kbd>status_code</kbd></li>
</ol>
</li>
</ol>
<ol start="4">
<li>Which of the following classes, declared in the <kbd>pyramid.httpexceptions</kbd> module, represent an HTTP <kbd>201 Created</kbd> status code for a response?
<ol>
<li><kbd>HTTP_201_Created</kbd></li>
<li><kbd>HTTP_Created</kbd></li>
<li><kbd>HTTPCreated</kbd></li>
</ol>
</li>
<li>Which of the following attributes allows us to specify the response body for a JSON response in a <kbd>pyramid.response.Response</kbd> instance?
<ol>
<li><kbd>json_body</kbd></li>
<li><kbd>body</kbd></li>
<li><kbd>body_as_json</kbd></li>
</ol>
</li>
</ol>
<p> </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we designed a RESTful API to interact with a simple data source with Pyramid 1.10. We defined the requirements for our API and understood the tasks performed by each HTTP method. We set up a virtual environment with Pyramid, built a new application from an existing template, and added additional required packages to the Pyramid application.</p>
<p>We created a class that represented a surfboard metric, and additional classes to make it possible to generate a simple data source to allow us to focus on specific Pyramid features to build a RESTful API.</p>
<p>We then created a Marshmallow schema to validate, serialize, and deserialize the metric model. Then, we started working with view callable functions to process specific HTTP ...</p></article></section></div>



  </body></html>