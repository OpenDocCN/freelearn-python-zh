<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 4. Using Mock Objects to Test Interactions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Using Mock Objects to Test Interactions</h1></div></div></div><p>Having looked at the <code class="literal">Rule</code> and <code class="literal">Stock</code> classes, let us now turn our attention to the <code class="literal">Event</code> class. The <code class="literal">Event</code> class is very simple: receivers can register with the event to be notified when the<a id="id158" class="indexterm"/> event occurs. When the event fires, all the receivers are notified of the event.</p><p>A more detailed description is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Event classes<a id="id159" class="indexterm"/> have a <code class="literal">connect</code> method, which takes a method or function to be called when the event fires</li><li class="listitem" style="list-style-type: disc">When the <code class="literal">fire</code> method<a id="id160" class="indexterm"/> is called, all the registered callbacks are called with the same parameters that are passed to the <code class="literal">fire</code> method</li></ul></div><p>Writing tests for the <code class="literal">connect</code> method is fairly straightforward—we just need to check that the receivers are being stored properly. But, how do we write the tests for the fire method? This method does not change any state or store any value that we can assert on. The main responsibility of this method is to call other methods. How do we test that this is being done correctly?</p><p>This is where mock objects come into the picture. Unlike ordinary unit tests that assert on object <span class="emphasis"><em>state</em></span>, mock objects are used to test that the <span class="emphasis"><em>interactions</em></span> between multiple objects occurs as it should.</p><div class="section" title="Hand writing a simple mock"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Hand writing a simple mock</h1></div></div></div><p>To start with, let<a id="id161" class="indexterm"/> us look at the code for the <code class="literal">Event</code> class so that we can understand what the tests need to do. The following code is in the file <code class="literal">event.py</code> in the source directory:</p><div class="informalexample"><pre class="programlisting">class Event:
    """A generic class that provides signal/slot functionality"""

    def __init__(self):
        self.listeners = []

    def connect(self, listener):
        self.listeners.append(listener)

    def fire(self, *args, **kwargs):
        for listener in self.listeners:
            listener(*args, **kwargs)</pre></div><p>The way this <a id="id162" class="indexterm"/>code works is fairly simple. Classes that want to get notified of the event should call the <code class="literal">connect</code> method and pass a function. This will register the function for the event. Then, when the event is fired using the <code class="literal">fire</code> method, all the registered functions will be notified of the event. The following is a walk-through of how this class is used:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; def handle_event(num):</strong></span>
<span class="strong"><strong>...   print("I got number {0}".format(num))</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; event = Event()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; event.connect(handle_event)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; event.fire(3)</strong></span>
<span class="strong"><strong>I got number 3</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; event.fire(10)</strong></span>
<span class="strong"><strong>I got number 10</strong></span>
</pre></div><p>As you can see, every time the <code class="literal">fire</code> method is called, all the functions that registered with the <code class="literal">connect</code> method get called with the given parameters.</p><p>So, how do we test the <code class="literal">fire</code> method? The walk-through above gives a hint. What we need to do is to create a function, register it using the <code class="literal">connect</code> method, and then verify that the method got notified when the <code class="literal">fire</code> method was called. The following is one way to write such a test:</p><div class="informalexample"><pre class="programlisting">import unittest
from ..event import Event

class EventTest(unittest.TestCase):
    def test_a_listener_is_notified_when_an_event_is_raised(self):
        called = False
        def listener():
            nonlocal called
            called = True

        event = Event()
        event.connect(listener)
        event.fire()
        self.assertTrue(called)</pre></div><p>Put this code<a id="id163" class="indexterm"/> into the <code class="literal">test_event.py</code> file in the tests folder and run the test. The test should pass. The following is what we are doing:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we create a variable named called and set it to <code class="literal">False</code>.</li><li class="listitem">Next, we create a dummy function. When the function is called, it sets called to <code class="literal">True</code>.</li><li class="listitem">Finally, we connect the dummy function to the event and fire the event.</li><li class="listitem">If the dummy function was successfully called when the event was fired, then the <code class="literal">called</code> variable would be changed to <code class="literal">True</code>, and we assert that the variable is indeed what we expected.</li></ol></div><p>The dummy function we created above is an example of a mock. A <span class="strong"><strong>mock</strong></span> is simply an object that is substituted for a real object in the test case. The mock then records some information such as whether it was called, what parameters were passed, and so on, and we can then assert that the mock was called as expected.</p><p>Talking about parameters, we should write a test that checks that the parameters are being passed correctly. The following is one such test:</p><div class="informalexample"><pre class="programlisting">    def test_a_listener_is_passed_right_parameters(self):
        params = ()
        def listener(*args, **kwargs):
            nonlocal params
            params = (args, kwargs)
        event = Event()
        event.connect(listener)
        event.fire(5, shape="square")
        self.assertEquals(((5, ), {"shape":"square"}), params)</pre></div><p>This test is the same as the previous one, except that it saves the parameters that are then used in the assert to verify that they were passed properly.</p><p>At this point, we can see some repetition coming up in the way we set up the mock function and then save some information about the call. We can extract this code into a separate class as follows:</p><div class="informalexample"><pre class="programlisting">class Mock:
    def __init__(self):
        self.called = False
        self.params = ()

    def __call__(self, *args, **kwargs):
        self.called = True
        self.params = (args, kwargs)</pre></div><p>Once we do this, we can use our <code class="literal">Mock</code> class in our tests as follows:</p><div class="informalexample"><pre class="programlisting">class EventTest(unittest.TestCase):
    def test_a_listener_is_notified_when_an_event_is_raised(self):
        listener = Mock()
        event = Event()
        event.connect(listener)
        event.fire()
        self.assertTrue(listener.called)

    def test_a_listener_is_passed_right_parameters(self):
        listener = Mock()
        event = Event()
        event.connect(listener)
        event.fire(5, shape="square")
        self.assertEquals(((5, ), {"shape": "square"}), listener.params)</pre></div><p>What we<a id="id164" class="indexterm"/> have just done is to create a simple mocking class that is quite lightweight and good for simple uses. However, there are often times when we need much more advanced functionality, such as mocking a series of calls or checking the order of specific calls. Fortunately, Python has us covered with the <code class="literal">unittest.mock</code> module that is supplied as a part of the standard library.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using the Python mocking framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Using the Python mocking framework</h1></div></div></div><p>The <code class="literal">unittest.mock</code> module provided by Python is an extremely powerful mocking framework, yet<a id="id165" class="indexterm"/> at the same time it is very easy to <a id="id166" class="indexterm"/>use.</p><p>Let us redo our tests using this library. First, we need to import the <code class="literal">mock</code> module at the top of our file as follows:</p><div class="informalexample"><pre class="programlisting">from unittest import mock</pre></div><p>Next, we rewrite our first test as follows:</p><div class="informalexample"><pre class="programlisting">class EventTest(unittest.TestCase):
    def test_a_listener_is_notified_when_an_event_is_raised(self):
        listener = mock.Mock()
        event = Event()
        event.connect(listener)
        event.fire()
        self.assertTrue(listener.called)</pre></div><p>The only change that we've made is to replace our own custom <code class="literal">Mock</code> class with the <code class="literal">mock.Mock</code> class provided by Python. That is it. With that single line change, our test is now using the<a id="id167" class="indexterm"/> inbuilt mocking class.</p><p>The <code class="literal">unittest.mock.Mock</code> class is the core of the Python mocking framework. All we need to do is to instantiate the class and pass it in where it is required. The mock will record if it was called in the <code class="literal">called</code> instance variable.</p><p>How do we check that the right parameters were passed? Let us look at the rewrite of the second test as follows:</p><div class="informalexample"><pre class="programlisting">    def test_a_listener_is_passed_right_parameters(self):
        listener = mock.Mock()
        event = Event()
        event.connect(listener)
        event.fire(5, shape="square")
        listener.assert_called_with(5, shape="square")</pre></div><p>The mock object automatically records the parameters that were passed in. We can assert on the parameters by using the <code class="literal">assert_called_with</code> method on the <code class="literal">mock</code> object. The method will raise an assertion error if the parameters don't match what was expected. In case we are not interested in testing the parameters (maybe we just want to check that the method was called), then we can pass the value <code class="literal">mock.ANY</code>. This value will match any parameter passed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>There is a subtle difference in the way normal assertions are called compared to assertions on mocks. Normal assertions are defined as a part of the <code class="literal">unittest.Testcase</code> class. Since our tests inherit from that class, we call the assertions on self, for example, <code class="literal">self.assertEquals</code>. On the other hand, the mock assertion methods are a part of the <code class="literal">mock</code> object, so you call them on the mock object, for example, <code class="literal">listener.assert_called_with</code>.</p></div></div><p>Mock objects have the following four assertions available out of the box:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assert_called_with</code>: This method asserts that the last call was made with the given parameters</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert_called_once_with</code>: This assertion checks that the method was called exactly once and was with the given parameters</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert_any_call</code>: This checks that the given call was made at some point during the execution</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert_has_calls</code>: This assertion checks that a list of calls occurred</li></ul></div><p>The four assertions are very subtly different, and that shows up when the mock has been called more than one. The <code class="literal">assert_called_with</code> method only checks the last call, so if there was <a id="id168" class="indexterm"/>more than one call, then the previous calls will not be asserted. The <code class="literal">assert_any_call</code> method will check if a call with the given parameters occurred anytime during execution. The <code class="literal">assert_called_once_with</code> assertion asserts for a single call, so if the mock was called more than once during execution, then this assert would fail. The <code class="literal">assert_has_calls</code> assertion can be used to assert that a set of calls with the given parameters occurred. Note that there might have been more calls than what we checked for in the assertion, but the assertion would still pass as long as the given calls are present.</p><p>Let us take a closer look at the <code class="literal">assert_has_calls</code> assertion. Here is how we can write the same test using this assertion:</p><div class="informalexample"><pre class="programlisting">    def test_a_listener_is_passed_right_parameters(self):
        listener = mock.Mock()
        event = Event()
        event.connect(listener)
        event.fire(5, shape="square")
        listener.assert_has_calls([mock.call(5, shape="square")])</pre></div><p>The mocking framework internally uses <code class="literal">_Call</code> objects to record calls. The <code class="literal">mock.call</code> function is a helper to create these objects. We just call it with the expected parameters to create the required call objects. We can then use these objects in the <code class="literal">assert_has_calls</code> assertion to assert that the expected call occurred.</p><p>This method is useful when the mock was called multiple times and we want to assert only some of the calls.</p><div class="section" title="Mocking objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Mocking objects</h2></div></div></div><p>While<a id="id169" class="indexterm"/> testing the <code class="literal">Event</code> class, we only needed to <a id="id170" class="indexterm"/>mock out single functions. A more common use of mocking is to mock a class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>The rest of this chapter builds on <code class="literal">test_driven_python-CHAPTER4_PART2</code> of the code bundle. Download it from from <a class="ulink" href="https://github.com/siddhi/test_driven_python/archive/CHAPTER4_PART2.zip">https://github.com/siddhi/test_driven_python/archive/CHAPTER4_PART2.zip</a>.</p></div></div><p>Take a look at the implementation of the <code class="literal">Alert</code> class in the following:</p><div class="informalexample"><pre class="programlisting">class Alert:
    """Maps a Rule to an Action, and triggers the action if the rule
    matches on any stock update"""

    def __init__(self, description, rule, action):
        self.description = description
        self.rule = rule
        self.action = action

    def connect(self, exchange):
        self.exchange = exchange
        dependent_stocks = self.rule.depends_on()
        for stock in dependent_stocks:
            exchange[stock].updated.connect(self.check_rule)

    def check_rule(self, stock):
        if self.rule.matches(self.exchange):
            self.action.execute(self.description)</pre></div><p>Let's<a id="id171" class="indexterm"/> break down how this class works as<a id="id172" class="indexterm"/> follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Alert</code> class takes a <code class="literal">Rule</code> and an <code class="literal">Action</code> in the initializer.</li><li class="listitem" style="list-style-type: disc">When the <code class="literal">connect</code> method is called, it takes all the dependent stocks and connects to their <code class="literal">updated</code> event.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">updated</code> event is an instance of the <code class="literal">Event</code> class that we saw earlier. Each <code class="literal">Stock</code> class has an instance of this event, and it is fired whenever a new update is made to that stock.</li><li class="listitem" style="list-style-type: disc">The listener for this event is the <code class="literal">self.check_rule</code> method of the <code class="literal">Alert</code> class.</li><li class="listitem" style="list-style-type: disc">In this method, the alert checks if the new update caused a rule to be matched.</li><li class="listitem" style="list-style-type: disc">If the rule matched, it calls the execute method on the <code class="literal">Action</code>. Otherwise, nothing happens.</li></ul></div><p>This class has a few requirements, as shown in the following, that need to be met. Each of these needs to be made into a unit test.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If a stock is updated, the class should check if the rule matches</li><li class="listitem" style="list-style-type: disc">If the rule matches, then the corresponding action should be executed</li><li class="listitem" style="list-style-type: disc">If the rule doesn't match, then nothing happens</li></ul></div><p>There are a number of different ways in which we could test this; let us go through some of the options.</p><p>The first option is not to use mocks at all. We could create a rule, hook it up to a test action, and then update the stock and verify that the action was executed. The following is what such a test would look like:</p><div class="informalexample"><pre class="programlisting">import unittest
from datetime import datetime
from unittest import mock

from ..alert import Alert
from ..rule import PriceRule
from ..stock import Stock

class TestAction:
    executed = False

    def execute(self, description):
        self.executed = True

class AlertTest(unittest.TestCase):
    def test_action_is_executed_when_rule_matches(self):
        exchange = {"GOOG": Stock("GOOG")}
        rule = PriceRule("GOOG", lambda stock: stock.price &gt; 10)
        action = TestAction()
        alert = Alert("sample alert", rule, action)
        alert.connect(exchange)
        exchange["GOOG"].update(datetime(2014, 2, 10), 11)
        self.assertTrue(action.executed)</pre></div><p>This is the <a id="id173" class="indexterm"/>most straightforward option, but it<a id="id174" class="indexterm"/> requires a bit of code to set up and there is the <code class="literal">TestAction</code> that we need to create just for the test case.</p><p>Instead of creating a test action, we could instead replace it with a mock action. We can then simply assert on the mock that it got executed. The following code shows this variation of the test case:</p><div class="informalexample"><pre class="programlisting">    def test_action_is_executed_when_rule_matches(self):
        exchange = {"GOOG": Stock("GOOG")}
        rule = PriceRule("GOOG", lambda stock: stock.price &gt; 10)
        action = mock.MagicMock()
        alert = Alert("sample alert", rule, action)
        alert.connect(exchange)
        exchange["GOOG"].update(datetime(2014, 2, 10), 11)
        action.execute.assert_called_with("sample alert")</pre></div><p>A couple of observations about this test:</p><p>If you notice, alert is not the usual <code class="literal">Mock</code> object that we have been using so far, but a <code class="literal">MagicMock</code> object. A <code class="literal">MagicMock</code> object is like a <code class="literal">Mock</code> object but it has special support for Python's magic methods which are present on all classes, such as <code class="literal">__str__</code>, <code class="literal">hasattr</code>. If we don't use <code class="literal">MagicMock</code>, we may sometimes get errors or strange behavior if the code uses any of these methods. The following example illustrates the difference:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from unittest import mock</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; mock_1 = mock.Mock()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; mock_2 = mock.MagicMock()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; len(mock_1)</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>TypeError: object of type 'Mock' has no len()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; len(mock_2)</strong></span>
<span class="strong"><strong>0</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
</pre></div><p>In general, we <a id="id175" class="indexterm"/>will be using <code class="literal">MagicMock</code> in most <a id="id176" class="indexterm"/>places where we need to mock a class. Using <code class="literal">Mock</code> is a good option when we need to mock stand alone functions, or in rare situations where we specifically don't want a default implementation for the magic methods.</p><p>The other observation about the test is the way methods are handled. In the test above, we created a mock action object, but we didn't specify anywhere that this mock class should contain an <code class="literal">execute</code> method and how it should behave. In fact, we don't need to. When a method or attribute is accessed on a mock object, Python conveniently creates a mock method and adds it to the mock class. Therefore, when the <code class="literal">Alert</code> class calls the <code class="literal">execute</code> method on our mock action object, that method is added to our mock action. We can then check that the method was called by asserting on <code class="literal">action.execute.called</code>.</p><p>The downside of Python's behavior of automatically creating mock methods when they are accessed is that a typo or change in interface can go unnoticed.</p><p>For example, suppose we rename the <code class="literal">execute</code> method in all the <code class="literal">Action</code> classes to run. But if we run our test cases, it still passes. Why does it pass? Because the <code class="literal">Alert</code> class calls the <code class="literal">execute</code> method, and the test only checks that the <code class="literal">execute</code> method was called, which it was. The test does not know that the name of the method has been changed in all the real <code class="literal">Action</code> implementations and that the <code class="literal">Alert</code> class will not work when integrated with the actual actions.</p><p>To avoid this problem, Python supports using another class or object as a specification. When a specification is given, the mock object only creates the methods that are present in the specification. All other method or attribute accesses will raise an error.</p><p>Specifications are passed to the mock at initialization time via the <code class="literal">spec</code> parameter. Both the <code class="literal">Mock</code> as well as <code class="literal">MagicMock</code> classes support setting a specification. The following code example shows the difference when a <code class="literal">spec</code> parameter is set compared to a default <code class="literal">Mock</code> object:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from unittest import mock</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; class PrintAction:</strong></span>
<span class="strong"><strong>...     def run(self, description):</strong></span>
<span class="strong"><strong>...         print("{0} was executed".format(description))</strong></span>
<span class="strong"><strong>...</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; mock_1 = mock.Mock()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; mock_1.execute("sample alert") # Does not give an error</strong></span>
<span class="strong"><strong>&lt;Mock name='mock.execute()' id='54481752'&gt;</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; mock_2 = mock.Mock(spec=PrintAction)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; mock_2.execute("sample alert") # Gives an error</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>  File "C:\Python34\lib\unittest\mock.py", line 557, in __getattr__</strong></span>
<span class="strong"><strong>    raise AttributeError("Mock object has no attribute %r" % name)</strong></span>
<span class="strong"><strong>AttributeError: Mock object has no attribute 'execute'</strong></span>
</pre></div><p>Notice in<a id="id177" class="indexterm"/> the above example that <code class="literal">mock_1</code> goes<a id="id178" class="indexterm"/> ahead and executes the <code class="literal">execute</code> method without any error, even though the method has been renamed in the <code class="literal">PrintAction</code>. On the other hand, by giving a spec, the method call to the nonexistent <code class="literal">execute</code> method raises an exception.</p></div><div class="section" title="Mocking return values"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Mocking return values</h2></div></div></div><p>The second variant above showed how we could use a mock <code class="literal">Action</code> class in the test instead of a <a id="id179" class="indexterm"/>real one. In the same way, we <a id="id180" class="indexterm"/>can also use a mock rule instead of creating a <code class="literal">PriceRule</code> in the test. The alert calls the rule to see whether the new stock update caused the rule to be matched. What the alert does depends on whether the rule returned <code class="literal">True</code> or <code class="literal">False</code>.</p><p>All the mocks we've created so far have not had to return a value. We were just interested in whether the right call was made or not. If we mock the rule, then we will have to configure it to return the right value for the test. Fortunately, Python makes that very simple to do.</p><p>All we have to do is to set the return value as a parameter in the constructor to the mock object as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; matches = mock.Mock(return_value=True)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; matches()</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; matches(4)</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; matches(4, "abcd")</strong></span>
<span class="strong"><strong>True</strong></span>
</pre></div><p>As we can see above, the mock just blindly returns the set value, irrespective of the parameters. Even the type or number of parameters is not considered. We can use the same procedure to set the return value of a method in a mock object as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; rule = mock.MagicMock()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; rule.matches = mock.Mock(return_value=True)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; rule.matches()</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
</pre></div><p>There is another way to set the return value, which is very convenient when dealing with methods in mock objects. Each mock object has a <code class="literal">return_value</code> attribute. We simply set this<a id="id181" class="indexterm"/> attribute to the return value and every <a id="id182" class="indexterm"/>call to the mock will return that value, as shown in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from unittest import mock</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; rule = mock.MagicMock()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; rule.matches.return_value = True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; rule.matches()</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
</pre></div><p>In the example above, the moment we access <code class="literal">rule.matches</code>, Python automatically creates a mock <code class="literal">matches</code> object and puts it in the <code class="literal">rule</code> object. This allows us to directly set the return value in one statement without having to create a mock for the <code class="literal">matches</code> method.</p><p>Now that we've seen how to set the return value, we can go ahead and change our test to use a mocked rule object, as shown in the following:</p><div class="informalexample"><pre class="programlisting">    def test_action_is_executed_when_rule_matches(self):
        exchange = {"GOOG": Stock("GOOG")}
        rule = mock.MagicMock(spec=PriceRule)
        rule.matches.return_value = True
        rule.depends_on.return_value = {"GOOG"}
        action = mock.MagicMock()
        alert = Alert("sample alert", rule, action)
        alert.connect(exchange)
        exchange["GOOG"].update(datetime(2014, 2, 10), 11)
        action.execute.assert_called_with("sample alert")</pre></div><p>There are two calls that the <code class="literal">Alert</code> makes to the rule: one to the <code class="literal">depends_on</code> method and the other to the matches method. We set the return value for both of them and the test passes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>In case no return value is explicitly set for a call, the default return value is to return a new <a id="id183" class="indexterm"/>mock object. The mock object is different <a id="id184" class="indexterm"/>for each method that is called, but is consistent for a particular method. This means if the same method is called multiple times, the same mock object will be returned each time.</p></div></div></div><div class="section" title="Mocking side effects"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Mocking side effects</h2></div></div></div><p>Finally, we come to the <code class="literal">Stock</code> class. This is the final dependency of the <code class="literal">Alert</code> class. We're currently creating <code class="literal">Stock</code> objects in our test, but we could replace it with a mock object just like <a id="id185" class="indexterm"/>we did for the <code class="literal">Action</code> and <code class="literal">PriceRule</code> classes.</p><p>The <code class="literal">Stock</code> class is<a id="id186" class="indexterm"/> again slightly different in behavior from the other two mock objects. The <code class="literal">update</code> method doesn't just return a value—it's primary behavior in this test is to trigger the updated event. Only if this event is triggered will the rule check occur.</p><p>In order to do this, we must tell our mock stock class to fire the event when the <code class="literal">update</code> event is called. Mock objects have a <code class="literal">side_effect</code> attribute to enable us to do just this.</p><p>There are many reasons we might want to set a side effect. Some of them are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We may want to call another method, like in the case of the <code class="literal">Stock</code> class, which needs to fire the event when the <code class="literal">update</code> method is called.</li><li class="listitem" style="list-style-type: disc">To raise an exception: this is particularly useful when testing error situations. Some errors such as a network timeout might be very difficult to simulate, and it is better to test using a mock that simply raises the appropriate exception.</li><li class="listitem" style="list-style-type: disc">To return multiple values: these may be different values each time the mock is called, or specific values, depending on the parameters passed.</li></ul></div><p>Setting the side effect is just like setting the return value. The only difference is that the side effect is a lambda function. When the mock is executed, the parameters are passed to the lambda function and the lambda is executed. The following is how we would use this with a mocked out <code class="literal">Stock</code> class:</p><div class="informalexample"><pre class="programlisting">    def test_action_is_executed_when_rule_matches(self):
        goog = mock.MagicMock(spec=Stock)
        goog.updated = Event()
        goog.update.side_effect = lambda date, value:
                goog.updated.fire(self)
        exchange = {"GOOG": goog}
        rule = mock.MagicMock(spec=PriceRule)
        rule.matches.return_value = True
        rule.depends_on.return_value = {"GOOG"}
        action = mock.MagicMock()
        alert = Alert("sample alert", rule, action)
        alert.connect(exchange)
        exchange["GOOG"].update(datetime(2014, 2, 10), 11)
        action.execute.assert_called_with("sample alert")</pre></div><p>So what is going on in that test?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we create a mock of the <code class="literal">Stock</code> class instead of using the real one.</li><li class="listitem">Next, we add in the <code class="literal">updated</code> event. We need to do this because the <code class="literal">Stock</code> class creates the attribute at runtime in the <code class="literal">__init__</code> scope. Because the attribute is set dynamically, <code class="literal">MagicMock</code> does not pick up the attribute from the <code class="literal">spec</code> parameter. We are setting an actual <code class="literal">Event</code> object here. We could set it as a mock as well, but it is probably overkill to do that.</li><li class="listitem">Finally, we set the side effect for the <code class="literal">update</code> method in the mock stock object. The lambda takes the two parameters that the method does. In this particular example, we just want to fire the event, so the parameters aren't used in the lambda. In other cases, we might want to perform different actions based on the values of the parameters. Setting the <code class="literal">side_effect</code> attribute allows us to do that.</li></ol></div><p>Just like <a id="id187" class="indexterm"/>with the <code class="literal">return_value</code> attribute, the <code class="literal">side_effect</code> attribute can also be set in the constructor.</p><p>Run the test and it<a id="id188" class="indexterm"/> should pass.</p><p>The <code class="literal">side_effect</code> attribute can also be set to an exception or a list. If it is set to an exception, then the given exception will be raised when the mock is called, as shown in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; m = mock.Mock()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; m.side_effect = Exception()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; m()</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>  File "C:\Python34\lib\unittest\mock.py", line 885, in __call__</strong></span>
<span class="strong"><strong>    return _mock_self._mock_call(*args, **kwargs)</strong></span>
<span class="strong"><strong>  File "C:\Python34\lib\unittest\mock.py", line 941, in _mock_call</strong></span>
<span class="strong"><strong>    raise effect</strong></span>
<span class="strong"><strong>Exception</strong></span>
</pre></div><p>If it is set to a list, then the mock will return the next element of the list each time it is called. This is a good way to mock a function that has to return different values each time it is called, as shown in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; m = mock.Mock()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; m.side_effect = [1, 2, 3]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; m()</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; m()</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; m()</strong></span>
<span class="strong"><strong>3</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; m()</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>  File "C:\Python34\lib\unittest\mock.py", line 885, in __call__</strong></span>
<span class="strong"><strong>    return _mock_self._mock_call(*args, **kwargs)</strong></span>
<span class="strong"><strong>  File "C:\Python34\lib\unittest\mock.py", line 944, in _mock_call</strong></span>
<span class="strong"><strong>    result = next(effect)</strong></span>
<span class="strong"><strong>StopIteration</strong></span>
</pre></div><p>As we have<a id="id189" class="indexterm"/> seen, the mocking framework's method <a id="id190" class="indexterm"/>of handling side effects using the <code class="literal">side_effect</code> attribute is very simple, yet quite powerful.</p></div><div class="section" title="How much mocking is too much?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec26"/>How much mocking is too much?</h2></div></div></div><p>In the previous few sections, we've seen the same test written with different levels of mocking. We started off with a test that didn't use any mocks at all, and subsequently mocked out each <a id="id191" class="indexterm"/>of the dependencies one by one. Which one of these solutions is the best?</p><p>As with many things, this is a point of personal preference. A purist would probably choose to mock out all dependencies. My personal preference is to use real objects when they are small and self-contained. I would not have mocked out the <code class="literal">Stock</code> class. This is because mocks generally require some configuration with return values or side effects, and this configuration can clutter the test and make it less readable. For small, self-contained classes, it is simpler to just use the real object.</p><p>At the other end of the spectrum, classes that might interact with external systems, or that take a lot of memory, or are slow are good candidates for mocking out.  Additionally, objects that require a lot of dependencies on other object to initialize are candidates for mocking. With mocks, you just create an object, pass it in, and assert on parts that you are interested in checking. You don't have to create an entirely valid object.</p><p>Even here there are alternatives to mocking. For example, when dealing with a database, it is common to mock out the database calls and hardcode a return value into the mock. This is because the database might be on another server, and accessing it makes the tests slow and unreliable. However, instead of mocks, another option could be to use a fast in-memory database for the tests. This allows us to use a live database instead of a mocked out database. Which <a id="id192" class="indexterm"/>approach is better depends on the situation.</p></div><div class="section" title="Mocks versus stubs versus fakes versus spies"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Mocks versus stubs versus fakes versus spies</h2></div></div></div><p>We've been talking about mocks so far, but we've been a little loose on the terminology. Technically, everything we've talked about falls under the category of a <span class="strong"><strong>test double</strong></span>. A test double<a id="id193" class="indexterm"/> is some sort of fake object that we use to stand in for a real object in a test case.</p><p>Mocks are a specific kind of test double that record information about calls that have been made to it, so that we can assert on them later.</p><p>
<span class="strong"><strong>Stubs</strong></span> are just<a id="id194" class="indexterm"/> an empty do-nothing kind of object or method. They are <a id="id195" class="indexterm"/>used when we don't care about some functionality in the test. For example, imagine we have a method that performs a calculation and then sends an e-mail. If we are testing the calculation logic, we might just replace the e-mail sending method with an empty do-nothing method in the test case so that no e-mails are sent out while the test is running.</p><p>
<span class="strong"><strong>Fakes</strong></span> are a<a id="id196" class="indexterm"/> replacement of one object or system with a simpler one that<a id="id197" class="indexterm"/> facilitates easier testing. Using an in-memory database instead of the real one, or the way we created a dummy <code class="literal">TestAction</code> earlier in this chapter would be examples of fakes.</p><p>Finally, <span class="strong"><strong>spies</strong></span> are<a id="id198" class="indexterm"/> objects that are like middlemen. Like mocks, they<a id="id199" class="indexterm"/> record the calls so that we can assert on them later, but after recording, they continue execution to the original code. Spies are different from the other three in the sense that they do not replace any functionality. After recording the call, the real code is still executed. Spies sit in the middle and do not cause any change in execution pattern.</p></div><div class="section" title="Patching methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Patching methods</h2></div></div></div><p>So far we <a id="id200" class="indexterm"/>have looked at simple mocking<a id="id201" class="indexterm"/> patterns. These are the methods that you will use most of the time. Python's mocking framework doesn't stop there and has tremendous support for doing more complex things.</p><p>Let us look at the <code class="literal">PrintAction</code> class (put this code in the file <code class="literal">action.py</code> in the <code class="literal">stock_alerter</code> directory) as follows:</p><div class="informalexample"><pre class="programlisting">class PrintAction:
    def execute(self, content):
        print(content)</pre></div><p>This is a simple action, which, when the <code class="literal">execute</code> method is called, will just print out the alert description to the screen.</p><p>Now, how do we go about testing this? What we want to test is that the action actually calls the print method with the right parameters. In the previous examples, we could create a mock object and pass it into the class instead of a real object. Here, there is no parameter or attribute that we can simply replace with a mock object.</p><p>The solution to<a id="id202" class="indexterm"/> this is to use <span class="strong"><strong>patching</strong></span>. Patching is a <a id="id203" class="indexterm"/>way to replace a class or function in the global namespace <a id="id204" class="indexterm"/>with a mock version. Because Python allows dynamic access to the globals as well as all imported modules, we can just go in and change which object an identifier points to.</p><p>In the following sequence, you can see how we replace the <code class="literal">print</code> function with another one that takes one parameter and returns the double:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; # the builtin print function prints a string</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print("hello") </strong></span>
<span class="strong"><strong>hello</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; # the builtin print function handles multiple parameters</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(1, 2) </strong></span>
<span class="strong"><strong>1 2</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; # this is where the print function is mapped</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; __builtins__.print </strong></span>
<span class="strong"><strong>&lt;built-in function print&gt;</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; # make the builtin print point to our own lambda</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; __builtins__.print = lambda x: x*2 </strong></span>

<span class="strong"><strong>&gt;&gt;&gt; # calling print now executes our substituted function</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print("hello") </strong></span>
<span class="strong"><strong>'hellohello'</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; # our lambda does not support two parameters</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(1, 2) Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>TypeError: &lt;lambda&gt;() takes 1 positional argument but 2 were given</strong></span>
</pre></div><p>As we can see above, all calls to <code class="literal">print</code> now call our own function instead of the default printing implementation.</p><p>This gives us the hint we need to proceed with our mocking. What if we just replace the <code class="literal">print</code> with a mock before running the test? This way the code will end up executing our mock instead of the default print implementation, and we can then assert on the mock that it was called with the right parameters.</p><p>The following is an example of this technique:</p><div class="informalexample"><pre class="programlisting">import unittest
from unittest import mock
from ..action import PrintAction

class PrintActionTest(unittest.TestCase):
    def test_executing_action_prints_message(self):
        mock_print = mock.Mock()
        old_print = __builtins__["print"]
        __builtins__["print"] = mock_print
        try:
            action = PrintAction()
            action.execute("GOOG &gt; $10")
            mock_print.assert_called_with("GOOG &gt; $10")
        finally:
            __builtins__["print"] = old_print</pre></div><p>What's going <a id="id205" class="indexterm"/>on here?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we <a id="id206" class="indexterm"/>create the mock function.</li><li class="listitem">Next, we save the default print implementation. We need to do this so that we can restore it properly at the end of the test.</li><li class="listitem">Finally, we replace the default print with our mock function. Now, every time the print function is called, it will call our mock.</li><li class="listitem">We run the test, wrapped around a <code class="literal">try</code> - <code class="literal">finally</code> block.</li><li class="listitem">In the <code class="literal">finally</code> block, we restore back the default print implementation.</li></ol></div><p>It is very, very important to restore the default implementation back. Remember, we are changing the global information here, so if we don't restore it back, print will point to our mock function in all the subsequent tests as well. This can lead to some very strange behavior, for example, somewhere else we might expect some output on the screen and nothing is printed, and we end up spending hours trying to figure out why. This is the reason why the test is wrapped in the <code class="literal">try</code> - <code class="literal">finally</code> block. This way, the mock gets reset back to the default even if there is an exception thrown in the test.</p><p>We just saw how to patch in functions and classes with a mock, and since this is a fairly common task, Python gives us a really nice way to perform patching through the <code class="literal">mock.patch</code> function.</p><p>The <code class="literal">mock.patch</code> function takes away a lot of the work needed to patch functions. Let us look at a couple of ways to use it.</p><p>The first way replicates the way we did our manual patching. We create a patcher and then use the <code class="literal">start</code> method to execute the patch, and the <code class="literal">stop</code> method to reset back the original implementation, as shown in the following:</p><div class="informalexample"><pre class="programlisting">    def test_executing_action_prints_message(self):
        patcher = mock.patch('builtins.print')
        mock_print = patcher.start()
        try:
            action = PrintAction()
            action.execute("GOOG &gt; $10")
            mock_print.assert_called_with("GOOG &gt; $10")
        finally:
            patcher.stop()</pre></div><p>Like our<a id="id207" class="indexterm"/> manual patching, we have to be <a id="id208" class="indexterm"/>careful that the stop method gets called even if an exception is raised.</p><p>The patch can also be used as a context manager in conjunction with the <code class="literal">with</code> keyword. This syntax is a lot cleaner and generally preferable to calling start and stop ourselves:</p><div class="informalexample"><pre class="programlisting">    def test_executing_action_prints_message(self):
        with mock.patch('builtins.print') as mock_print:
            action = PrintAction()
            action.execute("GOOG &gt; $10")
            mock_print.assert_called_with("GOOG &gt; $10")</pre></div><p>Let us walk through what is going on here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code where we want the patch to be active is wrapped inside the <code class="literal">with</code> block.</li><li class="listitem" style="list-style-type: disc">We call the <code class="literal">patch</code> function, which returns the patcher to be used as a context manager. The mock object is set in the variable specified in the <code class="literal">as</code> section. In this case, the patched mock is set to <code class="literal">mock_print</code>.</li><li class="listitem" style="list-style-type: disc">Inside the block, we perform the test and assert as usual.</li><li class="listitem" style="list-style-type: disc">The patch is removed once execution comes out of the context block. This could be because all the statements were executed or due to an exception.</li></ul></div><p>With this syntax, we don't need to worry about unhandled exceptions causing a problem with the patch.</p><p>The <code class="literal">patch</code> function can also be used as a method decorator, as the following example shows:</p><div class="informalexample"><pre class="programlisting">    @mock.patch("builtins.print")
    def test_executing_action_prints_message(self, mock_print):
        action = PrintAction()
        action.execute("GOOG &gt; $10")
        mock_print.assert_called_with("GOOG &gt; $10")</pre></div><p>With this syntax, the patcher patches the required function and passes in the replacement mock object as the first parameter to the test method. We can then use the mock object as normal. The patch is reset once the test completes.</p><p>If we need <a id="id209" class="indexterm"/>to patch the same object for a number <a id="id210" class="indexterm"/>of tests, then we can use the class decorator syntax instead, as shown in the following:</p><div class="informalexample"><pre class="programlisting">@mock.patch("builtins.print")
class PrintActionTest(unittest.TestCase):
    def test_executing_action_prints_message(self, mock_print):
        action = PrintAction()
        action.execute("GOOG &gt; $10")
        mock_print.assert_called_with("GOOG &gt; $10")</pre></div><p>This syntax decorates all the tests in the class with the patch. By default, the decorator searches for methods that start with <code class="literal">test</code>. However, this can be changed by setting the <code class="literal">patch.TEST_PREFIX</code> attribute, and the class decorator will patch all methods that start with that prefix.</p><div class="section" title="An important gotcha when patching"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec01"/>An important gotcha when patching</h3></div></div></div><p>When patching, we should remember to patch exactly the object that the class is using. Python allows<a id="id211" class="indexterm"/> multiple references to an object, and it is easy to end up patching the wrong object. We would then spend hours wondering why the mock object isn't being executed.</p><p>For example, support file <code class="literal">alert.py</code> uses an import like the following:</p><div class="informalexample"><pre class="programlisting">from rule import PriceRule</pre></div><p>Now in the alert test, if we want to patch out <code class="literal">PriceRule</code>, then the following is the way we need to do it:</p><div class="informalexample"><pre class="programlisting">import alert

@mock.patch("alert.PriceRule")
def test_patch_rule(self, mock_rule):
    ....</pre></div><p>Only if we do it this way will we patch the <code class="literal">PriceRule</code> object that is used in <code class="literal">alert.py</code> file. The following way will not work:</p><div class="informalexample"><pre class="programlisting">import rule

@mock.patch("rule.PriceRule")
def test_patch_rule(self, mock_rule):
    ....</pre></div><p>This code will <a id="id212" class="indexterm"/>patch out <code class="literal">rule.PriceRule</code>, which is different from the actual object that we want to patch out. When we run this test, we'll see that the alert executes the real <code class="literal">PriceRule</code> object and not the one that we patched out.</p><p>Since this is such a common mistake, we should check this first if ever we have problems with the test not executing the patched object correctly.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Tying it all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Tying it all together</h1></div></div></div><p>Let us tie this chapter <a id="id213" class="indexterm"/>together with a more complex example. The following is the code for the <code class="literal">EmailAction</code> class. This action sends an e-mail to the user when the rule is matched.</p><div class="informalexample"><pre class="programlisting">import smtplib
from email.mime.text import MIMEText

class EmailAction:
    """Send an email when a rule is matched"""
    from_email = "alerts@stocks.com"

    def __init__(self, to):
        self.to_email = to

    def execute(self, content):
        message = MIMEText(content)
        message["Subject"] = "New Stock Alert"
        message["From"] = "alerts@stocks.com"
        message["To"] = self.to_email
        smtp = smtplib.SMTP("email.stocks.com")
        try:
            smtp.send_message(message)
        finally:
            smtp.quit()</pre></div><p>The following is how the library works:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We instantiate the <code class="literal">SMTP</code> class in the <code class="literal">smtplib</code> library, passing it the server we want to connect to. This returns the <code class="literal">SMTP</code> object.</li><li class="listitem">We call the <code class="literal">send_message</code> method on the <code class="literal">SMTP</code> object, passing in the e-mail message details in the form of a <code class="literal">MIMEText</code> object.</li><li class="listitem">Finally, we call the <code class="literal">quit</code> method. This method always needs to be called, even if there was an exception in sending the message.</li></ol></div><p>Given this, we<a id="id214" class="indexterm"/> need to test the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The right calls are made to the <code class="literal">smtplib</code> library, with the right parameters.</li><li class="listitem">The message contents (from, to, subject, body) are correct.</li><li class="listitem">The <code class="literal">quit</code> method is called even if an exception was thrown when sending the message.</li></ol></div><p>Let us start with a simple test. This test is for verifying that the <code class="literal">SMTP</code> class is initialized with the right parameters:</p><div class="informalexample"><pre class="programlisting">class EmailActionTest(unittest.TestCase):
    def setUp(self):
        self.action = EmailAction(to="siddharta@silverstripesoftware.com")

    def test_email_is_sent_to_the_right_server(self, mock_smtp_class):
        self.action.execute("MSFT has crossed $10 price level")
        mock_smtp_class.assert_called_with("email.stocks.com")</pre></div><p>First, we start out by patching out the <code class="literal">SMTP</code> class in the <code class="literal">smtplib</code> module. Since we'll be doing this for every test, we set this up as a class decorator. We then instantiate the <code class="literal">EmailAction</code> that we want to test in the <code class="literal">setUp</code>.</p><p>The test itself is fairly simple. We call the <code class="literal">execute</code> method of the action and assert that the mock class was instantiated with the right parameter.</p><p>The following test verifies that the right calls are made to <code class="literal">SMTP</code> object:</p><div class="informalexample"><pre class="programlisting">    def test_connection_closed_after_sending_mail(self, mock_smtp_class):
        mock_smtp = mock_smtp_class.return_value
        self.action.execute("MSFT has crossed $10 price level")
        mock_smtp.send_message.assert_called_with(mock.ANY)
        self.assertTrue(mock_smtp.quit.called)
        mock_smtp.assert_has_calls([
            mock.call.send_message(mock.ANY),
            mock.call.quit()])</pre></div><p>There are a few new approaches in this test that are worth discussing.</p><p>First is the subtle difference in this series of tests where we are mocking the <code class="literal">SMTP</code> class and not an <span class="emphasis"><em>object</em></span>. In the first test, we were checking the parameters passed to the constructor. Since we mocked the class, we could assert directly on our mock object.</p><p>In this test, we need to check that the right calls are made on the <code class="literal">SMTP</code> <span class="emphasis"><em>object</em></span>. Since an object is the return value from initializing the class, we can access the mock <code class="literal">smtp</code> object from the return value of the mock <code class="literal">smtp</code> class. This is exactly what we are doing in the first line of the test.</p><p>Next, we <a id="id215" class="indexterm"/>execute the action as usual.</p><p>Finally, we are using the <code class="literal">assert_has_calls</code> method to assert that the right calls were made. We could have asserted the calls like the following instead:</p><div class="informalexample"><pre class="programlisting">        mock_smtp.send_message.assert_called_with(mock.ANY)
        self.assertTrue(mock_smtp.quit.called)</pre></div><p>The main difference is that the above assertions do not assert the sequence. Suppose the action calls the <code class="literal">quit</code> method first and then calls <code class="literal">send_message</code>, it would still pass these two assertions. However, the <code class="literal">assert_has_calls</code> assertion not only checks that the methods were called, but also checks that the <code class="literal">quit</code> method is called after <code class="literal">send_message</code>.</p><p>The following third test checks that the connection is closed even if an exception is raised when sending the message:</p><div class="informalexample"><pre class="programlisting">    def test_connection_closed_if_send_gives_error(self, mock_smtp_class):
        mock_smtp = mock_smtp_class.return_value
        mock_smtp.send_message.side_effect =
        smtplib.SMTPServerDisconnected()
        try:
            self.action.execute("MSFT has crossed $10 price level")
        except Exception:
            pass
        self.assertTrue(mock_smtp.quit.called)</pre></div><p>In this test, we use the <code class="literal">side_effect</code> attribute to set the send message mock to raise an exception. We then check that the <code class="literal">quit</code> method was called even when the exception was raised.</p><p>In the last test, we need to check that the right message contents are passed to <code class="literal">send_message</code>. The function takes a <code class="literal">MIMEText</code> object as a parameter. How do we check that the right object was passed?</p><p>The following is one way that <span class="emphasis"><em>does not</em></span> work:</p><div class="informalexample"><pre class="programlisting">    def test_email_is_sent_with_the_right_subject(self, mock_smtp_class):
        mock_smtp = mock_smtp_class.return_value
        self.action.execute("MSFT has crossed $10 price level")
        message = MIMEText("MSFT has crossed $10 price level")
        message["Subject"] = "New Stock Alert"
        message["From"] = "alerts@stocks.com"
        message["To"] = "siddharta@silverstripesoftware.com"
        mock_smtp.send_message.assert_called_with(message)</pre></div><p>If we run the above test, we'll get a failure like the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>AssertionError: Expected call: send_message(&lt;email.mime.text.MIMEText object at 0x0000000003641F98&gt;)</strong></span>
<span class="strong"><strong>Actual call: send_message(&lt;email.mime.text.MIMEText object at 0x000000000363A0F0&gt;)</strong></span>
</pre></div><p>The problem is<a id="id216" class="indexterm"/> that although the contents of the expected <code class="literal">MIMEText</code> object and the actual one passed to <code class="literal">send_message</code> are the same, the test still fails because they are both different objects. The mocking framework compares the two parameters by equality, and since both are two different objects, the test for equality fails.</p><p>One approach around this problem is to go into the mock, extract the arguments that were passed in the call, and check that they contained the right data. The following is a test that uses this approach:</p><div class="informalexample"><pre class="programlisting">    def test_email_is_sent_with_the_right_subject(self, mock_smtp_class):
        mock_smtp = mock_smtp_class.return_value
        self.action.execute("MSFT has crossed $10 price level")
        call_args, _ = mock_smtp.send_message.call_args
        sent_message = call_args[0]
        self.assertEqual("New Stock Alert", sent_message["Subject"])</pre></div><p>Once the <code class="literal">execute</code> method is called, we then access the <code class="literal">call_args</code> attribute of the <code class="literal">mock</code> object to get the arguments that were passed to <code class="literal">send_message</code>. We take the first parameter, which is the <code class="literal">MIMEText</code> object that we are interested in. We then assert that the subject was as expected.</p><p>A more elegant way is possible. Remember we said that the mocking framework compares parameters by equality? This means that we can pass in an object that implements the <code class="literal">__eq__</code> special method and use that to perform any comparison that we want. The following is one such class for checking equality between two <code class="literal">MIMEText</code> messages:</p><div class="informalexample"><pre class="programlisting">class MessageMatcher:
    def __init__(self, expected):
        self.expected = expected

    def __eq__(self, other):
        return self.expected["Subject"] == other["Subject"] and \
            self.expected["From"] == other["From"] and \
            self.expected["To"] == other["To"] and \
            self.expected["Message"] == other._payload</pre></div><p>This class basically takes a dictionary of values, and then can be used to compare whether a <code class="literal">MIMEText</code> object contains those values (at least the values we are interested in). Since it implements the <code class="literal">__eq__</code> method, a direct equality can be used to check, as shown in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; message = MIMEText("d")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; message["Subject"] = "a"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; message["From"] = "b"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; message["To"] = "c"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; expected = MessageMatcher({"Subject":"a", "From":"b", "To":"c", "Message":"d"})</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; message == expected</strong></span>
<span class="strong"><strong>True</strong></span>
</pre></div><p>We can use<a id="id217" class="indexterm"/> this technique to pass in such an object as the expected parameter of a test like the following:</p><div class="informalexample"><pre class="programlisting">    def test_email_is_sent_when_action_is_executed(self, mock_smtp_class):
        expected_message = {
            "Subject": "New Stock Alert",
            "Message": "MSFT has crossed $10 price level",
            "To": "siddharta@silverstripesoftware.com",
            "From": "alerts@stocks.com"
        }
        mock_smtp = mock_smtp_class.return_value
        self.action.execute("MSFT has crossed $10 price level")
        mock_smtp.send_message.assert_called_with(
            MessageMatcher(expected_message))</pre></div><p>Writing custom parameter matchers like this is an easy way to assert on parameters for which we might not have direct object access, or when we want to compare only a few attributes of the object for the purposes of the test.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Summary</h1></div></div></div><p>In this chapter, you looked at how to use mocks to test interactions between objects. You saw how to hand write our own mocks, followed by using the mocking framework provided in the Python standard library. Next, you saw how to use patching for more advanced mocking. We wrapped it up by looking at a slightly more complex mocking example that had us put all the mocking techniques into practice.</p><p>So far you have been looking at writing tests for new code. In the next chapter, you will take a look at how to deal with existing code that does not have tests.</p></div></div>
</body></html>