- en: Process-Based Parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use threads to implement concurrent
    applications. This chapter will examine the process-based approach that we introduced
    in [Chapter 1](64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml), *Getting Started with
    Parallel Computing and Python*. In particular, the focus of the chapter is on
    the Python `multiprocessing` module.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `multiprocessing` module, which is a part of the standard library
    of the language, implements the shared memory programming paradigm, that is, the
    programming of a system that consists of *one or more processors* that have access
    to a shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Python's `multiprocessing` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning a process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming a process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running processes in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Killing a process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a process in a subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a queue to exchange objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pipes to exchange objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing a state between processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a process pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Python's multiprocessing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of the Python `multiprocessing` documentation ([https://docs.python.org/2.7/library/multiprocessing.html#introduction](https://docs.python.org/2.7/library/multiprocessing.html#introduction))
    clearly mentions that all the functionality within this package requires the `main`
    module to be importable to the children ([https://docs.python.org/3.3/library/multiprocessing.html](https://docs.python.org/3.3/library/multiprocessing.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__main__` module is not importable to the children in IDLE, even if you
    run the script as a file with IDLE. To get the correct result, we will run all
    the examples from Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `multiprocessing_example.py` is the script's name.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spawning a process is the creation of a *child process* from a *parent process.*
    The latter continues its execution asynchronously or waits until the child process
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `multiprocessing` library allows spawning processes by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Define* the `process` object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Call* the `start()` method of the process to run it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Call* the `join()` method of the process. It waits until the process has completed
    the job and then exits.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a process, we need to import the `multiprocessing` module with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each process is associated with the `myFunc(i)` function. This function outputs
    the numbers from `0` to `i`, where `i` is the ID associated with the process number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the `process` object with `myFunc` as the `target` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call the `start` and `join` methods on the process created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Without the `join` method, child processes do not end and must be killed manually.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we have therefore seen how it is possible to create processes
    by starting from a parent process. This feature is called *spawning a process*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s `multiprocessing` library allows easy process management by following
    three simple steps. The first step is the process definition through the `multiprocessing`
    class method, `Process`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Process` method has as an argument of the function to spawn, `myFunc`,
    and any arguments of the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two steps are necessary to execute and exit the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the process and display the results, let''s open Command Prompt, preferably
    in the same folder containing the example file (`spawning_processes.py`), and
    then type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For each process created (there are six in all), the output of the target function
    is shown. Remember that this is a simple counter from `0` up to the index of the
    process ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This reminds us once again of the importance of instantiating the `Process`
    object within the main section: this is because the child process created imports
    the script file where the `target` function is contained. Then, by instantiating
    the `process` object within this block, we prevent an infinite recursive call
    of such instantiations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A valid workaround is used to define the `target` function in a different script,
    namely `myFunc.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` program containing the process instance is defined in a second file
    (`spawning_processes_namespace.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this example, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output is the same as the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official guide for the `multiprocessing` library can be found at [https://docs.python.org/3/](https://docs.python.org/3/).
  prefs: []
  type: TYPE_NORMAL
- en: Naming a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we identified the processes and how to pass a variable
    to the target function. However, it is very useful to associate a name to the
    processes as debugging an application requires the processes to be well marked
    and identifiable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point in your code, it may be crucial to know what process is currently being
    executed. For this purpose, the `multiprocessing` library provides the `current_process()`
    method, which uses the `name` attribute to identify which process is currently
    running. In the following section, we'll learn about this topic.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `target` function for both the processes is the `myFunc` function. It outputs
    the process name by evaluating the `multiprocessing.current_process().name` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create `process_with_name` simply by instantiating the `name` parameter
    and `process_with_default_name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the processes are started and then joined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `main` program, the processes are created using the same target function, `myFunc`.
    This function simply prints the process name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the example, open Command Prompt and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main Python process is `multiprocessing.process._MainProcess`, while child
    processes are `multiprocessing.process.Process`. It can be tested by simply typing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More on this topic can be found at [https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/](https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/).
  prefs: []
  type: TYPE_NORMAL
- en: Running processes in the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running in the background is a mode of execution that is typical of some programs
    that do not require the presence or intervention of the user, and which may be
    concurrent to the execution of other programs (and therefore, it is only possible
    in multitasking systems), resulting in the user being unaware about it. Background
    programs typically perform long or time-consuming tasks such as peer-to-peer filesharing
    programs or defragmentation of filesystems. Many OS processes also run in the
    background.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, programs in this mode (scanning antiviruses or OS updates) often
    place an icon in the system tray (the area of the desktop next to the system clock)
    in order to signal their activity and adopt behaviors that reduce the use of resources
    so as to not interfere with the user's interactive activities, such as slowing
    down or causing interruptions. In Unix and Unix-like systems, processes that run
    in the background are called **daemons**. Using a task manager can highlight all
    running programs including those in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `multiprocessing` module allows—through the daemonic option—to run background
    processes. In the following example, two processes are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`background_process` with their `daemon` parameter set to `True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NO_background_process` with their `daemon` parameter set to `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, we implement a target function, namely `foo`, which
    displays the digits from `0` to `4` **if** the child process is in the **background**;
    otherwise, it prints the digits from `5` to `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the relevant libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the `foo()` function. As previously specified, the printed
    digits depend on the value of the `name` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the following processes: `background_process` and `NO_background_process`.
    Notice that the `daemon` parameter is set for the two processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that only the `daemon` parameter of the process defines whether the process
    should run in the background or not. To run this example, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output clearly reports only the `NO_background_process` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output changes the setting of the `daemon` parameter for `background_process`
    to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this example, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output reports the execution of both the `background_process` and `NO_background_process` processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A code snippet on how to run a Python script in the background in Linux can
    be found at [https://janakiev.com/til/python-background/](https://janakiev.com/til/python-background/).
  prefs: []
  type: TYPE_NORMAL
- en: Killing a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no perfect software and even in the best applications, you can nest
    a bug that leads to blocking the application, which is why modern OSes have developed
    several methods to terminate the processes of applications in order to free the
    system resources and allow the user to use them for other operations as soon as
    possible. This section will show you how to kill a process in your multiprocessing
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible to kill a process immediately by using the `terminate` method.
    Also, we use the `is_alive` method to keep track of whether the process is alive
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps allow us to perform the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the relevant libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a simple `target` function is implemented. In this example, the `target`
    function, `foo()`, prints the first `10` digits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` program, we create a process monitoring its lifetime by the `is_alive`
    method; then, we finish it with a call to `terminate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we verify the status code when the process is finished and read the attribute
    of the `ExitCode` process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The possible values of `ExitCode` are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`== 0`: No error was produced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`> 0`: The process had an error and exited that code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`< 0`: The process was killed with a signal of `-1 * ExitCode`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample code consists of a target function, `foo()`, whose task is to print
    out the first `10` integer numbers on the screen. In the `main` program, the process
    is executed and then killed by the `terminate` instruction. The process is then
    joined and `ExitCode` is determined.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the code, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the output value of the `ExitCode` code is equal to `**-**15`. The
    negative value of `-15` indicates that the child was terminated by an interrupt
    signal, which is identified by the number `15`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a Linux machine, a Python process can be identified and then killed simply
    by following the tutorial at [http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html](http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Defining processes in a subclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `multiprocessing` module provides access to process management functionalities.
    In this section, we'll learn about how to define a process in a subclass of the
    `multiprocessing.Process` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement a multiprocessing custom subclass, we need to do the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Define* a subclass of the `multiprocessing.Process` class, redefining the
    `run()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Override* the `_init__(self [,args])` method to add additional arguments,
    if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Override* the `run(self [,args])` method to implement what `Process` should
    do when it is started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have created the new `Process` subclass, you can create an instance
    of it and then start by invoking the `start` method, which will, in turn, call
    the `run` method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just consider a very simple example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the relevant library first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define a subclass, `MyProcess`, overriding only the `run` method, which
    returns the process'' name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` program, we define a subclass of `10` processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each process subclass is represented by a class that extends the `Process`
    class and overrides the `run()` method. This method is the starting point of `Process`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` program, we create several objects of the `MyProcess()` type. The
    execution of the thread begins when the `start()` method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `join()` command just handles the termination of processes. To run the
    script from Command Prompt, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented programming, a subclass is a class that inherits all properties
    from a superclass, whether they are objects or methods. An alternative name to
    subclass is *derived class*. *Inheritance* is the specific term that indicates
    this process by which the daughter or derived classes inherit the properties of
    parent classes or superclasses.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a subclass as a particular genre of its superclass; in fact,
    it can use methods and/or attributes, as well as redefine them through *overriding*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information on class definition techniques can be found at [http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html](http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using a queue to exchange data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *queue* is a data structure of the **First-In, First-Out** (**FIFO**) type (the
    first input is the first to exit). A practical example is the queues to get a
    service, how to pay at the supermarket, or get your hair cut at the hairdresser.
    Ideally, you are served in the same order as you were presented to. This is exactly
    how a FIFO queue works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we show you how to use a queue for a *producer-consumer* problem,
    that is a classic example of *process synchronization*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **producer-consumer** problem describes two *processes*: one is the *producer*
    and the other is a *consumer*, sharing a **common** **buffer** of a **fixed**
    **size**.'
  prefs: []
  type: TYPE_NORMAL
- en: The task of the *producer* is to generate data and to deposit it in the buffer
    continuously. At the same time, the *consumer* will use the data produced, removing
    it from the buffer from time to time. The problem is to ensure that the producer
    does not process new data if the buffer is full and that the consumer does not
    look for data if the buffer is empty. The solution for the producer is to suspend
    its execution if the buffer is full.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the consumer has taken an item from the buffer, the producer wakes
    up and starts to fill the buffer again. Similarly, the consumer will suspend if
    the buffer is empty. As soon as the producer has downloaded the data into the
    buffer, the consumer wakes up.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This solution can be implemented by means of communication strategies between
    processes, shared memory, or message passing. An incorrect solution could result
    in a deadlock, in which both processes wait to be awakened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s perform the steps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `producer` class is responsible for entering `10` items in the queue by
    using the `put` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `consumer` class has the task of removing the items from the queue (using
    the `get` method) and verifying that the queue is not empty. If this happens,
    then the flow inside the `while` loop ends with a `break` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `multiprocessing` class has its `queue` object instantiated in the `main` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the `main` program, we define the queue using the `multiprocessing.Queue` object.
    Then, it is passed as an argument to the `producer ` and `consumer` processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `producer` class, the `queue.put` method is used to append new items
    to the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'While in the `consumer` class, the `queue.get` method is used to po*p* out
    the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the code by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output reports the interaction between the producer and the consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A queue has the `JoinableQueue` subclass. This provides the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`task_done()`: This method indicates that a task is complete, for example,
    after using the `get()` method to fetch items from the queue. So `task_done()`
    must be used only by queue consumers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`join()`: This method blocks the processes until all the items in the queue
    have been completed and processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good tutorial on how to use a queue is available at [https://www.pythoncentral.io/use-queue-beginners-guide/](https://www.pythoncentral.io/use-queue-beginners-guide/).
  prefs: []
  type: TYPE_NORMAL
- en: Using pipes to exchange objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *pipe* does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It returns a pair of connection objects connected by a pipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every connection object has to send/receive methods to communicate between processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `multiprocessing` library allows you to implement a pipe data structure
    using the `multiprocessing.Pipe (duplex)` function. This returns a pair of objects, `(conn1,
    conn2)`, which represent the end of the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `duplex` parameter determines whether the pipe for the last case is bidirectional
    (that is, `duplex = True`), or unidirectional (that is, `duplex = False`). `conn1`
    can only be used for receiving messages, and `conn2` can only be used for sending
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how to exchange objects using pipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a simple example of pipes. We have one process pipe that outputs numbers
    from `0` to `9`, and a second process pipe that takes the numbers and squares
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the `multiprocessing` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pipe` function returns a pair of connection objects connected by a *two-way*
    pipe. In the example, `out_pipe` contains the numbers from `0` to `9`, which were
    generated by the `target` function of `create_items`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `multiply_items` function is based on two pipes, `pipe_1` and `pipe_2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns the product of the elements of each pipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` program,  `pipe_1`, and `pipe_2` are defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'First, process `pipe_1` with numbers from `0` to `9`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, process `pipe_2`, which picks up the numbers from `pipe_1` and squares
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Print out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Essentially, the two pipes, `pipe_1` and `pipe_2`, are created by the `multiprocessing.Pipe(True)`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The first pipe, `pipe_1`, simply created a list of integers from `0` to `9`,
    while the second pipe, `pipe_2`, processed each element of the list created by
    `pipe_1`, calculating the squared value of each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, both processes are closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And the final result is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the code by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following result shows the square of the first `9` digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need more than two points to communicate, then use a `Queue()` method.
    However, if you need absolute performance, then a `Pipe()` method is much faster
    because `Queue()` is built on top of `Pipe()`**.**
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information on Python and pipes can be found at [https://www.python-course.eu/pipes.php](https://www.python-course.eu/pipes.php%0d).
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple processes can work together to perform a given task. Usually, they
    share data. It is important that access to shared data by various processes does
    not produce inconsistent data. Processes that cooperate by sharing data must,
    therefore, act in an orderly manner in order for that data to be accessible. Synchronization
    primitives are quite like those encountered for the library and threading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Synchronization primitives are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lock**: This object can be in either the locked or unlocked state. A locked
    object has two methods, `acquire()` and `release()`, to manage access to a shared
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event**: This object realizes simple communication between processes; one
    process signals an event and the other processes wait for it. An event object
    has two methods, `set()` and `clear()`, to manage its own internal flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Condition**: This object is used to synchronize parts of a workflow, in sequential
    or parallel processes. It has two basic methods: `wait()` is used to wait for
    a condition and `notify_all()` is used to communicate the condition that was applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semaphore**: This is used to share a common resource, for example, to support
    a fixed number of simultaneous connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RLock**: This defines the *recursive lock* object. The methods and functionality
    of RLock are the same as the `threading` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Barrier**: This divides a program into phases as it requires all processes
    to reach the barrier before any of the proceeds. Code that is executed after a
    barrier cannot be concurrent with the code that was executed before the barrier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Barrier* objects in Python are used to wait for the execution of a fixed number
    of threads to complete before a given thread can proceed with the execution of
    the program.'
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows how to synchronize simultaneous tasks with a `barrier()` object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider four processes, wherein process `p1` and process `p2` are managed
    by a barrier statement*,* while process `p3` and process `p4` have *no synchronization*
    directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the relevant libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test_with_barrier` function executes the barrier''s **`wait()`** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When the two processes have called the `wait()` method, they are released simultaneously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` program, we created four processes. However, we also need a barrier
    and lock primitive. The `2` parameter in the `Barrier` statement stands for the
    total number of processes to manage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Barrier` object provides one of the Python synchronization techniques with
    which single or multiple threads wait until a point in a set of activities and
    make progress together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` program, the `Barrier` object (that is, `synchronizer`) is defined
    through the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note that the number `2` within the parentheses represents the number of processes
    that the barrier should wait upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we implement a set of four processes, but only for the `p1` and `p2` processes.
    Note that `synchronizer` is passed as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, in the body of the `test_with_barrier` function, the barrier''s `wait()` method is
    used in order to synchronize the processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the script, we can see that the `p1` and `p2` processes print out
    the same timestamps as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows you how a barrier works with the two processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9077bdf-036b-4f0e-90ea-0ddfd80fc58f.png)'
  prefs: []
  type: TYPE_IMG
- en: Process management with a barrier
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please read [https://pymotw.com/2/multiprocessing/communication.html](https://pymotw.com/2/multiprocessing/communication.html)
    for more examples of process synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Using a process pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process pool mechanism allows the execution of a function across multiple
    input values to be parallelized, distributing *the* input data between processes. The
    process pool, therefore, allows implementing the so-called **data parallelism**
    that is based on the distribution of data through the different processes that
    operate on data in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `multiprocessing` library provides the `Pool` class for simple parallel
    processing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Pool` class has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply()`: This blocks until the result is ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply_async()`: This is a variant of the `apply()` ([https://docs.python.org/2/library/functions.html#apply](https://docs.python.org/2/library/functions.html#apply))
    method, which returns a result object. It is an asynchronous operation that will
    not lock the main thread until all the child classes are executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()`: This is the parallel equivalent of the built-in `map()` ([https://docs.python.org/2/library/functions.html#map](https://docs.python.org/2/library/functions.html#map))
    function. This blocks until the result is ready, and it chops the iterable data
    in a number of chunks that are submitted to the process pool as separate tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map_async()`: This is a variant of the `map()` ([https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map](https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map))
    method, which returns a `result` object. If a callback is specified, then it should
    be callable, which accepts a single argument. When the result becomes ready, a
    callback is applied to it (unless the call fails). A callback should be completed
    immediately; otherwise, the thread that handles the results will get blocked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example shows you how to implement a process pool to perform a parallel
    application. We create a pool of four processes and then we use the pool''s `map`
    method to perform a simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `multiprocessing` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Pool` method applies `function_square` to the input element to perform
    a simple calculation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter inputs are a list of integers from `0` to `100`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The total number of parallel processes is `4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pool.map` method submits to the process pool as separate tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the calculation is stored in `pool_outputs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the result of the `pool.map()` method is equivalent
    to Python's built-in `map()` function, except that the processes run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we have created a pool of four processes using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Each process has a list of integers as input. Here, `pool.map` works in the
    same way as the map, but uses multiple processes, whose number, four, was previously defined
    during pool creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To terminate the computation of the pool, the usual `close` and `join` functions are
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result that we get after completing the calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we saw that `Pool` also provides the `map` method,
    which allows us to apply a function to a different set of data. In particular,
    the scenario in which the same operation is performed in parallel on the elements
    of the input is referred to as*data parallelism*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, in which we use `Pool` and `map`, we create `pool`
    with `5` workers and, through the `map` method,a function of `f` is applied to
    a list of `10` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more information about process pools, use the following link: [https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm](https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm).'
  prefs: []
  type: TYPE_NORMAL
