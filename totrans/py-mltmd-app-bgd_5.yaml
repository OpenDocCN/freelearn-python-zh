- en: Chapter 5. Working with Audios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decades ago, silent movies lit up the screen but later, it was audio effect
    that brought life into them. We deal with digital audio processing quite frequently
    when just playing a CD track, recording your own voice or converting songs into
    a different audio format. There are many libraries or multimedia frameworks available
    for audio processing. This chapter teaches some common digital audio processing
    techniques using Python bindings of a popular multimedia framework called GStreamer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn basic concepts behind GStreamer multimedia framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use GStreamer API for audio processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop some simple audio processing tools for 'everyday use'. We will develop
    tools that will batch convert audio file formats, record an audio, and play audio
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it!
  prefs: []
  type: TYPE_NORMAL
- en: Installation prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are going to use an external multimedia framework, it is necessary
    to install the packages mentioned in this section.
  prefs: []
  type: TYPE_NORMAL
- en: GStreamer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GStreamer is a popular open source multimedia framework that supports audio/video
    manipulation of a wide range of multimedia formats. It is written in the C programming
    language and provides bindings for other programming languages including Python.
    Several open source projects use GStreamer framework to develop their own multimedia
    application. Throughout this chapter, we will make use of the GStreamer framework
    for audio handling. In order to get this working with Python, we need to install
    both GStreamer and the Python bindings for GStreamer.
  prefs: []
  type: TYPE_NORMAL
- en: Windows platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The binary distribution of GStreamer is not provided on the project website
    [http://www.gstreamer.net/](http://www.gstreamer.net/). Installing it from the
    source may require considerable effort on the part of Windows users. Fortunately,
    *GStreamer WinBuilds* project provides pre-compiled binary distributions. Here
    is the URL to the project website: [http://www.gstreamer-winbuild.ylatuya.es](http://www.gstreamer-winbuild.ylatuya.es)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The binary distribution for GStreamer as well as its Python bindings (Python
    2.6) are available in the **Download** area of the website: [http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download](http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download)'
  prefs: []
  type: TYPE_NORMAL
- en: You need to install two packages. First, the GStreamer and then the Python bindings
    to the GStreamer. Download and install the GPL distribution of GStreamer available
    on the GStreamer WinBuilds project website. The name of the GStreamer executable
    is `GStreamerWinBuild-0.10.5.1.exe`. The version should be 0.10.5 or higher. By
    default, this installation will create a folder [C:\gstreamer](http://C:%5Cgstreamer)
    on your machine. The `bin` directory within this folder contains runtime libraries
    needed while using GStreamer.
  prefs: []
  type: TYPE_NORMAL
- en: Next, install the Python bindings for GStreamer. The binary distribution is
    available on the same website. Use the executable `Pygst-0.10.15.1-Python2.6.exe`
    pertaining to Python 2.6\. The version should be 0.10.15 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GStreamer WinBuilds appears to be an independent project. It is based on the
    OSSBuild developing suite. Visit [http://code.google.com/p/ossbuild/](http://code.google.com/p/ossbuild/)
    for more information. It could happen that the GStreamer binary built with Python
    2.6 is no longer available on the mentioned website at the time you are reading
    this book. Therefore, it is advised that you should contact the developer community
    of OSSBuild. Perhaps they might help you out!
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can build GStreamer from source on the Windows platform,
    using a Linux-like environment for Windows, such as Cygwin (http://www.cygwin.com/).
    Under this environment, you can first install dependent software packages such
    as Python 2.6, gcc compiler, and others. Download the `gst-python-0.10.17.2.tar.gz`
    package from the GStreamer website [http://www.gstreamer.net/](http://www.gstreamer.net/).
    Then extract this package and install it from sources using the Cygwin environment.
    The `INSTALL` file within this package will have installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Other platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the Linux distributions provide GStreamer package. You can search for
    the appropriate `gst-python` distribution (for Python 2.6) in the package repository.
    If such a package is not available, install `gst-python` from the source as discussed
    in the earlier the *Windows platform* section.
  prefs: []
  type: TYPE_NORMAL
- en: If you are a Mac OS X user, visit [http://py26-gst-python.darwinports.com/](http://py26-gst-python.darwinports.com/).
    It has detailed instructions on how to download and install the package `Py26-gst-python
    version 0.10.17` (or higher).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mac OS X 10.5.x (Leopard) comes with the Python 2.5 distribution. If you are
    using packages using this default version of Python, GStreamer Python bindings
    using Python 2.5 are available on the darwinports website: [http://gst-python.darwinports.com/](http://gst-python.darwinports.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: PyGobject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a free multiplatform software utility library called ''GLib''. It
    provides data structures such as hash maps, linked lists, and so on. It also supports
    the creation of threads. The ''object system'' of GLib is called **GObject**.
    Here, we need to install the Python bindings for GObject. The Python bindings
    are available on the PyGTK website at: [http://www.pygtk.org/downloads.html](http://www.pygtk.org/downloads.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Windows platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The binary installer is available on the PyGTK website. The complete URL is:
    [http://ftp.acc.umu.se/pub/GNOME/binaries/win32/pygobject/2.20/](http://ftp.acc.umu.se/pub/GNOME/binaries/win32/pygobject/2.20/).
    Download and install version 2.20 for Python 2.6.'
  prefs: []
  type: TYPE_NORMAL
- en: Other platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Linux, the source tarball is available on the PyGTK website. There could
    even be binary distribution in the package repository of your Linux operating
    system. The direct link to the Version 2.21 of PyGObject (source tarball) is:
    [http://ftp.gnome.org/pub/GNOME/sources/pygobject/2.21/](http://ftp.gnome.org/pub/GNOME/sources/pygobject/2.21/).'
  prefs: []
  type: TYPE_NORMAL
- en: If you are a Mac user and you have Python 2.6 installed, a distribution of PyGObject
    is available at [http://py26-gobject.darwinports.com/](http://py26-gobject.darwinports.com/).
    Install version 2.14 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of installation prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table summarizes the packages needed for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '| Package | Download location | Version | Windows platform | Linux/Unix/OS
    X platforms |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GStreamer | [http://www.gstreamer.net/](http://www.gstreamer.net/) | 0.10.5
    or later | Install using binary distribution available on the Gstreamer WinBuild
    website:[http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download](http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download)Use
    `GStreamerWinBuild-0.10.5.1.exe` (or later version if available). | Linux: Use
    GStreamer distribution in package repository.Mac OS X: Download and install by
    following instructions on the website: [http://gstreamer.darwinports.com/](http://gstreamer.darwinports.com/).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Python Bindings for GStreamer | [http://www.gstreamer.net/](http://www.gstreamer.net/)
    | 0.10.15 or later for Python 2.6 | Use binary provided by GStreamer WinBuild
    project. See [http://www.gstreamer-winbuild.ylatuya.es](http://www.gstreamer-winbuild.ylatuya.es)
    for details pertaining to Python 2.6. | Linux: Use gst-python distribution in
    the package repository.Mac OS X: Use this package (if you are using Python2.6):
    [http://py26-gst-python.darwinports.com/](http://py26-gst-python.darwinports.com/).Linux/Mac:
    Build and install from the source tarball. |'
  prefs: []
  type: TYPE_TB
- en: '| Python bindings for GObject "PyGObject" | Source distribution:[http://www.pygtk.org/downloads.html](http://www.pygtk.org/downloads.html)
    | 2.14 or later for Python 2.6 | Use binary package from`pygobject-2.20.0.win32-py2.6.exe`
    | Linux: Install from source if pygobject is not available in the package repository.Mac:
    Use this package on darwinports (if you are using Python2.6) See [http://py26-gobject.darwinports.com/](http://py26-gobject.darwinports.com/)
    for details. |'
  prefs: []
  type: TYPE_TB
- en: Testing the installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ensure that the GStreamer and its Python bindings are properly installed. It
    is simple to test this. Just start Python from the command line and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If there is no error, it means the Python bindings are installed properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If this import is successful, we are all set to use GStreamer for processing
    audios and videos!
  prefs: []
  type: TYPE_NORMAL
- en: If `import gst` fails, it will probably complain that it is unable to work some
    required DLL/shared object. In this case, check your environment variables and
    make sure that the PATH variable has the correct path to the `gstreamer/bin` directory.
    The following lines of code in a Python interpreter show the typical location
    of the `pygst` and `gst` modules on the Windows platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, test if PyGObject is successfully installed. Start the Python interpreter
    and try importing the `gobject` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If this works, we are all set to proceed!
  prefs: []
  type: TYPE_NORMAL
- en: A primer on GStreamer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using GStreamer multimedia framework extensively.
    Before we move on to the topics that teach us various audio processing techniques,
    a primer on GStreamer is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: So what is GStreamer? It is a framework on top of which one can develop multimedia
    applications. The rich set of libraries it provides makes it easier to develop
    applications with complex audio/video processing capabilities. Fundamental components
    of GStreamer are briefly explained in the coming sub-sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comprehensive documentation is available on the GStreamer project website.
    GStreamer Application Development Manual is a very good starting point. In this
    section, we will briefly cover some of the important aspects of GStreamer. For
    further reading, you are recommended to visit the GStreamer project website: [http://www.gstreamer.net/documentation/](http://www.gstreamer.net/documentation/)'
  prefs: []
  type: TYPE_NORMAL
- en: gst-inspect and gst-launch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by learning the two important GStreamer commands. GStreamer can
    be run from the command line, by calling `gst-launch-0.10.exe` (on Windows) or
    `gst-launch-0.10` (on other platforms). The following command shows a typical
    execution of GStreamer on Linux. We will see what a `pipeline` means in the next
    sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: GStreamer has a plugin architecture. It supports a huge number of plugins. To
    see more details about any plugin in your GStreamer installation, use the command
    `gst-inspect-0.10` (gst-inspect-0.10.exe on Windows). We will use this command
    quite often. Use of this command is illustrated here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `decodebin` is a plugin. Upon execution of the preceding command, it prints
    detailed information about the plugin `decodebin`.
  prefs: []
  type: TYPE_NORMAL
- en: Elements and pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In GStreamer, the data flows in a pipeline. Various elements are connected together
    forming a pipeline, such that the output of the previous element is the input
    to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pipeline can be logically represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Element1` through to `Element5` are the element objects chained together
    by the symbol `!`. Each of the elements performs a specific task. One of the element
    objects performs the task of reading input data such as an audio or a video. Another
    element decodes the file read by the first element, whereas another element performs
    the job of converting this data into some other format and saving the output.
    As stated earlier, linking these element objects in a proper manner creates a
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a pipeline is similar to the one used in Unix. Following is a
    Unix example of a pipeline. Here, the vertical separator `|` defines the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `ls -la` lists all the files in a directory. However, sometimes, this
    list is too long to be displayed in the shell window. So, adding `| more` allows
    a user to navigate the data.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see a realistic example of running GStreamer from the command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For a Windows user, the `gst` command name would be `gst-launch-0.10.exe`. The
    pipeline is constructed by specifying different elements. The `!symbol` links
    the adjacent elements, thereby forming the whole pipeline for the data to flow.
    For Python bindings of GStreamer, the abstract base class for pipeline elements
    is `gst.Element`, whereas `gst.Pipeline` class can be used to created pipeline
    instance. In a pipeline, the data is sent to a separate thread where it is processed
    until it reaches the end or a termination signal is sent.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GStreamer is a plugin-based framework. There are several plugins available.
    A plugin is used to encapsulate the functionality of one or more GStreamer elements.
    Thus we can have a plugin where multiple elements work together to create the
    desired output. The plugin itself can then be used as an abstract element in the
    GStreamer pipeline. An example is `decodebin`. We will learn about it in the upcoming
    sections. A comprehensive list of available plugins is available at the GStreamer
    website [http://gstreamer.freedesktop.org](http://gstreamer.freedesktop.org).
    In this book, we will be using several of them to develop audio/video processing
    applications. For example, a plugin `Playbin` will be used for audio playback.
    In almost all applications to be developed, `decodebin` plugin will be used. For
    audio processing, the functionality provided by plugins such as `gnonlin, audioecho,
    monoscope, interleave`, and so on will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Bins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In GStreamer, a bin is a container that manages the element objects added to
    it. A bin instance can be created using gst.Bin class. It is inherited from `gst.Element`
    and can act as an abstract element representing a bunch of elements within it.
    A GStreamer plugin decodebin is a good example representing a bin. The decodebin
    contains decoder elements. It auto-plugs the decoder to create the decoding pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Pads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each element has some sort of *connection points* to handle data input and output.
    GStreamer refers to them as *pads*. Thus an element object can have one or more
    "receiver pads" termed as **sink pads** that accept data from the previous element
    in the pipeline. Similarly, there are 'source pads' that take the data out of
    the element as an input to the next element (if any) in the pipeline. The following
    is a very simple example that shows how source and sink pads are specified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `fakesrc` is the first element in the pipeline. Therefore, it only has a
    source pad. It transmits the data to the next `linkedelement`, that is `fakesink`
    which only has a sink pad to accept elements. Note that, in this case, since these
    are `fakesrc` and `fakesink`, just empty buffers are exchanged. A pad is defined
    by the class `gst.Pad`. A pad can be attached to an element object using the `gst.Element.add_pad()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a diagrammatic representation of a GStreamer element with a
    pad. It illustrates two GStreamer elements within a pipeline, having a single
    source and sink pad.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pads](img/0165_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know how the pads operate, let's discuss some of special types of
    pads. In the example, we assumed that the pads for the element are always 'out
    there'. However, there are some situations where the element doesn't have the
    pads available all the time. Such elements request the pads they need at runtime.
    Such a pad is called a dynamic pad. Another type of pad is called ghost pad. These
    types are discussed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic pads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some objects such as `decodebin` do not have pads defined when they are created.
    Such elements determine the type of pad to be used at the runtime. For example,
    depending on the media file input being processed, the `decodebin` will create
    a pad. This is often referred to as **dynamic pad** or sometimes the **available
    pad** as it is not always available in elements such as `decodebin`.
  prefs: []
  type: TYPE_NORMAL
- en: Ghost pads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As stated in the *Bins* section a **bin** object can act as an abstract element.
    How is it achieved? For that, the bin uses 'ghost pads' or 'pseudo link pads'.
    The ghost pads of a bin are used to connect an appropriate element inside it.
    A ghost pad can be created using `gst.GhostPad` class.
  prefs: []
  type: TYPE_NORMAL
- en: Caps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The element objects send and receive the data by using the pads. The type of
    media data that the element objects will handle is determined by the **caps**
    (a short form for **capabilities)**. It is a structure that describes the media
    formats supported by the element. The caps are defined by the class `gst.Caps`.
  prefs: []
  type: TYPE_NORMAL
- en: Bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `bus` refers to the object that delivers the message generated by GStreamer.
    A message is a `gst.Message` object that informs the application about an event
    within the pipeline. A message is put on the bus using the `gst.Bus.gst_bus_post()`
    method. The following code shows an example usage of the `bus`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first line in the code creates a `gst.Bus` instance. Here the pipeline is
    an instance of `gst.PipeLine`. On the next line, we add a signal watch so that
    the bus gives out all the messages posted on that bus. Line 3 connects the signal
    with a Python method. In this example, the message is the signal string and the
    method it calls is `message_handler`.
  prefs: []
  type: TYPE_NORMAL
- en: Playbin/Playbin2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playbin is a GStreamer plugin that provides a high-level audio/video player.
    It can handle a number of things such as automatic detection of the input media
    file format, auto-determination of decoders, audio visualization and volume control,
    and so on. The following line of code creates a `playbin` element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It defines a property called `uri`. The **URI** (Uniform **Resource Identifier)**
    should be an absolute path to a file on your computer or on the Web. According
    to the GStreamer documentation, Playbin2 is just the latest unstable version but
    once stable, it will replace the Playbin.
  prefs: []
  type: TYPE_NORMAL
- en: A Playbin2 instance can be created the same way as a Playbin instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this basic understanding, let us learn about various audio processing techniques
    using GStreamer and Python.
  prefs: []
  type: TYPE_NORMAL
- en: Playing music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given an audio file, one the first things you will do is to play that audio
    file, isn't it? In GStreamer, what basic elements do we need to play an audio?
    The essential elements are listed as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need is to open an audio file for reading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we need a decoder to transform the encoded information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, there needs to be an element to convert the audio format so that it is
    in a 'playable' format required by an audio device such as speakers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, an element that will enable the actual playback of the audio file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How will you play an audio file using the command-line version of GStreamer?
    One way to execute it using command line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `autoaudiosink` automatically detects the correct audio device on your
    computer to play the audio. This was tested on a machine with Windows XP and it
    worked fine. If there is any error playing an audio, check if the audio device
    on your computer is working properly. You can also try using element `sdlaudiosink`
    that outputs to the sound card via `SDLAUDIO` . If this doesn''t work, and you
    want to install a plugin for `audiosink` here is a partial list of GStreamer plugins:
    [http://www.gstreamer.net/data/doc/gstreamer/head/gst-plugins-good-plugins/html/](http://www.gstreamer.net/data/doc/gstreamer/head/gst-plugins-good-plugins/html/)'
  prefs: []
  type: TYPE_NORMAL
- en: Mac OS X users can try installing `osxaudiosink` if the default `autoaudiosink`
    doesn't work.
  prefs: []
  type: TYPE_NORMAL
- en: The audio file should start playing with this command unless there are any missing
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for action - playing an audio: method 1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of ways to play an audio using Python and GStreamer. Let's
    start with a simple one. In this section, we will use a command string, similar
    to what you would specify using the command-line version of GStreamer. This string
    will be used to construct a `gst.Pipeline` instance in a Python program.
  prefs: []
  type: TYPE_NORMAL
- en: So, here we go!
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating an `AudioPlayer` class in a Python source file. Just define
    the empty methods illustrated in the following code snippet. We will expand those
    in the later steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lines 1 to 5 in the code import the necessary modules. As discussed in the Installation
    prerequisites section, the package pygst is imported first. Then we call pygst.require
    to enable the import of gst module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now focus on the code block between lines 19 to 24\. It is the main execution
    code. It enables running the program until the music is played. We will use this
    or similar code throughout this book to run our audio application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 21, the thread module is used to create a new thread for playing the
    audio. The method AudioPlayer.play is sent on this thread. The second argument
    of thread.start_new_thread is the list of arguments to be passed to the method
    play. In this example, we do not support any command-line arguments. Therefore,
    an empty tuple is passed. Python adds its own thread management functionality
    on top of the operating system threads. When such a thread makes calls to external
    functions (such as C functions), it puts the 'Global Interpreter Lock' on other
    threads until, for instance, the C function returns a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The gobject.threads_init() is an initialization function for facilitating the
    use of Python threading within the gobject modules. It can enable or disable threading
    while calling the C functions. We call this before running the main event loop.
    The main event loop for executing this program is created using gobject on line
    23 and this loop is started by the call evt_loop.run().
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, fill the `AudioPlayer` class methods with the code. First, write the constructor
    of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The pipeline is constructed by the method call on line 2\. The flag self.is_playing
    is initialized to False. It will be used to determine whether the audio being
    played has reached the end of the stream. On line 4, a method self.connectSignals
    is called, to capture the messages posted on a bus. We will discuss both these
    methods next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main driver for playing the sound is the following `gst` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding string has four elements separated by the symbol !. These elements
    represent the components we briefly discussed earlier.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The first element `filesrc location=C:/AudioFiles/my_music.mp3` defines the
    source element that loads the audio file from a given location. In this string,
    just replace the audio file path represented by `location` with an appropriate
    file path on your computer. You can also specify a file on a disk drive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the filename contains namespaces, make sure you specify the path within
    quotes. For example, if the filename is my sound.mp3, specify it as follows: `filesrc
    location =\"C:/AudioFiles/my sound.mp3\`"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next element loads the file. This element is connected to a `decodebin`.
    As discussed earlier, the `decodebin` is a plugin to GStreamer and it inherits
    `gst.Bin`. Based on the input audio format, it determines the right type of decoder
    element to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third element is audioconvert. It translates the decoded audio data into
    a format playable by the audio device.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final element, autoaudiosink, is a plugin; it automatically detects the
    audio sink for the audio output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have sufficient information now to create an instance of gst.Pipeline. Write
    the following method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An instance of gst.Pipeline is created on line 5, using the gst.parse_launch
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now write the following method of class `AudioPlayer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On line 4, an instance of gst.Bus is created. In the introductory section on
    GStreamer, we already learned what the code between lines 4 to 6 does. This bus
    has the job of delivering the messages posted on it from the streaming threads.
    The add_signal_watch call makes the bus emit the message signal for each message
    posted. This signal is used by the method message_handler to take appropriate
    action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the following method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On line 2, we set the state of the gst pipeline to gst.STATE_PLAYING to start
    the audio streaming. The flag self.is_playing controls the while loop on line
    4\. This loop ensures that the main event loop is not terminated before the end
    of the audio stream is reached. Within the loop the call to time.sleep just buys
    some time for the audio streaming to finish. The value of flag is changed in the
    method message_handler that watches for the messages from the bus. On line 6,
    the main event loop is terminated. This gets called when the end of stream message
    is emitted or when some error occurs while playing the audio.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, develop method `AudioPlayer.message_handler`. This method sets the appropriate
    flag to terminate the main loop and is also responsible for changing the playing
    state of the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this method, we only check two things: whether the message on the bus says
    the streaming audio has reached its end (gst.MESSAGE_EOS ) or if any error occurred
    while playing the audio stream (gst.MESSAGE_ERROR ). For both these messages,
    the state of the gst pipeline is changed from gst.STATE_PLAYING to gst.STATE_NULL.
    The self.is_playing flag is updated to instruct the program to terminate the main
    event loop.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have defined all the necessary code to play the audio. Save the file as
    PlayingAudio.py and run the application from the command line as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will begin playback of the input audio file. Once it is done playing, the
    program will be terminated. You can press Ctrl + C on Windows or Linux to interrupt
    the playing of the audio file. It will terminate the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We developed a very simple audio player, which can play an input audio file.
    The code we wrote covered some of the most important components of GStreamer.
    These components will be useful throughout this chapter. The core component of
    the program was a GStreamer pipeline that had instructions to play the given audio
    file. Additionally, we learned how to create a thread and then start a `gobject`
    event loop to ensure that the audio file is played until the end.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero play audios from a playlist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simple audio player we developed can only play a single audio file, whose
    path is hardcoded in the constructed GStreamer pipeline. Modify this program so
    it can play audios in a "playlist". In this case, play list should define full
    paths of the audio files you would like to play, one after the other. For example,
    you can specify the file paths as arguments to this application or load the paths
    defined in a text file or load all audio files from a directory. Hint: In a later
    section, we will develop an audio file converter utility. See if you can use some
    of that code here.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a pipeline from elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section, a gst.Pipeline was automatically constructed for us by
    the gst.parse_launch method. All it required was an appropriate command string,
    similar to the one specified while running the command-line version of GStreamer.
    The creation and linking of elements was handled internally by this method. In
    this section, we will see how to construct a pipeline by adding and linking individual
    element objects. 'GStreamer Pipeline' construction is a fundamental technique
    that we will use throughout this chapter and also in other chapters related to
    audio and video processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for action - playing an audio: method 2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already developed code for playing an audio. Let's now tweak the method
    `AudioPlayer.constructPipeline` to build the `gst.Pipeline` using different element
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the `constructPipeline` method as follows. You can also download the
    file `PlayingAudio.py` from the Packt website for reference. This file has all
    the code we discussed in this and previous sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We begin by creating an instance of class `gst.Pipeline`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, on line 2, we create the element for loading the audio file. Any new `gst`
    element can be created using the API method, `gst.element_factory_make`. The method
    takes the element name (string) as an argument. For example, on line 3, this argument
    is specified as `"filesrc`" in order to create an instance of element `GstFileSrc`.
    Each element will have a set of properties. The path of the input audio file is
    stored in a property `location` of `self.filesrc` element. This property is set
    on line 4\. Replace the file path string with an appropriate audio file path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get a list of all properties by running the`'gst-inspect-0.10`' command
    from a console window. See the introductory section on **GSreamer** for more details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second optional argument serves as a custom name for the created object.
    For example, on line 20, the name for the `autoaudiosink` object is specified
    as `a_a_sink`. Like this, we create all the essential elements necessary to build
    the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 23 in the code, all the elements are put in the pipeline by calling
    the `gst.Pipeline.add` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `gst.element_link_many` establishes connection between two or more
    elements for the audio data to flow between them. The elements are linked together
    by the code on lines 26 and 27\. However, notice that we haven't linked together
    the elements `self.decodebin` and `self.audioconvert`. Why? That's up next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We cannot link the `decodebin` element with the `audioconvert` element at the
    time the pipeline is created. This is because `decodebin` uses dynamic pads. These
    pads are not available for connection with the `audioconvert` element when the
    pipeline is created. Depending upon the input data , it will create a pad. Thus,
    we need to watch out for a signal that is emitted when the `decodebin` adds a
    pad! How do we do that? It is done by the code on line 11 in the code snippet
    above. The "pad-added" signal is connected with a method, `decodebin_pad_added`.
    Whenever `decodebin` adds a dynamic pad, this method will get called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, all we need to do is to manually establish a connection between `decodebin`
    and `audioconvert` elements in the method `decodebin_pad_added`. Write the following
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method takes the element (in this case it is self.decodebin ) and pad as
    arguments. The pad is the new pad for the decodebin element. We need to link this
    pad with the appropriate one on self.audioconvert.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 2 in this code snippet, we find out what type of media data the pad
    handles. Once the capabilities (caps) are known, we pass this information to the
    method `get_compatible_pad` of object `self.audioconvert`. This method returns
    a compatible pad which is then linked with `pad` on line 6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the code is identical with the one illustrated in the earlier section.
    You can run this program the same way described earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned some very crucial components of GStreamer framework. With the simple
    audio player as an example, we created a GStreamer pipeline 'from scratch' by
    creating various element objects and linking them together. We also learned how
    to connect two elements by 'manually' linking their pads and why that was required
    for the element `self.decodebin`.
  prefs: []
  type: TYPE_NORMAL
- en: Pop Quiz - element linking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the earlier example, most of the elements in the pipeline linked using `gst.element_link_many`
    in method `AudioPlayer.constructPipeline`. However, we did not link the elements
    `self.decodebin` and `self.audioconvert` at the time when the pipeline was constructed.
    Why? Choose the correct answer from the following.
  prefs: []
  type: TYPE_NORMAL
- en: We were just trying out a different technique of manually linking these elements
    together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Decodebin` uses a dynamic pad that is created at the runtime. This pad is
    not available when the pipeline is created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't need to link these elements in the pipeline. The media data will just
    find its way somehow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are you talking about? It is impossible to connect `decodebin` and `audioconvert`
    elements no matter what you try.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Playing an audio from a website
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there is an audio somewhere on a website that you would like to play, we
    can pretty much use the same AudioPlayer class developed earlier. In this section,
    we will illustrate the use of gst.Playbin2 to play an audio by specifying a URL.
    The code snippet below shows the revised AudioPlayer.constructPipeline method.
    The name of this method should be changed as it is playbin object that it creates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: On line 4, the gst.Playbin2 element is created using `gst.element_factory_make`
    method. The argument to this method is a string that describes the element to
    be created. In this case it is "playbin2" . You can also define a custom name
    for this object by supplying an optional second argument to this method. Next,
    on line 5 and 6, we assign values to the properties uri and buffer-size. Set the
    uri property to an appropriate URL , the full path to the audio file you would
    like to play.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: When you execute this program, Python application tries to access the
    Internet. The anti-virus installed on your computer may block the program execution.
    In this case, you will need to allow this program to access the Internet. Also,
    you need to be careful of hackers. If you get the `fil_url` from an untrusted
    source, perform a safety check such as `assert not re.match("file://", file_url)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero use 'playbin' to play local audios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the last few sections, we learned different ways to play an audio file using
    Python and GStreamer. In the previous section, you must have noticed another simple
    way to achieve this, using a playbin or playbin2 object to play an audio. In the
    previous section, we learned how to play an audio file from a URL. Modify this
    code so that this program can now play audio files located in a drive on your
    computer. Hint: You will need to use the correct "uri" path. Convert the file
    path using Python''s module `urllib.pathname2url` and then append it to the string:
    `"file://`".'
  prefs: []
  type: TYPE_NORMAL
- en: Converting audio file format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you have a big collection of songs in wav file format that you would
    like to load on a cell phone. But you find out that the cell phone memory card
    doesn't have enough space to hold all these. What will you do? You will probably
    try to reduce the size of the song files right? Converting the files into mp3
    format will reduce the size. Of course you can do it using some media player.
    Let's learn how to perform this conversion operation using Python and GStreamer.
    Later we will develop a simple command-line utility that can be used to perform
    a batch conversion for all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: Like in the earlier examples, let's first list the important building blocks
    we need to accomplish file conversion. The first three elements remain the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As before, the first thing we need is to load an audio file for reading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need a decoder to transform the encoded information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, there needs to be an element to convert the raw audio buffers into an
    appropriate format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An encoder is needed that takes the raw audio data and encodes it to an appropriate
    file format to be written.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An element where the encoded data will be streamed to is needed. In this case
    it is our output audio file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Okay, what's next? Before jumping into the code, first check if you can achieve
    what you want using the command-line version of GStreamer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Specify the correct input and output file paths and run this command to convert
    a wave file to an mp3\. If it works, we are all set to proceed. Otherwise check
    for missing plugins.
  prefs: []
  type: TYPE_NORMAL
- en: You should refer to the GStreamer API documentation to know more about the properties
    of various elements illustrated above. Trust me, the `gst-inspect-0.10` (or `gst-inspect-0.10.exe`
    for Windows users) command is a very handy tool that will help you understand
    the components of a GStreamer plugin. The instructions on running this tool are
    already discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - audio file format converter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a simple audio file converter. This utility will batch process
    input audio files and save them in a user-specified file format. To get started,
    download the file AudioConverter.py from the Packt website. This file can be run
    from the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Where, the `[options]` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--input_dir` : The directory from which to read the input audio file(s) to
    be converted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--input_format:` The audio format of the input files. The format should be
    in a supported list of formats. The supported formats are "mp3", "ogg", and "wav".
    If no format is specified, it will use the default format as ".wav".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--output_dir` : The output directory where the converted files will be saved.
    If no output directory is specified, it will create a folder `OUTPUT_AUDIOS` within
    the input directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--output_format:` The audio format of the output file. Supported output formats
    are "wav" and "mp3".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's write this code now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start by importing necessary modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now declare the following class and the utility function. As you will notice,
    several of the methods have the same names as before. The underlying functionality
    of these methods will be similar to what we already discussed. In this section
    we will review only the most important methods in this class. You can refer to
    file `AudioConverter.py` for other methods or develop those on your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Look at the last few lines of code above. This is exactly the same code we used
    in the Playing Music section. The only difference is the name of the class and
    its method that is put on the thread in the call `thread.start_new_thread`. At
    the beginning, the function `audioFileExists()` is declared. It will be used to
    check if the specified path is a valid file path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now write the constructor of the class. Here we do initialization of various
    variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The self.supportedOutputFormats is a tuple that stores the supported output
    formats. `self.supportedInputFormats` is a list obtained from the keys of `self.encoders`
    and stores the supported input formats. These objects are used in `self.processArguments`
    to do necessary checks. The dictionary `self.encoders` provides the correct type
    of encoder string to be used to create an encoder element object for the GStreamer
    pipeline. As the name suggests, the call to `self.constructPipeline()` builds
    a `gst.Pipeline` instance and various signals are connected using `self.connectSignals()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, prepare a GStreamer pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code is similar to the one we developed in the *Playing Music* sub-section.
    However there are some noticeable differences. In the Audio Player example, we
    used the `autoaudiosink` plugin as the last element. In the Audio Converter, we
    have replaced it with elements `self.encoder` and `self.filesink`. The former
    encodes the audio data coming out of the `self.audioconvert`. The encoder will
    be linked to the sink element. In this case, it is a `filesink`. The `self.filesink`
    is where the audio data is written to a file given by the `location` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The encoder string, `encoder_str` determines the type of encoder element to
    create. For example, if the output format is specified as "mp3" the corresponding
    encoder to use is "lame" mp3 encoder. You can run the gst-inspect-0.10 command
    to know more about the `lame` mp3 encoder. The following command can be run from
    shell on Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The elements are added to the pipeline and then linked together. As before,
    the `self.decodebin` and `self.audioconvert` are not linked in this method as
    the `decodebin` plugin uses dynamic pads. The `pad_added` signal from the `self.decodebin`
    is connected in the `self.connectSignals()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another noticeable change is that we have not set the `location` property for
    both, `self.filesrc` and `self.filesink`. These properties will be set at the
    runtime. The input and output file locations keep on changing as the tool is a
    batch processing utility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's write the main method that controls the conversion process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code between lines 2 to 26 is similar to the one developed in the Image
    File conversion utility in this book. Refer to the Reading and Writing Images
    section of [Chapter 2](ch02.html "Chapter 2. Working with Images") to know what
    that code does. All the input audio files are collected in the list `inputFileList`
    by the code between lines 2 to 6 . Then, we loop over each of these files. First,
    the output file path is derived based on user inputs and then the input file path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The highlighted line of code is the workhorse method, `AudioConverter.convert_single_audio`,
    that actually does the job of converting the input audio. We will discuss that
    method next. On line 43, the main event loop is terminated. The rest of the code
    in method convert is self-explanatory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code in method `convert_single_audio` is illustrated below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As mentioned in the last step, `convert_single_audio` method is called within
    a for loop in the `self.convert()` . The for loop iterates over a list containing
    input audio file paths. The input and output file paths are given as arguments
    to this method. The code between lines 8-12 looks more or less similar to `AudioPlayer.play()`
    method illustrated in the *Play audio section*. The only difference is the main
    event loop is not terminated in this method. Earlier we did not set the location
    property for the file source and sink. These properties are set on lines 6 and
    7 respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now what''s up with the code on lines 2 and 3? The call `repr(inPath)` returns
    a printable representation of the string `inPath`. The `inPath` is obtained from
    the ''for loop''. The `os.path.normpath` doesn''t work on this string. In Windows,
    if you directly use `inPath`, GStreamer will throw an error while processing such
    a path string. One way to handle this is to use `repr(string)` , which will return
    the whole string including the quotes . For example: if `inPath` be "C:/AudioFiles/my_music.mp3"
    , then `repr(inPath)` will return `"''C:\\\\AudioFiles\\\\my_music.mp3''`". Notice
    that it has two single quotes. We need to get rid of the extra single quotes at
    the beginning and end by slicing the string as `inPth[1:-1]`. There could be some
    other better ways. You can come up with one and then just use that code as a path
    string!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s quickly skim through a few more methods. Write these down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `connectSignal` method is identical to the one discussed in the *Playing
    music* section, except that we are also connecting the `decodebin` signal with
    a method `decodebin_pad_added`. Add a print statement to `decodebin_pad_added`
    to check when it gets called. It will help you understand how the dynamic pad
    works! The program starts by processing the first audio file. The method `convert_single_audio`
    gets called. Here, we set the necessary file paths. After that, it begins playing
    the audio file. At this time, the `pad_added` signal is generated. Thus based
    on the input file data, `decodebin` will create the pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the methods such as `processArgs, printUsage`, and `message_handler`
    are self-explanatory. You can review these methods from the file `AudioConverter.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The audio converter should be ready for action now! Make sure that all methods
    are properly defined and then run the code by specifying appropriate input arguments.
    The following screenshot shows a sample run of audio conversion utility on Windows
    XP. Here, it will batch process all audio files in directory `C:\AudioFiles` with
    extension `.ogg` and convert them into mp3 file format . The resultant mp3 files
    will be created in directory `C:\AudioFiles\OUTPUT_AUDIOS`.![Time for action -
    audio file format converter](img/0165_5_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A basic audio conversion utility was developed in the previous section. This
    utility can batch-convert audio files with ogg or mp3 or wav format into user-specified
    output format (where supported formats are wav and mp3). We learned how to specify
    encoder and filesink elements and link them in the GStreamer pipeline. To accomplish
    this task, we also applied knowledge gained in earlier sections such as creation
    of GStreamer pipeline, capturing bus messages, running the main event loop, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero do more with audio converter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The audio converter we wrote is fairly simple. It deserves an upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Extend this application to support more audio output formats such as `ogg, flac`,
    and so on. The following pipeline illustrated one way of converting an input audio
    file into ogg file format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have an audio muxer, oggmux, that needs to be linked with encoder
    vorbisenc. Similarly, to create an MP4 audio file, it will need { faac ! mp4mux}
    as encoder and audio muxer. One of the simplest things to do is to define proper
    elements (such as encoder and muxer) and instead of constructing a pipeline from
    individual elements, use the `gst.parse_launch` method we studied earlier and
    let it automatically create and link elements using the command string. You can
    create a pipeline instance each time the audio conversion is called for. But in
    this case you would also need to connect signals each time the pipeline is created.
    Another better and simpler way is to link the audio muxer in the `AudioConverter.constructPipeline`
    method. You just need to check if it is needed based on the type of plugin you
    are using for encoding. In this case the code will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The audio converter illustrated in this example takes input files of only a
    single audio file format. This can easily be extended to accept input audio files
    in all supported file formats (except for the type specified by the `--output_format`
    option). The `decodebin` should take care of decoding the given input data. Extend
    Audio Converter to support this feature. You will need to modify the code in the
    `AudioConverter.convert()` method where the input file list is determined.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting part of an audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you have recorded a live concert of your favorite musician or a singer.
    You have saved all this into a single file with MP3 format but you would like
    to break this file into small pieces. There is more than one way to achieve this
    using Python and GStreamer. We will use the simplest and perhaps the most efficient
    way of cutting a small piece from an audio track. It makes use of an excellent
    GStreamer plugin, called Gnonlin.
  prefs: []
  type: TYPE_NORMAL
- en: The Gnonlin plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The multimedia editing can be classified as linear or non-linear. Non-linear
    multimedia editing enables control over the media progress in an interactive way.
    For example, it allows you to control the order in which the sources should be
    executed. At the same time it allows modifications to the position in a media
    track. While doing all this, note that the original source (such as an audio file)
    remains unchanged. Thus the editing is non-destructive. The Gnonlin or (G-Non-Linear)
    provides essential elements for non-linear editing of a multimedia. It has five
    major elements, namely, `gnlfilesource, gnlurisource, gnlcomposition, gnloperation`,
    and `gnlsource`. To know more about their properties, run gst-inspect-0.10 command
    on each of these elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will only focus on the element gnlfilesource and a few of its properties.
    This is really a GStreamer bin element. Like decodebin, it determines which pads
    to use at the runtime. As the name suggests, it deals with the input media file.
    All you need to specify is the input media source it needs to handle. The media
    file format can be any of the supported media formats. The gnlfilesource defines
    a number of properties. To extract a chunk of an audio, we just need to consider
    three of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`media-start:` The position in the input media file, which will become the
    start position of the extracted media. This is specified in nanoseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`media-duration:` Total duration of the extracted media file (beginning from
    `media-start)`. This is specified in nanoseconds as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uri:` The full path of the input media file. For example, if it is a file
    on your local hard drive, the `uri` will be something like `file:///C:/AudioFiles/my_music.mp3`.
    If the file is located on a website, then the `uri` will something of this sort:
    `http://path/to/file.mp3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The gnlfilesource internally does operations like loading and decoding the file,
    seeking the track to the specified position, and so on. This makes our job easier.
    We just need to create basic elements that will process the information furnished
    by gnlfilesource, to create an output audio file. Now that we know the basics
    of gnlfilesource, let's try to come up with a GStreamer pipeline that will cut
    a portion of an input audio file.
  prefs: []
  type: TYPE_NORMAL
- en: First the `gnlfilesource` element that does the crucial job of loading, decoding
    the file, seeking the correct start position, and finally presenting us with an
    audio data that represents the portion of track to be extracted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `audioconvert` element that will convert this data into an appropriate audio
    format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An encoder that encodes this data further into the final audio format we want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sink where the output data is dumped. This specifies the output audio file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try running the following from the command prompt by replacing the uri and location
    paths with appropriate file paths on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This should create an extracted audio file of duration 15 seconds, starting
    at the initial position on the original file. Note that the media-start and media-duration
    properties take the input in nanoseconds. This is really the essence of what we
    will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - MP3 cutter!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will develop a utility that will cut out a portion of an
    MP3 formatted audio and save it as a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: Keep the file `AudioCutter.py` handy. You can download it from the Packt website.
    Here we will only discuss important methods. The methods not discussed here are
    similar to the ones from earlier examples. Review the file `AudioCutter.py` which
    has all the necessary source code to run this application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the usual way. Do the necessary imports and write the following skeleton
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The overall code layout looks familiar doesn't it? The code is very similar
    to the code we developed earlier in this chapter. The key here is the appropriate
    choice of the file source element and linking it with the rest of the pipeline!
    The last few lines of code create a thread with method AudioCutter.run and run
    the main event loop as seen before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now fill in the constructor of the class. We will keep it simple this time.
    The things we need will be hardcoded within the constructor of the `class AudioCutter`.
    It is very easy to implement a `processArgs()` method as done on many occasions
    before. Replace the input and output file locations in the code snippet with a
    proper audio file path on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: the `self.media_start_time` is the new starting position of the mp3 file in
    seconds. This is the new start position for the extracted output audio. The `self.duration`
    variable stores the total duration extracted track. Thus, if you have an audio
    file with a total duration of 5 minutes, the extracted audio will have a starting
    position corresponding to 1 min, 40 seconds on the original track. The total duration
    of this output file will be 30 seconds, that is, the end time will correspond
    to 2 minutes, 10 seconds on the original track. The last two lines of this method
    build a pipeline and connect signals with class methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, build the GStreamer pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The highlighted line of code (line 3) creates the gnlfilesource. We call this
    as self.filesrc. As discussed earlier, this is responsible for loading and decoding
    audio data and presenting only the required portion of audio data that we need.
    It enables a higher level of abstraction in the main pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code between lines 9 to 13 sets three properties of `gnlfilesource, uri,
    media-start` and `media-duration` . The `media-start` and `media-duration` are
    specified in nanoseconds. Therefore, we multiply the parameter value (which is
    in seconds) by `gst.SECOND` which takes care of the units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the code looks very much similar to the Audio Converter example.
    In this case, we only support saving the file in mp3 audio format. The encoder
    element is defined on line 19. `self.filesink` determines where the output file
    will be saved. Elements are added to the pipeline by self.pipeline.add call and
    are linked together on line 32\. Note that the `gnlfilesource` element, `self.filesrc`,
    is not linked with `self.audioconvert` while constructing the pipeline. Like the
    `decodebin`, the `gnlfilesource` implements dynamic pads. Thus, the pad is not
    available when the pipeline is constructed. It is created at the runtime depending
    on the specified input audio format. The "pad_added" signal of `gnlfilesource`
    is connected with a method `self.gnonlin_pad_added`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now write the `connectSignals` and `gnonlin_pad_added` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The highlighted line of code in method connectSignals connects the pad_added
    signal of gnlfilesource with a method gnonlin_pad_added. The gnonlin_pad_added
    method is identical to the decodebin_pad_added method of class AudioConverter
    developed earlier. Whenever gnlfilesource creates a pad at the runtime, this method
    gets called and here, we manually link the pads of gnlfilesource with the compatible
    pad on self.audioconvert.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the code is very much similar to the code developed in the *Playing
    an audio* section. For example, `AudioCutter.run` method is equivalent to `AudioPlayer.play`
    and so on. You can review the code for remaining methods from the file `AudioCutter.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once everything is in place, run the program from the command line as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should create a new MP3 file which is just a specific portion of the original
    audio file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We accomplished creation of a utility that can cut a piece out of an MP3 audio
    file (yet keep the original file unchanged). This audio piece was saved as a separate
    MP3 file. We learned about a very useful plugin, called Gnonlin, intended for
    non-linear multimedia editing. A few fundamental properties of gnlfilesource element
    in this plugin to extract an audio file.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero extend MP3 cutter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify this program so that the parameters such as `media_start_time` can be
    passed as an argument to the program. You will need a method like `processArguments()`.
    You can use either `getopt` or `OptionParser` module to parse the arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add support for other file formats. For example, extend this code so that it
    can extract a piece from a wav formatted audio and save it as an MP3 audio file.
    The input part will be handled by `gnlfilesource`. Depending upon the type of
    output file format, you will need a specific encoder and possibly an audio muxer
    element. Then add and link these elements in the main GStreamer pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning how to cut out a piece from our favorite music tracks, the next
    exciting thing we will have is a 'home grown' audio recorder. Then use it the
    way you like to record music, mimicry or just a simple speech!
  prefs: []
  type: TYPE_NORMAL
- en: Remember what pipeline we used to play an audio? The elements in the pipeline
    to play an audio were `filesrc ! decodebin ! audioconvert ! autoaudiosink` . The
    autoaudiosink did the job of automatically detecting the output audio device on
    your computer.
  prefs: []
  type: TYPE_NORMAL
- en: For recording purposes, the audio source is going to be from the microphone
    connected to your computer. Thus, there won't be any `filesrc` element. We will
    instead replace with a GStreamer plugin that automatically detects the input audio
    device. On similar lines, you probably want to save the recording to a file. So,
    the `autoaudiosink` element gets replaced with a `filesink` element.
  prefs: []
  type: TYPE_NORMAL
- en: autoaudiosrc is an element we can possibly use for detecting input audio source.
    However, while testing this program on Windows XP, the autoaudiosrc was unable
    to detect the audio source for unknown reasons. So, we will use the `Directshow`
    audio capture source plugin called dshowaudiosrc, to accomplish the recording
    task. Run the `gst-inspect-0.10 dshowaudiosrc` command to make sure it is installed
    and to learn various properties of this element. Putting this plugin in the pipeline
    worked fine on Windows XP. The `dshowaudiosrc` is linked to the audioconvert.
  prefs: []
  type: TYPE_NORMAL
- en: With this information, let's give it a try using the command-line version of
    GStreamer. Make sure you have a microphone connected or built into your computer.
    For a change, we will save the output file in `ogg` format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The audioresample re-samples the raw audio data with different sample rates.
    Then the encoder element encodes it. The multiplexer or mux, if present, takes
    the encoded data and puts it into a single channel. The recorded audio file is
    written to the location specified by the filesink element.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - recording
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, time to write some code that does audio recording for us.
  prefs: []
  type: TYPE_NORMAL
- en: Download the file `RecordingAudio.py` and review the code. You will notice that
    the only important task is to set up a proper pipeline for audio recording. Content-wise,
    the other code is very much similar to what we learned earlier in the chapter.
    It will have some minor differences such as method names and print statements.
    In this section we will discuss only the important methods in the `class AudioRecorder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is similar to the `AudioPlayer.__init__()` except that we have added a
    call to `processArgs()` and initialized the error reporting variable `self.error_message`
    and the variable that indicates the total duration of the recording.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the GStreamer pipeline by writing `constructPipeline` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `dshowaudiosrc` (Directshow audiosrc) plugin as an audio source element.
    It finds out the input audio source which will be, for instance, the audio input
    from a microphone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 9, we set the number of buffers property to the one specified by `self.num_buffers`.
    This has a default value as `-1` , indicating that there is no limit on the number
    of buffers. If you specify this value as `500` for instance, it will output `500`
    buffers (5 second duration) before sending a **End of Stream** message to end
    the run of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 15, an instance of element 'audioresample' is created. This element
    is takes the raw audio buffer from the `self.audioconvert` and re-samples it to
    different sample rates. The encoder element then encodes the audio data into a
    suitable format and the recorder file is written to the location specified by
    `self.filesink`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code between lines 28 to 35 adds various elements to the pipeline and links
    them together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the code in file `RecordingAudio.py` to add rest of the code. Then run
    the program to record your voice or anything that you want to record that makes
    an audible sound! Following are sample command-line arguments. This program will
    record an audio for 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to record an audio using Python and GStreamer. We developed a
    simple audio recording utility to accomplish this task. The GStreamer plugin,
    dshowaudiosrc, captured the audio input for us. We created the main GStreamer
    Pipeline by adding this and other elements and used it for the Audio Recorder
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter gave us deeper insight into the fundamentals of audio processing
    using Python and the GStreamer multimedia framework. We used several important
    components of GStreamer to develop some frequently needed audio processing utilities.
    The main learning points of the chapter can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GStreamer installation: We learned how to install GStreamer and the dependent
    packages on various platforms. This set up a stage for learning audio processing
    techniques and will also be useful for the next chapters on audio/video processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A primer on GStreamer: A quick primer on GStreamer helped us understand important
    elements required for media processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use of GStreamer API to develop audio tools: We learned how to use GStremer
    API for general audio processing. This helped us develop tools such as an Audio
    player, a file format converter, an MP3 cutter, and audio recorder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've learned about basic audio processing using GStreamer, we're ready
    to add some 'spice' to the audio. In the next chapter we will learn techniques
    that will help us add special effects to an audio.
  prefs: []
  type: TYPE_NORMAL
