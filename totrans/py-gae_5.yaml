- en: Chapter 5. Storing Data in Google Cloud SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google Cloud SQL is a MySQL database server instance that lives in the Google
    cloud infrastructure; it can be used from outside Google Cloud Platform within
    applications that don''t run on the App Engine platform. We will learn how to
    use it both ways: by adding code to our Notes application and creating a standalone
    script that runs on our workstation.'
  prefs: []
  type: TYPE_NORMAL
- en: Google offers two billing plans for Cloud SQL, **Packages** and **Per Use**,
    without providing any free tier. This means we have to pay to execute the code
    in this chapter, though choosing the Per Use plan and running the instance for
    the sole purpose of going through the chapter should be extremely cheap.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create, configure, and run a Cloud SQL instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage a running instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Cloud SQL from App Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Cloud SQL from outside App Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Cloud SQL instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make heavy use of Developer Console throughout this chapter, and we
    start by creating an instance of a Cloud SQL database. As we already know from
    [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*, even if
    we created our Notes application from App Engine Admin Console, we should have
    a corresponding project on Developer Console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, we must have enabled the billing feature for our project to access
    all the Cloud-SQL-related functionalities from within Developer Console.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Developer Console, once our project is selected, we have to perform the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Cloud SQL** item under the **Storage** section on the left-hand
    side menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the **Create an instance** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a name for the database instance, for example, **myfirst**; the name
    of the instance must be unique within a project and will be always combined with
    the project name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **REGION**, the same as the location of the App Engine application (most
    likely **United States**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a tier for the instance; we can safely use the cheapest tier for the
    purpose of this chapter, the one labeled **D0**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows Developer Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Cloud SQL instance](img/8194OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The creation process for our Cloud SQL instance will immediately start. In a
    few minutes, the status of the instance will become runnable, which means that
    we can start the instance whenever we need it. We're not charged of any fee while
    the instance is in the runnable state.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before using our database instance, we should configure access permissions and
    credentials to control who can perform connections to the database and how. There
    are two levels of access control, one at the Cloud Platform level and another
    at the database level. The first level authorizes access to the Cloud SQL instance
    from client applications, either from the App Engine infrastructure by checking
    the application ID, or from a remote node on the Internet by checking the source
    IP address. The second level is the MySQL privilege system that is responsible
    for authentication of users and associate them with privileges on databases, such
    as the ability to perform the `SELECT`, `INSERT`, `UPDATE` or `DELETE` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we created the Cloud SQL instance from within our project settings in Developer
    Console, our App Engine application is already authorized to connect to the database.
    To double-check, on Developer Console we have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Cloud SQL** menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the instance ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Access Control** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Authorized App Engine Applications** label, we can see whether our
    application ID is listed.
  prefs: []
  type: TYPE_NORMAL
- en: While we are on that page, we can set up the access for our local machine; this
    is needed to perform administrative tasks such as adding users and databases using
    any MySQL client. We first need to assign an IP address for our instance so that
    we can reach it from outside the Cloud Platform infrastructure; click the **Add
    new** link, next to the **IP Addresses** label and wait for the address to be
    assigned to our instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we request an IP address for Cloud SQL instances, we should be aware that
    we will be charged for the time we use this address while instances are not running.
    To lower costs, we can release the IP address as soon as we don't need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we connect from our local machine to the Cloud SQL instance, we are obviously
    outside the App Engine infrastructure, so we have to add our public IP address
    to the list of the hosts allowed to access from the Internet. For this, we need
    to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get our public IP address; we can use Google for this by hitting this [https://www.google.com/#q=my-ip](https://www.google.com/#q=my-ip)
    URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add new** link next to the **Authorized Networks** label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill out the form with our public IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows Developer Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring access](img/8194OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From now on, we can connect to our Cloud SQL instance using the MySQL command
    line client, for instance, from our laptop. For the first level of the access
    control system, that's enough for now; we can proceed to configuring the second
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the root password
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step to take full control of our Cloud SQL instance is setting a
    password for the MySQL `root` user; to do this, perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On Developer Console, we go to the **ACCESS CONTROL** tab page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill the field under the **Set Root Password** section with the desired password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Set** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next paragraph, we will see how to connect to the instance as a `root`
    user and perform the administrative tasks we need to complete before using the
    instance from within our Notes application.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the instance with the MySQL console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To interact with our Cloud SQL instance, we will use the MySQL command line
    client, which is available for all the platforms supported by App Engine, even
    if we can use any client we feel more comfortable with. The client is usually
    shipped together with most MySQL server installation packages; besides having
    the MySQL client tool installed, it is advisable to install MySQL and have a local
    server running so that we can work with it instead of the production instance
    while developing applications. We will get back to this soon in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the notes database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first task we need to perform is creating a new database on the Cloud SQL
    instance; we will use this to store data from our Notes application. To connect
    to the instance, we issue the following from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After inserting the password for the `root` user, we should get into the MySQL
    monitor and see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we successfully managed to get to the prompt, we can create a database named
    `notes` by issuing the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output of the command should be very similar to the previous command in
    the case of success; we can now proceed to creating a dedicated database user
    we will use to perform connections from our Notes application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dedicated user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `root` user in a MySQL installation has unlimited privileges and it is
    a good security practice to avoid connecting to the server with the `superuser`
    credentials. For this reason, we create a dedicated user that we will use to make
    connections from our Notes application and that is able to operate exclusively
    on the `notes` database. Before proceeding, we remove the anonymous localhost
    access provided by default in Cloud SQL instances; this is a good security practice
    and avoids the anonymous user to shadow regular users when MySQL checks for user
    permissions. From the client, we issue the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We then proceed creating a regular user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we should pick up a stronger password; anyway, we have just created
    a new user named `notes` who will be able to perform connections from any host
    (notice the `%` character that is a wildcard matching any host). For convenience,
    we grant to the `notes` user any privilege on the `notes` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We finally make MySQL server reload all the updated privileges with the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now disconnect from the server, ending the current session with the
    `\q` command and try to reconnect using the `notes` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We should establish a connection with the MySQL monitor without errors, and
    then we can check whether we can actually access the `notes` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can now proceed with creating tables for storing data in our Notes application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we want to log users activities and store this information on a database
    so that we can use them later for, let''s say, business intelligence analysis.
    Using Datastore for this purpose is not a good idea for at least two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We will likely end with writing a lot of data, thus we cannot use too many indexes
    and we might have to refrain from using grouped entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will require another App Engine application to retrieve and analyze data
    because we cannot access Datastore from outside the platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloud SQL can solve both the issues above, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing limits for Cloud SQL are far more loose than Datastore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can connect to the Cloud SQL instance from an external application and access
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now start defining the data we want to log; for a simple usage analysis,
    we can save the user identifier, the type of operation performed, and the date
    and time of such an operation. Once connected to the server with the MySQL client,
    we can issue the `CREATE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the query succeeded, we should see something like this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL statement creates a relation or table named `ops` inside the `notes`
    database. The table has 4 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The** `id` **column** This contains integer values that increment automatically
    every time a new row is inserted; this is the primary key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `user_id` **column**: This holds the user identifier provided by App
    Engine, which is usually 56 characters long; we set 128 as the length so that
    we have room if the length grows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `operation` **column**: This is to store the type of operation logged;
    16 characters should be more than enough.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `date` **column**: This holds the date and time when operation was
    logged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to the instance from our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect with Cloud SQL instances from our Python code, we use the `MySQLdb`
    package, which is a MySQL driver that implements the Python Database API as described
    in the **PEP 249** document. To install the package, we can use `pip`; from the
    command line, we issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t specify the `-t` option as we did when installing GCS Client Library
    in [Chapter 3](ch03.html "Chapter 3. Storing and Processing Users'' Data"), *Storing
    and Processing Users'' Data* because the `MySQLdb` package is included in App
    Engine Python Runtime Environment on the production servers and we don''t need
    to upload it during deployment. Instead, we list the package in the `libraries`
    section of the `app.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple test to check if the database connection is working correctly consists
    of retrieving and logging the Cloud SQL version number. We add a function to the
    `utils.py` module to retrieve a connection to the database. We first need to import
    the `MySQLdb` package at the top of our `utils.py` module along with the `os`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returns a connection to the database. We retrieve all the information
    to perform the connection accessing some environment variables so that they are
    easily available from any point in our codebase. To define environment variables,
    we just have to add this at the bottom of our `app.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the database connection to get the MySQL version in the `get()`
    method of the `MainHandler` class in the `main.py` module. We first import the
    `get_cloudsql_db()` method and the `logging` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We modify the `get()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the Notes application with the local development server and access
    the main page with our browser; if everything is okay, we should see a message
    in the log console (or in your shell if you launched the `dev_appserver.py` server
    from there) similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good, but if we try to deploy the application on App Engine, the
    result will be an error page with this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OperationalError: (2004, "Can''t create TCP/IP socket (-1)")**'
  prefs: []
  type: TYPE_NORMAL
- en: This is because we are trying to access the Cloud SQL instance using a TCP/IP
    socket, which is perfectly fine if we connect from outside App Engine; due to
    the runtime environment networking restriction though, if we connect from an App
    Engine application, we have to use a Unix socket instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the connection string in the `utils.py` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define an additional environment variable named `CLOUD_SQL_INSTANCE_ID`
    in our `app.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to deploy this version of the application, we''ll notice this actually
    works on App Engine but it won''t work on the local environment server anymore.
    To avoid changing the code in the `get_cloudsql_db()` function every time we switch
    from development to production, we can provide a method that detects automatically
    whether an application is running locally or on the App Engine servers. In the
    `utils.py` module, we add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This function simply returns the `True` parameter if the application is running
    on App Engine and the `False` parameter otherwise. We can use the function in
    the `get_cloudsql_db()` function in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The function will always return the right database connection for the environment
    our application is running on.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and saving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to connect to a Cloud SQL instance from our App Engine
    application, it''s time to learn how to write and read data from the database.
    We already created a table called `ops`, and we will use it to store information
    about user operations. We will log the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: A user has created a note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user has added a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user has performed a shrink operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to assign a text code to each of the operation types we want to log.
    To do so, we can use a simple Python class that works as an enumeration. In the
    `utils.py` module, we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see how to use it in a moment. We now provide a `log_operation()` method
    in the `utils.py` module that we will use to log operations in the Cloud SQL database.
    We will call this function within the Notes code passing along the user who actually
    performed the operation, the appropriate operation type, and the date and time
    of the operation. The code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We first retrieve a valid database connection, and then we get a cursor object
    by calling the `cursor()` method on the connection object. By calling the `execute()`
    method on the cursor object, we can issue SQL statements contained in the string
    we pass as a parameter. In this case, we insert a new row in the `ops` table,
    persisting the user identifier, the string corresponding to the operation type,
    and the date and time when the operation was performed. We finally commit the
    transaction and close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the `log_operation()` method from the `main.py` module at various
    points in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `post()` method of the `MainHandler` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `get()` method of the `ShrinkHandler` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `receive()` method of the `CreateNoteHandler` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that by passing the date and time to the `log_operation()` method, we
    can record the actual time at which the user performs the operation instead of
    the time at which the function code was executed; this can be useful if we need
    to be punctual but the function is added to a task queue and executed at a later
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, when someone uses our Notes application, we will collect usage
    information about that user. We can access this information from the Notes application
    itself or another application on App Engine that is authorized to access the same
    Cloud SQL instance; otherwise, we can use a pure Python application that runs
    on our workstation or another remote server to access and process data whenever
    needed. For example, we create an application in an `analyze.py` module outside
    the App Engine project `root` (so that we can avoid uploading the file during
    deployment). The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the script from the command line at any time using the following
    line of command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Back to the code; in the `main()` method, we first get a connection to the database
    through a TCP/IP socket using the public IP of the instance. Then, we get a cursor
    object and perform the first query that counts the number of users we consider
    active, namely users who performed at least one kind of operation in the past
    month. As this is a count query, we expect only one row as result. In this case,
    we can call the `fetchone()` method of the cursor object; this method returns
    a tuple that contains one value that we get by index and store it in the `users`
    variable that we print on the standard output. With the same strategy, we retrieve
    and print to the standard output the number of operations globally performed in
    the last hour and the total number of shrinking operations.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a simple example but it shows how easy it can be to get usage metrics
    for our web applications extracting data from a Cloud SQL instance with any Python
    program running outside App Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Using the local MySQL installation for development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several reasons why we wouldn't want to work with a Cloud SQL instance
    while running our application locally in the development server. We might notice
    major slowdowns because every time we connect to a Cloud SQL instance, we perform
    a socket connection to a remote host that can be very far from us. Moreover, regardless
    of the Cloud SQL tier we choose, we always pay something for using the service
    and we might not want to use it while experimenting on the local development server.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can leverage the fact that, in the end, a Cloud SQL instance
    is nothing more than a MySQL database when our code talks to it. We can then install
    a local instance of a MySQL server and work with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We install and start the local server and perform the same operations we did
    on the Cloud SQL instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect with the MySQL client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `notes` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `notes` users and give them privileges on the `notes` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reload database privileges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `ops` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, all we have to do is change the `CLOUD_SQL_IP` environment variable
    in our `app.yaml` file so that it points to `localhost` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can now start using the local instance, avoiding network lags and costs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we put into action Cloud SQL, the scalable database service
    offered by Google Cloud Platform. Cloud SQL is more than a MySQL instance; it
    is a flexible and scalable relational database server that we can use to store
    and retrieve data from our App Engine applications as well as from external services
    and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Even if Cloud Datastore is the go-to solution when we have to deal with lot
    of data in our highly trafficked web applications, in this chapter, you learned
    how convenient it can be to have a relational database to store some data without
    hitting on the limits Datastore imposes to write operations. Being able to access
    that data from outside App Engine is a big plus and we have seen a simple yet
    effective use case, which we couldn't have implemented using Datastore.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add new features to our Notes application; we will
    make the application real time using Channel API to push data from the server
    to the clients connected.
  prefs: []
  type: TYPE_NORMAL
