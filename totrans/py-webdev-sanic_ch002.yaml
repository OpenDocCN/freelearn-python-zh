- en: 1 Introduction to Sanic and async frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 介绍 Sanic 和异步框架
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应该只有一个——最好是只有一个——明显的解决方案。
- en: '- *Tim Peters, The Zen of Python*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- *Tim Peters，《Python的禅意》*'
- en: Too often, this maxim of **Python** is taken to mean that there *must* be only
    one way to do something. Any Python web developer can simply look at the number
    of web frameworks that exist and tell you that the choice is not so simple. There
    are dozens of web frameworks on **PyPI**, and within the ecosystem of any single
    framework, you will find even more options to solve a single problem. Go ahead
    and type `authentication` into the search bar at [https://pypi.org](https://pypi.org).
    Looking at the number of results, that there is only “[one] obvious way to do
    it” does not seem so obvious. Maybe this sentence needs a change. Perhaps it could
    read, “There should be one … obvious way *for you* to do it.” Why? Because adding
    in the context that we are talking about your specific application brings us to
    the next level.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 太常了，这个Python格言被理解为“必须只有一个方法来做某事”。任何Python网络开发者都可以简单地看看存在的网络框架数量，并告诉你选择并不简单。在PyPI上有数十个网络框架，在任何单个框架的生态系统中，你将找到更多解决单个问题的选项。在[https://pypi.org](https://pypi.org)的搜索栏中输入“authentication”。看看结果的数量，只有一个“[一个]明显的解决方案”似乎并不明显。也许这句话需要改变。或许它可以读作，“应该有一个……对你来说明显的解决方案。”为什么？因为添加我们正在讨论你的特定应用程序的上下文，使我们达到了下一个层次。
- en: This is **Sanic**, and this is the goal of this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 **Sanic**，这也是本书的目标。
- en: What may be obvious for someone building a stock portfolio tracker will not
    be obvious to someone building a streaming media player. Therefore, to figure
    out what the *obvious* solution is, we must first understand the problem. And,
    to understand the problem, we must be hyper-aware of our specific use case.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建股票组合跟踪器的人来说可能显而易见的事情，对于构建流媒体播放器的人来说可能并不明显。因此，为了弄清楚什么是最明显的解决方案，我们首先必须理解问题。而且，为了理解问题，我们必须对我们的特定用例保持高度警觉。
- en: 'When trying to find a solution to a problem, many other tools and frameworks
    respond by saying: here is how you should do it. Do you want to read data from
    your web request? Here’s how to validate it. Do you need **cross-site request
    forgery** (**CSRF**) protection? Here’s the snippet you need to add. This approach
    fails to make you a better developer and fails to find the optimal solution for
    your use case.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图找到一个问题的解决方案时，许多其他工具和框架会回答说：这是你应该这样做。你想从你的网络请求中读取数据？这是如何验证它的方法。你需要 **跨站请求伪造**（**CSRF**）保护？这是你需要添加的代码片段。这种方法无法让你成为一个更好的开发者，也无法为你找到最佳的使用案例解决方案。
- en: Why should I validate my data this way? Why do I need this snippet to protect
    myself? Because someone else made the decision for you. You cannot answer these
    questions. All you know is that the framework documentation—or some blog on the
    Internet—told you to do this, so you did it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我应该以这种方式验证我的数据？为什么我需要这个代码片段来保护自己？因为有人为你做出了决定。你无法回答这些问题。你所知道的就是框架文档——或者某个互联网上的博客——告诉你这样做，所以你就这样做了。
- en: And this is why Sanic—and indeed, the book—takes a different approach. By the
    end of this book, we want you to know how to spot peculiar use cases, and how
    to bend the tooling to meet your needs. You should be able to think through different
    types of implementations and select one that is most meaningful for your needs.
    This will be the *obvious* solution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么Sanic——以及本书——采取不同的方法。到本书结束时，我们希望你知道如何发现特殊的使用案例，以及如何调整工具以满足你的需求。你应该能够思考不同类型的实现，并选择对你最有意义的解决方案。这将是最明显的解决方案。
- en: Sanic prides itself on being unopinionated. That is not to say that the maintainers
    of the project do not have strong opinions. I welcome you to engage me or anyone
    in the community in a discussion about proxy forwarding, deployment strategies,
    authentication schemes, etc. You will certainly find passionate opinions. By “unopinionated”,
    we mean to say that Sanic’s job is to take care of the plumbing so all you need
    to do is build the logic. The decision of how to tackle problems is not the domain
    of the framework.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 以其无偏见而自豪。这并不是说项目的维护者没有强烈的观点。我欢迎你与我或社区中的任何人就代理转发、部署策略、身份验证方案等进行讨论。你肯定会找到充满激情的观点。通过“无偏见”，我们是指Sanic的工作是处理基础设施，而你只需要构建逻辑。如何处理问题的决策不是框架的领域。
- en: You will find that Sanic developers are most keen to find solutions that are
    hyper-focused on solving the particular challenges that they face. Developers
    use Sanic because it is fast and simple. But, you will also find that using Sanic
    means the *obvious* solution to a problem is not based upon Sanic but upon your
    unique application requirements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，Sanic开发者最热衷于寻找针对他们面临的特定挑战的超专注解决方案。开发者使用Sanic是因为它既快又简单。但，你也会发现，使用Sanic意味着问题的明显解决方案不是基于Sanic，而是基于你独特的应用需求。
- en: The other side of the story is that sometimes your use case is not in need of
    a hyper-focused solution. This is also fine. For this reason, you will find a
    number of plugins (many of which are supported by active members of the Sanic
    core-developer team) or off-the-shelf solutions. We wholly support your adoption
    of them and their patterns. Throughout this book, our examples will steer away
    from implementations that require plugins. However, where there are popular solutions
    including plugins, we will also point them out to you for reference.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有时你的用例并不需要超专注的解决方案。这也是可以的。因此，你会发现许多插件（其中许多由Sanic核心开发者团队活跃成员支持）或现成的解决方案。我们完全支持你采用它们及其模式。在这本书中，我们的例子将避免需要插件的实现。然而，当有包括插件在内的流行解决方案时，我们也会为你指出以供参考。
- en: 'Our goal in this book is to learn to identify your unique application requirements
    and match them with the tools at our disposal to: (1) make our applications better;
    and (2) make us better developers.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中的目标是学习识别你独特的应用需求，并将它们与我们可用的工具相匹配，以：（1）使我们的应用更好；（2）使我们成为更好的开发者。
- en: 'In this chapter, we will begin building the foundational understanding needed
    to read through this book, by working through the following topics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下主题来构建阅读这本书所需的基础理解：
- en: What is Sanic?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Sanic？
- en: Leveling up
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升水平
- en: Framework vs server
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架与服务器
- en: Why use Sanic – build fast, run fast
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用Sanic – 构建快，运行快
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will include some basic Python and terminal usage. To follow along
    with the examples, make sure that your computer is set up with Python version
    3.7 or newer. You will also need to have curl, or a similar program, installed
    so that we can easily make and inspect HTTP requests. If you are unfamiliar with
    curl, it is a program executed from a terminal session that allows you to make
    HTTP requests. It should be available on most macOS and Linux installations by
    default and can be installed on Windows machines.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '本章将包括一些基本的Python和终端使用。为了跟随示例，请确保你的计算机已设置Python 3.7或更高版本。你还需要安装curl或类似程序，这样我们就可以轻松地制作和检查HTTP请求。如果你不熟悉curl，它是一个从终端会话执行的程序，允许你进行HTTP请求。它应该默认在大多数macOS和Linux安装中可用，也可以在Windows机器上安装。 '
- en: What is Sanic?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Sanic？
- en: Since you’re reading this book, you’re probably familiar with Python and may
    even know some popular tools used to build web applications using Python. As for
    Sanic, you’ve either heard of it or have used it and want to improve your skills
    and understanding of it. You may know that Sanic is unlike traditional tools.
    Built 100% from the ground up, it’s been developed with the idea of asynchronous
    Python in mind. From the very beginning, Sanic set out to be fast. It is one of
    the critical decisions that drive much of its development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在阅读这本书，你很可能熟悉Python，甚至可能了解一些用于使用Python构建Web应用的流行工具。至于Sanic，你可能听说过它，或者已经使用过它，并希望提高你的技能和对它的理解。你可能知道Sanic与传统工具不同。它是从头开始构建的，完全基于异步Python的理念。从一开始，Sanic就旨在追求速度。这是推动其大部分发展的关键决策之一。
- en: To truly understand the Sanic project, we’d benefit from a history lesson. Sanic
    was the first legitimate attempt to bring asynchronous Python to a web framework.
    It started out as a proof-of-concept, as a hobby project. Let’s set the stage.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解Sanic项目，我们可能需要从历史课开始。Sanic是第一个将异步Python引入Web框架的合法尝试。它最初是一个概念验证，作为一个爱好项目。让我们设定场景。
- en: The most fundamental building block of Sanic is the **asyncio module** from
    Python’s standard library. The Sanic project was born during the early stages
    of the module’s release and has matured along with the module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic最基础的构建块是来自Python标准库的**asyncio模块**。Sanic项目在模块早期发布阶段诞生，并随着模块的成熟而成熟。
- en: Python 3.4—released in early 2014—was the first step to introduce the concept
    of **coroutines** into the standard library in the newly added **asyncio** module.
    Using standard Python generators, a function’s execution can be halted while something
    else happens, and then data can be injected back into that function to allow it
    to resume execution. If there then was an object that “looped” through a list
    of tasks that needed work, we could duck in and out of the execution of multiple
    functions at the same time. This could achieve “concurrency” in a single thread
    and is the basis of the idea of asyncio.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.4——2014 年初发布——是将 **协程** 的概念引入标准库中新增的 **asyncio** 模块的第一步。使用标准的 Python
    生成器，可以在其他事情发生时暂停函数的执行，然后可以将数据注入该函数以允许其恢复执行。如果有一个“循环”对象可以遍历需要工作的任务列表，我们就可以同时进入和退出多个函数的执行。这可以在单个线程中实现“并发”，这是
    asyncio 概念的基础。
- en: In the early days, this was mainly a toy and there was not widespread adoption
    of coroutines. Of course, there were legitimate application needs being solved,
    but the concept was still very early in its development and not fully developed.
    The concept was refined over the course of the next several Python releases to
    give us the asyncio module we know today.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，这主要是一个玩具，协程并没有得到广泛的应用。当然，有一些合法的应用需求得到了解决，但这个概念在其发展初期仍然非常初级，并未完全成熟。在接下来的几个
    Python 版本中，这个概念得到了细化，最终形成了我们今天所知道的 asyncio 模块。
- en: 'Here’s a quick look at what asynchronous programming looked like in Python
    3.4:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面快速看一下 Python 3.4 中异步编程的样子：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While we will not delve into how this works, it is worth mentioning that asynchronous
    Python is built on the premise of generators. The idea is that a generator function
    can yield back to some “loop” to allow it to duck in and out of execution.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会深入探讨其工作原理，但值得一提的是，异步 Python 是建立在生成器的基础上的。其理念是生成器函数可以返回到某个“循环”以允许其进入和退出执行。
- en: '**Important note**'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will talk about how you can use alternative loops (such as trio) later on,
    but this book will assume we are using asyncio.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论如何使用替代循环（例如 trio），但本书将假设我们正在使用 asyncio。
- en: The language and syntax from the new asyncio module were both extremely powerful,
    and a bit clunky. Generators have usually been a bit mysterious and difficult
    for less-seasoned Python developers. What exactly is `yield` `from`? This stuff
    looked alien to many people; Python needed a better syntax.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 asyncio 模块的语言和语法都非常强大，但有点笨拙。生成器通常对不太熟练的 Python 开发者来说有点神秘和难以理解。`yield` `from`
    究竟是什么？这些东西对许多人来说看起来很陌生；Python 需要更好的语法。
- en: Before continuing, it is worth making a quick side note if you are unfamiliar
    with generators. Python has a special type of function that returns a generator.
    That generator can be used to execute partially and suspend its operation by *yielding*
    a value until it is further needed. Generators also have the ability to be bi-directional,
    in that data can be sent back into them during execution. Again, the specifics
    of this are beyond the scope of this book since it is not entirely pertinent,
    but it is helpful to know that this is what `yield from` helps us to achieve.
    Using the bidirectional functionality of generators, Python was able to build
    the capability for asynchronous coroutines.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，如果你不熟悉生成器，这里做一个简要的说明。Python 有一种特殊类型的函数，它返回一个生成器。这个生成器可以通过 *yield* 一个值来部分执行并暂停其操作，直到需要进一步处理。生成器还具有双向操作的能力，即在执行过程中可以将数据发送回它们。再次强调，这些细节超出了本书的范围，因为它们并非完全相关，但了解这一点有助于知道这就是
    `yield from` 帮助我们实现的目标。利用生成器的双向功能，Python 能够构建异步协程的能力。
- en: 'Because this implementation was complex and slightly more difficult for newcomers
    when Python 3.5 was released, it included a much simpler and cleaner version:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个实现复杂，对于 Python 3.5 的初学者来说稍微有点困难，因此它包含了一个更简单、更干净的版本：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: One of the main benefits of this style of programming is that it eases up the
    blocking of code due to input and output. This is known as **io-bound**. A classical
    example of an io-bound application is a web server. It was, therefore, a natural
    fit for this new asyncio module to be built with the idea of creating protocols
    for interacting with networking traffic.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格的主要好处是它减轻了由于输入和输出导致的代码阻塞。这被称为 **io-bound**。一个经典的 io-bound 应用示例是网络服务器。因此，构建一个旨在创建与网络流量交互的协议的新
    asyncio 模块是顺理成章的。
- en: At the time, however, there were no frameworks or web servers that adopted this
    approach. The Python web ecosystem was built upon a premise that is fundamentally
    at odds with asynchronous Python.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当时没有框架或 Web 服务器采用这种方法。Python Web 生态系统建立在与异步 Python 基本对立的前提之上。
- en: '**Important note**'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The classical Python pattern for integrating an application with a Python webserver
    is known as the **Web Server Gateway Interface** (**WSGI**). This is not within
    the scope of this book. While it is possible to shoehorn Sanic into WSGI, it is
    generally frowned upon. The problem with WSGI is that the entire premise of it
    is blocking. A web server receives a request, processes it, and sends a response
    all within a single execution. This means that the server can process only one
    request at a time. Using Sanic with a WSGI server completely destroys the asynchronous
    ability to efficiently handle multiple requests concurrently.
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 经典的 Python 集成应用程序与 Python Web 服务器的方式被称为 **Web 服务器网关接口**（**WSGI**）。这不在本书的范围内。虽然可以将
    Sanic 强行塞入 WSGI，但通常是不受欢迎的。WSGI 的问题在于其整个前提是阻塞的。Web 服务器接收一个请求，处理它，并在单个执行中发送响应。这意味着服务器一次只能处理一个请求。使用
    Sanic 与 WSGI 服务器完全破坏了高效并发处理多个请求的异步能力。
- en: Classical **Django** and **Flask** could not adopt this pattern. Looking back
    6+ years later, those projects eventually did find ways to introduce *async*/*await*.
    But, it is not the natural use pattern for these frameworks and came at the expense
    of an extraordinary effort over many years.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 **Django** 和 **Flask** 无法采用这种模式。回顾 6 年以上，这些项目最终找到了引入 *async*/*await* 的方法。但是，这并不是这些框架的自然使用模式，并且付出了多年非凡的努力。
- en: As the asyncio module was being released, there was a lack of web frameworks
    to fill this new use case. Even the concept that eventually came to be known as
    **Asynchronous Server Gateway Interface** (**ASGI**) did not exist.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当 asyncio 模块发布时，缺乏能够满足这一新用例的 Web 框架。甚至后来被称为 **异步服务器网关接口**（**ASGI**）的概念也尚未存在。
- en: '**Important note**'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The ASGI is the corollary to WSGI, except for asynchronous Python. It is possible—although
    not required—to use it for Sanic, and we will discuss it further in *Chapter 8*,
    *Running a server*.
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ASGI 是 WSGI 的对应物，但针对异步 Python。虽然不是必需的，但可以将其用于 Sanic，我们将在 *第 8 章*，*运行服务器* 中进一步讨论。
- en: 'In the Summer of 2016, Sanic was built to explore the gap. The idea was simple:
    could we take an application with a simplistic-looking API from Flask and make
    it *async*/*await*?'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2016 年夏季，Sanic 被构建出来以探索这个差距。想法很简单：我们能否将一个看起来简单的 Flask API 应用程序转换为 *async*/*await*？
- en: Somehow the idea took off and gained traction. It was not a project that was
    initially set out with the goal of redoing how Python applications handled web
    requests. It very much was a case of accidental exposure. The project exploded
    and created excitement very quickly. There was a lot of appeal to making Flask
    adopt this new pattern; but, since Flask was itself incapable of doing so, many
    people thought that Sanic could be the async version of Flask.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 某种程度上，这个想法起飞并获得了势头。这并不是一个最初旨在重新设计 Python 应用程序处理 Web 请求的项目。这非常典型地是一个意外曝光的案例。项目迅速爆炸并迅速创造了兴奋。很多人认为
    Flask 采用这种新模式有很大的吸引力；但由于 Flask 本身无法做到这一点，许多人认为 Sanic 可以是 Flask 的异步版本。
- en: Developers were excited for this new opportunity to use the latest in Python
    to bring a whole new level of performance to their applications. Early benchmarks
    showed Sanic running circles around Flask and Django.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者对使用最新的 Python 带来应用程序全新性能水平的新机会感到兴奋。早期的基准测试显示 Sanic 在 Flask 和 Django 之上运行得如风驰电掣。
- en: Like so many projects, however, the initial burst of energy died off. The original
    project was meant to answer the question, could a Flask-like framework exist?
    The answer was a resounding yes. However, being a one-person project that had
    no intention of handling the level of support and attention that it received,
    the project started to gather dust. Pull requests started piling up. Issues went
    unanswered.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像许多项目一样，最初的热情逐渐消退。原始项目旨在回答一个问题：是否存在一个类似 Flask 的框架？答案是响亮的肯定。然而，作为一个没有打算处理所获得的级别支持和关注的单人项目，该项目开始积满灰尘。拉取请求开始堆积。问题无人回答。
- en: Through 2017 and 2018 the ecosystem for asynchronous Python was still very immature.
    It lacked production-worthy platforms that would be supported, maintained, and
    viable for both personal and professional web applications. Furthermore, there
    was still a bit of an identity question about Sanic. Some people felt that it
    should be a very niche piece of software, while others felt it could have broad
    applicability.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2017 年和 2018 年间，异步 Python 的生态系统仍然非常不成熟。它缺乏值得信赖的平台，这些平台将得到支持、维护，并且适用于个人和专业的网络应用程序。此外，关于
    Sanic 仍有一些身份上的疑问。有些人认为它应该是一个非常小众的软件，而另一些人则认为它可能有广泛的应用。
- en: The result of the months of frustrations and lack of responses from the maintainers
    of the project resulted in the Sanic Task Force. This precursor to the Sanic Community
    Organization was a loose collective of developers that were interested in finding
    a future for the project that was on the verge of failing. There was a desire
    to stabilize the API and answer all of the outstanding identity questions. For
    several months in mid-2018, a debate brewed about how to move the project forward,
    and how to make sure the project would not suffer the same fate again.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '几个月来对项目维护者缺乏响应和挫败感的后果导致了 Sanic 任务小组的成立。这个 Sanic 社区组织的先驱是一群对找到即将失败的项目未来感兴趣的开发者松散集体。他们希望稳定
    API 并回答所有悬而未决的身份问题。在 2018 年中旬的几个月里，关于如何推进项目以及如何确保项目不会再次遭受同样命运的争论一直在酝酿。 '
- en: 'One of the most fundamental questions was whether the project should be forked.
    Since no one on the Sanic Task Force had admin access to the repository or other
    assets—and the only person who did was non-responsive—the only option was to fork
    and rebrand the project. However, Sanic had already existed for two years at that
    time and was known within the Python community as a viable (and fast) option to
    build asynchronous web applications. Dropping the existing project name would
    have been a huge blow towards ever getting the new project back up off the ground.
    Nonetheless, this was the only remaining solution. On the eve of forking the project
    to a new GitHub repository, the original maintainer offered up access to the repository
    and the SCO was born. The team worked to reorganize the operation of the community
    with the following goals:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的问题之一是项目是否应该被分叉。由于 Sanic 任务小组中没有人在仓库或其他资产上拥有管理员权限——而唯一有权限的人没有响应——唯一的选择就是分叉并重新命名项目。然而，Sanic
    在那时已经存在两年，在 Python 社区中作为构建异步网络应用程序的一个可行（且快速）的选项而闻名。放弃现有的项目名称将对新项目重新崛起造成巨大的打击。尽管如此，这是唯一剩下的解决方案。在将项目分叉到新的
    GitHub 仓库的前夕，原始维护者提供了对仓库的访问权限，SCO 因此诞生。团队努力重组社区运作，以下是一些目标：
- en: Regular and predictable releases, and deprecations;
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期和可预测的发布，以及弃用；
- en: Accountability and responsibility for responding to issues and support; and
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对响应问题和支持的问责制和责任感；以及
- en: Structure for reviewing code and making decisions.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查和决策的结构。
- en: 'In December 2018, the SCO released its first community version of Sanic: 18.12
    LTS.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2018 年 12 月，SCO 发布了 Sanic 的第一个社区版本：18.12 LTS。
- en: 'With this new structure in place, the SCO turned to its next question: what
    is Sanic? Ultimately, the decision was to break with any attempt at Flask parity.
    While it may be said that the original project was a “Flask clone”, this is no
    longer true. You will still hear it called “Flask-like”, but that is a fair comparison
    only because they look similar on the surface. The features and behaviors are
    fundamentally different, and the likeness stops there. Personally, I try to steer
    away from this comparison because it diminishes the effort and improvements that
    hundreds of contributors have made to let Sanic stand on its own.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立起新的结构之后，SCO 转向了下一个问题：Sanic 是什么？最终的决定是打破任何与 Flask 兼容的尝试。虽然可以说原始项目是一个“Flask
    克隆”，但这已经不再真实。你仍然会听到它被称为“类似 Flask”，但这种比较只因为它们在表面上看起来相似。功能和行为在本质上都是不同的，相似之处到此为止。我个人尽量避开这种比较，因为它贬低了数百名贡献者为让
    Sanic 独立而付出的努力和改进。
- en: Leveling up
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级
- en: Sanic encourages experimentation, customization, and most of all, curiosity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 鼓励实验、定制，最重要的是，好奇心。
- en: It probably is not the best tool for Python beginners since it assumes some
    knowledge of both Python and web development. That is not to say that the project
    discourages newcomers, or people just getting into web development. Indeed, Sanic
    is actually a wonderful place to start learning web development for those that
    truly want to understand the practice. Much of web development is learning to
    balance competing decisions. Sanic development often includes learning about these
    decision points.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它假设对Python和Web开发都有一定的了解，因此可能不是Python初学者的最佳工具。这并不是说项目会阻止新手，或者刚开始接触Web开发的人。实际上，对于那些真正想了解实践的人来说，Sanic是一个学习Web开发的绝佳起点。Web开发很大程度上是学习平衡相互竞争的决策。Sanic开发通常包括了解这些决策点。
- en: 'This touches upon the goal of this book: answering the question “what is the
    *obvious* path to building my Sanic application?” This book intends to explore
    different patterns that *could* be used in Sanic. While we will learn the concepts
    as they relate to Sanic, the principles can be abstracted and applied to building
    an application with any other framework or language. It is critical to remember
    that there is no “right” or “wrong” way. Online forums are filled with “what is
    the right way” questions that assume that there is standard practice. The answers
    to these questions point to the implication that if they are not following a particular
    pattern, then their application is wrong.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这触及了本书的目标：回答“构建我的Sanic应用的最佳路径是什么？”本书旨在探讨在Sanic中可能使用的不同模式。虽然我们将学习与Sanic相关的概念，但原则可以抽象化并应用于构建任何其他框架或语言的应用程序。记住，没有“正确”或“错误”的方法是至关重要的。在线论坛充满了“正确方法”的问题，这些假设存在标准实践。这些问题的答案指向了这样的含义，即如果他们没有遵循特定的模式，那么他们的应用程序就是错误的。
- en: 'For example, someone might ask the following questions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有人可能会问以下问题：
- en: “What is the right way to serve internationalized content?”
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “提供国际化内容的正确方法是什么？”
- en: “What is the right way to deploy my web app?”
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “我应该如何部署我的Web应用？”
- en: “What is the right way to handle long-running operations?”
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “处理长时间运行操作的正确方法是什么？”
- en: 'These “right way” questions suffer from a critical flaw: the belief that there
    is only a *single* obvious solution. Structuring a question like this is the domain
    of opinionated frameworks that do not teach developers to think on their own.
    Ask these same questions on the Sanic forums, and you’ll probably receive an “it
    depends” as your answer. Opinionated frameworks hinder creativity and design.
    They ultimately drive the developer into making choices based upon the constraints
    provided by the framework and not the constraints of the application''s needs.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“正确方法”的问题存在一个关键缺陷：认为只有一个“明显”的解决方案。以这种方式构建问题属于有偏见的框架领域，这些框架不教会开发者独立思考。在Sanic论坛上提出相同的问题，你可能会得到一个“视情况而定”的回答。有偏见的框架阻碍了创造力和设计。它们最终迫使开发者根据框架提供的限制而不是应用程序的需求来做出选择。
- en: Instead, Sanic provides a set of tools to help the developer craft the solutions
    that work for their use case without mandating certain practices. This is why
    the built-in features of Sanic focus on functionality and the request/response
    cycle, and not on implementation details like validation, **cross-origin resource
    sharing** (**CORS)**, CSRF, and database management. All of *that other stuff*
    is of course important, and we will explore them in later chapters. But the intent
    of this book is to look at the issues and see how you *might* solve the problem.
    Web applications and web APIs have differing needs, and therefore you as the developer
    should be allowed to make the choices that are best suited (and *obvious*) to
    solving your problems.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Sanic提供了一套工具，帮助开发者根据他们的用例定制解决方案，而不强制执行某些实践。这就是为什么Sanic的内置功能专注于功能性和请求/响应周期，而不是像验证、**跨源资源共享**（**CORS**）、CSRF和数据库管理这样的实现细节。当然，所有那些“其他东西”都很重要，我们将在后面的章节中探讨它们。但本书的意图是查看问题，并看看你“可能”如何解决问题。Web应用程序和Web
    API有不同的需求，因此作为开发者，你应该被允许做出最适合（且明显）解决问题的选择。
- en: 'Revisiting those questions above, a better way to phrase them would be:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾上述问题，更好的表述方式可能是：
- en: “How *can* I serve internationalized content?”
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “我该如何提供国际化内容？”
- en: “Which deployment strategy will work for me, considering my constraints?”
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “考虑到我的限制，哪种部署策略对我适用？”
- en: “What are the trade-offs to consider for handling long-running operations?”
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在处理长时间运行的操作时，需要考虑哪些权衡？”
- en: By the end of this book, you will be able to spot the questions and use your
    creativity to come up with appropriate solutions. You will learn some of the powerful
    strategies that Sanic has to offer. But, by no means think that any given solution
    is the only way. Just because it is outlined here does not mean that it is the
    *right* way. Or, that the tools used only apply in one particular situation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的结尾，你将能够识别问题，并运用你的创造力来提出合适的解决方案。你将学习Sanic提供的一些强大策略。但绝不要认为任何给定的解决方案是唯一的。仅仅因为它在这里被概述，并不意味着它是正确的。或者，所使用的工具只适用于特定的情况。
- en: 'The right way is to use the tools that Sanic and Python provide to solve your
    problems. If you were tasked with making soup, you would find there is no single
    way to do it. You could look up some recipes and try to learn some basic patterns:
    boil water, add ingredients, etc. Ultimately, to master the art of soup making,
    you need to cook within the constraints of your kitchen, equipment, ingredients,
    and the people you are serving. This is what I want you to learn about web development:
    master your tools, environment, and requirements to build what you need for your
    specific users.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是使用Sanic和Python提供的工具来解决你的问题。如果你被要求做汤，你会发现没有唯一的方法可以做到。你可以查找一些食谱，并尝试学习一些基本模式：烧开水，加配料等。最终，要掌握做汤的艺术，你需要在你自己的厨房、设备、配料以及你要服务的人的约束条件下烹饪。这就是我想让你了解的关于Web开发的知识：掌握你的工具、环境和需求，为你的特定用户构建你需要的东西。
- en: While reading this book you should both be learning and analyzing the patterns
    and code. Try to generalize the concepts and think about how to use similar ideas
    down the road in your own code. We encourage you to read the book in its entirety
    or duck in and out of chapters as they may apply to you. Both are valid approaches.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书的过程中，你应该既在学习也在分析模式和代码。尝试概括概念，并思考如何在未来的代码中运用类似的想法。我们鼓励你通读全书，或者根据需要跳读章节，这两种方法都是有效的。
- en: Let’s take a closer look that at the question about internationalization to
    see how framing the question differently impacts our application and our knowledge.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨国际化的问题，看看不同的问题框架如何影响我们的应用程序和知识。
- en: '**BAD**: What is the right way to serve internationalized content?'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：如何正确地提供国际化内容？'
- en: '**GOOD**: How *can* I serve internationalized content?'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确**：我如何提供国际化内容？'
- en: The answer to the first question likely will include a snippet of code from
    someone who has had this problem in the past. The developer will copy/paste and
    move on not learning anything in the process (and therefore will be unable to
    generalize and apply knowledge to similar problems in the future). At best, the
    solution is passably acceptable. At worst, the solution is harmful to the overall
    design of the application and the developer does not even know it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题的答案可能包括一些曾经遇到过这个问题的开发者的代码片段。开发者会复制粘贴并继续前进，在这个过程中没有学到任何东西（因此将无法将知识应用于未来类似的问题）。最好的解决方案是勉强可以接受的。最坏的情况是，解决方案对应用程序的整体设计有害，而开发者甚至不知道这一点。
- en: Framing the question as “How can I…” leaves open the idea that there may be
    multiple avenues to the same destination. The bad question style is narrow and
    drives our attention to a single approach. The good style opens up the possibilities
    to explore different solutions and weigh them against their merits. After asking
    the question, our job now is to figure out those possible solutions, determine
    the potential trade-offs, and then come to a conclusion. In this process, we can
    draw upon our own past experiences, examples from other developers, and resource
    materials like this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题框架为“我如何...”留出了可能有多种途径达到同一目的的想法。错误的问题风格是狭窄的，将我们的注意力引向单一的方法。好的风格则打开了探索不同解决方案的可能性，并权衡它们的优点。在提出问题后，我们现在的工作是找出可能的解决方案，确定潜在的权衡，然后得出结论。在这个过程中，我们可以借鉴我们自己的过去经验，其他开发者的例子，以及像这本书这样的资源材料。
- en: 'We might think about possible solutions involving the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以思考以下可能的解决方案：
- en: '**middleware** (catch the headers or path and reroute the request to a different
    handler)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件**（捕获头信息或路径，并将请求重定向到不同的处理程序）'
- en: '**routing** (embed the language code in the URL path, and extract the language
    from the route)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**（在URL路径中嵌入语言代码，并从路由中提取语言）'
- en: '**functional programming** (use different functional handlers to generate separate
    responses)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式编程**（使用不同的函数处理程序来生成单独的响应）'
- en: '**decorators** (execute some logic before (or after) the actual handler is
    run).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**（在实际处理程序运行之前或之后执行一些逻辑）。'
- en: 'But *which* solution should be used? We need to know about the specifics of
    our application. Here are some important questions to keep in mind:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但应该使用哪种解决方案？我们需要了解我们应用程序的具体情况。以下是一些需要记住的重要问题：
- en: Who is developing it? What is their experience level? How many developers are
    on the team? What tools will they be working with? Who will be maintaining it?
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁在开发它？他们的经验水平如何？团队中有多少开发者？他们将使用哪些工具？谁将维护它？
- en: Who will be using the application? Will it be consumed from a frontend JS framework?
    A mobile app? Third-party integrations?
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁将使用这个应用程序？它将被一个前端JS框架消费吗？一个移动应用？第三方集成？
- en: How large will it scale? What sort of content needs to be delivered?
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将扩展到多大？需要传递什么样的内容？
- en: These questions are the questions that are the domain of this book. We intend
    to ask the questions and determine the reasons behind making particular design
    pattern decisions. Of course, we cannot be exhaustive. Instead, we hope to inspire
    your journey to use as many tools and creative solutions as you can.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题是这本书的领域。我们打算提出问题，并确定做出特定设计模式决策的原因。当然，我们不可能详尽无遗。相反，我们希望激发你使用尽可能多的工具和创造性解决方案的旅程。
- en: Few projects can match the amount of literature that has been written about
    Django. But precisely because Sanic does not require specific patterns, there
    is no need for such expansive amounts of documentation. The only prerequisite
    is knowing Python. The depth of API-specific knowledge needed to be successful
    with Sanic is not large. Do you know how to instantiate objects, pass values,
    and access properties? Of course, you do, it's just Python!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有项目能和关于Django所写的文献数量相匹配。但正是因为Sanic不需要特定的模式，所以不需要如此大量的文档。唯一的前提是知道Python。成功使用Sanic所需的API特定知识的深度并不大。你知道如何实例化对象、传递值和访问属性吗？当然，你知道，这只是Python！
- en: Two obvious valuable Sanic-specific resources are the User Guide ([https://sanicframework.org](https://sanicframework.org))
    and the API documentation ([https://sanic.readthedocs.io](https://sanic.readthedocs.io)).
    We will refer to both of these heavily in this book. But, just as equally important
    are any other source on the web, or in print that you have used up to this point
    to learn Python.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 两个显然有价值的Sanic特定资源是用户指南([https://sanicframework.org](https://sanicframework.org))和API文档([https://sanic.readthedocs.io](https://sanic.readthedocs.io))。在这本书中，我们将大量参考这两个资源。但是，同样重要的是任何其他你到目前为止用来学习Python的在线或印刷资源。
- en: 'Coming back to the question of what is the *obvious* way to handle some tasks
    within Sanic: use the resources and tools that exist. There is a wealth of information
    on StackOverflow and the Sanic Community Forums. The Discord server is an active
    live discussion channel. Make yourself known, make your voice heard.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Sanic内部处理某些任务的最明显方式的问题：使用现有的资源和工具。StackOverflow和Sanic社区论坛上有很多信息。Discord服务器是一个活跃的实时讨论频道。让自己被认识，让自己的声音被听到。
- en: Don’t ask the *right way* questions. Instead, ask the *how can I* questions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要问“正确的方式”问题。相反，问“我该如何”问题。
- en: Framework v server
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架 v 服务器
- en: Sanic calls itself both a web framework and a web server. What does this mean?
    And more importantly, why is this important?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic将自己称为既是Web框架又是Web服务器。这意味着什么？更重要的是，这为什么很重要？
- en: Before we can explore this, we first must understand what these terms mean,
    and why they exist.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索这个问题之前，我们首先必须理解这些术语的含义以及它们为什么存在。
- en: Web server
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web服务器
- en: A web server is a piece of software that is designed to deliver documents and
    data via the **HTTP** protocol. Its function is to accept an incoming HTTP request,
    decode the message to understand what the request is trying to accomplish, and
    deliver an appropriate response. The language of web servers is the HTTP protocol.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器是一种设计用来通过**HTTP**协议传递文档和数据的软件。它的功能是接受传入的HTTP请求，解码消息以理解请求试图完成什么，并返回适当的响应。Web服务器的语言是HTTP协议。
- en: We will get more into the specifics later, but for now, we will set up a simple
    Sanic server, issue a request from `curl`, and look at the message.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后深入了解具体细节，但现在，我们将设置一个简单的Sanic服务器，从`curl`发出请求，并查看消息。
- en: Create a file called server.py, and then run it in your terminal.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为server.py的文件，然后在您的终端中运行它。
- en: '[PRE2]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we send a request to our API:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们向我们的API发送一个请求：
- en: '[PRE3]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our console, we should now see the HTTP request message:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制台中，我们现在应该能看到 HTTP 请求消息：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What we see here are three components:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是三个组件：
- en: The first line contains the HTTP method, the path, and the HTTP protocol is
    used
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含 HTTP 方法、路径以及使用的 HTTP 协议
- en: 'Next is a list of HTTP headers, one per line in `key: value` format'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '接下来是 HTTP 头部列表，每行一个，格式为 `key: value`'
- en: 'Last is the HTTP body, preceded by a blank line.HTTP responses are very similar:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是 HTTP 主体，前面有一个空行。HTTP 响应非常相似：
- en: '[PRE5]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The three components now are:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的三个组件是：
- en: The first line contains the HTTP protocol, followed by the HTTP status, and
    a status description
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含 HTTP 协议，后面是 HTTP 状态和状态描述
- en: 'Next is a list of HTTP header, one per line in `key: value` format'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '接下来是 HTTP 头部列表，每行一个，格式为 `key: value`'
- en: Last is the HTTP body (if there will be one), preceded by a blank line.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是 HTTP 主体（如果有的话），前面有一个空行。
- en: Though this is the language of web servers, it is very cumbersome to write all
    of that. Therefore, tools like web browsers and HTTP client libraries were created
    to build and parse these messages for us.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是 Web 服务器的语言，但编写所有这些内容非常繁琐。因此，创建了像 Web 浏览器和 HTTP 客户端库这样的工具来为我们构建和解析这些消息。
- en: Web framework
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web 框架
- en: We could, of course, write a program in Python that receives these raw HTTP
    messages, decodes them, and return an appropriate HTTP response message. However,
    this would require a lot of boilerplate, be difficult to scale and be prone to
    mistakes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以用 Python 编写一个程序来接收这些原始的 HTTP 消息，解码它们，并返回适当的 HTTP 响应消息。然而，这需要大量的模板代码，难以扩展，并且容易出错。
- en: 'There are tools that do this for us: web frameworks. The job of a web framework
    is to make the work of building the HTTP message and appropriately handling the
    request. Many frameworks go further by providing conveniences and utilities to
    make the process simpler.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具会为我们做这件事：Web 框架。Web 框架的工作是简化构建 HTTP 消息和处理请求的过程。许多框架更进一步，提供便利和实用工具以简化流程。
- en: There are many web frameworks in the Python ecosystem that do this work to varying
    degrees. Some provide a huge number of features, and some are very sparse in their
    offering. Some are very strict, and some are more open. Sanic tries to fall on
    the continuum of being feature-rich only so far as required to not get in the
    way of the developer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 生态系统中有许多 Web 框架，它们在提供这项工作方面各有不同。有些提供了大量的功能，有些提供得非常有限。有些非常严格，有些则更加开放。Sanic
    尝试在功能丰富和不妨碍开发者之间找到一个平衡点。
- en: One of the features that Sanic provides is that it is both a web framework and
    a web server.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 提供的一个特性是它既是 Web 框架又是 Web 服务器。
- en: If you perform a survey of web frameworks on PyPI, you will find that most of
    them require the installation of a separate web server. When deploying *most*
    Python applications, there is a hard line between the persistent operation that
    runs on the machine, and the tooling used to develop response handlers. We will
    not delve too deeply into WSGI since it is not applicable to Sanic. However, the
    paradigm that there is a server that calls a single input function passing it
    information about the request and expects a response is important to understand.
    Everything that happens in between is the framework.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 PyPI 上的 Web 框架进行一次调查，你会发现大多数都需要安装一个单独的 Web 服务器。在部署 *大多数* Python 应用程序时，机器上运行的持久操作和用于开发响应处理器的工具之间存在一条明确的界限。我们不会深入探讨
    WSGI，因为它不适用于 Sanic。然而，有一个重要的范式需要理解：有一个服务器调用一个输入函数，传递有关请求的信息并期望得到响应。所有介于其间的都是框架。
- en: 'Narrowing our focus to projects that support *async*/*await* style coroutine
    handlers, the vast majority require you to run an ASGI server. It follows a similar
    pattern: an ASGI ready server calls into an ASGI ready framework. These two components
    operate with one another using a specific protocol. There currently are three
    popular ASGI servers: uvicorn, hypercorn, and daphne.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的焦点缩小到支持 *async*/*await* 风格协程处理器的项目，那么绝大多数都需要你运行一个 ASGI 服务器。它遵循类似的模式：一个
    ASGI 准备好的服务器调用一个 ASGI 准备好的框架。这两个组件通过一个特定的协议相互操作。目前有三个流行的 ASGI 服务器：uvicorn、hypercorn
    和 daphne。
- en: Precisely because Sanic was born during the era that predated ASGI, it needed
    its own server. Over time, this has become one of its greatest assets and is in
    large part why it outperforms most other Python frameworks. Development of the
    Sanic server is hyper-focused on performance and minimization of the request/response
    cycle. However, in recent years Sanic also adopted an ASGI interface to allow
    it to be run by an ASGI web server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为 Sanic 诞生在 ASGI 之前的时代，它需要自己的服务器。随着时间的推移，这已成为其最大的资产之一，也是它优于大多数其他 Python 框架的部分原因。Sanic
    服务器的开发高度专注于性能和最小化请求/响应周期。然而，近年来 Sanic 也采用了 ASGI 接口，以便它可以通过 ASGI 网络服务器运行。
- en: However, for the majority of this book, you can assume that when we are talking
    about running Sanic, we mean using the internal web server. It is production ready,
    and still remains one of the best methods for deploying Sanic. Later in *Chapter
    8*, *Running a server*, we will discuss all of the potential choices, and help
    you to come up with the questions to ask when deciding which solution is *obvious*
    for your needs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这本书的大部分内容中，你可以假设当我们谈论运行 Sanic 时，我们指的是使用内部网络服务器。它是生产就绪的，并且仍然是部署 Sanic 的最佳方法之一。在
    *第 8 章*，*运行服务器* 中，我们将讨论所有潜在的选择，并帮助你提出在决定哪种解决方案对你的需求来说是*明显*的问题。
- en: Why we use Sanic—Build fast. Run fast.
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们使用 Sanic——构建快速，运行快速。
- en: 'Let’s begin by looking at Sanic’s goal:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解 Sanic 的目标开始：
- en: To provide a simple way to get up and running a highly performant HTTP server
    that is easy to build, to expand, and ultimately to scale.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一种简单的方法来快速搭建、扩展并最终扩展高性能的 HTTP 服务器。
- en: '*Source*: [https://sanicframework.org/en/guide/#goal](https://sanicframework.org/en/guide/#goal)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源*: [https://sanicframework.org/en/guide/#goal](https://sanicframework.org/en/guide/#goal)'
- en: Most people familiar with the Sanic project will tell you that its defining
    feature is performance. While this is of course important, it is only a single
    part of the core philosophies of the Sanic project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数熟悉 Sanic 项目的人都会告诉你，其定义特征是性能。虽然这当然很重要，但它只是 Sanic 项目核心哲学的一个方面。
- en: 'The Sanic tagline is: “Build fast. Run fast.” This highlights of course the
    performance orientation of the project. It also speaks to the goal that building
    an application in Sanic is meant to be intuitive. Getting an application up and
    running should not mean learning a complex set of APIs and a near constant second
    browser window opened to the documentation. While other tools make heavy usage
    of “black box” type features like global variables, “magic” imports, and monkey-patching,
    Sanic generally prefers to head in the direction of well-written, clean, and idiomatic
    Python (aka **pythonic code**). If you know Python, you can build a web API with
    Sanic.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 的口号是：“构建快速。运行快速。”这当然突出了项目的性能导向。它还表明，在 Sanic 中构建应用程序的目标是直观的。让应用程序快速运行不应该意味着学习复杂的一套
    API 和几乎持续打开的文档的第二浏览器窗口。虽然其他工具大量使用“黑盒”类型的功能，如全局变量、“魔法”导入和猴子补丁，但 Sanic 通常更倾向于走向编写良好、干净且符合
    Python 习惯（即 **pythonic 代码**）的方向。如果你了解 Python，你可以使用 Sanic 构建网络 API。
- en: 'If performance alone is not the defining feature, then what is? The front-page
    of the Sanic project’s website gives six reasons for us to explore:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能不是定义特征，那么是什么？Sanic 项目网站首页给出了六个原因，让我们来探索：
- en: Simple and lightweight
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单且轻量级
- en: Unopinionated and flexible
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无偏见且灵活
- en: Performant and scalable
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能卓越且可扩展
- en: Production ready
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产就绪
- en: Trusted by millions
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受数百万用户信赖
- en: Community driven
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区驱动
- en: Simple and lightweight
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单且轻量级
- en: The API is intentionally lightweight. This means that the most common properties
    and methods are easily accessible and that you do not need to spend a lengthy
    period of time memorizing a particular call stack. Early on in the history of
    the project, there were discussions about adding certain features. But often adding
    features can lead to bloat. The SCO decided that it was more important to focus
    on the specifics of providing a quality developer experience than on providing
    “bells and whistles” features.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: API 故意保持轻量级。这意味着最常见的属性和方法易于访问，你不需要花费大量时间来记忆特定的调用堆栈。在项目早期，曾有过关于添加某些功能的讨论。但通常添加功能会导致臃肿。SCO
    决定，专注于提供优质的开发者体验比提供“铃铛和口哨”功能更为重要。
- en: For example, if my application is meant to be consumed by third-party applications,
    then why do does it need CORS? There are so many differing needs for web applications
    that it was decided these features are better left to plugins and developers.
    This leads to the next reason.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我的应用程序旨在被第三方应用程序使用，那么为什么它需要CORS？对于Web应用程序来说，需求差异很大，因此决定将这些功能留给插件和开发者。这导致了下一个原因。
- en: Unopinionated and flexible
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无偏见且灵活
- en: 'Being unopinionated is a huge asset. It means that the developer decides if
    they want sessions or token authentication and if they want an ORM, raw SQL queries,
    a NoSQL db, a combination, or even no data store at all. That is not to say these
    things are not achievable in other frameworks. But, there are certain design decisions
    to take into account. Rather than focusing on all these features, Sanic would
    rather provide you with the tools to implement the features you need, and nothing
    more. Tooling beats features. Borrowing from a popular proverb: *Sanic does not
    give you the fish, it teaches you how to fish*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 无偏见是一个巨大的优势。这意味着开发者决定他们是否需要会话或令牌认证，以及他们是否需要ORM、原始SQL查询、NoSQL数据库、组合，甚至根本不需要数据存储。这并不是说这些事情在其他框架中无法实现。但是，需要考虑某些设计决策。与其关注所有这些特性，Sanic更愿意提供工具来实现你需要的功能，而无需更多。工具胜过特性。借用一句流行的谚语：*Sanic不给你鱼，而是教你如何捕鱼*。
- en: Performant and scalable
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能优异且可扩展
- en: This is what Sanic is most known for. With a performance-first approach towards
    development and implementations that include tools like **uvloop** and **ujson**,
    Sanic tends to outperform other asynchronous Python frameworks. We will not spend
    much time on benchmarks, because I tend to feel they have limited use when comparing
    frameworks. More important to performance is the ability to build fast and to
    scale fast. Sanic makes it simple to run multiple server instances from a single
    deployment. *Chapter 8*, *Running a server*, will talk more about scaling. Also
    important to note is that Sanic is very well suited to building monolithic applications,
    microservices, and everything in between because of the intentional flexibility
    of the API.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Sanic最出名的特点。Sanic以性能优先的开发方法，以及包括**uvloop**和**ujson**在内的工具在内的实现，往往能超越其他异步Python框架。我们不会在基准测试上花费太多时间，因为我倾向于认为在比较框架时它们的使用有限。对性能来说，更重要的是能够快速构建和快速扩展。Sanic使得从单个部署运行多个服务器实例变得简单。*第8章*，*运行服务器*，将更详细地讨论扩展。同样重要的是要注意，由于API的故意灵活性，Sanic非常适合构建单体应用程序、微服务以及介于两者之间的所有内容。
- en: Production ready
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产就绪
- en: It is common for frameworks to ship with a development server. These development
    servers make the process of building simpler by including features like auto-reload
    while you are working on it. However, these servers tend to not be ready for production
    environments. Sanic server is intentionally built to be the primary strategy for
    deployment in production systems. This leads to the next reason.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 框架通常附带开发服务器。这些开发服务器通过包括你在工作时自动重新加载等特性，使构建过程变得更简单。然而，这些服务器往往不适合生产环境。Sanic服务器是故意构建的，旨在成为生产系统中部署的主要策略。这导致了下一个原因。
- en: Trusted by millions
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受数百万信任
- en: Sanic is installed and powering a number of applications both large and small.
    It is used in corporate-built web applications and personal web projects. It tends
    to be one of the most downloaded frameworks from PyPI. Between April 2019 and
    April 2020, there were 48 million downloads of Django. Sanic in that same period
    had about 44 million downloads. It is a project with high visibility and wide-spread
    adoption in a variety of use cases.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic已安装并支持众多大小不一的应用程序。它被用于企业构建的Web应用程序和个人Web项目中。它往往是PyPI上下载量最大的框架之一。在2019年4月到2020年4月之间，Django的下载量达到了4800万次。在同一时期，Sanic的下载量约为4400万次。这是一个具有高度可见性和广泛采用的项目，适用于各种使用场景。
- en: Community driven
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 由社区驱动
- en: 'Since the move from an individual repository to a community organization in
    2018, decision-making has become shared across the members of the community in
    what they call “lazy consensus”. Here’s what the SCO’s website ([https://sanicframework.org/en/guide/project/scope.html#lazy-consensus](https://sanicframework.org/en/guide/project/scope.html#lazy-consensus))
    says:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2018年从个人仓库迁移到社区组织以来，决策权已经通过社区成员所称为的“懒惰共识”共享。以下是SCO网站([https://sanicframework.org/en/guide/project/scope.html#lazy-consensus](https://sanicframework.org/en/guide/project/scope.html#lazy-consensus))上的说法：
- en: In general, as long as nobody explicitly opposes a proposal or patch, it is
    recognized as having the support of the community. This is called lazy consensus;
    that is, those who have not stated their opinion explicitly have implicitly agreed
    to the implementation of the proposal.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，只要没有人明确反对一个提案或补丁，它就被认为是得到了社区的认可。这被称为懒惰共识；也就是说，那些没有明确表达意见的人已经隐含地同意了提案的实施。
- en: Another important factor of the community is the ability of all members (whether
    a regular contributor or a first-time user) to enter the conversation and input
    valuable information into the conversation. As much as possible, Sanic attempts
    to be “of the community, by the community” to ensure its stability, feature set,
    and future.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 社区的一个重要因素是所有成员（无论是常规贡献者还是首次用户）都有能力参与到对话中，并将有价值的信息输入到对话中。尽可能多的，Sanic试图成为“由社区，为社区”的，以确保其稳定性、功能集和未来。
- en: The insistence on a community-first organization is itself meant to create a
    level of stability. All the work on the project is done by volunteers. It is a
    labor of love. With that said, projects driven by passion alone are at risk of
    becoming unmaintained if it rests upon the shoulders of a single person. This
    is exactly the scenario Sanic was trying to escape when the SCO was created. Being
    a project “of the community” means that there are multiple people willing and
    capable to help carry the torch forward. Sanic achieves this with a rotating set
    of developers and balances long-term stability with staggered terms.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 强调以社区为先的组织本身是为了创造一种稳定性。项目上的所有工作都是由志愿者完成的。这是一项充满爱的工作。话虽如此，仅靠激情驱动的项目如果依赖于单一个人的肩膀，就有可能变得无人维护。这正是Sanic在创建SCO时试图避免的场景。作为一个“由社区”的项目意味着有多个愿意并且能够帮助继续前进的人。Sanic通过一组轮换的开发者来实现这一点，并在长期稳定性和交错任期之间取得平衡。
- en: '**More on the SCO**'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**更多关于SCO**'
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you want to learn more about the structure of the SCO and how you can get
    involved, check out the Sanic Community Organization Policy E-manual (aka SCOPE):
    [https://sanicframework.org/en/guide/project/scope.html](https://sanicframework.org/en/guide/project/scope.html).'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于SCO的结构以及如何参与其中，请查看Sanic社区组织政策E手册（也称为SCOPE）：[https://sanicframework.org/en/guide/project/scope.html](https://sanicframework.org/en/guide/project/scope.html)。
- en: What drives code decisions?
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动代码决策的是什么？
- en: Although not exactly formalized, there is an underlying set of principles that
    the architects and engineers of Sanic use when making coding decisions. Keeping
    in mind that this project is built by the hands of many people, from many backgrounds
    and experience levels, it is no surprise to learn that maintaining a set of consistent
    coding practices is itself a challenge.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并没有被正式化，但Sanic的架构师和工程师在做出编码决策时，遵循一套潜在的原则。考虑到这个项目是由来自不同背景和经验水平的多个人共同打造的，因此了解到维护一套一致的编码实践本身就是一项挑战，也就不足为奇了。
- en: I am not specifically talking about things like formatting–tools like **black**,
    **isort**, **flake8**, and **mypy** have abstracted that away. Rather, what should
    the code look like, how should it be organized, and what patterns should be followed?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是在具体谈论诸如格式化等问题——像**black**、**isort**、**flake8**和**mypy**这样的工具已经将这些问题抽象化了。相反，代码应该是什么样子，应该如何组织，以及应该遵循哪些模式？
- en: 'These principles behind developing Sanic’s code base are:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Sanic代码库背后的原则包括：
- en: performance,
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能，
- en: usability (unopinionated), and
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性（无偏见），以及
- en: simplicity
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单性
- en: 'Any line of code that is going to run during the execution of the request/response
    cycle will be highly scrutinized for its performance impacts. When faced with
    a question that puts two or more of these core philosophies in opposition, the
    performance consideration will almost always win. However, there are times when
    a slower alternative must be used to either: (1) not force developers into an
    awkward development pattern, or (2) add an undue level of complexity for developers.
    Part of the “speed” of Sanic is not just application performance, but also development
    performance.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求/响应周期执行过程中将要运行的任何代码行都将对其性能影响进行高度审查。当面对一个将两个或更多核心原则置于对立的问题时，性能考虑几乎总是占上风。然而，有时必须使用较慢的替代方案，要么是为了：（1）不让开发者陷入尴尬的开发模式，或者（2）为开发者增加不必要的复杂性。Sanic的“速度”不仅仅是指应用性能，还包括开发性能。
- en: When using Sanic, we can feel confident that there is a team of developers scrutinizing
    every line of code and its impact on performance, usability, and simplicity.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Sanic 时，我们可以确信有一支开发团队在审查每一行代码及其对性能、可用性和简洁性的影响。
- en: Let’s imagine you are being asked to build an API by a project manager, who
    has a deadline in mind. To meet that goal, you want to get up and running as quickly
    as possible. But, you also want to make sure you will have the freedom to iterate
    on the problems that face you without fear of being boxed into making bad decisions.
    One of the goals of this book is to help you identify useful patterns to adapt
    to help you get there.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你被项目经理要求构建一个 API，他有一个明确的截止日期。为了达到这个目标，你希望尽可能快地开始运行。但是，你也不想失去对面临的问题进行迭代改进的自由，而不必担心做出糟糕的决定。本书的一个目标就是帮助你识别有用的模式，以适应并帮助你达到那里。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: It is helpful to understand the history and decisions behind Sanic to understand
    its feature set and implementation. Often, Sanic will be seen as an attempt to
    bring *async/await* style programming to a Flask app. While this may be a fair
    point of the original proof-of-concept, Sanic has developed upon a very divergent
    path with the goal and impact of becoming a powerful tool designed for performance
    applications.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Sanic 的历史和背后的决策有助于了解其功能集和实现。通常，Sanic 被视为将 *async/await* 风格编程引入 Flask 应用的尝试。虽然这可能是一个原始概念的一个公平观点，但
    Sanic 已经发展出了一条非常不同的路径，其目标和影响是成为一个专为性能应用设计的强大工具。
- en: Sanic is therefore typically used by developers and teams that are looking to
    build a rich environment that addresses the unique—and *obvious*—design patterns
    required by their application’s needs. The intent of the project is to take away
    the difficult or cumbersome parts of building a web server and providing the tools
    to create performant and scalable web applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Sanic 通常被那些寻求构建一个满足其应用需求独特且*明显*的设计模式的丰富环境的开发者和团队所使用。项目的目的是去除构建网络服务器和提供创建高性能和可扩展网络应用工具的困难或繁琐部分。
- en: Now that we have learned the background of Sanic, we can understand and appreciate
    the flexibility of using Sanic as a web framework. It is helpful to know the context
    in which Sanic was developed so that we can learn how to use it in our projects.
    The next step—beginning in *Chapter 2*, *Organizing a project*, —is to start learning
    some of the foundational decisions we should make when starting any new web development
    project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Sanic 的背景，我们可以理解和欣赏使用 Sanic 作为网络框架的灵活性。了解 Sanic 的开发背景对我们学习如何在项目中使用它非常有帮助。下一步——从*第二章*，*组织项目*开始——是开始学习我们在开始任何新的网络开发项目时应该做出的基础决策。
