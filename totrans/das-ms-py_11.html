<html><head></head><body>
        

                            
                    <h1 class="header-title">Microservices</h1>
                
            
            
                
<p>In the previous chapter, we looked at reactive programming and the ReactiveX framework. In this chapter, we're going to take a look at what a microservice is, why we might want to structure our programs as microservices, and how to use some common Python tools to create them. You'll learn how to use the Flask package to quickly and easily construct a microservice that uses HTTP and <strong>representational state transfer</strong>, (<strong>REST</strong>), to provide its interface. We're also going to look at using the nameko package to create microservices that communicate using remote procedure calls instead of HTTP methods.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Microservices and the advantages of process isolation</li>
<li>Building high-level microservices with Flask</li>
<li>Building high-level microservices with nameko</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Microservices and the advantages of process isolation</h1>
                
            
            
                
<p>In this section, we'll look at microservices from a conceptual perspective. When we need a new feature for a project, there's a temptation to just add it to the project's main program and continue on from there. Sometimes, that's entirely appropriate, but in many cases, it's actually better to make the feature a distinct program in its own right.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advantages of the microservice architecture</h1>
                
            
            
                
<p>There are several reasons why a feature might be better off when less tightly integrated into the system. The most important ones are <strong>flexibility</strong>, <strong>scalability</strong>, and <strong>durability</strong>.</p>
<p>Understanding the flexibility benefit is easy. Modular programs inherently consist of a bunch of modules that we can reuse in the future. So, every time we write our code as an independent module with a well-defined interface, we're making an investment that will make it easier to adapt to the changes that come in the future.</p>
<p>The scalability advantage comes into play when our modules are actually separate processes, allowing separate instances to be run on multiple processors, with the load balanced across them.</p>
<p>The durability advantage also comes into play when the modules are processes because processes are mostly safe from the bugs that crop up in other processes, also because a failed process can often be restarted without needing to take down the whole system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying the microservice architecture to web servers</h1>
                
            
            
                
<p>Flexibility, scalability and durability are the same advantages that drove the development of microkernel operating systems back in the 1980s, but the term microservice (refer to following image) specifically refers to applying them to web applications:</p>
<div><img height="220" width="442" class="aligncenter size-full wp-image-920 image-border" src="img/74e911f5-e824-4b73-8503-80081817c880.jpg"/><br/></div>
<p>This means that instead of writing one server program that handles all the logic of our web application, we'll write one or more servers that handle most of the frontend work and call on a bunch of different special-purpose servers to handle all the backend work and any remaining parts of the frontend.</p>
<p>Each special-purpose server should do a single well-defined job as well as possible and not care about anything. Those special-purpose servers are microservices, and using a microservice design gives us better uptime. Uptime lets us scale up to take advantage of a server farm or a cloud hosting system and helps us adapt to the ever-changing web more quickly.</p>
<p>So, to recap, when our server is actually a collection of servers, each of which has a narrow and well-defined job to do, and does only that, we're using a microservice architecture. As an added benefit, the interfaces between our microservices constitute an application programming interface. So, if we get to a place where we want to expose an API for the world to use, all we have to do is adjust our authentication and authorization code, and possibly our routers, to allow external entities to access some of those interfaces.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building high-level microservices with Flask</h1>
                
            
            
                
<p>So, we had a look at what a microservice is and why structuring our servers as collection of microservices is helpful. Now, let's take a look at the practicalities and use Flask to construct a functioning microservice.</p>
<p>Microservices can be pretty easily divided into those that use web technologies, such as HTTP, to communicate with each other and those that use a dedicated inter-process communication or a remote-procedure-called mechanism to communicate.</p>
<p>There are advantages to each, depending on the specific needs of a project and neither is inherently easier to work with. However, I'm going to refer to microservices that use web technologies to communicate as <em>high level</em> because they are inherently closer to the level at which users operate. Conversely, I'll refer to microservices that use specialized protocols as <em>low level</em>. In this section, we'll look at high-level microservices, which usually use HTTP to communicate and provide REST-based programming interfaces.</p>
<p>Using stateless protocols for communication makes these microservices easy to load balance and easy to swap in and out for maintenance. For this type of microservice, we can use any of Python's several production quality web application frameworks or toolkits, but we're going to use Flask.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Flask</h1>
                
            
            
                
<p>Flask is laser-focused on making it easy to write handlers for HTTP requests and doesn't really do anything else. That makes it very well-suited for writing a microservice that processes a few specific requests while using minimal resources.</p>
<p>Flask isn't part of a Python standard library, but it's easily installed using <kbd>pip</kbd>, as shown in the following command line:</p>
<pre>
<strong>$python3 -m pip install flask</strong>
</pre>
<p>As always, you can add <kbd>--user</kbd> to the command to install Flask into your personal Python package library, or you can install it into a virtual environment if you prefer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating endpoints for a RESTful API in Flask</h1>
                
            
            
                
<p>Flask is designed to interface with a frontend web server or proxy using the <strong>Web Server Gateway Interface</strong> (<strong>WSGI</strong>), which is standard for Python web applications. However, we'll just use its built-in development server for our simple little demonstration. So, what shall we build?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a microservice to maintain a database</h1>
                
            
            
                
<p>Let's build a microservice that maintains a database of information about people-first name, last name, age, and for interest's sake, whether or not they are members of a particular club.</p>
<p>We'll use the <kbd>POST</kbd>, <kbd>GET</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> methods of HTTP to allow the clients of the microservice to create, access, update, and remove records from the database. Also, we'll provide the data in JSON format, but accept the input using the normal HTTP form encoding.</p>
<p>These choices are all very normal. The only, slightly-less-common choice would be to have incoming data in JSON format as well, which we accommodate by calling the <kbd>request.get_json</kbd> function of Flask when we need the data.</p>
<p>So, which boilerplate code do we need to get a Flask microservice on its feet? Not much, as it turns out. The following two command lines are sufficient to get the Flask system in place:</p>
<pre>
import flask 
app = flask.Flask('Demo Flask') 
</pre>
<p>These lines don't actually do anything except return <em>404 Not Found</em> errors in response to any request, but they'll respond. So, how do we make Flask handle a request? Let's take a look.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making Flask handle a request</h1>
                
            
            
                
<p>There are actually two ways to make Flask handle a request: one way is incredibly simple and the other is more flexible and better encapsulated.</p>
<p>The simpler way is to use the <kbd>@app.route</kbd> decorator to tell Flask that a particular function will handle requests for a given path, as shown in the following code example:</p>
<pre>
@app.route('/example') 
def example(): 
  return "This is an example" 
</pre>
<p>That's all that's needed, apart from making the function actually do something useful.</p>
<p>However, for our microservice, we want to use HTTP methods on the same path to produce different results. We can use an <kbd>app.route</kbd> decorator and a bunch of <kbd>if</kbd> and <kbd>else if</kbd> blocks in the function to handle that, but there's a better way, which is explained using the following code example and that you can find in the <kbd>endpoint.py</kbd> file in the download pack:</p>
<div><img height="430" width="520" class="aligncenter size-full wp-image-786 image-border" src="img/8b9ccad3-130f-4a89-8118-77ef0d2ada4a.jpg"/><br/></div>
<div><p>Flask supports pluggable view classes and specifically has a <kbd>MethodView</kbd> class that has a different handler function for each HTTP method, as you can see in the first four function definitions in our class. The appropriate function processes each request based on which HTTP method was used.</p>
<p>There's a slight complication to this because we don't actually always want to use the same path. Sometimes, we want an object <kbd>id</kbd> in the path and sometimes we don't. This is only a small complication though, because we can register the same pluggable view on several different combinations of path and method, which is exactly what the <kbd>endpoint.register</kbd> function in <kbd>endpoint.py</kbd> does, as you can see in the code example.</p>
<p>Each registration of <kbd>view</kbd> consists of one call to <kbd>app.add_url_rule</kbd>:</p>
<ul>
<li>The first one registers the <kbd>GET</kbd> method with no object <kbd>id</kbd> and fills in values to use for the <kbd>id</kbd> parameter when calling the <kbd>GET</kbd> function</li>
<li>The second one registers the <kbd>POST</kbd> method with no <kbd>id</kbd> and no default because our <kbd>POST</kbd> function doesn't accept an <kbd>id</kbd> parameter at all</li>
<li>The third one registers the <kbd>GET</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> methods when there is an <kbd>id</kbd> parameter</li>
</ul>
<p>These registrations cover all the use cases common to a single programming interface endpoint in REST.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Running and connecting to our microservice using Flask</h1>
                
            
            
                
<p>Now that we have our method dispatching ready, how about we put together our actual handlers for manipulating person objects? We can do it using the following code found in the <kbd>service.py</kbd> file:</p>
<div><img height="536" width="706" class="aligncenter size-full wp-image-923 image-border" src="img/166cafd1-dcad-4d22-a525-457023618911.jpg"/></div>
<p>For the detailed code, please refer to the code files.</p>
<p>From the preceding code example, we find the following:</p>
<ul>
<li>We see our <kbd>PersonAPI</kbd> class, which has one function for each of the operations we want to enable on our <kbd>person</kbd> database.</li>
<li>For the <kbd>POST</kbd> and <kbd>PUT</kbd> functions, we get data from the request using the <kbd>request.form</kbd> object, which is a dictionary-like object containing the decoded data from the request body.</li>
</ul>
<p>This looks like it's not thread-safe, but it actually is. Everything in Flask is multithread and multiprocess safe; it's just wrapped in a simplifying semantic layer that simulates a single-threaded single-process system.</p>
<ul>
<li>The <kbd>POST</kbd> function doesn't have any code to handle missing data, except for the member value. This is because if we try to access a missing value from <kbd>request.form</kbd>, an exception is raised that causes Flask to return a <em>400 Bad Request</em> error, which is exactly the right thing to do in this case.</li>
<li>The <kbd>PUT</kbd> function, on the other hand, handles those exceptions itself, so that it can decide which values to update and which to leave alone.</li>
<li>The <kbd>GET</kbd> function might be called with an integer <kbd>id</kbd> or with <kbd>None</kbd> for the <kbd>id</kbd> parameter and needs to handle both cases. This is easily done with an <kbd>if</kbd> statement.</li>
<li>In the case where the <kbd>id</kbd> parameter is a number, the <kbd>GET</kbd> function is supposed to return the state of the object with that <kbd>id</kbd> parameter. If <kbd>id</kbd> is <kbd>None</kbd>, it is supposed to return a list of all of the objects.</li>
</ul>
<p>All the methods return JSON-formatted data, which is done using Python's standard <kbd>json</kbd> package and specifically the <kbd>json.dumps</kbd> function, which transforms Python data structures into JSON-formatted strings.</p>
<p>We also need to provide the content type header with the value of application JSON as a matter of good practice. Between these two things in the return statement, we're also providing the HTTP status. This could be omitted, but since we're returning error codes in some places, it makes sense to include the status code even when it's not an error.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test running the microservice</h1>
                
            
            
                
<div><p>To do a test run of our microservice, we need to start up Flask (using the following command) and tell it to serve our microservice:</p>
<p>For Unix/Linux and macOS, run the following command:</p>
<pre>
<strong>export FLASK_APP=demo_flaskpython3 -m flask run</strong>
</pre>
<p>For Windows, run the following command:</p>
<pre>
<strong>set FLASK_APP=demo_flaskpython3 -m flask run</strong>
</pre>
<p>The <kbd>demo_flask</kbd> package also contains a module called <kbd>test.py</kbd> that we can use as a client that connects to our microservice and put it through its paces. It will add, delete, list, and modify a couple of database entries and also try out a bad post request to show that the error handling is working.</p>
<p>There's one more part of the Flask demo microservice that we haven't talked about and won't in detail. That is the <kbd>person.py</kbd> file, which contains a simple interface with a SQLite3 database for actually storing and retrieving objects. Feel free to look at it, of course, but it's not particularly relevant to the topics of the chapter, and a production system should probably use SQLAlchemy, Redis, CouchDB, and so on.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Building high-level microservices with nameko</h1>
                
            
            
                
<div><p>In this section, we'll take a look at <strong>nameko</strong>, which will help us put together a microservice that communicates using the <strong>Advanced Message Queuing Protocol</strong> (<strong>AMQP</strong>), which we can safely think of as a <strong>Remote Procedure Call</strong> (<strong>RPC</strong>) protocol, though that's actually only a part of what it does.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing nameko</h1>
                
            
            
                
<div><p>Using HTTP to define the interface for our microservice has the advantages of familiarity and good integration with web technologies, but there's a certain amount of overhead involved in mapping the request and input data onto the functions and parameters that are actually meaningful to us.</p>
<p>We can come up with abstractions that hide that part of the process, of course. That's essentially what the authors of nameko did, although they use AMQP instead of HTTP to transport data and events.</p>
<p>Installing nameko itself is easy. Use pretty much the same <kbd>pip</kbd> command we always use, as shown here:</p>
<pre>
<strong>python3 -m pip install nameko</strong>
</pre>
<p>The output of the preceding command is as follows:</p>
<div><img class="image-border" src="img/62ac1754-7bc5-4178-8d09-9ff6508c9216.jpg"/></div>
<p>Be aware though that nameko won't actually work until we install some other software as well. More on that is covered in the <em>Things to know before using nameko</em> section.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Running and connecting a microservice using nameko</h1>
                
            
            
                
<div><p>Looking at the nameko version of our <kbd>person</kbd> service, it's clear that the effort paid off. Our service is defined by a class with the <kbd>name</kbd> attribute and several member functions decorated with <kbd>RPC</kbd>, as shown in the following code example:</p>
<div><img height="427" width="472" class="aligncenter size-full wp-image-789 image-border" src="img/5524cd49-ae11-44bc-b14d-be71ea350057.jpg"/></div>
<p>The member functions interface with the same database interface class we used in the previous section. In a very straightforward way, it would even be reasonable to combine the two into one class, and that's it-the complete definition of our microservice using nameko. Pretty sweet, right? It really is, but every cloud has a silver lining, as we'll soon see.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Things to know before using nameko</h1>
                
            
            
                
<div><p>Nameko is great, but there are things we need to be aware of before we choose nameko or any similar tool.</p>
<p>The first thing to be aware of is that nameko doesn't provide the complete AMQP infrastructure, it just connects to it.</p>
<p>The AMQP infrastructure is responsible for conveying messages between connected programs in a way that is quick and reliable.</p>
<p>This means that we need an AMQP server running somewhere that nameko can find it and an AMQP server accessible to the microservice's users, and those servers need to be connected to each other.</p>
<p>They could be the same server, of course, but they don't have to be. Nameko recommends the RabbitMQ AMQP server, which can be downloaded from its own website (<a href="http://www.rabbitmq.com">www.rabbitmq.com</a>). The installation is relatively uncomplicated and there are detailed instructions on the site.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Interacting with our microservice</h1>
                
            
            
                
<div><p>Now that we have an AMQP server installed and running, can we connect or service and manipulate person objects? Technically yes, but we need to use nameko to write the client too.</p>
<p>AMQP isn't as simple to work with as HTTP, and the RPC mechanism adds an additional layer of complexity. We don't want to work with that raw.</p>
<p>There are two ways to interact with our microservice. Let's examine them in a bit more detail.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Interacting with a microservice manually using the nameko shell</h1>
                
            
            
                
<div><p>The first way we can interact with our microservice is manually using the nameko shell, which is an enhanced Python shell. First, we have to run the microservice, which we'll do in its own command window, running the following command:</p>
<pre>
<strong>nameko run demo_nameko.service</strong>
</pre>
<p>Then, we'll start the <kbd>nameko</kbd> shell and use the end <kbd>RPC</kbd> object to access the functions of our microservice, as shown in the following code example:</p>
<div><img height="111" width="371" class="aligncenter size-full wp-image-667 image-border" src="img/3af9b037-72e6-4ed9-95bc-8464fcfa3921.jpg"/></div>
<p>Here, it looks like we're just calling the functions, but actually we're communicating with the microservice through the AMQP protocol.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Interacting with a microservice by creating another microservice</h1>
                
            
            
                
<div><p>The second way we can interact with our microservice is to create another microservice that depends on it, as shown in the following code example found in the <kbd>test.py</kbd> file:</p>
</div>
<div><img height="302" width="371" class="aligncenter size-full wp-image-790 image-border" src="img/94de294f-8a56-4753-99a0-8b2b4c8c2beb.jpg"/></div>
<p>The <kbd>TestService</kbd> class periodically exercises the <kbd>person</kbd>service. It also demonstrates how to link one service to another, so that one of them is able to access the other. The key is this line, which creates an <kbd>RpcProxy</kbd> instance on the class:</p>
<pre>
<strong>person = RpcProxy('person')</strong>
</pre>
<p>When the service runs, it's able to access the functions of the specified remote service through that object. To run our tests, we need to start both the <kbd>person</kbd> microservice and the <kbd>test</kbd> microservice, which we can do with a single command, as shown in the following code:</p>
<pre>
<strong>nameko run demo_nameko.service demo_nameko.test</strong>
</pre>
<p>You may have noticed that we return the object <kbd>id</kbd> from the <kbd>create</kbd> function, rather than create a <kbd>person</kbd> object itself. That's because we can't return the <kbd>person</kbd> object.</p>
<p>Nameko functions can return any data that can be represented as JSON, but that doesn't include instances of arbitrary classes. The same goes for parameters that are passed into the functions of a microservice; they need to be within the limits of JSON.</p>
<p>This isn't actually a more stringent restriction than what we saw in the Flask microservice (in the previous section). It's just that with Flask it was obvious we were sending data across the network in JSON format, so that limitation was obvious. With nameko, the requirement is the same, but the reason for it is easier to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<div><p>At the start of the chapter, we looked at what microservices are philosophically and what their advantages are, and implemented an HTTP-oriented microservice using Flask.</p>
<p>We then looked at some of the advantages of process-based modularity and saw how applying those principles to web applications results in a microservice architecture. We looked at the details needed to use Flask to create a RESTful microservice and put that knowledge to use by building a simple person management microservice.</p>
<p>Next, we looked at using nameko's RPC mechanism to implement a microservice, which simplifies the code significantly, at the cost of requiring that we set up an AMQP infrastructure and a more difficult interface with systems outside the AMQP network.</p>
<p>In the next chapter, we'll look at how to interface between Python and compiled code to optimize performance bottlenecks in our code and access libraries written in other programming languages.</p>
</div>


            

            
        
    </body></html>