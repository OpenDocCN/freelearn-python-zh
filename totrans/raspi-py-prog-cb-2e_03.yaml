- en: Chapter 3. Using Python for Automation and Productivity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. 使用 Python 进行自动化和生产力
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using Tkinter to create graphical user interfaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Tkinter 创建图形用户界面
- en: Creating a graphical Start menu application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图形化启动菜单应用程序
- en: Displaying photo information in an application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中显示照片信息
- en: Organizing your photos automatically
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动组织您的照片
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Until now, we have focused purely on command-line applications; however, there
    is much more to the Raspberry Pi than just the command line. By using **graphical
    user interfaces** (**GUIs**), it is often easier to obtain input from a user and
    provide feedback in a more natural way. After all, we continuously process multiple
    inputs and outputs all the time, so why limit ourselves to the procedural format
    of the command line when we don't have to?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注的是命令行应用程序；然而，树莓派的功能远不止命令行。通过使用 **图形用户界面**（**GUIs**），通常更容易从用户那里获取输入并以更自然的方式提供反馈。毕竟，我们不断地处理多个输入和输出，所以为什么我们非得限制自己使用命令行的过程格式，而不必这样做呢？
- en: Fortunately, Python can support this. Much like other programming languages,
    such as Visual Basic and C/C++/C#, this can be achieved using prebuilt objects
    that provide standard controls. We will use a module called **Tkinter** which
    provides a good range of controls (also referred to as **widgets**) and tools
    for creating graphical applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 可以支持这一点。与其他编程语言类似，如 Visual Basic 和 C/C++/C#，这可以通过提供标准控件的前构建对象来实现。我们将使用一个名为
    **Tkinter** 的模块，它提供了一系列控件（也称为 **小部件**）和工具，用于创建图形应用程序。
- en: First, we will take our previous example, the `encryptdecrypt.py` module discussed
    in the *How to do it…* section in the *Working with text and strings* recipe in
    [Chapter 2](ch02.html "Chapter 2. Starting with Python Strings, Files, and Menus"),
    *Starting with Python Strings, Files, and Menus*, and demonstrate how useful modules
    can be written and reused in a variety of ways. This is a test of good coding
    practice. We should aim to write code that can be tested thoroughly and then reused
    in many places.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用之前在 *Working with text and strings* 章节中 *How to do it…* 小节讨论的 `encryptdecrypt.py`
    模块，并在 [第 2 章](ch02.html "第 2 章. 从 Python 字符串、文件和菜单开始") *Starting with Python Strings,
    Files, and Menus* 中展示如何编写和以多种方式重用有用的模块。这是一个良好的编码实践的测试。我们应该努力编写可以彻底测试并在许多地方重用的代码。
- en: Next, we will extend our previous examples by creating a small graphical Start
    menu application to run our favorite applications from.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过创建一个小的图形化启动菜单应用程序来扩展我们之前的示例，以便从该应用程序运行我们的最爱应用。
- en: Then, we will explore using **classes** within our applications to display and
    then to organize photos.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨在应用程序中使用 **类** 来显示和组织照片。
- en: Using Tkinter to create graphical user interfaces
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Tkinter 创建图形用户界面
- en: We will create a small GUI to allow the user to enter information, and the program
    can then be used to encrypt and decrypt it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小的图形用户界面（GUI），允许用户输入信息，然后程序可以用来加密和解密这些信息。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to ensure that you have completed the instructions in the *There's
    more…* section of the *Working with text and strings* recipe in [Chapter 2](ch02.html
    "Chapter 2. Starting with Python Strings, Files, and Menus"), *Starting with Python
    Strings, Files, and Menus*, where we created the reusable `encryptdecrypt.py`
    module. You must ensure that this file is placed in the same directory as the
    following script.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保您已经完成了 [第 2 章](ch02.html "第 2 章. 从 Python 字符串、文件和菜单开始") *Starting with
    Python Strings, Files, and Menus* 章节中 *There's more…* 小节 *Working with text and
    strings* 的说明，其中我们创建了可重用的 `encryptdecrypt.py` 模块。您必须确保此文件放置在与以下脚本相同的目录中。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since we are using Tkinter (one of many available add-ons of Python), we need
    to ensure that it is installed. It should be installed by default on the standard
    Raspbian image. We can confirm it is installed by importing it from the Python
    prompt, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用 Tkinter（Python 可用的许多附加组件之一），我们需要确保它已安装。它应该默认安装在标准的 Raspbian 映像中。我们可以通过从
    Python 提示符导入它来确认它已安装，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If it is not installed, an `ImportError` exception will be raised, in which
    case you can install it using the following command (use *Ctrl* + *Z* to exit
    the Python prompt):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它尚未安装，将会引发一个 `ImportError` 异常，在这种情况下，您可以使用以下命令进行安装（使用 *Ctrl* + *Z* 退出 Python
    提示符）：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the module did load, you can use the following command to read more about
    the module (use *Q* to quit when you are done reading):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块已加载，您可以使用以下命令了解更多关于模块的信息（阅读完毕后使用*Q*退出）：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also get information about all the classes, functions, and methods
    within the module using the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令获取模块中所有类、函数和方法的信息：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following `dir` command will list any valid commands or variables that
    are in the scope of the module:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`dir`命令将列出模块作用域内的任何有效命令或变量：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will see that our own modules will have the information about the functions
    marked by triple quotes; this will show up if we use the `help` command.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到我们自己的模块将包含由三引号标记的函数信息；如果我们使用`help`命令，这些信息将会显示。
- en: The command line will not be able to display the graphical displays created
    in this chapter, so you will have to start the Raspberry Pi desktop (using the
    command `startx`), or if you are using it remotely, ensure you have **X11 Forwarding**
    enabled and an **X server** running (see [Chapter 1](ch01.html "Chapter 1. Getting
    Started with a Raspberry Pi Computer"), *Getting Started with a Raspberry Pi Computer*).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行无法显示本章中创建的图形显示，因此您必须启动Raspberry Pi桌面（使用命令`startx`），或者如果您正在远程使用，请确保您已启用**X11转发**并且有一个**X服务器**正在运行（见[第1章](ch01.html
    "第1章。使用Raspberry Pi计算机入门")，*使用Raspberry Pi计算机入门*）。
- en: How to do it…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will use the `tkinter` module to produce a GUI for the `encryptdecrypt.py`
    script we wrote in the previous chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`tkinter`模块为我们在上一章中编写的`encryptdecrypt.py`脚本生成GUI。
- en: 'To generate the GUI we will create the following `tkencryptdecrypt.py` script:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成GUI，我们将创建以下`tkencryptdecrypt.py`脚本：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the script using the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We start by importing two modules; the first is our own `encryptdecrypt` module
    and the second is the `tkinter` module. To make it easier to see which items have
    come from where, we use `ENC`/`TK`. If you want to avoid the extra reference,
    you can use `from <module_name> import *` to refer to the module items directly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入两个模块；第一个是我们的`encryptdecrypt`模块，第二个是`tkinter`模块。为了更容易地看到哪些项目来自哪里，我们使用`ENC`/`TK`。如果您想避免额外的引用，可以使用`from
    <module_name> import *`直接引用模块项目。
- en: The `encryptButton()` and `decryptButton()` functions will be called when we
    click on the **Encrypt** and **Decrypt** buttons; they are explained in the following
    sections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**加密**和**解密**按钮时，将调用`encryptButton()`和`decryptButton()`函数；它们将在以下部分中解释。
- en: The main Tkinter window is created using the `Tk()` command, which returns the
    main window where all the widgets/controls can be placed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 主Tkinter窗口是通过使用`Tk()`命令创建的，它返回可以放置所有小部件/控件的主窗口。
- en: 'We will define six controls as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义以下六个控件：
- en: '`Label`: This displays the prompt **Enter message to encrypt:**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`: 这会显示提示**输入要加密的消息**：'
- en: '`Entry`: This provides a textbox to receive the user''s message to be encrypted'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输入框`: 这提供了一个文本框，用于接收用户要加密的消息'
- en: '`Button`: This is an **Encrypt** button to trigger the message to be encrypted'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮`: 这是一个**加密**按钮，用于触发消息加密'
- en: '`Button`: This is a **Decrypt** button to reverse the encryption'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮`: 这是一个**解密**按钮，用于反转加密'
- en: '`Label`: This displays the **Key:** field to prompt the user for an encryption
    key value'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`: 这会显示**密钥**字段，提示用户输入加密密钥值'
- en: '`Entry`: This provides a second textbox to receive values for the encryption
    keys'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输入框`: 这提供了一个第二个文本框，用于接收加密密钥的值'
- en: 'These controls will produce a GUI similar to the one shown in the following
    screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控件将生成一个与以下屏幕截图相似的GUI：
- en: '![How it works…](img/6623OT_03_1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/6623OT_03_1.jpg)'
- en: The GUI to encrypt/decrypt messages
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 加密/解密消息的GUI
- en: 'Let''s take a look at the first `label1` definition:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看第一个`label1`定义：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All controls must be linked to the application window; hence, we have to specify
    our Tkinter window `root`. The text used for the label is set by `text`; in this
    case, we have set it to a string named `prompt`, which has been defined previously
    with the text we require. We also set the `width` to match the number of characters
    of the message (while not essential, it provides a neater result if we add more
    text to our labels later), and finally, we set the background color using `bg='green'`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有控件都必须链接到应用程序窗口；因此，我们必须指定我们的Tkinter窗口`root`。用于标签的文本由`text`设置；在这种情况下，我们将其设置为名为`prompt`的字符串，该字符串之前已定义，包含我们所需的文本。我们还设置了`width`以匹配消息的字符数（虽然不是必需的，但如果我们以后添加更多文本到标签，它将提供更整洁的结果），最后，我们使用`bg='green'`设置了背景颜色。
- en: 'Next, we define the text `Entry` box for our message:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义用于消息的文本`Entry`框：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will define `textvariable`—a useful way to link a variable to the contents
    of the box—which is a special string variable. We could access the `text` directly
    using `textEnter.get()`, but we shall use a `Tkinter StringVar()` object instead
    to access it indirectly. If required, this will allow us to separate the data
    we are processing from the code that handles the GUI layout. The `enycrptvalue`
    variable automatically updates the `Entry` widget it is linked to whenever the
    `.set()` command is used (and the `.get()` command obtains the latest value from
    the `Entry` widget).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义`textvariable`——这是一种将变量链接到框内容的实用方法，它是一个特殊的字符串变量。我们可以直接使用`textEnter.get()`访问`text`，但我们将使用`Tkinter
    StringVar()`对象间接访问它。如果需要，这将允许我们将我们正在处理的数据与处理GUI布局的代码分开。`enycrptvalue`变量在每次使用`.set()`命令时自动更新它所链接的`Entry`小部件（并且`.get()`命令从`Entry`小部件获取最新值）。
- en: 'Next, we have our two `Button` widgets, **Encrypt** and **Decrypt**, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的两个`Button`小部件，**Encrypt**和**Decrypt**，如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, we can set a function to be called when the `Button` widget is
    clicked by setting the `command` attribute. We can define the two functions that
    will be called when each button is clicked. In the following code snippet, we
    have the `encryptButton()` function, which will set the `encryptvalue StringVar`
    that controls the contents of the first `Entry` box. This string is set to the
    result we get by calling `ENC.encryptText()` with the message we want to encrypt
    (the current value of `encryptvalue`) and the `keyvalue` variable. The `decrypt()`
    function is exactly the same, except we make the `keyvalue` variable negative
    to decrypt the message:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以通过设置`command`属性来设置当`Button`小部件被点击时调用的函数。我们可以定义当每个按钮被点击时将调用的两个函数。在下面的代码片段中，我们有`encryptButton()`函数，该函数将设置控制第一个`Entry`框内容的`encryptvalue
    StringVar`。该字符串被设置为通过调用`ENC.encryptText()`并传递我们想要加密的消息（`encryptvalue`的当前值）和`keyvalue`变量所得到的结果。`decrypt()`函数与它完全相同，除了我们将`keyvalue`变量设置为负值以解密消息：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We then set the final `Label` and `Entry` widgets in a similar way. Note that
    `textvariable` can also be an integer (numerical value) if required, but there
    is no built-in check to ensure that only numbers can be entered. You will get
    a `ValueError` exception when the `.get()` command is used.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后以类似的方式设置了最终的`Label`和`Entry`小部件。请注意，如果需要，`textvariable`也可以是一个整数（数值），但没有内置的检查来确保只能输入数字。当使用`.get()`命令时，您将得到一个`ValueError`异常。
- en: 'After we have defined all the widgets to be used in the Tkinter window, we
    have to set the layout. There are three ways to define the layout in Tkinter:
    place, pack, and grid.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了Tkinter窗口中要使用的所有小部件之后，我们必须设置布局。在Tkinter中有三种定义布局的方式：place、pack和grid。
- en: The place layout allows us to specify the positions and sizes using exact pixel
    positions. The pack layout places the items in the window in the order that they
    have been added in. The grid layout allows us to place the items in a specific
    layout. It is recommended that you avoid the place layout wherever possible since
    any small change to one item can have a knock-on effect on the positions and sizes
    of all the other items; the other layouts account for this by determining their
    positions relative to the other items in the window.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`place`布局允许我们使用精确的像素位置指定位置和大小。`pack`布局按照它们被添加的顺序将项目放置在窗口中。`grid`布局允许我们将项目放置在特定的布局中。建议尽可能避免使用`place`布局，因为任何一个小部件的微小变化都可能对其他所有小部件的位置和大小产生连锁反应；其他布局通过确定它们相对于窗口中其他项目的位置来解决这个问题。'
- en: 'We will place the items as laid out in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下截图所示放置项目：
- en: '![How it works…](img/6623OT_03_2.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/6623OT_03_2.jpg)'
- en: Grid layout for the Encrypt/Decrypt GUI
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 加密/解密GUI的网格布局
- en: 'The positions of first two items in the GUI are set using the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码设置GUI中前两个项目的位置：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can specify that the first `Label` and `Entry` box will span both columns
    (`columnspan=2`), and we can set the sticky values to ensure they span right to
    the edges. This is achieved by setting both the `TK.E` for the east and `TK.W`
    for the west sides. We'd use `TK.N` for the north and `TK.S` for the south sides
    if we needed to do the same vertically. If the `column` value is not specified,
    the grid function defaults to `column=0`. The other items are similarly defined.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定第一个 `Label` 和 `Entry` 框将跨越两个列（`columnspan=2`），并且我们可以设置粘性值以确保它们跨越到边缘。这是通过设置东边
    `TK.E` 和西边 `TK.W` 来实现的。如果我们需要垂直地做同样的事情，我们将使用 `TK.N` 对于北边和 `TK.S` 对于南边。如果未指定 `column`
    值，则网格函数默认为 `column=0`。其他项目以类似方式定义。
- en: The last step is to call `TK.mainloop()`, which allows Tkinter to run; this
    allows the buttons to be monitored for clicks and Tkinter to call the functions
    linked to them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用 `TK.mainloop()`，这允许Tkinter运行；这允许监控按钮的点击，并调用与它们链接的函数。
- en: Creating a graphical application – Start menu
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图形应用程序 – 开始菜单
- en: The example in this recipe shows how we can define our own variations of the
    Tkinter objects to generate custom controls and dynamically construct a menu with
    them. We will also take a quick look at using threads to allow other tasks to
    continue to function while a particular task is being executed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的示例展示了我们如何定义自己的Tkinter对象变体来生成自定义控件，并使用它们动态构建菜单。我们还将快速查看如何使用线程，以便在执行特定任务时允许其他任务继续运行。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To view the GUI display, you will need a monitor displaying the Raspberry Pi
    desktop, or need to be connected to another computer running the X server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看GUI显示，您需要一个显示Raspberry Pi桌面的监视器，或者需要连接到运行X服务器的另一台计算机。
- en: How to do it…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To create a graphical Start menu application, create the following `graphicmenu.py`
    script:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建图形开始菜单应用程序，创建以下 `graphicmenu.py` 脚本：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous code produces the following application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码生成以下应用程序：
- en: '![How to do it…](img/6623OT_03_3.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/6623OT_03_3.jpg)'
- en: The App Menu GUI
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序菜单GUI
- en: How it works…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We create the Tkinter window as we did before; however, instead of defining
    all the items separately, we create a special class for the application buttons.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建Tkinter窗口的方式与之前相同；然而，我们不是单独定义所有项目，而是为应用程序按钮创建一个特殊类。
- en: The **class** we create acts as a blueprint or specification of what we want
    the `appButtons` items to include. Each item will consist of a string value for
    `app_cmd`, a function called `startApp()`, and an `__init__()` function. The `__init__()`
    function is a special function (called a **constructor**) that is called when
    we create an `appButtons` item; it will allow us to create any setup that is required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 **类** 作为 `appButtons` 项目所需内容的蓝图或规范。每个项目将包括一个用于 `app_cmd` 的字符串值，一个名为 `startApp()`
    的函数，以及一个 `__init__()` 函数。`__init__()` 函数是一个特殊函数（称为 **构造函数**），在创建 `appButtons`
    项目时被调用；它将允许我们创建所需的任何设置。
- en: In this case, the `__init__()` function allows us to create a new Tkinter button
    with the text to be set to an item in `app_list` and the command to be called
    in the `startApp()` function when the button is clicked. The `self` keyword is
    used so that the command called will be the one that is part of the item; this
    means that each button will call a locally defined function that has access to
    the local data of the item.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`__init__()` 函数允许我们创建一个新的Tkinter按钮，按钮上的文本设置为 `app_list` 中的项目，当按钮被点击时，将调用
    `startApp()` 函数中的命令。使用 `self` 关键字，所调用的命令将是项目的一部分；这意味着每个按钮都将调用一个本地定义的函数，该函数可以访问项目的本地数据。
- en: We set the value of `self.app_cmd` to the command from `app_list` and make it
    ready for use by the `startApp()` function. We now create the `startApp()` function.
    If we run the application command here directly, the Tkinter window will freeze
    until the application we have opened is closed again. To avoid this, we can use
    the Python **Threading** module, which allows us to perform multiple actions at
    the same time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `self.app_cmd` 的值设置为 `app_list` 中的命令，并使其准备好由 `startApp()` 函数使用。现在我们创建 `startApp()`
    函数。如果我们在这里直接运行应用程序命令，Tkinter窗口将冻结，直到我们打开的应用程序再次关闭。为了避免这种情况，我们可以使用Python的 **Threading**
    模块，它允许我们同时执行多个操作。
- en: The `runApplicationThread()` class is created using the `threading.Thread` class
    as a template—this inherits all the features of the `threading.Thread` class in
    a new class. Just like our previous class, we provide an `__init__()` function
    for this as well. We first call the `__init__()` function of the inherited class
    to ensure it is set up correctly, and then we store the `app_cmd` value in `self.cmd`.
    After the `runApplicationThread()` function has been created and initialized,
    the `start()` function is called. This function is part of `threading.Thread`,
    which our class can use. When the `start()` function is called, it will create
    a separate application thread (that is, simulate running two things at the same
    time), allowing Tkinter to continue monitoring button clicks while executing the
    `run()` function within the class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`runApplicationThread()`类是通过使用`threading.Thread`类作为模板创建的——这在新类中继承了`threading.Thread`类的所有功能。就像我们之前的类一样，我们也为这个类提供了一个`__init__()`函数。我们首先调用继承类的`__init__()`函数以确保其正确设置，然后我们将`app_cmd`值存储在`self.cmd`中。在`runApplicationThread()`函数创建并初始化后，调用`start()`函数。这个函数是`threading.Thread`的一部分，我们的类可以使用它。当调用`start()`函数时，它将创建一个单独的应用程序线程（即模拟同时运行两件事），允许Tkinter在执行类内的`run()`函数的同时继续监控按钮点击。'
- en: Therefore, we can place the code in the `run()` function to run the required
    application (using `call(self.cmd)`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将代码放置在`run()`函数中以运行所需的应用程序（使用`call(self.cmd)`）。
- en: There's more…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One aspect that makes Python particularly powerful is that it supports the programming
    techniques used in **Object-Orientated Design** (**OOD**). This is commonly used
    by modern programming languages to help translate the tasks we want our program
    to perform into meaningful constructs and structures in code. The principle of
    OOD lies in the fact that we think of most problems consisting of several objects
    (a GUI window, a button, and so on) that interact with each other to produce a
    desired result.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使Python特别强大的一点是它支持**面向对象设计**（**OOD**）中使用的编程技术。现代编程语言通常使用它来帮助我们将程序要执行的任务转化为代码中的有意义的构造和结构。OOD的原则在于，我们认为大多数问题都由几个对象（一个GUI窗口、一个按钮等）组成，这些对象相互作用以产生期望的结果。
- en: In the previous section, we found that we can use classes to create standardized
    objects that can be reused multiple times. We created an `appButton` class, which
    generated an object with all the features of the class, including its own personal
    version of `app_cmd` that will be used by the `startApp()` function. Another object
    of the `appButton` type will have its own unrelated `[app_cmd]` data that its
    `startApp()` function will use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们发现我们可以使用类来创建可重复使用的标准化对象。我们创建了一个`appButton`类，它生成一个具有所有类特征的对象，包括它自己的`app_cmd`版本，该版本将由`startApp()`函数使用。另一个`appButton`类型的对象将有自己的无关的`[app_cmd]`数据，其`startApp()`函数将使用。
- en: You can see that classes are useful to keep together a collection of related
    variables and functions in a single object, and the class will hold its own data
    in one place. Having multiple objects of the same type (class), each with their
    own functions and data inside them, results in better program structure. The traditional
    approach would be to keep all the information in one place and send each item
    back and forth for various functions to process; however, this may become cumbersome
    in large systems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，类有助于将相关变量和函数集合在一个对象中，并且类将在一个地方保存其自己的数据。拥有多个相同类型的对象（类），每个对象内部都有它们自己的函数和数据，这会导致更好的程序结构。传统的方法是将所有信息放在一个地方，并将每个项目来回发送给各种函数处理；然而，在大型系统中这可能会变得繁琐。
- en: 'The following diagram shows the organization of related functions and data:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了相关函数和数据的组织结构：
- en: '![There''s more…](img/6623OT_03_4.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/6623OT_03_4.jpg)'
- en: Related functions and data can be organized into classes and objects
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相关函数和数据可以组织到类和对象中
- en: So far, we have used Python modules to separate parts of our programs into different
    files; this allows us to conceptually separate different parts of the program
    (an interface, encoder/decoder, or library of classes, such as Tkinter). Modules
    can provide code to control a particular bit of hardware, define an interface
    for the Internet, or provide a library of common functionality; however, its most
    important function is to control the interface (the collection of functions, variables,
    and classes that are available when the item is imported). A well implemented
    module should have a clear interface that is centered around how it is used, rather
    than how it is implemented. This allows you to create multiple modules that can
    be swapped and changed easily since they share the same interface. In our previous
    example, imagine how easy it would be to change the `encryptdecrypt` module for
    another one just by supporting `encryptText(input_text,key)`. Complex functionality
    can be split into smaller, manageable blocks that can be reused in multiple applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用 Python 模块将程序的各个部分分离到不同的文件中；这使得我们可以在概念上分离程序的不同部分（一个接口、编码器/解码器，或者类库，例如
    Tkinter）。模块可以提供控制特定硬件的代码，定义互联网的接口，或者提供常用功能的库；然而，它最重要的功能是控制接口（当导入项目时可用的一组函数、变量和类）。一个实现良好的模块应该有一个清晰的接口，这个接口围绕其使用方式而不是实现方式。这允许你创建多个模块，它们可以轻松地互换和更改，因为它们共享相同的接口。在我们的上一个例子中，想象一下，仅通过支持
    `encryptText(input_text,key)`，如何轻松地更换 `encryptdecrypt` 模块为另一个模块。复杂的功能可以被拆分成更小、更易于管理的块，这些块可以在多个应用程序中重复使用。
- en: Python makes use of classes and modules all the time. Each time you import a
    library, such as `sys` or Tkinter, or convert a value using `value.str()` and
    iterate through a list using `for...in`, you can use them without worrying about
    the details. You don't have to use classes or modules in every bit of code you
    write, but they are useful tools to keep in your programmer's toolbox for times
    when they fit what you are doing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Python 一直使用类和模块。每次你导入一个库，如 `sys` 或 Tkinter，或者使用 `value.str()` 转换值，或者使用 `for...in`
    遍历列表时，你都可以使用它们而不用担心细节。你不需要在编写的每一行代码中使用类或模块，但它们是程序员工具箱中非常有用的工具，在它们适合你所做的事情时可以使用。
- en: We will understand how classes and modules allow us to produce well-structured
    code that is easier to test and maintain by using them in the examples of this
    book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在本书的示例中使用类和模块，来理解它们如何帮助我们产生结构良好的代码，这些代码更容易测试和维护。
- en: Displaying photo information in an application
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中显示照片信息
- en: In this example, we shall create a utility class to handle photos that can be
    used by other applications (as a module) to access photo metadata and display
    preview images easily.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个实用类来处理照片，这个类可以被其他应用程序（作为一个模块）用来轻松访问照片元数据和显示预览图像。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The following script makes use of **Python Image Library** (**PIL**); a compatible
    version for Python 3 is **Pillow**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本使用了 **Python 图像库**（**PIL**）；Python 3 的兼容版本是 **Pillow**。
- en: Pillow has not been included in the Raspbian repository (used by `apt-get`);
    therefore, we will need to install Pillow using a **Python Package Manager** called
    **PIP**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow 没有包含在 Raspbian 存储库中（由 `apt-get` 使用）；因此，我们需要使用名为 **PIP** 的 **Python 包管理器**来安装
    Pillow。
- en: To install packages for Python 3, we will use the Python 3 version of PIP (this
    requires 50 MB of available space).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Python 3 安装包，我们将使用 Python 3 版本的 PIP（这需要 50 MB 的可用空间）。
- en: 'The following commands can be used to install PIP:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以用来安装 PIP：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before you use PIP, ensure that you have installed `libjpeg-dev` to allow Pillow
    to handle JPEG files. You can do this using the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 PIP 之前，请确保你已经安装了 `libjpeg-dev`，以便 Pillow 能够处理 JPEG 文件。你可以使用以下命令来完成此操作：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you can install Pillow using the following PIP command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下 PIP 命令来安装 Pillow：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: PIP also makes it easy to uninstall packages using `uninstall` instead of `install`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: PIP 还使得使用 `uninstall` 而不是 `install` 来卸载包变得容易。
- en: 'Finally, you can confirm that it has installed successfully by running `python3`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过运行 `python3` 来确认它已经成功安装：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should not get any errors and see lots of information about PIL and its
    uses (press *Q* to finish). Check the version installed as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该遇到任何错误，并且会看到很多关于 PIL 及其用途的信息（按 *Q* 键完成）。如下检查安装的版本：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should see `2.7.0` (or similar).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到 `2.7.0`（或类似版本）。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'PIP can also be used with Python 2 by installing pip-2.x using the following
    command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用以下命令安装 pip-2.x 来使用 PIP 与 Python 2 一起使用：
- en: '**sudo apt-get install python-pip**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo apt-get install python-pip**'
- en: Any packages installed using `sudo pip install` will be installed just for Python
    2.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sudo pip install` 安装的任何包都仅适用于 Python 2。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To display photo information in an application, create the following `photohandler.py`
    script:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中显示照片信息，创建以下 `photohandler.py` 脚本：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous code defines our `Photo` class; it is of no use to us until we
    run it in the *There's more…* section and in the next example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了我们的 `Photo` 类；在我们将其在 *还有更多...* 部分和下一个示例中运行之前，对我们来说它没有用处。
- en: How it works…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We define a general class called `Photo`; it contains details about itself and
    provides functions to access **Exchangeable Image File Format** (**EXIF**) information
    and generate a preview image.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个通用的类 `Photo`；它包含有关自身的详细信息，并提供访问 **可交换图像文件格式** （**EXIF**）信息和生成预览图像的功能。
- en: In the `__init__()` function, we set values for our class variables and call
    `self.initImage()`, which will open the image using the `Image()` function from
    the PIL. We then call `self.initExif()` and `self.initDates()` and set a flag
    to indicate whether the file was valid or not. If not valid, the `Image()` function
    would raise an `IOError` exception.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__init__()` 函数中，我们为我们的类变量设置值并调用 `self.initImage()`，这将使用 PIL 的 `Image()` 函数打开图像。然后我们调用
    `self.initExif()` 和 `self.initDates()` 并设置一个标志来指示文件是否有效。如果无效，`Image()` 函数将引发 `IOError`
    异常。
- en: 'The `initExif()` function uses PIL to read the EXIF data from the `img` object,
    as shown in the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`initExif()` 函数使用 PIL 从 `img` 对象中读取 EXIF 数据，如下面的代码片段所示：'
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code is a series of compound statements that result in `self.exif_info`
    being populated with a dictionary of tag names and their related values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一系列复合语句，其结果是 `self.exif_info` 被填充为一个包含标签名称及其相关值的字典。
- en: '`ExifTag.TAGS` is a dictionary that contains a list of possible tag names linked
    with their IDs, as shown in the following code snippet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExifTag.TAGS` 是一个包含可能标签名称列表的字典，这些名称与它们的 ID 相关联，如下面的代码片段所示：'
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `image._getexif()` function returns a dictionary that contains all the
    values set by the camera of the image, each linked to their relevant IDs, as shown
    in the following code snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`image._getexif()` 函数返回一个包含所有由相机设置的值的字典，每个值都与相关的 ID 相关联，如下面的代码片段所示：'
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `for` loop will go through each item in the image''s EXIF value dictionary
    and check for its occurrence in the `ExifTags.TAGS` dictionary; the result will
    get stored in `self.exif_info`. The code for this is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环将遍历图像 EXIF 值字典中的每个项目，并检查其在 `ExifTags.TAGS` 字典中的出现；结果将存储在 `self.exif_info`
    中。此代码如下：'
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, if there are no exceptions, we set a flag to indicate that the EXIF data
    is valid, or if there is no EXIF data, we raise an `AttributeError` exception.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果没有异常，我们设置一个标志来指示 EXIF 数据有效，或者如果没有 EXIF 数据，我们引发 `AttributeError` 异常。
- en: The `initDates()` function allows us to gather all the possible file dates and
    dates from the EXIF data so that we can select one of them as the date we wish
    to use for the file. For example, it allows us to rename all the images to a filename
    in the standard date format. We create a `self.filedates` dictionary that we populate
    with three dates extracted from the EXIF information. We then add the filesystem
    dates (created and modified) just in case no EXIF data is available. The `os`
    module allows us to use `os.path.getctime()` and `os.path.getmtime()` to obtain
    an epoch value of the file creation—it can also be the date and time when the
    file was moved—and file modification—when it was last written to (for example,
    it often refers to the date when the picture was taken). The epoch value is the
    number of seconds since January 1, 1970, but we can use `datetime.datetime.fromtimestamp()`
    to convert it into years, months, days, hours, and seconds. Adding `date()` simply
    limits it to years, months, and days.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`initDates()` 函数使我们能够收集所有可能的文件日期和EXIF数据中的日期，以便我们可以选择其中之一作为我们希望用于文件的日期。例如，它允许我们将所有图像重命名为标准日期格式的文件名。我们创建一个
    `self.filedates` 字典，并用从EXIF信息中提取的三个日期填充它。然后，为了以防没有EXIF数据可用，我们添加文件系统日期（创建和修改）。`os`
    模块允许我们使用 `os.path.getctime()` 和 `os.path.getmtime()` 获取文件的纪元值——它也可以是文件被移动的日期和时间——以及文件修改——最后一次写入时（例如，它通常指的是拍照的日期）。纪元值是自1970年1月1日以来的秒数，但我们可以使用
    `datetime.datetime.fromtimestamp()` 将其转换为年、月、日、小时和秒。添加 `date()` 仅将其限制为年、月和日。'
- en: Now if the `Photo` class was to be used by another module, and we wished to
    know the date of the image that was taken, we could look at the `self.dates` dictionary
    and pick out a suitable date. However, this would require the programmer to know
    how the `self.dates` values are arranged, and if we later changed how they are
    stored, it would break their program. For this reason, it is recommended that
    we access data in a class through access functions so the implementation is independent
    of the interfaces (this process is known as **encapsulation**). We provide a function
    that returns a date when called; the programmer does not need to know that it
    could be one of the five available dates or even that they are stored as epoch
    values. Using a function, we can ensure that the interface will remain the same
    no matter how the data is stored or collected.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果 `Photo` 类要被另一个模块使用，并且我们希望知道拍摄图像的日期，我们可以查看 `self.dates` 字典并选择一个合适的日期。然而，这要求程序员知道
    `self.dates` 值是如何排列的，如果我们后来更改了它们的存储方式，这会破坏他们的程序。因此，建议我们通过访问函数来访问类中的数据，这样实现就独立于接口（这个过程被称为**封装**）。我们提供了一个在调用时返回日期的函数；程序员不需要知道它可能是五个可用日期之一，甚至不需要知道它们是以纪元值存储的。使用函数，我们可以确保无论数据如何存储或收集，接口都将保持不变。
- en: Finally, the last function we want the `Photo` class to provide is `previewPhoto()`.
    This function provides a method to generate a small thumbnail image and save it
    as a **Portable Pixmap Format** (**PPM**) file. As we will discover in a moment,
    Tkinter allows us to place images on its `Canvas` widget, but unfortunately, it
    does not support JPGs (and only supports GIF or PPM) directly. Therefore, we simply
    save a small copy of the image we want to display in the PPM format—with the added
    caveat that the image pallet must be converted to RGB too—and then get Tkinter
    to load it onto the `Canvas` when required.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望 `Photo` 类提供的最后一个函数是 `previewPhoto()`。这个函数提供了一个生成小缩略图并将其保存为**便携式像素格式**（**PPM**）文件的方法。正如我们很快就会发现的，Tkinter
    允许我们在其 `Canvas` 小部件上放置图像，但遗憾的是，它不支持JPG（只支持GIF或PPM）。因此，我们只需将我们想要显示的图像的小副本保存为PPM格式——附带一个额外的注意事项，即图像调色板也必须转换为RGB——然后当需要时让Tkinter将其加载到
    `Canvas` 上。
- en: 'To summarize, the `Photo` class we have created is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们创建的 `Photo` 类如下：
- en: '| Operations | Description |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 描述 |'
- en: '| --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__init__(self,filename)` | This is the object initialization function |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `__init__(self,filename)` | 这是对象初始化函数 |'
- en: '| `initImage(self)` | This returns `img`, a PIL-type image object |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `initImage(self)` | 这返回 `img`，一个PIL类型的图像对象 |'
- en: '| `initExif(self,image)` | This extracts all the EXIF information, if any is
    present |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `initExif(self,image)` | 这将提取所有存在的EXIF信息 |'
- en: '| `initDates(self)` | This creates a dictionary of all the dates available
    from the file and photo information |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `initDates(self)` | 这将创建一个包含文件和照片信息中所有可用日期的字典 |'
- en: '| `getDate(self)` | This returns a string of the date when the photo was taken/created
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `getDate(self)` | 这返回照片拍摄/创建时的日期字符串 |'
- en: '| `previewPhoto(self)` | This returns a string of the filename of the previewed
    thumbnail |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `previewPhoto(self)` | 这返回预览缩略图的文件名字符串 |'
- en: 'The properties and their respective descriptions are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 属性及其相应描述如下：
- en: '| Properties | Description |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `self.filename` | The filename of the photo |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `self.filename` | 照片的文件名 |'
- en: '| `self.filevalid` | This is set to `True` if the file is opened successfully
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `self.filevalid` | 如果文件成功打开，则设置为 `True` |'
- en: '| `self.exifvalid` | This is set to `True` if the photo contains EXIF information
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `self.exifvalid` | 如果照片包含 EXIF 信息，则设置为 `True` |'
- en: '| `self.exif_info` | This contains the EXIF information from the photo |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `self.exif_info` | 这包含来自照片的 EXIF 信息 |'
- en: '| `self.filedates` | This contains a dictionary of the available dates from
    the file and photo information |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `self.filedates` | 这包含来自文件和照片信息的可用日期的字典 |'
- en: To test the new class, we will create some test code to confirm that everything
    is working as we expect; see the following section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试新类，我们将创建一些测试代码来确认一切是否按预期工作；请参阅以下部分。
- en: There's more…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We previously created the `Photo` class. Now we can add some test code to our
    module to ensure that it functions as we expect. We can use the `__name__ ="__main__"`
    attribute as before to detect whether the module has been run directly or not.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建了 `Photo` 类。现在我们可以在模块中添加一些测试代码，以确保它按预期工作。我们可以像之前一样使用 `__name__ ="__main__"`
    属性来检测模块是否被直接运行。
- en: 'We can add the subsequent section of code at the end of the `photohandler.py`
    script to produce the following test application, which looks as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `photohandler.py` 脚本的末尾添加后续代码部分，以生成以下测试应用程序，其外观如下：
- en: '![There''s more…](img/6623OT_03_5.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/6623OT_03_5.jpg)'
- en: The Photo View Demo application
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 照片查看演示应用程序
- en: 'Add the following code at the end of `photohandler.py`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `photohandler.py` 的末尾添加以下代码：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The previous test code will run the `main()` function, which takes the filename
    of a photo to use and create a new `Photo` object called `viewPhoto`. If `viewPhoto`
    is opened successfully, we will call `dispPreview()` to display the image and
    its details.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试代码将运行 `main()` 函数，该函数接受要使用的照片文件名并创建一个名为 `viewPhoto` 的新 `Photo` 对象。如果 `viewPhoto`
    打开成功，我们将调用 `dispPreview()` 来显示图像及其详细信息。
- en: 'The `dispPreview()` function creates four Tkinter widgets to be displayed:
    a `Canvas` to load the thumbnail image, a `Listbox` widget to display the photo
    information, and two scroll bars to control the `Listbox`. First, we create a
    `Canvas` widget the size of the thumbnail image (`previewsize`).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispPreview()` 函数创建四个 Tkinter 小部件以供显示：一个用于加载缩略图的 `Canvas`，一个用于显示照片信息的 `Listbox`
    小部件，以及两个用于控制 `Listbox` 的滚动条。首先，我们创建一个大小与缩略图相同的 `Canvas` 小部件（`previewsize`）。'
- en: Next, we create `photoInfo`, which will be our `listvariable` parameter linked
    to the `Listbox` widget. Since Tkinter doesn't provide a `ListVar()` function
    to create a suitable item, we use the generic type `TK.Variable()` and then ensure
    we convert it to a tuple type before setting the value. The `Listbox` widget gets
    added; we need to make sure that the `listvariable` parameter is set to `photoInfo`
    and also set the font to `monospace`. This will allow us to line up our data values
    using spaces, as `monospace` is a fixed width font, so each character takes up
    the same width as any other.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建 `photoInfo`，它将成为我们的 `listvariable` 参数，并将其链接到 `Listbox` 小部件。由于 Tkinter
    不提供 `ListVar()` 函数来创建合适的项，我们使用通用的 `TK.Variable()` 类型，并在设置值之前确保将其转换为元组类型。我们将 `Listbox`
    小部件添加进去；我们需要确保 `listvariable` 参数设置为 `photoInfo`，并且设置字体为 `monospace`。这将允许我们使用空格对齐数据值，因为
    `monospace` 是固定宽度字体，所以每个字符占据的宽度与其他任何字符相同。
- en: 'We define the two scroll bars, linking them to the `Listbox` widget, by setting
    the `Scrollbar` command parameters for vertical and horizontal scroll bars to
    `lbPhotoInfo.yview` and `lbPhotoInfo.xview`. Then, we adjust the parameters of
    the `Listbox` using the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过设置垂直和水平滚动条的 `Scrollbar` 命令参数为 `lbPhotoInfo.yview` 和 `lbPhotoInfo.xview`
    来定义两个滚动条，并将它们链接到 `Listbox` 小部件。然后，我们使用以下命令调整 `Listbox` 的参数：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `configure` command allows us to add or change the widget's parameters after
    it has been created, in this case linking the two scroll bars so the `Listbox`
    widget can also control them if the user scrolls within the list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure`命令允许我们在创建小部件后添加或更改其参数，在这种情况下，将两个滚动条链接起来，以便`Listbox`小部件也可以在用户在列表中滚动时控制它们。'
- en: As before, we make use of the grid layout to ensure that the `Listbox` widget
    has the two scroll bars placed correctly next to it and the `Canvas` widget is
    to the left of the `Listbox` widget.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，我们使用网格布局来确保`Listbox`小部件旁边正确放置两个滚动条，而`Canvas`小部件位于`Listbox`小部件的左侧。
- en: 'We now use the `Photo` object to create the `preview.ppm` thumbnail file (using
    the `aPhoto.previewPhoto()` function) and create a `TK.PhotoImage` object that
    can then be added to the `Canvas` widget with the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`Photo`对象来创建`preview.ppm`缩略图文件（使用`aPhoto.previewPhoto()`函数），并创建一个`TK.PhotoImage`对象，然后可以使用以下命令将其添加到`Canvas`小部件中：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, we use the date information that the `Photo` class gathers and the
    EXIF information (ensuring it is valid first) to populate the `Listbox` widget.
    We do this by converting each item into a list of strings that are spaced out
    using `.ljust(25)`—it adds a left justification to the name and pads it out to
    make the string 25 characters wide. Once we have the list, we convert it to a
    tuple type and set the `listvariable` (`photoInfo`) parameter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`Photo`类收集的日期信息和EXIF信息（确保它有效）来填充`Listbox`小部件。我们通过将每个项目转换为使用`.ljust(25)`分隔的字符串列表来实现这一点——它为名称添加左对齐并填充到25个字符宽。一旦我们有了列表，我们就将其转换为元组类型并设置`listvariable`（`photoInfo`）参数。
- en: As always, we call `app.mainloop()` to start the monitoring for events to respond
    to.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们调用`app.mainloop()`来开始对事件的监控以进行响应。
- en: Organizing your photos automatically
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动整理您的照片
- en: 'Now that we have a class that allows us to gather information about photos,
    we can apply this information to perform useful tasks. In this case, we will use
    the file information to automatically organize a folder full of photos into a
    subset of folders based on the dates the photos were taken on. The following screenshot
    shows the output of the script:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以让我们收集照片信息的类，我们可以将这些信息应用于执行有用的任务。在这种情况下，我们将使用文件信息来自动将一个装满照片的文件夹组织成基于拍摄日期的子文件夹集合。以下截图显示了脚本的输出：
- en: '![Organizing your photos automatically](img/6623OT_03_6.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![自动整理您的照片](img/6623OT_03_6.jpg)'
- en: The application will use the photo's information to sort pictures into folders
    by the date on which they were taken
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将使用照片信息按拍摄日期将图片排序到文件夹中
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a selection of photos placed in a folder on the Raspberry Pi.
    Alternatively, you can insert a USB memory stick or a card reader with photos
    on it—they will be located in `/mnt/`. However, please make sure you test the
    scripts with a copy of your photos first, just in case there are any problems.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Raspberry Pi上的一个文件夹中放置一组照片。或者，您可以将带有照片的USB闪存盘或卡读卡器插入——它们将位于`/mnt/`。但是，请确保您首先使用照片的副本测试脚本，以防万一有任何问题。
- en: How to do it…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create the following script in `filehandler.py` to automatically organize your
    photos:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`filehandler.py`文件中创建以下脚本来自动整理您的照片：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We shall make a class called `FileList`; it will make use of the `Photo` class
    to manage the photos within a specific folder. There are two main steps for this:
    we first need to find all the images within the folder, and then generate a list
    containing both the filename and the photo date. We will use this information
    to generate new subfolders and move the photos into these folders.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`FileList`的类；它将使用`Photo`类来管理特定文件夹内的照片。为此有两个主要步骤：我们首先需要找到文件夹内的所有图像，然后生成一个包含文件名和照片日期的列表。我们将使用这些信息来生成新的子文件夹并将照片移动到这些文件夹中。
- en: When we create the `FileList` object, we will create the list using `listFileDates()`.
    We will then confirm that the folder provided is valid and use `os.listdir` to
    obtain the full list of files within the directory. We will check that each file
    is a `.jpg` file and obtain each photo's date (using the function defined in the
    `Photo` class). Next, we will add the filename and date as a tuple to the `self.photo_namedates`
    list.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`FileList`对象时，我们将使用`listFileDates()`创建列表。然后我们将确认提供的文件夹是有效的，并使用`os.listdir`来获取目录中的文件完整列表。我们将检查每个文件是否是`.jpg`文件，并获取每张照片的日期（使用`Photo`类中定义的函数）。接下来，我们将文件名和日期作为一个元组添加到`self.photo_namedates`列表中。
- en: Finally, we will use the built-in `sorted` function to place all the files in
    order of their date. While we don't need to do this here, this function would
    make it easier to remove duplicate dates if we were to use this module elsewhere.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用内置的`sorted`函数按日期顺序排列所有文件。虽然我们在这里不需要这样做，但这个函数如果我们在其他地方使用此模块，将更容易删除重复的日期。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `sorted` function requires the list to be sorted, and in this case, we want
    to sort it by the `date` values.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted`函数需要排序的列表，在这种情况下，我们希望按`date`值排序。'
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will substitute `date[DATE]` with `lambda date:` as the value to sort by.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`date[DATE]`替换为`lambda date:`作为排序的值。
- en: Once the `FileList` object has been initialized, we can use it by calling `genFolders()`.
    First, we convert the date text into a suitable format for our folders (YYYYMMDD),
    allowing our folders to be easily sorted in order of their date. Next, it will
    create the folders within the current directory if they don't already exist. Finally,
    it will move each of the files into the required subfolder.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了`FileList`对象，我们就可以通过调用`genFolders()`来使用它。首先，我们将日期文本转换为适合我们文件夹的格式（YYYYMMDD），以便我们的文件夹可以按日期顺序排序。接下来，如果它们不存在，它将在当前目录中创建文件夹。最后，它将每个文件移动到所需的子文件夹中。
- en: 'We end up with our `FileList` class that is ready to be tested:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到一个准备测试的`FileList`类：
- en: '| Operations | Description |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 描述 |'
- en: '| --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__init__(self,folder)` | This is the object initialization function |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `__init__(self,folder)` | 这是对象初始化函数 |'
- en: '| `getPhotoNamedates(self)` | This returns a list of the filenames of the dates
    of the photos |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `getPhotoNamedates(self)` | 这个函数返回照片的文件名和日期列表 |'
- en: '| `listFileDates(self)` | This creates a list of the filenames and dates of
    the photos in the folder |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `listFileDates(self)` | 这个函数创建文件夹中照片的文件名和日期列表 |'
- en: '| `genFolders(self)` | This creates new folders based on a photo''s date and
    moves the files into them |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `genFolders(self)` | 这个函数根据照片的日期创建新文件夹，并将文件移动到其中 |'
- en: 'The properties are listed as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 属性如下列出：
- en: '| Properties | Description |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `self.folder` | The folder we are working with |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `self.folder` | 我们正在处理的文件夹 |'
- en: '| `self.photo_namedates` | This contains a list of the filenames and dates
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `self.photo_namedates` | 这包含了一个文件名和日期列表 |'
- en: 'The `FileList` class encapsulates all the functions and the relevant data together,
    keeping everything in one logical place:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileList`类封装了所有函数和相关的数据，将所有内容保持在逻辑上的一致位置：'
- en: '![How it works…](img/6623OT_03_7.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/6623OT_03_7.jpg)'
- en: Tkinter filediaglog.askdirectory() is used to select the photo directory
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Tkinter的filediaglog.askdirectory()选择照片目录
- en: To test this, we use the Tkinter `filedialog.askdirectory()` widget to allow
    us to select a target directory of pictures. We use `app.withdrawn()` to hide
    the main Tkinter window since it isn't required this time. We just need to create
    a new `FileList` object and then call `genFolders()` to move all our photos to
    new locations!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个功能，我们使用Tkinter的`filedialog.askdirectory()`小部件来允许我们选择一个目标图片目录。我们使用`app.withdrawn()`来隐藏主Tkinter窗口，因为这次不需要它。我们只需要创建一个新的`FileList`对象，然后调用`genFolders()`来将所有我们的照片移动到新的位置！
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Two additional flags have been defined in this script that provide an extra
    control for testing. `DEBUG` allows us to enable or disable extra debugging messages
    by setting them to either `True` or `False`. Furthermore, from this, `FOLDERSONLY`
    when set to `True` only generates the folders and doesn't move the files (this
    is helpful for testing whether the new subfolders are correct).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中定义了两个额外的标志，提供了额外的测试控制。`DEBUG`允许我们通过设置为`True`或`False`来启用或禁用额外的调试消息。此外，当设置为`True`时，`FOLDERSONLY`只生成文件夹，不移动文件（这对于测试新子文件夹是否正确非常有用）。
- en: Once you have run the script, you can check if all the folders have been created
    correctly. Finally, change `FOLDERSONLY` to `True`, and your program will automatically
    move and organize your photos according to their dates the next time. It is recommended
    that you only run this on a copy of your photos, just in case you get an error.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行了脚本，你可以检查所有文件夹是否已正确创建。最后，将`FOLDERSONLY`改为`True`，下次程序将自动根据照片的日期移动和组织你的照片。建议你只在照片的副本上运行此操作，以防出现错误。
