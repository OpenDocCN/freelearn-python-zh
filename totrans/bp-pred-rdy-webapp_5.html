<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-127"><a id="_idTextAnchor138"/>5</h1>
<h1 id="_idParaDest-128"><a id="_idTextAnchor139"/>Building the Single-Page App</h1>
<p>In the previous chapter, we extended a basic React app with the tooling and setup that we require to build user interfaces. This means that in this chapter, we can focus on the functionality that will make up our single-page app. Specifically, we’ll add functionality that allows users to authenticate, manage their passwords, and manage their to-dos.</p>
<p>The user interface and functionality to manage user authentication and passwords is useful to any app and could be used directly in yours. While the to-do user interface is unlikely to match what you require in your own apps, the techniques will be applicable.</p>
<p>So, in this chapter, we will cover the following topics:</p>
<ul>
<li>Adding navigation</li>
<li>Adding user authentication pages </li>
<li>Adding password management pages</li>
<li>Adding to-do pages</li>
</ul>
<h1 id="_idParaDest-129"><a id="_idTextAnchor140"/>Technical requirements</h1>
<p>The following additional folders are required in this chapter and should be created:</p>
<pre class="source-code">
tozo
└── frontend
    └── src
        └── pages</pre>
<p>To follow the development in this chapter using the companion repository, <a href="https://github.com/pgjones/tozo">https://github.com/pgjones/tozo</a>, see the commits between the tags <code>r1-ch5-start</code> and <code>r1-ch5-end</code>.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor141"/>Adding navigation</h1>
<p>The app we are<a id="_idIndexMarker315"/> building needs to allow logged-in users to <a id="_idIndexMarker316"/>navigate to the full to-do list, the page allowing them to change their password, and allow them to log out. For logged-out users, they need to navigate between login, register, and reset password pages. </p>
<p>Focusing on the needs of logged-in users, the Material Design system includes an app bar that exists at the top of the page. This will allow for links to the full to-do list (home page) and an account menu to change their password and log out.</p>
<p class="callout-heading">A more complex navigation</p>
<p class="callout">Your app probably has more pages than<a id="_idIndexMarker317"/> the one we are building in this book. This means the navigation system needs to be able to link to more pages. While the account menu can be extended with more links relating to the user, it is not a good location for other links. Instead, a drawer is the best solution. Drawers slide in from the left and can have as many links as required.</p>
<p>The account menu needs to allow users to log out, which means it needs to query the backend via a mutation and then update the app’s local authentication context (state). To do so, the following code should be added to <em class="italic">frontend/src/components/AccountMenu.tsx</em>:</p>
<pre class="source-code">
import axios from "axios"; 
import { useContext } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { AuthContext } from "src/AuthContext";
import { useMutation } from "src/query";
const useLogout = () =&gt; {
  const { setAuthenticated } = useContext(AuthContext);
  const queryClient = useQueryClient();
  const { mutate: logout } = useMutation(
    async () =&gt; await axios.delete("/sessions/"),
    { 
      onSuccess: () =&gt; {
        setAuthenticated(false);
        queryClient.clear();
      },
    },
  );
  return logout;
};</pre>
<p>This code provides a <code>logout</code> function, which, when called, triggers the mutation thereby sending a <code>DELETE /sessions/</code> request. If this request succeeds, the user is logged out, the local <a id="_idIndexMarker318"/>authentication context is set to <code>false</code>, and the data stored by <code>React-Query</code> is cleared. If the request fails, nothing will change, prompting <a id="_idIndexMarker319"/>the user to try again.</p>
<p>With this functionality in place, we now need to add the styled menu. We can do this by adding the following to the existing code in <em class="italic">frontend/src/components/AccountMenu.tsx</em>:</p>
<pre class="source-code">
import Divider from "@mui/material/Divider";
import IconButton from "@mui/material/IconButton";
import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import AccountCircle from "@mui/icons-material/AccountCircle";
import React, { useState } from "react";
import { Link } from "react-router-dom";
const AccountMenu = () =&gt; {
  const logout = useLogout();
  const [anchorEl, setAnchorEl] = useState&lt;null | HTMLElement&gt;(null);
  const onMenuOpen = (event: React.MouseEvent&lt;HTMLElement&gt;) =&gt; 
    setAnchorEl(event.currentTarget);
  const onMenuClose = () =&gt; setAnchorEl(null);
  return (
    &lt;&gt;
      &lt;IconButton
        color="inherit"
        onClick={onMenuOpen}
      &gt;
        &lt;AccountCircle /&gt;
      &lt;/IconButton&gt;
      &lt;Menu
        anchorEl={anchorEl}
        anchorOrigin={{ horizontal: "right", vertical: "top" }}
        keepMounted
        onClose={onMenuClose}
        open={Boolean(anchorEl)}
        transformOrigin={{           horizontal: "right", vertical: "top"         }}
      &gt;
        &lt;MenuItem 
          component={Link} 
          onClick={onMenuClose} 
          to="/change-password/"
        &gt;
          Change password
        &lt;/MenuItem&gt;
        &lt;Divider /&gt;
        &lt;MenuItem onClick={() =&gt; {logout(); onMenuClose();}}&gt;
          Logout
        &lt;/MenuItem&gt;
      &lt;/Menu&gt;
    &lt;/&gt;
  );
};
export default AccountMenu;</pre>
<p>This is standard <a id="_idIndexMarker320"/>MUI code for a menu that opens when the <code>IconButton</code> component is clicked.</p>
<p>We can now add the app bar itself, including a link to the home page, and the account menu if the user is logged in (authenticated) by adding the following to <em class="italic">frontend/src/components/TopBar.tsx</em>:</p>
<pre class="source-code">
import AppBar from "@mui/material/AppBar";
import Box from "@mui/material/Box";
import Button from "@mui/material/Button";
import Toolbar from "@mui/material/Toolbar";
import React, { useContext } from "react";
import { Link } from "react-router-dom";
import { AuthContext } from "src/AuthContext";
import AccountMenu from "src/components/AccountMenu";
const sxToolbar = {
<strong class="bold">  paddingLeft: "env(safe-area-inset-left)",</strong>
<strong class="bold">  paddingRight: "env(safe-area-inset-right)",</strong>
<strong class="bold">  paddingTop: "env(safe-area-inset-top)",</strong>
}
const TopBar = () =&gt; {
  const { authenticated } = useContext(AuthContext);
  return (
    &lt;&gt;
      &lt;AppBar position="fixed"&gt;
        &lt;Toolbar sx={sxToolbar}&gt;
          &lt;Box sx={{ flexGrow: 1 }}&gt;
            &lt;Button color="inherit" component={Link} to="/"&gt;
              Tozo
            &lt;/Button&gt;
          &lt;/Box&gt;
          {authenticated ? &lt;AccountMenu /&gt; : null}
        &lt;/Toolbar&gt;
      &lt;/AppBar&gt;
      &lt;Toolbar sx={{ ...sxToolbar, marginBottom: 2 }} /&gt;
    &lt;/&gt;
  );
};
export default TopBar;</pre>
<p>The additional <a id="_idIndexMarker321"/>padding styling (highlighted) that utilizes the <code>safe-area-inset</code> is required for the app bar to look correct on devices with a notch, such as the iPhone X. </p>
<p>The <code>TopBar</code> should be rendered in the <code>Router</code> within the <code>BrowserRouter,</code> by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import TopBar from "src/components/TopBar";</strong>
 
const Router = () =&gt; (
  &lt;BrowserRouter&gt; 
    &lt;ScrollToTop /&gt; 
<strong class="bold">    &lt;TopBar /&gt;</strong>
    &lt;Routes&gt; 
      {/* Place routes here */} 
    &lt;/Routes&gt; 
  &lt;/BrowserRouter&gt;
);</pre>
<p>The highlighted<a id="_idIndexMarker322"/> lines should be added to the existing code.</p>
<p>Once rendered, the app bar should look like <em class="italic">Figure 5.1</em>:</p>
<div><div><img alt="Figure 5.1: The app bar as displayed in a mobile browser " height="200" src="img/B18727_05_01.jpg" width="606"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: The app bar as displayed in a mobile browser</p>
<p>With the navigation complete, we can start adding the pages; we will begin by allowing users to register and log in.</p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor142"/>Adding user authentication pages</h1>
<p>On the first visit to<a id="_idIndexMarker323"/> our app, users will<a id="_idIndexMarker324"/> need to register, confirm their email, and log in. Whereas, on subsequent visits, they’ll just need to log in. Each of these actions will need to be a page in our app.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor143"/>Registration</h2>
<p>The first thing a new <a id="_idIndexMarker325"/>user needs to do when visiting our app is to register, so we’ll start by adding a registration page. To register, the user will need to enter their email and a password. Once the user has supplied these, we’ll use the members API to create the user and then redirect the user to the login page or, if the API call fails, display the relevant error. </p>
<p>We’ll start by adding this logic as a custom <code>useRegister</code> hook to <em class="italic">frontend/src/pages/Register.tsx</em>:</p>
<pre class="source-code">
import axios from "axios"; 
import { FormikHelpers } from "formik";
import { useContext } from "react";
import { useNavigate } from "react-router";
import { ToastContext } from "src/ToastContext";
import { useMutation } from "src/query";
interface IForm {
  email: string;
  password: string;
}
const useRegister = () =&gt; {
  const navigate = useNavigate();
  const { addToast } = useContext(ToastContext);
  const { mutateAsync: register } = useMutation(
    async (data: IForm) =&gt; await axios.post("/members/", data),
  );
  return async (
    data: IForm,
    { setFieldError }: FormikHelpers&lt;IForm&gt;,
  ) =&gt; {
    try {
      await register(data);
      addToast("Registered", "success");
      navigate("/login/", { state: { email: data.email } });
    } catch (error: any) {
<strong class="bold">      if (</strong>
<strong class="bold">        error.response?.status === 400 &amp;&amp;</strong>
<strong class="bold">        error.response?.data.code === "WEAK_PASSWORD"</strong>
<strong class="bold">      ) {</strong>
<strong class="bold">        setFieldError("password", "Password is too weak");</strong>
      } else {
        addToast("Try again", "error");
      }
    }
  };
};</pre>
<p>The function returned by the <code>useRegister</code> hook is designed to be used as a <code>Formik</code> <code>onSubmit</code> prop. This <a id="_idIndexMarker326"/>allows the function to add a specific error to the password field if the response from the backend indicates the password is too weak (as highlighted). Otherwise, if the registration succeeds, the app navigates to the login page.</p>
<p class="callout-heading">Automatically logging in on registration</p>
<p class="callout">The flow we’ve implemented <a id="_idIndexMarker327"/>directs the user to the login page where they log in after registering, rather than automatically logging them in. While this isn’t the best user experience, it is done to mitigate account enumeration, and hence is a safe default. However, you may decide for your app that the user experience is more important. If so, the backend route will need to log the user in, and this page should direct the user to the home page after registering.</p>
<p>We now need to provide<a id="_idIndexMarker328"/> input fields for the user to enter their email and a strong password, which we can ensure by showing the password strength. The fields will be validated to inform the user of any mistakes and use the correct autocomplete values. The autocomplete values should encourage the browser to do most of the work for the user (e.g., by filling in their email address). </p>
<p>The registration page is therefore extended by adding the following code to the existing code in <em class="italic">frontend/src/pages/Register.tsx</em>:</p>
<pre class="source-code">
import { Form, Formik } from "formik";
import { useLocation } from "react-router-dom"; 
import * as yup from "yup";
 
import EmailField from "src/components/EmailField";
import FormActions from "src/components/FormActions";
import LazyPasswordWithStrengthField from "src/components/LazyPasswordWithStrengthField";
import Title from "src/components/Title";
const validationSchema = yup.object({
  email: yup.string().email("Email invalid").required("Required"),
  password: yup.string().required("Required"),
});
 
const Register = () =&gt; {
  const location = useLocation();
  const onSubmit = useRegister();
  return (
    &lt;&gt;
      &lt;Title title="Register" /&gt;
      &lt;Formik&lt;IForm&gt;
        initialValues={{
          email: (location.state as any)?.email ?? "",
          password: "",
        }}
        onSubmit={onSubmit}
        validationSchema={validationSchema}
      &gt;
        {({ dirty, isSubmitting, values }) =&gt; (
          &lt;Form&gt;
          &lt;EmailField 
            fullWidth label="Email" name="email" required 
          /&gt;
            &lt;LazyPasswordWithStrengthField
              autoComplete="new-password"
              fullWidth
              label="Password"
              name="password"
              required
            /&gt;
            &lt;FormActions
              disabled={!dirty}
              isSubmitting={isSubmitting}
              label="Register"
              links={[
                {label: "Login", to: "/login/", state: { email:                   values.email }},
                {label: "Reset password", to: "/forgotten-                  password/", state: { email: values.email }},
              ]}
            /&gt;
          &lt;/Form&gt;
        )}
      &lt;/Formik&gt;
    &lt;/&gt;
  );
};
export default Register;</pre>
<p>As users often forget whether<a id="_idIndexMarker329"/> they have already registered, we’ve made it easier to navigate to the login and reset password pages via the <code>FormActions</code> links. In addition, as the user navigates between these pages, any value in the email field is persisted. This saves the user from having to type it in again, hence leading to a better user experience. This is done via the <code>location.state</code>, with the <code>useLocation</code> hook getting any current value, and the <code>state</code> part of the <code>links</code> prop of the <code>FormActions</code> component setting it. </p>
<p>Then we can add the page to the routing by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import { Route } from "react-router-dom";</strong>
<strong class="bold">import Register from "src/pages/Register";</strong>
const Router = () =&gt; (
  &lt;BrowserRouter&gt;  
    &lt;ScrollToTop /&gt;  
    &lt;TopBar /&gt; 
    &lt;Routes&gt;  
<strong class="bold">      &lt;Route path="/register/" element={&lt;Register /&gt;} /&gt;</strong> 
    &lt;/Routes&gt;  
  &lt;/BrowserRouter&gt;
);</pre>
<p>The highlighted lines should <a id="_idIndexMarker330"/>be added to the existing code.</p>
<p>The completed <strong class="bold">Register</strong> page should look like <em class="italic">Figure 5.2</em>:</p>
<div><div><img alt="Figure 5.2: The registration page  " height="546" src="img/B18727_05_02.jpg" width="666"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: The registration page </p>
<p>With users now able<a id="_idIndexMarker331"/> to register, they’ll next need to confirm their email.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor144"/>Email confirmation</h2>
<p>On registration, users are<a id="_idIndexMarker332"/> sent an email with a link back to our app. Within the link is a token that identifies the user. By following the link, the user passes the token to us and proves that they are in control of the email address. Hence, we need a page that, when visited, sends the token to the backend and displays the result.</p>
<p>The link has the form <code>/confirm-email/:token/</code> where <code>:token</code> is the actual user’s token (e.g., <code>/confirm-email/abcd/</code>). Therefore, we can extract the token using a route parameter by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import ConfirmEmail from "src/pages/ConfirmEmail";</strong>
const Router = () =&gt; (
  &lt;BrowserRouter&gt;  
    &lt;ScrollToTop /&gt;  
    &lt;TopBar /&gt; 
    &lt;Routes&gt;  
      &lt;Route path="/register/" element={&lt;Register /&gt;} /&gt;
<strong class="bold">      &lt;Route </strong>
<strong class="bold">        path="/confirm-email/:token/" element={&lt;ConfirmEmail /&gt;} </strong>
<strong class="bold">      /&gt; </strong>
    &lt;/Routes&gt;  
  &lt;/BrowserRouter&gt;
);</pre>
<p>The highlighted lines should be added to the existing code.</p>
<p>We can now build the <code>ConfirmEmail</code> page and utilize a <code>useParam</code> hook to extract the token from the path. To<a id="_idIndexMarker333"/> do so, the following code should be added to <em class="italic">frontend/src/pages/ConfirmEmail.tsx</em>:</p>
<pre class="source-code">
import LinearProgress from "@mui/material/LinearProgress";
import axios from "axios";
import { useContext } from "react";
import { useParams } from "react-router";
import { Navigate } from "react-router-dom";
 
import { useQuery } from "src/query";
import { ToastContext } from "src/ToastContext";
 
interface IParams {
  token?: string;
}
 
const ConfirmEmail = () =&gt; {
  const { addToast } = useContext(ToastContext);
<strong class="bold">  const params = useParams() as IParams;</strong>
<strong class="bold">  const token = params.token ?? "";</strong>
  const { isLoading } = useQuery(
    ["Email"],
    async () =&gt; await axios.put("/members/email/", { token }),
    {
      onError: (error: any) =&gt; {
        if (error.response?.status === 400) {
          if (error.response?.data.code === "TOKEN_INVALID") {
            addToast("Invalid token", "error");
          } else if (error.response?.data.code === "TOKEN_            EXPIRED"){
            addToast("Token expired", "error");
          }
        } else {
          addToast("Try again", "error");
        }
      },
      onSuccess: () =&gt; addToast("Thanks", "success"),
    },
  );
 
  if (isLoading) {
    return  &lt;LinearProgress /&gt;;
  } else {
    return &lt;Navigate to="/" /&gt;;
  }
};
 
export default ConfirmEmail;</pre>
<p>The highlighted<a id="_idIndexMarker334"/> lines show the token parameter being extracted from the path. </p>
<p>To ensure that the user knows that the app is working, a <code>LinearProgress</code> bar is shown while the frontend waits for the backend to respond; we can see this in <em class="italic">Figure 5.3</em>:</p>
<div><div><img alt="Figure 5.3: The Confirm Email page showing a LinearProgress bar to indicate processing is in progress " height="153" src="img/B18727_05_03.jpg" width="587"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: The Confirm Email page showing a LinearProgress bar to indicate processing is in progress</p>
<p>Finally, after registering and <a id="_idIndexMarker335"/>confirming their email, the user will need to log in.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor145"/>Logging in</h2>
<p>Users will need to log in to<a id="_idIndexMarker336"/> see and interact with their to-dos. To do so, the user will need to enter their email and a password. Once the user has supplied these, we’ll use the session API to create a session. If the login is successful, the user should then be redirected to the home page or to the page given by the <code>from</code> state if it is present. The <code>from</code> state redirects the user to the page they attempted to view without being logged in. </p>
<p>To do this, we’ll start by adding the following logic to <em class="italic">frontend/src/pages/Login.tsx</em>:</p>
<pre class="source-code">
import axios from "axios"; 
import { FormikHelpers } from "formik";
import { useContext } from "react";
import { useLocation, useNavigate } from "react-router";
import { AuthContext } from "src/AuthContext";
import { ToastContext } from "src/ToastContext";
import { useMutation } from "src/query";
interface IForm {
  email: string;
  password: string;
}
const useLogin = () =&gt; {
  const location = useLocation();
  const navigate = useNavigate();
  const { addToast } = useContext(ToastContext);
  const { setAuthenticated } = useContext(AuthContext);
  const { mutateAsync: login } = useMutation(
    async (data: IForm) =&gt; await axios.post("/sessions/",      data),
  );
  return async (
    data: IForm,
    { setFieldError }: FormikHelpers&lt;IForm&gt;,
  ) =&gt; {
    try {
      await login(data);
      setAuthenticated(true);
      navigate((location.state as any)?.from ?? "/");
    } catch (error: any) {
      if (error.response?.status === 401) {
        setFieldError("email", "Invalid credentials");
        setFieldError("password", "Invalid credentials");
      } else {
        addToast("Try again", "error");
      }
    }
  };
};</pre>
<p>With the login logic defined, we<a id="_idIndexMarker337"/> can now add the UI elements. This requires a form containing an email and password input, which should be added to the existing code in <em class="italic">frontend/src/pages/Login.tsx</em>:</p>
<pre class="source-code">
import { Form, Formik } from "formik"; 
import * as yup from "yup";
 
import EmailField from "src/components/EmailField";
import FormActions from "src/components/FormActions";
import PasswordField from "src/components/PasswordField";
import Title from "src/components/Title";
const validationSchema = yup.object({
  email: yup.string().email("Email invalid").required("Required"),
  password: yup.string().required("Required"),
});
 
const Login = () =&gt; {
  const onSubmit= useLogin();
  const location = useLocation();
  return (
    &lt;&gt;
      &lt;Title title="Login" /&gt;
      &lt;Formik&lt;IForm&gt;
        initialValues={{
          email: (location.state as any)?.email ?? "",
          password: "",
        }}
        onSubmit={onSubmit}
        validationSchema={validationSchema}
      &gt;
        {({ <strong class="bold">dirty</strong>, isSubmitting, values }) =&gt; (
          &lt;Form&gt;
            &lt;EmailField
              fullWidth label="Email" name="email" required
            /&gt;
            &lt;PasswordField
              autoComplete="password"
              fullWidth
              label="Password"
              name="password"
              required
            /&gt;
            &lt;FormActions
<strong class="bold">              disabled={!dirty}</strong>
              isSubmitting={isSubmitting}
              label="Login"
              links={[
                {label: "Reset password", to: "/forgotten-                  password/", state: { email: values.email }},
                {label: "Register", to: "/register/", state: {                   email: values.email }},
              ]}
            /&gt;
          &lt;/Form&gt;
        )}
      &lt;/Formik&gt;
    &lt;/&gt;
  );
};
export default Login;</pre>
<p>The highlighted code<a id="_idIndexMarker338"/> shows that the form submission is disabled until the form is dirty. This helps the user as it ensures that they can’t submit the form until they have made changes to it. This is a pattern we’ll use on all of the forms.</p>
<p>We can now add the page to the routing by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import Login from "src/pages/Login";</strong>
const Router = () =&gt; ( 
  &lt;BrowserRouter&gt;   
    &lt;ScrollToTop /&gt;   
    &lt;TopBar /&gt;  
    &lt;Routes&gt;   
      &lt;Route path="/register/" element={&lt;Register /&gt;} /&gt; 
      &lt;Route  
        path="/confirm-email/:token/"        element={&lt;ConfirmEmail /&gt;}  
      /&gt;  
<strong class="bold">      &lt;Route path="/login/" element={&lt;Login /&gt;} /&gt;</strong>
    &lt;/Routes&gt;   
  &lt;/BrowserRouter&gt; 
);</pre>
<p>The highlighted lines<a id="_idIndexMarker339"/> should be added to the existing code.</p>
<p>The completed <strong class="bold">Login</strong> page should look like <em class="italic">Figure 5.4</em>:</p>
<div><div><img alt="Figure 5.4: The Login page  " height="500" src="img/B18727_05_04.jpg" width="738"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4: The Login page </p>
<p>Users can now<a id="_idIndexMarker340"/> register and then log in to our app. They can’t manage their password though, which we’ll focus on next.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor146"/>Adding password management pages</h1>
<p>We need to allow <a id="_idIndexMarker341"/>users to manage their passwords. This is <a id="_idIndexMarker342"/>quite involved as users often forget their password and hence a secure mechanism to reset the password is also required. </p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor147"/>Changing a password</h2>
<p>For the user to<a id="_idIndexMarker343"/> change their password, they have to supply their existing password and a strong replacement password. Therefore, the frontend needs to send both to the backend and display relevant errors if the current password is incorrect or the new one is too weak. This logic is contained in the<a id="_idIndexMarker344"/> following code, which should be added to <em class="italic">frontend/src/pages/ChangePassword.tsx</em>:</p>
<pre class="source-code">
import axios from "axios"; 
import { FormikHelpers } from "formik";
import { useContext } from "react";
import { useNavigate } from "react-router-dom";
import { ToastContext } from "src/ToastContext";
import { useMutation } from "src/query";
interface IForm {
  currentPassword: string;
  newPassword: string;
}
 
const useChangePassword = () =&gt; {
  const { addToast } = useContext(ToastContext);
  const { mutateAsync: changePassword } = useMutation(
    async (data: IForm) =&gt; 
      await axios.put("/members/password/", data),
  );
  const navigate = useNavigate();
 
  return async (
    data: IForm,
    { setFieldError }: FormikHelpers&lt;IForm&gt;,
  ) =&gt; {
    try {
      await changePassword(data);
      addToast("Changed", "success");
      navigate("/");
    } catch (error: any) {
      if (axios.isAxiosError(error)) {
        if (error.response?.status === 400) { 
          setFieldError("newPassword", "Password is too weak"); 
        } else if (error.response?.status === 401) {
          setFieldError("currentPassword", "Incorrect             password"); 
        }
      } else { 
        addToast("Try again", "error"); 
      } 
    }
  };
}</pre>
<p>With the logic defined, we <a id="_idIndexMarker345"/>can now add the UI elements. This requires a form containing a plain password field and password strength field as shown here, which should be added to the existing code in <em class="italic">frontend/src/pages/ChangePassword.tsx</em>:</p>
<pre class="source-code">
import { Form, Formik } from "formik";
import * as yup from "yup";
import FormActions from "src/components/FormActions";
import LazyPasswordWithStrengthField from "src/components/LazyPasswordWithStrengthField";
import PasswordField from "src/components/PasswordField";
import Title from "src/components/Title";
 
const validationSchema = yup.object({
  currentPassword: yup.string().required("Required"),
  newPassword: yup.string().required("Required"),
});
 
const ChangePassword = () =&gt; {
  const onSubmit = useChangePassword();
  return (
    &lt;&gt;
      &lt;Title title="Change Password" /&gt;
      &lt;Formik&lt;IForm&gt;
        initialValues={{ currentPassword: "", newPassword: "" }}
        onSubmit={onSubmit}
        validationSchema={validationSchema}
      &gt;
        {({ dirty, isSubmitting }) =&gt; (
          &lt;Form&gt;
            &lt;PasswordField
              autoComplete="current-password"
              fullWidth
              label="Current password"
              name="currentPassword"
              required
            /&gt;
            &lt;LazyPasswordWithStrengthField 
              autoComplete="new-password" 
              fullWidth 
              label="New password" 
              name="newPassword" 
              required 
            /&gt;
            &lt;FormActions 
              disabled={!dirty}
              isSubmitting={isSubmitting} 
              label="Change" 
              links={[{ label: "Back", to: "/" }]} 
            /&gt;
          &lt;/Form&gt;
        )}
      &lt;/Formik&gt;
    &lt;/&gt;
  );
};
export default ChangePassword;</pre>
<p>Then we can add the page to the routing by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
import RequireAuth from "src/components/RequireAuth"; 
import ChangePassword from "src/pages/ChangePassword";
const Router = () =&gt; (
  &lt;BrowserRouter&gt;
<strong class="bold">    ...</strong>
    &lt;Routes&gt;
<strong class="bold">      ...</strong>
      &lt;Route 
        path="/change-password/" 
        element={&lt;RequireAuth&gt;&lt;ChangePassword /&gt;&lt;/RequireAuth&gt;} 
      /&gt;
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);</pre>
<p>In the code block,<a id="_idIndexMarker346"/> <code>...</code> represents code that has been omitted for brevity.</p>
<p>The completed <strong class="bold">Change Password</strong> page should look like <em class="italic">Figure 5.5</em>:</p>
<div><div><img alt="Figure 5.5: The Change Password page  " height="606" src="img/B18727_05_05.jpg" width="797"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5: The Change Password page </p>
<p>Users can now change<a id="_idIndexMarker347"/> their password while logged in. Next, we will allow users to request a password reset link when they have forgotten it.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor148"/>Forgotten passwords</h2>
<p>When a user forgets their<a id="_idIndexMarker348"/> password, they’ll need to reset it by requesting a reset link. To do so, the user needs to enter their email and then we’ll use the members API to send them a password reset email or, if that fails, display a generic error.</p>
<p>The following code to do this should be placed in <em class="italic">frontend/src/pages/ForgottenPassword.tsx</em>:</p>
<pre class="source-code">
import axios from "axios";
import { useContext } from "react";
import { useNavigate } from "react-router";
 
import { useMutation } from "src/query";
import { ToastContext } from "src/ToastContext";
interface IForm {
  email: string;
}
 
const useForgottenPassword = () =&gt; {
  const navigate = useNavigate();
  const { addToast } = useContext(ToastContext);
 
  const { mutateAsync: forgottenPassword } = useMutation(
    async (data: IForm) =&gt; 
      await axios.post("/members/forgotten-password/", data),
  ); 
  return async (data: IForm) =&gt; {
    try {
      await forgottenPassword(data);
      addToast("Reset link sent to your email", "success");
      navigate("/login/");
    } catch {
      addToast("Try again", "error");
    }
  };
};</pre>
<p>With the logic defined, we can now add the UI elements. This requires a form containing an email field as shown<a id="_idIndexMarker349"/> here, which should be added to the existing code in <em class="italic">frontend/src/pages/ForgottenPassword.tsx</em>:</p>
<pre class="source-code">
import { Form, Formik } from "formik";
import { useLocation } from "react-router";
import * as yup from "yup";
 
import EmailField from "src/components/EmailField";
import FormActions from "src/components/FormActions";
import Title from "src/components/Title";
 
const validationSchema = yup.object({ 
  email: yup.string().email("Email invalid").required("Required"), 
});
 
const ForgottenPassword = () =&gt; {
  const onSubmit = useForgottenPassword();
  const location = useLocation();
 
  return (
    &lt;&gt;
      &lt;Title title="Forgotten password" /&gt;
      &lt;Formik&lt;IForm&gt;
        initialValues={{ 
          email: (location.state as any)?.email ?? "" 
        }}
        onSubmit={onSubmit}
        validationSchema={validationSchema}
      &gt;
        {({ dirty, isSubmitting, values }) =&gt; (
          &lt;Form&gt;
            &lt;EmailField
              fullWidth label="Email" name="email" required
            /&gt;
            &lt;FormActions 
              disabled={!dirty}
              isSubmitting={isSubmitting} 
              label="Send email" 
              links={[ 
                {label: "Login", to: "/login/", state: { email:                   values.email }}, 
                {label: "Register", to: "/register/", state: {                   email: values.email }}, 
              ]} 
            /&gt;
          &lt;/Form&gt;
        )}
      &lt;/Formik&gt;
    &lt;/&gt;
  );
};
 
export default ForgottenPassword;</pre>
<p>Then we can add the page to<a id="_idIndexMarker350"/> the routing by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
import ForgottenPassword from "src/pages/ForgottenPassword";
const Router = () =&gt; (
  &lt;BrowserRouter&gt;
<strong class="bold">    ...</strong>
    &lt;Routes&gt;
<strong class="bold">      ...</strong>
      &lt;Route 
        path="/forgotten-password/" 
        element={&lt;ForgottenPassword /&gt;} 
      /&gt;
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);</pre>
<p>In the code block, <code>...</code> represents code that has been omitted for brevity.</p>
<p>The completed <strong class="bold">Forgotten password</strong> page should look like <em class="italic">Figure 5.6</em>:</p>
<div><div><img alt="Figure 5.6: The Forgotten password page  " height="397" src="img/B18727_05_06.jpg" width="753"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6: The Forgotten password page </p>
<p>Next, we need to add a page for the<a id="_idIndexMarker351"/> user to visit to actually reset their password.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor149"/>Resetting a password</h2>
<p>The email sent to the user via the <a id="_idIndexMarker352"/>forgotten password page will contain a link to the reset password page. This link will contain a token that identifies the user, in the same way as the email confirmation process described earlier. This page will need to allow the user to enter a new strong password and send it with the link’s token to the backend. The logic to do this is shown in the following code, which should be placed in <em class="italic">frontend/src/pages/ResetPassword.tsx</em>:</p>
<pre class="source-code">
import axios from "axios";
import { FormikHelpers } from "formik";
import { useContext } from "react";
import { useNavigate, useParams } from "react-router";
 
import { useMutation } from "src/query";
import { ToastContext } from "src/ToastContext";
interface IForm {
  password: string;
}
interface IParams {
  token?: string;
}
 
const useResetPassword = () =&gt; {
  const navigate = useNavigate();
  const params = useParams() as IParams;
  const token = params.token ?? "";
  const { addToast } = useContext(ToastContext);
 
  const { mutateAsync: reset } = useMutation(
    async (password: string) =&gt; 
      await axios.put(
        "/members/reset-password/", { password, token },
      ),
  ); 
  return async (
    data: IForm, 
    { setFieldError }: FormikHelpers&lt;IForm&gt;, 
  ) =&gt; {
    try {
      await reset(data.password);
      addToast("Success", "success");
      navigate("/login/");
    } catch (error: any) {
      if (error.response?.status === 400) { 
        if (error.response?.data.code === "WEAK_PASSWORD") { 
          setFieldError("newPassword", "Password is too weak");  
        } else if (error.response?.data.code === "TOKEN_           INVALID") {
          addToast("Invalid token", "error"); 
        } else if (error.response?.data.code === "TOKEN_           EXPIRED") { 
          addToast("Token expired", "error"); 
        } 
      } else {
        addToast("Try again", "error");
      }
    }
  }
};</pre>
<p>With the logic defined, we <a id="_idIndexMarker353"/>can now add the UI elements. This requires a form containing a password field that shows the password's strength. We can do this by adding the following code to the existing code in <em class="italic">frontend/src/pages/ResetPassword.tsx</em>:</p>
<pre class="source-code">
import { Form, Formik } from "formik";
import * as yup from "yup";
 
import LazyPasswordWithStrengthField from "src/components/LazyPasswordWithStrengthField"
import FormActions from "src/components/FormActions";
import Title from "src/components/Title";
 
const validationSchema = yup.object({ 
  email: yup.string().email("Email invalid").required("Required"), 
});
 
const ResetPassword = () =&gt; { 
  const onSubmit = useResetPassword();
  return (
    &lt;&gt;
      &lt;Title title="Reset password" /&gt;
      &lt;Formik&lt;IForm&gt;
        initialValues={{ password: "" }}
        onSubmit={onSubmit}
        validationSchema={validationSchema}
      &gt;
        {({ dirty, isSubmitting, values }) =&gt; (
          &lt;Form&gt;
            &lt;LazyPasswordWithStrengthField
              autoComplete="new-password"
              fullWidth
              label="Password"
              name="password"
              required
            /&gt;
            &lt;FormActions 
              disabled={!dirty}
              isSubmitting={isSubmitting} 
              label="Reset password"
              links={[{label: "Login", to: "/login/"}]}
            /&gt;
          &lt;/Form&gt;
        )}
      &lt;/Formik&gt;
    &lt;/&gt;
  );
};
 
export default ResetPassword;</pre>
<p>Then we can add the page<a id="_idIndexMarker354"/> to the routing by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
import ResetPassword from "src/pages/ResetPassword";
const Router = () =&gt; (
  &lt;BrowserRouter&gt;
<strong class="bold">    ...</strong>
    &lt;Routes&gt;
<strong class="bold">      ...</strong>
      &lt;Route 
        path="/reset-password/:token/" 
        element={&lt;ResetPassword /&gt;} 
      /&gt;
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);</pre>
<p>In the code <a id="_idIndexMarker355"/>block, <code>...</code> represents code that has been omitted for brevity.</p>
<p>The completed <strong class="bold">Reset password</strong> page should look like <em class="italic">Figure 5.7</em>:</p>
<div><div><img alt="Figure 5.7: The Reset password page  " height="434" src="img/B18727_05_07.jpg" width="631"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7: The Reset password page </p>
<p>Users can now manage their passwords, which means we can focus on pages to manage their to-dos.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor150"/>Adding to-do pages</h1>
<p>Users will need to<a id="_idIndexMarker356"/> manage their to-dos via the app, including <a id="_idIndexMarker357"/>creating, editing, and viewing their to-dos. These equate to different pages, which we will add. </p>
<p>First, let’s create the specific <code>React-Query</code> queries we will need to fetch to-dos from the backend. We can do this by adding the following code to <em class="italic">frontend/src/queries.ts</em>:</p>
<pre class="source-code">
import axios from "axios";
import { useQueryClient } from "@tanstack/react-query";
import { Todo } from "src/models";
import { useQuery } from "src/query";
<strong class="bold">export const STALE_TIME = 1000 * 60 * 5;  // 5 mins</strong>
export const useTodosQuery = () =&gt; 
  useQuery&lt;Todo[]&gt;(
    ["todos"], 
    async () =&gt; {
      const response = await axios.get("/todos/");
      return response.data.todos.map(
        (json: any) =&gt; new Todo(json)
      );
    },
<strong class="bold">    { staleTime: STALE_TIME },</strong>
  );
export const useTodoQuery = (id: number) =&gt; {
  const queryClient = useQueryClient();
  return useQuery&lt;Todo&gt;(
    ["todos", id.toString()],
    async () =&gt; {
      const response = await axios.get(`/todos/${id}/`);
      return new Todo(response.data);
    },
    {
      initialData: () =&gt; {
        return queryClient
          .getQueryData&lt;Todo[]&gt;(["todos"])
          ?.filter((todo: Todo) =&gt; todo.id === id)[0];
      },
<strong class="bold">      staleTime: STALE_TIME,</strong>
    },
  );
};</pre>
<p>The change to the <code>staleTime</code> option (highlighted) ensures that <code>react-query</code> doesn’t continually refetch the<a id="_idIndexMarker358"/> to-do data, but rather considers it valid for 5 minutes. This improves the user experience by reducing their internet data usage. In addition, the <code>useTodoQuery</code> will helpfully use the cached to-do data as the <code>initialData</code> if it is available, thereby saving a request to the backend and improving the user’s experience. </p>
<p class="callout-heading">Which user’s to-dos?</p>
<p class="callout">It may not be clear that the <code>useTodosQuery</code> defined previously will only return the currently authenticated user’s to-dos. This is because we’ve set up the backend to only return to-dos belonging to the currently authenticated user. It is vital that the authentication decisions are made in the backend as the user is able to alter the frontend code and hence potentially bypass checks.</p>
<p>Next, we need <a id="_idIndexMarker359"/>to add the mutations to update the to-do data in the backend by adding the following to <em class="italic">frontend/src/queries.ts</em>:</p>
<pre class="source-code">
import { useMutation } from "src/query";
export interface ItodoData {
  complete: boolean;
  due: Date | null;
  task: string;
} 
export const useCreateTodoMutation = () =&gt; {
  const queryClient = useQueryClient();
  return useMutation(
    async (data: ItodoData) =&gt; await axios.post("/todos/",       data),
    {
      onSuccess: () =&gt; queryClient.invalidateQueries(["todos"]),
    },
  );
};
export const useEditTodoMutation = (id: number) =&gt; {
  const queryClient = useQueryClient();
  return useMutation(
    async (data: ItodoData) =&gt; 
      await axios.put(`/todos/${id}/`, data),
    {
      onSuccess: () =&gt; queryClient.        invalidateQueries(["todos"]), 
    },
  );
};
export const useDeleteTodoMutation = () =&gt; {
  const queryClient = useQueryClient();
  return useMutation(
    async (id: number) =&gt; 
      await axios.delete(`/todos/${id}/`),
    {
      onSuccess: () =&gt; queryClient.        invalidateQueries(["todos"]), 
    },
  );
};</pre>
<p>All three of these<a id="_idIndexMarker360"/> mutations will invalidate the <code>[“todos”]</code> query data thereby requiring the to-do queries defined previously to fetch the new data, rather than return the outdated data.</p>
<p>With these queries available, we can now create the actual visual elements (i.e., pages for the user to interact with).</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor151"/>Showing to-dos</h2>
<p>The first page we need is one<a id="_idIndexMarker361"/> to show all the user’s to-dos, which is effectively the user’s home page. Alongside showing the to-dos, it needs to provide actions to create a to-do and edit and delete any existing ones. </p>
<p>The actions to edit or delete a to-do can be linked to the to-do directly by either clicking on it or a delete button associated with it. However, creating a to-do is a primary action for the page and hence is best suited to a floating action button. Therefore, the to-dos page should look like <em class="italic">Figure 5.8</em>:</p>
<div><div><img alt="Figure 5.8: The home page showing to-dos, along with the floating action button " height="606" src="img/B18727_05_08.jpg" width="666"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8: The home page showing to-dos, along with the floating action button</p>
<p>First, let’s create a component that shows an individual to-do by adding the following to <em class="italic">frontend/src/components/Todo.tsx</em>:</p>
<pre class="source-code">
import Checkbox from "@mui/material/Checkbox";
import IconButton from "@mui/material/IconButton";
import ListItem from "@mui/material/ListItem";
import ListItemButton from "@mui/material/ListItemButton";
import ListItemIcon from "@mui/material/ListItemIcon";
import ListItemText from "@mui/material/ListItemText";
import Skeleton from "@mui/material/Skeleton";
import DeleteIcon from "@mui/icons-material/Delete";
import { format } from "date-fns";
import { Link } from "react-router-dom";
import { Todo as TodoModel } from "src/models";
import { useDeleteTodoMutation } from "src/queries";
interface IProps { todo?: TodoModel }
const Todo = ({ todo }: IProps) =&gt; {
  const { mutateAsync: deleteTodo } = useDeleteTodoMutation();
  let secondary; 
  if (todo === undefined) {
    secondary = &lt;Skeleton width="200px" /&gt;;
  } else if (todo.due !== null) {
    secondary = format(todo.due, "P");
  }
  return (
    &lt;ListItem
      secondaryAction={
        &lt;IconButton
          disabled={todo === undefined} edge="end"
          onClick={() =&gt; deleteTodo(todo?.id!)}
        &gt;
          &lt;DeleteIcon /&gt;
        &lt;/IconButton&gt;
      }
    &gt;
      &lt;ListItemButton
        component={Link} disabled={todo === undefined}
        to={`/todos/${todo?.id}/`}
      &gt;
        &lt;ListItemIcon&gt;
          &lt;Checkbox
            checked={todo?.complete ?? false}
            disabled disableRipple edge="start" tabIndex={-1}
          /&gt;
        &lt;/ListItemIcon&gt;
        &lt;ListItemText 
          primary={todo?.task ?? &lt;Skeleton /&gt;}           secondary={secondary}
        /&gt;
      &lt;/ListItemButton&gt;
    &lt;/ListItem&gt;
  );
}
export default Todo;</pre>
<p>This <code>Todo</code> component will render skeletons if the <code>todo</code> prop is undefined. We can use this to improve the user <a id="_idIndexMarker362"/>experience as the to-dos are fetched from the backend. </p>
<p class="callout-heading">Skeleton loading</p>
<p class="callout">Fetching data from the backend will take a noticeable amount of time, during which the user will wonder what the app is doing. It is therefore best to show the user that the app is working (loading the data). We’l<a id="_idTextAnchor152"/>l do this by using skeletons, which are gray animated blocks arranged with the<a id="_idTextAnchor153"/> same layout as the completed page. The gray arrangement looks like a skeleton, which gives them their name. </p>
<p>The full home page, which shows all the to-dos the user has, is then finished by adding the following to <em class="italic">frontend/src/pages/Todos.tsx</em>:</p>
<pre class="source-code">
import Fab from "@mui/material/Fab";
import List from "@mui/material/List";
import AddIcon from "@mui/icons-material/Add";
import { Link, Navigate } from "react-router-dom";
import Todo from "src/components/Todo";
import { useTodosQuery } from "src/queries";
const Todos = () =&gt; {
  const { data: todos } = useTodosQuery();
  if (todos?.length === 0) {
    return &lt;Navigate to="/todos/new/" /&gt;;
  } else {
    return (
      &lt;&gt;
        &lt;List&gt;
          {todos !== undefined ?
            todos.map((todo) =&gt; &lt;Todo key={todo.id} todo={todo} /&gt;)
            : [1, 2, 3].map((id) =&gt; &lt;Todo key={-id} /&gt;)  
          }
        &lt;/List&gt;
        &lt;Fab 
          component={Link} 
          sx={{ 
            bottom: (theme) =&gt; theme.spacing(2), 
            position: "fixed", 
            right: (theme) =&gt; theme.spacing(2), 
          }} 
          to="/todos/new/"
        &gt;
          &lt;AddIcon /&gt;
        &lt;/Fab&gt;
      &lt;/&gt;
    );
  }
};
export default Todos;</pre>
<p>Then we can add the page to<a id="_idIndexMarker363"/> the routing by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
import Todos from "src/pages/Todos";
const Router = () =&gt; (
  &lt;BrowserRouter&gt;
<strong class="bold">    ...</strong>
    &lt;Routes&gt;
<strong class="bold">      ...</strong>
      &lt;Route 
        path="/" 
        element={&lt;RequireAuth&gt;&lt;Todos /&gt;&lt;/RequireAuth&gt;} 
      /&gt;
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);</pre>
<p>In the code block, <code>...</code> represents code that has been omitted for brevity.</p>
<p>Now that we can display the to-dos, we need to be able to create and edit them.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor154"/>Creating to-dos</h2>
<p>We will need to provide <a id="_idIndexMarker364"/>pages for users to create new to-dos and edit any existing ones. Both these pages will require a form to enter and edit the to-do data. Rather than repeat this form code for each page, we’ll create a <code>TodoForm</code> component, starting by defining the form validation by adding the following to <em class="italic">frontend/src/components/TodoForm.tsx</em>:</p>
<pre class="source-code">
import * as yup from "yup";
const validationSchema = yup.object({
  complete: yup.boolean(),
  due: yup.date().nullable(),
  task: yup.string().required("Required"),
});</pre>
<p>With the validation schema and form structure defined, we can add the component itself. This component <a id="_idIndexMarker365"/>needs only to render the relevant fields within a Formik form. The following code should be added to <em class="italic">frontend/src/components/TodoForm.tsx</em>:</p>
<pre class="source-code">
import { Form, Formik } from "formik";
 
import CheckboxField from "src/components/CheckboxField";
import DateField from "src/components/DateField";
import FormActions from "src/components/FormActions";
import TextField from "src/components/TextField";
import type { ITodoData } from "src/queries";
 
interface IProps {
  initialValues: ITodoData;
  label: string;
  onSubmit: (data: ITodoData) =&gt; Promise&lt;any&gt;;
}
 
const TodoForm = ({ initialValues, label, onSubmit }: IProps) =&gt; (
  &lt;Formik&lt; ITodoData&gt;
    initialValues={initialValues}
    onSubmit={onSubmit}
    validationSchema={validationSchema}
  &gt;
    {({ dirty, isSubmitting }) =&gt; (
      &lt;Form&gt;
        &lt;TextField
          fullWidth label="Task" name="task" required
        /&gt;
        &lt;DateField fullWidth label="Due" name="due" /&gt;
        &lt;CheckboxField
          fullWidth label="Complete" name="complete"
        /&gt;
        &lt;FormActions
          disabled={!dirty}
          isSubmitting={isSubmitting}
          label={label}
          links={[{ label: "Back", to: "/" }]}
        /&gt;
      &lt;/Form&gt;
    )}
  &lt;/Formik&gt;
);
 
export default TodoForm;</pre>
<p>We can then use the <code>TodoForm</code> in a page to<a id="_idIndexMarker366"/> create a to-do task, by adding the following to <em class="italic">frontend/src/pages/CreateTodo.tsx</em>:</p>
<pre class="source-code">
import { useContext } from "react";
import { useNavigate } from "react-router-dom";
 
import TodoForm from "src/components/TodoForm";
import Title from "src/components/Title";
import type { ITodoData } from "src/queries";
import { useCreateTodoMutation } from "src/queries";
import { ToastContext } from "src/ToastContext";
 
const CreateTodo = () =&gt; {
  const navigate = useNavigate();
  const { addToast } = useContext(ToastContext);
  const { mutateAsync: createTodo } = useCreateTodoMutation();
  const onSubmit = async (data: ITodoData) =&gt; {
    try {
      await createTodo(data);
      navigate("/");
    } catch {
      addToast("Try Again", "error");
    }
  };
 
  return (
    &lt;&gt;
      &lt;Title title="Create a Todo" /&gt;
      &lt;TodoForm
        initialValues={{           complete: false, due: null, task: ""         }}
        label="Create"
        onSubmit={onSubmit}
      /&gt;
    &lt;/&gt;
  );
};
 
export default CreateTodo;</pre>
<p>Then we can add the page to the<a id="_idIndexMarker367"/> routing by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
import CreateTodo from "src/pages/CreateTodo";
const Router = () =&gt; (
  &lt;BrowserRouter&gt;
<strong class="bold">    ...</strong>
    &lt;Routes&gt;
<strong class="bold">      ...</strong>
      &lt;Route 
        path="/todos/new/" 
        element={&lt;RequireAuth&gt;&lt;CreateTodo /&gt;&lt;/RequireAuth&gt;} 
      /&gt;
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);</pre>
<p>In the code <a id="_idIndexMarker368"/>block, <code>...</code> represents code that has been omitted for brevity.</p>
<p>The completed Create a Todo page should look like <em class="italic">Figure 5.9</em>:</p>
<div><div><img alt="Figure 5.9: The Create a Todo page showing the to-do form  " height="606" src="img/B18727_05_09.jpg" width="849"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9: The Create a Todo page showing the to-do form </p>
<p>Users will want to be able to edit their to-dos after creating them, which we’ll add next.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor155"/>Editing to-dos</h2>
<p>Finally, for the to-do pages, we<a id="_idIndexMarker369"/> need to allow users to edit their to-dos; you can do this via the following code, which should be added to <em class="italic">frontend/src/pages/EditTodo.tsx</em>:</p>
<pre class="source-code">
import Skeleton from "@mui/material/Skeleton";
import { useContext } from "react";
import { useNavigate, useParams } from "react-router";
 
import TodoForm from "src/components/TodoForm";
import Title from "src/components/Title";
import type { ITodoData } from "src/queries";
import { useEditTodoMutation, useTodoQuery } from "src/queries";
import { ToastContext } from "src/ToastContext";
 
interface Iparams {
  id: string;
}
 
const EditTodo = () =&gt; {
  const navigate = useNavigate();
  const params = useParams&lt;keyof Iparams&gt;() as Iparams;
  const todoId = parseInt(params.id, 10);
  const { addToast } = useContext(ToastContext);
  const { data: todo } = useTodoQuery(todoId); 
  const { mutateAsync: editTodo } = useEditTodoMutation(todoId);
 
  const onSubmit = async (data: ITodoData) =&gt; {
    try {
      await editTodo(data);
      navigate("/");
    } catch {
      addToast("Try again", "error");
    }
  };
 
  return (
    &lt;&gt;
      &lt;Title title="Edit todo" /&gt;
      {todo === undefined ? (
        &lt;Skeleton height="80px" /&gt;
      ) : (
        &lt;TodoForm
          initialValues={{
            complete: todo.complete,
            due: todo.due,
            task: todo.task,
          }}
          label="Edit"
          onSubmit={onSubmit}
        /&gt;
      )}
    &lt;/&gt;
  );
};
 
export default EditTodo;</pre>
<p>Then we can add the page to <a id="_idIndexMarker370"/>the routing by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
import EditTodo from "src/pages/EditTodo";
const Router = () =&gt; (
  &lt;BrowserRouter&gt;
<strong class="bold">    ...</strong>
    &lt;Routes&gt;
<strong class="bold">      ...</strong>
      &lt;Route 
        path="/todos/:id/" 
        element={&lt;RequireAuth&gt;&lt;EditTodo /&gt;&lt;/RequireAuth&gt;} 
      /&gt;
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);</pre>
<p>In the code block, <code>...</code> represents code that has been omitted for brevity.</p>
<p>The completed Edit todo page should look like <em class="italic">Figure 5.10</em>:</p>
<div><div><img alt="Figure 5.10: The Edit todo page  " height="543" src="img/B18727_05_10.jpg" width="716"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10: The Edit todo page </p>
<p>This completes<a id="_idIndexMarker371"/> the frontend functionality we need for our to-do app.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor156"/>Summary</h1>
<p>In this chapter, we’ve created a user interface that allows users to authenticate, manage their passwords, and manage their to-dos. This completes the development version of the app, which we can now use locally to manage to-dos.</p>
<p>The user authentication and password management user interfaces are useful to any app and could be used directly in your apps, and the to-do user interface could be adapted or used as a reference for other functionality.</p>
<p>In the next chapter, we’ll deploy this app to production, allowing users to access and use it.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor157"/>Further reading</h1>
<p>To further enhance your app, I recommend you read more about good UX practices, for example, via <a href="https://builtformars.com">https://builtformars.com</a>. Also, to improve your frontend styling skills, I’d recommend <a href="https://css-tricks.com">https://css-tricks.com</a>.</p>
</div>
</div>

<div><div><h1 id="_idParaDest-145"><a id="_idTextAnchor158"/>Part 3 Releasing a Production-Ready App</h1>
<p>Building a working app is only the first step; it needs to be deployed to a public domain name that runs on AWS, made secure, and then packaged for the mobile app stores. We’ll do all of this by incorporating as many industry best practices as possible.</p>
<p>This part consists of the following chapters:</p>
<ul>
<li><a href="B18727_06.xhtml#_idTextAnchor159"><em class="italic">Chapter 6</em></a>, <em class="italic">Deploying and Monitoring Your Application</em></li>
<li><a href="B18727_07.xhtml#_idTextAnchor180"><em class="italic">Chapter 7</em></a>, <em class="italic">Securing and Packaging the App</em></li>
</ul>
</div>
</div></body></html>