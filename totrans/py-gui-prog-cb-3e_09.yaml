- en: Extending Our GUI with the wxPython Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 wxPython 库扩展我们的 GUI
- en: In this chapter, we will introduce another Python GUI toolkit that does not
    ship with Python. It is called wxPython. There are two versions of this library.
    The original is called **Classic**, while the newest is called by its development
    project code name, which is **Phoenix**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍另一个不与 Python 一起分发的 Python GUI 工具包。它被称为 wxPython。这个库有两个版本。原始版本被称为 **Classic**，而最新版本被称为其开发项目的代码名，即
    **Phoenix**。
- en: The older Classic version does not work with Python 3.x, and we will not look
    further into this version but instead concentrate on the Phoenix software version.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的 Classic 版本不与 Python 3.x 兼容，我们将不会进一步探讨这个版本，而是专注于 Phoenix 软件版本。
- en: In this book, we are solely programming using Python 3.7 and later, and because
    the new Phoenix project is also aimed at supporting Python 3.7 and later, this
    is the version of wxPython we will use in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们仅使用 Python 3.7 及更高版本进行编程，因为新的 Phoenix 项目也旨在支持 Python 3.7 及更高版本，因此这是我们本章将使用的
    wxPython 版本。
- en: First, we will install the framework. Then, we will create a simple wxPython
    GUI, and after that, we will try to connect the `tkinter`-based GUIs we developed
    in this book with the new wxPython library.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装框架。然后，我们将创建一个简单的 wxPython GUI，之后，我们将尝试将我们在本书中开发的基于 `tkinter` 的 GUI 与新的
    wxPython 库连接起来。
- en: wxPython is a Python binding to wxWidgets. The *w* in wxPython stands for the
    Windows OS, and the *x* stands for Unix-based OSes, such as Linux and Apple's
    macOS.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 是 wxWidgets 的 Python 绑定。wxPython 中的 *w* 代表 Windows 操作系统，而 *x* 代表基于
    Unix 的操作系统，例如 Linux 和苹果的 macOS。
- en: While `tkinter` ships with Python, it is valuable to have experience using other
    GUI frameworks that work with Python. This will improve your Python GUI programming
    skills, and you can choose which framework to use in your projects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `tkinter` 与 Python 一起分发，但拥有使用其他与 Python 兼容的 GUI 框架的经验是有价值的。这将提高你的 Python
    GUI 编程技能，并且你可以选择在你的项目中使用哪个框架。
- en: 'Here is the overview of Python modules for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章 Python 模块的概述：
- en: '![](img/9eeacd50-9d24-4357-bef7-4d4bee6f6f6e.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9eeacd50-9d24-4357-bef7-4d4bee6f6f6e.png)'
- en: 'In this chapter, we will enhance our Python GUI by using the wxPython library.
    We will cover the following recipes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用 wxPython 库来增强我们的 Python GUI。我们将涵盖以下配方：
- en: Installing the wxPython library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 wxPython 库
- en: Creating our GUI in wxPython
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 wxPython 中创建我们的 GUI
- en: Quickly adding controls using wxPython
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 wxPython 快速添加控件
- en: Trying to embed a main wxPython app in a main tkinter app
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将主 wxPython 应用嵌入到主 tkinter 应用中
- en: Trying to embed our tkinter GUI code into wxPython
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将我们的 tkinter GUI 代码嵌入到 wxPython 中
- en: Using Python to control two different GUI frameworks
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 控制两个不同的 GUI 框架
- en: Communicating between two connected GUIs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个连接的 GUI 之间的通信
- en: Installing the wxPython library
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 wxPython 库
- en: The wxPython library does not ship with Python, so in order to use it, we first
    have to install it. This recipe will show us where and how to find the right version
    to install in order to match both the installed version of Python and the OS we
    are running.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 库不是与 Python 一起分发的，因此为了使用它，我们首先必须安装它。这个配方将向我们展示在哪里以及如何找到正确的版本来安装，以便与已安装的
    Python 版本和正在运行的操作系统相匹配。
- en: The wxPython third-party library has been around for more than 18 years, which
    indicates that it is a robust library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 第三方库已经存在了18年多，这表明它是一个健壮的库。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to use wxPython with Python 3.7 and later, we have to install the wxPython
    Phoenix version. Here is a link to the downloads page: [https://wxpython.org/pages/downloads/](https://wxpython.org/pages/downloads/).
    We will use this link to download and install the wxPython GUI framework.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 wxPython 与 Python 3.7 及更高版本，我们必须安装 wxPython Phoenix 版本。这是下载页面的链接：[https://wxpython.org/pages/downloads/](https://wxpython.org/pages/downloads/)。我们将使用此链接下载和安装
    wxPython GUI 框架。
- en: And this is a link to PyPI with good information about how to use wxPython: [https://pypi.org/project/wxPython/](https://pypi.org/project/wxPython/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是到 PyPI 的链接，其中包含有关如何使用 wxPython 的良好信息：[https://pypi.org/project/wxPython/](https://pypi.org/project/wxPython/)。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'While only a few years ago it was a little tricky to find the right wxPython
    version for Python 3, we can now simply use `pip`. Let''s see how in detail:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，找到适合 Python 3 的正确 wxPython 版本有点棘手，但现在我们可以简单地使用 `pip`。让我们详细看看：
- en: Open a Command Prompt or PowerShell window.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符或 PowerShell 窗口。
- en: Type `pip install wxPython`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `pip install wxPython`。
- en: 'The result should look similar to this:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '![](img/52b8865c-1242-4453-a3bb-7a2e2d554e7a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52b8865c-1242-4453-a3bb-7a2e2d554e7a.png)'
- en: 'Verify that you have a new folder named `wx` in your Python `site-packages`
    folder:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认在你的 Python `site-packages` 文件夹中有一个名为 `wx` 的新文件夹：
- en: '![](img/b6aa1996-b340-4146-b17e-fd611b147eef.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6aa1996-b340-4146-b17e-fd611b147eef.png)'
- en: Create a new module and call it `Hello_wxPython.py`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，并将其命名为 `Hello_wxPython.py`。
- en: 'Add the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running the preceding Python 3.7 script creates the following GUI using wxPython/Phoenix:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的 Python 3.7 脚本将使用 wxPython/Phoenix 创建以下 GUI：
- en: '![](img/8ed2506f-82d4-41fa-a68c-da02a09d0099.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ed2506f-82d4-41fa-a68c-da02a09d0099.png)'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，更好地理解它。
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, we use `pip` to install the wxPython framework. Then, we verify that
    we have the new `wx` folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `pip` 安装 wxPython 框架。然后，我们验证我们是否有新的 `wx` 文件夹。
- en: '`wx` is the name of the folder that the wxPython Phoenix library was installed
    into. We will import this module into our Python code using the name `wx`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`wx` 是 wxPython Phoenix 库安装到的文件夹的名称。我们将使用 `wx` 这个名称将这个模块导入到我们的 Python 代码中。'
- en: We can verify that our installation worked by executing this simple demo script
    from the official wxPython/Phoenix website. The link to the official website is [https://wxpython.org/pages/overview/#hello-world](https://wxpython.org/pages/overview/#hello-world).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行来自官方 wxPython/Phoenix 网站的简单演示脚本来验证我们的安装是否成功。官方网站的链接是 [https://wxpython.org/pages/overview/#hello-world](https://wxpython.org/pages/overview/#hello-world)。
- en: In this recipe, we successfully installed the correct version of the wxPython
    toolkit that we can use with Python 3.7\. We found the Phoenix project for this
    GUI toolkit, which is the current and active development line. Phoenix will replace
    the classic wxPython toolkit in time and is specifically designed to work well
    with Python 3.7.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们成功安装了与 Python 3.7 兼容的正确版本的 wxPython 工具包。我们找到了这个 GUI 工具包的 Phoenix 项目，这是当前和活跃的开发线。Phoenix
    将最终取代经典的 wxPython 工具包，并且专门设计来与 Python 3.7 一起很好地工作。
- en: After successfully installing the wxPython/Phoenix toolkit, we then created
    a GUI using this toolkit in only five lines of code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装 wxPython/Phoenix 工具包后，我们只用五行代码就创建了 GUI。
- en: We previously achieved the same results by using `tkinter`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前通过使用 `tkinter` 实现了相同的结果。
- en: Creating our GUI in wxPython
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 wxPython 中创建我们的 GUI
- en: In this recipe, we will start creating our Python GUIs using the wxPython GUI
    toolkit. We will first recreate several of the widgets we previously created using
    `tkinter`, which ships with Python. Then, we will explore some of the widgets
    the wxPython GUI toolkit offers, which are not that easy to create by using `tkinter`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将开始使用 wxPython GUI 工具包创建我们的 Python GUI。我们首先将重新创建我们之前使用 `tkinter` 创建的一些小部件，`tkinter`
    是 Python 的一部分。然后，我们将探索 wxPython GUI 工具包提供的一些小部件，这些小部件使用 `tkinter` 创建起来并不那么容易。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The previous recipe showed you how to install the correct version of wxPython
    that matches both your version of Python and the OS you are running. A good place
    to start exploring the wxPython GUI toolkit is by going to the following URL:
    [http://wxpython.org/Phoenix/docs/html/gallery.html](http://wxpython.org/Phoenix/docs/html/gallery.html).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的菜谱向你展示了如何安装与你的 Python 版本和运行操作系统相匹配的正确版本的 wxPython。探索 wxPython GUI 工具包的一个好地方是访问以下网址：[http://wxpython.org/Phoenix/docs/html/gallery.html](http://wxpython.org/Phoenix/docs/html/gallery.html)。
- en: 'This web page displays many wxPython widgets and, by clicking on any of them,
    we are taken to their documentation, which is a very helpful feature if you want
    to quickly learn about a wxPython control:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网页显示了多个 wxPython 小部件，通过点击任何一个，我们都会被带到它们的文档，这对于想要快速了解 wxPython 控件的人来说是一个非常有用的功能：
- en: '![](img/17476260-120b-455a-86da-3a4a4ef96824.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17476260-120b-455a-86da-3a4a4ef96824.png)'
- en: Let's now use the wxPython library.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 wxPython 库。
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We can very quickly create a working window that comes with a title, a menu
    bar, and also a status bar. This status bar displays the text of a menu item when
    hovering the mouse over it. Moving forward, perform the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常快速地创建一个带有标题、菜单栏和状态栏的工作窗口。这个状态栏在鼠标悬停在小部件上时显示菜单项的文本。接下来，执行以下步骤：
- en: Create a new Python module and name it `wxPython_frame_GUI.py`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Python 模块，并将其命名为 `wxPython_frame_GUI.py`。
- en: 'Add the following code:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This creates the following GUI, which is written in Python using the wxPython
    library:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建以下 GUI，它使用 wxPython 库用 Python 编写：
- en: '![](img/48fe8b61-d6b9-4479-8afb-30c5f82916a8.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48fe8b61-d6b9-4479-8afb-30c5f82916a8.png)'
- en: Create a new module and name it `wxPython_panel_GUI.py`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块并将其命名为 `wxPython_panel_GUI.py`。
- en: 'Add the following code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the preceding code and clicking our wxPython button widget results
    in the following GUI output:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码并点击我们的 wxPython 按钮小部件，将产生以下 GUI 输出：
- en: '![](img/69c05a45-6eb8-4e6e-8d68-4b8e1527968a.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69c05a45-6eb8-4e6e-8d68-4b8e1527968a.png)'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解它。
- en: How it works…
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the `wxPython_frame_GUI.py` code, we inherit from `wx.Frame`. In the next code,
    we inherit from `wx.Panel` and we pass in `wx.Frame` to the `__init__()` method
    of our class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `wxPython_frame_GUI.py` 代码中，我们继承自 `wx.Frame`。在下一代码中，我们继承自 `wx.Panel` 并将 `wx.Frame`
    传递到我们类的 `__init__()` 方法中。
- en: In wxPython, the top-level GUI window is called a frame. There cannot be a wxPython
    GUI without a frame, and the frame has to be created as part of a wxPython application.
    We create both the application and the frame at the bottom of our code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 wxPython 中，顶级 GUI 窗口被称为框架。没有框架就不能有 wxPython GUI，框架必须作为 wxPython 应用程序的一部分来创建。我们在代码的底部创建了应用程序和框架。
- en: In order to add widgets to our GUI, we have to attach them to a panel. The parent
    of the panel is the frame (our top-level window), and the parent of the widgets
    we place into the panel is the panel. In the `wxPython_panel_GUI.py` code, the parent is
    a `wx.Frame` we are passing into the GUI initializer. We also add a button widget
    to the panel widget, which, when clicked, prints out some text to the textbox.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将小部件添加到我们的 GUI 中，我们必须将它们附加到一个面板上。面板的父级是框架（我们的顶级窗口），而我们放入面板中的小部件的父级是面板。在 `wxPython_panel_GUI.py`
    代码中，`parent` 是我们传递给 GUI 初始化器的 `wx.Frame`。我们还向面板小部件添加了一个按钮小部件，当点击时，会在 `textbox`
    中打印一些文本。
- en: We have created our own GUI in this recipe using the mature wxPython GUI toolkit.
    In only a few lines of Python code, we were able to create a fully functional
    GUI that comes with minimize, maximize, and exit buttons. We added a menu bar,
    a multi-line text control, and a button. We also created a status bar that displays
    text when we select a menu item. We placed all these widgets into a panel container
    widget. We hooked up the button to print to the text control. When hovering over
    a menu item, some text gets displayed in the status bar.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用成熟的 wxPython GUI 工具包创建了我们的 GUI。仅用几行 Python 代码，我们就能够创建一个带有最小化、最大化和退出按钮的完整功能的
    GUI。我们添加了一个菜单栏、一个多行文本控件和一个按钮。我们还创建了一个状态栏，当选择菜单项时，会在状态栏中显示文本。我们将所有这些小部件放入一个面板容器小部件中。我们将按钮连接到打印到文本控件。当悬停在菜单项上时，状态栏中会显示一些文本。
- en: Quickly adding controls using wxPython
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 wxPython 快速添加控件
- en: In this recipe, we will recreate the GUI we originally created earlier in this
    book with `tkinter`, but this time, we will be using the wxPython library. We
    will see how easy and quick it is to use the wxPython GUI toolkit to create our
    own Python GUIs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重新创建本书早期使用 `tkinter` 创建的 GUI，但这次我们将使用 wxPython 库。我们将看到使用 wxPython
    GUI 工具包创建自己的 Python GUI 是多么容易和快捷。
- en: We will not recreate the entire functionality we created in the previous chapters.
    For example, we will not internationalize our wxPython GUI, nor connect it to
    a MySQL database. We will recreate the visual aspects of the GUI and add some
    functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重新创建之前章节中创建的全部功能。例如，我们不会国际化我们的 wxPython GUI，也不会将其连接到 MySQL 数据库。我们将重新创建 GUI
    的视觉方面并添加一些功能。
- en: Comparing different libraries gives us the choice of which toolkits to use for
    our own Python GUI development, and we can combine several of those toolkits in
    our own Python code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 比较不同的库为我们提供了选择用于我们自己的 Python GUI 开发的工具包的机会，我们可以在自己的 Python 代码中组合这些工具包中的几个。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure you have the wxPython module installed to follow this recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已安装 wxPython 模块，以便遵循此菜谱。
- en: How to do it…
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s see how to perform this recipe:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何执行这个菜谱：
- en: First, we create our Python `OOP` class as we did before when using `tkinter`,
    but this time we inherit from and extend the `wx.Frame` class. We name the class `MainFrame`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建我们的 Python `OOP` 类，就像之前使用 `tkinter` 一样，但这次我们继承并扩展了 `wx.Frame` 类。我们将类命名为
    `MainFrame`。
- en: Create a new Python module and call it `GUI_wxPython.py`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Python 模块，并将其命名为 `GUI_wxPython.py`。
- en: 'Add the following code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code to create a `notebook` widget:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以创建一个 `notebook` 小部件：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a new class and name it `Widgets`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的类并命名为 `Widgets`：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add these methods:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the `addStaticBoxWithLabels` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `addStaticBoxWithLabels` 方法：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following methods and call them in `__init__`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法并在 `__init__` 中调用它们：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the bottom of the module, add the code to call `MainLoop`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块的底部，添加调用 `MainLoop` 的代码：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run `GUI_wxPython.py`. The final result of our wxPython GUI looks as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `GUI_wxPython.py`。我们的 wxPython GUI 的最终结果如下：
- en: '![](img/7ca130af-7909-462d-9f27-15b61ae2c341.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ca130af-7909-462d-9f27-15b61ae2c341.png)'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: First, we create a new Python module. For reasons of clarity, we no longer call
    our class `OOP` but, instead, rename it as `MainFrame`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的 Python 模块。为了清晰起见，我们不再将我们的类命名为 `OOP`，而是将其重命名为 `MainFrame`。
- en: In wxPython, the main GUI window is called a frame.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 wxPython 中，主 GUI 窗口被称为框架。
- en: We also create a callback method that closes the GUI when we click the Exit menu
    item and declare a light-gray tuple as the background color for our GUI. We then
    add a tabbed control to our GUI by creating an instance of the wxPython `Notebook` class
    and assign it as the parent of our own custom class named `Widgets`. The `Notebook` class
    instance variable has `wx.Panel` as its parent.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个回调方法，当点击 Exit 菜单项时关闭 GUI，并声明一个浅灰色元组作为我们的 GUI 的背景颜色。然后，我们通过创建 wxPython
    的 `Notebook` 类的实例并将其分配给我们的自定义类 `Widgets` 作为其父类，向我们的 GUI 添加一个选项卡控件。`Notebook` 类实例变量以
    `wx.Panel` 作为其父类。
- en: In wxPython, the tabbed widget is named `Notebook`, just like in `tkinter`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 wxPython 中，选项卡控件被命名为 `Notebook`，就像在 `tkinter` 中一样。
- en: Every `Notebook` widget needs to have a parent and, in order to lay out widgets
    in the `Notebook` in wxPython, we use different kinds of sizers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Notebook` 小部件都需要一个父类，为了在 wxPython 的 `Notebook` 中布局小部件，我们使用不同类型的 sizers。
- en: wxPython sizers are layout managers, similar to grid layout manager of `tkinter`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 的 sizers 是布局管理器，类似于 `tkinter` 的网格布局管理器。
- en: Next, we add controls to our `Notebook` page, and we do this by creating a separate
    class, `Widgets`, that inherits from `wx.Panel`. We modularize our GUI code by
    breaking it into small methods, following Python OOP programming best practices,
    which keeps our code manageable and understandable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向 `Notebook` 页面添加控件，我们通过创建一个继承自 `wx.Panel` 的单独类 `Widgets` 来完成这项工作。我们通过将代码分解成小方法来模块化我们的
    GUI 代码，遵循 Python OOP 编程的最佳实践，这使我们的代码易于管理和理解。
- en: When using wxPython `StaticBox` widgets, in order to successfully lay them out,
    we use a combination of `StaticBoxSizer` and a regular `BoxSizer`. The wxPython `StaticBox` is
    very similar to the `LabelFrame` widget of `tkinter`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 wxPython 的 `StaticBox` 小部件时，为了成功布局它们，我们使用 `StaticBoxSizer` 和常规 `BoxSizer`
    的组合。wxPython 的 `StaticBox` 与 `tkinter` 的 `LabelFrame` 小部件非常相似。
- en: Embedding a `StaticBox` within another `StaticBox` is straightforward in `tkinter`,
    but using wxPython is a little non-intuitive. One way to make it work is shown
    in the `addStaticBoxWithLabels` method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tkinter` 中将 `StaticBox` 嵌套在另一个 `StaticBox` 内是直接的，但使用 wxPython 则稍微不那么直观。使它工作的一种方法在
    `addStaticBoxWithLabels` 方法中显示。
- en: After this, we create a horizontal `BoxSizer`. Next, we create a vertical `StaticBoxSizer` because
    we want to arrange two labels in a vertical layout in this frame. In order to
    arrange another widget to the right of the embedded `StaticBox`, we have to assign
    both the embedded `StaticBox` with its children controls and the next widget to
    the horizontal `BoxSizer`. Next, we need to assign this `BoxSizer`, which now
    contains both our embedded `StaticBox` and our other widgets, to the main `StaticBox`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们创建一个水平的 `BoxSizer`。接下来，我们创建一个垂直的 `StaticBoxSizer`，因为我们想在这个框架中将两个标签垂直排列。为了将另一个小部件安排在嵌入的
    `StaticBox` 的右侧，我们必须将嵌入的 `StaticBox` 及其子控件和下一个小部件都分配给水平 `BoxSizer`。接下来，我们需要将这个
    `BoxSizer` 分配给主 `StaticBox`。
- en: Does this sound confusing?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来是不是很困惑？
- en: Just experiment with these sizers to get a feel of how to use them. Start with
    the code for this recipe and comment out some code or modify some *x* and *y* coordinates
    to see the effects. It is also good to read the official wxPython documentation
    to learn more.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 只需实验这些 sizers，以了解如何使用它们。从本食谱的代码开始，注释掉一些代码或修改一些 *x* 和 *y* 坐标以查看效果。阅读官方 wxPython
    文档以了解更多信息也是好的。
- en: The important thing is knowing where to add the different sizers in the code
    in order to achieve the layout we wish.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道在代码中添加不同的 sizers 的位置，以便实现我们想要的布局。
- en: In order to create the second `StaticBox` below the first, we create separate `StaticBoxSizer` and
    assign them to the same panel. We design and lay out our wxPython GUI in several
    classes. Once we have done this, in the bottom section of our Python module, we
    create an instance of the wxPython application. Next, we instantiate our wxPython
    GUI code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在第一个`StaticBox`下方创建第二个`StaticBox`，我们创建了单独的`StaticBoxSizer`并将它们分配给同一个面板。我们在几个类中设计和布局我们的wxPython
    GUI。一旦完成，在Python模块的底部部分，我们创建wxPython应用程序的一个实例。接下来，我们实例化我们的wxPython GUI代码。
- en: After that, we call the main GUI event loop, which executes all of our Python
    code running within this application process. This displays our wxPython GUI.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用主GUI事件循环，它执行此应用程序进程中运行的全部Python代码。这显示了我们的wxPython GUI。
- en: This recipe used OOP to show how to use the wxPython GUI toolkit.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方使用了面向对象编程（OOP）来展示如何使用wxPython GUI工具包。
- en: Trying to embed a main wxPython app in a main tkinter app
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试在主tkinter应用程序中嵌入主wxPython应用程序
- en: Now that we have created the same GUI using both Python's built-in `tkinter`
    library as well as the wxPython wrapper of the wxWidgets library, we really would
    like to combine the GUIs we created using these technologies.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Python内置的`tkinter`库以及wxWidgets库的wxPython包装器创建了相同的GUI，我们真的希望结合使用这些技术创建的GUI。
- en: Both the wxPython and the `tkinter` libraries have their own advantages. In
    online forums, such as [http://stackoverflow.com/](http://stackoverflow.com/),
    we often see questions such as which one is better, which GUI toolkit should I
    use, and so on. This suggests that we have to make an either-or decision. In reality,
    we do not have to make such a decision.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython和`tkinter`库都有自己的优点。在在线论坛，如[http://stackoverflow.com/](http://stackoverflow.com/)，我们经常看到诸如哪个更好、我应该使用哪个GUI工具包等问题。这表明我们必须做出非此即彼的决定。实际上，我们不必做出这样的决定。
- en: One of the main challenges in doing so is that each GUI toolkit must have its
    own event loop. In this recipe, we will try to embed a simple wxPython GUI by
    calling it from our `tkinter` GUI.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做的主要挑战之一是，每个GUI工具包都必须有自己的事件循环。在这个配方中，我们将尝试通过从我们的`tkinter` GUI中调用它来嵌入一个简单的wxPython
    GUI。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will reuse the `tkinter` GUI we built in the *Combo box widgets *recipe in
    Chapter 1, *Creating the GUI Form and Adding Widgets*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用我们在第1章“创建GUI表单和添加小部件”中“组合框小部件”配方中构建的`tkinter` GUI。
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will start from a simple `tkinter` GUI:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的`tkinter` GUI开始：
- en: Create a new module and name it `Embed_wxPython.py`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，并将其命名为`Embed_wxPython.py`。
- en: 'Add the following code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the code and observe the following output:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察以下输出：
- en: '![](img/0c44febd-10d9-4bae-bf6e-9fd9023cef35.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c44febd-10d9-4bae-bf6e-9fd9023cef35.png)'
- en: 'Create a new function, `wxPythonApp`, and place it above the main loop:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的函数`wxPythonApp`，并将其放置在主循环之上：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the preceding code starts a wxPython GUI from our `tkinter` GUI after
    clicking the `tkinter` button control:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码会在点击`tkinter`按钮控件后从我们的`tkinter` GUI启动wxPython GUI：
- en: '![](img/ed9f5eaf-d5f4-4d7f-ba13-3677091cc514.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed9f5eaf-d5f4-4d7f-ba13-3677091cc514.png)'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we create a simple `tkinter` GUI and run it by itself. Next, we try to
    invoke a simple wxPython GUI, which we created in a previous recipe in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个简单的`tkinter` GUI并单独运行它。然后，我们尝试调用一个简单的wxPython GUI，这是我们在这个章节之前的一个配方中创建的。
- en: 'We create a new function, `wxPythonApp`, which has the wxPython code, and we
    place it above the `tkinter` button. After that, we set the `command` attribute
    of the button to this function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的函数，`wxPythonApp`，其中包含wxPython代码，并将其放置在`tkinter`按钮之上。之后，我们将按钮的`command`属性设置为这个函数：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The important part is that we place the entire wxPython code into its own function,
    which we named `def wxPythonApp()`. In the callback function for the button-click
    event, we simply call this code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们将整个wxPython代码放入一个名为`def wxPythonApp()`的单独函数中。在按钮点击事件的回调函数中，我们简单地调用这段代码。
- en: One thing to note is that we have to close the wxPython GUI before we can continue
    using the `tkinter` GUI.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是，我们必须在继续使用`tkinter` GUI之前关闭wxPython GUI。
- en: Trying to embed our tkinter GUI code into wxPython
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试将我们的tkinter GUI代码嵌入到wxPython中
- en: In this recipe, we will go in the opposite direction of the previous recipe
    and try to call our `tkinter` GUI code from within a wxPython GUI.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将与之前的配方相反，尝试在wxPython GUI中调用我们的`tkinter` GUI代码。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will reuse some of the wxPython GUI code we created in a previous recipe
    in this chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用本章之前菜谱中创建的一些 wxPython GUI 代码。
- en: How to do it…
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will start from a simple wxPython GUI:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的 wxPython GUI 开始：
- en: Create a new module and name it `Embed_tkinter.py`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块并将其命名为 `Embed_tkinter.py`。
- en: 'Add the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the code and observe the following output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察以下输出：
- en: '![](img/6fb9e9b9-6499-4942-b2ac-6049b59b3e74.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fb9e9b9-6499-4942-b2ac-6049b59b3e74.png)'
- en: 'Add the following code to the very top of the module:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到模块的顶部：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the code and click the Call tkinter GUI button.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并点击调用 tkinter GUI 按钮。
- en: In the `tkinter` GUI, enter some text and click the Print button.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tkinter` GUI 中输入一些文本并点击打印按钮。
- en: 'Type into the wxPython `TextCtrl` widget:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 wxPython 的 `TextCtrl` 小部件中输入：
- en: '![](img/0e005ca7-8bd0-4a4e-b977-99f4d91c369b.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e005ca7-8bd0-4a4e-b977-99f4d91c369b.png)'
- en: Run the code and click the Call tkinter GUI button several times.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并多次点击调用 tkinter GUI 按钮。
- en: 'Type into the `tkinter` GUIs and click the Print button:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tkinter` GUI 中输入并点击打印按钮：
- en: '![](img/ea624762-f334-46f2-bcb8-1498672c97d8.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea624762-f334-46f2-bcb8-1498672c97d8.png)'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解幕后，更好地理解代码。
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we went in the opposite direction of the previous recipe by
    first creating a GUI using wxPython and then, from within it, creating several
    GUI instances built using `tkinter`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们与之前的菜谱相反，首先使用 wxPython 创建了一个 GUI，然后从其中创建了几种使用 `tkinter` 构建的 GUI 实例。
- en: Running the `Embed_tkinter.py` code starts a `tkinter` GUI from our wxPython
    GUI after clicking the wxPython button widget. We can then enter text into the
    `tkinter` textbox and, by clicking its button, the button text gets updated with
    the name.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `Embed_tkinter.py` 代码在点击 wxPython 按钮小部件后从我们的 wxPython GUI 启动一个 `tkinter`
    GUI。然后我们可以输入文本到 `tkinter` 文本框中，并通过点击其按钮，按钮文本会更新为名称。
- en: After starting the `tkinter` event loop, the wxPython GUI is still responsive
    because we can still type into the `TextCtrl` widget while the `tkinter` GUI is
    up and running.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 `tkinter` 事件循环后，wxPython GUI 仍然可以响应，因为我们可以在 `tkinter` GUI 运行时仍然向 `TextCtrl`
    小部件中输入。
- en: In the previous recipe, we could not use our `tkinter` GUI until we had closed
    the wxPython GUI. Being aware of this difference can help our design decisions
    if we want to combine the two Python GUI technologies.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们无法使用我们的 `tkinter` GUI，直到我们关闭了 wxPython GUI。了解这种差异可以帮助我们做出设计决策，如果我们想结合这两种
    Python GUI 技术。
- en: We can also create several `tkinter` GUI instances by clicking the wxPython
    GUI button several times. We cannot, however, close the wxPython GUI while any
    `tkinter` GUIs are still running. We have to close them first.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过多次点击 wxPython GUI 按钮来创建几个 `tkinter` GUI 实例。然而，我们无法在 `tkinter` GUI 运行时关闭
    wxPython GUI。我们必须先关闭它们。
- en: The wxPython GUI remained responsive while one or more `tkinter` GUIs were running.
    However, clicking the `tkinter` button only updated its button text in the first
    instance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个或多个 `tkinter` GUI 运行时，wxPython GUI 仍然可以响应。然而，点击 `tkinter` 按钮只在其第一次更新按钮文本。
- en: Using Python to control two different GUI frameworks
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 控制两个不同的 GUI 框架
- en: In this recipe, we will explore ways to control the `tkinter` and wxPython GUI
    frameworks from Python. We have already used the Python threading module to keep
    our GUI responsive in [Chapter 6](802f3638-4c00-4d83-8f04-3acdb39b53ec.xhtml),
    *Threads and Networking*, so here we will attempt to use the same approach.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨从 Python 控制 `tkinter` 和 wxPython GUI 框架的方法。我们已经在第 6 章 [802f3638-4c00-4d83-8f04-3acdb39b53ec.xhtml]，*线程和网络*
    中使用了 Python 线程模块来保持我们的 GUI 响应，所以在这里我们将尝试使用相同的方法。
- en: We will see that things don't always work in a way that would be intuitive.
    However, we will improve our `tkinter` GUI from being unresponsive while we invoke
    an instance of the wxPython GUI from within it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到事情并不总是以直观的方式工作。然而，我们将改进我们的 `tkinter` GUI，使其在从内部调用 wxPython GUI 实例时不再无响应。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will extend a previous recipe from this chapter, *Trying to embed
    a main wxPython app in a main tkinter app*, in which we successfully tried to
    embed a main wxPython GUI into our `tkinter` GUI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将扩展本章之前的菜谱，*尝试在主 tkinter 应用程序中嵌入主 wxPython 应用程序*，其中我们成功地将主 wxPython GUI
    嵌入到我们的 `tkinter` GUI 中。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'When we created an instance of a wxPython GUI from our `tkinter` GUI, we could
    no longer use the `tkinter` GUI controls until we closed the one instance of the
    wxPython GUI. Let''s improve on this now:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 `tkinter` GUI 创建 wxPython GUI 实例时，我们不能再使用 `tkinter` GUI 控件，直到我们关闭一个 wxPython
    GUI 实例。现在让我们改进这一点：
- en: Create a new module and name it `Control_Frameworks_NOT_working.py`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，并将其命名为 `Control_Frameworks_NOT_working.py`。
- en: 'Write the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the code. Open some wxPython GUIs and type into the `tkinter` GUI:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。打开一些 wxPython GUI 并在 `tkinter` GUI 中输入：
- en: '![](img/d8121b9a-45da-4611-a14b-4bb191345a5a.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8121b9a-45da-4611-a14b-4bb191345a5a.png)'
- en: 'Close the GUIs:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 GUI：
- en: '![](img/ea830be4-e15a-4f17-a850-3d5b4b90fb39.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea830be4-e15a-4f17-a850-3d5b4b90fb39.png)'
- en: In order to avoid this crashing of the `Python.exe` executable process as shown
    in the preceding screenshot, instead of trying to run the entire wxPython application
    in a thread, we can change the code to make only the wxPython `app.MainLoop` run
    in a thread.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免如前一张截图所示，`Python.exe` 可执行进程崩溃的情况，我们不是在单独的线程中运行整个 wxPython 应用程序，而是可以将代码修改为只让
    wxPython 的 `app.MainLoop` 在一个线程中运行。
- en: Create a new module and name it `Control_Frameworks.py`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，并将其命名为 `Control_Frameworks.py`。
- en: 'Write the following code and run it:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码并运行：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's comprehend the steps in detail in the next section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中详细理解这些步骤。
- en: How it works…
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We first tried to run the entire wxPython GUI application in a thread, `Control_Frameworks_NOT_working.py`,
    but this did not work because the wxPython main event loop expects to be the main
    thread of the application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试在一个线程中运行整个 wxPython GUI 应用程序，即 `Control_Frameworks_NOT_working.py`，但这没有工作，因为
    wxPython 的主事件循环期望它是应用程序的主线程。
- en: At first, `Control_Frameworks_NOT_working.py` seems to be working, which would
    be intuitive, as the `tkinter` controls are no longer disabled and we can create
    several instances of the wxPython GUI by clicking the button. We can also type
    into the wxPython GUI and select the other `tkinter` widgets. However, once we
    try to close the GUIs, we get an error from wxWidgets and our Python executable
    crashes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Control_Frameworks_NOT_working.py` 似乎可以正常工作，这是直观的，因为 `tkinter` 控件不再被禁用，我们可以通过点击按钮创建几个
    wxPython GUI 实例。我们还可以在 wxPython GUI 中输入并选择其他的 `tkinter` 小部件。然而，当我们尝试关闭 GUI 时，我们会从
    wxWidgets 接收错误，并且我们的 Python 可执行文件会崩溃。
- en: We found a workaround, `Control_Frameworks.py`, for this by only running the
    wxPython `app.MainLoop` in a thread that tricks it into believing it is the main
    thread. One side effect of this approach is that we can no longer individually
    close all of the wxPython GUI instances. At least one of them only closes when
    we close the wxPython GUI that created the threads as daemons. You can test this
    out by clicking the Call wxPython GUI button once or several times and then try
    to close all the created wxPython window forms. We cannot close the last one until
    we close the calling `tkinter` GUI!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过只在一个线程中运行 wxPython 的 `app.MainLoop` 并使其相信它是主线程来解决这个问题，这个线程是一个技巧。这种方法的一个副作用是我们不能再单独关闭所有的
    wxPython GUI 实例。至少有一个实例只有在关闭创建线程作为守护进程的 wxPython GUI 时才会关闭。你可以通过点击一次或多次调用 wxPython
    GUI 按钮来测试这一点，然后尝试关闭所有创建的 wxPython 窗口表单。我们无法关闭最后一个，除非我们关闭调用的 `tkinter` GUI！
- en: I am not quite sure why this is. Intuitively, we might expect to be able to
    close all daemon threads without having to wait for the main thread that created
    them to close first. It possibly has to do with a reference counter not having
    been set to zero while our main thread is still running. On a pragmatic level,
    this is how it currently works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不完全清楚这是为什么。直观上，我们可能期望能够关闭所有守护线程，而无需等待创建它们的父线程首先关闭。这可能与我们的主线程仍在运行时引用计数器没有被设置为零有关。在实用层面上，这就是它目前的工作方式。
- en: Communicating between the two connected GUIs
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个连接的 GUI 之间的通信
- en: lIn this recipe, we will explore ways to make the two GUIs talk to each other.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨使两个 GUI 互相通信的方法。
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading the previous recipe might be a good preparation for this one.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前面的食谱可能是为这个食谱做准备的好方法。
- en: In this recipe, we will use the slightly modified GUI code with respect to the
    previous recipe, but most of the basic GUI-building code is the same.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用与上一个食谱略有修改的 GUI 代码，但大部分基本的 GUI 构建代码是相同的。
- en: How to do it…
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will write Python code that makes the two GUIs communicate with each other
    to a certain degree:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写 Python 代码，使两个 GUI 以一定程度的相互通信：
- en: Create a new module and name it `Communicate.py`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，并将其命名为 `Communicate.py`。
- en: 'Add the following code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the code and then perform the next step.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，然后执行下一步。
- en: 'Click both buttons and type into the controls:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击两个按钮并在控件中输入：
- en: '![](img/f332d976-ae5e-4838-8a7f-a28dc1150470.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f332d976-ae5e-4838-8a7f-a28dc1150470.png)'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解幕后，更好地理解代码。
- en: How it works…
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Running the `Communicate.py` code first creates the `tkinter` part of the program,
    and when we click the button in this GUI, it runs the wxPython GUI. Both are running
    at the same time as before, but this time there is an extra level of communication
    between the two GUIs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先运行`Communicate.py`代码创建程序的`tkinter`部分，当我们在这个GUI中点击按钮时，它运行wxPython GUI。两者都像之前一样同时运行，但这次在两个GUI之间有一个额外的通信层级。
- en: The `tkinter` GUI is shown on the left-hand side in the preceding screenshot,
    and by clicking the Call wxPython GUI button, we invoke an instance of the wxPython
    GUI. We can create several instances by clicking the button several times.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，`tkinter` GUI显示在左侧，通过点击Call wxPython GUI按钮，我们调用wxPython GUI的一个实例。我们可以通过多次点击按钮创建多个实例。
- en: All of the created GUIs remain responsive. They do not crash nor freeze.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所创建的GUI都保持响应。它们不会崩溃也不会冻结。
- en: Clicking the Print button on any of the wxPython GUI instances writes one sentence
    to its own `TextCtrl` widget and then writes another line to itself, as well as
    to the `tkinter` GUI. You will have to scroll up to see the first sentence in
    the wxPython GUI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何wxPython GUI实例上点击Print按钮会将一句话写入其自己的`TextCtrl`小部件，并将另一行写入自身以及`tkinter` GUI。您将需要向上滚动才能看到wxPython
    GUI中的第一句话。
- en: The way this works is by using a module-level queue and a `Text` widget of `tkinter`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作方式是通过使用模块级队列和`tkinter`的`Text`小部件。
- en: 'One important element to note is that we create a thread to run the wxPython
    `app.MainLoop`, as we did in the previous recipe:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的重要元素是，我们创建了一个线程来运行wxPython的`app.MainLoop`，就像我们在前面的菜谱中所做的那样：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We created a class that inherits from `wx.Panel` and named it `GUI` and then
    instantiated an instance of this class in the preceding code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个从`wx.Panel`继承的类，命名为`GUI`，然后在前面代码中实例化了该类的实例。
- en: 'We created a button-click event callback method in this class, which then calls
    the code that was written above it. Because of this, the class has access to the
    functions and can write to the shared queue:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们创建了一个按钮点击事件回调方法，然后调用上面编写的代码。正因为如此，这个类可以访问函数，并且可以写入共享队列：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We first check whether the data has been placed in the shared queue in the preceding method
    and, if that is the case, print the common data to both GUIs.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查在前面方法中数据是否已经放置在共享队列中，如果是这样，就将公共数据打印到两个GUI。
- en: The `putDataIntoQueue()` line places data into the queue and `readDataFromQueue()`
    reads it back out, saving it in the `data` variable. `text.insert('0.0', data)`
    is the line that writes this data into the `tkinter` GUI from the Print button's
    wxPython callback method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`putDataIntoQueue()`行将数据放入队列，`readDataFromQueue()`读取它，并将其保存在`data`变量中。`text.insert(''0.0'',
    data)`是将此数据写入`tkinter` GUI的Print按钮的wxPython回调方法的行。'
- en: 'The following functions are called in the code and make it work:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中调用了以下函数，使其工作：
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We used a simple boolean flag named `dataInQueue` to communicate when the data
    is available in the queue.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个简单的布尔标志`dataInQueue`来通信当数据在队列中可用时。
- en: In this recipe, we have successfully combined the two GUIs we created in a similar
    fashion, but which were previously standalone and not talking to each other. However,
    in this recipe, we connected them further by making one GUI launch another and,
    via a simple multiprocessing Python queue mechanism, we were able to make them
    communicate with each other, writing data from a shared queue into both GUIs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们成功地以类似的方式结合了我们创建的两个GUI，但它们之前是独立的，没有相互通信。然而，在这个菜谱中，我们通过使一个GUI启动另一个GUI，并通过简单的多进程Python队列机制，我们能够使它们相互通信，将共享队列中的数据写入两个GUI。
- en: There are many more advanced and complicated technologies available to connect
    different processes, threads, pools, locks, pipes, TCP/IP connections, and so
    on.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多更高级和复杂的技术可用于连接不同的进程、线程、池、锁、管道、TCP/IP连接等等。
- en: In the Pythonic spirit, we found a simple solution that works for us. Once our
    code becomes more complicated, we might have to refactor it, but this is a good
    beginning.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python精神下，我们找到了一个简单的解决方案，对我们来说很适用。一旦我们的代码变得更加复杂，我们可能需要重构它，但这是一个好的开始。
