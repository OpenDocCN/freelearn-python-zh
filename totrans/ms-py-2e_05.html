<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer110" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">5</h1>&#13;
    <h1 id="_idParaDest-125" class="chapterTitle">Functional Programming – Readability Versus Brevity</h1>&#13;
    <p class="normal">This chapter will show you some of the cool tricks that functional programming in Python gives you, and it will explain some of the limitations of Python’s implementation. For learning and entertainment, we will also briefly discuss the mathematical equivalent using lambda calculus, using the <strong class="keyWord">Y combinator</strong> as an example.</p>&#13;
    <p class="normal">The last few paragraphs will list and explain the usage of the <code class="inlineCode">functools</code> and <code class="inlineCode">itertools</code> libraries. If you are familiar with these libraries, feel free to skip them, but note that some of these will be used heavily in the later chapters about decorators (<em class="chapterRef">Chapter 6</em>), generators (<em class="chapterRef">Chapter 7</em>), and performance (<em class="chapterRef">Chapter 12</em>).</p>&#13;
    <p class="normal">These are the topics covered in this chapter:</p>&#13;
    <ul>&#13;
      <li class="bulletList">The theory behind functional programming</li>&#13;
      <li class="bulletList"><code class="inlineCode">list</code>, <code class="inlineCode">dict</code>, and <code class="inlineCode">set</code> comprehensions</li>&#13;
      <li class="bulletList"><code class="inlineCode">lambda</code> functions</li>&#13;
      <li class="bulletList"><code class="inlineCode">functools</code> (<code class="inlineCode">partial</code> and <code class="inlineCode">reduce</code>)</li>&#13;
      <li class="bulletList"><code class="inlineCode">itertools</code> (<code class="inlineCode">accumulate</code>, <code class="inlineCode">chain</code>, <code class="inlineCode">dropwhile</code>, <code class="inlineCode">starmap</code>, and so on)</li>&#13;
    </ul>&#13;
    <p class="normal">First, we will begin with a bit of history about functional programming in Python and what functional programming actually means.</p>&#13;
    <h1 id="_idParaDest-126" class="heading-1">Functional programming</h1>&#13;
    <p class="normal">Functional programming is <a id="_idIndexMarker331"/>a paradigm that originates from the lambda calculus (λ-calculus), a formal system in mathematics that can be used to simulate any Turing machine. Without diving too much into the λ-calculus, this means that computation is performed using only the function arguments as input and that the output consists of a new variable without mutating the input variables. With a strictly functional programming language this behavior would be enforced, but since Python is not a strictly functional language, this doesn’t necessarily hold true. </p>&#13;
    <p class="normal">It is still a good idea to adhere to this paradigm since mixing paradigms can cause unforeseen bugs, as discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">Pythonic Syntax and Common Pitfalls</em>.</p>&#13;
    <h2 id="_idParaDest-127" class="heading-2">Purely functional</h2>&#13;
    <p class="normal">Purely functional programming<a id="_idIndexMarker332"/> expects functions to have no side effects. That means that arguments given to the function should not be mutated, and neither should any other external states. Let’s illustrate this with a simple example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span> <span class="hljs-con-title">add_value_functional</span>(items, value):&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> items + [value]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items = [<span class="hljs-con-number">1</span>,<span class="hljs-con-number"> 2</span>,<span class="hljs-con-number"> 3</span>]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> add_value_functional(items, <span class="hljs-con-number">5</span>)&#13;
[1, 2, 3, 5]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items&#13;
[1, 2, 3]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add_value_regular</span><span class="hljs-con-function">(</span><span class="hljs-con-params">items, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     items.append(value)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> items&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> add_value_regular(items, <span class="hljs-con-number">5</span>)&#13;
[1, 2, 3, 5]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items&#13;
[1, 2, 3, 5]&#13;
</code></pre>&#13;
    <p class="normal">That essentially shows the difference between a regular function and a purely functional one. The first function returns a <em class="italic">new </em>value purely based on the input, without any other side effects. This is in comparison to the second function, which modifies the given input or even variables outside of its scope.</p>&#13;
    <p class="normal">Even outside of functional programming, limiting your changes to local variables only is a good idea. Keeping<a id="_idIndexMarker333"/> functions purely functional (relying only on the given input) makes code clearer, easier to understand, and better to test as there are fewer dependencies. Well-known examples can be found within the <code class="inlineCode">math</code> module. These functions (<code class="inlineCode">sin</code>, <code class="inlineCode">cos</code>, <code class="inlineCode">pow</code>, <code class="inlineCode">sqrt</code>, and so on) have an input and an output that is strictly dependent on the input.</p>&#13;
    <h2 id="_idParaDest-128" class="heading-2">Functional programming and Python</h2>&#13;
    <p class="normal">Python is <a id="_idIndexMarker334"/>one of the few, or at least earliest, non-functional programming languages to add functional programming features. The initial few functional programming functions were introduced around 1993, and these were <code class="inlineCode">lambda</code>, <code class="inlineCode">reduce</code>, <code class="inlineCode">filter</code>, and <code class="inlineCode">map</code>. Since that time, Guido van Rossum has been less than happy with their existence because they often make readability suffer. Additionally, functions such as <code class="inlineCode">map</code> and <code class="inlineCode">filter</code> can easily be replicated using <code class="inlineCode">list</code> comprehensions. Because of this, Guido wanted to remove these functions with the Python 3 release, but after a lot of resistance he opted for moving at least the <code class="inlineCode">reduce</code> function to <code class="inlineCode">functools.reduce</code>.</p>&#13;
    <p class="normal">Since then, several other<a id="_idIndexMarker335"/> functional programming features have been added to Python:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">list</code>/<code class="inlineCode">dict</code>/<code class="inlineCode">set</code> comprehensions</li>&#13;
      <li class="bulletList">Generator expressions</li>&#13;
      <li class="bulletList">Generator functions</li>&#13;
      <li class="bulletList">Coroutines</li>&#13;
    </ul>&#13;
    <p class="normal">There are also a host of useful functions in the <code class="inlineCode">functools</code> and <code class="inlineCode">itertools</code> modules.</p>&#13;
    <h2 id="_idParaDest-129" class="heading-2">Advantages of functional programming</h2>&#13;
    <p class="normal">The<a id="_idIndexMarker336"/> big question is, of course, why would you want to use functional programming instead of regular/procedural programming? There are multiple advantages to writing code in a functional style:</p>&#13;
    <ul>&#13;
      <li class="bulletList">One major advantage of writing purely functional code is that it becomes trivially easy to run in parallel. Because there are no external variables needed and no external variables changed, you can easily parallelize the code to run on multiple processors or even on multiple machines. Assuming you can easily transfer the input variables and output results, of course.</li>&#13;
      <li class="bulletList">Because the functions are self-contained and don’t have any side effects, they mitigate several kinds of bugs. Mutating function arguments in-place, for example, is a great source of bugs. Additionally, a seemingly useless function call that modifies a variable in the parent scope couldn’t exist in a purely functional codebase.</li>&#13;
      <li class="bulletList">It makes testing much easier. If a function only has a given input and output and does not touch anything outside of those, you can test without having to set up an entire environment for that function. It also omits the need for sandboxing functions while testing them.</li>&#13;
    </ul>&#13;
    <p class="normal">Naturally, functional programming<a id="_idIndexMarker337"/> also comes with a few drawbacks, several of which are caused by the same advantages.</p>&#13;
    <p class="normal">In some cases it can be a hassle to pass along all useful arguments all of the time. When modifying a database for example, you need to get the database connection somehow. If you decide to pass the database connection as an argument and did not prepare for that, you will need to modify not just that function but all the calling functions as well to pass along that argument. In those cases a globally accessible variable containing the database connection could save you a lot of work.</p>&#13;
    <p class="normal">Another often-touted downside of functional programming is recursion. While recursion is a very useful tool, it can make it much harder to trace the code execution path, which can be a problem when solving bugs.</p>&#13;
    <p class="normal">Functional programming has its place and its time. It’s not suited for every situation but when applied correctly it is a very useful tool for your toolbox. Now let’s continue with some examples of functional programming.</p>&#13;
    <h1 id="_idParaDest-130" class="heading-1">list, set, and dict comprehensions</h1>&#13;
    <p class="normal">The<a id="_idIndexMarker338"/> Python <code class="inlineCode">list</code>, <code class="inlineCode">set</code>, and <code class="inlineCode">dict</code> comprehensions are a very easy way to apply a function or <a id="_idIndexMarker339"/>filter to a list of items. </p>&#13;
    <p class="normal">When used correctly, <code class="inlineCode">list</code>/<code class="inlineCode">set</code>/<code class="inlineCode">dict</code> comprehensions can be really useful for quick filtering or transforming <a id="_idIndexMarker340"/>of lists, sets, and dicts. The same results can be achieved using the “functional” functions <code class="inlineCode">map</code> and <code class="inlineCode">filter</code>, but <code class="inlineCode">list</code>/<code class="inlineCode">set</code>/<code class="inlineCode">dict</code> comprehensions are often easier to use and also easier to read.</p>&#13;
    <h2 id="_idParaDest-131" class="heading-2">Basic list comprehensions</h2>&#13;
    <p class="normal">Let’s dive<a id="_idIndexMarker341"/> right into a few examples. The basic premise of a <code class="inlineCode">list</code> comprehension looks like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> squares = [x ** <span class="hljs-con-number">2</span> <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>)]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> squares&#13;
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&#13;
</code></pre>&#13;
    <p class="normal">We can easily expand this with a filter:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> odd_squares = [x ** <span class="hljs-con-number">2</span> <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>) <span class="hljs-con-keyword">if</span> x % <span class="hljs-con-number">2</span>]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> odd_squares&#13;
[1, 9, 25, 49, 81]&#13;
</code></pre>&#13;
    <p class="normal">This brings us to the version that is common in most functional languages using <code class="inlineCode">map</code> and <code class="inlineCode">filter</code>: </p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">square</span><span class="hljs-con-function">(</span><span class="hljs-con-params">x</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> x ** <span class="hljs-con-number">2</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">odd</span><span class="hljs-con-function">(</span><span class="hljs-con-params">x</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> x % <span class="hljs-con-number">2</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> squares = <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">map</span>(square, <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>)))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> squares&#13;
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> odd_squares = <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">filter</span>(odd, <span class="hljs-con-built_in">map</span>(square, <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>))))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> odd_squares&#13;
[1, 9, 25, 49, 81]&#13;
</code></pre>&#13;
    <p class="normal">After seeing this it becomes slightly more obvious why Guido van Rossum wanted to remove these from the language. In particular, the version using both <code class="inlineCode">filter</code> and <code class="inlineCode">map</code> isn’t all that readable given the number of parentheses, unless you’re used to the Lisp programming language, that is.</p>&#13;
    <p class="normal">The most important application of <code class="inlineCode">map</code> is actually not using <code class="inlineCode">map</code> itself, but using one of the <code class="inlineCode">map</code>-like functions such as <code class="inlineCode">multiprocessing.pool.Pool.map</code> and variants such as <code class="inlineCode">map_async</code>, <code class="inlineCode">imap</code>, <code class="inlineCode">starmap</code>, <code class="inlineCode">starmap_async</code>, and <code class="inlineCode">imap_unordered</code>, which automatically execute the functions in parallel on multiple processors.</p>&#13;
    <p class="normal">While I am personally not against <code class="inlineCode">map</code> or <code class="inlineCode">filter</code>, I think their usage should be reserved for cases <a id="_idIndexMarker342"/>where you have an existing function available to use in the <code class="inlineCode">map</code> or <code class="inlineCode">filter</code> call. A somewhat more useful example would be:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> os&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> directories = <span class="hljs-con-built_in">filter</span>(os.path.isdir, os.listdir(<span class="hljs-con-string">'.'</span>))&#13;
<span class="hljs-con-comment"># Versus:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> directories = [x <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> os.listdir(<span class="hljs-con-string">'.'</span>) <span class="hljs-con-keyword">if</span> os.path.isdir(x)]&#13;
</code></pre>&#13;
    <p class="normal">In this case, the <code class="inlineCode">filter</code> version might be slightly more readable than the <code class="inlineCode">list</code> comprehension.</p>&#13;
    <p class="normal">As for the <code class="inlineCode">list</code> comprehensions, the syntax is pretty close to regular Python for loops, but the <code class="inlineCode">if</code> statement and automatic storing of results make it quite useful to condense code slightly. The regular Python equivalent is not much longer:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> odd_squares = []&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>):&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> x % <span class="hljs-con-number">2</span>:&#13;
<span class="hljs-con-meta">...</span>         odd_squares.append(x ** <span class="hljs-con-number">2</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> odd_squares&#13;
[1, 9, 25, 49, 81]&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-132" class="heading-2">set comprehensions</h2>&#13;
    <p class="normal">In <a id="_idIndexMarker343"/>addition to <code class="inlineCode">list</code> comprehensions, we can also use a <code class="inlineCode">set</code> comprehension, which has the same syntax but returns a unique and unordered (all sets are unordered) set instead:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># List comprehension</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [x // <span class="hljs-con-number">2</span> <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>)]&#13;
[0, 0, 1]&#13;
&#13;
<span class="hljs-con-comment"># Set comprehension</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> numbers = {x // <span class="hljs-con-number">2</span> <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>)}&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span>(numbers)&#13;
[0, 1]&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-133" class="heading-2">dict comprehensions</h2>&#13;
    <p class="normal">Lastly, we<a id="_idIndexMarker344"/> have <code class="inlineCode">dict</code> comprehensions, which return a <code class="inlineCode">dict</code> instead of a <code class="inlineCode">list</code> or <code class="inlineCode">set</code>.</p>&#13;
    <p class="normal">Beyond the return type, the only real difference is that you need to return both a key and a value. The following is a basic example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> {x: x ** <span class="hljs-con-number">2</span> <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">6</span>)}&#13;
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> {x: x ** <span class="hljs-con-number">2</span> <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">6</span>) <span class="hljs-con-keyword">if</span> x % <span class="hljs-con-number">2</span>}&#13;
{1: 1, 3: 9, 5: 25}&#13;
</code></pre>&#13;
    <div class="note">&#13;
      <p class="normal">Since the output is a dictionary, the key needs to be hashable for the <code class="inlineCode">dict</code> comprehension to work. We covered hashing in <em class="chapterRef">Chapter 4</em>, but the short version is that <code class="inlineCode">hash(key)</code> needs to return a consistent value for your object. That means that hashing mutable objects such as lists is not possible.</p>&#13;
    </div>&#13;
    <p class="normal">The funny thing is that you can mix these two, of course, for even more unreadable magic:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> {x ** <span class="hljs-con-number">2</span>: [y <span class="hljs-con-keyword">for</span> y <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(x)] <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">5</span>)}&#13;
{0: [], 1: [0], 4: [0, 1], 16: [0, 1, 2, 3], 9: [0, 1, 2]}&#13;
</code></pre>&#13;
    <p class="normal">Obviously, you need to be careful with these. They can be very useful if used correctly, but the output quickly becomes unreadable, even with proper whitespace.</p>&#13;
    <h2 id="_idParaDest-134" class="heading-2">Comprehension pitfalls</h2>&#13;
    <p class="normal">When using <a id="_idIndexMarker345"/>comprehensions, some care must be taken. Some types <a id="_idIndexMarker346"/>of operations are not as obvious as you <a id="_idIndexMarker347"/>might expect. This time, we are looking for random numbers greater than <code class="inlineCode">0.5</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> random&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [random.random() <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>) <span class="hljs-con-keyword">if</span> random.random() &gt;= <span class="hljs-con-number">0.5</span>]&#13;
[0.5211948104577864, 0.650010512129705, 0.021427316545174158]&#13;
</code></pre>&#13;
    <p class="normal">See that last number? It’s actually less than <code class="inlineCode">0.5</code>. This happens because the first and the last random calls are actually separate calls and return different results.</p>&#13;
    <p class="normal">One way<a id="_idIndexMarker348"/> to counter this is by creating the list separately from the filter:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> random&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> numbers = [random.random() <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>)]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [x <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> numbers <span class="hljs-con-keyword">if</span> x &gt;= <span class="hljs-con-number">0.5</span>]&#13;
[0.715510247827078, 0.8426277505519564, 0.5071133900377911]&#13;
</code></pre>&#13;
    <p class="normal">That <a id="_idIndexMarker349"/>obviously <a id="_idIndexMarker350"/>works, but it’s not all that pretty. So what other options are there? Well, there are a few but the readability is a bit questionable, so these are not the solutions that I would recommend. It’s good to see them at least once, however.</p>&#13;
    <p class="normal">Here is a <code class="inlineCode">list</code> comprehension within a <code class="inlineCode">list</code> comprehension:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> random&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [x <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> [random.random() <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>)] <span class="hljs-con-keyword">if</span> x &gt;= <span class="hljs-con-number">0.5</span>]&#13;
</code></pre>&#13;
    <p class="normal">And here’s one that quickly becomes an incomprehensible <code class="inlineCode">list</code> comprehension:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> random&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [x <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>) <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> [random.random()] <span class="hljs-con-keyword">if</span> x &gt;= <span class="hljs-con-number">0.5</span>]&#13;
</code></pre>&#13;
    <p class="normal">Caution is needed with these options as the double list comprehension actually works like a nested <code class="inlineCode">for</code> loop would, so it quickly generates a lot of results. To elaborate on this, consider:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> [(x, y) <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>) <span class="hljs-con-keyword">for</span> y <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>, <span class="hljs-con-number">5</span>)]&#13;
[(0, 3), (0, 4), (1, 3), (1, 4), (2, 3), (2, 4)]&#13;
</code></pre>&#13;
    <p class="normal">This effectively does the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> results = []&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>):&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> y <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>, <span class="hljs-con-number">5</span>):&#13;
<span class="hljs-con-meta">...</span>         results.append((x, y))&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> results&#13;
[(0, 3), (0, 4), (1, 3), (1, 4), (2, 3), (2, 4)]&#13;
</code></pre>&#13;
    <p class="normal">These can be useful for some cases, but I would strongly recommend against nesting comprehensions as this quickly results in unreadable code. Understanding what is happening<a id="_idIndexMarker351"/> is still useful, however, so let’s look at one more example. The following <code class="inlineCode">list</code> comprehension <a id="_idIndexMarker352"/>swaps the column and row counts, so a 3 x 4 matrix becomes 4 x 3:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> matrix = [&#13;
<span class="hljs-con-meta">...</span>     [<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">4</span>],&#13;
<span class="hljs-con-meta">...</span>     [<span class="hljs-con-number">5</span>, <span class="hljs-con-number">6</span>, <span class="hljs-con-number">7</span>, <span class="hljs-con-number">8</span>],&#13;
<span class="hljs-con-meta">...</span>     [<span class="hljs-con-number">9</span>, <span class="hljs-con-number">10</span>, <span class="hljs-con-number">11</span>, <span class="hljs-con-number">12</span>],&#13;
<span class="hljs-con-meta">...</span> ]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> reshaped_matrix = [&#13;
<span class="hljs-con-meta">...</span>     [&#13;
<span class="hljs-con-meta">...</span>         [y <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> matrix <span class="hljs-con-keyword">for</span> y <span class="hljs-con-keyword">in</span> x][i * <span class="hljs-con-built_in">len</span>(matrix) + j]&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">for</span> j <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-built_in">len</span>(matrix))&#13;
<span class="hljs-con-meta">...</span>     ]&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-built_in">len</span>(matrix[<span class="hljs-con-number">0</span>]))&#13;
<span class="hljs-con-meta">...</span> ]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pprint&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pprint.pprint(reshaped_matrix, width=<span class="hljs-con-number">40</span>)&#13;
[[1, 2, 3],&#13;
 [4, 5, 6],&#13;
 [7, 8, 9],&#13;
 [10, 11, 12]]&#13;
</code></pre>&#13;
    <p class="normal">Even with <a id="_idIndexMarker353"/>the extra indentation, the <code class="inlineCode">list</code> comprehension just isn’t all that readable. With four nested loops, that is expectedly so, of course. There are rare cases where nested list comprehensions might be justified, such as very basic matrix manipulation. In the general case, however, I would not recommend using nested comprehensions.</p>&#13;
    <p class="normal">Next up, we will look at <code class="inlineCode">lambda</code> functions, which can be combined with <code class="inlineCode">map</code> and <code class="inlineCode">filter</code> for short convenient functions. </p>&#13;
    <h1 id="_idParaDest-135" class="heading-1">lambda functions</h1>&#13;
    <p class="normal">The <code class="inlineCode">lambda</code> statement<a id="_idIndexMarker354"/> in Python is simply an anonymous function. Due to the syntax, it is slightly more limited than regular functions, but a lot can be done through it. As always though, readability counts, so generally it is a good idea to keep it as<a id="_idIndexMarker355"/> simple as possible. One of the more common use cases is as the <code class="inlineCode">sort</code> key for the <code class="inlineCode">sorted</code> function:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> operator&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> values = <span class="hljs-con-built_in">dict</span>(one=<span class="hljs-con-number">1</span>, two=<span class="hljs-con-number">2</span>, three=<span class="hljs-con-number">3</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span>(values.items())&#13;
[('one', 1), ('three', 3), ('two', 2)]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span>(values.items(), key=<span class="hljs-con-keyword">lambda</span> item: item[<span class="hljs-con-number">1</span>])&#13;
[('one', 1), ('two', 2), ('three', 3)]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> get_value = operator.itemgetter(<span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span>(values.items(), key=get_value)&#13;
[('one', 1), ('two', 2), ('three', 3)]&#13;
</code></pre>&#13;
    <p class="normal">The first version sorts by key and the second sorts by the value. The last one shows an alternative option using <code class="inlineCode">operator.itemgetter</code> to generate a function that gets a specific item.</p>&#13;
    <p class="normal">The regular (non-lambda) function wouldn’t be much more verbose but in these cases, a lambda function is a very useful shorthand. For completeness, let’s look at both identical functions:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> key = <span class="hljs-con-keyword">lambda</span> item: item[<span class="hljs-con-number">1</span>]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">key</span><span class="hljs-con-function">(</span><span class="hljs-con-params">item</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> item[<span class="hljs-con-number">1</span>]&#13;
</code></pre>&#13;
    <p class="normal">Do note that <code class="inlineCode">PEP8</code> dictates that assigning a lambda to a variable is a bad idea (<a href="https://peps.python.org/pep-0008/#programming-recommendations"><span class="url">https://peps.python.org/pep-0008/#programming-recommendations</span></a>). And logically, it is. The idea of an anonymous function is that it is just that—anonymous and without a name. If you are giving it an identity, you should define it as a normal function. </p>&#13;
    <p class="normal">In my opinion, the only valid use case for a <code class="inlineCode">lambda</code> function is as an anonymous one-line argument to a function such as <code class="inlineCode">sorted()</code>.</p>&#13;
    <h2 id="_idParaDest-136" class="heading-2">The Y combinator</h2>&#13;
    <div class="note">&#13;
      <p class="normal">This section can easily be skipped. It is mostly an example of the mathematical value of the lambda statement.</p>&#13;
    </div>&#13;
    <p class="normal">The Y combinator <a id="_idIndexMarker356"/>is probably the most famous example of the λ-calculus:</p>&#13;
    <p class="center"><a id="_idIndexMarker357"/><img src="Images/B15882_05_001.png" alt="" style="height: 1.7em !important;" width="298" height="29"/></p>&#13;
    <p class="normal">All this looks very complicated, but that’s mostly because it uses the lambda calculus notation, which is not all that difficult if you look beyond the special characters. </p>&#13;
    <p class="normal">To illustrate, you should read this syntax, <a id="_idIndexMarker358"/><img src="Images/B15882_05_002.png" alt="" style="height: 1.3em !important;" width="58" height="25"/>, as an anonymous (lambda) function that takes <em class="italic">x</em> as an input and returns <a id="_idIndexMarker359"/><img src="Images/B15882_05_003.png" alt="" style="height: 1.25em !important;" width="24" height="26"/>. In Python, this would be expressed almost exactly as it is in the original lambda calculus, except for replacing <a id="_idIndexMarker360"/><img src="Images/B15882_05_004.png" alt="" style="height: 1.7em !important;" width="13" height="25"/> with <code class="inlineCode">lambda</code> and <code class="inlineCode">.</code> with <code class="inlineCode">:</code>, so it results in <code class="inlineCode">lambda x: x**2</code>.</p>&#13;
    <p class="normal">With some algebra (<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus"><span class="url">https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus</span></a>), the Y combinator can be reduced to <a id="_idIndexMarker361"/><img src="Images/B15882_05_005.png" alt="" style="height: 1.5em !important;" width="116" height="29"/>, or a function that takes the <a id="_idIndexMarker362"/><img src="Images/B15882_05_006.png" alt="" style="height: 1.5em !important;" width="14" height="27"/> function and applies it to itself. The λ-calculus notation of this function is as follows:</p>&#13;
    <p class="center"><a id="_idIndexMarker363"/><img src="Images/B15882_05_007.png" alt="" style="height: 1.7em !important;" width="96" height="30"/></p>&#13;
    <p class="normal">Here is the Python notation for the <code class="inlineCode">lambda</code> functions:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Y = <span class="hljs-keyword">lambda</span> f: <span class="hljs-keyword">lambda</span> *args: f(Y(f))(*args)&#13;
</code></pre>&#13;
    <p class="normal">Or the regular function version:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">Y</span><span class="hljs-function">(</span><span class="hljs-params">f</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">y</span><span class="hljs-function">(</span><span class="hljs-params">*args</span><span class="hljs-function">):</span>&#13;
        y_function = f(Y(f))&#13;
        <span class="hljs-keyword">return</span> y_function(*args)&#13;
    <span class="hljs-keyword">return</span> y&#13;
</code></pre>&#13;
    <p class="normal">This all <a id="_idIndexMarker364"/>comes down to a function that accepts a function <code class="inlineCode">f</code> which gets called with that function as an argument using the <code class="inlineCode">Y</code> combinator.</p>&#13;
    <p class="normal">This might still be a bit unclear, so let’s look at an example that actually uses it:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> Y = <span class="hljs-con-keyword">lambda</span> f: <span class="hljs-con-keyword">lambda</span> *args: f(Y(f))(*args)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">factorial</span><span class="hljs-con-function">(</span><span class="hljs-con-params">combinator</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_factorial</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> n:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">return</span> n * combinator(n - <span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">return</span> <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> _factorial&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Y(factorial)(<span class="hljs-con-number">5</span>)&#13;
120&#13;
</code></pre>&#13;
    <p class="normal">The following is the short version, where the power of the Y combinator becomes more apparent, with a recursive anonymous function:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> Y = <span class="hljs-con-keyword">lambda</span> f: <span class="hljs-con-keyword">lambda</span> *args: f(Y(f))(*args)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Y(<span class="hljs-con-keyword">lambda</span> c: <span class="hljs-con-keyword">lambda</span> n: n <span class="hljs-con-keyword">and</span> n * c(n - <span class="hljs-con-number">1</span>) <span class="hljs-con-keyword">or</span> <span class="hljs-con-number">1</span>)(<span class="hljs-con-number">5</span>)&#13;
120&#13;
</code></pre>&#13;
    <p class="normal">Note that the <code class="inlineCode">n and n * c(n – 1) or 1</code> part is short for the <code class="inlineCode">if</code> statement used in the longer version of the function. Alternatively, this can be written using the Python ternary operator:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> Y = <span class="hljs-con-keyword">lambda</span> f: <span class="hljs-con-keyword">lambda</span> *args: f(Y(f))(*args)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Y(<span class="hljs-con-keyword">lambda</span> c: <span class="hljs-con-keyword">lambda</span> n: n * c(n - <span class="hljs-con-number">1</span>) <span class="hljs-con-keyword">if</span> n <span class="hljs-con-keyword">else</span> <span class="hljs-con-number">1</span>)(<span class="hljs-con-number">5</span>)&#13;
120&#13;
</code></pre>&#13;
    <p class="normal">You might be wondering about the point of this entire exercise. You could easily write a factorial function in regular Python that is shorter, easier and more idiomatic. So what is the point of the Y combinator? The Y combinator<a id="_idIndexMarker365"/> allows us to make a non-recursive function execute in a recursive way.</p>&#13;
    <p class="normal">More importantly, however, I think it is an interesting demonstration of the power of Python — how you can implement something as fundamental as the lambda-calculus in a few lines of Python. I think it has a certain kind of beauty in its implementation. </p>&#13;
    <p class="normal">One final example of the <code class="inlineCode">Y</code> combinator will be given by the definition of <code class="inlineCode">quicksort</code> in a few lines:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> quicksort = Y(<span class="hljs-con-keyword">lambda</span> f:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">lambda</span> x: (&#13;
<span class="hljs-con-meta">...</span>         f([item <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> x <span class="hljs-con-keyword">if</span> item &lt; x[<span class="hljs-con-number">0</span>]])&#13;
<span class="hljs-con-meta">...</span>         + [y <span class="hljs-con-keyword">for</span> y <span class="hljs-con-keyword">in</span> x <span class="hljs-con-keyword">if</span> x[<span class="hljs-con-number">0</span>] == y]&#13;
<span class="hljs-con-meta">...</span>         + f([item <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> x <span class="hljs-con-keyword">if</span> item &gt; x[<span class="hljs-con-number">0</span>]])&#13;
<span class="hljs-con-meta">...</span>     ) <span class="hljs-con-keyword">if</span> x <span class="hljs-con-keyword">else</span> [])&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> quicksort([<span class="hljs-con-number">1</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">5</span>, <span class="hljs-con-number">4</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">2</span>])&#13;
[1, 1, 2, 3, 3, 4, 5]&#13;
</code></pre>&#13;
    <p class="normal">While the Y combinator most likely doesn’t have much practical use in Python, it does show the power of the <code class="inlineCode">lambda</code> statement and how close Python is to the fundamental mathematics behind it. Essentially, the difference is only in the notation and not in the functionality.</p>&#13;
    <p class="normal">Now that we know how to write our own <code class="inlineCode">lambda</code> and functional functions, we will take a look at the bundled functional functions in Python.</p>&#13;
    <h1 id="_idParaDest-137" class="heading-1">functools</h1>&#13;
    <p class="normal">In <a id="_idIndexMarker366"/>addition to the <code class="inlineCode">list/dict/set</code> comprehensions, Python also has a few (more advanced) functions that can be really convenient when coding functionally. The <code class="inlineCode">functools</code> library is a collection of functions that return callable objects. Some of these functions are used as decorators (we’ll cover more about that in <em class="chapterRef">Chapter 6</em>, <em class="italic">Decorators – Enabling Code Reuse by Decorating</em>), but the ones that we are going to talk about are used as straight-up functions to make your life easier.</p>&#13;
    <h2 id="_idParaDest-138" class="heading-2">partial – Prefill function arguments</h2>&#13;
    <p class="normal">The <code class="inlineCode">partial</code> function<a id="_idIndexMarker367"/> is<a id="_idIndexMarker368"/> really convenient for adding some default arguments to a function that you use often but can’t (or don’t want to) redefine. With object-oriented code, you can usually work around cases <a id="_idIndexMarker369"/>similar to these, but with procedural code, you will often have to repeat your arguments. Let’s take the <code class="inlineCode">heapq</code> functions from <em class="chapterRef">Chapter 4</em>, <em class="italic">Pythonic Design Patterns</em>, as an example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> heapq&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heap = []&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heapq.heappush(heap, <span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heapq.heappush(heap, <span class="hljs-con-number">3</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heapq.heappush(heap, <span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heapq.heappush(heap, <span class="hljs-con-number">2</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heapq.heappush(heap, <span class="hljs-con-number">4</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heapq.nsmallest(<span class="hljs-con-number">3</span>, heap)&#13;
[1, 2, 3]&#13;
</code></pre>&#13;
    <p class="normal">Almost all of the <code class="inlineCode">heapq</code> functions require a <code class="inlineCode">heap</code> argument, so we are going to make a shortcut that automatically fills the <code class="inlineCode">heap</code> variable for us. This could easily be done with a regular function of course:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">push</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> heapq.heappush(heap, *args, **kwargs)&#13;
</code></pre>&#13;
    <p class="normal">There is an easier method, however. Python comes bundled with a function called <code class="inlineCode">functools.partial</code> that generates a function with pre-filled arguments:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> functools&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> heapq&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heap = []&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> push = functools.partial(heapq.heappush, heap)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> smallest = functools.partial(heapq.nsmallest, iterable=heap)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> push(<span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> push(<span class="hljs-con-number">3</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> push(<span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> push(<span class="hljs-con-number">2</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> push(<span class="hljs-con-number">4</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> smallest(<span class="hljs-con-number">3</span>)&#13;
[1, 2, 3]&#13;
</code></pre>&#13;
    <p class="normal">With <code class="inlineCode">functools.partial</code> we can automatically fill in positional and/or keyword arguments for us. So a call to <code class="inlineCode">push(...)</code> is automatically expanded to <code class="inlineCode">heapq.heappush(heap, ...)</code>.</p>&#13;
    <p class="normal">Why <a id="_idIndexMarker370"/>should we use <code class="inlineCode">partial</code> instead of writing a <code class="inlineCode">lambda</code> argument? Well, it’s mostly about convenience, but it also helps solve the late binding problem discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">Pythonic Syntax and Common Pitfalls</em>. Additionally, partial <a id="_idIndexMarker371"/>functions still behave somewhat similarly to the original function, which means they still have the documentation available and can be pickled, whereas <code class="inlineCode">lambda</code> statements cannot.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The <code class="inlineCode">pickle</code> module in Python allows serialization of many complex Python objects, but not all by default. The <code class="inlineCode">lambda</code> functions have no defined <code class="inlineCode">pickle</code> method by default, but this can be worked around by defining your own lambda-pickle method in <code class="inlineCode">copy_reg.dispatch_table</code>. An easy way to achieve this is by using the <code class="inlineCode">dill</code> library, which contains a whole range of <code class="inlineCode">pickle</code> helpers.</p>&#13;
    </div>&#13;
    <p class="normal">To illustrate the difference between <code class="inlineCode">lambda</code> and <code class="inlineCode">functools.partial</code>, look at the following example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> lambda_push = <span class="hljs-con-keyword">lambda</span> x: heapq.heappush(heap, x)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heapq.heappush&#13;
&lt;built-in function heappush&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> push&#13;
functools.partial(&lt;built-in function heappush&gt;, [1, 2, 5, 3, 4])&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> lambda_push&#13;
&lt;function &lt;lambda&gt; at ...&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heapq.heappush.__doc__&#13;
'Push item onto heap, maintaining the heap invariant.'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> push.__doc__&#13;
'partial(func, *args, **keywords) - new function ...'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> lambda_push.__doc__&#13;
</code></pre>&#13;
    <p class="normal">Note how the <code class="inlineCode">lambda_push.__doc__</code> doesn’t return anything and the <code class="inlineCode">lambda</code> only has a very unhelpful <code class="inlineCode">&lt;function &lt;lambda&gt; ...&gt;</code> representation string. This is one of the reasons that <code class="inlineCode">functools.partial</code> is far more convenient to use in practice. It shows the documentation from the reference function; the representation string shows exactly what it is <a id="_idIndexMarker372"/>doing<a id="_idIndexMarker373"/> and it can be pickled with no modification.</p>&#13;
    <p class="normal">In <em class="chapterRef">Chapter 6</em>, <em class="italic">Decorators – Enabling Code Reuse by Decorating</em> (specifically, in the section about <code class="inlineCode">functools.wraps</code>), we will see how we can make functions copy attributes from other functions in a similar fashion to how <code class="inlineCode">functools.partial</code> copies the documentation.</p>&#13;
    <h2 id="_idParaDest-139" class="heading-2">reduce – Combining pairs into a single result</h2>&#13;
    <p class="normal">The <code class="inlineCode">reduce</code> function<a id="_idIndexMarker374"/> implements <a id="_idIndexMarker375"/>a mathematical technique called folding. It applies a pair of the previous result and the next item in the given list to the function that is passed.</p>&#13;
    <p class="normal">The <code class="inlineCode">reduce</code> function is supported by many languages but in most cases using different names such as <code class="inlineCode">curry</code>, <code class="inlineCode">fold</code>, <code class="inlineCode">accumulate</code>, or <code class="inlineCode">aggregate</code>. Python has actually supported <code class="inlineCode">reduce</code> for a very long time, but since Python 3, it has been moved from the global scope to the <code class="inlineCode">functools</code> library. Some code can be simplified beautifully using the <code class="inlineCode">reduce</code> statement; whether it’s readable or not is debatable, however.</p>&#13;
    <h3 id="_idParaDest-140" class="heading-3">Implementing a factorial function</h3>&#13;
    <p class="normal">One of<a id="_idIndexMarker376"/> the most used examples of <code class="inlineCode">reduce</code> is for <a id="_idIndexMarker377"/>calculating factorials, which is indeed quite simple:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> operator&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> functools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> functools.reduce(operator.mul, <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">1</span>, <span class="hljs-con-number">5</span>))&#13;
24&#13;
</code></pre>&#13;
    <div class="note">&#13;
      <p class="normal">The preceding code uses <code class="inlineCode">operator.mul</code> instead of <code class="inlineCode">lambda a, b: a * b</code>. While they produce the same results, the former can be much faster.</p>&#13;
    </div>&#13;
    <p class="normal">Internally, the <code class="inlineCode">reduce</code> function will do the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> operator <span class="hljs-con-keyword">import</span> mul&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> mul(mul(mul(<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>), <span class="hljs-con-number">3</span>), <span class="hljs-con-number">4</span>)&#13;
24&#13;
</code></pre>&#13;
    <p class="normal">Or, creating a reduce function that automatically loops would look like:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> operator&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">reduce</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function, iterable</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'iterable=</span><span class="hljs-con-subst">{iterable}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Fetch the first item to prime 'result'</span>&#13;
<span class="hljs-con-meta">...</span>     result, *iterable = iterable&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> iterable:&#13;
<span class="hljs-con-meta">...</span>         old_result = result&#13;
<span class="hljs-con-meta">...</span>         result = function(result, item)&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">f'</span><span class="hljs-con-subst">{old_result}</span><span class="hljs-con-string"> * </span><span class="hljs-con-subst">{item}</span><span class="hljs-con-string"> = </span><span class="hljs-con-subst">{result}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> result&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> iterable = <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">1</span>, <span class="hljs-con-number">5</span>))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> iterable&#13;
[1, 2, 3, 4]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> reduce(operator.mul, iterable)&#13;
iterable=[1, 2, 3, 4]&#13;
1 * 2 = 2&#13;
2 * 3 = 6&#13;
6 * 4 = 24&#13;
24&#13;
</code></pre>&#13;
    <p class="normal">Using the <a id="_idIndexMarker378"/>form <code class="inlineCode">a, *b = c</code>, we can split an iterable <a id="_idIndexMarker379"/>between the first item and the remaining ones. Which means that <code class="inlineCode">a, *b = [1, 2, 3]</code> will result in <code class="inlineCode">a=1, b=[2, 3]</code>.</p>&#13;
    <p class="normal">In this example, this means that we start by priming the <code class="inlineCode">result</code> variable so it contains the initial value and continue to call the function with the current result and the next item until the iterable is exhausted.</p>&#13;
    <p class="normal">Effectively, this comes down to:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1"><code class="inlineCode">iterable = [1, 2, 3, 4]</code></li>&#13;
      <li class="numberedList"><code class="inlineCode">result, *iterable = iterable</code>&#13;
        <p class="normal">This gives us <code class="inlineCode">result=1</code> and <code class="inlineCode">iterable = [2, 3, 4]</code>.</p>&#13;
      </li>&#13;
      <li class="numberedList">Next up is the first call to operator.mul with the arguments result and item, which is stored in result. This is the big difference between reduce and map. Whereas map applies the function only to the given item, reduce applies <a id="_idIndexMarker380"/>both the previous result and the item to the function. So effectively, it runs result = operator.mul(result, item). Filling in the variables gives us <code class="inlineCode">result</code> <code class="inlineCode">=</code> <code class="inlineCode">1</code> <code class="inlineCode">*</code> <code class="inlineCode">2</code> <code class="inlineCode">=</code> <code class="inlineCode">2</code>.</li>&#13;
      <li class="numberedList">The <a id="_idIndexMarker381"/>next call effectively repeats the process, but because of the previous call our initial <code class="inlineCode">result</code> value is now <code class="inlineCode">2</code> and the next <code class="inlineCode">item</code> is <code class="inlineCode">3</code>: <code class="inlineCode">result = 2 * 3 = 6</code>.</li>&#13;
      <li class="numberedList">We repeat this one more time because our <code class="inlineCode">iterable</code> is now exhausted. The last call will run <code class="inlineCode">result = 6 * 4 = 24</code>.</li>&#13;
    </ol>&#13;
    <h3 id="_idParaDest-141" class="heading-3">Processing trees</h3>&#13;
    <p class="normal">Trees<a id="_idIndexMarker382"/> are a <a id="_idIndexMarker383"/>case where the <code class="inlineCode">reduce</code> function really shines. Remember the one-line tree definition using a <code class="inlineCode">defaultdict</code> from <em class="chapterRef">Chapter 4</em>, <em class="italic">Pythonic Design Patterns</em>. What would be a good way to access the keys inside of that object? Given a path of a tree item, we can use <code class="inlineCode">reduce</code> to easily access the items inside. First, let’s build a tree: </p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> json&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> functools&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> collections&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">tree</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> collections.defaultdict(tree)&#13;
&#13;
<span class="hljs-con-comment"># Build the tree:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> taxonomy = tree()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> reptilia = taxonomy[<span class="hljs-con-string">'Chordata'</span>][<span class="hljs-con-string">'Vertebrata'</span>][<span class="hljs-con-string">'Reptilia'</span>]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> reptilia[<span class="hljs-con-string">'Squamata'</span>][<span class="hljs-con-string">'Serpentes'</span>][<span class="hljs-con-string">'Pythonidae'</span>] = [&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'Liasis'</span>, <span class="hljs-con-string">'Morelia'</span>, <span class="hljs-con-string">'Python'</span>]&#13;
&#13;
<span class="hljs-con-comment"># The actual contents of the tree</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print(json.dumps(taxonomy, indent=<span class="hljs-con-number">4</span>))&#13;
{&#13;
    "Chordata": {&#13;
        "Vertebrata": {&#13;
            "Reptilia": {&#13;
                "Squamata": {&#13;
                    "Serpentes": {&#13;
                        "Pythonidae": [&#13;
                            "Liasis",&#13;
                            "Morelia",&#13;
                            "Python"&#13;
                        ]&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">First, we<a id="_idIndexMarker384"/> created a <code class="inlineCode">tree</code> structure by using a recursive definition with <code class="inlineCode">collections.defaultdict</code>. This allows us to nest the <code class="inlineCode">tree</code> many levels <a id="_idIndexMarker385"/>deep without the need for explicit definitions.</p>&#13;
    <p class="normal">To provide somewhat readable output, we use the <code class="inlineCode">json</code> module to export the <code class="inlineCode">tree</code> (which is effectively a list of nested dicts).</p>&#13;
    <p class="normal">Now it’s time for the lookup:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Let's build the lookup function</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> operator&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">lookup</span><span class="hljs-con-function">(</span><span class="hljs-con-params">tree, path</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Split the path for easier access</span>&#13;
<span class="hljs-con-meta">...</span>     path = path.split(<span class="hljs-con-string">'.'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Use 'operator.getitem(a, b)' to get 'a[b]'</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># And use reduce to recursively fetch the items</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> functools.reduce(operator.getitem, path, tree)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> path = <span class="hljs-con-string">'Chordata.Vertebrata.Reptilia.Squamata.Serpentes'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">dict</span>(lookup(taxonomy, path))&#13;
{'Pythonidae': ['Liasis', 'Morelia', 'Python']}&#13;
&#13;
<span class="hljs-con-comment"># The path we wish to get</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> path = <span class="hljs-con-string">'Chordata.Vertebrata.Reptilia.Squamata'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> lookup(taxonomy, path).keys()&#13;
dict_keys(['Serpentes'])&#13;
</code></pre>&#13;
    <p class="normal">Now we have a very simple way of walking through the <code class="inlineCode">tree</code> structure recursively in just a few short lines of code.</p>&#13;
    <h3 id="_idParaDest-142" class="heading-3">Reducing in the other direction </h3>&#13;
    <p class="normal">People <a id="_idIndexMarker386"/>that are familiar with functional programming might wonder why Python only has the equivalent of <code class="inlineCode">fold_left</code> and no <code class="inlineCode">fold_right</code>. You honestly don’t really need both of them as you can easily reverse the operation. To be fair, however, the same can be said of <code class="inlineCode">reduce</code> as well since it is trivial to implement, as we have seen in the previous paragraph.</p>&#13;
    <p class="normal">The regular <code class="inlineCode">reduce</code>—the <code class="inlineCode">fold left</code> operation:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">fold_left = functools.reduce(&#13;
    <span class="hljs-keyword">lambda</span> x, y: function(x, y),&#13;
    iterable,&#13;
    initializer,&#13;
)&#13;
</code></pre>&#13;
    <p class="normal">The reverse—the <code class="inlineCode">fold right</code> operation:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">fold_right = functools.reduce(&#13;
    <span class="hljs-keyword">lambda</span> x, y: function(y, x),&#13;
    <span class="hljs-built_in">reversed</span>(iterable),&#13;
    initializer,&#13;
)&#13;
</code></pre>&#13;
    <p class="normal">There may not be too many useful cases for <code class="inlineCode">reduce</code>, but there are definitely a few. In particular, traversing recursive data structures is far more easily done using <code class="inlineCode">reduce</code>, since it would otherwise involve more complicated loops or recursive functions.</p>&#13;
    <p class="normal">Now that we have seen a few of the functional functions in Python, it is time to take a look at a few methods that focus on iterables instead.</p>&#13;
    <h1 id="_idParaDest-143" class="heading-1">itertools</h1>&#13;
    <p class="normal">The <code class="inlineCode">itertools</code> library<a id="_idIndexMarker387"/> contains iterable functions inspired by those available in functional languages. All of these are iterable and have been constructed in such a way that only a minimal amount of memory is required to process even the largest of datasets. While you can easily write most of these functions yourself, I would still recommend using the ones available in the <code class="inlineCode">itertools</code> library. These are all fast, memory efficient, and—perhaps more importantly—tested. We’re going to explore a few now: <code class="inlineCode">accumulate</code>, <code class="inlineCode">chain</code>, <code class="inlineCode">compress</code>, <code class="inlineCode">dropwhile/takewhile</code>, <code class="inlineCode">count</code>, and <code class="inlineCode">groupby</code>.</p>&#13;
    <h2 id="_idParaDest-144" class="heading-2">accumulate – reduce with intermediate results</h2>&#13;
    <p class="normal">The <code class="inlineCode">accumulate</code> function is <a id="_idIndexMarker388"/>very similar to the <code class="inlineCode">reduce</code> function, which<a id="_idIndexMarker389"/> is why some languages actually have <code class="inlineCode">accumulate</code> instead of <code class="inlineCode">reduce</code> as the folding operator.</p>&#13;
    <p class="normal">The major difference between the two is that the <code class="inlineCode">accumulate</code> function returns the immediate results. This can be useful when summing the results of a company’s sales, for example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> operator&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-comment"># Sales per month</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> months = [<span class="hljs-con-number">10</span>, <span class="hljs-con-number">8</span>, <span class="hljs-con-number">5</span>, <span class="hljs-con-number">7</span>, <span class="hljs-con-number">12</span>, <span class="hljs-con-number">10</span>, <span class="hljs-con-number">5</span>, <span class="hljs-con-number">8</span>, <span class="hljs-con-number">15</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">4</span>, <span class="hljs-con-number">2</span>]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.accumulate(months, operator.add))&#13;
[10, 18, 23, 30, 42, 52, 57, 65, 80, 83, 87, 89]&#13;
</code></pre>&#13;
    <p class="normal">It should be noted that the <code class="inlineCode">operator.add</code> function is actually optional in this case as the default behavior of <code class="inlineCode">accumulate</code> is to sum the results. In some other languages and libraries, this function is sometimes called <code class="inlineCode">cumsum</code> (cumulative sum).</p>&#13;
    <h2 id="_idParaDest-145" class="heading-2">chain – Combining multiple results</h2>&#13;
    <p class="normal">The <code class="inlineCode">chain</code> function<a id="_idIndexMarker390"/> is a simple but useful function that combines<a id="_idIndexMarker391"/> the results of multiple iterators. Very simple but also very useful if you have multiple lists, iterators, and so on—just combine them with a simple chain:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.chain(a, b))&#13;
[0, 1, 2, 0, 1, 2, 3, 4]&#13;
</code></pre>&#13;
    <p class="normal">It should be noted that there is a small variant of <code class="inlineCode">chain</code> that accepts an iterable containing iterables, namely <code class="inlineCode">chain.from_iterable</code>. This works nearly identically, except for the fact that you need to pass along an iterable item instead of passing a list of arguments. </p>&#13;
    <p class="normal">Your initial response might be that this can be achieved simply by unpacking the (<code class="inlineCode">*args</code>) tuple, as we will see in <em class="chapterRef">Chapter 7</em>, <em class="italic">Generators and Coroutines – Infinity, One Step at a Time</em>. However, this is not always the case. For now, just remember that if you have an <a id="_idIndexMarker392"/>iterable<a id="_idIndexMarker393"/> containing iterables, the easiest method is to use <code class="inlineCode">itertools.chain.from_iterable</code>. The usage is as you would expect:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> iterables = [<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>), <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">5</span>)]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.chain.from_iterable(iterables))&#13;
[0, 1, 2, 0, 1, 2, 3, 4]&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-146" class="heading-2">compress – Selecting items using a list of Booleans</h2>&#13;
    <p class="normal">The <code class="inlineCode">compress</code> function is<a id="_idIndexMarker394"/> one of those that you won’t need too often, but it can be very useful when you do need it. It applies a Boolean filter to<a id="_idIndexMarker395"/> your iterable, making it return only the elements you actually need. The most important thing to note here is that <code class="inlineCode">compress</code> executes lazy and that <code class="inlineCode">compress</code> will stop if either the data is exhausted, or no elements are being fetched anymore. So, even with infinite ranges, it works without a hitch:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.compress(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">1000</span>), [<span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>]))&#13;
[1, 2, 3, 5]&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">compress</code> function can be useful if you want to make a filtered view of a larger iterable without modifying the original iterable. If calculating the filter is a heavy operation and the actual values inside the iterable can change, this can be very useful. To build on the example above:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> primes = [<span class="hljs-con-number">0</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> odd = [<span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> numbers = [<span class="hljs-con-string">'zero'</span>, <span class="hljs-con-string">'</span><span class="hljs-con-string">one'</span>, <span class="hljs-con-string">'two'</span>, <span class="hljs-con-string">'three'</span>, <span class="hljs-con-string">'four'</span>, <span class="hljs-con-string">'five'</span>]&#13;
&#13;
<span class="hljs-con-comment"># Primes:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.compress(numbers, primes))&#13;
['two', 'three', 'five']&#13;
&#13;
<span class="hljs-con-comment"># Odd numbers</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.compress(numbers, odd))&#13;
['one', 'three', 'five']&#13;
&#13;
<span class="hljs-con-comment"># Odd primes</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.compress(numbers, <span class="hljs-con-built_in">map</span>(<span class="hljs-con-built_in">all</span>, <span class="hljs-con-built_in">zip</span>(odd, primes))))&#13;
['three', 'five']&#13;
</code></pre>&#13;
    <p class="normal">In this case, both<a id="_idIndexMarker396"/> the filters and the iterable are predefined and very small. But if you have a large<a id="_idIndexMarker397"/> set that takes a lot of time to compute (or fetch from an external resource), this method can be useful to quickly filter without having to recalculate everything, especially since the filters can be combined easily using a combination of <code class="inlineCode">map</code>, <code class="inlineCode">all</code>, and <code class="inlineCode">zip</code>. You can use <code class="inlineCode">any</code> instead of <code class="inlineCode">all</code> if you want to see the results from both.</p>&#13;
    <h2 id="_idParaDest-147" class="heading-2">dropwhile/takewhile – Selecting items using a function</h2>&#13;
    <p class="normal">The <code class="inlineCode">dropwhile</code> function<a id="_idIndexMarker398"/> will drop all results until a given <a id="_idIndexMarker399"/>predicate evaluates to true. This can be useful if you are waiting for a device to finally return an expected result. That’s a bit difficult to demonstrate in a book, so we only have an example with the basic usage—waiting for a number greater than <code class="inlineCode">3</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.dropwhile(<span class="hljs-con-keyword">lambda</span> x: x &lt;= <span class="hljs-con-number">3</span>, [<span class="hljs-con-number">1</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">5</span>, <span class="hljs-con-number">4</span>, <span class="hljs-con-number">2</span>]))&#13;
[5, 4, 2]&#13;
</code></pre>&#13;
    <p class="normal">As you might expect, the <code class="inlineCode">takewhile</code> function is the reverse of this. It will simply return all rows until the predicate turns false:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.takewhile(<span class="hljs-con-keyword">lambda</span> x: x &lt;= <span class="hljs-con-number">3</span>, [<span class="hljs-con-number">1</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">5</span>, <span class="hljs-con-number">4</span>, <span class="hljs-con-number">2</span>]))&#13;
[1, 3]&#13;
</code></pre>&#13;
    <p class="normal">Adding the results from <code class="inlineCode">dropwhile</code> and <code class="inlineCode">takewhile</code> will give you all the elements again as they are each other’s opposites.</p>&#13;
    <h2 id="_idParaDest-148" class="heading-2">count – Infinite range with decimal steps</h2>&#13;
    <p class="normal">The <code class="inlineCode">count</code> function is<a id="_idIndexMarker400"/> quite similar to the <code class="inlineCode">range</code> function, but <a id="_idIndexMarker401"/>there are two significant differences:</p>&#13;
    <ul>&#13;
      <li class="bulletList">The first is that this range is infinite, so don’t even try to do <code class="inlineCode">list(itertools.count())</code>. You’ll definitely run out of memory immediately and it might even freeze your system.</li>&#13;
      <li class="bulletList">The second difference is that, unlike the <code class="inlineCode">range</code> function, you can actually use floating-point numbers here, so there is no need for whole/integer numbers.</li>&#13;
    </ul>&#13;
    <p class="normal">Since listing the entire range will kill our Python interpreter, we’ll limit the results using the <code class="inlineCode">itertools.islice</code> function, which is similar to regular slicing (e.g. <code class="inlineCode">some_list[10:20]</code>) but works on infinitely large inputs as well.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The infinitely large functions such as <code class="inlineCode">count</code> are not sliceable because they are infinite generators, a topic we will discuss in <em class="chapterRef">Chapter 7</em>, <em class="italic">Generators and Coroutines – Infinity, One Step at a Time</em>.</p>&#13;
    </div>&#13;
    <p class="normal">The <code class="inlineCode">count</code> function takes two optional parameters: a <code class="inlineCode">start</code> parameter, which defaults to <code class="inlineCode">0</code>, and a <code class="inlineCode">step</code> parameter, which defaults to <code class="inlineCode">1</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.islice(itertools.count(), <span class="hljs-con-number">10</span>))&#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.islice(itertools.count(), <span class="hljs-con-number">5</span>, <span class="hljs-con-number">10</span>, <span class="hljs-con-number">2</span>))&#13;
[5, 7, 9]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.islice(itertools.count(<span class="hljs-con-number">10</span>, <span class="hljs-con-number">2.5</span>), <span class="hljs-con-number">5</span>))&#13;
[10, 12.5, 15.0, 17.5, 20.0]&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-149" class="heading-2">groupby – Grouping your sorted iterable</h2>&#13;
    <p class="normal">The <code class="inlineCode">groupby</code> function<a id="_idIndexMarker402"/> is a really convenient function for <a id="_idIndexMarker403"/>grouping results. It allows you to convert a list of objects into a list of groups given a specific grouping function.</p>&#13;
    <p class="normal">A basic example of <code class="inlineCode">groupby</code> usage:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> operator&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> words = [<span class="hljs-con-string">'aa'</span>, <span class="hljs-con-string">'ab'</span>, <span class="hljs-con-string">'ba'</span>, <span class="hljs-con-string">'bb'</span>, <span class="hljs-con-string">'</span><span class="hljs-con-string">ca'</span>, <span class="hljs-con-string">'cb'</span>, <span class="hljs-con-string">'cc'</span>]&#13;
&#13;
<span class="hljs-con-comment"># Gets the first element from the iterable</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> getter = operator.itemgetter(<span class="hljs-con-number">0</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> group, items <span class="hljs-con-keyword">in</span> itertools.groupby(words, key=getter):&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'group: </span><span class="hljs-con-subst">{group}</span><span class="hljs-con-string">, items: </span><span class="hljs-con-subst">{</span><span class="hljs-con-built_in">list</span><span class="hljs-con-subst">(items)}</span><span class="hljs-con-string">'</span>)&#13;
group: a, items: ['aa', 'ab']&#13;
group: b, items: ['ba', 'bb']&#13;
group: c, items: ['ca', 'cb', 'cc']&#13;
</code></pre>&#13;
    <p class="normal">We can<a id="_idIndexMarker404"/> see here how the words are grouped by the first character with very little effort. This can be<a id="_idIndexMarker405"/> a really convenient utility for grouping employees by department in a user interface, for example.</p>&#13;
    <p class="normal">There are some important things to keep in mind when using this function, however:</p>&#13;
    <ul>&#13;
      <li class="bulletList">The input needs to be sorted by the <code class="inlineCode">group</code> parameter. Otherwise, every repeated group will be added as a separate group.</li>&#13;
      <li class="bulletList">The results are available for use only once. So, after processing a group, it will not be available anymore. If you wish to iterate the results twice, wrap the results in <code class="inlineCode">list()</code> or <code class="inlineCode">tuple()</code>.</li>&#13;
    </ul>&#13;
    <p class="normal">Here is an example of <code class="inlineCode">groupby</code> including the side effects of not sorting:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> raw_items = [<span class="hljs-con-string">'spam'</span>, <span class="hljs-con-string">'eggs'</span>, <span class="hljs-con-string">'sausage'</span>, <span class="hljs-con-string">'spam'</span>]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">keyfunc</span><span class="hljs-con-function">(</span><span class="hljs-con-params">group</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> group[<span class="hljs-con-number">0</span>]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> group, items <span class="hljs-con-keyword">in</span> itertools.groupby(raw_items, key=keyfunc):&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'group: </span><span class="hljs-con-subst">{group}</span><span class="hljs-con-string">, items: </span><span class="hljs-con-subst">{</span><span class="hljs-con-built_in">list</span><span class="hljs-con-subst">(items)}</span><span class="hljs-con-string">'</span>)&#13;
group: s, items: ['spam']&#13;
group: e, items: ['eggs']&#13;
group: s, items: ['sausage', 'spam']&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> raw_items.sort()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> group, items <span class="hljs-con-keyword">in</span> itertools.groupby(raw_items, key=keyfunc):&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'group: </span><span class="hljs-con-subst">{group}</span><span class="hljs-con-string">, items: </span><span class="hljs-con-subst">{</span><span class="hljs-con-built_in">list</span><span class="hljs-con-subst">(items)}</span><span class="hljs-con-string">'</span>)&#13;
group: e, items: ['eggs']&#13;
group: s, items: ['sausage', 'spam', 'spam']&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">groupby</code> function<a id="_idIndexMarker406"/> is definitely a very useful one that you can use in a wide variety of scenarios. Grouping output for a user, for example, can make results much easier to read. </p>&#13;
    <h1 id="_idParaDest-150" class="heading-1">Exercises</h1>&#13;
    <p class="normal">Now that you know how to use some of the functional programming features in Python, perhaps you can try writing the quicksort algorithm as (a collection of) regular functions instead of the hard-to-read Y-combinator version.</p>&#13;
    <p class="normal">You can also try and write a <code class="inlineCode">groupby</code> function yourself that isn’t affected by sorting and returns lists of results that can be used multiple times rather than just once.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_5.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-151" class="heading-1">Summary</h1>&#13;
    <p class="normal">Functional programming is a paradigm that scares many people initially, but really it shouldn’t. The most important difference between functional and procedural programming (within Python) is the mindset. Everything is executed using simple functions that depend only on their input variables and don’t produce any side effects outside of the local scope.</p>&#13;
    <p class="normal">The main advantages are:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Because there are fewer side-effects and code influencing each other, you will get fewer bugs.</li>&#13;
      <li class="bulletList">Because the functions always have a predictable input and output, they can be easily parallelized across multiple processors or even multiple machines.</li>&#13;
    </ul>&#13;
    <p class="normal">This chapter covered the basics of functional programming within Python and a tiny portion of the mathematics behind it. In addition to this, some of the many useful libraries that can be used in a very convenient way by using functional programming were covered.</p>&#13;
    <p class="normal">The most important takeaways should be the following:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Lambda statements are not inherently bad, but it would be best to make them use variables from the local scope only, and they should not be longer than a single line.</li>&#13;
      <li class="bulletList">Functional programming can be very powerful, but has a tendency to become unreadable. Care must be taken.</li>&#13;
      <li class="bulletList"><code class="inlineCode">list/dict/set</code> comprehensions are very useful but have a tendency to quickly become unreadable. In particular, nested comprehensions are hard to read in nearly all cases and should mostly be avoided.</li>&#13;
    </ul>&#13;
    <p class="normal">Ultimately, it is a matter of preference. For the sake of readability, I recommend limiting the usage of the functional paradigm when there is no obvious benefit. Having said that, when executed correctly, it can be a thing of beauty.</p>&#13;
    <p class="normal">Next up are decorators – methods to wrap your functions and classes in other functions and/or classes to modify their behavior and extend their functionality.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>