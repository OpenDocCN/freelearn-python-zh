<html><head></head><body>
		<div id="_idContainer035">
			<h1 id="_idParaDest-104"><em class="italic"><a id="_idTextAnchor141"/>Chapter 4</em>: Python Libraries for Advanced Programming</h1>
			<p>In previous chapters, we have discussed different approaches to building modular and reusable programs in Python. In this chapter, we will investigate a few advanced concepts of the Python programming language such as iterators, generators, logging, and error handling. These concepts are important to write efficient and reusable code. For this chapter, we assume that you are familiar with the Python language syntax and know how to write control and loop structures. </p>
			<p>In this chapter, we will learn how loops work in Python, how files are handled and what is the best practice to open and access files, and how to handle erroneous situations, which may be expected or unexpected. We will also investigate the logging support in Python and different ways of configuring the logging system. This chapter will also help you learn how to use the advanced libraries in Python for building complex projects.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing Python data containers</li>
				<li>Using iterators and generators for data processing</li>
				<li>Handling files in Python</li>
				<li>Handling errors and exceptions</li>
				<li>Using the Python <strong class="source-inline">logging</strong> module </li>
			</ul>
			<p>By the end of this chapter, you will have learned how to build iterators and generators, how to handles errors and exceptions in your program, and how to implement logging for your Python project in an efficient way.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor142"/>Technical requirements</h1>
			<p>The technical requirement for this chapter is that you need to have installed Python 3.7 or later on your computer. Sample code for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter04">https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter04</a>.</p>
			<p>Let's begin by refreshing our knowledge about the data containers available in Python, which will be helpful for the follow-up topics in this chapter. </p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor143"/>Introducing Python data containers</h1>
			<p>Python supports several<a id="_idIndexMarker361"/> data types, both numeric as well as collections. Defining numeric data types such as integers and floating-point numbers is based on assigning a value to a variable. The value we assign to a variable determines the type of the numeric data type. Note that a specific constructor (for example, <strong class="source-inline">int()</strong> and <strong class="source-inline">float()</strong>) can also be used to create a variable of a specific data type. Container data types can also be defined either by assigning values in an appropriate format or by using a specific constructor for each collection data type. We will study five different container data types in this section: <strong class="bold">strings</strong>, <strong class="bold">lists</strong>, <strong class="bold">t</strong><strong class="bold">uples</strong>, <strong class="bold">dictionaries</strong>, and <strong class="bold">sets</strong>.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor144"/>Strings</h2>
			<p>Strings are not directly a<a id="_idIndexMarker362"/> container data type. But it is important to discuss the string data type because of its wide use in Python programming and also the fact that the string data type is implemented using an <strong class="bold">immutable sequence</strong> of Unicode code<a id="_idIndexMarker363"/> points. The fact that it uses a sequence (a collection type) makes it a candidate to be discussed in this section. </p>
			<p>String objects are immutable objects in Python. With immutability, string objects provide a safe solution for concurrent programs where multiple functions may access the same string object and will get the same result back. This safety is not possible with mutable objects. Being immutable objects, string objects are popular to use as keys for the dictionary data type or as data elements for the set data type. The drawback of immutability is that a new instance needs to be created even if a small change is to be made to an existing string instance. </p>
			<p class="callout-heading">Mutable versus immutable objects</p>
			<p class="callout">A mutable object can be changed after its creation, but it is not possible to change an immutable object.</p>
			<p>String literals can be enclosed by using matching single quotes (for example, <em class="italic">'blah'</em>), double quotes (for example, <em class="italic">"blah blah"</em>), or triple single or double quotes (for example, <em class="italic">"""none"""</em> or <em class="italic">'''none'''</em>). It is also worth mentioning that string objects are handled differently in Python 3 versus Python 2. In Python 3, string objects can hold only text sequences in the form of Unicode data points, but in Python 2 they can hold text as well as byte data. In Python<a id="_idIndexMarker364"/> 3, byte data is handled by the <strong class="source-inline">bytes</strong> data type. </p>
			<p>Separating text from bytes in Python 3 makes it clean and efficient but at the cost of data portability. The Unicode text in strings cannot be saved to disk or sent to a remote location on the network without converting it into a binary format. This conversion requires encoding the string data into a byte sequence, which can be achieved in one of the following ways:</p>
			<ul>
				<li><strong class="bold">Using the str.encode (encoding, errors) method:</strong> This method is available on the <a id="_idIndexMarker365"/>string object and it can take two arguments. A user can provide the type of codec to be used (<strong class="source-inline">UTF-8</strong> being the default) and how to handle the errors. </li>
				<li><strong class="bold">Converting to the bytes datatype:</strong> A string object can be converted to the <strong class="source-inline">Bytes</strong> data type by passing the <a id="_idIndexMarker366"/>string instance to the bytes constructor along with the encoding scheme and the error handling scheme.</li>
			</ul>
			<p>The details of methods and the attributes available with any string object can be found in the official Python documentation as per the Python release. </p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor145"/>Lists</h2>
			<p>The list is one <a id="_idIndexMarker367"/>of the basic collection<a id="_idIndexMarker368"/> types in Python, which is used to store multiple objects using a single variable. Lists are dynamic and <em class="italic">mutable</em>, which means the objects in a list can be changed and the list can grow or shrink. </p>
			<p>List objects in Python are not implemented using any linked list concept but using a variable-length array. The array contains references to objects it is storing. The pointer of this array and its length are stored in the list head structure, which is kept up to date as objects are added or deleted from a list. The behavior of such an array is made to appear like a list but in reality, it is not a real list. That is why some of the operations on a Python list are not optimized. For example, inserting a new object into a list and deleting objects from a list will have a complexity of <em class="italic">n</em>.</p>
			<p>To rescue the<a id="_idIndexMarker369"/> situation, Python provides a <strong class="source-inline">deque</strong> data type in the <strong class="source-inline">collections</strong> built-in module. The <strong class="source-inline">deque</strong> data type provides the functionality of stacks and queues and is a good alternative<a id="_idIndexMarker370"/> option for cases when a linked list-like behavior is demanded by a problem statement. </p>
			<p>Lists can be created empty or with an initial value using <em class="italic">square brackets</em>. Next, we present a code snippet that demonstrates how to create an empty or non-empty list object using only the square brackets or using the list object constructor:</p>
			<p class="source-code">e1 = []                  #an empty list</p>
			<p class="source-code">e2 = list()              #an empty list via constructor</p>
			<p class="source-code">g1 = ['a', 'b']          #a list with 2 elements</p>
			<p class="source-code">g2 = list(['a', 'b'])    #a list with 2 elements using a \</p>
			<p class="source-code">                          constructor</p>
			<p class="source-code">g3 = list(g1)            #a list created from a list</p>
			<p>The details of the operations available with a list object, such as <strong class="source-inline">add</strong>, <strong class="source-inline">insert</strong>, <strong class="source-inline">append</strong>, and <strong class="source-inline">delete</strong> can be reviewed in the official Python documentation. We will introduce tuples in the next section.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor146"/>Tuples</h2>
			<p>A tuple is an immutable <a id="_idIndexMarker371"/>list, which means it cannot be modified <a id="_idIndexMarker372"/>after creation. Tuples are usually used for a small number of entries and when the position and sequence of the entries in a collection is important. To preserve the sequence of entries, tuples are designed as immutable, and this is where tuples differentiate themselves from lists. Operations on a tuple are typically faster than a regular list datatype. In cases when the values in a collection are required to be constant in a particular order, using tuples is the preferred option because of their superior performance. </p>
			<p>Tuples are normally initialized with values because they are immutable. A simple tuple can be created using<a id="_idIndexMarker373"/> parenthesis. A few ways to create tuple instances are shown in the next code snippet:</p>
			<p class="source-code">w = ()                     #an empty tuple</p>
			<p class="source-code">x = (2, 3)                 #tuple with two elements</p>
			<p class="source-code">y = ("Hello World")        #not a tuple, Comma is required \</p>
			<p class="source-code">                            for single entry tuple</p>
			<p class="source-code">z = ("Hello World",)       #A comma will make it a tuple</p>
			<p>In this code snippet, we created an empty tuple (<strong class="source-inline">w</strong>), a tuple with numbers (<strong class="source-inline">x</strong>), and a tuple with the text <strong class="source-inline">Hello World</strong>, which is <strong class="source-inline">z</strong>. The variable <strong class="source-inline">y</strong> is not a tuple since, for a 1-tuple (a single-object tuple), we need a<a id="_idIndexMarker374"/> trailing comma to indicate that it is a tuple. </p>
			<p>After introducing lists and tuples, we will briefly introduce dictionaries.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor147"/>Dictionaries</h2>
			<p>Dictionaries are one<a id="_idIndexMarker375"/> of the most used and versatile data types in Python. A dictionary is a collection that is used to store data values in the <em class="italic">key:value</em> format. Dictionaries<a id="_idIndexMarker376"/> are mutable and unordered data types. In other<a id="_idIndexMarker377"/> programming languages, they are referred to as <em class="italic">associative arrays</em> or <em class="italic">hashtables</em>. </p>
			<p>A dictionary <a id="_idIndexMarker378"/>can be created using <em class="italic">curly brackets</em> with a list of <em class="italic">key:value</em> pairs. The key is separated from its value by a colon <em class="italic">':'</em> and the <em class="italic">key:value</em> pairs are separated by a comma <em class="italic">','</em>. A code snippet for a dictionary definition follows:</p>
			<p class="source-code">mydict = {</p>
			<p class="source-code">  "brand": "BMW",</p>
			<p class="source-code">  "model": "330i",</p>
			<p class="source-code">  "color": "Blue"</p>
			<p class="source-code">}</p>
			<p>Duplicate keys are not allowed in a dictionary. A key must be an immutable object type such as a string, tuple, or number. The values in a dictionary can be of any data type, which even includes lists, sets, custom objects, and even another dictionary itself. </p>
			<p>When dealing with<a id="_idIndexMarker379"/> dictionaries, three objects or lists are important: </p>
			<ul>
				<li><strong class="bold">Keys</strong>: A list of keys in a <a id="_idIndexMarker380"/>dictionary is used to iterate through dictionary items. A list of keys can be obtained using the <strong class="source-inline">keys()</strong> method:<p class="source-code">dict_object.<strong class="bold">keys</strong>()</p></li>
				<li><strong class="bold">Values</strong>: Values are the <a id="_idIndexMarker381"/>objects stored against different keys. A list of value objects can be obtained using the <strong class="source-inline">values()</strong> method:<p class="source-code">dict_object.<strong class="bold">values</strong>()</p></li>
				<li><strong class="bold">Items</strong>: Items are the <a id="_idIndexMarker382"/>key-value pairs that are stored in a dictionary. A list of items can be obtained using the <strong class="source-inline">items()</strong> method:<p class="source-code">dict_object.<strong class="bold">items</strong>()</p></li>
			</ul>
			<p>Next, we will discuss sets, which <a id="_idIndexMarker383"/>are also key data structures in Python.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor148"/>Sets</h2>
			<p>A set is a <em class="italic">unique</em> collection of objects. A set is a <a id="_idIndexMarker384"/>mutable and unordered collection. There is no duplication <a id="_idIndexMarker385"/>of objects allowed in a set. Python uses a hashtable data structure to implement uniqueness in a set, which is the same approach used to ensure<a id="_idIndexMarker386"/> the uniqueness of keys in a dictionary. The behavior of sets in Python is very similar to sets in mathematics. This data type finds its application in situations where the order of objects is not important, but their uniqueness is. This helps to test whether a certain collection contains a certain object or not. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If the behavior of a set is required as an immutable data type, Python has a variant implementation of sets called <strong class="source-inline">frozenset</strong>.</p>
			<p>Creating a new set <a id="_idIndexMarker387"/>object is possible using <em class="italic">curly brackets</em> or using the set constructor (<strong class="source-inline">set()</strong>). The next code snippet shows a few examples of creating a set:</p>
			<p class="source-code">s1 = set()            # empty set</p>
			<p class="source-code">s2 = {}               # an empty set using curly </p>
			<p class="source-code">s3 = set(['a', 'b'])  # a set created from a list with                       # const.</p>
			<p class="source-code">s3 = {1,2}            # a set created using curly bracket</p>
			<p class="source-code">s4 = {1, 2, 1}        # a set will be created with only 1 and 2                     # objects. Duplicate object will be ignored</p>
			<p>Accessing set objects is not<a id="_idIndexMarker388"/> possible using an indexing approach. We need to pop one object from the set like a list or we can iterate on a set to get objects one by one. Like mathematical sets, sets in Python also support operations such as <em class="italic">union</em>, <em class="italic">intersection</em>, and <em class="italic">difference</em>. </p>
			<p>In this section, we <a id="_idIndexMarker389"/>reviewed the key concepts of strings and collection data types in Python 3, which are important to understand the upcoming topic – iterators and generators. </p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor149"/>Using iterators and generators for data processing</h1>
			<p>Iteration is <a id="_idIndexMarker390"/>one of the key tools used for data processing and data<a id="_idIndexMarker391"/> transformation. Iterations are especially useful when dealing with large datasets and when bringing the whole dataset into memory is not possible or efficient. Iterators provide a way to bring the data into memory one item at a time. </p>
			<p>Iterators can be created by defining them with a separate class and implementing special methods such as <strong class="source-inline">__iter__</strong> and <strong class="source-inline">__next__</strong>. But there is also a new way to create iterators using the <strong class="source-inline">yield</strong> operation, known as generators. In the next subsections, we will study both iterators and generators.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor150"/>Iterators</h2>
			<p>Iterators are the <a id="_idIndexMarker392"/>objects that are used to iterate on other objects. An object on which an iterator can iterate is called <strong class="bold">iterable</strong>. In theory, the two objects are different, but it is <a id="_idIndexMarker393"/>possible to implement an iterator within the <strong class="source-inline">iterable</strong> object class. This is not recommended but is technically possible and we will discuss with an example why this approach is not a good design approach. In the next code snippet, we provide a few examples of using the <strong class="source-inline">for</strong> loop for iteration purposes in Python:</p>
			<p class="source-code"><strong class="bold">#iterator1.py</strong></p>
			<p class="source-code"><strong class="bold">#example 1: iterating on a list</strong></p>
			<p class="source-code">for x in [1,2,3]:</p>
			<p class="source-code">    print(x)</p>
			<p class="source-code"><strong class="bold">#example 2: iterating on a string</strong></p>
			<p class="source-code">for x in "Python for Geeks":</p>
			<p class="source-code">    print(x, end="")</p>
			<p class="source-code">print('')</p>
			<p class="source-code"><strong class="bold">#example 3: iterating on a dictionary</strong></p>
			<p class="source-code">week_days = {1:'Mon', 2:'Tue', </p>
			<p class="source-code">             3:'Wed', 4:'Thu', </p>
			<p class="source-code">             5:'Fri', 6:'Sat', 7:'Sun'}</p>
			<p class="source-code">for k in week_days:</p>
			<p class="source-code">   print(k, week_days[k])</p>
			<p class="source-code"><strong class="bold">#example 4: iterating on a file</strong></p>
			<p class="source-code">for row in open('abc.txt'):</p>
			<p class="source-code">    print(row, end="")</p>
			<p>In these code examples, we used different <strong class="source-inline">for</strong> loops to iterate on a list, a string, a dictionary, and a file. All these data types are iterable and thus we will be using a simple syntax with the <strong class="source-inline">for</strong> loop to get through the items in these collections or sequences. Next, we will study what<a id="_idIndexMarker394"/> ingredients make an object iterable, which is also<a id="_idIndexMarker395"/> referred to as the <strong class="bold">Iterator Protocol</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Every collection in Python is <em class="italic">iterable</em> by default.</p>
			<p>In Python, an iterator object must implement two special methods: <strong class="source-inline">__iter__</strong> and <strong class="source-inline">__next__</strong>. To iterate on an object, the object has to implement at least the <strong class="source-inline">__iter__ </strong>method. Once the object implements the <strong class="source-inline">__iter__</strong> method, we can call the object iterable. These methods are described next:</p>
			<ul>
				<li><strong class="source-inline">__iter__</strong>: This method returns the iterator object. This method is called at the start of a loop to get the iterator object.</li>
				<li><strong class="source-inline">__next__</strong>: This method is called at each iteration of the loop and it returns the next item in the iterable object.</li>
			</ul>
			<p>To explain how to build a custom object that is iterable, we will implement the <strong class="source-inline">Week </strong>class, which stores the numbers and names of all weekdays in a dictionary. This class will not be iterable by default. To make it iterable, we will add <strong class="source-inline">__iter__</strong>. To keep the example simple, we will also add the <strong class="source-inline">__next__</strong> method in the same class. Here is the code snippet with the <strong class="source-inline">Week</strong> class and the main program, which iterates to get the names of weekdays:</p>
			<p class="source-code"><strong class="bold">#iterator2.py</strong></p>
			<p class="source-code">class Week:</p>
			<p class="source-code">    def <strong class="bold">__init__(self)</strong>:</p>
			<p class="source-code">        self.days = {1:'Monday', 2: "Tuesday",</p>
			<p class="source-code">                     3:"Wednesday", 4: "Thursday",</p>
			<p class="source-code">                     5:"Friday", 6:"Saturday", 7:"Sunday"}</p>
			<p class="source-code">        self._index = 1</p>
			<p class="source-code">    <strong class="bold">def __iter__(self)</strong>:</p>
			<p class="source-code">        self._index = 1</p>
			<p class="source-code">        return self</p>
			<p class="source-code">    <strong class="bold">def __next__(self):</strong></p>
			<p class="source-code">        if self._index &lt; 1 | self._index &gt; 7 :</p>
			<p class="source-code">            <strong class="bold">raise StopIteration</strong></p>
			<p class="source-code">        else:</p>
			<p class="source-code">            <strong class="bold">ret_value =  self.days[self._index]</strong></p>
			<p class="source-code">            self._index +=1</p>
			<p class="source-code">        <strong class="bold">return ret_value</strong></p>
			<p class="source-code">if(__name__ == "__main__"):</p>
			<p class="source-code">    wk = Week()</p>
			<p class="source-code">    <strong class="bold">for day in wk:</strong></p>
			<p class="source-code">        print(day)</p>
			<p>We shared this code <a id="_idIndexMarker396"/>example just to demonstrate how the <strong class="source-inline">__iter__</strong> and <strong class="source-inline">__next__</strong> methods can be implemented in the same object class. This style of implementing an iterator is commonly found on the internet, but it is not a recommended approach and is considered a bad design. The reason is that when we use it in the <strong class="source-inline">for</strong> loop, we get back the main object as an iterator as we implemented <strong class="source-inline">__iter__</strong> and <strong class="source-inline">__next__</strong> in the same class. This can give unpredictable<a id="_idIndexMarker397"/> results. We can demonstrate this by executing the following code snippet for the same class, <strong class="source-inline">Week</strong>:</p>
			<p class="source-code"><strong class="bold">#iterator3.py</strong></p>
			<p class="source-code"><strong class="bold">class Week:</strong></p>
			<p class="source-code">#class definition is the same as shown in the previous \</p>
			<p class="source-code"> code example</p>
			<p class="source-code">if(__name__ == "__main__"):</p>
			<p class="source-code">    wk = Week()</p>
			<p class="source-code">    iter1 = <strong class="bold">iter</strong>(wk)</p>
			<p class="source-code">    iter2 = iter(wk)</p>
			<p class="source-code">   print(iter1<strong class="bold">.__next__()</strong>)</p>
			<p class="source-code">   print(iter2.__next__())</p>
			<p class="source-code">   print(<strong class="bold">next</strong>(iter1))</p>
			<p class="source-code">   print(next(iter2))</p>
			<p>In this new main program, we are iterating on the same object using two different iterators. The results of this main program are not as expected. This is due to a common <strong class="source-inline">_index</strong> attribute shared by the two iterators. Here is a console output as a reference:</p>
			<p class="source-code">Monday</p>
			<p class="source-code">Tuesday</p>
			<p class="source-code">Wednesday</p>
			<p class="source-code">Thursday</p>
			<p>Note that in this new main program we deliberately did not use a <strong class="source-inline">for</strong> loop. We created two iterator objects for the same object of the <strong class="source-inline">Week</strong> class using the <strong class="source-inline">iter</strong> function. The <strong class="source-inline">iter</strong> function is a Python standard function that calls the <strong class="source-inline">__iter__</strong> method. To get the next item in the iterable object, we directly used the <strong class="source-inline">__next__</strong> method as well as the <strong class="source-inline">next</strong> function. The <strong class="source-inline">next</strong> function is also a general function, like the <strong class="source-inline">iter</strong> function. This approach of using an iterable as an iterator is also not considered thread-safe. </p>
			<p>The best approach is<a id="_idIndexMarker398"/> always to use a separate iterator class and always create a new instance of an iterator through the <strong class="source-inline">__iter__</strong> method. Each iterator instance has to manage its own internal state. A revised version of the same code example of the <strong class="source-inline">Week</strong> class is shown next with a separate iterator class: </p>
			<p class="source-code">#<strong class="bold">iterator4.py</strong></p>
			<p class="source-code">class Week:</p>
			<p class="source-code">    def __init__(self):</p>
			<p class="source-code">        self.days = {1: 'Monday', 2: "Tuesday",</p>
			<p class="source-code">                     3: "Wednesday", 4: "Thursday",</p>
			<p class="source-code">                     5: "Friday", 6: "Saturday", 7: "Sunday"}</p>
			<p class="source-code">        </p>
			<p class="source-code">    def <strong class="bold">__iter__(</strong>self):</p>
			<p class="source-code">        return <strong class="bold">WeekIterator</strong>(self.days)</p>
			<p class="source-code">class <strong class="bold">WeekIterator</strong>:</p>
			<p class="source-code">    def __init__(self, dayss):</p>
			<p class="source-code">        self.days_ref = dayss</p>
			<p class="source-code">        self._index = 1</p>
			<p class="source-code">    def <strong class="bold">__next__</strong>(self):</p>
			<p class="source-code">        if self._index &lt; 1 | self._index &gt; 8:</p>
			<p class="source-code">            raise StopIteration</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            ret_value =  self.days_ref[self._index]</p>
			<p class="source-code">            self._index +=1</p>
			<p class="source-code">        return ret_valu</p>
			<p class="source-code">if(__name__ == "__main__"):</p>
			<p class="source-code">    wk = Week()</p>
			<p class="source-code">    iter1 = iter(wk)</p>
			<p class="source-code">    iter2 = iter(wk)</p>
			<p class="source-code">    print(iter1.__next__())</p>
			<p class="source-code">    print(iter2.__next__())</p>
			<p class="source-code">    print(next(iter1))</p>
			<p class="source-code">    print(next(iter2))</p>
			<p>In this revised code <a id="_idIndexMarker399"/>example, we have a separate iterator class with the <strong class="source-inline">__next__</strong> method and it has its own <strong class="source-inline">_index</strong> attribute for managing the iterator state. The iterator instance will have a reference to the container object (dictionary). The console output of the revised example gives the results as expected: each iterator is iterating separately on the same instance of the <strong class="source-inline">Week</strong> class. The console output is shown next as a reference:</p>
			<p class="source-code">Monday</p>
			<p class="source-code">Monday</p>
			<p class="source-code">Tuesday</p>
			<p class="source-code">Tuesday</p>
			<p>In short, to create an iterator, we need to implement the <strong class="source-inline">__iter__</strong> and <strong class="source-inline">__next__</strong> methods, manage internal state, and raise a <strong class="source-inline">StopIteration</strong> exception when there are no values available. Next, we will study generators, which will simplify the way we return iterators. </p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor151"/>Generators</h2>
			<p>A generator is a <a id="_idIndexMarker400"/>simple way of returning an iterator instance that can be used for iteration, which is achieved by implementing only a generator function. A generator function is similar to a normal function but with a <strong class="source-inline">yield</strong> statement instead of a <strong class="source-inline">return</strong> statement in it. The <strong class="source-inline">return</strong> statement is still allowed in a generator function but will not be used to return the next item in an iterable object. </p>
			<p>By definition, a <a id="_idIndexMarker401"/>function will be a generator function if it has at least one <strong class="source-inline">yield</strong> statement in it. The main difference when using the <strong class="source-inline">yield</strong> statement is that it pauses the function and saves its internal state, and when the function is called next time, it starts from the line it yielded the last time. This design pattern makes the iterator functionality simple and efficient. </p>
			<p>Internally, methods such as <strong class="source-inline">__iter__</strong> and <strong class="source-inline">__next__</strong> are implemented automatically and the <strong class="source-inline">StopIteration</strong> exception is also raised automatically. The local attributes and their values are preserved between the successive calls and there is no additional logic to be implemented by the developer. The Python interpreter provides all this functionality whenever it identifies a generator function (a function with a <strong class="source-inline">yield</strong> statement in it).</p>
			<p>To understand how the generator works, we will start with a simple generator example that is used to generate a sequence of the first three letters of the alphabet:</p>
			<p class="source-code">#<strong class="bold">generators1</strong>.py</p>
			<p class="source-code">def my_gen():</p>
			<p class="source-code">    <strong class="bold">yield 'A'</strong></p>
			<p class="source-code">    yield 'B'</p>
			<p class="source-code">    yield 'C'</p>
			<p class="source-code">if(__name__ == "__main__"):</p>
			<p class="source-code">    <strong class="bold">iter1 = my_gen()</strong></p>
			<p class="source-code">    print(iter1.__next__())</p>
			<p class="source-code">    print(<strong class="bold">next(iter1))</strong></p>
			<p class="source-code">    print(<strong class="bold">iter1.__next__()</strong>)</p>
			<p>In this code example, we implemented a simple generator function using three <strong class="source-inline">yield</strong> statements without a <strong class="source-inline">return</strong> statement. In the main part of the program, we did the following: </p>
			<ol>
				<li>We called the generator function, which returns us an iterator instance. At this stage, no line inside the <strong class="source-inline">my_gen()</strong> generator function is executed. </li>
				<li>Using the iterator instance, we called the <strong class="source-inline">__next__</strong> method, which starts the execution of the <strong class="source-inline">my_gen()</strong> function, pauses after executing the first <strong class="source-inline">yield</strong> statement, and returns <strong class="source-inline">A</strong>. </li>
				<li>Next, we call the <strong class="source-inline">next()</strong> function on the iterator instance. The result is the same as we get with the <strong class="source-inline">__next__</strong> method. But this time, the <strong class="source-inline">my_gen()</strong> function starts <a id="_idIndexMarker402"/>the execution from the next line from where it paused the last time because of the <strong class="source-inline">yield</strong> statement. The next line is another <strong class="source-inline">yield</strong> statement, which results in another pause after returning the letter <strong class="source-inline">B</strong>.</li>
				<li>The next <strong class="source-inline">__next__</strong> method will result in the execution of the next <strong class="source-inline">yield</strong> statement, which will return the letter <strong class="source-inline">C</strong>.</li>
			</ol>
			<p>Next, we will revisit the <strong class="source-inline">Week</strong> class and its iterator implementation and will use a generator instead of an iterator class. The sample code is presented next: </p>
			<p class="source-code">#generator2.py</p>
			<p class="source-code">class Week:</p>
			<p class="source-code">    def __init__(self):</p>
			<p class="source-code">        self.days = {1:'Monday', 2: "Tuesday", </p>
			<p class="source-code">                     3:"Wednesday", 4: "Thursday", </p>
			<p class="source-code">                     5:"Friday", 6:"Saturday", 7:"Sunday"}</p>
			<p class="source-code">    <strong class="bold">def week_gen</strong>(self):</p>
			<p class="source-code">        for x in self.days:</p>
			<p class="source-code"><strong class="bold">            yield self.days[x]</strong></p>
			<p class="source-code">if(__name__ == "__main__"):</p>
			<p class="source-code">    wk = Week()</p>
			<p class="source-code">    iter1 = <strong class="bold">wk.week_gen()</strong></p>
			<p class="source-code">    iter2 = <strong class="bold">iter(wk.week_gen())</strong></p>
			<p class="source-code">    print(iter1.__next__())</p>
			<p class="source-code">    print(iter2.__next__())</p>
			<p class="source-code">    print(next(iter1))</p>
			<p class="source-code">    print(next(iter2))</p>
			<p>In comparison to <strong class="source-inline">iterator4.py</strong>, the implementation of the <strong class="source-inline">Week</strong> class with a generator is way simpler and cleaner and we can achieve the same results. This is the power of generators and that is why they are very popular in Python. Before concluding this topic, it is important to<a id="_idIndexMarker403"/> highlight a few other key features of generators:</p>
			<ul>
				<li><strong class="bold">Generator expressions</strong>: Generator <a id="_idIndexMarker404"/>expressions can be used to create simple generators (also known as <strong class="bold">anonymous functions</strong>) on the fly without <a id="_idIndexMarker405"/>writing a special method. The syntax is similar to list comprehension except we use parentheses instead of square brackets. The next code example (an extension of the example we introduced for list comprehension) shows how a generator expression can be used to create a generator, its usage, and also a comparison with list comprehension:<p class="source-code">#<strong class="bold">generator3</strong>.py</p><p class="source-code">L = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</p><p class="source-code">f1 = [x+1 for x in L]</p><p class="source-code"><strong class="bold">g1 = (x+1 for x in L)</strong></p><p class="source-code"><strong class="bold">print(g1.__next__())</strong></p><p class="source-code"><strong class="bold">print(g1.__next__())</strong></p></li>
				<li><strong class="bold">Infinite streams</strong>: Generators can <a id="_idIndexMarker406"/>also be used to implement an<a id="_idIndexMarker407"/> infinite stream of data. It is always a challenge to bring an infinite stream into memory, which is solved easily with generators as they return only one data item at a time. </li>
				<li><strong class="bold">Pipelining generators</strong>: When working with complex problems, multiple generators can be used as a <a id="_idIndexMarker408"/>pipeline to achieve any goals. The concept of pipelining multiple generators can be explained with an example. We take on a problem, which is to take the sum of the squares of prime numbers. This problem can be solved with traditional <strong class="source-inline">for</strong> loops, but we will try to solve it using two generators: the <strong class="source-inline">prime_gen</strong> generator for generating prime numbers and the <strong class="source-inline">x2_gen</strong> generator for taking the square of the prime numbers fed to this generator by the <strong class="source-inline">prime_gen</strong> generator. We feed the two generators pipelined into the <strong class="source-inline">sum</strong> function to get the desired result. Here is the code snippet for this problem solution:<p class="source-code">#<strong class="bold">generator4</strong>.py</p><p class="source-code">def <strong class="bold">prime_gen</strong>(num):</p><p class="source-code">    for cand in range(2, num+1):</p><p class="source-code">        for i in range (2, cand):</p><p class="source-code">            if (cand % i) == 0:</p><p class="source-code">                break</p><p class="source-code">        else:</p><p class="source-code">            yield cand</p><p class="source-code">def <strong class="bold">x2_gen</strong>(list2):</p><p class="source-code">    for num in list2:</p><p class="source-code">        yield num*num</p><p class="source-code"><strong class="bold">print(sum(x2_gen(prime_gen(5))))</strong></p></li>
			</ul>
			<p>Generators operate on an on-demand basis, which makes them not only memory efficient but also provides a way to generate values when they are needed. This helps to avoid unnecessary data generation, which may not be used at all. Generators are well suited to be used for a large<a id="_idIndexMarker409"/> amount of data processing, for piping<a id="_idIndexMarker410"/> the data from one function to others, and to simulate concurrency as well.</p>
			<p>In the next section, we will investigate how to handle files in Python.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor152"/>Handling files in Python</h1>
			<p>Reading data from a<a id="_idIndexMarker411"/> file or writing data to a file is one of the fundamental operations supported by any programming language. Python provides extensive support for handling file operations, which are mostly available in its standard library. In this <a id="_idIndexMarker412"/>section, we will discuss core file operations such as opening a file, closing a file, reading from a file, writing to a file, file management with context managers, and opening multiple files with one handle using the Python standard library. We will start our discussion with file operations in the next subsection.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor153"/>File operations</h2>
			<p>File operations<a id="_idIndexMarker413"/> typically start with opening a file and then reading or updating the contents in that file. The core file operations are as follows:</p>
			<h3>Opening and closing a file</h3>
			<p>To apply any read or<a id="_idIndexMarker414"/> update operation to a file, we need a pointer or reference to the file. A file reference can be obtained by opening a file using the built-in <strong class="source-inline">open</strong> function. This function<a id="_idIndexMarker415"/> returns a reference to the <strong class="source-inline">file</strong> object, which is also known as a <strong class="bold">file handle</strong> in some<a id="_idIndexMarker416"/> literature. The minimum requirement with the <strong class="source-inline">open</strong> function is the name of the file with an absolute or relative path. One optional parameter is the access mode to indicate in which mode a file is to be opened. The access mode can be <strong class="source-inline">read</strong>, <strong class="source-inline">write</strong>, <strong class="source-inline">append</strong>, or others. A full list of access mode options is as follows:</p>
			<ul>
				<li><strong class="source-inline">r</strong>: This option is for opening a file in read-only mode. This is a default option if the access mode option is not provided:<p class="source-code">f = open ('abc.txt')</p></li>
				<li><strong class="source-inline">a</strong>: This option is for opening a file to append a new line at the end of the file:<p class="source-code">f = open ('abc.txt', 'a')</p></li>
				<li><strong class="source-inline">w</strong>: This option is for opening a file for writing. If a file does not exist, it will create a new file. If the file exists, this option will override it and any existing contents in that file will be destroyed: <p class="source-code">f = open ('abc.txt', 'w')</p></li>
				<li><strong class="source-inline">x</strong>: This option is for opening a file for exclusive writing. If the file already exists, it will throw an error:<p class="source-code">f = open ('abc.txt', 'x')</p></li>
				<li><strong class="source-inline">t</strong>: This option is for opening a file in text mode. This is the default option.</li>
				<li><strong class="source-inline">b</strong>: This option is for opening a file in binary mode.</li>
				<li><strong class="source-inline">+</strong>: This option is for opening a file for reading and writing:<p class="source-code">f = open ('abc.txt', 'r+'</p></li>
			</ul>
			<p>The mode options can be combined to get multiple options. In addition to the filename and the access mode options, we can also pass the encoding type, especially for text files. Here is an example of opening a file with <strong class="source-inline">utf-8</strong>:</p>
			<p class="source-code">f = open("abc.txt", mode='r', encoding='utf-8')</p>
			<p>When we complete our operations with a file, it is a must to close the file to free up the resources for other processes<a id="_idIndexMarker417"/> to use the file. A file can be closed by using the <strong class="source-inline">close</strong> method on the file instance or the file handle. Here is a code snippet showing the use of the <strong class="source-inline">close</strong> method: </p>
			<p class="source-code">file = open("abc.txt", 'r+w')</p>
			<p class="source-code">#operations on file</p>
			<p class="source-code"><strong class="bold">file.close()</strong></p>
			<p>Once a file is closed, the<a id="_idIndexMarker418"/> resources associated with the file instance and locks (if any) will be released by the operating system, which is a best practice in any programming language.</p>
			<h3>Reading and writing files</h3>
			<p>A file can be read by <a id="_idIndexMarker419"/>opening the file in access mode <strong class="source-inline">r</strong> and then using one<a id="_idIndexMarker420"/> of the read methods. Next, we summarize different methods available for read operations:</p>
			<ul>
				<li><strong class="source-inline">read(n)</strong>: This method reads <strong class="source-inline">n</strong> characters from a file.</li>
				<li><strong class="source-inline">readline()</strong>: This method returns one line from a file.</li>
				<li><strong class="source-inline">readlines()</strong>: This method returns all lines from a file as a list.</li>
			</ul>
			<p>Similarly, we can append or write to a file once it is opened in an appropriate access mode. The methods that are relevant to appending a file are as follows:</p>
			<ul>
				<li><strong class="source-inline">write (x)</strong>: This method writes a string or a sequence of bytes to a file and returns the number of characters added to the file.</li>
				<li><strong class="source-inline">writelines (lines)</strong>: This method writes a list of lines to a file.</li>
			</ul>
			<p>In the next code example, we will create a new file, add a few text lines to it, and then read the text data using the read operations discussed previously:</p>
			<p class="source-code"><strong class="bold">#writereadfile.py: write to a file and then read from it</strong></p>
			<p class="source-code">f1 = <strong class="bold">open("myfile.txt",'w')</strong></p>
			<p class="source-code"><strong class="bold">f1.write("This is a sample file\n")</strong></p>
			<p class="source-code">lines =["This is a test data\n", "in two lines\n"]</p>
			<p class="source-code">f1.<strong class="bold">writelines</strong>(lines)</p>
			<p class="source-code">f1.close()</p>
			<p class="source-code">f2 = <strong class="bold">open("myfile.txt",'r')</strong></p>
			<p class="source-code">print(f2.<strong class="bold">read</strong>(4))</p>
			<p class="source-code">print(f2.<strong class="bold">readline</strong>())</p>
			<p class="source-code">print(f2.readline())</p>
			<p class="source-code">f2.seek(0)</p>
			<p class="source-code">for line in f2.<strong class="bold">readlines</strong>():</p>
			<p class="source-code">    print(line)</p>
			<p class="source-code">f2.close()</p>
			<p>In this code<a id="_idIndexMarker421"/> example, we write three lines to a file first. In the read operations, first, we<a id="_idIndexMarker422"/> read four characters, followed by reading two lines using the <strong class="source-inline">readline</strong> method. In the end, we move the pointer back to the top of the file using the <strong class="source-inline">seek</strong> method and access all lines in the file using the <strong class="source-inline">readlines</strong> method.</p>
			<p>In the next section, we will see how the use of a context manager makes file handling convenient. </p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor154"/>Using a context manager</h2>
			<p>Correct and fair usage<a id="_idIndexMarker423"/> of resources is critical in any programming language. A file handler and a database connection are a couple of many examples where it is a common practice to not release the resources on time after working with objects. If the resources are not released at all, then it will end up in a situation called <strong class="bold">memory leakage</strong> and may<a id="_idIndexMarker424"/> impact the system performance, and ultimately may result in the system crashing. </p>
			<p>To solve this memory<a id="_idIndexMarker425"/> leakage and timely resource release problem, Python came up with the concept of context managers. A context manager is designed to reserve and release resources precisely as per the design. When a context manager is used with the <strong class="source-inline">with</strong> keyword, a statement after the <strong class="source-inline">with</strong> keyword is expected to return an object that must implement the <strong class="bold">context management protocol</strong>. This protocol requires two<a id="_idIndexMarker426"/> special methods to be implemented by the returned object. These special methods are as follows: </p>
			<ul>
				<li><strong class="source-inline">.__enter__()</strong>: This method is called with the <strong class="source-inline">with</strong> keyword and is used to reserve the resources required as per the statement after the <strong class="source-inline">with</strong> keyword.</li>
				<li><strong class="source-inline">.__exit__()</strong>: This method is called after the execution of the <strong class="source-inline">with</strong> block and is used to release the resources that are reserved in the <strong class="source-inline">.__enter__()</strong> method.</li>
			</ul>
			<p>For example, when a file is opened using the context manager <strong class="source-inline">with</strong> statement (block), there is no need to close the file. The file <strong class="source-inline">open</strong> statement will return the file handler object, which has already implemented the context management protocol and the file will be closed automatically as soon the execution of the <strong class="source-inline">with</strong> block is completed. A revised version of the code example for writing and reading a file using the context manager is as follows: </p>
			<p class="source-code">#<strong class="bold">contextmgr1</strong>.py</p>
			<p class="source-code"><strong class="bold">with open</strong>("myfile.txt",'w') <strong class="bold">as f1</strong>:</p>
			<p class="source-code">    f1.write("This is a sample file\n")</p>
			<p class="source-code">    lines = ["This is a test data\n", "in two lines\n"]</p>
			<p class="source-code">    f1.writelines(lines)</p>
			<p class="source-code"><strong class="bold">with open</strong>("myfile.txt",'r') <strong class="bold">as f2</strong>:</p>
			<p class="source-code">    for line in f2.readlines():</p>
			<p class="source-code">        print(line)</p>
			<p>The code with the context manager is simple and easy to read. The use of a context manager is a recommended <a id="_idIndexMarker427"/>approach for opening and working with files. </p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor155"/>Operating on multiple files</h2>
			<p>Python supports opening<a id="_idIndexMarker428"/> and operating on multiple files at the same time. We can open these files in different modes and operate on them. There is no limit on the number of files. We can open two files in read mode by using the following sample code and access the files in any order:</p>
			<p class="source-code"><strong class="bold">1.txt</strong></p>
			<p class="source-code">This is a sample file 1</p>
			<p class="source-code">This is a test data 1</p>
			<p class="source-code"><strong class="bold">2.txt</strong></p>
			<p class="source-code">This is a sample file 2</p>
			<p class="source-code">This is a test data 2</p>
			<p class="source-code">#<strong class="bold">multifilesread1.py</strong></p>
			<p class="source-code">with <strong class="bold">open("1.txt") as file1, open("2.txt") as file2</strong>:</p>
			<p class="source-code">    print(file2.readline())</p>
			<p class="source-code">    print(file1.readline())</p>
			<p>We can also read from one file and write to another file using this multifile operating option. Sample code to transfer contents from one file to another file is as follows:</p>
			<p class="source-code">#<strong class="bold">multifilesread2.py</strong></p>
			<p class="source-code"><strong class="bold">with open("1.txt",'r') as file1, open("3.txt",'w') as file2:</strong></p>
			<p class="source-code">   for line in file1.readlines():</p>
			<p class="source-code">     file2.write(line)</p>
			<p>Python also has a more elegant solution to operate on multiple files using the <strong class="source-inline">fileinput</strong> module. This module's input function can take a list of multiple files and then treat all such files as a single input. Sample <a id="_idIndexMarker429"/>code with two input files, <strong class="source-inline">1.txt</strong> and <strong class="source-inline">2.txt</strong>, and using the <strong class="source-inline">fileinput</strong> module is presented next:</p>
			<p class="source-code">#<strong class="bold">multifilesread1</strong>.py</p>
			<p class="source-code">import <strong class="bold">fileinput</strong></p>
			<p class="source-code">with <strong class="bold">fileinput.input</strong>(<strong class="bold">files = ("1.txt",'2.txt'</strong>)) <strong class="bold">as f</strong>:</p>
			<p class="source-code">    for line in f:</p>
			<p class="source-code">        print(f.<strong class="bold">filename</strong>())</p>
			<p class="source-code">        print(line)</p>
			<p>With this approach, we get one file handle that operates on multiple files sequentially. Next, we will discuss error and exception handling in Python.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor156"/>Handling errors and exceptions</h1>
			<p>There are many types <a id="_idIndexMarker430"/>of errors possible in Python. The most common one is related to the syntax <a id="_idIndexMarker431"/>of the program and is typically known as a <strong class="bold">syntax error</strong>. On many occasions, errors are reported during <a id="_idIndexMarker432"/>the execution of a program. Such errors are called <strong class="bold">runtime errors</strong>. The runtime errors that can be handled <a id="_idIndexMarker433"/>within our program are called <strong class="bold">exceptions</strong>. This section will focus on how to handle runtime errors or exceptions. Before jumping on to error handling, we will briefly introduce the most common runtime errors as follows:</p>
			<ul>
				<li><strong class="source-inline">IndexError</strong>: This error occurs when a program tries to access an item at an invalid index (location in the memory).</li>
				<li><strong class="source-inline">ModuleNotFoundError</strong>: This error will be thrown when a specified module is not found at the system path.</li>
				<li><strong class="source-inline">ZeroDivisionError</strong>: This error is thrown when a program tries to divide a number by zero.</li>
				<li><strong class="source-inline">KeyError</strong>: This error occurs when a program tries to fetch a value from a dictionary using an invalid key.</li>
				<li><strong class="source-inline">StopIteration</strong>: This error is thrown when the <strong class="source-inline">__next__</strong> method does not find any further items in a container.</li>
				<li><strong class="source-inline">TypeError</strong>: This error occurs when a program tries to apply an operation on an object of an inappropriate type.</li>
			</ul>
			<p>A complete list of errors is available in the official documentation of Python. In the following subsections, we <a id="_idIndexMarker434"/>will discuss how to handle errors, sometimes also called<a id="_idIndexMarker435"/> exceptions, using appropriate constructs in Python.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor157"/>Working with exceptions in Python</h2>
			<p>When runtime errors arise, the program<a id="_idIndexMarker436"/> can terminate abruptly and can cause damage to system resources such as corrupting files and database tables. This is why error or exception handling is one of the key ingredients of writing<a id="_idIndexMarker437"/> robust programs in any language. The idea is to anticipate that runtime errors can occur and if such an error occurs, what the behavior of our program would be as a response to that particular error. </p>
			<p>Like many other languages, Python uses the <strong class="source-inline">try</strong> and <strong class="source-inline">except</strong> keywords. The two keywords are followed by separate blocks of code to be executed. The <strong class="source-inline">try</strong> block is a regular set of statements for which we anticipate that an error may occur. The <strong class="source-inline">except</strong> block will be executed only if there is an error in a <strong class="source-inline">try</strong> block. Next is the syntax of writing Python code with <strong class="source-inline">try</strong> and <strong class="source-inline">except</strong> blocks:</p>
			<p class="source-code"><strong class="bold">try</strong>:</p>
			<p class="source-code">    #a series of statements</p>
			<p class="source-code"><strong class="bold">except</strong>:</p>
			<p class="source-code">    #statements to be executed if there is an error in \</p>
			<p class="source-code">     try block</p>
			<p>If we anticipate a particular error type or multiple error types, we can define an <strong class="source-inline">except</strong> block with the error name and can add as many <strong class="source-inline">except</strong> blocks as we need. Such named <strong class="source-inline">except</strong> blocks are executed only if the named exception is raised in the <strong class="source-inline">try</strong> block. With the <strong class="source-inline">except</strong> block <a id="_idIndexMarker438"/>statement, we can also add an <strong class="source-inline">as</strong> statement to store the exception object as a variable that is raised during the <strong class="source-inline">try</strong> block. The <strong class="source-inline">try</strong> block in<a id="_idIndexMarker439"/> the next code example has many possible runtime errors and that is why it has multiple <strong class="source-inline">except</strong> blocks:</p>
			<p class="source-code">#<strong class="bold">exception1</strong>.py</p>
			<p class="source-code">try:</p>
			<p class="source-code">    <strong class="bold">print (x)</strong></p>
			<p class="source-code">    x = 5</p>
			<p class="source-code">    y = 0</p>
			<p class="source-code">    <strong class="bold">z = x /y</strong></p>
			<p class="source-code">    <strong class="bold">print('x'+ y)</strong></p>
			<p class="source-code">except <strong class="bold">NameError as e</strong>:</p>
			<p class="source-code">    print(e)</p>
			<p class="source-code">except <strong class="bold">ZeroDivisionError</strong>:</p>
			<p class="source-code">    print("Division by 0 is not allowed")</p>
			<p class="source-code">except <strong class="bold">Exception as e</strong>:</p>
			<p class="source-code">    print("An error occured")</p>
			<p class="source-code">    print(e)</p>
			<p>To illustrate a better use of an <strong class="source-inline">except</strong> block(s), we added multiple except blocks that are explained next:</p>
			<ul>
				<li><strong class="bold">The NameError block</strong>: This block will be<a id="_idIndexMarker440"/> executed when a statement in the <strong class="source-inline">try</strong> block tries to access an undefined variable. In our code example, this block will be executed when the interpreter tries to execute the <strong class="source-inline">print(x)</strong> statement. Additionally, we named the exception object as <strong class="source-inline">e</strong> and used it with the <strong class="source-inline">print</strong> statement to get the official error detail associated with this error type.</li>
				<li><strong class="bold">The ZeroDivisionError block</strong>: This block <a id="_idIndexMarker441"/>will be executed when we try to execute <strong class="source-inline">z = x/y</strong> and y = 0. For this block to be executed, we need to fix the <strong class="source-inline">NameError</strong> block first. </li>
				<li><strong class="bold">The default except block</strong>: This is a <a id="_idIndexMarker442"/>catch-all <strong class="source-inline">except</strong> block, which means if no match is found with the previous two <strong class="source-inline">except</strong> blocks, this block will be executed. The last <a id="_idIndexMarker443"/>statement <strong class="source-inline">print('x'+ y)</strong> will also raise an error of type <strong class="source-inline">TypeError</strong> and will be handled by this block. Since we are not receiving any one particular type of exception in this block, we can use the <strong class="source-inline">Exception</strong> keyword to store the exception object in a<a id="_idIndexMarker444"/> variable.</li>
			</ul>
			<p>Note that as soon an error occurs in any statement in the <strong class="source-inline">try</strong> block, the rest of the statements are ignored, and the control goes to one of the <strong class="source-inline">except</strong> blocks. In our code example, we need to fix the <strong class="source-inline">NameError</strong> error first to see the next level of exception and so on. We added three different types of errors in our example to demonstrate how to define multiple <strong class="source-inline">except</strong> blocks for the same <strong class="source-inline">try</strong> block. The order of the <strong class="source-inline">except</strong> blocks is important because more specific <strong class="source-inline">except</strong> blocks with error names have to be defined first and an <strong class="source-inline">except</strong> block without specifying an error name has to always be at the end. </p>
			<p>The following figure shows all the exception handling blocks: </p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B17189_04_01.jpg" alt="Figure 4.1 – Different exception handling blocks in Python&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Different exception handling blocks in Python</p>
			<p>As shown in the preceding<a id="_idIndexMarker445"/> diagram, in addition to <strong class="source-inline">try</strong> and <strong class="source-inline">except</strong> blocks, Python also supports <strong class="source-inline">else</strong> and <strong class="source-inline">finally</strong> blocks to enhance the error handling <a id="_idIndexMarker446"/>functionality. The <strong class="source-inline">else</strong> block is executed if no errors were raised during the <strong class="source-inline">try</strong> block. The code in this block will be executed as normal and no exception will be thrown if any error occurs within this block. Nested <strong class="source-inline">try</strong> and <strong class="source-inline">except</strong> blocks can be added within the <strong class="source-inline">else</strong> block if needed. Note that this block is optional. </p>
			<p>The <strong class="source-inline">finally</strong> block is executed regardless of whether there is an error in the <strong class="source-inline">try</strong> block or not. The code inside the <strong class="source-inline">finally</strong> block is executed without any exception handling mechanism. This block is mainly used to free up the resources by closing the connections or opened files. Although it is an optional block, it is highly recommended to implement this block. </p>
			<p>Next, we will look at the use of these blocks with a code example. In this example, we will open a new file for writing in the <strong class="source-inline">try</strong> block. If an error occurs in opening the file, an exception will be thrown, and we will send the error details to the console using the <strong class="source-inline">print</strong> statement in the <strong class="source-inline">except</strong> block. If no error occurs, we will execute the code in the <strong class="source-inline">else</strong> block that is writing some text to the file. In both cases (error or no error), we will close the file in the <strong class="source-inline">finally</strong> block. The complete sample code is as follows: </p>
			<p class="source-code">#<strong class="bold">exception2</strong>.py</p>
			<p class="source-code"><strong class="bold">try:</strong></p>
			<p class="source-code">    f = open("abc.txt", "w")</p>
			<p class="source-code"><strong class="bold">except</strong> Exception as e:</p>
			<p class="source-code">    print("Error:" + e)</p>
			<p class="source-code"><strong class="bold">else:</strong></p>
			<p class="source-code">    f.write("Hello World")</p>
			<p class="source-code">    f.write("End")</p>
			<p class="source-code"><strong class="bold">finally:</strong></p>
			<p class="source-code">    f.close()</p>
			<p>We have covered<a id="_idIndexMarker447"/> extensively how to handle an exception in Python. Next, we will<a id="_idIndexMarker448"/> discuss how to raise an exception from Python code.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor158"/>Raising exceptions</h2>
			<p>Exceptions or errors are raised by the<a id="_idIndexMarker449"/> Python interpreter at runtime when an error occurs. We can also raise errors or exceptions ourselves if a condition occurs that may give us bad output or crash the program if we proceed further. Raising an error or exception will provide a graceful exit of the program.</p>
			<p>An exception (object) can be thrown to the caller by using the <strong class="source-inline">raise</strong> keyword. An exception can be of one of the following types:</p>
			<ul>
				<li>A built-in exception</li>
				<li>A custom exception</li>
				<li>A generic <strong class="source-inline">Exception</strong> object</li>
			</ul>
			<p>In the next code example, we will be calling a simple function to calculate a square root and will implement it to throw an exception if the input parameter is not a valid positive number:</p>
			<p class="source-code">#<strong class="bold">exception3</strong>.py</p>
			<p class="source-code">import math</p>
			<p class="source-code">def sqrt(num):</p>
			<p class="source-code">    if not isinstance(num, (int, float)) :</p>
			<p class="source-code">        <strong class="bold">raise TypeError</strong>("only numbers are allowed")</p>
			<p class="source-code">    if num &lt; 0:</p>
			<p class="source-code">        <strong class="bold">raise Exception</strong> ("Negative number not supported")</p>
			<p class="source-code">    return math.sqrt(num)</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    try:</p>
			<p class="source-code">        print(sqrt(9))</p>
			<p class="source-code">        <strong class="bold">print(sqrt('a'))</strong></p>
			<p class="source-code">        <strong class="bold">print (sqrt(-9))</strong></p>
			<p class="source-code">    except Exception as e:</p>
			<p class="source-code">        print(e)</p>
			<p>In this code example, we raised a <a id="_idIndexMarker450"/>built-in exception by creating a new instance of the <strong class="source-inline">TypeError</strong> class when the number passed to the <strong class="source-inline">sqrt</strong> function is not a number. We also raised a generic exception when the number passed is lower than <strong class="source-inline">0</strong>. In both cases, we passed our custom text to its constructor. In the next section, we will study how to define our own custom exception and then throw it to the caller.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor159"/>Defining custom exceptions</h2>
			<p>In Python, we can define our own custom<a id="_idIndexMarker451"/> exceptions by creating a new class that has to be derived from the built-in <strong class="source-inline">Exception</strong> class or its subclass. To illustrate the concept, we will revise our previous example by defining two custom exception classes to replace the built-in <strong class="source-inline">TypeError</strong> and the <strong class="source-inline">Exception</strong> error types. The new custom exception classes will be derived from the <strong class="source-inline">TypeError</strong> and the <strong class="source-inline">Exception</strong> classes. Here is sample code for reference with custom exceptions:</p>
			<p class="source-code">#<strong class="bold">exception4</strong>.py</p>
			<p class="source-code">import math</p>
			<p class="source-code"><strong class="bold">class NumTypeError(TypeError):</strong></p>
			<p class="source-code">    pass</p>
			<p class="source-code"><strong class="bold">class NegativeNumError(Exception):</strong></p>
			<p class="source-code">    <strong class="bold">def __init__(self):</strong></p>
			<p class="source-code">        super().__init__("Negative number not supported")</p>
			<p class="source-code">def sqrt(num):</p>
			<p class="source-code">    if not isinstance(num, (int, float)) :</p>
			<p class="source-code">        <strong class="bold">raise NumTypeError</strong>("only numbers are allowed")</p>
			<p class="source-code">    if num &lt; 0:</p>
			<p class="source-code">        <strong class="bold">raise NegativeNumError</strong></p>
			<p class="source-code">    return math.sqrt(num)</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    try:</p>
			<p class="source-code">        print(sqrt(9))</p>
			<p class="source-code">        <strong class="bold">print(sqrt('a'))</strong></p>
			<p class="source-code">        <strong class="bold">print (sqrt(-9))</strong></p>
			<p class="source-code">    except <strong class="bold">NumTypeError as e</strong>:</p>
			<p class="source-code">        print(e)</p>
			<p class="source-code">    except <strong class="bold">NegativeNumError as e</strong>:</p>
			<p class="source-code">        print(e)</p>
			<p>In this code example, the <strong class="source-inline">NumTypeError</strong> class is derived from the <strong class="source-inline">TypeError</strong> class and we have not added anything in this class. The <strong class="source-inline">NegativeNumError</strong> class is inherited from the <strong class="source-inline">Exception</strong> class and <a id="_idIndexMarker452"/>we override its constructor and add a custom message for this exception as part of the constructor. When we raise these custom exceptions in the <strong class="source-inline">sqrt()</strong> function, we do not pass any text with the <strong class="source-inline">NegativeNumError</strong> exception class. When we used the main program, we get the message with the <strong class="source-inline">print (e)</strong> statement as we have set it as part of the class definition.  </p>
			<p>In this section, we covered how to handle built-in error types using <strong class="source-inline">try</strong> and <strong class="source-inline">except</strong> blocks, how to define custom exceptions, and how to raise an exception declaratively. In the next section, we will cover logging in Python.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor160"/>Using the Python logging module</h1>
			<p>Logging is a fundamental<a id="_idIndexMarker453"/> requirement for any reasonably sized application. Logging not only helps in debugging and troubleshooting but also provides insight into<a id="_idIndexMarker454"/> details of an application's internal issues. A few advantages of logging are as follows:</p>
			<ul>
				<li>Debugging code, especially to diagnose why and when an application failed or crashed</li>
				<li>Diagnosing unusual application behavior</li>
				<li>Providing auditing data for regulatory or legal compliance matters</li>
				<li>Identifying users' behaviors and malicious attempts to access unauthorized resources </li>
			</ul>
			<p>Before discussing any <a id="_idIndexMarker455"/>practical ex<a id="_idTextAnchor161"/>amples of logging, we will first discuss the key <a id="_idIndexMarker456"/>components of the logging system in Python. </p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor162"/>Introducing core logging components</h2>
			<p>The following components are <a id="_idIndexMarker457"/>fundamental to set up logging for an <a id="_idIndexMarker458"/>application in Python:</p>
			<ul>
				<li>Logger</li>
				<li>Logging levels</li>
				<li>Logging formatter</li>
				<li>Logging handler</li>
			</ul>
			<p>A high-level architecture of the Python logging system can be summarized here:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B17189_04_02.jpg" alt="Figure 4.2 – Logging components in Python&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Logging components in Python</p>
			<p>Each of these components is discussed in detail in the following subsections.</p>
			<h3>The logger</h3>
			<p>The logger is the entry point to the Python logging system. It is the interface to the application programmer. The <strong class="source-inline">Logger</strong> class available in Python provides several methods to log messages with different priorities. We will study the <strong class="source-inline">Logger</strong> class methods with code examples later in this section.</p>
			<p>An application<a id="_idIndexMarker459"/> interacts with the <strong class="source-inline">Logger</strong> instance, which is set up using logging configuration such as the logging level. On receiving logging events, the <strong class="source-inline">Logger</strong> instance selects one or more appropriate logging handlers and delegates the events to the handlers. Each handler is typically designed for a specific output target. A handler sends the messages after applying a filter and formatting to the intended output target. </p>
			<h3>Logging levels</h3>
			<p>All events and messages for a<a id="_idIndexMarker460"/> logging system are not of the same priority. For example, messages about errors are more urgent than warning messages. Logging levels are a way to set different priorities for different logging events. There are six levels defined in Python. Each level is associated with an integer value that indicates the severity. These levels are <strong class="source-inline">NOTSET</strong>, <strong class="source-inline">DEBUG</strong>, <strong class="source-inline">INFO</strong>, <strong class="source-inline">WARNING</strong>, <strong class="source-inline">ERROR</strong>, and <strong class="source-inline">CRITICAL</strong>. These are summarized here:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B17189_04_03.jpg" alt="Figure 4.3 – Logging levels in Python&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Logging levels in Python</p>
			<h3>The logging formatter</h3>
			<p>The logging formatter component helps to<a id="_idIndexMarker461"/> improve the formatting of messages, which is important for consistency and for human and machine readability. The logging formatter also adds extra context to messages such as time, module name, line number, threads, and process, which is extremely useful for debugging purposes. An example formatter expression is as follows:</p>
			<p class="source-code">"%(asctime)s — %(name)s — %(levelname)s — %(funcName)s:%(lineno)d — %(message)s"</p>
			<p>When such a formatter expression is used, the log message <strong class="source-inline">hello Geeks</strong> of level <strong class="source-inline">INFO</strong> will be displayed similar to the console output that follows:</p>
			<p class="source-code">2021-06-10 19:20:10,864 - a.b.c - INFO - &lt;module name&gt;:10 - hello Geeks</p>
			<h3>The logging handler</h3>
			<p>The role of a logging handler is to <a id="_idIndexMarker462"/>write log data to an appropriate destination, which can be a console, a file, or even an email. There are many types of built-in logging handlers available in Python. A few popular handlers are introduced here: </p>
			<ul>
				<li><strong class="source-inline">StreamHandler</strong> for displaying the logs on a console</li>
				<li><strong class="source-inline">FileHandler</strong> for writing the logs to a file</li>
				<li><strong class="source-inline">SMTPHandler</strong> for sending the logs to an email</li>
				<li><strong class="source-inline">SocketHandler</strong> for sending the logs to a network socket</li>
				<li><strong class="source-inline">SyslogHandler</strong> for sending the logs to a local or remote <em class="italic">Unix</em> syslog server</li>
				<li><strong class="source-inline">HTTPHandler</strong> for sending the logs to a web server using either <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong> methods</li>
			</ul>
			<p>The logging handler uses the logging<a id="_idIndexMarker463"/> formatter to add more context info to the logs and the logging level to filter the logging data. </p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor163"/>Working with the logging module</h2>
			<p>In this section, we will discuss how<a id="_idIndexMarker464"/> to use the <strong class="source-inline">logging</strong> module with code examples. We will start with basic logging options and will take them to an advanced level in a gradual manner. </p>
			<h3>Using the default logger </h3>
			<p>Without creating an instance of <a id="_idIndexMarker465"/>any logger class, there is already a default logger available in Python. The default logger, also known as the <strong class="bold">root logger</strong>, can be used<a id="_idIndexMarker466"/> by importing the <strong class="source-inline">logging</strong> module and using its methods to dispatch logging events. The next code snippet shows the use of the root logger for capturing log events:</p>
			<p class="source-code">#<strong class="bold">logging1</strong>.py</p>
			<p class="source-code">import <strong class="bold">logging</strong></p>
			<p class="source-code"><strong class="bold">logging.debug</strong>("This is a debug message")</p>
			<p class="source-code"><strong class="bold">logging.warning</strong>("This is a warning message")</p>
			<p class="source-code"><strong class="bold">logging.info</strong>("This is an info message")</p>
			<p>The <strong class="source-inline">debug</strong>, <strong class="source-inline">warning</strong>, and <strong class="source-inline">info</strong> methods are used to dispatch logging events to the logger as per their severity. The default log level for this logger is set to <strong class="source-inline">WARNING</strong> and the default output is set to <strong class="source-inline">stderr</strong>, which means all the messages will go to the console or terminal only. This setting will block <strong class="source-inline">DEBUG</strong> and <strong class="source-inline">INFO</strong> messages to be displayed on the console output, which will be as follows:</p>
			<p class="source-code">WARNING:root:This is a warning message</p>
			<p>The level of the root<a id="_idIndexMarker467"/> logger can be changed by adding the following line after the <strong class="source-inline">import</strong> statement:</p>
			<p class="source-code">logging.<strong class="bold">basicConfig</strong>(level=logging.DEBUG)</p>
			<p>After changing the logging level to <strong class="source-inline">DEBUG</strong>, the console output will now show all the log messages:</p>
			<p class="source-code">DEBUG:root:This is a debug message</p>
			<p class="source-code">WARNING:root:This is a warning message</p>
			<p class="source-code">INFO:root:This is an info message</p>
			<p>Although we discussed the default or root logger in this subsection, it is not recommended to use it other than for basic logging purposes. As a best practice, we should create a new logger with a name, which we will discuss in the next code examples. </p>
			<h3>Using a named logger</h3>
			<p>We can create a separate logger with its<a id="_idIndexMarker468"/> own name and possibly with its own log level, handlers, and formatters. The next code snippet is an example of creating a logger with a custom name and also using a different logging level than the root logger:</p>
			<p class="source-code">#<strong class="bold">logging2</strong>.py</p>
			<p class="source-code">import logging</p>
			<p class="source-code">logger1 = <strong class="bold">logging.getLogger</strong>("my_logger")</p>
			<p class="source-code">logging.<strong class="bold">basicConfig</strong>()</p>
			<p class="source-code">logger1.<strong class="bold">setLevel</strong>(logging.INFO)</p>
			<p class="source-code">logger1.<strong class="bold">warning</strong>("This is a warning message")</p>
			<p class="source-code">logger1.<strong class="bold">info</strong>("This is a info message")</p>
			<p class="source-code">logger1.<strong class="bold">debug</strong>("This is a debug message")</p>
			<p class="source-code">logging.<strong class="bold">info</strong>("This is an info message")</p>
			<p>When we create a logger instance using the <strong class="source-inline">getLogger</strong> method with a string name or using the module name (by using the <strong class="source-inline">__name__</strong> global variable), then only one instance is managed for one name. This means if we try to use the <strong class="source-inline">getLogger</strong> method with the same name in any part of the application, the Python interpreter will check whether there is already an instance created for this name. If there is already one created, it will return the same instance. </p>
			<p>After creating a logger instance, we need to make a call to the root logger (<strong class="source-inline">basicConfig()</strong>) to provide a handler and formatter to our logger. Without any handler configuration, we<a id="_idIndexMarker469"/> will get an internal handler as the last resort, which will only output messages without any formatting and the logging level will be <strong class="source-inline">WARNING</strong> regardless of the logging level we set for our logger. The console output of this code snippet is shown next, and it is as expected:</p>
			<p class="source-code">WARNING:my_logger:This is a warning message</p>
			<p class="source-code">INFO:my_logger:This is a info message</p>
			<p>It is also important to note the following:</p>
			<ul>
				<li>We set the logging level for our logger to <strong class="source-inline">INFO</strong> and we were able to log <strong class="source-inline">warning</strong> and <strong class="source-inline">info</strong> messages but not the debug message.</li>
				<li>When we used the root logger (by using the <strong class="source-inline">logging</strong> instance), we were not able to send out the <strong class="source-inline">info</strong> message. This was because the root logger was still using the default logging level, which is <strong class="source-inline">WARNING</strong>.</li>
			</ul>
			<h3>Using a logger with a built-in handler and custom formatter</h3>
			<p>We can create a logger object using a built-in handler but with a custom formatter. In this case, the handler object can <a id="_idIndexMarker470"/>use a custom formatter object and the handler object can be added to the logger object as its handler before we start using the logger for any log events. Here is a code snippet to illustrate how to create a handler and a formatter programmatically and then add the handler to the logger:</p>
			<p class="source-code">#<strong class="bold">logging3</strong>.py</p>
			<p class="source-code">import logging</p>
			<p class="source-code">logger = logging.getLogger('my_logger')</p>
			<p class="source-code">my_handler = <strong class="bold">logging.StreamHandler</strong>()</p>
			<p class="source-code">my_formatter = <strong class="bold">logging.Formatter</strong>('%(asctime)s - '\</p>
			<p class="source-code">                  '%(name)s - %(levelname)s - %(message)s')</p>
			<p class="source-code">my_handler.<strong class="bold">setFormatter</strong>(my_formatter)</p>
			<p class="source-code">logger.<strong class="bold">addHandler</strong>(my_handler)</p>
			<p class="source-code">logger.<strong class="bold">setLevel</strong>(logging.INFO)</p>
			<p class="source-code">logger.warning("This is a warning message")</p>
			<p class="source-code">logger.info("This is an info message")</p>
			<p class="source-code">logger.debug("This is a debug message")</p>
			<p>We can create a logger with the same settings by using the <strong class="source-inline">basicConfig</strong> method as well with appropriate arguments. The next code snippet is a revised version of <strong class="source-inline">logging3.py</strong> with the <strong class="source-inline">basicConfig</strong> settings:</p>
			<p class="source-code">#<strong class="bold">logging3A</strong>.py</p>
			<p class="source-code">import logging</p>
			<p class="source-code">logger = logging.getLogger('my_logger')</p>
			<p class="source-code">logging.<strong class="bold">basicConfig</strong>(<strong class="bold">handlers</strong>=[logging.StreamHandler()],</p>
			<p class="source-code">                    <strong class="bold">format</strong>="%(asctime)s - %(name)s - "</p>
			<p class="source-code">                           "%(levelname)s - %(message)s",</p>
			<p class="source-code">                    <strong class="bold">level</strong>=logging.INFO)</p>
			<p class="source-code">logger.warning("This is a warning message")</p>
			<p class="source-code">logger.info("This is an info message")</p>
			<p class="source-code">logger.debug("This is a debug message")</p>
			<p>Up till now, we have covered <a id="_idIndexMarker471"/>cases where we used built-in classes and objects to set up our loggers. Next, we will set up a logger with custom handlers and formatters.</p>
			<h3>Using a logger with a file handler </h3>
			<p>The logging handler sends the<a id="_idIndexMarker472"/> log messages to their final destination. By default, every logger is set up to send log messages to the console or terminal associated with the running program. But this can be changed by configuring a logger with a new handler with a different destination. A file handler can be created by using one of the two approaches we already discussed in the previous subsection. In this section, we will use a third approach to create a file handler automatically with the <strong class="source-inline">basicConfig</strong> method by providing the filename as an attribute to this method. This is shown in the next code snippet:</p>
			<p class="source-code"> #<strong class="bold">logging4</strong>.py</p>
			<p class="source-code">import logging</p>
			<p class="source-code">logging.<strong class="bold">basicConfig(filename='logs/logging4.log'</strong> </p>
			<p class="source-code">                    ,<strong class="bold">level=logging.DEBUG</strong>)</p>
			<p class="source-code">logger = logging.getLogger('my_logger')</p>
			<p class="source-code">logger.setLevel(logging.INFO)</p>
			<p class="source-code">logger.warning("This is a warning message")</p>
			<p class="source-code">logger.info("This is a info message")</p>
			<p class="source-code">logger.debug("This is a debug message")</p>
			<p>This will generate log messages to the file we specified with the <strong class="source-inline">basicConfig</strong> method and as per the logging <a id="_idIndexMarker473"/>level, which is<a id="_idIndexMarker474"/> set to <strong class="source-inline">INFO</strong>. </p>
			<h3>Using a logger with multiple handlers programmatically </h3>
			<p>Creating a logger with multiple handlers is <a id="_idIndexMarker475"/>pretty straightforward and can be achieved either by using the <strong class="source-inline">basicConfig</strong> method or by attaching handlers manually to a logger. For illustration purposes, we will revise our code example <strong class="source-inline">logging3.py</strong> to do the following:</p>
			<ol>
				<li value="1">We will create two handlers (one for the console output and one for the file output) that are instances of the <strong class="source-inline">streamHandler</strong> and <strong class="source-inline">fileHandler</strong> classes.</li>
				<li>We will create two separate formatters, one for each handler. We will not include the time information for the formatter of the console handler.</li>
				<li>We will set separate logging levels for the two handlers. It is important to understand that the logging level at the handler level cannot override the root level handler. </li>
			</ol>
			<p>Here is the complete code example:</p>
			<p class="source-code">#<strong class="bold">logging5</strong>.py</p>
			<p class="source-code">import logging</p>
			<p class="source-code">logger = logging.getLogger('my_logger')</p>
			<p class="source-code"><strong class="bold">logger.setLevel(logging.DEBUG)</strong></p>
			<p class="source-code">console_handler = <strong class="bold">logging.StreamHandler()</strong></p>
			<p class="source-code">file_handler = <strong class="bold">logging.FileHandler</strong>("logs/logging5.log")</p>
			<p class="source-code">#<strong class="bold">setting logging levels at the handler level</strong></p>
			<p class="source-code">console_handler.setLevel(logging.DEBUG)</p>
			<p class="source-code">file_handler.setLevel(logging.INFO)</p>
			<p class="source-code">#<strong class="bold">creating separate formatter for two handlers</strong></p>
			<p class="source-code">console_formatter = logging.Formatter(</p>
			<p class="source-code">                  '%(name)s - %(levelname)s - %(message)s')</p>
			<p class="source-code">file_formatter = logging.Formatter('%(asctime)s - '</p>
			<p class="source-code">                  '%(name)s - %(levelname)s - %(message)s')</p>
			<p class="source-code">#<strong class="bold">adding formatters to the handler</strong></p>
			<p class="source-code">console_handler.setFormatter(console_formatter)</p>
			<p class="source-code">file_handler.setFormatter(file_formatter)</p>
			<p class="source-code">#<strong class="bold">adding handlers to the logger</strong></p>
			<p class="source-code">logger.addHandler(console_handler)</p>
			<p class="source-code">logger.addHandler(file_handler)</p>
			<p class="source-code">logger.error("This is an error message")</p>
			<p class="source-code">logger.warning("This is a warning message")</p>
			<p class="source-code">logger.info("This is an info message")</p>
			<p class="source-code">logger.debug("This is a debug message")</p>
			<p>Although we set different logging levels for the two handlers, which are <strong class="source-inline">INFO</strong> and <strong class="source-inline">DEBUG</strong>, they will be effective only if the logging level of the logger is at a lower value (the default is <strong class="source-inline">WARNING</strong>). This is why we have to set the logging level for our logger to <strong class="source-inline">DEBUG</strong> at the beginning of the program. The logging level at the handler level can be <strong class="source-inline">DEBUG</strong> or any higher<a id="_idIndexMarker476"/> level. This is a very important point to consider whenever designing a logging strategy for your application. </p>
			<p>In the code example shared in this section, we basically configured the logger programmatically. In the next section, we will work on how to configure a logger through a configuration file. </p>
			<h3>Configuring a logger with multiple handlers using a configuration file</h3>
			<p>Setting up a logger<a id="_idIndexMarker477"/> programmatically is appealing but not practical for production environments. In production environments, we have to set up the logger configuration differently as compared to the development setup <a id="_idIndexMarker478"/>and sometimes we have to enhance the logging level to troubleshoot problems that we encounter only in live environments. This is why we have the option of providing the logger configuration through a file that is easy to change as per the target environment. The configuration file for a logger can be written using <strong class="bold">JSON</strong> (<strong class="bold">JavaScript Object Notation</strong>) or <strong class="bold">YAML</strong> (<strong class="bold">Yet Another Markup Language</strong>) or as a list of <a id="_idIndexMarker479"/><em class="italic">key:value</em> pairs in a <strong class="source-inline">.conf</strong> file. For illustration purposes, we <a id="_idIndexMarker480"/>will demonstrate the logger configuration using a YAML file, which is exactly the same as we achieved programmatically in the previous section. The complete YAML file and the Python code is as follows:</p>
			<p>The following is the YAML config file:</p>
			<p class="source-code">version: 1</p>
			<p class="source-code">formatters:</p>
			<p class="source-code">  <strong class="bold">console_formatter</strong>:</p>
			<p class="source-code">    format: '%(name)s - %(levelname)s - %(message)s'</p>
			<p class="source-code">  <strong class="bold">file_formatter</strong>:</p>
			<p class="source-code">      format: '%(asctime)s - %(name)s - %(levelname)s -         %(message)s'</p>
			<p class="source-code">handlers:</p>
			<p class="source-code">  <strong class="bold">console_handler</strong>:</p>
			<p class="source-code">    class: logging.StreamHandler</p>
			<p class="source-code">    level: DEBUG</p>
			<p class="source-code">    formatter: console_formatter</p>
			<p class="source-code">    stream: ext://sys.stdout</p>
			<p class="source-code">  <strong class="bold">file_handler</strong>:</p>
			<p class="source-code">    class: logging.FileHandler</p>
			<p class="source-code">    level: INFO</p>
			<p class="source-code">    formatter: file_formatter</p>
			<p class="source-code">    filename: logs/logging6.log</p>
			<p class="source-code">loggers:</p>
			<p class="source-code">  <strong class="bold">my_logger</strong>:</p>
			<p class="source-code">    level: DEBUG</p>
			<p class="source-code">    handlers: [console_handler, file_handler]</p>
			<p class="source-code">    propagate: no</p>
			<p class="source-code">root:</p>
			<p class="source-code">  level: ERROR</p>
			<p class="source-code">  handlers: [console_handler]</p>
			<p>The following is the Python <a id="_idIndexMarker481"/>program using<a id="_idIndexMarker482"/> the YAML file to configure the logger:</p>
			<p class="source-code">#<strong class="bold">logging6</strong>.py</p>
			<p class="source-code">import logging</p>
			<p class="source-code">import logging.config</p>
			<p class="source-code">import yaml</p>
			<p class="source-code">with open('logging6.conf.yaml', 'r') as f:</p>
			<p class="source-code">    config = yaml.safe_load(f.read())</p>
			<p class="source-code">    <strong class="bold">logging.config.dictConfig</strong>(config)</p>
			<p class="source-code">logger = logging.getLogger('my_logger')</p>
			<p class="source-code">logger.error("This is an error message")</p>
			<p class="source-code">logger.warning("This is a warning message")</p>
			<p class="source-code">logger.info("This is a info message")</p>
			<p class="source-code">logger.debug("This is a debug message")</p>
			<p>To load config from a file, we used the <strong class="source-inline">dictConfig</strong> method instead of the <strong class="source-inline">basicConfig</strong> method. The outcome of the YAML-based logger configuration is exactly the same as we achieved with Python statements. There are other additional configuration options available for a full-featured logger.  </p>
			<p>In this section, we <a id="_idIndexMarker483"/>presented different <a id="_idIndexMarker484"/>scenarios of configuring one or more logger instances for an application. Next, we will discuss what type of events to log and what not to log. </p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor164"/>What to log and what not to log</h2>
			<p>There is always a debate about what information we should log and what not to log. As a best practice, the following<a id="_idIndexMarker485"/> information is important for logging:</p>
			<ul>
				<li>An application should log all errors and exceptions and the most appropriate way is to log these events at the source module.</li>
				<li>Exceptions that are handled with an alternative flow of code can be logged as warnings.</li>
				<li>For debugging purposes, entry and exit to a function is useful information for logging. </li>
				<li>It is also useful to log decision points in the code because it can be helpful for troubleshooting.</li>
				<li>The activities and actions of users, especially related to the access of certain resources and functions in the application, are important to log for security and auditing purposes. </li>
			</ul>
			<p>When logging messages, the context information is also important, which includes the time, logger name, module name, function name, line number, logging level, and so on. This information is critical for identifying the route cause analysis. </p>
			<p>A follow-up discussion on this topic is what not to capture for logging. We should not log any sensitive information such as user ID, email address, passwords, and any private and sensitive data. We <a id="_idIndexMarker486"/>should also avoid logging any personal and business record data such as health records, government-issued document details, and organization details.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor165"/>Summary</h1>
			<p>In this chapter, we discussed a variety of topics that require the use of advanced Python modules and libraries. We started by refreshing our knowledge about data containers in Python. Next, we learned how to use and build iterators for iterable objects. We also covered generators, which are more efficient and easier to build and use than iterators. We discussed how to open and read from files and how to write to files, followed by the use of a context manager with files. In the next topic, we discussed how to handle errors and exceptions in Python, how to raise exceptions through programming, and how to define custom exceptions. Exception handling is fundamental to any decent Python application. In the last section, we covered how to configure the logging framework in Python using different options for handlers and formatters.</p>
			<p>After going through this chapter, you now know how to build your own iterators and design generator functions to iterate on any iterable object, and how to handle files, errors, and exceptions in Python. You have also learned how to set up loggers with one or more handlers to manage the logging of an application using different logging levels. The skills you have learned in this chapter are key to building any open source or commercial applications. </p>
			<p>In the next chapter, we will switch our focus to how to build and automate unit tests and integration tests.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor166"/>Questions</h1>
			<ol>
				<li value="1">What is the difference between a list and a tuple?</li>
				<li>Which Python statement will always be used when working with a context manager?</li>
				<li>What is the use of the <strong class="source-inline">else</strong> statement with the <strong class="source-inline">try-except</strong> block?</li>
				<li>Generators are better to use than iterators. Why?</li>
				<li>What is the use of multiple handlers for logging?</li>
			</ol>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor167"/>Further reading</h1>
			<ul>
				<li><em class="italic">Fluent Python</em> by Luciano Ramalho</li>
				<li><em class="italic">Advanced Guide to Python 3 Programming</em> by John Hunt</li>
				<li><em class="italic">The Python 3 Standard Library by Example</em> by Doug Hellmann</li>
				<li><em class="italic">Python 3.7.10 documentation</em> (<a href="https://docs.python.org/3.7/">https://docs.python.org/3.7/</a>)</li>
				<li>To learn more about additional options available for configuring a logger, you can refer to the official Python documentation at <a href="https://docs.python.org/3/library/logging.config.html">https://docs.python.org/3/library/logging.config.html</a>  </li>
			</ul>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor168"/>Answers</h1>
			<ol>
				<li value="1">A list is a mutable object whereas a tuple is immutable. This means we can update a list after creating it. This is not true for tuples. </li>
				<li>The <strong class="source-inline">with</strong> statement is used with a context manager.</li>
				<li>The <strong class="source-inline">else</strong> block is executed only when the code in the <strong class="source-inline">try</strong> block is executed without any error. A follow-up action can be coded in the <strong class="source-inline">else</strong> block once the core functionality is executed without any problem in the <strong class="source-inline">try</strong> block. </li>
				<li>Generators are efficient in memory and also easy to program as compared to iterators. A generator function automatically provides an <strong class="source-inline">iterator</strong> instance and the <strong class="source-inline">next</strong> function implementation out of the box.</li>
				<li>The use of multiple handlers is common because one handler usually focuses on one type of destination. If we need to send log events to multiple destinations and perhaps with different priority levels, we will need multiple handlers. Also, if we need to log messages to multiple files with different logging levels, we can create different file handlers to coordinate with multiple files. </li>
			</ol>
		</div>
	</body></html>