<html><head></head><body>
		<div><h1 id="_idParaDest-104"><em class="italic"><a id="_idTextAnchor141"/>Chapter 4</em>: Python Libraries for Advanced Programming</h1>
			<p>In previous chapters, we have discussed different approaches to building modular and reusable programs in Python. In this chapter, we will investigate a few advanced concepts of the Python programming language such as iterators, generators, logging, and error handling. These concepts are important to write efficient and reusable code. For this chapter, we assume that you are familiar with the Python language syntax and know how to write control and loop structures. </p>
			<p>In this chapter, we will learn how loops work in Python, how files are handled and what is the best practice to open and access files, and how to handle erroneous situations, which may be expected or unexpected. We will also investigate the logging support in Python and different ways of configuring the logging system. This chapter will also help you learn how to use the advanced libraries in Python for building complex projects.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing Python data containers</li>
				<li>Using iterators and generators for data processing</li>
				<li>Handling files in Python</li>
				<li>Handling errors and exceptions</li>
				<li>Using the Python <code>logging</code> module </li>
			</ul>
			<p>By the end of this chapter, you will have learned how to build iterators and generators, how to handles errors and exceptions in your program, and how to implement logging for your Python project in an efficient way.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor142"/>Technical requirements</h1>
			<p>The technical requirement for this chapter is that you need to have installed Python 3.7 or later on your computer. Sample code for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter04">https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter04</a>.</p>
			<p>Let's begin by refreshing our knowledge about the data containers available in Python, which will be helpful for the follow-up topics in this chapter. </p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor143"/>Introducing Python data containers</h1>
			<p>Python supports several<a id="_idIndexMarker361"/> data types, both numeric as well as collections. Defining numeric data types such as integers and floating-point numbers is based on assigning a value to a variable. The value we assign to a variable determines the type of the numeric data type. Note that a specific constructor (for example, <code>int()</code> and <code>float()</code>) can also be used to create a variable of a specific data type. Container data types can also be defined either by assigning values in an appropriate format or by using a specific constructor for each collection data type. We will study five different container data types in this section: <strong class="bold">strings</strong>, <strong class="bold">lists</strong>, <strong class="bold">t</strong><strong class="bold">uples</strong>, <strong class="bold">dictionaries</strong>, and <strong class="bold">sets</strong>.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor144"/>Strings</h2>
			<p>Strings are not directly a<a id="_idIndexMarker362"/> container data type. But it is important to discuss the string data type because of its wide use in Python programming and also the fact that the string data type is implemented using an <strong class="bold">immutable sequence</strong> of Unicode code<a id="_idIndexMarker363"/> points. The fact that it uses a sequence (a collection type) makes it a candidate to be discussed in this section. </p>
			<p>String objects are immutable objects in Python. With immutability, string objects provide a safe solution for concurrent programs where multiple functions may access the same string object and will get the same result back. This safety is not possible with mutable objects. Being immutable objects, string objects are popular to use as keys for the dictionary data type or as data elements for the set data type. The drawback of immutability is that a new instance needs to be created even if a small change is to be made to an existing string instance. </p>
			<p class="callout-heading">Mutable versus immutable objects</p>
			<p class="callout">A mutable object can be changed after its creation, but it is not possible to change an immutable object.</p>
			<p>String literals can be enclosed by using matching single quotes (for example, <em class="italic">'blah'</em>), double quotes (for example, <em class="italic">"blah blah"</em>), or triple single or double quotes (for example, <em class="italic">"""none"""</em> or <em class="italic">'''none'''</em>). It is also worth mentioning that string objects are handled differently in Python 3 versus Python 2. In Python 3, string objects can hold only text sequences in the form of Unicode data points, but in Python 2 they can hold text as well as byte data. In Python<a id="_idIndexMarker364"/> 3, byte data is handled by the <code>bytes</code> data type. </p>
			<p>Separating text from bytes in Python 3 makes it clean and efficient but at the cost of data portability. The Unicode text in strings cannot be saved to disk or sent to a remote location on the network without converting it into a binary format. This conversion requires encoding the string data into a byte sequence, which can be achieved in one of the following ways:</p>
			<ul>
				<li><code>UTF-8</code> being the default) and how to handle the errors. </li>
				<li><code>Bytes</code> data type by passing the <a id="_idIndexMarker366"/>string instance to the bytes constructor along with the encoding scheme and the error handling scheme.</li>
			</ul>
			<p>The details of methods and the attributes available with any string object can be found in the official Python documentation as per the Python release. </p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor145"/>Lists</h2>
			<p>The list is one <a id="_idIndexMarker367"/>of the basic collection<a id="_idIndexMarker368"/> types in Python, which is used to store multiple objects using a single variable. Lists are dynamic and <em class="italic">mutable</em>, which means the objects in a list can be changed and the list can grow or shrink. </p>
			<p>List objects in Python are not implemented using any linked list concept but using a variable-length array. The array contains references to objects it is storing. The pointer of this array and its length are stored in the list head structure, which is kept up to date as objects are added or deleted from a list. The behavior of such an array is made to appear like a list but in reality, it is not a real list. That is why some of the operations on a Python list are not optimized. For example, inserting a new object into a list and deleting objects from a list will have a complexity of <em class="italic">n</em>.</p>
			<p>To rescue the<a id="_idIndexMarker369"/> situation, Python provides a <code>deque</code> data type in the <code>collections</code> built-in module. The <code>deque</code> data type provides the functionality of stacks and queues and is a good alternative<a id="_idIndexMarker370"/> option for cases when a linked list-like behavior is demanded by a problem statement. </p>
			<p>Lists can be created empty or with an initial value using <em class="italic">square brackets</em>. Next, we present a code snippet that demonstrates how to create an empty or non-empty list object using only the square brackets or using the list object constructor:</p>
			<pre>e1 = []                  #an empty list
e2 = list()              #an empty list via constructor
g1 = ['a', 'b']          #a list with 2 elements
g2 = list(['a', 'b'])    #a list with 2 elements using a \
                          constructor
g3 = list(g1)            #a list created from a list</pre>
			<p>The details of the operations available with a list object, such as <code>add</code>, <code>insert</code>, <code>append</code>, and <code>delete</code> can be reviewed in the official Python documentation. We will introduce tuples in the next section.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor146"/>Tuples</h2>
			<p>A tuple is an immutable <a id="_idIndexMarker371"/>list, which means it cannot be modified <a id="_idIndexMarker372"/>after creation. Tuples are usually used for a small number of entries and when the position and sequence of the entries in a collection is important. To preserve the sequence of entries, tuples are designed as immutable, and this is where tuples differentiate themselves from lists. Operations on a tuple are typically faster than a regular list datatype. In cases when the values in a collection are required to be constant in a particular order, using tuples is the preferred option because of their superior performance. </p>
			<p>Tuples are normally initialized with values because they are immutable. A simple tuple can be created using<a id="_idIndexMarker373"/> parenthesis. A few ways to create tuple instances are shown in the next code snippet:</p>
			<pre>w = ()                     #an empty tuple
x = (2, 3)                 #tuple with two elements
y = ("Hello World")        #not a tuple, Comma is required \
                            for single entry tuple
z = ("Hello World",)       #A comma will make it a tuple</pre>
			<p>In this code snippet, we created an empty tuple (<code>w</code>), a tuple with numbers (<code>x</code>), and a tuple with the text <code>Hello World</code>, which is <code>z</code>. The variable <code>y</code> is not a tuple since, for a 1-tuple (a single-object tuple), we need a<a id="_idIndexMarker374"/> trailing comma to indicate that it is a tuple. </p>
			<p>After introducing lists and tuples, we will briefly introduce dictionaries.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor147"/>Dictionaries</h2>
			<p>Dictionaries are one<a id="_idIndexMarker375"/> of the most used and versatile data types in Python. A dictionary is a collection that is used to store data values in the <em class="italic">key:value</em> format. Dictionaries<a id="_idIndexMarker376"/> are mutable and unordered data types. In other<a id="_idIndexMarker377"/> programming languages, they are referred to as <em class="italic">associative arrays</em> or <em class="italic">hashtables</em>. </p>
			<p>A dictionary <a id="_idIndexMarker378"/>can be created using <em class="italic">curly brackets</em> with a list of <em class="italic">key:value</em> pairs. The key is separated from its value by a colon <em class="italic">':'</em> and the <em class="italic">key:value</em> pairs are separated by a comma <em class="italic">','</em>. A code snippet for a dictionary definition follows:</p>
			<pre>mydict = {
  "brand": "BMW",
  "model": "330i",
  "color": "Blue"
}</pre>
			<p>Duplicate keys are not allowed in a dictionary. A key must be an immutable object type such as a string, tuple, or number. The values in a dictionary can be of any data type, which even includes lists, sets, custom objects, and even another dictionary itself. </p>
			<p>When dealing with<a id="_idIndexMarker379"/> dictionaries, three objects or lists are important: </p>
			<ul>
				<li><code>keys()</code> method:<pre>dict_object.<strong class="bold">keys</strong>()</pre></li>
				<li><code>values()</code> method:<pre>dict_object.<strong class="bold">values</strong>()</pre></li>
				<li><code>items()</code> method:<pre>dict_object.<strong class="bold">items</strong>()</pre></li>
			</ul>
			<p>Next, we will discuss sets, which <a id="_idIndexMarker383"/>are also key data structures in Python.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor148"/>Sets</h2>
			<p>A set is a <em class="italic">unique</em> collection of objects. A set is a <a id="_idIndexMarker384"/>mutable and unordered collection. There is no duplication <a id="_idIndexMarker385"/>of objects allowed in a set. Python uses a hashtable data structure to implement uniqueness in a set, which is the same approach used to ensure<a id="_idIndexMarker386"/> the uniqueness of keys in a dictionary. The behavior of sets in Python is very similar to sets in mathematics. This data type finds its application in situations where the order of objects is not important, but their uniqueness is. This helps to test whether a certain collection contains a certain object or not. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If the behavior of a set is required as an immutable data type, Python has a variant implementation of sets called <code>frozenset</code>.</p>
			<p>Creating a new set <a id="_idIndexMarker387"/>object is possible using <em class="italic">curly brackets</em> or using the set constructor (<code>set()</code>). The next code snippet shows a few examples of creating a set:</p>
			<pre>s1 = set()            # empty set
s2 = {}               # an empty set using curly 
s3 = set(['a', 'b'])  # a set created from a list with                       # const.
s3 = {1,2}            # a set created using curly bracket
s4 = {1, 2, 1}        # a set will be created with only 1 and 2                     # objects. Duplicate object will be ignored</pre>
			<p>Accessing set objects is not<a id="_idIndexMarker388"/> possible using an indexing approach. We need to pop one object from the set like a list or we can iterate on a set to get objects one by one. Like mathematical sets, sets in Python also support operations such as <em class="italic">union</em>, <em class="italic">intersection</em>, and <em class="italic">difference</em>. </p>
			<p>In this section, we <a id="_idIndexMarker389"/>reviewed the key concepts of strings and collection data types in Python 3, which are important to understand the upcoming topic – iterators and generators. </p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor149"/>Using iterators and generators for data processing</h1>
			<p>Iteration is <a id="_idIndexMarker390"/>one of the key tools used for data processing and data<a id="_idIndexMarker391"/> transformation. Iterations are especially useful when dealing with large datasets and when bringing the whole dataset into memory is not possible or efficient. Iterators provide a way to bring the data into memory one item at a time. </p>
			<p>Iterators can be created by defining them with a separate class and implementing special methods such as <code>__iter__</code> and <code>__next__</code>. But there is also a new way to create iterators using the <code>yield</code> operation, known as generators. In the next subsections, we will study both iterators and generators.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor150"/>Iterators</h2>
			<p>Iterators are the <a id="_idIndexMarker392"/>objects that are used to iterate on other objects. An object on which an iterator can iterate is called <code>iterable</code> object class. This is not recommended but is technically possible and we will discuss with an example why this approach is not a good design approach. In the next code snippet, we provide a few examples of using the <code>for</code> loop for iteration purposes in Python:</p>
			<pre><strong class="bold">#iterator1.py</strong>
<strong class="bold">#example 1: iterating on a list</strong>
for x in [1,2,3]:
    print(x)
<strong class="bold">#example 2: iterating on a string</strong>
for x in "Python for Geeks":
    print(x, end="")
print('')
<strong class="bold">#example 3: iterating on a dictionary</strong>
week_days = {1:'Mon', 2:'Tue', 
             3:'Wed', 4:'Thu', 
             5:'Fri', 6:'Sat', 7:'Sun'}
for k in week_days:
   print(k, week_days[k])
<strong class="bold">#example 4: iterating on a file</strong>
for row in open('abc.txt'):
    print(row, end="")</pre>
			<p>In these code examples, we used different <code>for</code> loops to iterate on a list, a string, a dictionary, and a file. All these data types are iterable and thus we will be using a simple syntax with the <code>for</code> loop to get through the items in these collections or sequences. Next, we will study what<a id="_idIndexMarker394"/> ingredients make an object iterable, which is also<a id="_idIndexMarker395"/> referred to as the <strong class="bold">Iterator Protocol</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Every collection in Python is <em class="italic">iterable</em> by default.</p>
			<p>In Python, an iterator object must implement two special methods: <code>__iter__</code> and <code>__next__</code>. To iterate on an object, the object has to implement at least the <code>__iter__ </code>method. Once the object implements the <code>__iter__</code> method, we can call the object iterable. These methods are described next:</p>
			<ul>
				<li><code>__iter__</code>: This method returns the iterator object. This method is called at the start of a loop to get the iterator object.</li>
				<li><code>__next__</code>: This method is called at each iteration of the loop and it returns the next item in the iterable object.</li>
			</ul>
			<p>To explain how to build a custom object that is iterable, we will implement the <code>Week </code>class, which stores the numbers and names of all weekdays in a dictionary. This class will not be iterable by default. To make it iterable, we will add <code>__iter__</code>. To keep the example simple, we will also add the <code>__next__</code> method in the same class. Here is the code snippet with the <code>Week</code> class and the main program, which iterates to get the names of weekdays:</p>
			<pre><strong class="bold">#iterator2.py</strong>
class Week:
    def <strong class="bold">__init__(self)</strong>:
        self.days = {1:'Monday', 2: "Tuesday",
                     3:"Wednesday", 4: "Thursday",
                     5:"Friday", 6:"Saturday", 7:"Sunday"}
        self._index = 1
    <strong class="bold">def __iter__(self)</strong>:
        self._index = 1
        return self
    <strong class="bold">def __next__(self):</strong>
        if self._index &lt; 1 | self._index &gt; 7 :
            <strong class="bold">raise StopIteration</strong>
        else:
            <strong class="bold">ret_value =  self.days[self._index]</strong>
            self._index +=1
        <strong class="bold">return ret_value</strong>
if(__name__ == "__main__"):
    wk = Week()
    <strong class="bold">for day in wk:</strong>
        print(day)</pre>
			<p>We shared this code <a id="_idIndexMarker396"/>example just to demonstrate how the <code>__iter__</code> and <code>__next__</code> methods can be implemented in the same object class. This style of implementing an iterator is commonly found on the internet, but it is not a recommended approach and is considered a bad design. The reason is that when we use it in the <code>for</code> loop, we get back the main object as an iterator as we implemented <code>__iter__</code> and <code>__next__</code> in the same class. This can give unpredictable<a id="_idIndexMarker397"/> results. We can demonstrate this by executing the following code snippet for the same class, <code>Week</code>:</p>
			<pre><strong class="bold">#iterator3.py</strong>
<strong class="bold">class Week:</strong>
#class definition is the same as shown in the previous \
 code example
if(__name__ == "__main__"):
    wk = Week()
    iter1 = <strong class="bold">iter</strong>(wk)
    iter2 = iter(wk)
   print(iter1<strong class="bold">.__next__()</strong>)
   print(iter2.__next__())
   print(<strong class="bold">next</strong>(iter1))
   print(next(iter2))</pre>
			<p>In this new main program, we are iterating on the same object using two different iterators. The results of this main program are not as expected. This is due to a common <code>_index</code> attribute shared by the two iterators. Here is a console output as a reference:</p>
			<pre>Monday
Tuesday
Wednesday
Thursday</pre>
			<p>Note that in this new main program we deliberately did not use a <code>for</code> loop. We created two iterator objects for the same object of the <code>Week</code> class using the <code>iter</code> function. The <code>iter</code> function is a Python standard function that calls the <code>__iter__</code> method. To get the next item in the iterable object, we directly used the <code>__next__</code> method as well as the <code>next</code> function. The <code>next</code> function is also a general function, like the <code>iter</code> function. This approach of using an iterable as an iterator is also not considered thread-safe. </p>
			<p>The best approach is<a id="_idIndexMarker398"/> always to use a separate iterator class and always create a new instance of an iterator through the <code>__iter__</code> method. Each iterator instance has to manage its own internal state. A revised version of the same code example of the <code>Week</code> class is shown next with a separate iterator class: </p>
			<pre>#<strong class="bold">iterator4.py</strong>
class Week:
    def __init__(self):
        self.days = {1: 'Monday', 2: "Tuesday",
                     3: "Wednesday", 4: "Thursday",
                     5: "Friday", 6: "Saturday", 7: "Sunday"}
        
    def <strong class="bold">__iter__(</strong>self):
        return <strong class="bold">WeekIterator</strong>(self.days)
class <strong class="bold">WeekIterator</strong>:
    def __init__(self, dayss):
        self.days_ref = dayss
        self._index = 1
    def <strong class="bold">__next__</strong>(self):
        if self._index &lt; 1 | self._index &gt; 8:
            raise StopIteration
        else:
            ret_value =  self.days_ref[self._index]
            self._index +=1
        return ret_valu
if(__name__ == "__main__"):
    wk = Week()
    iter1 = iter(wk)
    iter2 = iter(wk)
    print(iter1.__next__())
    print(iter2.__next__())
    print(next(iter1))
    print(next(iter2))</pre>
			<p>In this revised code <a id="_idIndexMarker399"/>example, we have a separate iterator class with the <code>__next__</code> method and it has its own <code>_index</code> attribute for managing the iterator state. The iterator instance will have a reference to the container object (dictionary). The console output of the revised example gives the results as expected: each iterator is iterating separately on the same instance of the <code>Week</code> class. The console output is shown next as a reference:</p>
			<pre>Monday
Monday
Tuesday
Tuesday</pre>
			<p>In short, to create an iterator, we need to implement the <code>__iter__</code> and <code>__next__</code> methods, manage internal state, and raise a <code>StopIteration</code> exception when there are no values available. Next, we will study generators, which will simplify the way we return iterators. </p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor151"/>Generators</h2>
			<p>A generator is a <a id="_idIndexMarker400"/>simple way of returning an iterator instance that can be used for iteration, which is achieved by implementing only a generator function. A generator function is similar to a normal function but with a <code>yield</code> statement instead of a <code>return</code> statement in it. The <code>return</code> statement is still allowed in a generator function but will not be used to return the next item in an iterable object. </p>
			<p>By definition, a <a id="_idIndexMarker401"/>function will be a generator function if it has at least one <code>yield</code> statement in it. The main difference when using the <code>yield</code> statement is that it pauses the function and saves its internal state, and when the function is called next time, it starts from the line it yielded the last time. This design pattern makes the iterator functionality simple and efficient. </p>
			<p>Internally, methods such as <code>__iter__</code> and <code>__next__</code> are implemented automatically and the <code>StopIteration</code> exception is also raised automatically. The local attributes and their values are preserved between the successive calls and there is no additional logic to be implemented by the developer. The Python interpreter provides all this functionality whenever it identifies a generator function (a function with a <code>yield</code> statement in it).</p>
			<p>To understand how the generator works, we will start with a simple generator example that is used to generate a sequence of the first three letters of the alphabet:</p>
			<pre>#<strong class="bold">generators1</strong>.py
def my_gen():
    <strong class="bold">yield 'A'</strong>
    yield 'B'
    yield 'C'
if(__name__ == "__main__"):
    <strong class="bold">iter1 = my_gen()</strong>
    print(iter1.__next__())
    print(<strong class="bold">next(iter1))</strong>
    print(<strong class="bold">iter1.__next__()</strong>)</pre>
			<p>In this code example, we implemented a simple generator function using three <code>yield</code> statements without a <code>return</code> statement. In the main part of the program, we did the following: </p>
			<ol>
				<li>We called the generator function, which returns us an iterator instance. At this stage, no line inside the <code>my_gen()</code> generator function is executed. </li>
				<li>Using the iterator instance, we called the <code>__next__</code> method, which starts the execution of the <code>my_gen()</code> function, pauses after executing the first <code>yield</code> statement, and returns <code>A</code>. </li>
				<li>Next, we call the <code>next()</code> function on the iterator instance. The result is the same as we get with the <code>__next__</code> method. But this time, the <code>my_gen()</code> function starts <a id="_idIndexMarker402"/>the execution from the next line from where it paused the last time because of the <code>yield</code> statement. The next line is another <code>yield</code> statement, which results in another pause after returning the letter <code>B</code>.</li>
				<li>The next <code>__next__</code> method will result in the execution of the next <code>yield</code> statement, which will return the letter <code>C</code>.</li>
			</ol>
			<p>Next, we will revisit the <code>Week</code> class and its iterator implementation and will use a generator instead of an iterator class. The sample code is presented next: </p>
			<pre>#generator2.py
class Week:
    def __init__(self):
        self.days = {1:'Monday', 2: "Tuesday", 
                     3:"Wednesday", 4: "Thursday", 
                     5:"Friday", 6:"Saturday", 7:"Sunday"}
    <strong class="bold">def week_gen</strong>(self):
        for x in self.days:
<strong class="bold">            yield self.days[x]</strong>
if(__name__ == "__main__"):
    wk = Week()
    iter1 = <strong class="bold">wk.week_gen()</strong>
    iter2 = <strong class="bold">iter(wk.week_gen())</strong>
    print(iter1.__next__())
    print(iter2.__next__())
    print(next(iter1))
    print(next(iter2))</pre>
			<p>In comparison to <code>iterator4.py</code>, the implementation of the <code>Week</code> class with a generator is way simpler and cleaner and we can achieve the same results. This is the power of generators and that is why they are very popular in Python. Before concluding this topic, it is important to<a id="_idIndexMarker403"/> highlight a few other key features of generators:</p>
			<ul>
				<li><strong class="bold">Generator expressions</strong>: Generator <a id="_idIndexMarker404"/>expressions can be used to create simple generators (also known as <strong class="bold">anonymous functions</strong>) on the fly without <a id="_idIndexMarker405"/>writing a special method. The syntax is similar to list comprehension except we use parentheses instead of square brackets. The next code example (an extension of the example we introduced for list comprehension) shows how a generator expression can be used to create a generator, its usage, and also a comparison with list comprehension:<pre>#<strong class="bold">generator3</strong>.py
L = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
f1 = [x+1 for x in L]
<strong class="bold">g1 = (x+1 for x in L)</strong>
<strong class="bold">print(g1.__next__())</strong>
<strong class="bold">print(g1.__next__())</strong></pre></li>
				<li><strong class="bold">Infinite streams</strong>: Generators can <a id="_idIndexMarker406"/>also be used to implement an<a id="_idIndexMarker407"/> infinite stream of data. It is always a challenge to bring an infinite stream into memory, which is solved easily with generators as they return only one data item at a time. </li>
				<li><code>for</code> loops, but we will try to solve it using two generators: the <code>prime_gen</code> generator for generating prime numbers and the <code>x2_gen</code> generator for taking the square of the prime numbers fed to this generator by the <code>prime_gen</code> generator. We feed the two generators pipelined into the <code>sum</code> function to get the desired result. Here is the code snippet for this problem solution:<pre>#<strong class="bold">generator4</strong>.py
def <strong class="bold">prime_gen</strong>(num):
    for cand in range(2, num+1):
        for i in range (2, cand):
            if (cand % i) == 0:
                break
        else:
            yield cand
def <strong class="bold">x2_gen</strong>(list2):
    for num in list2:
        yield num*num
<strong class="bold">print(sum(x2_gen(prime_gen(5))))</strong></pre></li>
			</ul>
			<p>Generators operate on an on-demand basis, which makes them not only memory efficient but also provides a way to generate values when they are needed. This helps to avoid unnecessary data generation, which may not be used at all. Generators are well suited to be used for a large<a id="_idIndexMarker409"/> amount of data processing, for piping<a id="_idIndexMarker410"/> the data from one function to others, and to simulate concurrency as well.</p>
			<p>In the next section, we will investigate how to handle files in Python.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor152"/>Handling files in Python</h1>
			<p>Reading data from a<a id="_idIndexMarker411"/> file or writing data to a file is one of the fundamental operations supported by any programming language. Python provides extensive support for handling file operations, which are mostly available in its standard library. In this <a id="_idIndexMarker412"/>section, we will discuss core file operations such as opening a file, closing a file, reading from a file, writing to a file, file management with context managers, and opening multiple files with one handle using the Python standard library. We will start our discussion with file operations in the next subsection.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor153"/>File operations</h2>
			<p>File operations<a id="_idIndexMarker413"/> typically start with opening a file and then reading or updating the contents in that file. The core file operations are as follows:</p>
			<h3>Opening and closing a file</h3>
			<p>To apply any read or<a id="_idIndexMarker414"/> update operation to a file, we need a pointer or reference to the file. A file reference can be obtained by opening a file using the built-in <code>open</code> function. This function<a id="_idIndexMarker415"/> returns a reference to the <code>file</code> object, which is also known as a <code>open</code> function is the name of the file with an absolute or relative path. One optional parameter is the access mode to indicate in which mode a file is to be opened. The access mode can be <code>read</code>, <code>write</code>, <code>append</code>, or others. A full list of access mode options is as follows:</p>
			<ul>
				<li><code>r</code>: This option is for opening a file in read-only mode. This is a default option if the access mode option is not provided:<pre>f = open ('abc.txt')</pre></li>
				<li><code>a</code>: This option is for opening a file to append a new line at the end of the file:<pre>f = open ('abc.txt', 'a')</pre></li>
				<li><code>w</code>: This option is for opening a file for writing. If a file does not exist, it will create a new file. If the file exists, this option will override it and any existing contents in that file will be destroyed: <pre>f = open ('abc.txt', 'w')</pre></li>
				<li><code>x</code>: This option is for opening a file for exclusive writing. If the file already exists, it will throw an error:<pre>f = open ('abc.txt', 'x')</pre></li>
				<li><code>t</code>: This option is for opening a file in text mode. This is the default option.</li>
				<li><code>b</code>: This option is for opening a file in binary mode.</li>
				<li><code>+</code>: This option is for opening a file for reading and writing:<pre>f = open ('abc.txt', 'r+'</pre></li>
			</ul>
			<p>The mode options can be combined to get multiple options. In addition to the filename and the access mode options, we can also pass the encoding type, especially for text files. Here is an example of opening a file with <code>utf-8</code>:</p>
			<pre>f = open("abc.txt", mode='r', encoding='utf-8')</pre>
			<p>When we complete our operations with a file, it is a must to close the file to free up the resources for other processes<a id="_idIndexMarker417"/> to use the file. A file can be closed by using the <code>close</code> method on the file instance or the file handle. Here is a code snippet showing the use of the <code>close</code> method: </p>
			<pre>file = open("abc.txt", 'r+w')
#operations on file
<strong class="bold">file.close()</strong></pre>
			<p>Once a file is closed, the<a id="_idIndexMarker418"/> resources associated with the file instance and locks (if any) will be released by the operating system, which is a best practice in any programming language.</p>
			<h3>Reading and writing files</h3>
			<p>A file can be read by <a id="_idIndexMarker419"/>opening the file in access mode <code>r</code> and then using one<a id="_idIndexMarker420"/> of the read methods. Next, we summarize different methods available for read operations:</p>
			<ul>
				<li><code>read(n)</code>: This method reads <code>n</code> characters from a file.</li>
				<li><code>readline()</code>: This method returns one line from a file.</li>
				<li><code>readlines()</code>: This method returns all lines from a file as a list.</li>
			</ul>
			<p>Similarly, we can append or write to a file once it is opened in an appropriate access mode. The methods that are relevant to appending a file are as follows:</p>
			<ul>
				<li><code>write (x)</code>: This method writes a string or a sequence of bytes to a file and returns the number of characters added to the file.</li>
				<li><code>writelines (lines)</code>: This method writes a list of lines to a file.</li>
			</ul>
			<p>In the next code example, we will create a new file, add a few text lines to it, and then read the text data using the read operations discussed previously:</p>
			<pre><strong class="bold">#writereadfile.py: write to a file and then read from it</strong>
f1 = <strong class="bold">open("myfile.txt",'w')</strong>
<strong class="bold">f1.write("This is a sample file\n")</strong>
lines =["This is a test data\n", "in two lines\n"]
f1.<strong class="bold">writelines</strong>(lines)
f1.close()
f2 = <strong class="bold">open("myfile.txt",'r')</strong>
print(f2.<strong class="bold">read</strong>(4))
print(f2.<strong class="bold">readline</strong>())
print(f2.readline())
f2.seek(0)
for line in f2.<strong class="bold">readlines</strong>():
    print(line)
f2.close()</pre>
			<p>In this code<a id="_idIndexMarker421"/> example, we write three lines to a file first. In the read operations, first, we<a id="_idIndexMarker422"/> read four characters, followed by reading two lines using the <code>readline</code> method. In the end, we move the pointer back to the top of the file using the <code>seek</code> method and access all lines in the file using the <code>readlines</code> method.</p>
			<p>In the next section, we will see how the use of a context manager makes file handling convenient. </p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor154"/>Using a context manager</h2>
			<p>Correct and fair usage<a id="_idIndexMarker423"/> of resources is critical in any programming language. A file handler and a database connection are a couple of many examples where it is a common practice to not release the resources on time after working with objects. If the resources are not released at all, then it will end up in a situation called <strong class="bold">memory leakage</strong> and may<a id="_idIndexMarker424"/> impact the system performance, and ultimately may result in the system crashing. </p>
			<p>To solve this memory<a id="_idIndexMarker425"/> leakage and timely resource release problem, Python came up with the concept of context managers. A context manager is designed to reserve and release resources precisely as per the design. When a context manager is used with the <code>with</code> keyword, a statement after the <code>with</code> keyword is expected to return an object that must implement the <strong class="bold">context management protocol</strong>. This protocol requires two<a id="_idIndexMarker426"/> special methods to be implemented by the returned object. These special methods are as follows: </p>
			<ul>
				<li><code>.__enter__()</code>: This method is called with the <code>with</code> keyword and is used to reserve the resources required as per the statement after the <code>with</code> keyword.</li>
				<li><code>.__exit__()</code>: This method is called after the execution of the <code>with</code> block and is used to release the resources that are reserved in the <code>.__enter__()</code> method.</li>
			</ul>
			<p>For example, when a file is opened using the context manager <code>with</code> statement (block), there is no need to close the file. The file <code>open</code> statement will return the file handler object, which has already implemented the context management protocol and the file will be closed automatically as soon the execution of the <code>with</code> block is completed. A revised version of the code example for writing and reading a file using the context manager is as follows: </p>
			<pre>#<strong class="bold">contextmgr1</strong>.py
<strong class="bold">with open</strong>("myfile.txt",'w') <strong class="bold">as f1</strong>:
    f1.write("This is a sample file\n")
    lines = ["This is a test data\n", "in two lines\n"]
    f1.writelines(lines)
<strong class="bold">with open</strong>("myfile.txt",'r') <strong class="bold">as f2</strong>:
    for line in f2.readlines():
        print(line)</pre>
			<p>The code with the context manager is simple and easy to read. The use of a context manager is a recommended <a id="_idIndexMarker427"/>approach for opening and working with files. </p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor155"/>Operating on multiple files</h2>
			<p>Python supports opening<a id="_idIndexMarker428"/> and operating on multiple files at the same time. We can open these files in different modes and operate on them. There is no limit on the number of files. We can open two files in read mode by using the following sample code and access the files in any order:</p>
			<pre><strong class="bold">1.txt</strong>
This is a sample file 1
This is a test data 1
<strong class="bold">2.txt</strong>
This is a sample file 2
This is a test data 2
#<strong class="bold">multifilesread1.py</strong>
with <strong class="bold">open("1.txt") as file1, open("2.txt") as file2</strong>:
    print(file2.readline())
    print(file1.readline())</pre>
			<p>We can also read from one file and write to another file using this multifile operating option. Sample code to transfer contents from one file to another file is as follows:</p>
			<pre>#<strong class="bold">multifilesread2.py</strong>
<strong class="bold">with open("1.txt",'r') as file1, open("3.txt",'w') as file2:</strong>
   for line in file1.readlines():
     file2.write(line)</pre>
			<p>Python also has a more elegant solution to operate on multiple files using the <code>fileinput</code> module. This module's input function can take a list of multiple files and then treat all such files as a single input. Sample <a id="_idIndexMarker429"/>code with two input files, <code>1.txt</code> and <code>2.txt</code>, and using the <code>fileinput</code> module is presented next:</p>
			<pre>#<strong class="bold">multifilesread1</strong>.py
import <strong class="bold">fileinput</strong>
with <strong class="bold">fileinput.input</strong>(<strong class="bold">files = ("1.txt",'2.txt'</strong>)) <strong class="bold">as f</strong>:
    for line in f:
        print(f.<strong class="bold">filename</strong>())
        print(line)</pre>
			<p>With this approach, we get one file handle that operates on multiple files sequentially. Next, we will discuss error and exception handling in Python.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor156"/>Handling errors and exceptions</h1>
			<p>There are many types <a id="_idIndexMarker430"/>of errors possible in Python. The most common one is related to the syntax <a id="_idIndexMarker431"/>of the program and is typically known as a <strong class="bold">syntax error</strong>. On many occasions, errors are reported during <a id="_idIndexMarker432"/>the execution of a program. Such errors are called <strong class="bold">runtime errors</strong>. The runtime errors that can be handled <a id="_idIndexMarker433"/>within our program are called <strong class="bold">exceptions</strong>. This section will focus on how to handle runtime errors or exceptions. Before jumping on to error handling, we will briefly introduce the most common runtime errors as follows:</p>
			<ul>
				<li><code>IndexError</code>: This error occurs when a program tries to access an item at an invalid index (location in the memory).</li>
				<li><code>ModuleNotFoundError</code>: This error will be thrown when a specified module is not found at the system path.</li>
				<li><code>ZeroDivisionError</code>: This error is thrown when a program tries to divide a number by zero.</li>
				<li><code>KeyError</code>: This error occurs when a program tries to fetch a value from a dictionary using an invalid key.</li>
				<li><code>StopIteration</code>: This error is thrown when the <code>__next__</code> method does not find any further items in a container.</li>
				<li><code>TypeError</code>: This error occurs when a program tries to apply an operation on an object of an inappropriate type.</li>
			</ul>
			<p>A complete list of errors is available in the official documentation of Python. In the following subsections, we <a id="_idIndexMarker434"/>will discuss how to handle errors, sometimes also called<a id="_idIndexMarker435"/> exceptions, using appropriate constructs in Python.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor157"/>Working with exceptions in Python</h2>
			<p>When runtime errors arise, the program<a id="_idIndexMarker436"/> can terminate abruptly and can cause damage to system resources such as corrupting files and database tables. This is why error or exception handling is one of the key ingredients of writing<a id="_idIndexMarker437"/> robust programs in any language. The idea is to anticipate that runtime errors can occur and if such an error occurs, what the behavior of our program would be as a response to that particular error. </p>
			<p>Like many other languages, Python uses the <code>try</code> and <code>except</code> keywords. The two keywords are followed by separate blocks of code to be executed. The <code>try</code> block is a regular set of statements for which we anticipate that an error may occur. The <code>except</code> block will be executed only if there is an error in a <code>try</code> block. Next is the syntax of writing Python code with <code>try</code> and <code>except</code> blocks:</p>
			<pre><strong class="bold">try</strong>:
    #a series of statements
<strong class="bold">except</strong>:
    #statements to be executed if there is an error in \
     try block</pre>
			<p>If we anticipate a particular error type or multiple error types, we can define an <code>except</code> block with the error name and can add as many <code>except</code> blocks as we need. Such named <code>except</code> blocks are executed only if the named exception is raised in the <code>try</code> block. With the <code>except</code> block <a id="_idIndexMarker438"/>statement, we can also add an <code>as</code> statement to store the exception object as a variable that is raised during the <code>try</code> block. The <code>try</code> block in<a id="_idIndexMarker439"/> the next code example has many possible runtime errors and that is why it has multiple <code>except</code> blocks:</p>
			<pre>#<strong class="bold">exception1</strong>.py
try:
    <strong class="bold">print (x)</strong>
    x = 5
    y = 0
    <strong class="bold">z = x /y</strong>
    <strong class="bold">print('x'+ y)</strong>
except <strong class="bold">NameError as e</strong>:
    print(e)
except <strong class="bold">ZeroDivisionError</strong>:
    print("Division by 0 is not allowed")
except <strong class="bold">Exception as e</strong>:
    print("An error occured")
    print(e)</pre>
			<p>To illustrate a better use of an <code>except</code> block(s), we added multiple except blocks that are explained next:</p>
			<ul>
				<li><code>try</code> block tries to access an undefined variable. In our code example, this block will be executed when the interpreter tries to execute the <code>print(x)</code> statement. Additionally, we named the exception object as <code>e</code> and used it with the <code>print</code> statement to get the official error detail associated with this error type.</li>
				<li><code>z = x/y</code> and y = 0. For this block to be executed, we need to fix the <code>NameError</code> block first. </li>
				<li><code>except</code> block, which means if no match is found with the previous two <code>except</code> blocks, this block will be executed. The last <a id="_idIndexMarker443"/>statement <code>print('x'+ y)</code> will also raise an error of type <code>TypeError</code> and will be handled by this block. Since we are not receiving any one particular type of exception in this block, we can use the <code>Exception</code> keyword to store the exception object in a<a id="_idIndexMarker444"/> variable.</li>
			</ul>
			<p>Note that as soon an error occurs in any statement in the <code>try</code> block, the rest of the statements are ignored, and the control goes to one of the <code>except</code> blocks. In our code example, we need to fix the <code>NameError</code> error first to see the next level of exception and so on. We added three different types of errors in our example to demonstrate how to define multiple <code>except</code> blocks for the same <code>try</code> block. The order of the <code>except</code> blocks is important because more specific <code>except</code> blocks with error names have to be defined first and an <code>except</code> block without specifying an error name has to always be at the end. </p>
			<p>The following figure shows all the exception handling blocks: </p>
			<div><div><img src="img/B17189_04_01.jpg" alt="Figure 4.1 – Different exception handling blocks in Python&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Different exception handling blocks in Python</p>
			<p>As shown in the preceding<a id="_idIndexMarker445"/> diagram, in addition to <code>try</code> and <code>except</code> blocks, Python also supports <code>else</code> and <code>finally</code> blocks to enhance the error handling <a id="_idIndexMarker446"/>functionality. The <code>else</code> block is executed if no errors were raised during the <code>try</code> block. The code in this block will be executed as normal and no exception will be thrown if any error occurs within this block. Nested <code>try</code> and <code>except</code> blocks can be added within the <code>else</code> block if needed. Note that this block is optional. </p>
			<p>The <code>finally</code> block is executed regardless of whether there is an error in the <code>try</code> block or not. The code inside the <code>finally</code> block is executed without any exception handling mechanism. This block is mainly used to free up the resources by closing the connections or opened files. Although it is an optional block, it is highly recommended to implement this block. </p>
			<p>Next, we will look at the use of these blocks with a code example. In this example, we will open a new file for writing in the <code>try</code> block. If an error occurs in opening the file, an exception will be thrown, and we will send the error details to the console using the <code>print</code> statement in the <code>except</code> block. If no error occurs, we will execute the code in the <code>else</code> block that is writing some text to the file. In both cases (error or no error), we will close the file in the <code>finally</code> block. The complete sample code is as follows: </p>
			<pre>#<strong class="bold">exception2</strong>.py
<strong class="bold">try:</strong>
    f = open("abc.txt", "w")
<strong class="bold">except</strong> Exception as e:
    print("Error:" + e)
<strong class="bold">else:</strong>
    f.write("Hello World")
    f.write("End")
<strong class="bold">finally:</strong>
    f.close()</pre>
			<p>We have covered<a id="_idIndexMarker447"/> extensively how to handle an exception in Python. Next, we will<a id="_idIndexMarker448"/> discuss how to raise an exception from Python code.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor158"/>Raising exceptions</h2>
			<p>Exceptions or errors are raised by the<a id="_idIndexMarker449"/> Python interpreter at runtime when an error occurs. We can also raise errors or exceptions ourselves if a condition occurs that may give us bad output or crash the program if we proceed further. Raising an error or exception will provide a graceful exit of the program.</p>
			<p>An exception (object) can be thrown to the caller by using the <code>raise</code> keyword. An exception can be of one of the following types:</p>
			<ul>
				<li>A built-in exception</li>
				<li>A custom exception</li>
				<li>A generic <code>Exception</code> object</li>
			</ul>
			<p>In the next code example, we will be calling a simple function to calculate a square root and will implement it to throw an exception if the input parameter is not a valid positive number:</p>
			<pre>#<strong class="bold">exception3</strong>.py
import math
def sqrt(num):
    if not isinstance(num, (int, float)) :
        <strong class="bold">raise TypeError</strong>("only numbers are allowed")
    if num &lt; 0:
        <strong class="bold">raise Exception</strong> ("Negative number not supported")
    return math.sqrt(num)
if __name__ == "__main__":
    try:
        print(sqrt(9))
        <strong class="bold">print(sqrt('a'))</strong>
        <strong class="bold">print (sqrt(-9))</strong>
    except Exception as e:
        print(e)</pre>
			<p>In this code example, we raised a <a id="_idIndexMarker450"/>built-in exception by creating a new instance of the <code>TypeError</code> class when the number passed to the <code>sqrt</code> function is not a number. We also raised a generic exception when the number passed is lower than <code>0</code>. In both cases, we passed our custom text to its constructor. In the next section, we will study how to define our own custom exception and then throw it to the caller.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor159"/>Defining custom exceptions</h2>
			<p>In Python, we can define our own custom<a id="_idIndexMarker451"/> exceptions by creating a new class that has to be derived from the built-in <code>Exception</code> class or its subclass. To illustrate the concept, we will revise our previous example by defining two custom exception classes to replace the built-in <code>TypeError</code> and the <code>Exception</code> error types. The new custom exception classes will be derived from the <code>TypeError</code> and the <code>Exception</code> classes. Here is sample code for reference with custom exceptions:</p>
			<pre>#<strong class="bold">exception4</strong>.py
import math
<strong class="bold">class NumTypeError(TypeError):</strong>
    pass
<strong class="bold">class NegativeNumError(Exception):</strong>
    <strong class="bold">def __init__(self):</strong>
        super().__init__("Negative number not supported")
def sqrt(num):
    if not isinstance(num, (int, float)) :
        <strong class="bold">raise NumTypeError</strong>("only numbers are allowed")
    if num &lt; 0:
        <strong class="bold">raise NegativeNumError</strong>
    return math.sqrt(num)
if __name__ == "__main__":
    try:
        print(sqrt(9))
        <strong class="bold">print(sqrt('a'))</strong>
        <strong class="bold">print (sqrt(-9))</strong>
    except <strong class="bold">NumTypeError as e</strong>:
        print(e)
    except <strong class="bold">NegativeNumError as e</strong>:
        print(e)</pre>
			<p>In this code example, the <code>NumTypeError</code> class is derived from the <code>TypeError</code> class and we have not added anything in this class. The <code>NegativeNumError</code> class is inherited from the <code>Exception</code> class and <a id="_idIndexMarker452"/>we override its constructor and add a custom message for this exception as part of the constructor. When we raise these custom exceptions in the <code>sqrt()</code> function, we do not pass any text with the <code>NegativeNumError</code> exception class. When we used the main program, we get the message with the <code>print (e)</code> statement as we have set it as part of the class definition.  </p>
			<p>In this section, we covered how to handle built-in error types using <code>try</code> and <code>except</code> blocks, how to define custom exceptions, and how to raise an exception declaratively. In the next section, we will cover logging in Python.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor160"/>Using the Python logging module</h1>
			<p>Logging is a fundamental<a id="_idIndexMarker453"/> requirement for any reasonably sized application. Logging not only helps in debugging and troubleshooting but also provides insight into<a id="_idIndexMarker454"/> details of an application's internal issues. A few advantages of logging are as follows:</p>
			<ul>
				<li>Debugging code, especially to diagnose why and when an application failed or crashed</li>
				<li>Diagnosing unusual application behavior</li>
				<li>Providing auditing data for regulatory or legal compliance matters</li>
				<li>Identifying users' behaviors and malicious attempts to access unauthorized resources </li>
			</ul>
			<p>Before discussing any <a id="_idIndexMarker455"/>practical ex<a id="_idTextAnchor161"/>amples of logging, we will first discuss the key <a id="_idIndexMarker456"/>components of the logging system in Python. </p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor162"/>Introducing core logging components</h2>
			<p>The following components are <a id="_idIndexMarker457"/>fundamental to set up logging for an <a id="_idIndexMarker458"/>application in Python:</p>
			<ul>
				<li>Logger</li>
				<li>Logging levels</li>
				<li>Logging formatter</li>
				<li>Logging handler</li>
			</ul>
			<p>A high-level architecture of the Python logging system can be summarized here:</p>
			<div><div><img src="img/B17189_04_02.jpg" alt="Figure 4.2 – Logging components in Python&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Logging components in Python</p>
			<p>Each of these components is discussed in detail in the following subsections.</p>
			<h3>The logger</h3>
			<p>The logger is the entry point to the Python logging system. It is the interface to the application programmer. The <code>Logger</code> class available in Python provides several methods to log messages with different priorities. We will study the <code>Logger</code> class methods with code examples later in this section.</p>
			<p>An application<a id="_idIndexMarker459"/> interacts with the <code>Logger</code> instance, which is set up using logging configuration such as the logging level. On receiving logging events, the <code>Logger</code> instance selects one or more appropriate logging handlers and delegates the events to the handlers. Each handler is typically designed for a specific output target. A handler sends the messages after applying a filter and formatting to the intended output target. </p>
			<h3>Logging levels</h3>
			<p>All events and messages for a<a id="_idIndexMarker460"/> logging system are not of the same priority. For example, messages about errors are more urgent than warning messages. Logging levels are a way to set different priorities for different logging events. There are six levels defined in Python. Each level is associated with an integer value that indicates the severity. These levels are <code>NOTSET</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>CRITICAL</code>. These are summarized here:</p>
			<div><div><img src="img/B17189_04_03.jpg" alt="Figure 4.3 – Logging levels in Python&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Logging levels in Python</p>
			<h3>The logging formatter</h3>
			<p>The logging formatter component helps to<a id="_idIndexMarker461"/> improve the formatting of messages, which is important for consistency and for human and machine readability. The logging formatter also adds extra context to messages such as time, module name, line number, threads, and process, which is extremely useful for debugging purposes. An example formatter expression is as follows:</p>
			<pre>"%(asctime)s — %(name)s — %(levelname)s — %(funcName)s:%(lineno)d — %(message)s"</pre>
			<p>When such a formatter expression is used, the log message <code>hello Geeks</code> of level <code>INFO</code> will be displayed similar to the console output that follows:</p>
			<pre>2021-06-10 19:20:10,864 - a.b.c - INFO - &lt;module name&gt;:10 - hello Geeks</pre>
			<h3>The logging handler</h3>
			<p>The role of a logging handler is to <a id="_idIndexMarker462"/>write log data to an appropriate destination, which can be a console, a file, or even an email. There are many types of built-in logging handlers available in Python. A few popular handlers are introduced here: </p>
			<ul>
				<li><code>StreamHandler</code> for displaying the logs on a console</li>
				<li><code>FileHandler</code> for writing the logs to a file</li>
				<li><code>SMTPHandler</code> for sending the logs to an email</li>
				<li><code>SocketHandler</code> for sending the logs to a network socket</li>
				<li><code>SyslogHandler</code> for sending the logs to a local or remote <em class="italic">Unix</em> syslog server</li>
				<li><code>HTTPHandler</code> for sending the logs to a web server using either <code>GET</code> or <code>POST</code> methods</li>
			</ul>
			<p>The logging handler uses the logging<a id="_idIndexMarker463"/> formatter to add more context info to the logs and the logging level to filter the logging data. </p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor163"/>Working with the logging module</h2>
			<p>In this section, we will discuss how<a id="_idIndexMarker464"/> to use the <code>logging</code> module with code examples. We will start with basic logging options and will take them to an advanced level in a gradual manner. </p>
			<h3>Using the default logger </h3>
			<p>Without creating an instance of <a id="_idIndexMarker465"/>any logger class, there is already a default logger available in Python. The default logger, also known as the <code>logging</code> module and using its methods to dispatch logging events. The next code snippet shows the use of the root logger for capturing log events:</p>
			<pre>#<strong class="bold">logging1</strong>.py
import <strong class="bold">logging</strong>
<strong class="bold">logging.debug</strong>("This is a debug message")
<strong class="bold">logging.warning</strong>("This is a warning message")
<strong class="bold">logging.info</strong>("This is an info message")</pre>
			<p>The <code>debug</code>, <code>warning</code>, and <code>info</code> methods are used to dispatch logging events to the logger as per their severity. The default log level for this logger is set to <code>WARNING</code> and the default output is set to <code>stderr</code>, which means all the messages will go to the console or terminal only. This setting will block <code>DEBUG</code> and <code>INFO</code> messages to be displayed on the console output, which will be as follows:</p>
			<pre>WARNING:root:This is a warning message</pre>
			<p>The level of the root<a id="_idIndexMarker467"/> logger can be changed by adding the following line after the <code>import</code> statement:</p>
			<pre>logging.<strong class="bold">basicConfig</strong>(level=logging.DEBUG)</pre>
			<p>After changing the logging level to <code>DEBUG</code>, the console output will now show all the log messages:</p>
			<pre>DEBUG:root:This is a debug message
WARNING:root:This is a warning message
INFO:root:This is an info message</pre>
			<p>Although we discussed the default or root logger in this subsection, it is not recommended to use it other than for basic logging purposes. As a best practice, we should create a new logger with a name, which we will discuss in the next code examples. </p>
			<h3>Using a named logger</h3>
			<p>We can create a separate logger with its<a id="_idIndexMarker468"/> own name and possibly with its own log level, handlers, and formatters. The next code snippet is an example of creating a logger with a custom name and also using a different logging level than the root logger:</p>
			<pre>#<strong class="bold">logging2</strong>.py
import logging
logger1 = <strong class="bold">logging.getLogger</strong>("my_logger")
logging.<strong class="bold">basicConfig</strong>()
logger1.<strong class="bold">setLevel</strong>(logging.INFO)
logger1.<strong class="bold">warning</strong>("This is a warning message")
logger1.<strong class="bold">info</strong>("This is a info message")
logger1.<strong class="bold">debug</strong>("This is a debug message")
logging.<strong class="bold">info</strong>("This is an info message")</pre>
			<p>When we create a logger instance using the <code>getLogger</code> method with a string name or using the module name (by using the <code>__name__</code> global variable), then only one instance is managed for one name. This means if we try to use the <code>getLogger</code> method with the same name in any part of the application, the Python interpreter will check whether there is already an instance created for this name. If there is already one created, it will return the same instance. </p>
			<p>After creating a logger instance, we need to make a call to the root logger (<code>basicConfig()</code>) to provide a handler and formatter to our logger. Without any handler configuration, we<a id="_idIndexMarker469"/> will get an internal handler as the last resort, which will only output messages without any formatting and the logging level will be <code>WARNING</code> regardless of the logging level we set for our logger. The console output of this code snippet is shown next, and it is as expected:</p>
			<pre>WARNING:my_logger:This is a warning message
INFO:my_logger:This is a info message</pre>
			<p>It is also important to note the following:</p>
			<ul>
				<li>We set the logging level for our logger to <code>INFO</code> and we were able to log <code>warning</code> and <code>info</code> messages but not the debug message.</li>
				<li>When we used the root logger (by using the <code>logging</code> instance), we were not able to send out the <code>info</code> message. This was because the root logger was still using the default logging level, which is <code>WARNING</code>.</li>
			</ul>
			<h3>Using a logger with a built-in handler and custom formatter</h3>
			<p>We can create a logger object using a built-in handler but with a custom formatter. In this case, the handler object can <a id="_idIndexMarker470"/>use a custom formatter object and the handler object can be added to the logger object as its handler before we start using the logger for any log events. Here is a code snippet to illustrate how to create a handler and a formatter programmatically and then add the handler to the logger:</p>
			<pre>#<strong class="bold">logging3</strong>.py
import logging
logger = logging.getLogger('my_logger')
my_handler = <strong class="bold">logging.StreamHandler</strong>()
my_formatter = <strong class="bold">logging.Formatter</strong>('%(asctime)s - '\
                  '%(name)s - %(levelname)s - %(message)s')
my_handler.<strong class="bold">setFormatter</strong>(my_formatter)
logger.<strong class="bold">addHandler</strong>(my_handler)
logger.<strong class="bold">setLevel</strong>(logging.INFO)
logger.warning("This is a warning message")
logger.info("This is an info message")
logger.debug("This is a debug message")</pre>
			<p>We can create a logger with the same settings by using the <code>basicConfig</code> method as well with appropriate arguments. The next code snippet is a revised version of <code>logging3.py</code> with the <code>basicConfig</code> settings:</p>
			<pre>#<strong class="bold">logging3A</strong>.py
import logging
logger = logging.getLogger('my_logger')
logging.<strong class="bold">basicConfig</strong>(<strong class="bold">handlers</strong>=[logging.StreamHandler()],
                    <strong class="bold">format</strong>="%(asctime)s - %(name)s - "
                           "%(levelname)s - %(message)s",
                    <strong class="bold">level</strong>=logging.INFO)
logger.warning("This is a warning message")
logger.info("This is an info message")
logger.debug("This is a debug message")</pre>
			<p>Up till now, we have covered <a id="_idIndexMarker471"/>cases where we used built-in classes and objects to set up our loggers. Next, we will set up a logger with custom handlers and formatters.</p>
			<h3>Using a logger with a file handler </h3>
			<p>The logging handler sends the<a id="_idIndexMarker472"/> log messages to their final destination. By default, every logger is set up to send log messages to the console or terminal associated with the running program. But this can be changed by configuring a logger with a new handler with a different destination. A file handler can be created by using one of the two approaches we already discussed in the previous subsection. In this section, we will use a third approach to create a file handler automatically with the <code>basicConfig</code> method by providing the filename as an attribute to this method. This is shown in the next code snippet:</p>
			<pre> #<strong class="bold">logging4</strong>.py
import logging
logging.<strong class="bold">basicConfig(filename='logs/logging4.log'</strong> 
                    ,<strong class="bold">level=logging.DEBUG</strong>)
logger = logging.getLogger('my_logger')
logger.setLevel(logging.INFO)
logger.warning("This is a warning message")
logger.info("This is a info message")
logger.debug("This is a debug message")</pre>
			<p>This will generate log messages to the file we specified with the <code>basicConfig</code> method and as per the logging <a id="_idIndexMarker473"/>level, which is<a id="_idIndexMarker474"/> set to <code>INFO</code>. </p>
			<h3>Using a logger with multiple handlers programmatically </h3>
			<p>Creating a logger with multiple handlers is <a id="_idIndexMarker475"/>pretty straightforward and can be achieved either by using the <code>basicConfig</code> method or by attaching handlers manually to a logger. For illustration purposes, we will revise our code example <code>logging3.py</code> to do the following:</p>
			<ol>
				<li value="1">We will create two handlers (one for the console output and one for the file output) that are instances of the <code>streamHandler</code> and <code>fileHandler</code> classes.</li>
				<li>We will create two separate formatters, one for each handler. We will not include the time information for the formatter of the console handler.</li>
				<li>We will set separate logging levels for the two handlers. It is important to understand that the logging level at the handler level cannot override the root level handler. </li>
			</ol>
			<p>Here is the complete code example:</p>
			<pre>#<strong class="bold">logging5</strong>.py
import logging
logger = logging.getLogger('my_logger')
<strong class="bold">logger.setLevel(logging.DEBUG)</strong>
console_handler = <strong class="bold">logging.StreamHandler()</strong>
file_handler = <strong class="bold">logging.FileHandler</strong>("logs/logging5.log")
#<strong class="bold">setting logging levels at the handler level</strong>
console_handler.setLevel(logging.DEBUG)
file_handler.setLevel(logging.INFO)
#<strong class="bold">creating separate formatter for two handlers</strong>
console_formatter = logging.Formatter(
                  '%(name)s - %(levelname)s - %(message)s')
file_formatter = logging.Formatter('%(asctime)s - '
                  '%(name)s - %(levelname)s - %(message)s')
#<strong class="bold">adding formatters to the handler</strong>
console_handler.setFormatter(console_formatter)
file_handler.setFormatter(file_formatter)
#<strong class="bold">adding handlers to the logger</strong>
logger.addHandler(console_handler)
logger.addHandler(file_handler)
logger.error("This is an error message")
logger.warning("This is a warning message")
logger.info("This is an info message")
logger.debug("This is a debug message")</pre>
			<p>Although we set different logging levels for the two handlers, which are <code>INFO</code> and <code>DEBUG</code>, they will be effective only if the logging level of the logger is at a lower value (the default is <code>WARNING</code>). This is why we have to set the logging level for our logger to <code>DEBUG</code> at the beginning of the program. The logging level at the handler level can be <code>DEBUG</code> or any higher<a id="_idIndexMarker476"/> level. This is a very important point to consider whenever designing a logging strategy for your application. </p>
			<p>In the code example shared in this section, we basically configured the logger programmatically. In the next section, we will work on how to configure a logger through a configuration file. </p>
			<h3>Configuring a logger with multiple handlers using a configuration file</h3>
			<p>Setting up a logger<a id="_idIndexMarker477"/> programmatically is appealing but not practical for production environments. In production environments, we have to set up the logger configuration differently as compared to the development setup <a id="_idIndexMarker478"/>and sometimes we have to enhance the logging level to troubleshoot problems that we encounter only in live environments. This is why we have the option of providing the logger configuration through a file that is easy to change as per the target environment. The configuration file for a logger can be written using <code>.conf</code> file. For illustration purposes, we <a id="_idIndexMarker480"/>will demonstrate the logger configuration using a YAML file, which is exactly the same as we achieved programmatically in the previous section. The complete YAML file and the Python code is as follows:</p>
			<p>The following is the YAML config file:</p>
			<pre>version: 1
formatters:
  <strong class="bold">console_formatter</strong>:
    format: '%(name)s - %(levelname)s - %(message)s'
  <strong class="bold">file_formatter</strong>:
      format: '%(asctime)s - %(name)s - %(levelname)s -         %(message)s'
handlers:
  <strong class="bold">console_handler</strong>:
    class: logging.StreamHandler
    level: DEBUG
    formatter: console_formatter
    stream: ext://sys.stdout
  <strong class="bold">file_handler</strong>:
    class: logging.FileHandler
    level: INFO
    formatter: file_formatter
    filename: logs/logging6.log
loggers:
  <strong class="bold">my_logger</strong>:
    level: DEBUG
    handlers: [console_handler, file_handler]
    propagate: no
root:
  level: ERROR
  handlers: [console_handler]</pre>
			<p>The following is the Python <a id="_idIndexMarker481"/>program using<a id="_idIndexMarker482"/> the YAML file to configure the logger:</p>
			<pre>#<strong class="bold">logging6</strong>.py
import logging
import logging.config
import yaml
with open('logging6.conf.yaml', 'r') as f:
    config = yaml.safe_load(f.read())
    <strong class="bold">logging.config.dictConfig</strong>(config)
logger = logging.getLogger('my_logger')
logger.error("This is an error message")
logger.warning("This is a warning message")
logger.info("This is a info message")
logger.debug("This is a debug message")</pre>
			<p>To load config from a file, we used the <code>dictConfig</code> method instead of the <code>basicConfig</code> method. The outcome of the YAML-based logger configuration is exactly the same as we achieved with Python statements. There are other additional configuration options available for a full-featured logger.  </p>
			<p>In this section, we <a id="_idIndexMarker483"/>presented different <a id="_idIndexMarker484"/>scenarios of configuring one or more logger instances for an application. Next, we will discuss what type of events to log and what not to log. </p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor164"/>What to log and what not to log</h2>
			<p>There is always a debate about what information we should log and what not to log. As a best practice, the following<a id="_idIndexMarker485"/> information is important for logging:</p>
			<ul>
				<li>An application should log all errors and exceptions and the most appropriate way is to log these events at the source module.</li>
				<li>Exceptions that are handled with an alternative flow of code can be logged as warnings.</li>
				<li>For debugging purposes, entry and exit to a function is useful information for logging. </li>
				<li>It is also useful to log decision points in the code because it can be helpful for troubleshooting.</li>
				<li>The activities and actions of users, especially related to the access of certain resources and functions in the application, are important to log for security and auditing purposes. </li>
			</ul>
			<p>When logging messages, the context information is also important, which includes the time, logger name, module name, function name, line number, logging level, and so on. This information is critical for identifying the route cause analysis. </p>
			<p>A follow-up discussion on this topic is what not to capture for logging. We should not log any sensitive information such as user ID, email address, passwords, and any private and sensitive data. We <a id="_idIndexMarker486"/>should also avoid logging any personal and business record data such as health records, government-issued document details, and organization details.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor165"/>Summary</h1>
			<p>In this chapter, we discussed a variety of topics that require the use of advanced Python modules and libraries. We started by refreshing our knowledge about data containers in Python. Next, we learned how to use and build iterators for iterable objects. We also covered generators, which are more efficient and easier to build and use than iterators. We discussed how to open and read from files and how to write to files, followed by the use of a context manager with files. In the next topic, we discussed how to handle errors and exceptions in Python, how to raise exceptions through programming, and how to define custom exceptions. Exception handling is fundamental to any decent Python application. In the last section, we covered how to configure the logging framework in Python using different options for handlers and formatters.</p>
			<p>After going through this chapter, you now know how to build your own iterators and design generator functions to iterate on any iterable object, and how to handle files, errors, and exceptions in Python. You have also learned how to set up loggers with one or more handlers to manage the logging of an application using different logging levels. The skills you have learned in this chapter are key to building any open source or commercial applications. </p>
			<p>In the next chapter, we will switch our focus to how to build and automate unit tests and integration tests.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor166"/>Questions</h1>
			<ol>
				<li value="1">What is the difference between a list and a tuple?</li>
				<li>Which Python statement will always be used when working with a context manager?</li>
				<li>What is the use of the <code>else</code> statement with the <code>try-except</code> block?</li>
				<li>Generators are better to use than iterators. Why?</li>
				<li>What is the use of multiple handlers for logging?</li>
			</ol>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor167"/>Further reading</h1>
			<ul>
				<li><em class="italic">Fluent Python</em> by Luciano Ramalho</li>
				<li><em class="italic">Advanced Guide to Python 3 Programming</em> by John Hunt</li>
				<li><em class="italic">The Python 3 Standard Library by Example</em> by Doug Hellmann</li>
				<li><em class="italic">Python 3.7.10 documentation</em> (<a href="https://docs.python.org/3.7/">https://docs.python.org/3.7/</a>)</li>
				<li>To learn more about additional options available for configuring a logger, you can refer to the official Python documentation at <a href="https://docs.python.org/3/library/logging.config.html">https://docs.python.org/3/library/logging.config.html</a>  </li>
			</ul>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor168"/>Answers</h1>
			<ol>
				<li value="1">A list is a mutable object whereas a tuple is immutable. This means we can update a list after creating it. This is not true for tuples. </li>
				<li>The <code>with</code> statement is used with a context manager.</li>
				<li>The <code>else</code> block is executed only when the code in the <code>try</code> block is executed without any error. A follow-up action can be coded in the <code>else</code> block once the core functionality is executed without any problem in the <code>try</code> block. </li>
				<li>Generators are efficient in memory and also easy to program as compared to iterators. A generator function automatically provides an <code>iterator</code> instance and the <code>next</code> function implementation out of the box.</li>
				<li>The use of multiple handlers is common because one handler usually focuses on one type of destination. If we need to send log events to multiple destinations and perhaps with different priority levels, we will need multiple handlers. Also, if we need to log messages to multiple files with different logging levels, we can create different file handlers to coordinate with multiple files. </li>
			</ol>
		</div>
	</body></html>