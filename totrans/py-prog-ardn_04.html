<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Diving into Python-Arduino Prototyping</h1></div></div></div><p>On the completion of the first project, you successfully started Python-Arduino interfacing. We also interfaced multiple hardware components, that is, motion sensor and LEDs with Arduino via digital pins. During the project, you learned more about the Firmata protocol while utilizing simple Python methods that helped you to establish a connection between your Arduino board and the Python program. When you are working on complex projects, you need more than basic methods to implement the different features that are required by the projects and their associated electronics components. This chapter is designed to give you a comprehensive experience of interfacing so that you can start working on hard problems from the next chapter onwards. We have described various interfacing protocols at the Python-Arduino and Arduino-to-components levels. This chapter also includes practical examples for these protocols with appropriate code and circuit diagrams. In this chapter, we are going to cover the following main topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to Prototyping</li><li class="listitem" style="list-style-type: disc">Detailed description of various <code class="literal">pyFirmata</code> methods to port Arduino functionalities into Python</li><li class="listitem" style="list-style-type: disc">Python-Arduino interfacing examples using Firmata for basic electronic components such as the potentiometer, the buzzer, the DC motor, and the servomotor</li><li class="listitem" style="list-style-type: disc">Introduction to the <strong>inter-integrated circuit</strong> (<strong>I2C</strong>) protocol and prototyping examples for <a id="id363" class="indexterm"/>the I2C components such as the temperature sensor (TMP102) and the light sensor (BH1750)</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Prototyping</h1></div></div></div><p>Just for a moment, let's step back and look at the project that we built in the previous chapter. The project had a very simple goal and we were able to develop it quite comfortably. However, the project is certainly not ready to be a consumer product since it doesn't have<a id="id364" class="indexterm"/> significant functionalities and most importantly, it is not a robust product that can be repeatedly produced as it is. What you can tell about your current project is that it is a DIY project for personal use or just a model that can be developed further to be a great product.</p><p>Now, if you are looking to develop a commercial product or just a DIY project that is really robust and scalable, you must consider starting it by making a model first. At this stage, you need to envision the product with the required features that need to be developed and the number of components that are required to deploy these features. Prototyping is basically a rapid way to create a working model of your envisioned idea before developing it into a fully functional project or product. The proof of concept prototype that is developed during this prototyping process lets you to identify the feasibility of your idea, and in some cases, it helps you to explore the potential of your project. The prototyping or functional model-making process is essential for any industry and not just for electronics.</p><p>In the electronics domain, prototyping can be used at the very first stage of interfacing components to a computer, instead of directly spending a significant amount of resources for the schematic design, PCB manufacturing, and developing the complete code base. This stage helps you to identify major flaws in your circuit design and check the mutual compatibility of the selected components.</p><p>Fortunately, Arduino and the existing software support around Arduino have really simplified electronics' prototyping. In the upcoming sections, we will go through various helper functions and interfacing exercises to help you proceed with your own projects. These examples or templates are designed in such a fashion that they can be used as a blueprint for larger projects.</p><p>Before diving into these prototyping examples, let's understand two different abstractions of interfacing that we are going to explore in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Interfacing Arduino with Python</strong>: We have learned the easiest method of Python-Arduino interfacing using the Firmata protocol. On the Arduino board, the Firmata <a id="id365" class="indexterm"/>protocol is implemented using <a id="id366" class="indexterm"/>the <strong>StandardFirmata</strong> firmware, while on the Python end, we used the Firmata libraries, <code class="literal">pyFirmata</code> or <code class="literal">pyMata</code>, for Python. Another Python-Arduino interfacing method includes the use of simple but nonstandard serial commands using the custom Arduino sketch and the <code class="literal">pySerial</code> library in the Python program. It is also possible to use a computer network to establish communication between Python and Arduino, which is covered later in the book.</li><li class="listitem" style="list-style-type: disc"><strong>Interfacing electronic components with Arduino</strong>: The second interfacing abstraction is associated with Arduino and the physical components. As we already <a id="id367" class="indexterm"/>did, various electronics components can be simply interfaced with the Arduino board using digital or analog pins. These components deal with either digital or analog signals. A few digital pins on the Arduino board support PWM communication for specific hardware devices. The other alternative <a id="id368" class="indexterm"/>interfacing methods include I2C and <strong>serial peripheral interface</strong> (<strong>SPI</strong>) communication. The I2C method is comprehensively explained in the final section of this chapter.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Working with pyFirmata methods</h1></div></div></div><p>The <code class="literal">pyFirmata</code> package provides useful methods to bridge the gap between Python and Arduino's <a id="id369" class="indexterm"/>Firmata protocol. Although these methods are described with specific examples, you can use them in various different ways. This section also provides a detailed description of a few additional methods that were not used in the previous project and lists the missing features.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Setting up the Arduino board</h2></div></div></div><p>To set up your Arduino board in a Python program using <code class="literal">pyFirmata</code>, you need to specifically follow the steps that we have covered. We have distributed the entire code that is <a id="id370" class="indexterm"/>required <a id="id371" class="indexterm"/>for the setup process into small code snippets in each step. While writing your code, you will have to carefully use the code snippets that are appropriate for your application. You can always refer to the example Python files containing the complete code. Before we go ahead, let's first make sure that your Arduino board is equipped with the latest version of the <strong>StandardFirmata</strong> program and is connected to your computer:</p><div><ol class="orderedlist arabic"><li class="listitem">Depending upon the Arduino board that is being utilized, start by importing the appropriate <code class="literal">pyFirmata</code> classes to the Python code. Currently, the inbuilt <code class="literal">pyFirmata</code> classes only support the Arduino Uno and Arduino Mega boards:<div><pre class="programlisting">from pyfirmata import Arduino</pre></div><p>In the case of Arduino Mega, use the following line of code:</p><div><pre class="programlisting">from pyfirmata import ArduinoMega</pre></div></li><li class="listitem">Before we start executing any methods that are associated with handling pins, you need to properly set up the Arduino board. To perform this task, we have to first identify the USB port to which the Arduino board is connected <a id="id372" class="indexterm"/>and assign this location to a variable in the form of a string object. For Mac OS X, the <a id="id373" class="indexterm"/>port string should approximately look like this:<div><pre class="programlisting">port = '/dev/cu.usbmodemfa1331'</pre></div><p>For Windows, use the following string structure:</p><div><pre class="programlisting">port = 'COM3'</pre></div><p>In the case of the Linux operating system, use the following line of code:</p><div><pre class="programlisting">port = '/dev/ttyACM0'</pre></div><p>The port's location might be different according to your computer configuration. You can identify the correct location of your Arduino USB port by using the Arduino IDE, as described in <a class="link" href="ch02.html" title="Chapter 2. Working with the Firmata Protocol and the pySerial Library">Chapter 2</a>, <em>Working with the Firmata Protocol and the pySerial Library</em>.</p></li><li class="listitem">Once you have imported the Arduino class and assigned the port to a variable object, it's time to engage Arduino with <code class="literal">pyFirmata</code> and associate this relationship to another variable:<div><pre class="programlisting">board = Arduino(port)</pre></div><p>Similarly, for Arduino Mega, use this:</p><div><pre class="programlisting">board = ArduinoMega(port)</pre></div></li><li class="listitem">The synchronization between the Arduino board and <code class="literal">pyFirmata</code> requires some time. Adding sleep time between the preceding assignment and the next set of instructions can help to avoid any issues that are related to serial port buffering. The easiest way to add sleep time is to use the inbuilt Python method, <code class="literal">sleep(time)</code>:<div><pre class="programlisting">from time import sleep
sleep(1)</pre></div><p>The <code class="literal">sleep()</code> method takes seconds as the parameter and a floating-point number can be used to provide the specific sleep time. For example, for 200 milliseconds, it will be <code class="literal">sleep(0.2)</code>.</p></li></ol></div><p>At this point, you have successfully synchronized your Arduino Uno or Arduino Mega board to the computer using <code class="literal">pyFirmata</code>. What if you want to use a different variant (other than Arduino Uno or ArduinoMega) of the Arduino board?</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Any board layout in <code class="literal">pyFirmata</code> is defined as a dictionary object. The following is a <a id="id374" class="indexterm"/>sample of the <a id="id375" class="indexterm"/>dictionary object for the Arduino board:<div><pre class="programlisting">arduino = {
    'digital' : tuple(x for x in range(14)),
    'analog' : tuple(x for x in range(6)),
    'pwm' : (3, 5, 6, 9, 10, 11),
    'use_ports' : True,
    'disabled' : (0, 1) # Rx, Tx, Crystal
}</pre></div></li><li class="listitem" style="list-style-type: disc">For your variant of the Arduino board, you have to first create a custom dictionary object. To create this object, you need to know the hardware layout of your board. For example, an Arduino Nano board has a layout similar to a regular Arduino board, but it has eight instead of six analog ports. Therefore, the preceding dictionary object can be customized as follows:<div><pre class="programlisting">nano = {
    'digital' : tuple(x for x in range(14)),
    'analog' : tuple(x for x in range(8)),
    'pwm' : (3, 5, 6, 9, 10, 11),
    'use_ports' : True,
    'disabled' : (0, 1) # Rx, Tx, Crystal
}</pre></div></li><li class="listitem" style="list-style-type: disc">As you have already synchronized the Arduino board earlier, modify the layout of the board using the <code class="literal">setup_layout(layout)</code> method:<div><pre class="programlisting">board.setup_layout(nano)</pre></div><p>This command will modify the default layout of the synchronized Arduino board to the Arduino Nano layout or any other variant for which you have customized the dictionary object.</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Configuring Arduino pins</h2></div></div></div><p>Once your Arduino board is synchronized, it is time to configure the digital and analog pins that <a id="id376" class="indexterm"/>are going<a id="id377" class="indexterm"/> to be used as part of your program. Arduino board has digital I/O pins and analog input pins that can be utilized to perform various operations. As we already know, some of these digital pins are also capable of PWM.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec28"/>The direct method</h3></div></div></div><p>Now before we start writing or reading any data to these pins, we have to first assign modes<a id="id378" class="indexterm"/> to these pins. In the Arduino sketch-based approach that we used in the previous chapter, we used the <code class="literal">pinMode</code> function, that is, <code class="literal">pinMode(11, INPUT)</code> for this operation. Similarly, in <code class="literal">pyFirmata</code>, this assignment operation is performed using the <code class="literal">mode</code> method on the board object as shown in the following code snippet:</p><div><pre class="programlisting">from pyfirmata import Arduino
from pyfirmata import INPUT, OUTPUT, PWM

# Setting up Arduino board
port = '/dev/cu.usbmodemfa1331'
board = Arduino(port)

# Assigning modes to digital pins
board.digital[13].mode = OUTPUT
board.analog[0].mode = INPUT</pre></div><p>The <code class="literal">pyFirmata</code> library includes classes for the <code class="literal">INPUT</code> and <code class="literal">OUTPUT</code> modes, which are required to be imported before you utilized them. The preceding example shows the delegation of digital pin 13 as an output and the analog pin 0 as an input. The mode method is performed on the variable assigned to the configured Arduino board using the <code class="literal">digital[]</code> and <code class="literal">analog[]</code> array index assignment.</p><p>The <code class="literal">pyFirmata</code> library also supports additional modes such as <code class="literal">PWM</code> and <code class="literal">SERVO</code>. The <code class="literal">PWM</code> mode is used to get analog results from digital pins, while the <code class="literal">SERVO</code> mode helps a digital pin to set the angle of the shaft between 0 to 180 degrees. The <code class="literal">PWM</code> and <code class="literal">SERVO</code> modes are explained with detailed examples later in this chapter. If you are using any of these modes, import their appropriate classes from the <code class="literal">pyFirmata</code> library. Once these classes are imported from the <code class="literal">pyFirmata</code> package, the modes for the appropriate pins can be assigned using the following lines of code:</p><div><pre class="programlisting">board.digital[3].mode = PWM
board.digital[10].mode = SERVO</pre></div><div><div><h3 class="title"><a id="note23"/>Note</h3><p>In electronics, PWM is a signal modulation technique that is greatly used to provide controlled amount of power to components. While dealing with digital signals, the PWM technique is used to obtain analog results by utilizing <a id="id379" class="indexterm"/>square waves and controlling the width of the signal.</p><p>As we already know, the digital pins of the Arduino board can only have two states, 5V (HIGH) and 0V (LOW). One can generate square pulses by controlling the switching pattern between HIGH and LOW and thus generate the pulse. By changing the width of these pulses, you can simulate any voltage between 0V and 5V. As you can see in the following diagram, we have a square wave with 25 percent width of the duty cycle. It means that we are simulating 0.25 * 5V = 1.25V for the period of that duty cycle:</p><div><img src="img/5938OS_04_06.jpg" alt="The direct method"/></div><p>The Arduino language supports PWM using the <code class="literal">analogWrite()</code> function, where the voltage range between 0V and 5V is linearly scaled for values between 0 and 255. For example, 50 percent duty cycle (simulation of 2.5V) translates to a value of 127, which can be coded in Arduino as <code class="literal">analogWrite(13,127)</code>. Here, the number <code class="literal">13</code> represents the digital pin that supports PWM on the Arduino Uno board. Similarly, a 20 percent duty cycle (1V) translates to <code class="literal">analogWrite(13,64)</code>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec29"/>Assigning pin modes</h3></div></div></div><p>The direct method of configuring pins is mostly used for a single line of execution calls. In a project <a id="id380" class="indexterm"/>containing a large code and complex logic, it is convenient to assign a pin with its role to a variable object. With an assignment like this, you can later utilize the assigned variable throughout the program for various actions, instead of calling the direct method every time you need to use that pin. In <code class="literal">pyFirmata</code>, this assignment can be performed using the <code class="literal">get_pin(pin_def)</code> method:</p><div><pre class="programlisting">from pyfirmata import Arduino
port = '/dev/cu.usbmodemfa1311'
board = Arduino(port)

# pin mode assignment
ledPin = board.get_pin('d:13:o')</pre></div><p>The <code class="literal">get_pin()</code> method lets you assign pin modes using the <code class="literal">pin_def</code> string parameter, <code class="literal">'d:13:o'</code>. The three components of <code class="literal">pin_def</code> are pin type, pin number, and pin mode separated by a colon (<code class="literal">:</code>) operator. The pin types (analog and digital) are denoted <a id="id381" class="indexterm"/>with <code class="literal">a</code> and <code class="literal">d</code> respectively. The <code class="literal">get_pin()</code> method supports three modes, <code class="literal">i</code> for input, <code class="literal">o</code> for output, and <code class="literal">p</code> for PWM. In the previous code sample, <code class="literal">'d:13:o'</code> specifies the digital pin 13 as an output. In another example, if you want to set up the analog pin 1 as an input, the parameter string will be <code class="literal">'a:1:i'</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Working with pins</h2></div></div></div><p>Now you have <a id="id382" class="indexterm"/>configured your Arduino pins, it's time to start performing actions using them. Two different <a id="id383" class="indexterm"/>types of methods are supported while working with pins: reporting methods and I/O operation methods.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec30"/>Reporting data</h3></div></div></div><p>When pins get configured in a program as analog input pins, they start sending input values to the serial port. If the program does not utilize this incoming data, the data starts <a id="id384" class="indexterm"/>getting buffered at the serial port and quickly overflows. The <code class="literal">pyFirmata</code> library provides the reporting and iterator methods to deal with this phenomenon.</p><p>The <code class="literal">enable_reporting()</code> method is used to set the input pin to start reporting. This method needs to be utilized before performing a reading operation on the pin:</p><div><pre class="programlisting">board.analog[3].enable_reporting()</pre></div><p>Once the reading operation is complete, the pin can be set to disable reporting:</p><div><pre class="programlisting">board.analog[3].disable_reporting()</pre></div><p>In the preceding example, we assumed that you had already set up the Arduino board and configured the mode of the analog pin 3 as <code class="literal">INPUT</code>.</p><p>The <code class="literal">pyFirmata</code> library also provides the <code class="literal">Iterator()</code> class to read and handle data over the serial port. While working with analog pins, we recommend that you start an iterator thread in the main loop to update the pin value to the latest one. If the iterator method is not used, the buffered data might overflow your serial port. This class is defined in the <code class="literal">util</code> module of the <code class="literal">pyFirmata</code> package and needs to be imported before it is utilized in the code:</p><div><pre class="programlisting">from pyfirmata import Arduino, util
# Setting up the Arduino board
port = 'COM3'
board = Arduino(port)
sleep(5)

# Start Iterator to avoid serial overflow
it = util.Iterator(board)
it.start()</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec31"/>Manual operations</h3></div></div></div><p>As we have configured the Arduino pins to suitable modes and their reporting characteristic, we can start <a id="id385" class="indexterm"/>monitoring them. The <code class="literal">pyFirmata</code> library provides the <code class="literal">write()</code> and <code class="literal">read()</code> methods for the configured pins.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec03"/>The write() method</h4></div></div></div><p>The <code class="literal">write()</code> method is <a id="id386" class="indexterm"/>used to write a value to the pin. If the pin's mode is set to <code class="literal">OUTPUT</code>, the value parameter is a Boolean, that is, <code class="literal">0</code> or <code class="literal">1</code>:</p><div><pre class="programlisting">board.digital[pin].mode = OUTPUT
board.digital[pin].write(1)</pre></div><p>If you have used an alternative method of assigning the pin's mode, you can use the <code class="literal">write()</code> method as follows:</p><div><pre class="programlisting">ledPin = board.get_pin('d:13:o')
ledPin.write(1)</pre></div><p>In the case of the PWM signal, the Arduino accepts a value between 0 and 255 that represents the length of the duty cycle between 0 and 100 percent. The <code class="literal">pyFirmata</code> library provides a simplified method to deal with the PWM values as instead of values between 0 and 255, you can just provide a float value between 0 and 1.0. For example, if you want a 50 percent duty cycle (2.5V analog value), you can specify <code class="literal">0.5</code> with the <code class="literal">write()</code> method. The <code class="literal">pyFirmata</code> library will take care of the translation and send the appropriate value, that is, <code class="literal">127</code>, to the Arduino board via the Firmata protocol:</p><div><pre class="programlisting">board.digital[pin].mode = PWM
board.digital[pin].write(0.5)</pre></div><p>Similarly, for the indirect method of assignment, you can use some code similar to the following snippet:</p><div><pre class="programlisting">pwmPin = board.get_pin('d:13:p')
pwmPin.write(0.5)</pre></div><p>If you are using the <code class="literal">SERVO</code> mode, you need to provide the value in degrees between 0 and 180. Unfortunately, the <code class="literal">SERVO</code> mode is only applicable for direct assignment of the pins and <a id="id387" class="indexterm"/>will be available in future for indirect assignments:</p><div><pre class="programlisting">board.digital[pin].mode = SERVO
board.digital[pin].write(90)</pre></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec04"/>The read() method</h4></div></div></div><p>The <code class="literal">read()</code> method provides an output value at the specified Arduino pin. When the <code class="literal">Iterator()</code> class is being used, the value received using this method is the latest updated value <a id="id388" class="indexterm"/>at the serial port. When you read a digital pin, you can get only one of the two inputs, <code class="literal">HIGH</code> or <code class="literal">LOW</code>, which will translate to <code class="literal">1</code> or <code class="literal">0</code> in Python:</p><div><pre class="programlisting">board.digital[pin].read()</pre></div><p>The analog pins of Arduino linearly translate the input voltages between 0 and +5V to 0 and 1023. However, in <code class="literal">pyFirmata</code>, the values between 0 and +5V are linearly translated into the float values of 0 and 1.0. For example, if the voltage at the analog pin is 1V, an Arduino program will measure a value somewhere around 204, but you will receive the float value as 0.2 while using pyFirmata's <code class="literal">read()</code> method in Python.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Additional functions</h2></div></div></div><p>Besides the method that has already been described, the <code class="literal">pyFirmata</code> library also provides some utility functions for additional customization, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">servo_config(pin,min_pulse=544,max_pulse=2400,angle=0)</code>: This method<a id="id389" class="indexterm"/> helps to set up the <code class="literal">SERVO</code> mode with further customization such as the minimum pulse value, maximum pulse value, and starting angle. One can set the initial angle of the servomotor using the <code class="literal">angle</code> parameter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pass_time(seconds)</code>: This method provides a functionality similar to that found in the <a id="id390" class="indexterm"/>default Python's default method <code class="literal">sleep()</code> that is provided by the <code class="literal">time</code> module. However, the <code class="literal">pass_time</code> function provides a non-blocking timeout in seconds.</li><li class="listitem" style="list-style-type: disc"><code class="literal">get_firmata_version()</code>: This function returns a tuple that contains the version of the <a id="id391" class="indexterm"/>Firmata protocol from the Arduino board:<div><pre class="programlisting">board.get_firmata_version()</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">exit()</code>: We recommend that you disconnect the Arduino board from <code class="literal">pyFirmata</code> once <a id="id392" class="indexterm"/>you have completed running your code. This will free the serial port, which can be then utilized by other programs:<div><pre class="programlisting">board.exit()</pre></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Upcoming functions</h2></div></div></div><p>The <code class="literal">pyFirmata</code> library is currently under development and it continuously receives updates to add and improve various methods. Although most of the native Arduino methods are available in the <code class="literal">pyFirmata</code> library via the Firmata protocol, there are few functions that are still missing or under development and they are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pulseIn</code>/<code class="literal">pulseOut</code>: These <a id="id393" class="indexterm"/>native Arduino functions wait for the Arduino pin to achieve the specified value. The waiting period is returned in microseconds. This method is widely used by Ping (ultrasonic distance measurement) sensors. Implementation of this method using <code class="literal">pyFirmata</code> requires major changes to the standard Firmata protocol.</li><li class="listitem" style="list-style-type: disc"><code class="literal">shiftIn</code>/<code class="literal">shiftOut</code>: These <a id="id394" class="indexterm"/>functions shift a byte of data in or out, one bit at a time. The <code class="literal">pyFirmata</code> library lacks supports for these functions and can be implemented using the various Python programming tricks.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Prototyping templates using Firmata</h1></div></div></div><p>The goal of this section is to provide prototyping templates while also explaining various Python methods and programming techniques. It tries to cover some of the most popular <a id="id395" class="indexterm"/>sensors with coding examples that are used by DIY Arduino projects. This section is designed to utilize the Firmata protocol to implement these Python programs. It also includes various Python programming paradigms such as working with indefinite loops, creating custom functions, working with random numbers, acquiring manual inputs from prompt, and so on. These prototyping templates are designed in such a way that they can be easily included in large projects or they can be blueprints for a larger project that can be developed around them. You learned about the <code class="literal">pyFirmata</code> package comprehensively in the previous section and we will only utilize those <code class="literal">pyFirmata</code> functions in the upcoming examples. An alternative Python library that supports the Firmata protocol is covered later in the chapter.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Potentiometer – continuous observation from an analog input</h2></div></div></div><p>A potentiometer<a id="id396" class="indexterm"/> is a variable resistor that can be controlled using a knob. It has three terminals out of which two of them are Vref and ground, while the third one provides a variable output. The output of the potentiometer varies between the supplied voltages, according to the position of the knob. In Arduino, you can connect the potentiometer with +5V and the ground pins of the board to provide the supply voltage. When the variable terminal is interfaced with the Arduino analog input, this voltage values translates between 0 and 1023 respectively. In the case of <code class="literal">pyFirmata</code>, the value of the analog observation translates between 0 and 1.</p><p>This coding template containing the potentiometer can be applied to projects in which external <a id="id397" class="indexterm"/>manual control to a system is required. The potentiometer output that translates to the analog input of Arduino can be used to control an actuator such as a motor or an LED. In some cases, the input can also be used to control the flow of the program by applying its values to a variable.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec32"/>Connections</h3></div></div></div><p>Connect the output of the <a id="id398" class="indexterm"/>potentiometer to analog pin A0 as shown in the following diagram. Complete the circuit by connecting Vref and the ground terminals of the potentiometers to +5V and the ground of the Arduino board respectively:</p><div><img src="img/5938OS_04_01.jpg" alt="Connections"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec33"/>The Python code</h3></div></div></div><p>Assuming that <a id="id399" class="indexterm"/>you already have the <strong>StandardFirmata</strong> firmware uploaded to the Arduino board, you are required to run a Python code on your computer to complete its interfacing with the potentiometer. A Python code template with the name <code class="literal">potentiometer.py</code> to help you get started with this example is located in the code bundle of this book, which can be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support/1961">https://www.packtpub.com/books/content/support/1961</a>. Let's open this file to understand the program. As you can see, we are using the <code class="literal">pyFirmata</code> library with other Python modules such as <code class="literal">time</code> and <code class="literal">os</code>:</p><div><pre class="programlisting">from pyfirmata import Arduino, util
from time import sleep
import os</pre></div><p>In the second step of the program, we are initializing the Arduino board and starting the <code class="literal">Iterator()</code> function over it:</p><div><pre class="programlisting">port = 'COM3'
board = Arduino(port)
sleep(5)
it = util.Iterator(board)
it.start()</pre></div><p>Once the <a id="id400" class="indexterm"/>board has been initialized, we need to assign a role to the analog pin, <code class="literal">0</code>, as it is going to be used as an input pin. We are using the <code class="literal">get_pin()</code> method to assign a role to the analog pin, <code class="literal">0</code>:</p><div><pre class="programlisting">a0 = board.get_pin('a:0:i')</pre></div><p>Now, as part of the main program, we need to continuously monitor the output of the potentiometer at the pin, <code class="literal">a0</code>, that we just defined. We are using the <code class="literal">while</code> statement to create an indefinite loop for the script that will read and print the analog input. The problem with this indefinite <code class="literal">while</code> loop is that the program will not close properly when it is interrupted and it will not release the board by executing the <code class="literal">board.exit()</code> method. To avoid this, we will use another control statement from the Python programming paradigm, called <code class="literal">try/except</code>:</p><div><pre class="programlisting">try:
  while True:
    p = a0.read()
    print p
except KeyboardInterrupt:
  board.exit()
  os._exit()</pre></div><p>Using this statement, the program will keep running the <code class="literal">while</code> loop until the keyboard interruption occurs, which is <em>Ctrl</em> + <em>C</em>, and the program will execute the script under the <code class="literal">except</code> statement. This includes releasing the board using <code class="literal">board.exit()</code> and existing the program using the <code class="literal">os._exit()</code> method. In summary, the program will keep printing the output of the potentiometer until someone presses <em>Ctrl</em> + <em>C</em> to interrupt the program.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>The <code class="literal">try/except</code> statement provides a very efficient way to capture exceptions <a id="id401" class="indexterm"/>in Python. It is advisable to utilize this statement throughout the development process to cleverly debug your programs. You can learn about Python errors and exceptions from the following links:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://docs.python.org/2/reference/compound_stmts.html#try">https://docs.python.org/2/reference/compound_stmts.html#try</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://docs.python.org/2/tutorial/errors.html">https://docs.python.org/2/tutorial/errors.html</a></li></ul></div></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec68"/>Buzzer – generating sound alarm pattern</h2></div></div></div><p>Digital buzzer sensors are used in various applications that require alarm notifications. These <a id="id402" class="indexterm"/>sensors produce sound when they are supplied with a digital <code class="literal">HIGH</code> value (that is, +5V), which can be provided by using Arduino digital pins. Similar to the <a id="id403" class="indexterm"/>LED example in the previous chapter, they are very easy to interface with Arduino. However, rather than performing a simple digital output, we are implementing Python programming tricks to generate different sound patterns and produce various sound effects. The same code template can be also used to produce different LED blink patterns.</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>An <a id="id404" class="indexterm"/>analog digital buzzer can be found at <a class="ulink" href="http://www.amazon.com/Arduino-Compatible-Speaker-arduino-sensors/dp/B0090X0634">http://www.amazon.com/Arduino-Compatible-Speaker-arduino-sensors/dp/B0090X0634</a>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec34"/>Connections</h3></div></div></div><p>As displayed in <a id="id405" class="indexterm"/>the following circuit diagram, connect the VCC and the ground of the sensor board to 5V and the ground pin of the Arduino board respectively. Connect the signal pin of the sensor to the digital pin 2 via the 220-ohm resistor. You can use any digital pin to connect the buzzer. Just make sure that you update the Python code to reflect the pin that you have selected.</p><div><img src="img/5938OS_04_02.jpg" alt="Connections"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec35"/>The Python code</h3></div></div></div><p>In the code example, two different sound patterns are generated using arrays of time delays. To perform these actions, we are going to implement a custom Python function that will take the<a id="id406" class="indexterm"/> pin number, the recurrence time, and the pattern number as input. Before we jump to explain the code, let's open the program file, <code class="literal">buzzerPattern.py</code>, from the code folder. In the beginning of the code, you can find the Python function, <code class="literal">buzzerPattern()</code> that will be called from the main program with appropriate options. As this function is the core of the entire program, let's try to understand it. The function contains two hardcoded pattern arrays, <code class="literal">pattern1</code> and <code class="literal">pattern2</code>. Each contains the on and off time for the buzzer for a second, which is the duty cycle of the pattern. For example, in <code class="literal">pattern1</code>, <code class="literal">0.8</code> represents the time the buzzer needs to be on and <code class="literal">0.2</code> represents the opposite. The function will repeat this buzzer pattern for <code class="literal">recurrence</code> times that is specified by the function argument. Once the <code class="literal">for</code> loop with the value of <code class="literal">recurrence</code> is started, the function will check for the pattern number from the function argument and execute the pattern. We are using the <code class="literal">flag</code> variable to alternatively use elements of the <code class="literal">pattern</code> array to control the buzzer. Once the entire recurrence loop is complete, we will turn off the buzzer completely again, if it is on, and safely disengage the board using the <code class="literal">exit()</code> method:</p><div><pre class="programlisting">def buzzerPattern(pin, recurrence, pattern):
  pattern1 = [0.8, 0.2]
  pattern2 = [0.2, 0.8]
  flag = True
  for i in range(recurrence):
    if pattern == 1:
      p = pattern1
    elif pattern == 2:
      p = pattern2
    else:
      print "Please enter valid pattern. 1 or 2."
      exit
    for delay in p:
      if flag is True:
        board.digital[pin].write(1)
        flag = False
        sleep(delay)
      else:
        board.digital[pin].write(0)
        flag = True
        sleep(delay)
  board.digital[pin].write(0)
  board.exit()</pre></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>If you want to change the time delays or implement a totally different pattern, you can play around with the <code class="literal">pattern</code> arrays.</p></div></div><p>The remaining<a id="id407" class="indexterm"/> part of the program is relatively simple as it contains code for importing libraries and initializing the Arduino board. Once the board is initialized, we will execute the <code class="literal">buzzerPattern()</code> function with the input argument, <code class="literal">(2, 10, 1)</code>. This argument will ask the function to play <code class="literal">pattern1</code> 10 times on the pin number 2:</p><div><pre class="programlisting">from pyfirmata import Arduino
from time import sleep

port = '/dev/cu.usbmodemfa1331'
board = Arduino(port)
sleep(5)

buzzerPattern(2, 10, 1)</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec69"/>DC motor – controlling motor speed using PWM</h2></div></div></div><p>DC motors are widely used in robotics applications. They are available in a wide range of voltage specifications, depending upon the application. In this example, we are utilizing <a id="id408" class="indexterm"/>a 5V DC motor because we want to supply the power using the Arduino board itself. As the <a id="id409" class="indexterm"/>Arduino digital pin can only have two states, that is, <code class="literal">HIGH</code> (+5V) or <code class="literal">LOW</code> (0V), it is impossible to control the speed of the motor using just the <code class="literal">OUTPUT</code> mode. As a solution, we are going to implement the <code class="literal">PWM</code> mode via digital pins that are capable of supporting PWM. While using <code class="literal">pyFirmata</code>, pins configured with the <code class="literal">PWM</code> mode take any float input values between 0 and 1.0, which represent 0V and 5V respectively.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec36"/>Connections</h3></div></div></div><p>Depending upon the load, DC motors can sometimes draw large amounts of current and harm the <a id="id410" class="indexterm"/>Arduino board. To avoid any damage to the Arduino board due to any large accidental current draw, we will use a transistor as a switch, which only uses a small amount of current to control the large amount of current in the DC motor. To complete the circuit connection as displayed in the following diagram, you will need an NPN transistor (TIP120, N2222, or a similar one), one diode (1N4001 or similar one) and a 220-ohm resistor with your DC motor. Connect the base of the transistor to the digital pin 3 that also supports the PWM mode. Connect the remaining components as displayed in the diagram:</p><div><img src="img/5938OS_04_03.jpg" alt="Connections"/></div><div><div><h3 class="title"><a id="note27"/>Note</h3><p>To find out more about transistor terminals (collector, emitter, and base) and to <a id="id411" class="indexterm"/>associate transistor pins with their respective terminals, you can refer to their <a id="id412" class="indexterm"/>datasheets or the following websites:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://en.wikipedia.org/wiki/Transistor">http://en.wikipedia.org/wiki/Transistor</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.onsemi.com/pub/Collateral/TIP120-D.PDF">http://www.onsemi.com/pub/Collateral/TIP120-D.PDF</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.mouser.com/ds/2/68/PN2221-2222A-11964.pdf">http://www.mouser.com/ds/2/68/PN2221-2222A-11964.pdf</a></li></ul></div></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec37"/>The Python code</h3></div></div></div><p>The Python recipe with the name <code class="literal">dcMotorPWM.py</code> for a DC motor is located in the code bundle <a id="id413" class="indexterm"/>of this book, which can be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support/1961">https://www.packtpub.com/books/content/support/1961</a>. Open the Python file to further understand the usage of PWM to control the speed of the DC motor. The custom function, <code class="literal">dcMotorControl()</code>, takes motor speed and time duration as input parameters as described in the following code snippet:</p><div><pre class="programlisting">def dcMotorControl(r, deltaT):
  pwmPin.write(r/100.00)
  sleep(deltaT)
  pwmPin.write(0)</pre></div><p>Just like the previous examples, we are using a similar code to import the necessary library and initialize the Arduino board. After initialization, we are assigning the mode of the digital pin 3 as <code class="literal">PWM</code>, which can be seen from the utilization of the <code class="literal">get_pin('d:3:p')</code> method. This code reflects the indirect mode of pin mode assignment that we learned in the previous section:</p><div><pre class="programlisting"># Set mode of pin 3 as PWM
pwmPin = board.get_pin('d:3:p')</pre></div><p>As part of collecting manual inputs from the user, we are running a combination of the <code class="literal">try/except</code> statement (to release the board on exit) and the <code class="literal">while</code> statement (to obtain continuous inputs from the user). The code template introduces the <code class="literal">input()</code> method to obtain custom values (motor speed and duration to run the motor) from Python's interactive terminal. Once these values are obtained from the user, the program calls the <code class="literal">dcMotorControl()</code> function to perform the motor action:</p><div><pre class="programlisting">try:
  while True:
    r = input("Enter value to set motor speed: ")
    if (r &gt; 100) or (r &lt;= 0):
      print "Enter appropriate value."
      board.exit()
      break
    t = input("How long? (seconds)")
    dcMotorControl(r, t)
except KeyboardInterrupt:
  board.exit()
  os._exit</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec70"/>LED – controlling LED brightness using PWM</h2></div></div></div><p>In the previous template, we controlled the speed of DC motor using PWM. One can also control the brightness of the LED using the same method. Instead of asking the user to input <a id="id414" class="indexterm"/>brightness, we are going to use the Python module <code class="literal">random</code> in this template. We will use this module to generate a random number between 1 and 100, which will be later used to write that value on the pin and randomly change the brightness of the <a id="id415" class="indexterm"/>LED. This <code class="literal">randint()</code> function is a really useful feature provided by the <code class="literal">random</code> module and it is widely used in testing prototypes by rapidly sending random signals.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>The <code class="literal">randint()</code> function takes the <code class="literal">randint(startValue, endValue)</code> syntax and returns the random integer between the range established by <code class="literal">startValue</code> and <code class="literal">endValue</code>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec38"/>Connections</h3></div></div></div><p>Like we used in the <a id="id416" class="indexterm"/>previous chapter's project, we will need a pull-up resistor to connect the LED with the Arduino pin. As displayed in the following diagram, simply connect the anode of the LED (longer leg) to the digital pin 11 via one 220-ohm resistor and connect the cathode (shorter leg) to the ground:</p><div><img src="img/5938OS_04_04.jpg" alt="Connections"/></div><p>It is important to note that the digital pin 11 on Arduino Uno is also capable of performing <a id="id417" class="indexterm"/>PWM along with digital pins 3, 5, 6, 9, and 10.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec39"/>The Python code</h3></div></div></div><p>The Python code with the title <code class="literal">ledBrightnessPWM.py</code> for this exercise is located in the <a id="id418" class="indexterm"/>code bundle of this book, which can be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support/1961">https://www.packtpub.com/books/content/support/1961</a>. Open the file to explore the code. As you can see in this code template, a float value between 0 and 1.0 is randomly selected before passing it to the PWM pin. This method generates random LED brightness for a given amount of time. This practice can be used to generate random input samples for various other testing projects.</p><p>As you can see, the first few lines of the code import the necessary libraries and initialize the board. Although the board variable, <code class="literal">/dev/cu.usbmodemfa1311</code>, is selected for Mac OS X, you can use your operating system's specific variable name in the following code snippet. You can obtain more information about choosing this variable name from the <em>Setting up the Arduino board</em> section at the beginning of this chapter.</p><div><pre class="programlisting">from pyfirmata import Arduino, INPUT, PWM
from time import sleep
import random

port = '/dev/cu.usbmodemfa1311'
board = Arduino(port)
sleep(5)</pre></div><p>In this example, we are utilizing the direct method of pin mode assignment. As you can see in the following code snippet, the digital pin 11 is being assigned to the <code class="literal">PWM</code> mode:</p><div><pre class="programlisting">pin = 11
board.digital[pin].mode = PWM</pre></div><p>Once the pin mode is assigned, the program will run a loop using the <code class="literal">for</code> statement while randomly generating an integer number between 0 and 100, and then send the appropriate PWM value to the pin according to the generated number. With the execution of this, you will be able to see the LED randomly changing its brightness for approximately 10 seconds:</p><div><pre class="programlisting">for i in range(0, 99):
  r = random.randint(1, 100)
  board.digital[pin].write(r / 100.00)
  sleep(0.1)</pre></div><p>Once you are done with the loop, you need to safely disengage the Arduino board after turning off the LED one last time. It is a good practice to turn off the LED or any connected <a id="id419" class="indexterm"/>sensor at the end of the program before exiting the board, to prevent any sensor from running accidentally:</p><div><pre class="programlisting">board.digital[pin].write(0)
board.exit()</pre></div><div><div><h3 class="title"><a id="note29"/>Note</h3><p>If you want to homogenously glow the LED instead of randomly changing its brightness, replace the code in the <code class="literal">for</code> loop with the following code snippet. Here, we are changing the PWM input to the incrementing variable, <code class="literal">i</code>, instead of the random variable, <code class="literal">r</code>:</p><div><pre class="programlisting">for i in range(0, 99):
  board.digital[pin].write(i / 100.00)
  sleep(0.1)</pre></div></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec71"/>Servomotor – moving the motor to a certain angle</h2></div></div></div><p>Servomotors<a id="id420" class="indexterm"/> are widely used electronic components in applications such as pan-tilt camera control, robotic arms, mobile robot movements, and so on where precise movement of the <a id="id421" class="indexterm"/>motor shaft is required. This precise control of the motor shaft is possible because of the position sensing decoder, which is an integral part of the servomotor assembly. A standard servomotor allows the angle of the shaft to be set between 0 and 180 degrees. The <code class="literal">pyFirmata</code> library provides the <code class="literal">SERVO</code> mode that can be implemented on every digital pin. This prototyping exercise provides a template and guidelines to interface a servomotor with Python.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec40"/>Connections</h3></div></div></div><p>Typically, a servomotor has wires that are color-coded red, black, and yellow respectively to<a id="id422" class="indexterm"/> connect with the power, ground, and signal of the Arduino board. Connect the power and the ground of the servomotor to 5V and the ground of the Arduino board. As displayed in the following diagram, connect the yellow signal wire to the digital pin 13:</p><div><img src="img/5938OS_04_05.jpg" alt="Connections"/></div><p>If you want to use any other digital pin, make sure that you change the pin number in the Python program in the next section. Once you have made the appropriate connections, let's move on to the Python program.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec41"/>The Python code</h3></div></div></div><p>The Python file <a id="id423" class="indexterm"/>consisting of this code is named <code class="literal">servoCustomAngle.py</code> and is located in the code bundle of this book, which can be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support/19610">https://www.packtpub.com/books/content/support/19610</a>. Open this file in your Python editor. Like other examples, the starting section of the program contains the code to import the libraries and set up the Arduino board:</p><div><pre class="programlisting">from pyfirmata import Arduino, SERVO
from time import sleep

# Setting up the Arduino board
port = 'COM5'
board = Arduino(port)
# Need to give some time to pyFirmata and Arduino to synchronize
sleep(5)</pre></div><p>Now that you have Python ready to communicate with the Arduino board, let's configure the<a id="id424" class="indexterm"/> digital pin that is going to be used to connect the servomotor to the Arduino board. We will complete this task by setting the <code class="literal">mode</code> of pin 13 to <code class="literal">SERVO</code>:</p><div><pre class="programlisting"># Set mode of the pin 13 as SERVO
pin = 13
board.digital[pin].mode = SERVO</pre></div><p>The <code class="literal">setServoAngle(pin,angle)</code> custom function takes the pins on which the servomotor is connected and the custom angle as input parameters. This function can be used as a part of various large projects that involve servos:</p><div><pre class="programlisting"># Custom angle to set Servo motor angle
def setServoAngle(pin, angle):
  board.digital[pin].write(angle)
  sleep(0.015)</pre></div><p>In the main logic of this template, we want to incrementally move the motor shaft in one direction until it achieves the maximum achievable angle (180 degrees) and then move it back to the original position with the same incremental speed. In the <code class="literal">while</code> loop, we will ask the user to provide input to continue this routine, which will be captured using the <code class="literal">raw_input()</code> function. The user can enter the character <code class="literal">y</code> to continue this routine or enter any other character to abort the loop:</p><div><pre class="programlisting"># Testing the function by rotating motor in both direction
while True:
  for i in range(0, 180):
    setServoAngle(pin, i)
  for i in range(180, 1, -1):
    setServoAngle(pin, i)

  # Continue or break the testing process
  i = raw_input("Enter 'y' to continue or Enter to quit): ")
  if i == 'y':
    pass
  else:
    board.exit()
    break</pre></div><p>While working with all these prototyping examples, we used the direct communication method by using digital and analog pins to connect the sensors with Arduino. Now, let's get familiar with another widely used communication method between Arduino and the sensors, which is called I2C communication.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Prototyping with the I2C protocol</h1></div></div></div><p>In the previous section, sensors or actuators were directly communicating with Arduino via digital, analog, or PWM pins. These methods are utilized by a large number of basic, low-level sensors and you will be widely using them in your future Arduino <a id="id425" class="indexterm"/>projects. Beside these methods, there is a wide variety of popular sensors that are based <a id="id426" class="indexterm"/>on <strong>integrated circuit</strong> (<strong>IC</strong>), which require different ways of communication. These IC-based advanced sensors utilize I2C- or SPI bus-based methods to communicate with the microcontroller. As we are going to use I2C-based sensors in the upcoming projects, the section will only cover the I2C protocol and practical example to understand the protocol in a better way. Once you understand the fundamentals of the I2C protocol, you can learn the SPI protocol very quickly.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>You can learn more about SPI protocol and the supported Arduino SPI library from the following links:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://arduino.cc/en/Reference/SPI">http://arduino.cc/en/Reference/SPI</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.instructables.com/id/Using-an-Arduino-to-Control-or-Test-an-SPI-electro/">http://www.instructables.com/id/Using-an-Arduino-to-Control-or-Test-an-SPI-electro/</a></li></ul></div></div></div><p>In 1982, the Philips company needed to find out a simple and efficient way to establish communication between a microcontroller and the peripheral chips on TV sets, which led to the development of the I2C communication protocol. The I2C protocol connects the microcontroller or the CPU to a large number of low-speed peripheral devices using just two wires. Examples of such peripheral devices or sensors include I/O devices, A/D converters, D/A converters, EEPROM, and many similar devices. I2C uses the concept of master-slave devices, where the microcontroller is the master and the peripherals are the slave devices. The following diagram shows an example of the I2C communication bus:</p><div><img src="img/5938OS_04_07.jpg" alt="Prototyping with the I2C protocol"/></div><p>As displayed in the preceding diagram, the master device contains two bidirectional lines: <strong>Serial Data Line</strong> (<strong>SDA</strong>) and <strong>Serial Clock Line</strong> (<strong>SCL</strong>). In the case of Arduino Uno, the <a id="id427" class="indexterm"/>analog pins 4 and 5 provide interfaces for SDA and SCL. It is important to note that these pin <a id="id428" class="indexterm"/>configurations will change with different variants of the Arduino board. The peripheral sensors that are working as slaves connect to these lines, which are also <a id="id429" class="indexterm"/>supported by the pull resistors. The master device is responsible for generating the clock signal on the SCL and initializing communication with the slaves. The slave devices receive the clock and respond to the commands sent by the master device.</p><p>The order of the slave devices is not important as the master device communicates with the slaves using their part address. To initialize the communication, the master sends one of the following types of message on the bus with the specific part address:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A single message in which data is written on the slave</li><li class="listitem" style="list-style-type: disc">A single message in which data is read from the slave</li><li class="listitem" style="list-style-type: disc">Multiple messages in which first data is requested from the slave and then the received data is read</li></ul></div><p>To support I2C protocol in Arduino programming, the Arduino IDE comes equipped with a default library called <code class="literal">Wire</code>. This library can be imported to your Arduino sketch by adding the following line of code at the beginning of your program:</p><div><pre class="programlisting">#include &lt;Wire.h&gt;</pre></div><p>To initialize I2C communication, the <code class="literal">Wire</code> library uses a combination of the following functions to write data on the slave device:</p><div><pre class="programlisting">Wire.beginTransmission(0x48);
Wire.write(0);
Wire.endTransmission();</pre></div><p>These slave <a id="id430" class="indexterm"/>devices are differentiated using unique part addresses. As you can see in the preceding example, <code class="literal">0x48</code> is the part address of a connected slave device.</p><p>The <code class="literal">Wire</code> library<a id="id431" class="indexterm"/> also provides the <code class="literal">Wire.read()</code> and <code class="literal">Wire.requestFrom()</code> functions to read and request data from the slave devices. These functions are explained in detail in the next section.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>You can learn <a id="id432" class="indexterm"/>more about <a id="id433" class="indexterm"/>the I2C protocol and the <code class="literal">Wire</code> library from the following links:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.instructables.com/id/I2C-between-Arduinos/">http://www.instructables.com/id/I2C-between-Arduinos/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://arduino.cc/en/reference/wire">http://arduino.cc/en/reference/wire</a></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec72"/>Arduino examples for I2C interfacing</h2></div></div></div><p>In order to practice prototyping exercises for the I2C protocol, let's utilize two popular I2C sensors that <a id="id434" class="indexterm"/>detect temperature and ambient light in the environment. As the first step towards understanding I2C messaging, we will work with Arduino sketches for I2C interfacing, and later, we will develop similar functionalities using Python.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec42"/>Arduino coding for the TMP102 temperature sensor</h3></div></div></div><p>TMP102 is one <a id="id435" class="indexterm"/>of the <a id="id436" class="indexterm"/>widely used digital sensors to measure ambient temperature. TMP102 provides better resolution and accuracy compared to traditional analog temperature sensors such as LM35 or TMP36. The following is an image of TMP102:</p><div><img src="img/5938OS_04_08.jpg" alt="Arduino coding for the TMP102 temperature sensor"/></div><p>The previous image shows a breakout board with the available pins for the TMP102 sensor. Please keep in mind that the TMP102 sensor that you obtain might have a different pin layout compared to the one displayed in the image. It is always advisable to check the datasheet of your sensor breakout board before making any connections. As you <a id="id437" class="indexterm"/>can see in the image, the TMP102 sensor supports the I2C protocol and is<a id="id438" class="indexterm"/> equipped with SDA and SCL pins. Connect analog pins 4 and 5 of your Arduino Uno board to the SDA and SCL pins of the TMP102 sensor. Also, connect +5V and the ground as displayed in the following diagram. In this example, we are using the Arduino Uno board as the master and TMP102 as the slave peripheral, where the part address of TMP102 is <code class="literal">0x48</code> in hex:</p><div><img src="img/5938OS_04_09.jpg" alt="Arduino coding for the TMP102 temperature sensor"/></div><div><div><h3 class="title"><a id="note32"/>Note</h3><p>You can obtain the TMP102 sensor breakout board from SparkFun Electronics at <a class="ulink" href="https://www.sparkfun.com/products/11931">https://www.sparkfun.com/products/11931</a>.</p><p>The datasheet of this board can be obtained at <a class="ulink" href="https://www.sparkfun.com/datasheets/Sensors/Temperature/tmp102.pdf">https://www.sparkfun.com/datasheets/Sensors/Temperature/tmp102.pdf</a>.</p></div></div><p>Now, connect your Arduino board to your computer using a USB cable and create a new sketch in the Arduino IDE using the following code snippet. Once you have selected the<a id="id439" class="indexterm"/> appropriate serial port and type of board in the Arduino IDE, upload and run the code. If <a id="id440" class="indexterm"/>all the steps are performed as described, on execution, you will be able to see the temperature reading in <strong>Celsius</strong> and <strong>Fahrenheit</strong> in the <strong>Serial Monitor</strong> window:</p><div><pre class="programlisting">#include &lt;Wire.h&gt;
int partAddress = 0x48;

void setup(){
  Serial.begin(9600);
  Wire.begin();
}

void loop(){

  Wire.requestFrom(partAddress,2);
  byte MSB = Wire.read();
  byte LSB = Wire.read();

  int TemperatureData = ((MSB &lt;&lt; 8) | LSB) &gt;&gt; 4;

  float celsius = TemperatureData*0.0625;
  Serial.print("Celsius: ");
  Serial.println(celsius);

  float fahrenheit = (1.8 * celsius) + 32;
  Serial.print("Fahrenheit: ");
  Serial.println(fahrenheit);

  delay(500);
}</pre></div><p>In the preceding code snippet, the <code class="literal">Wire.requestFrom(partAddress,2)</code> function requests two bytes from the slave TMP102. The slave sends data bytes to the master, which get captured by the <code class="literal">Wire.read()</code> function and are stored as two different bits: <strong>most significant bit</strong> (<strong>MSB</strong>) and <strong>least significant bit</strong> (<strong>LSB</strong>). These bytes are converted into an integer <a id="id441" class="indexterm"/>value, which<a id="id442" class="indexterm"/> is then converted into the actual Celsius reading by multiplying the incremental fraction of the TMP102 sensor that is obtained from the datasheet. TMP102 is one of the easiest I2C sensors to interface with Arduino as the sensor values can be obtained via a simple I2C request method.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec43"/>Arduino coding for the BH1750 light sensor</h3></div></div></div><p>BH1750 is a digital light sensor that measures the amount of visible light in a given area. Although <a id="id443" class="indexterm"/>various DIY projects utilize simple photocells as a cheap alternative, the BH1750 sensor is <a id="id444" class="indexterm"/>known for higher resolution and accuracy in a wide range of applications. The ambient light, also called luminous flux or lux, is measured in unit lumen. The BH1750 sensor supports I2C communication with part address <code class="literal">0x23</code>, with <code class="literal">0x5C</code> as the secondary address if you are using multiple BH1750 sensors. The following is an image of a typical breakout board consisting of BH1750:</p><div><img src="img/5938OS_04_10.jpg" alt="Arduino coding for the BH1750 light sensor"/></div><p>Connect the SDA and SCL pins of the BH1750 breakout board to analog pins 4 and 5 of the Arduino Uno board, as displayed in the following circuit diagram. Also, complete the +5V and ground connections as displayed in the following diagram:</p><div><img src="img/5938OS_04_11.jpg" alt="Arduino coding for the BH1750 light sensor"/></div><p>In the previous example, we used functions from the <code class="literal">Wire</code> library to complete the I2C communication. Although <code class="literal">BH1750</code> is a simple and convenient I2C sensor, in the case of a sensor with multiple measurement capabilities, it is not convenient to code directly <a id="id445" class="indexterm"/>using the <code class="literal">Wire</code> library. In this situation, you can use sensor-specific Arduino libraries that are <a id="id446" class="indexterm"/>developed by the manufacturer or the open source community. For <code class="literal">BH1750</code>, we will demonstrate the use of such a library to assist the I2C coding. Before we can use this library, we will have to import it to the Arduino IDE. It is really important to know the process of importing libraries to your Arduino IDE as you will be repeating this process to install other libraries in future. Execute the following steps to import the <code class="literal">BH1750</code> library to your Arduino IDE:</p><div><ol class="orderedlist arabic"><li class="listitem">Download and extract <a class="link" href="ch07.html" title="Chapter 7. The Midterm Project – a Portable DIY Thermostat">Chapter 7</a>, <em>The Midterm Project – a Portable DIY Thermostat</em>, code examples in a folder.</li><li class="listitem">Open the Arduino IDE and navigate to <strong>Sketch</strong> | <strong>Import Library…</strong> | <strong>Add Library…</strong>.</li><li class="listitem">When you are asked for a directory, go to the <code class="literal">BH1750</code> folder in the downloaded file and click on <strong>Select</strong>.</li><li class="listitem">To check if your library is installed, navigate to <strong>Sketch</strong> | <strong>Import Library…</strong> and look for <strong>BH1750</strong> in the drop-down list.</li><li class="listitem">Finally, restart the Arduino IDE.<div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>If you are using an Arduino IDE with version 1.0.4 or an older version, you might not be able to find the <strong>Import Library…</strong> option from the menu. In this case, you need to follow the tutorial at <a class="ulink" href="http://arduino.cc/en/Guide/Libraries">http://arduino.cc/en/Guide/Libraries</a>.</p></div></div></li></ol></div><p>The <code class="literal">BH1750</code> library has a method to directly obtain ambient light values. Let's test this library using a built-in code example.</p><p>After restarting your Arduino IDE, navigate to <strong>File</strong> | <strong>Examples</strong> | <strong>BH1750</strong> and open the <strong>BH1750test</strong> Arduino sketch. This should open the following code snippet in the Arduino IDE. Set up an appropriate serial port and upload the code to your Arduino board. Once the code is executed, you will be able to check the luminous flux (<code class="literal">lux</code>) values using the serial monitor of the Arduino IDE. Make sure that the serial monitor is configured to 9600 baud:</p><div><pre class="programlisting">#include &lt;Wire.h&gt;
#include &lt;BH1750.h&gt;

BH1750 lightMeter;

void setup(){
  Serial.begin(9600);
  lightMeter.begin();
  Serial.println("Running...");
}

void loop() {
  uint16_t lux = lightMeter.readLightLevel();
  Serial.print("Light: ");
  Serial.print(lux);
  Serial.println(" lx");
  delay(1000);
}</pre></div><p>As you can <a id="id447" class="indexterm"/>see from the preceding code snippet, we have imported the <code class="literal">BH1750</code> library by including <code class="literal">BH1750.h</code> file with <code class="literal">Wire.h</code>. This library provides the <code class="literal">readLightLevel()</code> function, which <a id="id448" class="indexterm"/>will fetch the ambient light value from the sensor and provide it as an integer. As the Arduino code runs in a loop with a delay of 1000 milliseconds, the <code class="literal">lux</code> values will be fetched from the sensor and sent to the serial port every second. You can observe these values in the <strong>Serial Monitor</strong> window.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec73"/>PyMata for quick I2C prototyping</h2></div></div></div><p>We have been using <code class="literal">pyFirmata</code> as our default Python library to interface the Firmata protocol. The <code class="literal">pyFirmata</code> library is a very useful Python library to get started with the Firmata <a id="id449" class="indexterm"/>protocol, as it provides many simple and effective methods to define the Firmata ports and their roles. Due to these reasons, we extensively used <code class="literal">pyFirmata</code> for rapid prototyping in the previous section. Although <code class="literal">pyFirmata</code> supports analog, digital, PWM, and SERVO modes with easy-to-use methods, it provides limited support to the I2C protocol.</p><p>In this section, we are going to use a different Python Firmata library called <code class="literal">PyMata</code> to get familiar with Python-based prototyping of I2C sensors. The <code class="literal">PyMata</code> library supports regular Firmata methods and also provides full support for the I2C messaging protocol.</p><p>
<code class="literal">PyMata</code> can be easily installed using Setuptools, which we used in the previous chapters to install other Python libraries. We are assuming that you already have Setuptools and <code class="literal">pip</code> on your computer. Let's start performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To install <code class="literal">PyMata</code> on a Windows computer, execute the following command in the command prompt:<div><pre class="programlisting">
<strong>C:\&gt; easy_install.exe pymata</strong>
</pre></div></li><li class="listitem">If you are using Linux or Mac OS X, use the following command in the terminal to install the <code class="literal">PyMata</code> library:<div><pre class="programlisting">
<strong>$ sudo pip install pymata</strong>
</pre></div></li><li class="listitem">If everything is set up properly, this process will complete without any error. You can confirm <code class="literal">PyMata</code> by opening Python's interactive prompt and importing <code class="literal">PyMata</code>:<div><pre class="programlisting">
<strong>&gt;&gt;&gt; import PyMata</strong>
</pre></div></li><li class="listitem">If the<a id="id450" class="indexterm"/> execution of the preceding command fails, you need to check the installation process for any error. Resolve the error and repeat the installation process.</li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec44"/>Interfacing TMP102 using PyMata</h3></div></div></div><p>In order to <a id="id451" class="indexterm"/>utilize <code class="literal">PyMata</code> functionalities, you will need your Arduino board to be equipped with <a id="id452" class="indexterm"/>the standard firmata firmware just like the <code class="literal">pyFirmata</code> library. Before we proceed to explain the <code class="literal">PyMata</code> functions, let's first run the following code snippet. Connect your TMP102 temperature sensor as explained in the previous section. Using the Arduino IDE, navigate to <strong>File</strong> | <strong>Examples</strong> | <strong>Firmata</strong> and upload the standard Firmata sketch from there to your Arduino board. Now, create a Python executable file using the following code snippet. Change the value of port (<code class="literal">COM5</code>), if needed, to an appropriate port name as required by your operating system. Finally, run the program:</p><div><pre class="programlisting">import time
from PyMata.pymata import PyMata

#Initialize Arduino using port name
port = PyMata("COM5")

#Configure I2C pin
port.i2c_config(0, port.ANALOG, 4, 5)

# One shot read asking peripheral to send 2 bytes
port.i2c_read(0x48, 0, 2, port.I2C_READ)
# Wait for peripheral to send the data
time.sleep(3)

# Read from the peripheral
data = port.i2c_get_read_data(0x48)

# Obtain temperature from received data
TemperatureSum = (data[1] &lt;&lt; 8 | data[2]) &gt;&gt; 4

celsius = TemperatureSum * 0.0625
print celsius

fahrenheit = (1.8 * celsius) + 32
print fahrenheit

firmata.close()</pre></div><p>On the <a id="id453" class="indexterm"/>execution <a id="id454" class="indexterm"/>of the preceding code snippet, you will be able to see the temperature reading in Fahrenheit and Celsius. As you can see from the inline comments in the code, the first step to utilize Arduino using <code class="literal">PyMata</code> is to initialize the port using the <code class="literal">PyMata</code> constructor. <code class="literal">PyMata</code> supports the configuration of I2C pins via the <code class="literal">i2c_config()</code> function. <code class="literal">PyMata</code> also supports simultaneous reading and writing operations via the <code class="literal">i2c_read()</code> and <code class="literal">i2c_write()</code> functions.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec45"/>Interfacing BH1750 using PyMata</h3></div></div></div><p>In the case of BH1750, the previous <code class="literal">PyMata</code> code snippet can be utilized with minor modifications <a id="id455" class="indexterm"/>to obtain ambient light sensor data. As the first change, you want to replace the part address <a id="id456" class="indexterm"/>of TMP102 (<code class="literal">0x48</code>) with the one of BH1750 (<code class="literal">0x23</code>) in the following code snippet. You will also have to convert the raw values received from the sensor into the <code class="literal">lux</code> value using the given formula. After these modifications, run the following program from the terminal:</p><div><pre class="programlisting">import time
from PyMata.pymata import PyMata

port = PyMata("COM5")
port.i2c_config(0, port.ANALOG, 4, 5)

# Request BH1750 to send 2 bytes
port.i2c_read(0x23, 0, 2, port.I2C_READ)
# Wait for BH1750 to send the data
time.sleep(3)

# Read data from BH1750
data = port.i2c_get_read_data(0x23)

# Obtain lux values from received data
LuxSum = (data[1] &lt;&lt; 8 | data[2]) &gt;&gt; 4

lux = LuxSum/1.2
print str(lux) + ' lux'

firmata.close()</pre></div><p>On running the preceding code snippet, you will be able to see the ambient light sensor reading in <code class="literal">lux</code> at the terminal. This process can be used in a large number of I2C devices to read <a id="id457" class="indexterm"/>the registered information. In complex I2C devices, you will have to<a id="id458" class="indexterm"/> follow their datasheet or examples to organize the read and write commands of the I2C.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec74"/>Useful pySerial commands</h2></div></div></div><p>The standard Firmata protocol and Python's Firmata libraries are very useful for testing or <a id="id459" class="indexterm"/>quick <a id="id460" class="indexterm"/>prototyping of the I2C sensors. Although they have many advantages, Firmata-based <a id="id461" class="indexterm"/>projects face the following disadvantages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Delay in real-time execution</strong>: Firmata-based approaches require a series of serial communication messages to receive and send data, which adds additional delay and reduces the speed of execution.</li><li class="listitem" style="list-style-type: disc"><strong>Unwanted space</strong>: The Firmata protocol contains a large amount of additional code to support various other Arduino functions. In a well-defined project, you don't really need the complete set of functions.</li><li class="listitem" style="list-style-type: disc"><strong>Limited support</strong>: Although a version of Firmata includes I2C support, it is quite difficult to implement complex I2C functions without adding delay.</li></ul></div><p>In summary, you can always use Firmata-based approaches to quickly prototype your projects, but when you are working on production-level or advanced projects, you can use alternative methods. In these scenarios, you can use custom Arduino code that is supported by Python's serial library, <code class="literal">pySerial</code>, to enable communication for very specific functionalities. In this section, we are going to cover a few helpful <code class="literal">pySerial</code> methods that you can use if you have to utilize the library directly.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec46"/>Connecting with the serial port</h3></div></div></div><p>Once you have connected your Arduino to a USB port of your computer, you can open the port in <a id="id462" class="indexterm"/>your Python code using the <code class="literal">Serial</code> class as displayed in the following code example:</p><div><pre class="programlisting">import serial
port = serial.Serial('COM5',9600, timeout=1)</pre></div><p>In addition to port name and baud rate, you can also specify a number of serial port parameters such as <code class="literal">timeout</code>, <code class="literal">bytesize</code>, <code class="literal">parity</code>, <code class="literal">stopbits</code>, and so on using <code class="literal">Serial()</code>. It is necessary to initialize the serial port before executing any other command from the <code class="literal">pySerial</code> library.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec47"/>Reading a line from the port</h3></div></div></div><p>Once the serial port is<a id="id463" class="indexterm"/> opened, you can start reading the port using <code class="literal">readline()</code>. The <code class="literal">readline()</code> function requires the timeout to be specified while initializing the port, otherwise the code can terminate with an exception:</p><div><pre class="programlisting">line = port.readline()</pre></div><p>The <code class="literal">readline()</code> function will process each line from the port that is terminated with the end line character <code class="literal">\n</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec48"/>Flushing the port to avoid buffer overflow</h3></div></div></div><p>While working <a id="id464" class="indexterm"/>with <code class="literal">pySerial</code>, it is necessary to flush the input buffer to avoid buffer overflow and maintain real-time operations:</p><div><pre class="programlisting">port.flushInput()</pre></div><p>If the port's baud rate is high and the processing of the input data is slow, buffer overflow may occur, reducing the speed of execution and making the experience sluggish.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec49"/>Closing the port</h3></div></div></div><p>It is a good <a id="id465" class="indexterm"/>coding practice to close the serial port once the process is complete. This practice can eliminate the port-blocking problem once the Python code is terminated:</p><div><pre class="programlisting">port.close()</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Summary</h1></div></div></div><p>In this chapter, you learned important methods that are required to successfully interface the Arduino board with Python. You were also introduced to various prototyping code templates with practical applications. These prototyping templates helped us to learn new Python programing paradigms and Firmata methods. Later in the chapter, we dived further into prototyping by learning more about the different ways of establishing communication between sensors and the Arduino board. Although we covered a vast amount of programming concepts with these prototyping examples, the goal of the chapter was to make you familiar with the interfacing problems and provide quick recipes for your projects.</p><p>We are assuming that by now you are comfortable testing your sensors or project prototypes using Python and Arduino. It's time to start working towards creating your applications that have complex Python features such as user controls, charts, and plots. In the next chapter, we are going to develop custom graphical user interfaces (GUIs) for your Python-Arduino projects.</p></div></body></html>