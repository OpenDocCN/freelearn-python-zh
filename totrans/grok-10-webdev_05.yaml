- en: Chapter 5. Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。表单
- en: We have seen how easy it is to create a small application, such as the to-do
    list manager that we have developed over the past couple of chapters. We will
    now take a look at one of the many ways that Grok can help us develop more complex
    applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到创建一个小型应用程序是多么容易，比如我们在过去几章中开发的待办事项管理器。现在，我们将探讨Grok如何帮助我们开发更复杂应用程序的多种方法之一。
- en: Until now, we have been working with simple one-or two-field forms. When we
    changed our model in the previous chapter, we had to go back and edit the HTML
    for the forms as well. With a couple of fields this requires little work, but
    when we have complex models with perhaps a dozen fields or more, it would be great
    if we didn't have to modify two files whenever we make a change.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理简单的一到两个字段的表单。当我们上一章更改我们的模型时，我们必须回去编辑表单的HTML。对于几个字段来说，这需要很少的工作，但是当我们有可能有十几个字段或更多的复杂模型时，如果我们每次更改都不必修改两个文件，那就太好了。
- en: 'Fortunately, Grok has a mechanism for automating the creation and processing
    of forms. We''ll see how it works in this chapter, along with a few other form-related
    subjects:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Grok有一个自动化创建和处理表单的机制。我们将在本章中了解它是如何工作的，以及一些其他与表单相关的主题：
- en: What is an interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是接口
- en: What is a schema
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是模式
- en: How interfaces and schemas are used to generate forms automatically, using Grok's
    form components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Grok的表单组件自动生成表单，以及接口和模式是如何被使用的
- en: How to create, add, and edit forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建、添加和编辑表单
- en: How to filter fields and prevent them from appearing in a form
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何过滤字段并防止它们出现在表单中
- en: How to change form templates and presentation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何更改表单模板和展示
- en: A quick demonstration of automatic forms
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动表单的快速演示
- en: Let's start by showing how this works, before getting into the details. To do
    that, we'll add a project model to our application. A project can have any number
    of lists associated with it, so that related to-do lists can be grouped together.
    For now, let's consider the project model by itself. Add the following lines to
    the `app.py` file, just after the `Todo` application class definition. We'll worry
    later about how this fits into the application as a whole.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看它是如何工作的，然后再深入了解细节。为了做到这一点，我们将向我们的应用程序添加一个项目模型。一个项目可以与任何数量的列表相关联，这样相关的待办事项列表就可以一起分组。现在，让我们单独考虑项目模型。将以下行添加到`app.py`文件中，在`Todo`应用程序类定义之后。我们稍后再考虑它是如何融入整个应用程序的。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll also need to add a couple of imports at the top of the file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在文件顶部添加几个导入：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save the file, restart the server, and go to the URL [http://localhost:8080/todo/addproject](http://localhost:8080/todo/addproject).
    The result should be similar to the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，重新启动服务器，然后访问URL [http://localhost:8080/todo/addproject](http://localhost:8080/todo/addproject)。结果应该类似于以下截图：
- en: '![A quick demonstration of automatic forms](img/7481_05_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![自动表单的快速演示](img/7481_05_01.jpg)'
- en: OK, where did the HTML for the form come from? We know that `AddProject` is
    some sort of a view, because we used the `grok.context` class annotation to set
    its context and name. Also, the name of the class, but in lowercase, was used
    in the URL, like in previous view examples.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，表单的HTML是从哪里来的？我们知道`AddProject`是一种视图，因为我们使用了`grok.context`类注解来设置其上下文和名称。此外，类的名称（小写）被用于URL中，就像之前的视图示例一样。
- en: The important new thing is how the form fields were created and used. First,
    a class named `IProject` was defined. The interface defines the fields on the
    form, and the `grok.AutoFields` method assigns them to the `Form` view class.
    That's how the view knows which HTML form controls to generate when the form is
    rendered.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的新事物是如何创建和使用表单字段。首先，定义了一个名为`IProject`的类。该接口定义了表单上的字段，而`grok.AutoFields`方法将它们分配给`Form`视图类。这就是视图知道在表单渲染时生成哪些HTML表单控件的原因。
- en: 'We have three fields: `name, description`, and `kind`. Later in the code, the
    `grok.AutoFields` line takes this `IProject` class and turns these fields into
    form fields.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个字段：`name, description`和`kind`。在代码的后面，`grok.AutoFields`行将这个`IProject`类转换成表单字段。
- en: That's it. There's no need for a template or a `render` method. The `grok.Form`
    view takes care of generating the HTML required to present the form, taking the
    information from the value of the `form_fields` attribute that the `grok.AutoFields`
    call generated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。不需要模板或`render`方法。`grok.Form`视图负责生成显示表单所需的HTML，从`grok.AutoFields`调用生成的`form_fields`属性值中获取信息。
- en: Interfaces
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: The `I` in the class name stands for Interface. We imported the `zope.interface`
    package at the top of the file, and the `Interface` class that we have used as
    a base class for `IProject` comes from this package.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类名中的`I`代表接口。我们在文件顶部导入了`zope.interface`包，我们用作`IProject`基类的`Interface`类就来自这个包。
- en: Example of an interface
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口示例
- en: 'An **interface** is an object that is used to specify and describe the external
    behavior of objects. In a sense, the interface is like a contract. A class is
    said to implement an interface when it includes all of the methods and attributes
    defined in an interface class. Let''s see a simple example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**是一个用于指定和描述对象外部行为的对象。从某种意义上说，接口就像一份合同。当一个类包含接口类中定义的所有方法和属性时，我们说这个类实现了接口。让我们看看一个简单的例子：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are describing how cavemen behave. A caveman will have a weapon, and
    he can hunt, eat, and sleep. Notice that the `weapon` is an *attribute* something
    that belongs to the object, whereas `hunt, eat`, and `sleep` are *methods*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在描述穴居人的行为。穴居人将拥有武器，他可以狩猎、进食和睡眠。请注意，`武器`是一个*属性*，它是属于对象的某个东西，而`狩猎`、`进食`和`睡眠`是*方法*。
- en: 'Once the interface is defined, we can create classes that implement it. These
    classes are committed to include all of the attributes and methods of their interface
    class. Thus, if we say:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了接口，我们就可以创建实现它的类。这些类承诺包括它们接口类中的所有属性和方法。因此，如果我们说：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we are promising that the `Caveman` class will implement the methods and
    attributes described in the `ICaveman` interface:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们承诺`Caveman`类将实现`ICaveman`接口中描述的方法和属性：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that though our example class implements all of the interface methods,
    there is no enforcement of any kind made by the Python interpreter. We could define
    a class that does not include any of the methods or attributes defined, and it
    would still work.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们的示例类实现了所有接口方法，但Python解释器并没有做出任何类型的强制执行。我们可以定义一个不包含任何定义的方法或属性的类，它仍然可以工作。
- en: Interfaces in Grok
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grok中的接口
- en: 'In Grok, a model can implement an interface by using the `grok.implements`
    method. For example, if we decided to add a project model, it could implement
    the `IProject` interface as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grok中，一个模型可以通过使用`grok.implements`方法来实现接口。例如，如果我们决定添加一个项目模型，它可以如下实现`IProject`接口：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Due to their descriptive nature, interfaces can be used for documentation. They
    can also be used for enabling component architectures, but we'll see about that
    later on. What is of more interest to us right now is that they can be used for
    generating forms automatically.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的描述性，接口可以用作文档。它们还可以用于启用组件架构，但我们会稍后讨论这一点。对我们来说，现在更有兴趣的是，它们可以用于自动生成表单。
- en: Schemas
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: The way to define the form fields is to use the `zope.schema` package. This
    package includes many kinds of field definitions that can be used to populate
    a form.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 定义表单字段的方法是使用`zope.schema`包。这个包包括许多种字段定义，可以用来填充表单。
- en: Basically, a schema permits detailed descriptions of class attributes that are
    using fields. In terms of a form which is what is of interest to us here a schema
    represents the data that will be passed to the server when the user submits the
    form. Each field in the form corresponds to a field in the schema.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，模式允许详细描述使用字段的类属性。在形式方面，这是我们在这里感兴趣的内容，模式表示当用户提交表单时将传递给服务器的数据。表单中的每个字段对应于模式中的一个字段。
- en: 'Let''s take a closer look at the schema we defined in the last section:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们在上一节中定义的模式：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The schema that we are defining for `IProject` has three fields. There are several
    kinds of fields, which are listed in the following table. In our example, we have
    defined a `name` field, which will be a required field, and will have the label
    `Name` beside it. We also have a `kind` field, which is a list of options from
    which the user must pick one. Note that the default value for `required` is `True`,
    but it's usually best to specify it explicitly, to avoid confusion. You can see
    how the list of possible values is passed statically by using the `values` parameter.
    Finally, `description` is a text field, which means it will have multiple lines
    of text.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `IProject` 定义的方案有三个字段。有多种类型的字段，如下表所示。在我们的示例中，我们定义了一个 `name` 字段，它将是一个必填字段，并且旁边将有一个标签
    `Name`。我们还定义了一个 `kind` 字段，它是一个用户必须从中选择一个选项的选项列表。请注意，`required` 的默认值是 `True`，但通常最好明确指定它，以避免混淆。您可以通过使用
    `values` 参数来静态地传递可能的值列表。最后，`description` 是一个文本字段，这意味着它将有多行文本。
- en: Available schema attributes and field types
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用的模式属性和字段类型
- en: 'In addition to `title, values`, and `required`, each schema field can have
    a number of properties, as detailed in the following table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `title`、`values` 和 `required` 之外，每个模式字段还可以有多个属性，如下表详细说明：
- en: '| Attribute | Description |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `title` | A short summary or label. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `title` | 简短的摘要或标签。 |'
- en: '| `description` | A description of the field. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `description` | 字段的描述。 |'
- en: '| `required` | Indicates whether a field requires a value to exist. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `required` | 表示字段是否需要存在值。 |'
- en: '| `readonly` | If `True`, the field''s value cannot be changed. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `readonly` | 如果为 `True`，则字段的值不能被更改。 |'
- en: '| `default` | The field''s default value may be `None`, or a valid field value.
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `default` | 字段的默认值可以是 `None`，或者一个有效的字段值。 |'
- en: '| `missing_value` | If input for this field is missing, and that''s OK, then
    this is the value to use. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `missing_value` | 如果此字段的输入缺失，并且这是可以接受的，那么这就是要使用的值。 |'
- en: '| `order` | The `order` attribute can be used to determine the order in which
    fields in a schema are defined. If one field is created after another (in the
    same thread), its order will be greater. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `order` | `order` 属性可以用来确定模式中字段的定义顺序。如果一个字段在另一个字段之后（在同一线程中）创建，则其顺序将更大。 |'
- en: In addition to the field attributes described in the preceding table, some field
    types provide additional attributes. In the previous example, we saw that there
    are various field types, such as `Text, TextLine`, and `Choice`. There are several
    other field types available, as shown in the following table. We can create very
    sophisticated forms just by defining a schema in this way, and letting Grok generate
    them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面表格中描述的字段属性之外，一些字段类型还提供了额外的属性。在前面的示例中，我们看到了各种字段类型，如 `Text`、`TextLine` 和 `Choice`。还有其他几种字段类型可用，如下表所示。我们可以通过这种方式定义一个方案，并让
    Grok 生成它们，从而创建非常复杂的表单。
- en: '| Field type | Description | Parameters |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 字段类型 | 描述 | 参数 |'
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Bool` | Boolean field. |   |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Bool` | 布尔字段。 |   |'
- en: '| `Bytes` | Field containing a byte string (such as the python `str)`. The
    value might be constrained to be within length limits. |   |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Bytes` | 包含字节字符串的字段（如 python 的 `str`）。值可能被限制在长度范围内。 |   |'
- en: '| `ASCII` | Field containing a 7-bit ASCII string. No characters > DEL (chr(127))
    are allowed. The value might be constrained to be within length limits. |   |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `ASCII` | 包含 7 位 ASCII 字符串的字段。不允许任何大于 DEL（chr(127)）的字符。值可能被限制在长度范围内。 |  
    |'
- en: '| `BytesLine` | Field containing a byte string without new lines. |   |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `BytesLine` | 包含没有换行符的字节字符串的字段。 |   |'
- en: '| `ASCIILine` | Field containing a 7-bit ASCII string without new lines. |
      |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `ASCIILine` | 包含没有换行符的 7 位 ASCII 字符串的字段。 |   |'
- en: '| `Text` | Field containing a Unicode string. |   |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Text` | 包含 Unicode 字符串的字段。 |   |'
- en: '| `SourceText` | Field for the source text of an object. |   |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `SourceText` | 包含对象源文本的字段。 |   |'
- en: '| `TextLine` | Field containing a Unicode string without new lines. |   |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `TextLine` | 包含没有换行符的 Unicode 字段的字段。 |   |'
- en: '| `Password` | Field containing a Unicode string without new lines, which is
    set as the password. |   |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Password` | 包含没有换行符的 Unicode 字符串的字段，该字符串被设置为密码。 |   |'
- en: '| `Int` | Field containing an Integer value. |   |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | 包含整数值的字段。 |   |'
- en: '| `Float` | Field containing a Float. |   |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Float` | 包含浮点数的字段。 |   |'
- en: '| `Decimal` | Field containing a Decimal. |   |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `Decimal` | 包含十进制数的字段。 |   |'
- en: '| `DateTime` | Field containing a DateTime. |   |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `DateTime` | 包含日期时间的字段。 |   |'
- en: '| `Date` | Field containing a date. |   |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `Date` | 包含日期的字段。 |   |'
- en: '| `Timedelta` | Field containing a timedelta. |   |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `Timedelta` | 包含 timedelta 的字段。 |   |'
- en: '| `Time` | Field containing time. |   |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `时间` | 包含时间的字段。 |   |'
- en: '| `URI` | A field containing an absolute URI. |   |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `URI` | 包含绝对 URI 的字段。 |   |'
- en: '| `Id` | A field containing a unique identifier. A unique identifier is either
    an absolute URI or a dotted name. If it''s a dotted name, it should have a module
    or package name as a prefix. |   |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `Id` | 包含唯一标识符的字段。唯一标识符可以是绝对 URI 或点分名称。如果是点分名称，它应该有一个模块或包名称作为前缀。 |   |'
- en: '| Field type | Description | Parameters |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 字段类型 | 描述 | 参数 |'
- en: '| `Choice` | Field whose value is contained in a predefined set. | `values:`
    A list of text choices for the field.`vocabulary:` A Vocabulary object that will
    dynamically produce the choices.`source:` A different, newer way to produce dynamic
    choices.Note: only one of the three should be provided. More information about
    sources and vocabularies is provided later in this book. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `选择` | 值包含在预定义集合中的字段。 | `values:` 字段文本选择的列表。`vocabulary:` 将动态生成选择的词汇对象。`source:`
    生成动态选择的不同、较新的方式。注意：三者中只能提供其一。关于来源和词汇的更多信息将在本书后面提供。 |'
- en: '| `Tuple` | Field containing a value that implements the API of a conventional
    Python tuple. | `value_type:` Field value items must conform to the given type,
    expressed via a field.`Unique`. Specifies whether the members of the collection
    must be unique. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `元组` | 包含实现传统 Python 元组 API 的值的字段。 | `value_type:` 字段值项必须符合通过字段给出的类型，通过字段表达。`Unique`。指定集合的成员是否必须是唯一的。
    |'
- en: '| `List` | Field containing a value that implements the API of a conventional
    Python list. | `value_type:` Field value items must conform to the given type,
    expressed via a field.`Unique`. Specifies whether the members of the collection
    must be unique. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `列表` | 包含实现传统 Python 列表 API 的值的字段。 | `value_type:` 字段值项必须符合通过字段给出的类型，通过字段表达。`Unique`。指定集合的成员是否必须是唯一的。
    |'
- en: '| `Set` | Field containing a value that implements the API of a conventional
    Python standard library `sets.Set` or a Python 2.4+ set. | `value_type:` Field
    value items must conform to the given type, expressed via a field. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `集合` | 包含实现传统 Python 标准库 `sets.Set` 或 Python 2.4+ 集合 API 的值的字段。 | `value_type:`
    字段值项必须符合通过字段给出的类型，通过字段表达。 |'
- en: '| `FrozenSet` | Field containing a value that implements the API of a conventional
    Python 2.4+ frozenset. | `value_type:` Field value items must conform to the given
    type, expressed via a field. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `冻结集合` | 包含实现传统 Python 2.4+ frozenset API 的值的字段。 | `value_type:` 字段值项必须符合通过字段给出的类型，通过字段表达。
    |'
- en: '| `Object` | Field containing an object value. | `Schema:` The interface that
    defines the fields comprising the object. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `对象` | 包含对象值的字段。 | `Schema:` 定义对象所包含字段的接口。 |'
- en: '| `Dict` | Field containing a conventional dictionary. The `key_type` and `value_type`
    fields allow specification of restrictions for keys and values contained in the
    dictionary. | `key_type:` Field keys must conform to the given type, expressed
    via a field.`value_type:` Field value items must conform to the given type, expressed
    via a field. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `字典` | 包含传统字典的字段。`key_type` 和 `value_type` 字段允许指定字典中键和值的限制。 | `key_type:`
    字段键必须符合通过字段给出的类型，通过字段表达。`value_type:` 字段值项必须符合通过字段给出的类型，通过字段表达。 |'
- en: Form fields and widgets
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单字段和部件
- en: Schema fields are perfect for defining data structures, but when dealing with
    forms sometimes they are not enough. In fact, once you generate a form using a
    schema as a base, Grok turns the schema fields into form fields. A **form field**
    is like a schema field but has an extended set of methods and attributes. It also
    has a default associated widget that is responsible for the appearance of the
    field inside the form.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 模式字段非常适合定义数据结构，但在处理表单时有时它们并不足够。实际上，一旦使用模式作为基础生成表单，Grok 将模式字段转换为表单字段。**表单字段**类似于模式字段，但具有扩展的方法和属性集。它还有一个默认关联的部件，负责在表单内字段的外观。
- en: Rendering forms requires more than the fields and their types. A form field
    needs to have a user interface, and that is what a widget provides. A `Choice`
    field, for example, could be rendered as a`<select>` box on the form, but it could
    also use a collection of checkboxes, or perhaps radio buttons. Sometimes, a field
    may not need to be displayed on a form, or a writable field may need to be displayed
    as text instead of allowing users to set the field's value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染表单需要不仅仅是字段及其类型。表单字段需要一个用户界面，这正是小部件提供的。例如，`Choice` 字段可以渲染为表单上的 `<select>` 框，但它也可以使用一组复选框，或者可能是单选按钮。有时，字段可能不需要在表单上显示，或者可写字段可能需要以文本形式显示，而不是允许用户设置字段的值。
- en: Form components
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单组件
- en: 'Grok offers four different components that automatically generate forms. We
    have already worked with the first one of these, `grok.Form`. The other three
    are specializations of this one:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Grok 提供了四个不同的组件，可以自动生成表单。我们已经与这些组件中的第一个 `grok.Form` 一起工作过。其他三个是这个组件的专门化：
- en: '`grok.AddForm` is used to add new model instances.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grok.AddForm` 用于添加新的模型实例。'
- en: '`grok.EditForm` is used for editing an already existing instance.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grok.EditForm` 用于编辑已存在的实例。'
- en: '`grok.DisplayForm` simply displays the values of the fields.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grok.DisplayForm` 简单地显示字段的值。'
- en: A Grok form is itself a specialization of a `grok.View`, which means that it
    gets the same methods as those that are available to a view. It also means that
    a model does not actually need a view assignment if it already has a form. In
    fact, simple applications can get away by using a form as a view for their objects.
    Of course, there are times when a more complex view template is needed, or even
    when fields from multiple forms need to be shown in the same view. Grok can handle
    these cases as well, which we will see later on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Grok 表单本身是 `grok.View` 的专门化，这意味着它获得与视图相同的方法。这也意味着如果模型已经有了表单，实际上不需要为模型分配视图。实际上，简单的应用程序可以通过将表单用作对象的视图来避免这种情况。当然，有时需要更复杂的视图模板，或者甚至需要在同一视图中显示来自多个表单的字段。Grok
    也可以处理这些情况，我们将在稍后看到。
- en: Adding a project container at the root of the site
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在站点的根目录添加一个项目容器
- en: To get to know Grok's form components, let's properly integrate our project
    model into our to-do list application. We'll have to restructure the code a little
    bit, as currently the to-do list container is the root object of the application.
    We need to have a project container as the root object, and then add a to-do list
    container to it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Grok 的表单组件，让我们将我们的项目模型正确集成到待办事项列表应用程序中。我们需要对代码进行一点重构，因为目前待办事项列表容器是应用程序的根对象。我们需要有一个项目容器作为根对象，然后向其中添加一个待办事项列表容器。
- en: 'Luckily, we already structured the code properly in the last chapter, so we
    won''t need to make many changes now. To begin, let''s modify the top of `app.py`,
    immediately before the `TodoList` class definition, to look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们在上一章中已经正确地结构化了代码，所以我们现在不需要做很多修改。首先，让我们修改 `app.py` 的顶部，在 `TodoList` 类定义之前，使其看起来像这样：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we import `zope.interface` and `zope.schema`. Notice how we keep the
    `Todo` class as the root application class, but now it can contain projects instead
    of lists. We also omitted the `addProject` method, because the `grok.AddForm`
    instance is going to take care of that. Other than that, the `Todo` class is almost
    the same.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 `zope.interface` 和 `zope.schema`。注意我们如何保持 `Todo` 类作为根应用程序类，但现在它可以包含项目而不是列表。我们还省略了
    `addProject` 方法，因为 `grok.AddForm` 实例将负责这一点。除此之外，`Todo` 类几乎相同。
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We then have the interface definition for `IProject`, where we add the `title,
    kind, description`, and `next_id` fields. These were the fields that we previously
    added during the call to the `__init__` method at the time of product initialization.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有 `IProject` 的接口定义，其中我们添加了 `title, kind, description` 和 `next_id` 字段。这些是我们之前在产品初始化时调用
    `__init__` 方法时添加的字段。
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The key thing to notice in the `Project` class definition is that we use the
    `grok.implements` class declaration to see that this class will implement the
    schema that we have just defined.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Project` 类定义中需要注意的关键点是，我们使用 `grok.implements` 类声明来查看这个类将实现我们刚刚定义的模式。
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The actual form view is defined after that, by using `grok.AddForm` as a base
    class. We assign this view to the main `Todo` container by using the `grok.context`
    annotation. The name `index` is used for now, so that the default page for the
    application will be the 'add form' itself.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的表单视图是在之后定义的，通过使用`grok.AddForm`作为基类。我们使用`grok.context`注解将此视图分配给主`Todo`容器。目前使用`index`这个名字，这样应用程序的默认页面就是“添加表单”本身。
- en: Next, we create the form fields by calling the `grok.AutoFields` method. Notice
    that this time the argument to this method call is the `Project` class directly,
    rather than the interface. This is possible because the `Project` class was associated
    with the correct interface when we previously used `grok.implements`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用`grok.AutoFields`方法创建表单字段。请注意，这次这个方法调用的参数是`Project`类本身，而不是接口。这是因为我们在之前使用`grok.implements`时将`Project`类与正确的接口关联起来了。
- en: 'After we have assigned the fields, we set the `label` attribute of the form
    to the text: **To begin, add a new project**. This is the title that will be shown
    on the form.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分配字段之后，我们将表单的`label`属性设置为文本：“**开始，添加一个新项目**”。这是将在表单上显示的标题。
- en: In addition to this new code, all occurrences of `grok.context(Todo)` in the
    rest of the file need to be changed to `grok.context(Project)`, as the to-do lists
    and their views will now belong to a project and not to the main `Todo` application.
    For details, take a look at the source code of this book for Chapter 5.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这段新代码之外，文件中所有`grok.context(Todo)`的实例都需要更改为`grok.context(Project)`，因为待办事项列表及其视图现在属于一个项目，而不是主`Todo`应用程序。有关详细信息，请参阅本书第5章的源代码。
- en: Form actions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单操作
- en: 'If you carefully look at the screenshot shown in the *A quick demonstration
    of automatic forms* section, you will see that the form has no submit buttons.
    In Grok, every form can have one or more actions, and for each action the form
    will have a submit button. The Grok `action` decorator is used to mark the methods
    of the form class that will be used as actions. In this case, the `add` method
    is decorated with it and the value of the text parameter, in this case `Add project`,
    will be used as the text on the button. To change the text on the button, simply
    modify the string passed to the decorator:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看“自动表单快速演示”部分中显示的截图，你会看到表单没有提交按钮。在Grok中，每个表单都可以有一个或多个操作，并且对于每个操作，表单都会有一个提交按钮。Grok的`action`装饰器用于标记表单类中将用作操作的方法。在这种情况下，`add`方法被装饰了，并且文本参数的值，在这种情况下是`Add
    project`，将用作按钮上的文本。要更改按钮上的文本，只需修改传递给装饰器的字符串即可：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `add` method receives all of the filled form fields in the `data` parameter,
    and then creates a `Project` instance. Next, it sets the attributes of `project`
    to the values in the form by calling the `applyData` method of the form. Finally,
    it adds the new project to the `Todo` instance and redirects the user to the project
    page.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`方法接收`data`参数中所有填写好的表单字段，然后创建一个`Project`实例。接下来，它通过调用表单的`applyData`方法将`project`的属性设置为表单中的值。最后，它将新项目添加到`Todo`实例中，并将用户重定向到项目页面。'
- en: Trying out the application
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试应用程序
- en: When you try out the application, there are two things to notice. First, when
    the add project form is displayed, the `next_id` field, which is used to name
    the projects, is shown. We could even edit it if we like. Obviously, we don't
    want this behavior.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试应用程序时，有两点需要注意。首先，当添加项目表单显示时，用于命名项目的`next_id`字段会显示出来。如果我们愿意，甚至可以编辑它。显然，我们不希望这种行为。
- en: Second, once the project has been created and we get redirected to the project
    page, everything works as before, even though we didn't touch the templates. With
    the approach that we tried in Chapter 3, using hidden values and list indexes,
    we would have had to modify the `index.pt` template in lots of places. Now that
    we have a structure based on models, the views and methods that were registered
    for them don't need to change, even though the containment hierarchy is different.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，一旦项目创建完成并且我们被重定向到项目页面，一切都会像以前一样工作，即使我们没有触摸模板。如果我们使用第3章中尝试的方法，即使用隐藏值和列表索引，我们就需要在`index.pt`模板的许多地方进行修改。现在我们有一个基于模型的架构，为它们注册的视图和方法不需要改变，即使包含层次结构不同。
- en: Another important thing to notice is that the add project form has no design
    or styling at all. This is because the form building mechanism uses a common template,
    which we haven't styled yet.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要事情是，添加项目表单没有任何设计或样式。这是因为表单构建机制使用了一个通用的模板，我们还没有对其进行样式设计。
- en: '![Trying out the application](img/7481_05_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![尝试应用程序](img/7481_05_02.jpg)'
- en: Filtering fields
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤字段
- en: Remember that currently we have the `next_id` field of the project shown on
    the form. We don't want it there, so how do we remove it? Fortunately for us,
    the list of fields generated by the `grok.AutoFields` method can easily be filtered.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目前我们在表单上显示了项目的`next_id`字段。我们不想让它在那里，所以我们如何移除它？幸运的是，`grok.AutoFields`方法生成的字段列表可以很容易地进行过滤。
- en: 'We can either select precisely the fields we need, using the `select` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`select`方法精确选择我们需要的字段：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or we can omit specific fields by using the `omit` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过使用`omit`方法省略特定的字段：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In both cases, we pass the IDs of the fields as strings to the selected method.
    Now the `next_id` field is not there anymore, as you can see in the next screenshot.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们将字段的ID作为字符串传递给选择的方法。现在，`next_id`字段已经不再存在了，正如您可以在下一张屏幕截图中所看到的。
- en: Filtering fields can be useful not just for removing unwanted fields such as
    `next_id`. We can also have specialized forms for editing only a part of a schema,
    or for showing specific fields, depending on user information or input.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤字段不仅对于移除不想要的字段（如`next_id`）有用。我们还可以为编辑模式下的部分模式创建专门的表单，或者根据用户信息或输入显示特定字段。
- en: Using grok.EditForm
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用grok.EditForm
- en: The form that we just made is intended to add a new project to the application,
    but what if we need to edit an existing project? In this case, we need a form
    that knows how to get the existing values of all of the fields on the form, and
    display them when editing. Another difference is that the add project form was
    assigned to the main Todo application, but an edit form would use as a context
    the actual project that it would be modifying.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才制作的表单是为了向应用程序添加一个新项目，但如果我们需要编辑现有的项目怎么办？在这种情况下，我们需要一个知道如何获取表单上所有字段的现有值并在编辑时显示它们的表单。另一个区别是，添加项目表单被分配给了主Todo应用程序，但编辑表单将使用它将要修改的实际项目作为上下文。
- en: 'That''s why Grok has another kind of form component for editing. Using `grok.EditForm`
    is even easier than `grok.AddForm`. Here''s all the code that we need to add to
    our application in order to be able to edit projects:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么Grok有另一种形式的编辑组件。使用`grok.EditForm`比`grok.AddForm`更容易。以下是我们需要添加到我们的应用程序中的所有代码，以便能够编辑项目：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As mentioned earlier, the context for this form is the `Project` class, which
    we set by using the `grok.context` class annotation. We give this form the name
    `edit`, so that it will be possible to just append that word to a project URL
    to get its edit view. As we discussed in the previous section, it is a good idea
    to eliminate the display of the `next_id` field from the form, so we use the `omit`
    method to do that. Finally, we set a label for the form and we are then ready
    to test it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此表单的上下文是`Project`类，我们通过使用`grok.context`类注解来设置它。我们给这个表单命名为`edit`，这样就可以直接将这个词添加到项目URL后面，以获取其编辑视图。正如我们在上一节中讨论的，从表单中删除`next_id`字段的显示是个好主意，所以我们使用`omit`方法来实现这一点。最后，我们为表单设置了一个标签，然后就可以准备测试它了。
- en: 'Start the application. If you haven''t created a project already, please do
    so.Then, go to the URL: [http://localhost:8080/todo/0/edit](http://localhost:8080/todo/0/edit).
    Edit the project fields and then click on the **Apply** button. You should see
    a screen similar to the one shown in following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序。如果您还没有创建项目，请先创建一个。然后，转到URL：[http://localhost:8080/todo/0/edit](http://localhost:8080/todo/0/edit)。编辑项目字段，然后点击**应用**按钮。您应该会看到一个类似于以下屏幕截图的屏幕：
- en: '![Using grok.EditForm](img/7481_05_03.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用grok.EditForm](img/7481_05_03.jpg)'
- en: Notice how we didn't include a redirect after rendering the form, so that when
    we click on the **Apply** button we go back to the same form, but with a message
    telling us that the object was updated along with the date of modification. If
    we wanted, we could add an 'edit' action, by using the `action` decorator and
    a redirect, just like we did for the add form.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在渲染表单后没有包含重定向，所以当我们点击**应用**按钮时，我们会回到同一个表单，但会显示一条消息告诉我们对象已更新，以及修改的日期。如果我们想的话，我们可以通过使用`action`装饰器和重定向来添加一个`edit`操作，就像我们对添加表单所做的那样。
- en: Modifying individual form fields
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改单个表单字段
- en: Having the add and edit forms created automatically by Grok is neat, but there
    are cases where we will need to make small modifications in how a form is rendered.
    Grok allows us to modify specific field attributes easily to make that happen.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由Grok自动创建添加和编辑表单很方便，但在某些情况下，我们可能需要以某种方式对表单的渲染进行小修改。Grok允许我们轻松修改特定字段属性，以便实现这一点。
- en: Remember that each form field will be rendered by a widget, which could be thought
    of as views for specific fields. These views usually accept a number of parameters
    to allow the user to customize the appearance of the form in one way or another.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个表单字段都将由一个控件渲染，这可以被视为特定字段的视图。这些视图通常接受多个参数，以便用户以某种方式自定义表单的外观。
- en: Just before being rendered, Grok's form components always call a method named
    `setUpWidgets`, which we can override in order to make modifications to the fields
    and their attributes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染之前，Grok的表单组件总是调用一个名为`setUpWidgets`的方法，我们可以覆盖它来对字段及其属性进行修改。
- en: 'In the add and edit project forms, the title of the project, which is of type
    `TextLine`, has a widget that displays the`<input>` tag used to capture its value
    with a length of 20 characters. Many project names could be longer than that,
    so we want to extend the length to 50 characters. Also, the text area for the
    description is too long for a project summary, so we''ll cut it to five rows instead.
    Let''s use the `setUpWidgets` method for this. Add the following lines to both
    the `AddProjectForm` and `EditProjectForm` classes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加和编辑项目表单中，项目标题，其类型为`TextLine`，有一个显示用于捕获其值的`<input>`标签的控件，长度为20个字符。许多项目名称可能比这更长，因此我们希望将其长度扩展到50个字符。此外，描述文本区域对于项目摘要来说太长了，所以我们将它截断为五行。让我们使用`setUpWidgets`方法来完成这个任务。将以下行添加到`AddProjectForm`和`EditProjectForm`类中：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Take care to substitute `EditProjectForm` for `AddProjectForm` on the super
    call when adding the method to its appropriate class. The `setUpWidgets` method
    is fairly simple. We first call the super class to make sure that we get the correct
    properties in the form before trying to modify them. Next, we modify any properties
    that we want for the field. In this case, we access the `widgets` property to
    get at the widgets for the fields that we defined, and change the values that
    we want.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在将方法添加到适当类时，请注意在超类调用中用`EditProjectForm`替换`AddProjectForm`。`setUpWidgets`方法相当简单。我们首先调用超类，以确保在尝试修改之前我们得到表单中的正确属性。接下来，我们修改我们想要的任何属性。在这种情况下，我们访问`widgets`属性来获取我们定义的字段的控件，并更改我们想要的值。
- en: Another thing that requires explanation is the `ignore_request` parameter that
    is passed to the `setUpWidgets` method. If this is set to `False`, as we have
    defined it, then this means that any field values present in the `HTTP` request
    will be applied to the corresponding fields. A value of `True` means that no values
    should be changed during this call.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要解释的是传递给`setUpWidgets`方法的`ignore_request`参数。如果将其设置为`False`，正如我们定义的那样，这意味着任何存在于`HTTP`请求中的字段值都将应用于相应的字段。`True`的值表示在此调用期间不应更改任何值。
- en: Restart the application and you will see that the edit and add forms now present
    the widgets using the properties that we modified.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用程序，您将看到编辑和添加表单现在使用我们修改过的属性显示控件。
- en: Form validation
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单验证
- en: Now we have working forms for adding and editing projects. In fact, the forms
    can do more than we have shown so far. For example, if we go to the add form and
    try to submit it without filling in the required `title` field, we'll get the
    form back, instead of being redirected. No project will be created, and an error
    message will be visible on the screen, warning us that the field can't be empty.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了用于添加和编辑项目的有效表单。实际上，这些表单可以做得比我们迄今为止展示的更多。例如，如果我们转到添加表单并尝试提交它而不填写必需的`title`字段，我们将得到表单，而不是被重定向。不会创建任何项目，屏幕上将显示一个错误消息，警告我们该字段不能为空。
- en: 'This validation happens automatically, but we can also add our own constraints
    by using the `constraint` parameter, when defining a field in the schema. For
    example, suppose that we absolutely need to have more than two words in the title.
    We can do that very easily. Just add the following lines before the interface
    definition:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种验证是自动发生的，但我们可以通过在定义模式中的字段时使用`constraint`参数来添加我们自己的约束。例如，假设我们绝对需要在标题中有多于两个单词。我们可以非常容易地做到这一点。只需在接口定义之前添加以下行：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, modify the title field definition to look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改标题字段定义，使其看起来像这样：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We first defined a function that will receive the field value as a parameter,
    and must return `True` if the value is valid, or `False` otherwise. We then assign
    this function to the `constraint` parameter, when defining the field in the interface.
    This is all very simple, but it allows us to add validations for whatever conditions
    we need to meet in our form data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个函数，该函数将接收字段值作为参数，如果值有效则返回`True`，否则返回`False`。然后，在定义接口中的字段时，我们将此函数分配给`constraint`参数。这一切都非常简单，但它允许我们为表单数据中需要满足的任何条件添加验证。
- en: There are cases where a simple constraint is not enough to validate a field.
    For instance, imagine that what we need is that whenever the kind of the project
    is 'business', the description can't be empty. In this case, a constraint will
    not do, as whether or not the description field is valid depends on the value
    of another field.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，简单的约束不足以验证字段。例如，想象一下，我们需要的是每当项目的类型是“business”时，描述不能为空。在这种情况下，约束是不够的，因为描述字段是否有效取决于另一个字段的值。
- en: 'A constraint that involves more than one field is known as an **invariant**
    in Grok. To define one, the `@interface.invariant` decorator is used. For the
    hypothetical case described earlier, we can use the following definition, which
    we''ll add inside the `Interface` definition:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grok中，涉及多个字段的约束被称为**不变量**。要定义一个，使用`@interface.invariant`装饰器。对于之前描述的假设情况，我们可以使用以下定义，并将其添加到`Interface`定义中：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, when we try to add a project of kind ''business'', Grok will complain
    if the description is empty. Look at the next screenshot for reference:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试添加一个类型为“business”的项目时，如果描述为空，Grok将会抱怨。请参考下一张截图以获取参考信息：
- en: '![Form validation](img/7481_05_04.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![表单验证](img/7481_05_04.jpg)'
- en: Customizing the form template
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义表单模板
- en: Earlier, we commented on the fact that our new project forms have no styling
    or design applied, and therefore they look markedly different from the rest of
    our application. It's time to change that.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们评论了我们的新项目表单没有应用样式或设计，因此它们与我们的应用程序的其他部分明显不同。现在是时候改变这一点了。
- en: 'The disadvantage of using automatic form generation is that the default template
    must be fairly generic to be useful in multiple applications. However, Grok allows
    us to set a custom template for editing the form. All we need to do is set the
    `template` attribute in the form:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动表单生成的缺点是默认模板必须相当通用，才能在多个应用程序中发挥作用。然而，Grok允许我们为编辑表单设置自定义模板。我们所需做的只是设置表单中的`template`属性：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of course, for this to work we also have to provide the named template inside
    our application directory (not inside `app_templates)`. For now, let's just add
    a stylesheet and a class to the generic edit template that comes with Grok. There
    is nothing special here, so we will just take the default edit form template and
    add the same stylesheet that we defined previously. Please look at the source
    code of this book, if you want to see the rest of the template.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了让这起作用，我们还需要在我们的应用程序目录内（而不是在`app_templates`内）提供命名模板。现在，让我们先为Grok附带的一般编辑模板添加一个样式表和类。这里没有什么特别之处，所以我们只需采用默认的编辑表单模板，并添加之前定义的相同样式表。如果您想查看模板的其余部分，请查看本书的源代码。
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That's all that's needed in order to have our custom template for editing the
    form. Take a look at the next screenshot to see how it looks. Of course, we would
    have to further modify it to get it to look just like we want. We could even leave
    only the fields that we wanted, placed in an irregular arrangement, but the reason
    that we used the original template and modified it just a little is so that you
    can look at it and be careful with the sections where the validation messages
    are shown and the actions are generated. We'll have more to say about this in
    future chapters.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有我们自定义的表单编辑模板，所需的就是这些。请查看下一张截图以了解其外观。当然，我们可能需要进一步修改它，以使其看起来正好符合我们的要求。我们甚至可以只留下我们想要的字段，以不规则的方式排列，但使用原始模板并稍作修改的原因是，您可以查看它，并小心处理显示验证消息和生成操作的章节。我们将在未来的章节中对此有更多讨论。
- en: '![Customizing the form template](img/7481_05_05.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![自定义表单模板](img/7481_05_05.jpg)'
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen how to automatically generate forms by using schemas, and how it's
    possible to customize their rendering. In addition, we learned a little bit about
    some Zope Framework libraries, such as `zope.schema` and `zope.interface`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何使用模式自动生成表单，以及如何自定义它们的渲染方式。此外，我们还了解了一些 Zope 框架库，例如 `zope.schema` 和 `zope.interface`。
