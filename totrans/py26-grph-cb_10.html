<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. GUI Construction: Part 1</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Widget configuration</li><li class="listitem" style="list-style-type: disc">Button focus</li><li class="listitem" style="list-style-type: disc">The simplest push button with validation</li><li class="listitem" style="list-style-type: disc">The data entry box</li><li class="listitem" style="list-style-type: disc">Colored button causing message pop-ups</li><li class="listitem" style="list-style-type: disc">Complex interaction between buttons</li><li class="listitem" style="list-style-type: disc">Images on buttons and widget packing geometry</li><li class="listitem" style="list-style-type: disc">The grid geometry manager and button arrays</li><li class="listitem" style="list-style-type: disc">Drop-down menus to select from a list</li><li class="listitem" style="list-style-type: disc">Listbox</li><li class="listitem" style="list-style-type: disc">Text in a window</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec01"/>Introduction</h1></div></div></div><p>In this chapter, we provide recipes for the components that are used to create user interfaces of the graphical kind. These are known as<strong> GUI</strong> or<strong> Graphic User Interface</strong>. The commonly-used term for GUI components is<strong> Widget</strong>. The word Widget has no particular meaning other than "general sort of gadget". If you used the example from<a class="link" href="ch04.html" title="Chapter 4. Animation Principles"> Chapter 4</a>,<em> Animation Principles</em> on a color-mixing palette, then you would have used the slider or scale widget which will be explained in this chapter. We will also demonstrate that it is not too difficult to create our own widgets.<a id="id263" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec02"/>Widget configuration a label</h1></div></div></div><p>We see here how to change the properties (attributes) of most widgets using its<code class="literal"> configuration()</code> method.<a id="id264" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec01"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way.<a id="id265" class="indexterm"/>
</p><div><pre class="programlisting"># widget_configuration_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk( )
labelfont = ('times', 30, 'bold')
widget = Label(root, text='Purple and red mess with your focus')
widget.config(bg='red', fg='purple')
widget.config(font=labelfont)
widget.config(bd=6)
widget.config(relief=RAISED)
widget.config(height=2, width=40) # lines high, characters wide
widget.pack(expand=YES, fill=BOTH)
root.mainloop( )
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec02"/>How it works...</h2></div></div></div><p>All widgets have default values such as a gray background, and 12 point font size. Once the code for the creation of a widget has been executed the widget appears on the screen with all its assigned properties. Further down the code, as the program is being executed, the properties of the widget can be changed using the<code class="literal"> widget.config(attribute=new value)</code> method. The result is shown in the following screenshot:<a id="id266" class="indexterm"/>
</p><div><img src="img/3845_10_1.jpg" height="75" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec03"/>There's more...</h2></div></div></div><p>Choice is good because it allows us to make our GUIs look good. The downside of this choice is that it allows us to make poor choices. But as the adage goes: poor choices made with intelligence lead to good choices.<a id="id267" class="indexterm"/>
</p><p>If we run this program we will see that the combination of colors made is about the worst that can be made they interfere with the eye's focusing mechanics because the two colors have different wavelengths and follow slightly different paths on their way to the retina.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec03"/>Button focus</h1></div></div></div><p>Here we demonstrate the concept of focus, which is easier to show than describe. When there are a group of widgets inside a window, only one widget can react to an event like the click of the mouse button. In this example, the button underneath the mouse cursor has focus and therefore is the one that will respond to a click of the mouse. As the cursor moves over another button, then<em> that button has focus</em>. In this example, the button that has focus changes its color, on a Linux-operating system. On MS Windows, the buttons do not change color but the mouse cursor changes.<a id="id268" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec04"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way.<a id="id269" class="indexterm"/>
</p><div><pre class="programlisting">#button_focus_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
butn_widget_1 = Button(text='First, RAISED', padx=10, pady=10)
butn_widget_1.config(cursor='gumby')
butn_widget_1.config(bd=8, relief=RAISED)
butn_widget_1.config(bg='dark green', fg='white')
butn_widget_1.config(font=('helvetica', 20, 'underline italic'))
butn_widget_1.grid(row=1, column = 1)
butn_widget_2 = Button(text='Second, FLAT', padx=10, pady=10)
butn_widget_2.config(cursor='circle')
butn_widget_2.config(bd=8, relief=FLAT)
butn_widget_2.grid(row=1, column = 2)
butn_widget_3 = Button(text='Third, SUNKEN', padx=10, pady=10)
butn_widget_3.config(cursor='heart')
butn_widget_3.config(bd=8, relief=SUNKEN)
butn_widget_3.config(bg='dark blue', fg='white')
butn_widget_3.config(font=('helvetica', 30, 'underline italic'))
butn_widget_3.grid(row=1, column = 3)
butn_widget_4 = Button(text='Fourth, GROOVE', padx=10, pady=10)
butn_widget_4.config(cursor='spider')
butn_widget_4.config(bd=8, relief=GROOVE)
butn_widget_4.config(bg='red', fg='white')
butn_widget_4.config(font=('helvetica', 20, 'bold'))
butn_widget_4.grid(row=1, column = 4)
butn_widget_5 = Button(text='Fifth RIDGE', padx=10, pady=10)
butn_widget_5.config(cursor='pencil')
butn_widget_5.config(bd=8, relief=RIDGE)
butn_widget_5.config(bg='purple', fg='white')
butn_widget_5.grid(row=1, column = 5)
root.mainloop( )
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec05"/>How it works...</h2></div></div></div><p>When we run the preceding code under Linux, we will see that the color of each button change as it acquires focus. The button that has focus is the only one of the group that will react to a left mouse click. Under MS Windows 7, this change of color with focus does not work. Nevertheless, the logic of focus behavior and reaction to mouse events is unaffected.<a id="id270" class="indexterm"/>
</p><p>We have also taken the opportunity to look at the different button border styles available.</p><div><img src="img/3845_10_2.jpg" height="54" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec06"/>There's more...</h2></div></div></div><p>One thing to note in this example is that the size of a button is determined by the font size and amount of text placed on the button.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec04"/>The simplest push button with validation</h1></div></div></div><p>We now home in on the simplest example of event processing by means of a<code class="literal"> callback()</code> function.<a id="id271" class="indexterm"/>
</p><p>The validation referred to previously is any kind of reaction that provides confirmation that our code did what we wanted it to do. When you are developing code experimentally you need some kind of validation at the earliest stage in order build up insight.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec07"/>How to do it...</h2></div></div></div><p>Copy, save and execute. The result is shown as follows:</p><div><img src="img/3845_10_3.jpg" height="35" alt="How to do it..."/></div><div><pre class="programlisting"># button_1.py
push buttonwith validation#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
def callback_1(): # The event processor function
print "Someone pushed a button"
# The instantiation (i.e. creation of a specific instance or # realization) of a button.
button_1= Button(root, command=callback_1).grid(row=1, column=0)
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec08"/>How it works...</h2></div></div></div><p>When you push the little button with your mouse pointer, a message will appear on your terminal. The appearance of the message is the vital validation action your program produces.</p><p>This simple example demonstrates the fundamental design of all programs that react to user input. Then all you have to do is the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Wait for some external event such as the click of a mouse or the tap of a key on the keyboard.</li><li class="listitem" style="list-style-type: disc">If and when the external event occurs, we must have an<code class="literal"> event handler</code> function inside our program that specifies what actions must occur. These are often referred to as<code class="literal"> callback</code> functions.</li></ul></div><p>Inside the code, that makes an instance of any widget designed to accept user input, there must always be an option-specifier like<code class="literal"> command=callback_1</code> that points to the name of your event-processing function named<code class="literal"> callback_1</code> that will do all the things we want it to do when the event occurs. We do not have to use the actual word<code class="literal"> callback_1</code> - we could have chosen any word we liked. In this case, the event is the push of a button. All we ask it to do inside the<code class="literal"> callback()</code> function is to print a message. However, the list of resulting actions initiated by our<code class="literal"> callback()</code> function can be as long as we like.<a id="id273" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec09"/>There's more...</h2></div></div></div><p>Programming literature often uses the word instantiation, especially with reference to objects in the object-oriented programming context. The word instantiation means to transform some object, which previously only existed as a semi-abstract description, into an actual block of code with a real namespace for its variables that interact with the data and commands inside your program. Python with Tkinter has a pre-defined object called a button. In our preceding program, we instantiate a button named<code class="literal"> button_1</code> into existence by the command:<a id="id274" class="indexterm"/>
</p><p>
<code class="literal">button_1= Button(root, command=callback_1).grid(row=1, column=0)</code>
</p><p>The description to the right of the equals sign is the pre-existing abstract description taken from a long list of objects inside the Tkinter library. The name<code class="literal"> button_1</code> on the left is the name of the instance that will have all of the actual properties that were previously just words in a library. This is like having a file with engineering drawings and assembly instructions for a sports car (the abstract description) and then getting some engineering workshop to actually manufacture an instance of the gleaming steel and chrome speedster. The file with drawings and manufacturing instructions is the equivalent of the object definition in our Python code. The thing with a metallic blue paint job, which you will sit in and drive with the wind in your hair, is an instance of the object.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec01"/>Buttons behave differently on Windows</h3></div></div></div><p>The button in this recipe behaves slightly differently in MS Windows compared to Linux. Windows displays the normal minimize, maximize, close symbols on the top right of the frame containing the button. We close the application by clicking on the top right "X" symbol. In Linux, there is a round button in the top of the frame. When we click this button, a menu opens up with a close command that can end the program.<a id="id275" class="indexterm"/>
</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec05"/>A data entry box</h1></div></div></div><p>We make a GUI that provides a data entry box and a button for handling whatever text is typed into the box.<a id="id276" class="indexterm"/>
</p><p>The<strong> Entry</strong> widget is a standard Tkinter widget used to enter or display a single line of text.<a id="id277" class="indexterm"/>
</p><p>The button<code class="literal"> callback()</code> function (event handler) assigns the contents of the textbox to be the value of a variable. All these actions are verified by displaying the value of this variable.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec10"/>How to do it...</h2></div></div></div><p>Execute the program shown in the normal way.</p><div><pre class="programlisting"># entry_box_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
from Dialog import Dialog
root = Tk()
root.title("Data Entry Box")
enter_data_1 = Entry(root, bg = "pale green") # Creates a text entry
# field
enter_data_1.grid(row=1, column=1)
enter_data_1.insert(0, "enter text here") # Place text into the box.
def callback_origin():
# Push button event handler.
data_inp_1 = enter_data_1.get() # Fetch text from the box.
# Create a label and write the value of 'data_inp_1' to it.
# ie. Validate by displaying the newly acquired data as a label on
# the frame.
label_2_far_right = Label(root, text=data_inp_1)
label_2_far_right.grid(row=1, column=3)
# This is button that triggers data transfer from entry box to named
# variable 'data_inp_1'.
but1= Button(root, text="press to \
transfer",command=callback_origin).grid(row=5, column=0)
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec11"/>How it works...</h2></div></div></div><div><img src="img/3845_10_4.jpg" height="52" alt="How it works..."/></div><p>A text entry box on its own is not much use. It is like a post box text can be sent to it or picked up from it.</p><p>This program does the following things:<a id="id278" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It sets up a parent frame or window named<code class="literal"> root</code> inside of which is a labeled button and a textbox with an initial message<code class="literal"> enter text here</code> displayed.</li><li class="listitem" style="list-style-type: disc">We can click on the entry box and replace the initial text with new text.</li><li class="listitem" style="list-style-type: disc">If we click on the button it takes the contents of the box, and assigns them as the value of a variable called<code class="literal"> data_inp_1</code>.</li><li class="listitem" style="list-style-type: disc">It displays the value of<code class="literal"> data_inp_1</code> as a label to the right of the textbox.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec12"/>There's more...</h2></div></div></div><p>The key to getting buttons to perform useful functions lies in the code you place in the<code class="literal"> callback()</code> function that gets executed when the button is pushed.</p><p>Programming buttons can get very complicated and we can easily get confounded by our own ingenuity. The rule is to keep things simple.</p><p>You can locate more than one button in the same position inside a frame, with the button that is visible being the last one our Python program placed there.</p><p>Later on, we can make sets of buttons that appear 'illuminated' when on and 'dark' when off. It is fun to do these things but be wary of getting too clever. A very brilliant and wise programmer said the following:</p><p>—Brian W. Kernighan, co-author of the C programming language.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec02"/>Did we keep things simple?</h3></div></div></div><p>In the sixth recipe of this chapter called "complex interaction between buttons", we ignore the wise advice just to explore what may be possible. We do this kind of thing for our own edification and fun but should shun it for any kind of professional work.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec03"/>Single-line versus multi-line entry</h3></div></div></div><p>The widget used here is called the<strong> Entry</strong> widget and is for single-line input only. There is another one called the<strong> Text</strong> widget that is designed for multi-line input. There is an example of how to use this widget later in this chapter.<a id="id279" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec04"/>The Clever Geometry Manager</h3></div></div></div><p>Notice how the size of the parent window changes to accommodate the size of the label text during the execution of the program. This is a very intelligent program design.<a id="id280" class="indexterm"/>
</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec06"/>Colored button causing a message pop-up</h1></div></div></div><p>Buttons can be given different visual properties and complex behaviors. Here we create a blue raised button that changes appearance when clicked with a mouse. A message box widget is made to pop up when the button is pushed.<a id="id281" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec13"/>How to do it...</h2></div></div></div><p>Execute the program shown in the normal way.</p><div><pre class="programlisting"># button_message_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import tkMessageBox
root = Tk()
root.title("Message Button")
def callback_button():
tkMessageBox.showinfo( "Certificate of Button Pushery", \ "Are glowing pixels a reality?")
message_button = Button(root,
bd=6, # border width
relief = RAISED, # raised appearance # to button border
bg = "blue", # normal background
# color
fg = "green", # normal foreground
# (text) color
font = "Arial 20 bold",
text ="Push me", # text on button
activebackground = "red", # background when
# button is clicked
activeforeground = "yellow", # text color when
# clicked
command = callback_button) # name of event
# handler
message_button.grid(row=0, column=0)
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec14"/>How it works...</h2></div></div></div><div><img src="img/3845_10_5.jpg" height="58" alt="How it works..."/></div><div><img src="img/3845_10_6.jpg" height="78" alt="How it works..."/></div><p>What we see now is that buttons are highly customizable, as are many Tkinter widgets. This recipe illustrates another term that you are bound to come across as a GUI programmer and that is the word focus.<a id="id282" class="indexterm"/>
</p><p>Focus is the idea that when there are several widgets on a graphic container only one of them can be given attention or listened to at a time. Each button is programmed to respond to the click of a mouse but when the mouse is clicked, only one button should respond. The widget responding is the one that the program focuses on. In our example, you actually see the focus being given to the button when the mouse pointer moves across it the focus is used to change the button's coloring in a Linux operating system. It is like the chairman offering the floor to someone wanting to address a meeting group. The aspirant talker can only do so when the chairman offers them the floor (gives them focus). When this happens, everyone else is expected to be quiet and listen courteously.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec07"/>Complex interaction between buttons</h1></div></div></div><p>In this recipe, we show how button actions can be made as complex as we choose by getting a set of three buttons that modify each other.<a id="id283" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec15"/>How to do it...</h2></div></div></div><p>Execute the program shown in the normal way.</p><div><pre class="programlisting"># button_interaction_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("now what?")
def callback_button_1():
message_button_1.flash()
message_button_2["bg"]= "grey"
message_button_2.flash()
message_button_3.flash()
message_button_3["bg"]= "pink"
message_button_1["relief"] = SUNKEN
message_button_1["text"]= "What have you done?"
def callback_button_2():
message_button_2["bg"]= "green"
message_button_3["bg"]= "cyan"
message_button_1["relief"] = RAISED
message_button_1["text"]= "Beware"
def callback_button_3():
message_button_1.destroy()
message_button_2.destroy()
message_button_3.destroy()
root.destroy()
message_button_1 = Button(root,
bd=6,
relief = RAISED, # Raised # appearance.
bg = "blue" # Normal (without
# focus) # background
# color
fg = "green", # Normal (without
# focus) # foreground
# (text) color
font = "Arial 20 bold",
text ="Push me first", # Text on button
activebackground = "red", # Background when
# button has # focus
activeforeground = "yellow", #Text with focus
command = callback_button_1) # event handler
message_button_1.grid(row=0, column=0)
message_button_2 = Button(root,
bd=6,
relief = SUNKEN,
bg = "green",
fg = "blue",
font = "Arial 20 bold",
text ="Now Push me",
activebackground = "purple",
activeforeground = "yellow",
command = callback_button_2)
message_button_2.grid(row=1, column=0)
set of three buttonsmodifying, one anothermessage_button_3 = Button(root,
bd=6,
relief = SUNKEN,
bg = "grey",
fg = "blue",
font = "Arial 20 bold",
text ="kill everything",
activebackground = "purple",
activeforeground = "yellow",
command = callback_button_3)
message_button_3.grid(row=2, column=0)
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec16"/>How it works...</h2></div></div></div><div><img src="img/3845_10_7.jpg" width="111" alt="How it works..."/></div><div><img src="img/3845_10_8.jpg" width="157" alt="How it works..."/></div><p>All the action happens in the event handler (callback()) functions. Every instantiated object, like the buttons used here, has a collection of attributes like color, text, and appearance that can be modified by specifications like:<code class="literal"> message_button_2["bg"]= "grey"</code>
<a id="id285" class="indexterm"/>
</p><p>So what happens is that when button 1 is clicked, button 2 has its background color changed from green to grey.</p><p>While it is fun to create very complicated interactive behavior with button actions, it rapidly becomes nearly impossible to keep track of what behavior you want. The more complexity you add, the more unintended behaviors appear. The best advice then is to try to keep things simple.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec08"/>Images on buttons and button packing</h1></div></div></div><p>By placing GIF format images onto buttons, we can create any appearance desirable. The images can convey information about the function of the button. Image size has to be taken into account and the geometry manager has to be used thoughtfully.<a id="id286" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec17"/>How to do it...</h2></div></div></div><p>Execute the program shown in exactly the same way as usual.<a id="id287" class="indexterm"/>
</p><div><pre class="programlisting"># image_button_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Image Sized Buttons")
go_image = PhotoImage(file = "/constr/pics1/go_on.gif")
fireman_image = PhotoImage(file = "/constr/pics1/fireman_1.gif")
winged_lion_image = PhotoImage(file = "/constr/pics1/winged_lion.gif")
earth_image = PhotoImage(file = "/constr/pics1/earth.gif")
def callback_go():
print "Go has been pushed to no purpose"
def callback_fireman():
print "A little plastic fireman is wanted"
def callback_lion():
print "A winged lion rampant would look cool on a t-shirt"
def callback_earth():
print "Think of the children (and therefore also of their parents)"
btn_go= Button(root, image = go_image, \
command=callback_go ).grid(row=0, column=0)
btn_firmean= Button(root, image = fireman_image, \
command=callback_fireman).grid(row=0, column=1)
btn_lion= Button(root, image = winged_lion_image, \
command=callback_lion ).grid(row=0, column=2)
btn_earth= Button(root, image = earth_image, \
command=callback_earth ).grid(row=0, column=3)
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec18"/>How it works...</h2></div></div></div><div><img src="img/3845_10_9.jpg" height="146" alt="How it works..."/></div><p>The thing to notice here is that the grid geometry manager packs all the widgets together as neatly as it can regardless of widget size.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec19"/>There's more...</h2></div></div></div><p>One of the wonderful thoughts behind the design of Python modules is that their actions should be kind and tolerant. This means that if attributes are coded with unsuitable values then defaults will be selected by the interpreter as at least some choice that is likely to work. This is an enormous boon to coders. If you ever come across one of the inner circle of Python developers they deserve an affectionate hug for this reason alone.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec09"/>Grid Geometry Manager and button arrays</h1></div></div></div><p>By placing GIF format images onto buttons, we can create any desired appearance. Image size has to be taken into account and the geometry manager has to be used thoughtfully.<a id="id288" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec20"/>How to do it...</h2></div></div></div><p>Execute the program shown in the normal way.</p><div><pre class="programlisting"># button_array_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Button Array")
usb = PhotoImage(file = "/constr/pics1/Usbkey_D.gif")
galaxy = PhotoImage(file = "/constr/pics1/galaxy_D.gif")
alert = PhotoImage(file = "/constr/pics1/alert_D.gif")
earth = PhotoImage(file = "/constr/pics1/earth_D.gif")
eye = PhotoImage(file = "/constr/pics1/eye_D.gif")
rnd_2 = PhotoImage(file = "/constr/pics1/random_2_D.gif")
rnd_3 = PhotoImage(file = "/constr/pics1/random_3_D.gif")
smile = PhotoImage(file = "/constr/pics1/smile_D.gif")
vine = PhotoImage(file = "/constr/pics1/vine_D.gif")
blueye = PhotoImage(file = "/constr/pics1/blueeye_D.gif")
winglion = PhotoImage(file = "/constr/pics1/winglion_D.gif")
def cb_usb(): print "usb"
def cb_galaxy(): print "galaxy"
def cb_alert(): print "alert"
def cb_earth(): print "earth"
def cb_eye(): print "eye"
def cb_rnd_2(): print "random_2"
def cb_rnd_3(): print "random_3"
def cb_smile(): print "smile"
GIF format imagesplacing, on button arraysdef cb_vine(): print "vine"
def cb_blueeye(): print "blueeye"
def cb_winglion(): print "winglion"
butn_usb = Button(root, image = usb, command=cb_usb \
).grid(row=0, column=0)
butn_galaxy = Button(root, image = galaxy, command=cb_galaxy).grid(row=1, column=0)
butn_alert = Button(root, image = alert, command=cb_alert \
).grid(row=2, column=0)
butn_earth = Button(root, image = earth, command=cb_earth \
).grid(row=3, column=0)
butn_eye = Button(root, image = eye, command=cb_eye \
).grid(row=0, column=1, rowspan=2)
butn_rnd_2 = Button(root, image = rnd_2, command=cb_rnd_2 \
).grid(row=2, column=1)
butn_rnd_3 = Button(root, image = rnd_3, command=cb_rnd_3 \
).grid(row=3, column=1)
butn_smile = Button(root, image = smile, command=cb_smile \
).grid(row=0, column=2, columnspan=2)
butn_vine = Button(root, image = vine, command=cb_vine \
).grid(row=1, column=2, rowspan=2, columnspan=2)
butn_blueye = Button(root, image = blueye, \
command=cb_blueeye).grid(row=3, column=2)
butn_winglion= Button(root, image = winglion, command=cb_winglion \
).grid(row=3, column=3)
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec21"/>How it works...</h2></div></div></div><div><img src="img/3845_10_10.jpg" width="139" alt="How it works..."/></div><p>There are two geometry managers in Tkinter. In this book, we have used the Grid Geometry Manager exclusively up until now because it keeps the level of complexity down and also because it is easy to use and gives you direct control of your interface layout. The other layout geometry manager is called<strong> pack</strong> and is addressed in the next chapter.<a id="id290" class="indexterm"/>
</p><p>The rules are simple. Our parent window or frame is divided into rows and columns.<code class="literal"> Row=0</code> is the first row along the top and<code class="literal"> column=0</code> is the first column down the left-hand side.<code class="literal"> columnspan=2</code> means that the widget using this attribute sits in the center of two adjacent columns. Note that the button with the vine icon on it sits in the center of four grid regions because it has both<code class="literal"> columnspan=2</code> and<code class="literal"> rowspan=2</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec22"/>There's more...</h2></div></div></div><p>By changing the grid attributes in this example, you can help yourself acquire an insight to the Grid Geometry Manager. Please experiment with the grid manager for a while it will pay dividends in your programming endeavors.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec10"/>Drop-down menus to select from a list</h1></div></div></div><p>Here we use a drop-down menu widget as a way to select one item from a choice of several on offer.<a id="id291" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec23"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way. The result is shown in the following screenshot:</p><div><img src="img/3845_10_11.jpg" height="60" alt="How to do it..."/></div><div><pre class="programlisting"># dropdown_1.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Drop-down boxes for option selections.")
var = StringVar(root)
var.set("drop down menu button")
def grab_and_assign(event):
chosen_option = var.get()
label_chosen_variable= Label(root, text=chosen_option)
label_chosen_variable.grid(row=1, column=2)
print chosen_option
drop_menu = OptionMenu(root, var, "one", "two", "three", "four", \ "meerkat", "12345", "6789", command=grab_and_assign)
drop_menu.grid(row=0, column=0)
label_left=Label(root, text="chosen variable= ")
label_left.grid(row=1, column=0)
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec24"/>How it works...</h2></div></div></div><p>The drop-down menu has its own button. The<code class="literal"> callback()</code> function that gets called when this button is clicked is named<code class="literal"> grab_and_assign</code> in this particular recipe and one of the instructions in this event service routine is to assign the value of the menu item selected to the variable<code class="literal"> chosen_option</code>. The instruction that does this is<code class="literal"> chosen_option = var.get()</code>.<a id="id292" class="indexterm"/>
</p><p>As we did previously, we reassure ourselves that everything works as expected by printing the new value of<code class="literal"> chosen_option</code> as a label on the parent window.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec11"/>Listbox variable selection</h1></div></div></div><p>A<strong> listbox</strong> is a widget that shows a choice of alternatives in a list form. An item in the list can be selected by clicking the mouse cursor on it.<a id="id293" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec25"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way.</p><div><pre class="programlisting"># listbox_simple_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Listbox Data Input")
def get_list(event):
# Mouse button release callback
# Read the listbox selection and put the result in an entry box
# widget
index = listbox1.curselection()[0] # get selected line index
seltext = listbox1.get(index) # get the line's text &amp; # assign
# to a variable
enter_1.delete(0, 50) # delete previous text in
# enter_1 otherwise the # entries
# append to each other.
enter_1.insert(0, seltext) # now display the selected # text
# Create the listbox (note that size is in characters)
listboxitem, selecting fromlistbox1 = Listbox(root, width=50, height=6)
listbox1.grid(row=0, column=0)
# Fill the listbox with data
listbox1.insert(END, "a list entry")
for item in ["one has begun", "two is a shoe", "three like a knee", \
"four to the door"]:
listbox1.insert(END, item)
# use entry widget to display/edit selection
enter_1 = Entry(root, width=50, bg='yellow')
enter_1.insert(0, 'Click on an item in the listbox')
enter_1.grid(row=1, column=0)
# left mouse click on a list item to display selection
listbox1.bind('&lt;ButtonRelease-1&gt;', get_list)
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec26"/>How it works...</h2></div></div></div><div><img src="img/3845_10_12.jpg" height="112" alt="How it works..."/></div><p>A listbox named<code class="literal"> listbox1</code> is created and placed inside a Tkinter window. It is populated with five string items using a for loop.<a id="id295" class="indexterm"/>
</p><p>When the mouse cursor is clicked on an item, the function<code class="literal"> get_list</code> assigns that item as the value of a variable<code class="literal"> seltext</code>. The value of this variable is displayed in the yellow entry box.<a id="id296" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec12"/>Text in a window</h1></div></div></div><p>Here is a simple way to place text in a window. There is no provision made to interact with the text.<a id="id297" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec27"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way.</p><div><pre class="programlisting"># text_in_window_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Text in a window")
text_on_window = Text(root)
text_on_window.grid(row=0, column=0)
for i in range(20):
text_on_window.insert(END, "Fill an area with some text: line %d\n"\
% i)
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec28"/>How it works...</h2></div></div></div><p>A Text widget is created by the<code class="literal"> Text(root)</code> method and the<code class="literal"> insert(…)</code> function places the text inside. The END attribute places each new line at the end of the previous one.<a id="id298" class="indexterm"/>
</p></div></div></div>
</body></html>