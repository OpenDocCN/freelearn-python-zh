<html><head></head><body>
<div id="_idContainer098">
<h1 class="chapter-number" id="_idParaDest-353"><a id="_idTextAnchor675"/><a id="_idTextAnchor676"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-354"><a id="_idTextAnchor677"/><span class="koboSpan" id="kobo.2.1">Microservices and Containers</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Up until now, we have been developing the complete application as one block of code (usually known as a </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">monolith</span></strong><span class="koboSpan" id="kobo.5.1">), which is typically designed, tested, and deployed as a single unit. </span><span class="koboSpan" id="kobo.5.2">Scaling also occurs </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.6.1">in a similar manner, where either the whole application is scaled or not. </span><span class="koboSpan" id="kobo.6.2">However, as the application grows in size, it is natural to want to break the monolith into smaller chunks that can be separately managed and scaled. </span><span class="koboSpan" id="kobo.6.3">A solution to this is microservices. </span><span class="koboSpan" id="kobo.6.4">This chapter is all about microservices, and we will look at a few methodologies for creating and </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">managing them.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">Microservices comprise a method of developing and architecting software applications as a collection of multiple loosely coupled services. </span><span class="koboSpan" id="kobo.8.2">These services are designed and developed to help build single-function modules that have clear and fine-grained interfaces. </span><span class="koboSpan" id="kobo.8.3">The benefit of this modularity, if designed and architected properly, is that the overall application becomes easier to understand, develop, maintain, and test. </span><span class="koboSpan" id="kobo.8.4">Multiple small autonomous teams can work in parallel on multiple microservices, so the time to develop and deliver an application is effectively reduced. </span><span class="koboSpan" id="kobo.8.5">Each microservice can now be deployed and scaled separately, which allows for less downtime and cost-effective scaling since only the high-traffic services can be scaled based on predefined criteria. </span><span class="koboSpan" id="kobo.8.6">Other services can operate </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">as usual.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">This chapter will start with some of the common terminologies that you might hear whenever microservices are talked about – that is, containers and Docker. </span><span class="koboSpan" id="kobo.10.2">First, we will look at how to deploy a Flask application using Docker containers. </span><span class="koboSpan" id="kobo.10.3">Then, we will look at how multiple containers are scaled and managed effectively using Kubernetes, which is one of the best container orchestration tools available. </span><span class="koboSpan" id="kobo.10.4">Then, we will look at how to create fully-managed microservices using some cloud platforms such as </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">AWS Lambda</span></strong><span class="koboSpan" id="kobo.12.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">GCP Cloud Run</span></strong><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">Finally, we will look at how to stitch everything together into a seamless deployment pipeline using </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.15.1">GitHub Actions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Containerization </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">with Docker</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Orchestrating containers </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">with Kubernetes</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Going serverless with Google </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Cloud Run</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Continuous deployment with </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">GitHub Actions</span></span><a id="_idTextAnchor678"/></li>
</ul>
<h1 id="_idParaDest-355"><span class="koboSpan" id="kobo.27.1">Containerization with Docker</span><a id="_idTextAnchor679"/></h1>
<p><span class="koboSpan" id="kobo.28.1">A container can be thought of as a standardized package of code that is needed to run the application </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.29.1">and all its dependencies, which allows the application to </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.30.1">run uniformly across multiple environments </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.31.1">and platforms. </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">Docker</span></strong><span class="koboSpan" id="kobo.33.1"> is a tool that allows for a standard and easy method of creating, distributing, deploying, and running applications </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">using containe</span><a id="_idTextAnchor680"/><span class="koboSpan" id="kobo.35.1">rs.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Docker is essentially a virtualization software, but instead of visualizing the whole operating system, it allows the application to use the underlying host OS and requires applications to package additional dependencies and components as needed. </span><span class="koboSpan" id="kobo.36.2">This makes Docker container images very lightweight and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">to distribu</span><a id="_idTextAnchor681"/><a id="_idTextAnchor682"/><span class="koboSpan" id="kobo.38.1">te.</span></span></p>
<h2 id="_idParaDest-356"><a id="_idTextAnchor683"/><span class="koboSpan" id="kobo.39.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.40.1">The first step is to install Docker. </span><span class="koboSpan" id="kobo.40.2">Docker’s installation steps vary in terms of the operating system you use. </span><span class="koboSpan" id="kobo.40.3">The detailed steps for each operating system can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">at </span></span><a href="https://docs.docker.com/install/"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://docs.docker.com/install/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.44.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.45.1">Docker is a fast-evolving software and has had multiple major releases in the last few years, where a lot </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.46.1">of older releases have been deprecated. </span><span class="koboSpan" id="kobo.46.2">I would suggest that you always read the documentation thoroughly to avoid installing any legacy versions </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">of Docker.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Once Docker has been successfully installed, head over to the Terminal and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.50.1">
$ docker ps
CONTAINER ID   IMAGE   COMMAND   CREATED   STATUS   PORTS   NAMES</span></pre>
<p><span class="koboSpan" id="kobo.51.1">The preceding command is used to list all the running containers. </span><span class="koboSpan" id="kobo.51.2">If it runs without any errors and </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.52.1">shows a row of headers that start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">CONTAINER ID</span></strong><span class="koboSpan" id="kobo.54.1">, then </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.55.1">Docker has been </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">successfully installed.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.57.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.58.1">Different versions of Docker, whether old or current, have been called Docker Toolbox, Docker Machine, Docker Engine, Docker Desktop, and so on. </span><span class="koboSpan" id="kobo.58.2">These names will appear multiple times across the documentation and other resources on the internet. </span><span class="koboSpan" id="kobo.58.3">There is a great probability that these might change or evolve in the future as well. </span><span class="koboSpan" id="kobo.58.4">For the sake of simplicity, I will just call </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">everything </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.60.1">Docker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">A more fun way to verify the Docker installation would be to try out a </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">hello-world</span></strong><span class="koboSpan" id="kobo.64.1"> container. </span><span class="koboSpan" id="kobo.64.2">Just run the </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.66.1">
$ docker run hello-world</span></pre>
<p><span class="koboSpan" id="kobo.67.1">The preceding command should give you the following output. </span><span class="koboSpan" id="kobo.67.2">It lists the steps that Docker took to execute this command. </span><span class="koboSpan" id="kobo.67.3">I recommend reading </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">through this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.69.1"><img alt="Figure 12.1 – Testing D﻿ocker" src="image/B19111_12_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.70.1">Figure 12.1 – Testing D</span><a id="_idTextAnchor684"/><span class="koboSpan" id="kobo.71.1">ocker</span></p>
<h2 id="_idParaDest-357"><a id="_idTextAnchor685"/><span class="koboSpan" id="kobo.72.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.73.1">We will start with the catalog application from the </span><em class="italic"><span class="koboSpan" id="kobo.74.1">Managing and monitoring application performance with New Relic</span></em><span class="koboSpan" id="kobo.75.1"> recipe from </span><a href="B19111_11.xhtml#_idTextAnchor610"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.76.1">Chapter 11</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.77.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.78.1">The first step toward creating a container is to create an image for it. </span><span class="koboSpan" id="kobo.78.2">A Docker image can easily be </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.79.1">created in a scripted manner by creating a </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.80.1">file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">This file contains the steps that Docker needs to perform to build an image for our application’s container. </span><span class="koboSpan" id="kobo.82.3">A basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.84.1"> for our application would be </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.86.1">
FROM python:3</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.87.1">
WORKDIR /usr/src/app</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.88.1">
COPY requirements.txt requirements.txt</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.89.1">
RUN pip install -r requirements.txt</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.90.1">
COPY . </span><span class="koboSpan" id="kobo.90.2">.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.91.1">
ENTRYPOINT [ "python" ]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.92.1">
CMD [ "run.py" ]</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.93.1">Each line in the preceding file is a command that is executed in a linear top-down approach. </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">FROM</span></strong><span class="koboSpan" id="kobo.95.1"> specifies the base container image over which the new image for our application container will be built. </span><span class="koboSpan" id="kobo.95.2">I have taken the base image as </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">python:3</span></strong><span class="koboSpan" id="kobo.97.1">, which is a Linux image with </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">Python 3.11</span></strong><span class="koboSpan" id="kobo.99.1"> installed.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.100.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.101.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">python:3</span></strong><span class="koboSpan" id="kobo.103.1"> Docker base images come with </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">Python 3.11</span></strong><span class="koboSpan" id="kobo.105.1"> pre-installed at the time of writing this book. </span><span class="koboSpan" id="kobo.105.2">This will change </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">over time.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">WORKDIR</span></strong><span class="koboSpan" id="kobo.108.1"> indicates the default directory where the application will be installed. </span><span class="koboSpan" id="kobo.108.2">I have set it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">/usr/src/app</span></strong><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">Any commands that are run after this will be executed from inside this folder.</span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">COPY</span></strong><span class="koboSpan" id="kobo.112.1"> simply </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.113.1">copies the files specified on the local machine </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.114.1">to the container filesystem. </span><span class="koboSpan" id="kobo.114.2">I have copied </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.116.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">/usr/src/app</span></strong><span class="koboSpan" id="kobo.118.1">.</span></p>
<p><span class="koboSpan" id="kobo.119.1">This is followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">RUN</span></strong><span class="koboSpan" id="kobo.121.1">, which executes the command provided. </span><span class="koboSpan" id="kobo.121.2">Here, we have installed all the requirements from </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.123.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">pip</span></strong><span class="koboSpan" id="kobo.125.1">. </span><span class="koboSpan" id="kobo.125.2">Then, I simply copied all the files from my current local folder, which is essentially my application root folder, to </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">/usr/src/app</span></strong><span class="koboSpan" id="kobo.127.1">.</span></p>
<p><span class="koboSpan" id="kobo.128.1">Finally, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">ENTRYPOINT</span></strong><span class="koboSpan" id="kobo.130.1"> is defined that indicates the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">CMD</span></strong><span class="koboSpan" id="kobo.132.1"> command, which should be run when a container is started. </span><span class="koboSpan" id="kobo.132.2">Here, I have simply run my application by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">python run.py</span></strong><span class="koboSpan" id="kobo.134.1">.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.135.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.136.1">A Dockerfile provides many other </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.137.1">keywords, all of which can be used to create powerful scripts. </span><span class="koboSpan" id="kobo.137.2">Refer to </span><a href="https://docs.docker.com/engine/reference/builder/"><span class="koboSpan" id="kobo.138.1">https://docs.docker.com/engine/reference/builder/</span></a><span class="koboSpan" id="kobo.139.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">more information.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.141.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.142.1">There are multiple ways of running the application, as outlined in </span><a href="B19111_11.xhtml#_idTextAnchor610"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.143.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.144.1">, </span><em class="italic"><span class="koboSpan" id="kobo.145.1">Deployment and Post-Deployment</span></em><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">I would urge you to use those methods while dockerizing </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">the application.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.148.1">For the Dockerfile to run, you must have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.150.1"> file in your application’s </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.151.1">root folder. </span><span class="koboSpan" id="kobo.151.2">If you don’t have one, you can </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.152.1">simply generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.154.1"> file using the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.156.1">$ pip freeze &gt; requirements.txt</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.157.1">The following is my </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.159.1"> file. </span><span class="koboSpan" id="kobo.159.2">I encourage you to generate your own instead of using the one that follows because the Python package versions will evolve and you will want to use the latest and most relevant ones:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.160.1">
aiohttp==3.8.4
aiosignal==1.3.1
async-timeout==4.0.2
attrs==22.2.0
Babel==2.11.0
blinker==1.5
boto3==1.26.76
botocore==1.29.76
certifi==2022.12.7
charset-normalizer==3.0.1
click==8.1.3
Flask==2.2.3
flask-babel==3.0.1
Flask-SQLAlchemy==3.0.3
Flask-WTF==1.1.1
frozenlist==1.3.3
geoip2==4.6.0
greenlet==2.0.2
gunicorn==20.1.0
idna==3.4
itsdangerous==2.1.2
Jinja2==3.1.2
jmespath==1.0.1
MarkupSafe==2.1.2
maxminddb==2.2.0
multidict==6.0.4
python-dateutil==2.8.2
pytz==2022.7.1
requests==2.28.2
s3transfer==0.6.0
sentry-sdk==1.15.0
six==1.16.0
SQLAlchemy==2.0.4
tornado==6.2
typing_extensions==4.5.0
urllib3==1.26.14
Werkzeug==2.2.3
WTForms==3.0.1
yarl==1.8.2
newrelic==8.7.0</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.161.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.162.1">If you have </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">mod_wsgi</span></strong><span class="koboSpan" id="kobo.164.1"> in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.166.1"> file, you can remove it from the file unless you specifically want to run your application in a Docker container using </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">Apache</span></strong><span class="koboSpan" id="kobo.168.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">mod_wsgi</span></strong><span class="koboSpan" id="kobo.170.1"> is an OS-specific package and the OS on your development machine might not match that on the Docker image, which would lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">installation failure.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.172.1">A small change needs to be made to </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">run.py</span></strong><span class="koboSpan" id="kobo.174.1">, after which it will look </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.176.1">
from my_app import app</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.177.1">
app.run(debug=True, host='0.0.0.0', port='8000')</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.178.1">I have </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.179.1">added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">host</span></strong><span class="koboSpan" id="kobo.181.1"> parameter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">app.run</span></strong><span class="koboSpan" id="kobo.183.1">. </span><span class="koboSpan" id="kobo.183.2">This </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.184.1">allows the application to be accessed outside the Docker container.</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.185.1">The creation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.187.1"> is followed by building a Docker container image, which can then be run </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">like so:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.189.1">$ docker build -t cookbook .</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.190.1">Here, we asked Docker to build an image using the Dockerfile at the same location. </span><span class="koboSpan" id="kobo.190.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">-t</span></strong><span class="koboSpan" id="kobo.192.1"> argument sets the name/tag for the image that will be built. </span><span class="koboSpan" id="kobo.192.2">The final argument is a dot (</span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">.</span></strong><span class="koboSpan" id="kobo.194.1">), which indicates that everything in the current folder needs to be packaged in the build. </span><span class="koboSpan" id="kobo.194.2">This command might take a while to process when it’s run for the first time because it will download the base image and then all of our application dependencies.</span></p>
<p><span class="koboSpan" id="kobo.195.1">Let’s check the created image:</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.196.1">$ docker images</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.197.1">REPOSITORY     TAG     IMAGE ID       CREATED          SIZE</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.198.1">cookbook    latest   bceac988395a   48 seconds ago   1.13GB</span></strong></pre>
<ol>
<li value="5"><span class="koboSpan" id="kobo.199.1">Next, run this image to create </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">a container:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.201.1">$ docker run -d -p 8000:8000 cookbook:latest</span></strong></pre></li>
</ol>
<p><strong class="bold"><span class="koboSpan" id="kobo.202.1">92a7ee37e044cf59196f5ec4472d9ffb540c7f48ee3f4f1e5f978f7f93b301ba</span></strong></p>
<p><span class="koboSpan" id="kobo.203.1">Here, we have asked Docker to run the container using the commands that were specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.205.1"> at the bottom. </span><span class="koboSpan" id="kobo.205.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">-d</span></strong><span class="koboSpan" id="kobo.207.1"> argument asks Docker to </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.208.1">run the container in detached mode in the </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.209.1">background; otherwise, it will block control to the current shell window. </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">-p</span></strong><span class="koboSpan" id="kobo.211.1"> maps the port from the host machine to the Docker container port. </span><span class="koboSpan" id="kobo.211.2">This means that we have asked Docker to map port </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">8000</span></strong><span class="koboSpan" id="kobo.213.1"> on the local machine to port </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">8000</span></strong><span class="koboSpan" id="kobo.215.1"> on the container. </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">8000</span></strong><span class="koboSpan" id="kobo.217.1"> is the port on which we are running our Flask app (see </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">run.py</span></strong><span class="koboSpan" id="kobo.219.1">). </span><span class="koboSpan" id="kobo.219.2">The last argument is the name of the container image, which is a combination of </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">REPOSITORY</span></strong><span class="koboSpan" id="kobo.221.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">TAG</span></strong><span class="koboSpan" id="kobo.223.1">, as indicated by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">docker images</span></strong><span class="koboSpan" id="kobo.225.1"> command. </span><span class="koboSpan" id="kobo.225.2">Alternatively, you can just prov</span><a id="_idTextAnchor686"/><span class="koboSpan" id="kobo.226.1">ide an </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">IMAGE ID</span></strong><span class="koboSpan" id="kobo.228.1">.</span></p>
<h2 id="_idParaDest-358"><a id="_idTextAnchor687"/><span class="koboSpan" id="kobo.229.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.230.1">Head over to </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.231.1">your browser and open </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">http://localhost:8000/</span></strong><span class="koboSpan" id="kobo.233.1"> to </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.234.1">see the </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">application running.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">Now, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">docker ps</span></strong><span class="koboSpan" id="kobo.238.1"> again to see the details of the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">running container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.240.1">
$ docker ps
CONTAINER ID   IMAGE             COMMAND           CREATED         STATUS         PORTS                    NAMES
92a7ee37e044   cookbook:latest   "python run.py"   7 seconds ago   Up 6 seconds   0.0.0.0:8000-&gt;8000/tcp   beautiful_ritchie</span></pre>
<h2 id="_idParaDest-359"><a id="_idTextAnchor688"/><span class="koboSpan" id="kobo.241.1">See also</span></h2>
<ul>
<li><span class="koboSpan" id="kobo.242.1">You can learn more about Dockerfiles </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">at </span></span><a href="https://docs.docker.com/engine/reference/builder/"><span class="No-Break"><span class="koboSpan" id="kobo.244.1">https://docs.docker.com/engine/reference/builder/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.245.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.246.1">The definition of a container by Docker can be read </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">at </span></span><a href="https://www.docker.com/resources/what-container"><span class="No-Break"><span class="koboSpan" id="kobo.248.1">https://www.docker.com/resources/what-container</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.249.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.250.1">You can read about microservices in general </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">at </span></span><a href="https://en.wikipedia.org/wiki/Microservices"><span class="No-Break"><span class="koboSpan" id="kobo.252.1">https://en.wikipedia.org/wiki/Microservices</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.253.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.254.1">One of the first articles on microservices by Martin Fowler can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">at </span></span><a href="https://martinfowler.com/articles/microservices.html"><span class="No-Break"><span class="koboSpan" id="kobo.256.1">https://martinfowler.com/articles/m</span><span id="_idTextAnchor689"/><span class="koboSpan" id="kobo.257.1">icroservices.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.258.1">.</span></span></li>
</ul>
<h1 id="_idParaDest-360"><a id="_idTextAnchor690"/><span class="koboSpan" id="kobo.259.1">Orchestrating containers with Kubernetes</span></h1>
<p><span class="koboSpan" id="kobo.260.1">Docker containers </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.261.1">are pretty </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.262.1">easy and powerful, as we saw from the previous recipe, but without a strong container orchestration system, managing containers can become pretty intensive. </span><strong class="bold"><span class="koboSpan" id="kobo.263.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.264.1"> (also written as </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">K8s</span></strong><span class="koboSpan" id="kobo.266.1">) is an open source container orchestration system </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.267.1">that automates the management, deployment, and scaling of containerized applications. </span><span class="koboSpan" id="kobo.267.2">It was originally developed at Google and, over the years, has become the most popular container orchestration software. </span><span class="koboSpan" id="kobo.267.3">It is widely available across all m</span><a id="_idTextAnchor691"/><span class="koboSpan" id="kobo.268.1">ajor </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">cloud providers.</span></span></p>
<h2 id="_idParaDest-361"><a id="_idTextAnchor692"/><span class="koboSpan" id="kobo.270.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.271.1">In this recipe, we will see how we can leverage Kubernetes to automate the deployment and scaling of our application container, which we created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">previous recipe.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">Kubernetes is </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.274.1">packaged along </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.275.1">with the newer versions of the Docker Desktop installation and works in a pretty straightforward manner. </span><span class="koboSpan" id="kobo.275.2">However, we will be using </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">minikube</span></strong><span class="koboSpan" id="kobo.277.1">, which is a standard distribution that’s provided by Kubernetes </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.278.1">itself. </span><span class="koboSpan" id="kobo.278.2">It’s quite popular and good for getting started. </span><span class="koboSpan" id="kobo.278.3">For this recipe, I will use Minikube, which will allow a single-node Kubernetes cluster to be run inside a VM on our local machine. </span><span class="koboSpan" id="kobo.278.4">You can choose to use other distributions of Kubernetes; refer to </span><a href="https://kubernetes.io/docs/setup/"><span class="koboSpan" id="kobo.279.1">https://kubernetes.io/docs/setup/</span></a><span class="koboSpan" id="kobo.280.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">more details.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">To install Minikube, follow </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.283.1">the instructions outlined at </span><a href="https://minikube.sigs.k8s.io/docs/start/"><span class="koboSpan" id="kobo.284.1">https://minikube.sigs.k8s.io/docs/start/</span></a><span class="koboSpan" id="kobo.285.1"> for your </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">operating system.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.287.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.288.1">Kubernetes is a huge topic that spans multiple dimensions. </span><span class="koboSpan" id="kobo.288.2">There are multiple books dedicated just to Kubernetes, and many more are being written. </span><span class="koboSpan" id="kobo.288.3">In this recipe, we will cover a very basic implementation of Kubernetes, just to ge</span><a id="_idTextAnchor693"/><span class="koboSpan" id="kobo.289.1">t you acquainted </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">with it.</span></span></p>
<h2 id="_idParaDest-362"><a id="_idTextAnchor694"/><span class="koboSpan" id="kobo.291.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.292.1">Follow these steps to understand how a local Kubernetes cluster can be created </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">and used:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.294.1">After Minikube has been installed, create a Minikube cluster on your </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">local machine:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.296.1">$ minikube start</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.297.1">😄</span></strong><strong class="bold"><span class="koboSpan" id="kobo.298.1">  minikube v1.29.0 on Darwin 13.0</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.299.1">✨</span></strong><strong class="bold"><span class="koboSpan" id="kobo.300.1">  Automatically selected the docker driver. </span><span class="koboSpan" id="kobo.300.2">Other choices: hyperkit, ssh</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.301.1">📌</span></strong><strong class="bold"><span class="koboSpan" id="kobo.302.1">  Using Docker Desktop driver with root privileges</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.303.1">👍</span></strong><strong class="bold"><span class="koboSpan" id="kobo.304.1">  Starting control plane node minikube in cluster minikube</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.305.1">🚜</span></strong><strong class="bold"><span class="koboSpan" id="kobo.306.1">  Pulling base image …</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.307.1">. </span><span class="koboSpan" id="kobo.307.2">. </span><span class="koboSpan" id="kobo.307.3">. </span><span class="koboSpan" id="kobo.307.4">.</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.308.1">Downloading and installing images</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.309.1">. </span><span class="koboSpan" id="kobo.309.2">. </span><span class="koboSpan" id="kobo.309.3">.</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.310.1">🔎</span></strong><strong class="bold"><span class="koboSpan" id="kobo.311.1">  Verifying Kubernetes components...</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.312.1">🌟</span></strong><strong class="bold"><span class="koboSpan" id="kobo.313.1">  Enabled addons: storage-provisioner, default-storageclass</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.314.1">🏄</span></strong><strong class="bold"><span class="koboSpan" id="kobo.315.1">  Done! </span><span class="koboSpan" id="kobo.315.2">kubectl is now configured to use "minikube" cluster and "default" namespace by default</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.316.1">As you can </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.317.1">see, the preceding </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.318.1">command downloads a bunch of images to set up and run Minikube, which creates a VM on your local machine. </span><span class="koboSpan" id="kobo.318.2">After creating a VM using these images, a simple Kubernetes cluster with only one node will be launched. </span><span class="koboSpan" id="kobo.318.3">This process might take a bit of time when it’s run for the first time.</span></p>
<p><span class="koboSpan" id="kobo.319.1">Minikube provides a browser dashboard view as well. </span><span class="koboSpan" id="kobo.319.2">This can be initiated by running the following command:</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.320.1">$ minikube dashboard</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.321.1">🔌</span></strong><strong class="bold"><span class="koboSpan" id="kobo.322.1">  Enabling dashboard ...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.323.1">▪</span></strong><strong class="bold"><span class="koboSpan" id="kobo.324.1"> Using image docker.io/kubernetesui/metrics-scraper:v1.0.8</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.325.1">▪</span></strong><strong class="bold"><span class="koboSpan" id="kobo.326.1"> Using image docker.io/kubernetesui/dashboard:v2.7.0</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.327.1">🤔</span></strong><strong class="bold"><span class="koboSpan" id="kobo.328.1">  Verifying dashboard health ...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.329.1">🚀</span></strong><strong class="bold"><span class="koboSpan" id="kobo.330.1">  Launching proxy ...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.331.1">🤔</span></strong><strong class="bold"><span class="koboSpan" id="kobo.332.1">  Verifying proxy health ...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.333.1">🎉</span></strong><strong class="bold"><span class="koboSpan" id="kobo.334.1">  Opening http://127.0.0.1:57206/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ in your default browser...</span></strong></pre>
<p><span class="koboSpan" id="kobo.335.1">Visit the URL mentioned in the output of the preceding command to view the dashboard.</span></p>
<p><span class="koboSpan" id="kobo.336.1">In Kubernetes, containers are deployed in pods, where a pod can be defined as a group of </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.337.1">one or more </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.338.1">containers that are tied together for sharing resources and networking. </span><span class="koboSpan" id="kobo.338.2">In this recipe, we will have only one container inside a pod.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.339.1">Whenever a deployment is created using Minikube, it will look for the Docker image on some cloud-based registries such as Docker Hub or Google Cloud Registry, or something custom. </span><span class="koboSpan" id="kobo.339.2">For this recipe, we intend to make a deployment using a local Docker image. </span><span class="koboSpan" id="kobo.339.3">Therefore, we will run the following command, which sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">docker</span></strong><span class="koboSpan" id="kobo.341.1"> environment to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">minikube docker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.344.1">$ eval $(minikube -p minikube docker-env)</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.345.1">Now, rebuild the Docker image using the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">docker</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.347.1">environment set:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.348.1">$ docker build -t cookbook .</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.349.1">For more details on building Docker images, refer to the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.350.1">Containerization with Docker</span></em><span class="koboSpan" id="kobo.351.1">.</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.352.1">Next, create </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.353.1">a file </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.354.1">named </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">cookbook-deployment.yaml</span></strong><span class="koboSpan" id="kobo.356.1"> in your application </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">root folder:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.358.1">
apiVersion: apps/v1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.359.1">
kind: Deployment</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.360.1">
metadata:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.361.1">
  creationTimestamp: null</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.362.1">
  labels:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.363.1">
    app: cookbook-recipe</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.364.1">
  name: cookbook-recipe</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.365.1">
spec:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.366.1">
  replicas: 1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.367.1">
  selector:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.368.1">
    matchLabels:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.369.1">
      app: cookbook-recipe</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.370.1">
  strategy: {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.371.1">
  template:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.372.1">
    metadata:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.373.1">
      creationTimestamp: null</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.374.1">
      labels:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.375.1">
        app: cookbook-recipe</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.376.1">
    spec:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.377.1">
      containers:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.378.1">
      - image: cookbook:latest</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.379.1">
        name: cookbook</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.380.1">
        resources: {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.381.1">
        imagePullPolicy: Never</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.382.1">
status: {}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.383.1">In this file, we created a deployment named </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">cookbook-recipe</span></strong><span class="koboSpan" id="kobo.385.1">, which uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">cookbook:latest</span></strong><span class="koboSpan" id="kobo.387.1"> image. </span><span class="koboSpan" id="kobo.387.2">Take note of </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">imagePullPolicy</span></strong><span class="koboSpan" id="kobo.389.1">, which is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">Never</span></strong><span class="koboSpan" id="kobo.391.1"> – this signifies that kubectl should not try to fetch the image from online Docker repositories (such as Docker Hub or </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">Google Container Registry</span></strong><span class="koboSpan" id="kobo.393.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.394.1">GCR</span></strong><span class="koboSpan" id="kobo.395.1">); instead, it should always search for this image locally.</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.396.1">Now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">apply</span></strong><span class="koboSpan" id="kobo.398.1"> the preceding file to create a Kubernetes deployment </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">using kubectl:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.400.1">$ kubectl apply -f cookbook-deployment.yaml</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.401.1">deployment.apps/cookbook-recipe created</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.402.1">You can </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.403.1">verify and </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.404.1">get the status of the deployment that’s been created by running the following:</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.405.1">$ kubectl get deployments</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.406.1">NAME              READY   UP-TO-DATE   AVAILABLE   AGE</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.407.1">cookbook-recipe   1/1     1            1           26s</span></strong></pre>
<p><span class="koboSpan" id="kobo.408.1">Check the values for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">READY</span></strong><span class="koboSpan" id="kobo.410.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">UP-TO-DATE</span></strong><span class="koboSpan" id="kobo.412.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">AVAILABLE</span></strong><span class="koboSpan" id="kobo.414.1"> columns. </span><span class="koboSpan" id="kobo.414.2">These values represent the number of replicas of our application in the cluster.</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.415.1">Our application is now running but is currently not accessible outside the cluster. </span><span class="koboSpan" id="kobo.415.2">To expose the application outside the Kubernetes cluster, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">LoadBalancer</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.417.1">type service:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.418.1">$ kubectl expose deployment cookbook-recipe --type=LoadBalancer --port=8000</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.419.1">service/cookbook-recipe exposed</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.420.1">The deployment that we created in the last step exposed our application on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">8000</span></strong><span class="koboSpan" id="kobo.422.1">, which was internal to the cluster. </span><span class="koboSpan" id="kobo.422.2">The preceding command has exposed this internal </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">8000</span></strong><span class="koboSpan" id="kobo.424.1"> port to any random port that can be accessed outside the cluster and</span><a id="_idTextAnchor695"/><span class="koboSpan" id="kobo.425.1"> hence via a browser.</span></p>
<h2 id="_idParaDest-363"><a id="_idTextAnchor696"/><span class="koboSpan" id="kobo.426.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.427.1">To open the application in a browser, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
$ minikube service cookbook-recipe</span></pre>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.430.1"><img alt="Figure 12.2 – Service deployed using Kubernetes" src="image/B19111_12_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.431.1">Figure 12.2 – Service deployed using Kubernetes</span></p>
<p><span class="koboSpan" id="kobo.432.1">Running the preceding command will open the application in a browser on a random port, such </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">58764</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">Scaling a </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.437.1">deployment is very easy with </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.438.1">Kubernetes. </span><span class="koboSpan" id="kobo.438.2">It is as simple as running a single command. </span><span class="koboSpan" id="kobo.438.3">By doing this, the application will be replicated in </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">multiple pods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
$ kubectl scale --replicas=3 deployment/cookbook-recipe
deployment.apps/cookbook-recipe scaled</span></pre>
<p><span class="koboSpan" id="kobo.441.1">Now, look at the status of </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">deployment again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
$ kubectl get deployments
NAME              READY   UP-TO-DATE   AVAILABLE   AGE
cookbook-recipe   3/3     3            3           90s</span></pre>
<p><span class="koboSpan" id="kobo.444.1">Check the </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.445.1">replica values in </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.446.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">READY</span></strong><span class="koboSpan" id="kobo.448.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">UP-TO-DATE</span></strong><span class="koboSpan" id="kobo.450.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">AVAILABLE</span></strong><span class="koboSpan" id="kobo.452.1"> columns, which will hav</span><a id="_idTextAnchor697"/><span class="koboSpan" id="kobo.453.1">e increased from </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.455.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">.</span></span></p>
<h2 id="_idParaDest-364"><a id="_idTextAnchor698"/><span class="koboSpan" id="kobo.458.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.459.1">You can look at the YAML configurations that Kubernetes automatically creates for the deployment </span><a id="_idIndexMarker599"/><span class="No-Break"><span class="koboSpan" id="kobo.460.1">and service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.461.1">
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2023-03-06T08:23:24Z"
  labels:
    app: cookbook-recipe
  name: cookbook-recipe
  namespace: default
  resourceVersion: "5991"
  uid: 1253962c-f3d5-4a1f-b997-c11a4abd2b33
spec:
  allocateLoadBalancerNodePorts: true
  clusterIP: 10.105.38.134
  clusterIPs:
  - 10.105.38.134
  externalTrafficPolicy: Cluster
  internalTrafficPolicy: Cluster
  ipFamilies:
  - IPv4
  ipFamilyPolicy: SingleStack
  ports:
  - nodePort: 31473
    port: 8000
    protocol: TCP
    targetPort: 8000
  selector:
    app: cookbook-recipe
  sessionAffinity: None
  type: LoadBalancer
status:
  loadBalancer: {}</span></pre>
<p><span class="koboSpan" id="kobo.462.1">The preceding code is the config for the service. </span><span class="koboSpan" id="kobo.462.2">You can choose to create/save and </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">apply</span></strong><span class="koboSpan" id="kobo.464.1"> this config (instead of specifying configuration values in command lines) just like we did earlier for the deployment in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.465.1">Step 5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.467.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.468.1">What I have shown in this recipe is a very basic implementation of Kubernetes. </span><span class="koboSpan" id="kobo.468.2">The purpose of this is to get you acquainted with Kubernetes. </span><span class="koboSpan" id="kobo.468.3">This recipe does not intend to be a production-grade implementation. </span><span class="koboSpan" id="kobo.468.4">Ideally, the config files need to be created, and then the overall Kubernetes deployment can be built around them. </span><span class="koboSpan" id="kobo.468.5">I would urge you to build on the knowledge from this recipe and strive toward production-grade te</span><a id="_idTextAnchor699"/><span class="koboSpan" id="kobo.469.1">chniques </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">with Kubernetes.</span></span></p>
<h2 id="_idParaDest-365"><a id="_idTextAnchor700"/><span class="koboSpan" id="kobo.471.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.472.1">To learn more, check out the </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">following resources:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.474.1">Start getting to know about Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">at </span></span><a href="https://kubernetes.io/docs/concepts/overview/"><span class="No-Break"><span class="koboSpan" id="kobo.476.1">https://kubernetes.io/docs/concepts/overview/</span></span></a></li>
<li><span class="koboSpan" id="kobo.477.1">The basics of Kubernetes are available </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">at </span></span><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/"><span class="No-Break"><span class="koboSpan" id="kobo.479.1">https://kubernetes.io/docs/tutorials/kubernetes-basics/</span></span></a></li>
<li><span class="koboSpan" id="kobo.480.1">A Minikube tutorial can be followed </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">at </span></span><a href="https://kubernetes.io/docs/tutorials/hello-minikube/"><span class="No-Break"><span class="koboSpan" id="kobo.482.1">https://kubernetes.io/docs/tutorials/hello-minikube/</span></span></a></li>
<li><span class="koboSpan" id="kobo.483.1">You can learn about the details of Minikube’s installation </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">at </span></span><a href="https://minikube.sigs.k8s.io/docs/start/"><span class="No-Break"><span class="koboSpan" id="kobo.485.1">https://minikube.sigs.k8s.io/docs/start/</span></span></a></li>
<li><span class="koboSpan" id="kobo.486.1">The complete Kubernetes documentation can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">at </span></span><a href="https://kubernetes.io/docs/home/"><span class="No-Break"><span class="koboSpan" id="kobo.488.1">https:/</span><span id="_idTextAnchor701"/><span class="koboSpan" id="kobo.489.1">/kubernetes.io/docs/home/</span></span></a></li>
</ul>
<h1 id="_idParaDest-366"><a id="_idTextAnchor702"/><span class="koboSpan" id="kobo.490.1">Going serverless with Google Cloud Run</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.491.1">Serverless computing</span></strong><span class="koboSpan" id="kobo.492.1"> is a cloud computing model where the cloud provider runs the server and </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.493.1">dynamically manages the allocation of machine resources by </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.494.1">scaling the resources up or down, depending </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.495.1">on the consumption. </span><span class="koboSpan" id="kobo.495.2">Pricing is done based on the actual resources that are used. </span><span class="koboSpan" id="kobo.495.3">It also simplifies the overall process of deploying code, and it becomes relatively easy to maintain different executions for different environments, such as development, testing, staging, and production. </span><span class="koboSpan" id="kobo.495.4">These properties of serverless computing make this model a perfect candidate for developing and deploying tons of microservices without worrying about managing </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">the overhead.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.497.1">Trivia</span></p>
<p class="callout"><span class="koboSpan" id="kobo.498.1">Why is this model called “serverless” even though there is a </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">server involved?</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.500.1">Even though there is a server involved that hosts your application and serves the requests coming into your application, the lifespan of the server is as small as a single request. </span><span class="koboSpan" id="kobo.500.2">So, you can think of a server as something that lives to serve a single request. </span><span class="koboSpan" id="kobo.500.3">Hence, the lifespan of a server is typically </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">in milliseconds.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">As Google explains, </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">Cloud Run</span></strong><span class="koboSpan" id="kobo.504.1"> is a managed compute platform that lets you run containers directly </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.505.1">on top of Google’s scalable infrastructure. </span><span class="koboSpan" id="kobo.505.2">Also, since Google Cloud provides loads of other services with which Cloud Run integrates very well, it allows us to build full-featured applications without a lot of moving parts from different </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">cloud vendors.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.507.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.508.1">Throughout this recipe, I will interchangeably use the terms </span><strong class="bold"><span class="koboSpan" id="kobo.509.1">Google Cloud</span></strong><span class="koboSpan" id="kobo.510.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">Google Cloud Platform</span></strong><span class="koboSpan" id="kobo.512.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.514.1">GCP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.516.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.517.1">Deploying with serverless tools allows developers to focus more on writing code rather than worry</span><a id="_idTextAnchor703"/><span class="koboSpan" id="kobo.518.1">ing about </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">the infrastructure.</span></span></p>
<h2 id="_idParaDest-367"><a id="_idTextAnchor704"/><span class="koboSpan" id="kobo.520.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.521.1">Before you can </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.522.1">deploy with Cloud Run, you need to </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.523.1">set up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">gcloud</span></strong><span class="koboSpan" id="kobo.525.1"> CLI on your machine from where you would deploy your application to Cloud Run. </span><span class="koboSpan" id="kobo.525.2">Go through the </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.527.1">First, create an account on Google Cloud Platform. </span><span class="koboSpan" id="kobo.527.2">Head over to </span><a href="https://console.cloud.google.com/getting-started"><span class="koboSpan" id="kobo.528.1">https://console.cloud.google.com/getting-started</span></a><span class="koboSpan" id="kobo.529.1"> and create a new account if you don’t already have one. </span><span class="koboSpan" id="kobo.529.2">Then, create a project under which you will deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">your application.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.531.1">Once you’ve created your account, make sure you have a billing account activated. </span><span class="koboSpan" id="kobo.531.2">Even though you will not be charged for the use case of this recipe, Google mandates you to have a billing account activated and linked to your project.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.532.1">Next, install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">gcloud</span></strong><span class="koboSpan" id="kobo.534.1"> CLI. </span><span class="koboSpan" id="kobo.534.2">This is highly OS-specific, so look for appropriate instructions </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">here: </span></span><a href="https://cloud.google.com/sdk/docs/install"><span class="No-Break"><span class="koboSpan" id="kobo.536.1">https://cloud.google.com/sdk/docs/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.537.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.538.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">gcloud</span></strong><span class="koboSpan" id="kobo.540.1"> CLI uses Python versions 3.5 to 3.9 for its installation. </span><span class="koboSpan" id="kobo.540.2">If you have a later version of Python such as 3.10 or 3.11, you don’t need to worry about it as </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">gcloud</span></strong><span class="koboSpan" id="kobo.542.1"> will download its own Python version and create a virtual environment for itself.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.543.1">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">gcloud</span></strong><span class="koboSpan" id="kobo.545.1"> installation is done, run the following command to initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">gcloud</span></strong><span class="koboSpan" id="kobo.547.1"> and go over some </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">basic settings:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.549.1">$ gcloud init</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.550.1">The execution of this command will ask you for some details, such as which GCP account you </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.551.1">would want to use to link to </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.552.1">your </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">gcloud</span></strong><span class="koboSpan" id="kobo.554.1"> CLI. </span><span class="koboSpan" id="kobo.554.2">On a desktop, it will open a browser and ask you to log into your GCP account. </span><span class="koboSpan" id="kobo.554.3">Make sure the user who logs in has enough permissions to deploy to Cloud Run. </span><span class="koboSpan" id="kobo.554.4">For this recipe, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">owner</span></strong><span class="koboSpan" id="kobo.556.1"> permission should handle everything.</span></p>
<p><span class="koboSpan" id="kobo.557.1">Then, you will be asked about the GCP project that you want to use.</span></p>
<p><span class="koboSpan" id="kobo.558.1">You can always change this configuration b</span><a id="_idTextAnchor705"/><span class="koboSpan" id="kobo.559.1">y running the same command again.</span></p>
<h2 id="_idParaDest-368"><a id="_idTextAnchor706"/><span class="koboSpan" id="kobo.560.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.561.1">Follow </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.563.1">After setting up and initializing </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">gcloud</span></strong><span class="koboSpan" id="kobo.565.1">, the next step is to create and upload the container of your application to GCR. </span><span class="koboSpan" id="kobo.565.2">You can also </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.566.1">use other container registries such as Docker Hub, but that is outside the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">this recipe.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.568.1">Important</span></p>
<p class="callout"><span class="koboSpan" id="kobo.569.1">Cloud Run expects the application to run on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">8080</span></strong><span class="koboSpan" id="kobo.571.1">. </span><span class="koboSpan" id="kobo.571.2">So, update your </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">run.py</span></strong><span class="koboSpan" id="kobo.573.1"> to run on </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">8080</span></strong><span class="koboSpan" id="kobo.575.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">8000</span></strong><span class="koboSpan" id="kobo.577.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">5000</span></strong><span class="koboSpan" id="kobo.579.1"> like we have done so far in </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">Run the following command from the root of your application where your </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.583.1"> is located:</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.584.1">$ gcloud builds submit --tag "gcr.io/&lt;Your project</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.585.1">  ID&gt;/&lt;Name of your container image&gt;"</span></strong></pre>
<p><span class="koboSpan" id="kobo.586.1">The preceding command created a Docker container using </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.588.1">. </span><span class="koboSpan" id="kobo.588.2">Then, it uploaded </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.589.1">the Docker container to GCR at </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.590.1">the path provided in the command. </span><span class="koboSpan" id="kobo.590.2">On successful execution, you will get a response similar to the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.591.1"><img alt="Figure 12.3 – GCR image creation" src="image/B19111_12_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.592.1">Figure 12.3 – GCR image creation</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.593.1">Now, use the image you created to deploy your application to Cloud Run. </span><span class="koboSpan" id="kobo.593.2">Run the following command for </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">the same:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.595.1">$ gcloud run deploy "your-application-name" –image</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.596.1">  "gcr.io/&lt;Your project ID&gt;/&lt;Name of your container</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.597.1">  image&gt;" --allow-unauthenticated --platform "managed"</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.598.1">This command will ask for a region of deployment if one hasn’t been set already; then, it will take a few minutes to deploy the application successfully to Cloud Run. </span><span class="koboSpan" id="kobo.598.2">Once done, it will provide the Service URL on which the application can be accessed. </span><span class="koboSpan" id="kobo.598.3">See the following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.599.1"><img alt="Fig﻿ure 12.4 – Deployment on Cloud Run" src="image/B19111_12_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.600.1">Fig</span><a id="_idTextAnchor707"/><span class="koboSpan" id="kobo.601.1">ure 12.4 – Deployment on Cloud Run</span></p>
<h2 id="_idParaDest-369"><a id="_idTextAnchor708"/><span class="koboSpan" id="kobo.602.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.603.1">To check whether the </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.604.1">application deployment is </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.605.1">successful and is running as expected, open the Service URL provided, as shown in the previous screenshot. </span><span class="koboSpan" id="kobo.605.2">It sh</span><a id="_idTextAnchor709"/><span class="koboSpan" id="kobo.606.1">ould open the application </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">home page.</span></span></p>
<h2 id="_idParaDest-370"><a id="_idTextAnchor710"/><span class="koboSpan" id="kobo.608.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.609.1">To learn more, check out the </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">following resources:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.611.1">You can </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.612.1">read more about Cloud Run </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">at </span></span><a href="https://cloud.google.com/run/docs/overview/what-is-cloud-run"><span class="No-Break"><span class="koboSpan" id="kobo.614.1">https://cloud.google.com/run/docs/overview/what-is-cloud-run</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.615.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.616.1">There are other serverless tools and platforms such as Serverless, Zappa, AWS Beanstalk, AWS Lambda, and others. </span><span class="koboSpan" id="kobo.616.2">I urge you to explore them on your own. </span><span class="koboSpan" id="kobo.616.3">The</span><a id="_idTextAnchor711"/><span class="koboSpan" id="kobo.617.1"> underlying concept remains </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">the same.</span></span></li>
</ul>
<h1 id="_idParaDest-371"><a id="_idTextAnchor712"/><span class="koboSpan" id="kobo.619.1">Continuous deployment with GitHub Actions</span></h1>
<p><span class="koboSpan" id="kobo.620.1">Continuous deployment is a deployment strategy that enables the deployment and release of software to </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.621.1">its relevant environment (production, in most cases) whenever there is a committed code change. </span><span class="koboSpan" id="kobo.621.2">Usually, this is </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.622.1">preceded by automated test cases; when those pass, the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">deployed automatically.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.624.1">GitHub Actions</span></strong><span class="koboSpan" id="kobo.625.1"> is a continuous deployment platform provided by GitHub that allows you to trigger workflows </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.626.1">on certain actions (such as code commit/merge/pull request). </span><span class="koboSpan" id="kobo.626.2">These workflows can be used to deploy to your choice of cloud provider. </span><span class="koboSpan" id="kobo.626.3">The best thing about GitHub Actions is that it integrates seamlessly </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">with GitHub.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">Other tools can be used to perform continuous deployment but I will be focusing on GitHub Actions because it is one of t</span><a id="_idTextAnchor713"/><span class="koboSpan" id="kobo.629.1">he easiest ones to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">and adopt.</span></span></p>
<h2 id="_idParaDest-372"><a id="_idTextAnchor714"/><span class="koboSpan" id="kobo.631.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.632.1">For this recipe, I am assuming that you have a GitHub account and know the basics of managing code and repositories </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">on GitHub.</span></span></p>
<p><span class="koboSpan" id="kobo.634.1">In this recipe, we will be building upon the application from the </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">previous recipe.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">Two steps need to be done to get ready for </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">this recipe:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.638.1">In the previous recipe, the authentication step for Google Cloud was performed during </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">gcloud init</span></strong><span class="koboSpan" id="kobo.640.1">, where you were asked to log in to GCP. </span><span class="koboSpan" id="kobo.640.2">But when deploying from GitHub Actions, you won’t have this liberty; hence, you need to create </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.641.1">a service account on Google Cloud </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.642.1">that has permission to create a container image on GCR and then deploy it to </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">Cloud Run.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.644.1">To create a service account, head over to your GCP console and open </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">IAM &amp; Admin</span></strong><span class="koboSpan" id="kobo.646.1">. </span><span class="koboSpan" id="kobo.646.2">Next, create a service account and give it relevant permissions/roles. </span><span class="koboSpan" id="kobo.646.3">To test this recipe, </span><strong class="bold"><span class="koboSpan" id="kobo.647.1">owner</span></strong><span class="koboSpan" id="kobo.648.1"> permission should do. </span><span class="koboSpan" id="kobo.648.2">Once you have created and configured a service account, it should look like this:</span></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.649.1"><img alt="" src="image/B19111_12_5.png"/></span><span class="koboSpan" id="kobo.650.1">Figure 12.5 – Service account on GCP</span></p>
<p><span class="koboSpan" id="kobo.651.1">Download the service account file in JSON format when given the option. </span><span class="koboSpan" id="kobo.651.2">It cannot be downloaded again.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.652.1">Next, configure your GitHub repository so that it stores secrets that will be read when the deployment runs. </span><span class="koboSpan" id="kobo.652.2">Head over to your GitHub repository by going to </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">Settings</span></strong><span class="koboSpan" id="kobo.654.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.655.1">Secrets and variables</span></strong><span class="koboSpan" id="kobo.656.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">Actions</span></strong><span class="koboSpan" id="kobo.658.1">. </span><span class="koboSpan" id="kobo.658.2">Here, create two repository secrets called </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">RUN_PROJECT</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.660.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">RUN_SA_KEY</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">.</span></span></li>
</ol>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">RUN_PROJECT</span></strong><span class="koboSpan" id="kobo.664.1"> is the project ID of your GCP project, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">RUN_SA_KEY</span></strong><span class="koboSpan" id="kobo.666.1"> is the content of the service account JSON file that you downloaded in the previous step:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.667.1"><img alt="Figure 12.6 – GitHub repository secrets" src="image/B19111_12_6.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><a id="_idTextAnchor715"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.668.1">Figure 12.6 – GitHub repository secrets</span></p>
<h2 id="_idParaDest-373"><a id="_idTextAnchor716"/><span class="koboSpan" id="kobo.669.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.670.1">Now, create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">.github/workflows/main.yml</span></strong><span class="koboSpan" id="kobo.672.1"> in your application’s root folder. </span><span class="koboSpan" id="kobo.672.2">Make sure the path for the file is created properly. </span><span class="koboSpan" id="kobo.672.3">You will need to create two folders </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.673.1">called </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">.github</span></strong><span class="koboSpan" id="kobo.675.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">workflows</span></strong><span class="koboSpan" id="kobo.677.1"> inside it, followed </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.678.1">by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">main.yml</span></strong><span class="koboSpan" id="kobo.680.1"> file in the latter. </span><span class="koboSpan" id="kobo.680.2">The following is the content of </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.682.1">
name: Build and Deploy to Cloud Run
on:
  push:
    branches:
    - vol-3
env:
  PROJECT_ID: ${{ secrets.RUN_PROJECT }}
  RUN_REGION: asia-south1
  SERVICE_NAME: flask-cookbook-git
jobs:
  setup-build-deploy:
    name: Setup, Build, and Deploy
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    # Setup gcloud CLI
    - uses: 'google-github-actions/auth@v1'
      with:
        credentials_json: ${{ secrets.RUN_SA_KEY }}
        project_id: ${{ secrets.RUN_PROJECT }}
    # Build and push image to Google Container Registry
    - name: Build
      run: |-
        gcloud builds submit \
          --quiet \
          --tag "gcr.io/$PROJECT_ID/$SERVICE_NAME"
    # Deploy image to Cloud Run
    - name: Deploy
      run: |-
        gcloud run deploy "$SERVICE_NAME" \
          --quiet \
          --region "$RUN_REGION" \
          --image "gcr.io/$PROJECT_ID/$SERVICE_NAME" \
          --platform "managed" \
          --allow-unauthenticated</span></pre>
<p><span class="koboSpan" id="kobo.683.1">In this file, first, we specified the branch on which the GitHub action is triggered on code push. </span><span class="koboSpan" id="kobo.683.2">Then, we </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.684.1">have some environment variables </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.685.1">that will be used in the next steps in the file. </span><span class="koboSpan" id="kobo.685.2">A job named </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">Setup, Build,</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.687.1">and Deploy</span></strong><span class="koboSpan" id="kobo.688.1"> is then created that specifies the operating system, which is Ubuntu in our case. </span><span class="koboSpan" id="kobo.688.2">The job consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">four steps:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.690.1">Checkout</span></strong><span class="koboSpan" id="kobo.691.1">: Checks out code from the GitHub branch that was </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">specified earlier.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.693.1">Set up the gcloud CLI</span></strong><span class="koboSpan" id="kobo.694.1">: Sets up </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">gcloud</span></strong><span class="koboSpan" id="kobo.696.1"> and authenticates using the service account </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">credentials file.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.698.1">Build</span></strong><span class="koboSpan" id="kobo.699.1">: Builds the Docker image and pushes it to GCR using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">gcloud submit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.702.1">Deploy the image to Cloud Run</span></strong><span class="koboSpan" id="kobo.703.1">: Deploys the Docker image created in the preceding step to </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">Cloud Run.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.705.1">Now, just commi</span><a id="_idTextAnchor717"/><span class="koboSpan" id="kobo.706.1">t and push your code to the </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">relevant branch.</span></span></p>
<h2 id="_idParaDest-374"><a id="_idTextAnchor718"/><span class="koboSpan" id="kobo.708.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.709.1">When the code is pushed to GitHub on the correct branch, the GitHub action is triggered. </span><span class="koboSpan" id="kobo.709.2">A successful GitHub action looks </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.711.1"><img alt="Figure 12.7 – Successful GitHub action execution" src="image/B19111_12_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.712.1">Figure 12.7 – Successful GitHub action execution</span></p>
<p><span class="koboSpan" id="kobo.713.1">To see your </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.714.1">application running, copy the service </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.715.1">URL, as shown in the preceding screenshot, and open it in </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">your browser.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.717.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.718.1">If you have followed this book since the beginning, this recipe would be a good place to think about how all the major pieces fall into place to complete the puzzle. </span><span class="koboSpan" id="kobo.718.2">We learned about creating a Flask application, then built more complexity into it, which was followed by unit test cases and, last but not </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">least, deployment.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.720.1">In this recipe, we automated </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.721.1">deployment on code commits known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.722.1">continuous deployment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.724.1">You can also modify </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.725.1">your GitHub workflow to run test cases before building the image and exit on </span><a id="_idTextAnchor719"/><span class="koboSpan" id="kobo.726.1">failure. </span><span class="koboSpan" id="kobo.726.2">This is called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.727.1">continuous integration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">.</span></span></p>
<h2 id="_idParaDest-375"><a id="_idTextAnchor720"/><span class="koboSpan" id="kobo.729.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.730.1">You can read more about GitHub Actions </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">at </span></span><a href="https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions"><span class="No-Break"><span class="koboSpan" id="kobo.732.1">https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.733.1">.</span></span></p>
</div>
</body></html>