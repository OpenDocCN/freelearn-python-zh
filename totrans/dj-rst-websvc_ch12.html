<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Working with Models, Migrations, Serialization, and Deserialization</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Models, Migrations, Serialization, and Deserialization</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will define the requirements for our first RESTful Web Service. We will start working with Django, Django REST framework, Python, configurations, models, migrations, serialization, and deserialization. We will create a RESTful Web Service that performs <strong>CRUD</strong> (short for <strong>Create</strong>, <strong>Read</strong>, <strong>Update</strong> and <strong>Delete</strong>) operations on a simple SQLite database. We will be:</p>
<ul>
<li>Defining the requirements for our first RESTful Web Service</li>
<li>Creating our first model</li>
<li>Running our initial migration</li>
<li>Understanding migrations</li>
<li>Analyzing the database</li>
<li>Understanding Django tables</li>
<li>Controlling, serialization, and deserialization</li>
<li>Working with the Django shell and diving deeply into serialization and deserialization</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining the requirements for our first RESTful Web Service</h1>
                </header>
            
            <article>
                
<p>Imagine a team of developers working on a mobile app for iOS and Android and requires a RESTful Web Service to perform CRUD operations with toys. We definitely don't want to use a mock web service and we don't want to spend time choosing and configuring an <strong>ORM</strong> (short for <strong>Object-Relational Mapping</strong>). We want to quickly build a RESTful Web Service and have it ready as soon as possible to start interacting with it in the mobile app.</p>
<p>We really want the toys to persist in a database but we don't need it to be production-ready. Therefore, we can use the simplest possible relational database, as long as we don't have to spend time performing complex installations or configurations.</p>
<p><strong>Django REST framework</strong>, also known as <strong>DRF</strong>, will allow us to easily accomplish this task and start making HTTP requests to the first version of our RESTful Web Service. In this case, we will work with a very simple SQLite database, the default database for a new Django REST framework project.</p>
<p>First, we must specify the requirements for our main resource: a toy. We need the following attributes or fields for a toy entity:</p>
<ul>
<li>An integer identifier</li>
<li>A name</li>
<li>An optional description</li>
<li>A toy category description, such as action figures, dolls, or playsets</li>
<li>A release date</li>
<li>A bool value indicating whether the toy has been on the online store's homepage at least once</li>
</ul>
<p>In addition, we want to have a timestamp with the date and time of the toy's addition to the database table, which will be generated to persist toys.</p>
<p>In a RESTful Web Service, each resource has its own unique URL. In our web service, each toy will have its own unique URL.</p>
<p>The following table shows the HTTP verbs, the scope, and the semantics of the methods that our first version of the web service must support. Each method is composed of an HTTP verb and a scope. All the methods have a well-defined meaning for toys and collections:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>HTTP verb</strong></p>
</td>
<td>
<p><strong>Scope</strong></p>
</td>
<td>
<p><strong>Semantics</strong></p>
</td>
</tr>
<tr>
<td>
<p>GET</p>
</td>
<td>
<p>Toy</p>
</td>
<td>
<p>Retrieve a single toy</p>
</td>
</tr>
<tr>
<td>
<p>GET</p>
</td>
<td>
<p>Collection of toys</p>
</td>
<td>
<p>Retrieve all the stored toys in the collection, sorted by their name in ascending order</p>
</td>
</tr>
<tr>
<td>
<p>POST</p>
</td>
<td>
<p>Collection of toys</p>
</td>
<td>
<p>Create a new toy in the collection</p>
</td>
</tr>
<tr>
<td>
<p>PUT</p>
</td>
<td>
<p>Toy</p>
</td>
<td>
<p>Update an existing toy</p>
</td>
</tr>
<tr>
<td>
<p>DELETE</p>
</td>
<td>
<p>Toy</p>
</td>
<td>
<p>Delete an existing toy</p>
</td>
</tr>
</tbody>
</table>
<p>&#160;</p>
<p>In the previous table, the GET HTTP verb appears twice but with two different scopes: toys and collection of toys. The first row shows a GET HTTP verb applied to a toy, that is, to a single resource. The second row shows a GET HTTP verb applied to a collection of toys, that is, to a collection of resources.</p>
<p>We want our web service to be able to differentiate collections from a single resource of the collection in the URLs. When we refer to a collection, we will use a slash (<kbd>/</kbd>) as the last character for the URL, as in <kbd>http://localhost:8000/toys/</kbd>. When we refer to a single resource of the collection we won't use a slash (<kbd>/</kbd>) as the last character for the URL, as in <kbd>http://localhost:8000/toys/5</kbd>.</p>
<p>Let's consider that <kbd>http://localhost:8000/toys/</kbd> is the URL for the collection of toys. If we add a number to the previous URL, we identify a specific toy with an ID or primary key equal to the specified numeric value. For example, <kbd>http://localhost:8000/toys/42</kbd> identifies the toy with an ID equal to <kbd>42</kbd>.</p>
<p>We have to compose and send an HTTP request with the&#160;<kbd>POST</kbd>&#160;<span>HTTP verb</span> and <kbd>http://localhost:8000/toys/</kbd>&#160;<span>request URL</span> to create a new toy and add it to the toys collection. In this example, our RESTful Web Service will work with <strong>JSON</strong> (short for <strong>JavaScript Object Notation</strong>), and therefore we have to provide the JSON&#160;key-value pairs with the field names and the values to create the new toy. As a result of the request, the server will validate the provided values for the fields, make sure that it is a valid toy, and persist it in the database. The server will insert a new row with the new toy in the appropriate table and it will return a <kbd>201 Created</kbd> status code and a JSON body with the recently added toy serialized to JSON, including the assigned ID that was automatically generated by the database and assigned to the toy object:</p>
<pre>POST http://localhost:8000/toys/ </pre>
<p>We have to compose and send an HTTP request with the <kbd>GET</kbd>&#160;<span>HTTP verb</span> and <kbd>http://localhost:8000/toys/{id}</kbd><span>&#160;request URL</span>&#160;to retrieve the toy whose ID matches the specified numeric value in&#160;<kbd>{id}</kbd>. For example, if we use the request URL <kbd>http://localhost:8000/toys/25</kbd>, the server will retrieve the toy whose ID matches <kbd>25</kbd>. As a result of the request, the server will retrieve a toy with the specified ID from the database and create the appropriate toy object in Python. If a toy is found, the server will serialize the toy object into JSON, return a <kbd>200 OK</kbd> status code, and return a JSON body with the serialized toy object. If no toy matches the specified ID, the server will return only a <kbd>404 Not Found</kbd> status:</p>
<pre>GET http://localhost:8000/toys/{id} </pre>
<p>We have to compose and send an HTTP request with the <kbd>PUT</kbd><span>&#160;HTTP verb</span> and request URL <kbd>http://localhost:8000/toys/{id}</kbd>&#160;to retrieve the toy whose ID matches the value in&#160;<kbd>{id}</kbd>&#160;and replace it with a toy created with the provided data. In addition, we have to provide the JSON key-value pairs with the field names and the values to create the new toy that will replace the existing one. As a result of the request, the server will validate the provided values for the fields, make sure that it is a valid toy, and replace the one that matches the specified ID with the new one in the database. The ID for the toy will be the same after the update operation. The server will update the existing row in the appropriate table and it will return a <kbd>200 OK</kbd> status code and a JSON body with the recently updated toy serialized to JSON. If we don't provide all the necessary data for the new toy, the server will return a <kbd>400 Bad Request</kbd> status code. If the server doesn't find a toy with the specified ID, the server will only return a <kbd>404 Not Found</kbd> status:</p>
<pre>PUT http://localhost:8000/toys/{id}</pre>
<p>We have to compose and send an HTTP request with the <kbd>DELETE&#160;</kbd><span>HTTP verb</span> and request URL <kbd>http://localhost:8000/toys/{id}</kbd>&#160;to remove the toy whose ID&#160;matches the specified numeric value in&#160;<kbd>{id}</kbd>. For example, if we use the request URL <kbd>http://localhost:8000/toys/34</kbd>, the server will delete the toy whose ID matches <kbd>34</kbd>. As a result of the request, the server will retrieve a toy with the specified ID from the database and create the appropriate toy object in Python. If a toy is found, the server will request the ORM delete the toy row associated with this toy object and the server will return a <kbd>204 No Content</kbd> status code. If no toy matches the specified ID, the server will return only a <kbd>404 Not Found</kbd> status:</p>
<pre>DELETE http://localhost:8000/toys/{id} </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating our first model</h1>
                </header>
            
            <article>
                
<p>Now, we will create a simple <kbd>Toy</kbd> model in Django, which we will use to represent and persist toys. Open the <kbd>toys/models.py</kbd> file. The following lines show the initial code for this file with just one <kbd>import</kbd> statement and a comment that indicates we should create the models:</p>
<pre>from django.db import models 
 
# Create your models here. </pre>
<p>The following lines show the new code that creates a <kbd>Toy</kbd> class, specifically, a <kbd>Toy</kbd> model in the <kbd>toys/models.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder in the <kbd>restful01/toys/models.py</kbd> file:</p>
<pre>from django.db import models 
 
 
class Toy(models.Model): 
    created = models.DateTimeField(auto_now_add=True) 
    name = models.CharField(max_length=150, blank=False, default='') 
    description = models.CharField(max_length=250, blank=True, default='') 
    toy_category = models.CharField(max_length=200, blank=False, default='') 
    release_date = models.DateTimeField() 
    was_included_in_home = models.BooleanField(default=False) 
 
    class Meta: 
        ordering = ('name',)</pre>
<p>The <kbd>Toy</kbd> class is a subclass of the <kbd>django.db.models.Model</kbd> class and defines the following attributes: <kbd>created</kbd>, <kbd>name</kbd>, <kbd>description</kbd>, <kbd>toy_category</kbd>, <kbd>release_date</kbd>,&#160;and <kbd>was_included_in_home</kbd>. Each of these attributes represents a database column or field.</p>
<div class="packt_tip">Django automatically adds an auto-increment integer primary key column named <kbd>id</kbd> when it creates the database table related to the model. It is very important to notice that the model maps the underlying <kbd>id</kbd> column in an attribute named <kbd>pk</kbd> for the model.</div>
<p>We specified the field types, maximum lengths, and defaults for many attributes. The class declares a <kbd>Meta</kbd> inner class that declares an <kbd>ordering</kbd> attribute and sets its value to a tuple of <kbd>string</kbd> whose first value is the <kbd>'name'</kbd> string. This way, the inner class indicates to Django that, by default, we want the results ordered by the <kbd>name</kbd> attribute in ascending order.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running our initial migration</h1>
                </header>
            
            <article>
                
<p>Now, it is necessary to create the initial migration for the new <kbd>Toy</kbd> model we recently coded. We will also synchronize the SQLite database for the first time. By default, Django uses the popular self-contained and embedded SQLite database, and therefore we don't need to make changes in the initial ORM configuration. In this example, we will be working with this default configuration. Of course, we will upgrade to another database after we have a sample web service built with Django. We will only use SQLite for this example.</p>
<p>We just need to run the following Python script in the virtual environment that we activated in the previous chapter. Make sure you are in the <kbd>restful01</kbd> folder within the main folder for the virtual environment when you run the following command:</p>
<pre>    <strong>python manage.py makemigrations toys</strong>  </pre>
<p>The following lines show the output generated after running the previous command:</p>
<pre>    <strong>Migrations for 'toys':</strong>
    <strong>  toys/migrations/0001_initial.py:</strong>
    <strong>    - Create model Toy</strong></pre>
<p>The output indicates that the <kbd>restful01/toys/migrations/0001_initial.py</kbd> file includes the code to create the <kbd>Toy</kbd> model. The following lines show the code for this file that was automatically generated by Django. The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder in the <kbd>restful01/toys/migrations/0001_initial.py</kbd> file:</p>
<pre># -*- coding: utf-8 -*- 
# Generated by Django 1.11.5 on 2017-10-08 05:19 
from __future__ import unicode_literals 
 
from django.db import migrations, models 
 
 
class Migration(migrations.Migration): 
 
    initial = True 
 
    dependencies = [ 
    ] 
 
    operations = [ 
        migrations.CreateModel( 
            name='Toy', 
            fields=[ 
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 
                ('created', models.DateTimeField(auto_now_add=True)), 
                ('name', models.CharField(default='', max_length=150)), 
                ('description', models.CharField(blank=True, default='', max_length=250)), 
                ('toy_category', models.CharField(default='', max_length=200)), 
                ('release_date', models.DateTimeField()), 
                ('was_included_in_home', models.BooleanField(default=False)), 
            ], 
            options={ 
                'ordering': ('name',), 
            }, 
        ), 
    ] </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding migrations</h1>
                </header>
            
            <article>
                
<p>The automatically generated code defines a subclass of the <kbd>django.db.migrations.Migration</kbd> class named <kbd>Migration</kbd>, which defines an operation that creates the <kbd>Toy</kbd> model's table and includes it in the <kbd>operations</kbd> attribute. The call to the <kbd>migrations.CreateModel</kbd> method specifies the model's name, the fields, and the options to instruct the ORM to create a table that will allow the underlying database to persist the model.</p>
<p>The <kbd>fields</kbd> argument is a list of tuples that includes information about the field name, the field type, and additional attributes based on the data we provided in our model, that is, in the <kbd>Toy</kbd> class.</p>
<p>Now, run the following Python script to apply all the generated migrations. Make sure you are in the <kbd>restful01</kbd> folder within the main folder for the virtual environment when you run the following command:</p>
<pre>    <strong>python manage.py migrate</strong></pre>
<p>The following lines show the output generated after running the previous command:</p>
<pre>    <strong>Operations to perform:</strong>
    <strong>  Apply all migrations: admin, auth, contenttypes, sessions, toys</strong>
    <strong>Running migrations:</strong>
    <strong>  Applying contenttypes.0001_initial... OK</strong>
    <strong>  Applying auth.0001_initial... OK</strong>
    <strong>  Applying admin.0001_initial... OK</strong>
    <strong>  Applying admin.0002_logentry_remove_auto_add... OK</strong>
    <strong>  Applying contenttypes.0002_remove_content_type_name... OK</strong>
    <strong>  Applying auth.0002_alter_permission_name_max_length... OK</strong>
    <strong>  Applying auth.0003_alter_user_email_max_length... OK</strong>
    <strong>  Applying auth.0004_alter_user_username_opts... OK</strong>
    <strong>  Applying auth.0005_alter_user_last_login_null... OK</strong>
    <strong>  Applying auth.0006_require_contenttypes_0002... OK</strong>
    <strong>  Applying auth.0007_alter_validators_add_error_messages... OK</strong>
    <strong>  Applying auth.0008_alter_user_username_max_length... OK</strong>
    <strong>  Applying sessions.0001_initial... OK</strong>
    <strong>  Applying toys.0001_initial... OK</strong>
  </pre>
<p>After we run the previous command, we will notice that the root folder for our <kbd>restful01</kbd> project now has a <kbd>db.sqlite3</kbd> file that contains the SQLite database. We can use the SQLite command line or any other application that allows us to easily check the contents of the SQLite database to check the tables that Django generated.</p>
<p>The first migration will generate many tables required by Django and its installed apps before running the code that creates the table for the <kbd>Toys</kbd> model. These tables provide support for user authentication, permissions, groups, logs, and migration management. We will work with the models related to these tables after we add more features and security to our web services.</p>
<p>After the migration process creates all these Django tables in the underlying database, the first migration runs the Python code that creates the table required to persist our model. Thus, the last line of the running migrations section displays <kbd>Applying toys.0001_initial</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Analyzing the database</h1>
                </header>
            
            <article>
                
<p>In most modern Linux distributions and macOS, SQLite is already installed, and therefore you can run the <kbd>sqlite3</kbd> command-line utility.</p>
<p>In Windows, if you want to work with the <kbd>sqlite3.exe</kbd> command-line utility, you have to download the bundle of command-line tools for managing SQLite database files from the downloads section of the SQLite webpage at&#160;<a href="http://www.sqlite.org/download.html"><span class="URLPACKT">http://www.sqlite.org/download.html</span></a>. For example, the ZIP file that includes the command-line tools for version 3.20.1 is <kbd>sqlite-tools-win32-x8 6-3200100.zip</kbd>. The name for the file changes with the SQLite version. You just need to make sure that you download the bundle of command-line tools and not the ZIP file that provides the SQLite DLLs. After you unzip the file, you can include the folder that includes the command-line tools in the PATH environment variable, or you can access the <kbd>sqlite3.exe</kbd> command-line utility by specifying the full path to it.</p>
<p>Run the following command to list the generated tables. The first argument, <kbd>db.sqlite3</kbd>, specifies the file that contains that SQLite database and the second argument indicates the command that we want the <kbd>sqlite3</kbd> command-line utility to run against the specified database:</p>
<pre>    <strong>sqlite3 db.sqlite3 ".tables"</strong> </pre>
<p>The following lines show the output for the previous command with the list of tables that Django generated in the SQLite database:</p>
<pre>    <strong>auth_group                  django_admin_log</strong>
    <strong>auth_group_permissions      django_content_type</strong>
    <strong>auth_permission             django_migrations</strong>
    <strong>auth_user                   django_session</strong>
    <strong>auth_user_groups            toys_toy</strong>
    <strong>auth_user_user_permissions</strong>  </pre>
<p>The following command will allow you to check the contents of the <kbd>toys_toy</kbd> table after we compose and send HTTP requests to the RESTful Web Service and the web service makes CRUD operations to the <kbd>toys_toy</kbd> table:</p>
<pre>    <strong>sqlite3 db.sqlite3 "SELECT * FROM toys_toy ORDER BY name;"</strong> </pre>
<p>Instead of working with the SQLite command-line utility, you can use a GUI tool to check the contents of the SQLite database. DB Browser for SQLite is a useful, free,&#160;<span>multiplatform</span>&#160;GUI tool that allows us to easily check the database contents of an SQLite database in Linux, macOS, and Windows. You can read more information about this tool and download its different versions from <a href="http://sqlitebrowser.org"><span class="URLPACKT">http://sqlitebrowser.org</span></a>. Once you have installed the tool, you just need to open the <kbd>db.sqlite3</kbd> file and you can check the database structure and browse the data for the different tables. After we start working with the first version of our web service, you need to check the contents of the <kbd>toys_toy</kbd> table with this tool.</p>
<div class="packt_tip">You can also&#160;<span>use</span>&#160;the database tools included with your favorite IDE to check the contents of the SQLite database.</div>
<p>The SQLite database engine and the database file name are specified in the <kbd>restful01/settings.py</kbd> Python file. The following lines show the declaration of the DATABASES dictionary, which contains the settings for all the databases that Django uses. The nested dictionary maps the database named <kbd>default</kbd> with the <kbd>django.db.backends.sqlite3</kbd> database engine and the <kbd>db.sqlite3</kbd> database file located in the <kbd>BASE_DIR</kbd> folder (<kbd>restful01</kbd>):</p>
<pre>DATABASES = { 
    'default': { 
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 
    } 
} </pre>
<p>After we execute the migrations, the SQLite database will have the following tables. Django uses prefixes to identify the modules and applications that each table belongs to. The tables that start with the <kbd>auth_</kbd> prefix belong to the Django authentication module. The table that starts with the <kbd>toys_</kbd> prefix belongs to our <kbd>toys</kbd> application. If we add more models to our <kbd>toys</kbd> application, Django will create new tables with the <kbd>toys_</kbd> prefix:</p>
<ul>
<li><kbd>auth_group</kbd>: Stores authentication groups</li>
<li><kbd>auth_group_permissions</kbd>: Stores permissions for authentication groups</li>
<li><kbd>auth_permission</kbd>: Stores permissions for authentication</li>
<li><kbd>auth_user</kbd>: Stores authentication users</li>
<li><kbd>auth_user_groups</kbd>: Stores authentication user groups</li>
<li><kbd>auth_user_groups_permissions</kbd>: Stores permissions for authentication user groups</li>
<li><kbd>django_admin_log</kbd>: Stores the Django administrator log</li>
<li><kbd>django_content_type</kbd>: Stores Django content types</li>
<li><kbd>django_migrations</kbd>: Stores the scripts generated by Django migrations and the date and time at which they were applied</li>
<li><kbd>django_session</kbd>: Stores Django sessions</li>
<li><kbd>toys_toy</kbd>: Persists the <kbd>Toys</kbd> model</li>
<li><kbd>sqlite_sequence</kbd>: Stores sequences for SQLite primary keys with autoincrement fields</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the table generated by Django</h1>
                </header>
            
            <article>
                
<p>The <kbd>toys_toy</kbd> table persists in the database the <kbd>Toy</kbd> class we recently created, specifically, the <kbd>Toy</kbd> model. Django's integrated ORM generated the <kbd>toys_toy</kbd> table based on our <kbd>Toy</kbd> model.</p>
<p>Run the following command to retrieve the SQL used to create the <kbd>toys_toy</kbd> table:</p>
<pre>    <strong>sqlite3 db.sqlite3 ".schema toys_toy"</strong></pre>
<p>The following lines show the output for the previous command together with the SQL that the migrations process executed, to create the <kbd>toys_toy</kbd> table that persists the <kbd>Toy</kbd> model. The next lines are formatted to make it easier to understand the SQL code. Notice that the output from the command is formatted in a different way:</p>
<pre>    <strong>CREATE TABLE IF NOT EXISTS "toys_toy" </strong>
    <strong>(</strong>
    <strong>    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,</strong>
    <strong>    "created" datetime NOT NULL, </strong>
    <strong>    "name" varchar(150) NOT NULL, </strong>
    <strong>    "description" varchar(250) NOT NULL, </strong>
    <strong>    "toy_category" varchar(200) NOT NULL, </strong>
    <strong>    "release_date" datetime NOT NULL, </strong>
    <strong>    "was_included_in_home" bool NOT NULL</strong>
    <strong>);</strong>
  </pre>
<p>The <kbd>toys_toy</kbd> table has the following columns (also known as fields) with their SQLite types, all of them not nullable:</p>
<ul>
<li><kbd>id</kbd>: The integer primary key, an autoincrement row</li>
<li><kbd>created</kbd>: DateTime</li>
<li><kbd>name</kbd>: varchar(150)</li>
<li><kbd>description</kbd>: varchar(250)</li>
<li><kbd>toy_category</kbd>: varchar(200)</li>
<li><kbd>release_date</kbd>: DateTime</li>
<li><kbd>was_included_in_home</kbd>: bool</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling, serialization, and deserialization</h1>
                </header>
            
            <article>
                
<p>Our RESTful Web Service has to be able to serialize and deserialize the <kbd>Toy</kbd> instances into JSON representations. In Django REST framework, we just need to create a serializer class for the <kbd>Toy</kbd> instances to manage serialization to JSON and deserialization from JSON. Now, we will dive deep into the serialization and deserialization process in Django REST framework. It is very important to understand how it works because it is one of the most important components for all the RESTful Web Services we will build.</p>
<p>Django REST framework uses a two-phase process for serialization. The serializers are mediators between the model instances and Python primitives. Parser and renderers handle as mediators between Python primitives and HTTP requests and responses. We will configure our mediator between the <kbd>Toy</kbd> model instances and Python primitives by creating a subclass of the <kbd>rest_framework.serializers.Serializer</kbd> class to declare the fields and the necessary methods to manage serialization and deserialization.</p>
<p>We will repeat some of the information about the fields that we have included in the <kbd>Toy</kbd> model so that we understand all the things that we can configure in a subclass of the <kbd>Serializer</kbd> class. However, we will work with shortcuts, which will reduce boilerplate code later in the following examples. We will write less code in the following examples by using the <kbd>ModelSerializer</kbd> class.</p>
<p>Now, go to the <kbd>restful01/toys</kbd> folder and create a new Python code file named <kbd>serializers.py</kbd>. The following lines show the code that declares the new <kbd>ToySerializer</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder in the <kbd>restful01/toys/</kbd><kbd>serializers.py</kbd> file:</p>
<pre>from rest_framework import serializers 
from toys.models import Toy 
 
 
class ToySerializer(serializers.Serializer): 
    pk = serializers.IntegerField(read_only=True) 
    name = serializers.CharField(max_length=150) 
    description = serializers.CharField(max_length=250) 
    release_date = serializers.DateTimeField() 
    toy_category = serializers.CharField(max_length=200) 
    was_included_in_home = serializers.BooleanField(required=False) 
 
    def create(self, validated_data): 
        return Toy.objects.create(**validated_data) 
 
    def update(self, instance, validated_data): 
        instance.name = validated_data.get('name', instance.name)         
        instance.description = validated_data.get('description', instance.description) 
        instance.release_date = validated_data.get('release_date', instance.release_date) 
        instance.toy_category = validated_data.get('toy_category', instance.toy_category) 
        instance.was_included_in_home = validated_data.get('was_included_in_home', instance.was_included_in_home) 
        instance.save() 
        return instance </pre>
<p>The <kbd>ToySerializer</kbd> class declares the attributes that represent the fields that we want to be serialized. Notice that we have omitted the <kbd>created</kbd> attribute that was present in the <kbd>Toy</kbd> model. When there is a call to the&#160;<kbd>save</kbd> method that <kbd>ToySerializer</kbd> inherits from the <kbd>serializers.Serializer</kbd> superclass, the overridden <kbd>create</kbd> and <kbd>update</kbd> methods define how to create a new instance or update an existing instance. In fact, these methods must be implemented in our class because they only raise a <kbd>NotImplementedError</kbd> exception in their base declaration in the <kbd>serializers.Serializer</kbd> superclass.</p>
<p>The <kbd>create</kbd> method receives the validated data in the <kbd>validated_data</kbd> argument. The code creates and returns a new <kbd>Toy</kbd> instance based on the received validated data.</p>
<p>The <kbd>update</kbd> method receives an existing <kbd>Toy</kbd> instance that is being updated and the new validated data in the <kbd>instance</kbd> and <kbd>validated_data</kbd> arguments. The code updates the values for the attributes of the instance with the updated attribute values retrieved from the validated data. Finally, the code calls the <kbd>save</kbd> method for the updated <kbd>Toy</kbd> instance and returns the updated and saved instance.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with the Django shell and diving deeply into serialization and deserialization</h1>
                </header>
            
            <article>
                
<p>We can launch our default Python interactive shell in our virtual environment and make all the Django project modules available before it starts. This way, we can check that the serializer works as expected. We will do this to understand how serialization works in Django.</p>
<p>Run the following command to launch the interactive shell. Make sure you are within the <kbd>restful01</kbd> folder in the terminal, Command Prompt, or Windows Powershell:</p>
<pre><strong>python manage.py shell</strong></pre>
<p>You will notice a line that says <kbd>(InteractiveConsole)</kbd> is displayed after the usual lines that introduce your default Python interactive shell. The following screenshot shows the Django shell launched in a Windows command prompt:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/c9ec6e74-4bbd-4c0a-9178-4c81bd2d1b33.png"/></div>
<p>Enter the following code in the Python interactive shell to import all the things we will need to test the <kbd>Toy</kbd> model and its serializer. The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder, in the <kbd>restful01/toy_serializers_test_01.py</kbd> file:</p>
<pre>from datetime import datetime 
from django.utils import timezone 
from django.utils.six import BytesIO 
from rest_framework.renderers import JSONRenderer 
from rest_framework.parsers import JSONParser 
from toys.models import Toy 
from toys.serializers import ToySerializer </pre>
<p>Enter the following code to create two instances of the <kbd>Toy</kbd> model and save them. The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder, in the <kbd>restful01/toy_serializers_test_01.py</kbd> file:</p>
<pre>toy_release_date = timezone.make_aware(datetime.now(), timezone.get_current_timezone()) 
toy1 = Toy(name='Snoopy talking action figure', description='Snoopy speaks five languages', release_date=toy_release_date, toy_category='Action figures', was_included_in_home=False) 
toy1.save() 
toy2 = Toy(name='Hawaiian Barbie', description='Barbie loves Hawaii', release_date=toy_release_date, toy_category='Dolls', was_included_in_home=True) 
toy2.save() </pre>
<p>After we execute the preceding code, we can check the SQLite database with the previously introduced command-line or GUI tools to check the contents of the <kbd>toys_toy</kbd> table. We will notice the table has two rows and columns with the values we have provided to the different attributes of the <kbd>Toy</kbd> instances. The following screenshot shows the results of browsing the data of the <kbd>toys_toy</kbd> table with the DB Browser for SQLite GUI utility. We can see that two rows were inserted.</p>
<p>Enter the following code in the interactive shell to check the values for the primary keys or identifiers for the saved <kbd>Toy</kbd> instances, and the value of their <kbd>name</kbd> and <kbd>was_included_in_home_attribute</kbd> attributes. The code also checks the value of the <kbd>created</kbd> attribute, which includes the date and time at which Django saved each instance to the database. The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder, in the <kbd>restful01/toy_serializers_test_01.py</kbd> file:</p>
<pre>print(toy1.pk) 
print(toy1.name) 
print(toy1.created) 
print(toy1.was_included_in_home) 
print(toy2.pk) 
print(toy2.name) 
print(toy2.created) 
print(toy2.was_included_in_home)</pre>
<p>The following screenshot shows sample results of the previously shown code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="125" width="553" class="image-border" src="images/9c6597cc-6372-4109-9ce0-0103b525bd4b.png"/></div>
<p>Now, let's write the following code to serialize the first <kbd>Toy</kbd> instance (<kbd>toy1</kbd>). The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder, in the <kbd>restful01/toy_serializers_test_01.py</kbd> file:</p>
<pre>serializer_for_toy1 = ToySerializer(toy1) 
print(serializer_for_toy1.data) </pre>
<p>The following lines show the generated dictionary, specifically, a <kbd>rest_framework.utils.serializer_helpers.ReturnDict</kbd> instance, stored in the <kbd>serializer_for_toy1.data</kbd> attribute. The next lines show the results with easily understood formatting:</p>
<pre>    <strong>{</strong>
    <strong>    'pk': 1, </strong>
    <strong>    'name': 'Snoopy talking action figure', </strong>
    <strong>    'description': 'Snoopy speaks five languages', </strong>
    <strong>    'release_date': '2017-10-09T12:11:37.090335Z', </strong>
    <strong>    'toy_category': 'Action figures', </strong>
    <strong>    'was_included_in_home': False</strong>
    <strong>}</strong></pre>
<p>Now, let's serialize the second <kbd>Toy</kbd> instance (<kbd>toy2</kbd>). The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder, in the <kbd>restful01/toy_serializers_test_01.py</kbd> file:</p>
<pre>serializer_for_toy2 = ToySerializer(toy2) 
print(serializer_for_toy2.data)</pre>
<p>The following lines show the generated dictionary stored in the <kbd>serializer_for_toy2.data</kbd> attribute. The next lines show the results with easily understood formatting:</p>
<pre>    <strong>{</strong>
    <strong>    'pk': 2, </strong>
    <strong>    'name': 'Hawaiian Barbie', </strong>
    <strong>    'description': 'Barbie loves Hawaii', </strong>
    <strong>    'release_date': '2017-10-09T12:11:37.090335Z', </strong>
    <strong>    'toy_category': 'Dolls', </strong>
    <strong>    'was_included_in_home': True</strong>
    <strong>}</strong>  </pre>
<p>We can easily render the dictionaries held in the <kbd>data</kbd> attribute into JSON with the help of the <kbd>rest_framework.renderers.JSONRenderer</kbd> class. The following lines create an instance of this class and then call the <kbd>render</kbd> method to render the dictionaries held in the <kbd>data</kbd> attribute into JSON. The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder, in the <kbd>restful01/toy_serializers_test_01.py</kbd> file:</p>
<pre>json_renderer = JSONRenderer() 
toy1_rendered_into_json = json_renderer.render(serializer_for_toy1.data) 
toy2_rendered_into_json = json_renderer.render(serializer_for_toy2.data) 
print(toy1_rendered_into_json) 
print(toy2_rendered_into_json) </pre>
<p>The following lines show the output generated from the two calls to the <kbd>render</kbd> method:</p>
<pre>    <strong>b'{"pk":1,"name":"Snoopy talking action figure","description":"Snoopy speaks five languages","release_date":"2017-10-09T12:11:37.090335Z","toy_category":"Action figures","was_included_in_home":false}'</strong>
    <strong>&gt;&gt;&gt; print(toy2_rendered_into_json)</strong>
    <strong>b'{"pk":2,"name":"Hawaiian Barbie","description":"Barbie loves Hawaii","release_date":"2017-10-09T12:11:37.090335Z","toy_category":"Dolls","was_included_in_home":true}'</strong>  </pre>
<p>Now, we will work in the opposite direction: from serialized data to the population of a <kbd>Toy</kbd> instance. The following lines generate a new <kbd>Toy</kbd> instance from a JSON string (serialized data), that is, the code deserializes and parses the data. The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder, in the <kbd>restful01/toy_serializers_test_01.py</kbd> file:</p>
<pre>json_string_for_new_toy = '{"name":"Clash Royale play set","description":"6 figures from Clash Royale", "release_date":"2017-10-09T12:10:00.776594Z","toy_category":"Playset","was_included_in_home":false}' 
json_bytes_for_new_toy = bytes(json_string_for_new_toy, encoding="UTF-8") 
stream_for_new_toy = BytesIO(json_bytes_for_new_toy) 
parser = JSONParser() 
parsed_new_toy = parser.parse(stream_for_new_toy) 
print(parsed_new_toy) </pre>
<p>The first line creates a new string with the JSON that defines a new toy (<kbd>json_string_for_new_toy</kbd>). The next line converts the string to <kbd>bytes</kbd> and saves the results of the conversion in the <kbd>json_bytes_for_new_toy</kbd> variable. The <kbd>django.utils.six.BytesIO</kbd> class provides a buffered I/O implementation using an in-memory bytes buffer. The code uses this class to create a stream from the previously generated JSON bytes with the serialized data, <kbd>json_bytes_for_new_toy</kbd>, and saves the generated stream instance in the <kbd>stream_for_new_toy</kbd> variable.</p>
<p>We can easily deserialize and parse a stream into a Python model with the help of the <kbd>rest_framework.parsers.JSONParser</kbd> class. The next line creates an instance of this class and then calls the <kbd>parse</kbd> method with <kbd>stream_for_new_toy</kbd> as an argument, parses the stream into Python native datatypes, and saves the results in the <kbd>parsed_new_toy</kbd> variable.</p>
<p>After executing the previous lines, <kbd>parsed_new_toy</kbd> holds a Python dictionary, parsed from the stream. The following lines show the output generated after executing the preceding code snippet. The next lines show the results with easily understood formatting:</p>
<pre>  <strong>     <strong>{</strong>
    </strong>
    <strong>
      <strong>    'name': 'Clash Royale play set', </strong>
    </strong>
    <strong>
      <strong>    'description': '6 figures from Clash Royale', </strong>
    </strong>
    <strong>
      <strong>    'release_date': '2017-10-09T12:10:00.776594Z', </strong>
    </strong>
    <strong>
      <strong>    'toy_category': 'Playset', </strong>
    </strong>
    <strong>
      <strong>    'was_included_in_home': False</strong>
    </strong>
    <strong>
      <strong>}</strong></strong> </pre>
<p>The following lines use the <kbd>ToySerializer</kbd> class to generate a fully populated <kbd>Toy</kbd> instance named <kbd>toy3</kbd> from the Python dictionary, parsed from the stream. The code file for the sample is included in the <kbd>hillar_django_restful_02_01</kbd> folder, in the <kbd>restful01/toy_serializers_test_01.py</kbd> file:</p>
<pre>new_toy_serializer = ToySerializer(data=parsed_new_toy) 
if new_toy_serializer.is_valid(): 
    toy3 = new_toy_serializer.save() 
    print(toy3.name)</pre>
<p>First, the code creates an instance of the <kbd>ToySerializer</kbd> class with the Python dictionary that we previously parsed from the stream (<kbd>parsed_new_toy</kbd>) passed as the <kbd>data</kbd> keyword argument. Then, the code calls the <kbd>is_valid</kbd> method to check whether the data is valid.</p>
<div class="packt_tip">Note that we must always call <kbd>is_valid</kbd> before we attempt to access the serialized data representation when we pass a <kbd>data</kbd> keyword argument in the creation of a serializer.</div>
<p>If the method returns <kbd>true</kbd>, we can access the serialized representation in the <kbd>data</kbd> attribute, and therefore, the code calls the <kbd>save</kbd> method that persists the new instance. In this case, it is a new <kbd>Toy</kbd> instance, and therefore the code to the <kbd>save</kbd> method inserts the corresponding row in the database and returns a fully populated <kbd>Toy</kbd> instance, saved in the <kbd>toy3</kbd> local variable. Then, the code prints one of the attributes from the fully populated <kbd>Toy</kbd> instance. After executing the previous code, we fully populated a new <kbd>Toy</kbd> instance: <kbd>toy3</kbd>.</p>
<div class="packt_tip">As we can see from the previous code, Django REST framework makes it easy to serialize from objects to JSON and deserialize from JSON to objects, which are core requirements for our RESTful Web Service that has to perform CRUD operations.</div>
<p>Enter the following command to leave the Django shell with the Django project modules that we loaded to test serialization and deserialization:</p>
<pre><strong>quit()</strong> </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<ol>
<li>In Django REST framework, serializers are:
<ol>
<li>Mediators between the view functions and Python primitives</li>
<li>Mediators between the URLs and view functions</li>
<li>Mediators between the model instances and Python primitives</li>
</ol>
</li>
<li>If we want to create a simple <kbd>Toy</kbd> model that we will use to represent and persist toys in Django REST framework, we can create:
<ol>
<li>&#160;A <kbd>Toy</kbd> class as a subclass of the <kbd>djangorestframework.models.Model</kbd> class</li>
<li>&#160;A <kbd>Toy</kbd> class as a subclass of the <kbd>django.db.models.Model</kbd> class</li>
<li>&#160;A <kbd>Toy</kbd> function in the <kbd>restframeworkmodels.py</kbd> file</li>
</ol>
</li>
</ol>
<ol start="3">
<li>In Django REST framework, parsers and renderers:
<ol>
<li>Handle as mediators between model instances and Python primitives</li>
<li>Handle as mediators between Python primitives and HTTP requests and responses</li>
<li>Handle as mediators between the view functions and Python primitives.</li>
</ol>
</li>
<li>Which of the following commands starts the Django shell?
<ol>
<li><kbd>python manage.py shell</kbd></li>
<li><kbd>python django.py shell</kbd></li>
<li><kbd>django shell</kbd></li>
</ol>
</li>
<li>If we have a Django application named <kbd>computers</kbd> and a model called <kbd>memory</kbd>, what is the name of the table that Django's ORM will create to persist the model in the database?
<ol>
<li><kbd>computers_memories</kbd></li>
<li><kbd>memory_computers</kbd></li>
<li><kbd>computers_memory</kbd></li>
</ol>
</li>
</ol>
<p>&#160;</p>
<p><span>The rights answers are included in the <a href="dj-rst-websvc_ch19.html" target="_blank">Appendix</a>,&#160;<em>Solutions</em>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we designed a RESTful Web Service to interact with a simple SQLite database and perform CRUD operations with toys. We defined the requirements for our web service and we understood the tasks performed by each HTTP method and the different scopes.</p>
<p>We created a model to represent and persist toys, and we executed migrations in Django to create the required tables in an SQLite database. We analyzed the tables that Django generated. We learned to manage serialization of toy instances into JSON representations with Django REST framework and the reverse process.</p>
<p>Now that we understand models, migrations, serialization, and deserialization with Django and Django REST framework, we will create Django views combined with serializer classes and start making HTTP requests to our web service. We will cover these topics in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>, <em>Creating API Views</em>.</p>
<p class="mce-root"></p>


            </article>

            
        </section>
    </div>
</body>
</html>