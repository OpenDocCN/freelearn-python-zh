["```py\nimport cv2 \n```", "```py\nimage = cv2.imread('image_1.jpg')\n```", "```py\ncv2.imshow(\"Original\", image) \n```", "```py\ncv2.waitKey(0) \n```", "```py\ncv2.imwrite(\"Saved Image.jpg\", image) \n```", "```py\nimport cv2 \n```", "```py\nimage = cv2.imread('image_2.jpg')\n```", "```py\ncv2.imshow(\"Original\", image) \n```", "```py\ncv2.waitKey(0) \n```", "```py\n# cv2.flip is used to flip images \n# Horizontal flipping of images using value '1' \nflipping = cv2.flip(image, 1) \n```", "```py\n# Display horizontally flipped image \ncv2.imshow(\"Horizontal Flipping\", flipping) \n```", "```py\ncv2.waitKey(0) \n```", "```py\n# Vertical flipping of images using value '0' \nflipping = cv2.flip(image, 0) \n```", "```py\ncv2.imshow(\"Vertical Flipping\", flipping) \n```", "```py\ncv2.waitKey(0) \n```", "```py\n# Horizontal & Vertical flipping of images using value '-1' \nflipping = cv2.flip(image, -1) \n# Display horizontally & vertically flipped image \ncv2.imshow(\"Horizontal & Vertical Flipping\", flipping) \n# Wait until any key is pressed \ncv2.waitKey(0)\n```", "```py\n# Close all windows \ncv2.destroyAllWindows() \n```", "```py\n# Scaling (Resizing) Images - Cubic, Area, Linear Interpolations \n# Interpolation is a method of estimating values between known data points  \n# Import Computer Vision package - cv2 \nimport cv2 \n# Import Numerical Python package - numpy as np \nimport numpy as np \n```", "```py\nimage = cv2.imread('image_3.jpg') \n```", "```py\ncv2.imshow(\"Original\", image) \n```", "```py\ncv2.waitKey() \n```", "```py\n# cv2.resize(image, output image size, x scale, y scale, interpolation) \n```", "```py\n# Scaling using cubic interpolation \nscaling_cubic = cv2.resize(image, None, fx=.75, fy=.75, interpolation = cv2.INTER_CUBIC) \n```", "```py\n# Display cubic interpolated image \ncv2.imshow('Cubic Interpolated', scaling_cubic) \n```", "```py\ncv2.waitKey()\n```", "```py\n# Scaling using area interpolation \nscaling_skewed = cv2.resize(image, (600, 300), interpolation = cv2.INTER_AREA) \n```", "```py\n# Display area interpolated image \ncv2.imshow('Area Interpolated', scaling_skewed)  \n```", "```py\n# Wait until any key is pressed \ncv2.waitKey() \n```", "```py\n# Scaling using linear interpolation \nscaling_linear  = cv2.resize(image, None, fx=0.5, fy=0.5, interpolation = cv2.INTER_LINEAR) \n```", "```py\n# Display linear interpolated image \ncv2.imshow('Linear Interpolated', scaling_linear)  \n```", "```py\ncv2.waitKey() \n```", "```py\n# Close all windows \ncv2.destroyAllWindows() \n```", "```py\nimport cv2 \n```", "```py\nimport numpy as np \n```", "```py\nimage = cv2.imread('image_4.jpg')\n```", "```py\ncv2.imshow(\"Original\", image) \n```", "```py\ncv2.waitKey(0) \n```", "```py\n# np.ones(shape, dtype) \n# 5 x 5 is the dimension of the kernel, uint8: is an unsigned integer (0 to 255) \nkernel = np.ones((5,5), dtype = \"uint8\") \n```", "```py\n# cv2.erode(image, kernel, iterations) \nerosion = cv2.erode(image, kernel, iterations = 1) \n```", "```py\ncv2.imshow(\"Erosion\", erosion) \n```", "```py\ncv2.waitKey(0) \n```", "```py\n# cv2.dilate(image, kernel, iterations) \ndilation = cv2.dilate(image, kernel, iterations = 1) \n```", "```py\ncv2.imshow(\"Dilation\", dilation) \n```", "```py\ncv2.waitKey(0) \n```", "```py\ncv2.destroyAllWindows()\n```", "```py\nimport cv2 \n# Import Numerical Python package - numpy as np \nimport numpy as np \n```", "```py\nimage = cv2.imread('image_5.jpg') \n```", "```py\ncv2.imshow(\"Original\", image) \n```", "```py\ncv2.waitKey(0) \n```", "```py\n# cv2.Canny is the built-in function used to detect edges \n# cv2.Canny(image, threshold_1, threshold_2) \ncanny = cv2.Canny(image, 50, 200) \n```", "```py\ncv2.imshow(\"Canny Edge Detection\", canny) \n```", "```py\ncv2.waitKey(0)\n```", "```py\n# cv2.findContours is the built-in function to find contours \n# cv2.findContours(canny, contour retrieval mode, contour approximation mode) \n# contour retrieval mode: cv2.RETR_LIST (retrieves all contours)  \n# contour approximation mode: cv2.CHAIN_APPROX_NONE (stores all boundary points) \ncontours, hierarchy = cv2.findContours(canny, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) \n```", "```py\n# cv2.drawContours is the built-in function to draw contours \n# cv2.drawContours(image, contours, index of contours, color, thickness) \ncv2.drawContours(image, contours, -1, (255,0,0), 10) \n# index of contours = -1 will draw all the contours \n```", "```py\n# Display contours using imshow built-in function \ncv2.imshow(\"Contours\", image) \n```", "```py\ncv2.waitKey() \n```", "```py\n# Close all windows \ncv2.destroyAllWindows() \n```", "```py\nimport cv2 \n# Import Numerical Python package - numpy as np \nimport numpy as np \n```", "```py\nimage = cv2.imread('image_6.jpg') \n```", "```py\ncv2.imshow(\"Original\", image) \n```", "```py\ncv2.waitKey(0) \n```", "```py\n# Blurring images: Averaging, cv2.blur built-in function \n# Averaging: Convolving image with normalized box filter \n# Convolution: Mathematical operation on 2 functions which produces third function. \n# Normalized box filter having size 3 x 3 would be: \n# (1/9)  [[1, 1, 1], \n#         [1, 1, 1], \n#         [1, 1, 1]] \nblur = cv2.blur(image,(9,9)) # (9 x 9) filter is used  \n```", "```py\ncv2.imshow('Blurred', blur) \n```", "```py\ncv2.waitKey(0)\n```", "```py\n# Sharpening images: Emphasizes edges in an image \nkernel = np.array([[-1,-1,-1],  \n                   [-1,9,-1],  \n                   [-1,-1,-1]]) \n# If we don't normalize to 1, image would be brighter or darker respectively     \n# cv2.filter2D is the built-in function used for sharpening images \n# cv2.filter2D(image, ddepth, kernel) \n# ddepth = -1, sharpened images will have same depth as original image \nsharpened = cv2.filter2D(image, -1, kernel) \n```", "```py\ncv2.imshow('Sharpened', sharpened) \n```", "```py\ncv2.waitKey(0) \n```", "```py\n# Close all windows \ncv2.destroyAllWindows() \n```", "```py\nimport sys \nimport cv2 \nimport numpy as np \n```", "```py\nin_file = sys.argv[1] \nimage = cv2.imread(in_file, cv2.IMREAD_GRAYSCALE) \n```", "```py\nhorizontal_sobel = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=5) \nvertical_sobel = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=5) \nlaplacian_img = cv2.Laplacian(image, cv2.CV_64F) \ncanny_img = cv2.Canny(image, 30, 200) \n```", "```py\ncv2.imshow('Original', image) \ncv2.imshow('horizontal Sobel', horizontal_sobel) \ncv2.imshow('vertical Sobel', vertical_sobel) \ncv2.imshow('Laplacian image', laplacian_img) \ncv2.imshow('Canny image', canny_img) \n```", "```py\ncv2.waitKey() \n```", "```py\ncv2.imshow('Original', image) \ncv2.imshow('horizontal Sobel', horizontal_sobel) \ncv2.imshow('vertical Sobel', vertical_sobel) \ncv2.imshow('Laplacian image', laplacian_img) \ncv2.imshow('Canny image', canny_img) \n```", "```py\ncv2.waitKey()\n```", "```py\nimport sys \nimport cv2 \nimport numpy as np \n```", "```py\nin_file = sys.argv[1] \nimage = cv2.imread(in_file) \n```", "```py\nimage_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) \ncv2.imshow('Input grayscale image', image_gray) \n```", "```py\nimage_gray_histoeq = cv2.equalizeHist(image_gray) \ncv2.imshow('Histogram equalized - grayscale image', image_gray_histoeq) \n```", "```py\nimage_yuv = cv2.cvtColor(image, cv2.COLOR_BGR2YUV) \nimage_yuv[:,:,0] = cv2.equalizeHist(image_yuv[:,:,0]) \nimage_histoeq = cv2.cvtColor(image_yuv, cv2.COLOR_YUV2BGR) \n```", "```py\ncv2.imshow('Input image', image) \ncv2.imshow('Histogram equalized - color image', image_histoeq) \ncv2.waitKey()\n```", "```py\nimport sys \nimport cv2 \nimport numpy as np \n```", "```py\nin_file = sys.argv[1] \nimage = cv2.imread(in_file) \ncv2.imshow('Input image', image) \nimage_gray1 = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) \nimage_gray2 = np.float32(image_gray1) \n```", "```py\nimage_harris1 = cv2.cornerHarris(image_gray2, 7, 5, 0.04) \n```", "```py\nimage_harris2 = cv2.dilate(image_harris1, None) \n```", "```py\nimage[image_harris2 > 0.01 * image_harris2.max()] = [0, 0, 0] \n```", "```py\ncv2.imshow('Harris Corners', image) \n```", "```py\ncv2.waitKey() \n```"]