- en: Completing the Application, Embedded Devices, and Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will complete this book. All of the main GUI elements that can
    be used at the start of development practice are described. Of course, the Qt
    library has more than 1,500 classes, and tools may vary depending on the GUI application
    tasks. However, the implementation principles are similar and the reader can implement
    them with ease. Within this book, we have created and demonstrated an application
    that provides the most useful functionality, and this chapter will pack this GUI
    app for presentation. We will also discuss mechanisms for realizing the GUI on
    the different devices and platforms and, where possible, without additional modifications.
    Qt currently supports the most popular and modern platforms and provides additional
    mechanisms for deploying the application with embedded devices. In addition, we
    will cover classes for implementing unit testing of Qt-based applications and
    libraries, using Qt library tools. This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Completing the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the application, we need to run the `u_app.py` file and look at
    what sections/features are not completed. As we can see, some options in the top
    panel bar have not been completed, so let's do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e90404c-b505-4b35-8664-720fbc51fd0f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we have `Edit`, `Options`, `Help` and `Visualization`
    options which will be constructed as we proceed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Edit option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Edit` option in the top panel is usually used for editing some text in
    the text edit fields with simple operations such as undoing/redoing previous operations,
    cutting selected text from the text field, and copying and pasting to/from the
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the editing options are standard and replicate the option of the default
    popups, but we add the `Alignment` option with a sub-menu and font/color changing
    options for the text of the text edit field. First of all, open the `u_window.py`
    files and add/change the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add new options to the `Edit` menu and add a sub-menu, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `"&Alignment"` option is added as a sub-menu of the `Edit` option. Options
    in terms of color and font of the selected text in the text field are also added.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to make some additions/changes to the `UApp` class of the `u_app.py`
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make some changes to the signals of the `UApp` class for the `Edit` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Edit` option (`self.mb2`) will connect the `triggered()` signal to the
    `edit()` function, and the `Alignment` sub-menu option will connect to the `edit_align()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `edit()` function to the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function will operate with simple edit options and incorporate functionality
    for changing the font/color of the selected text in the text edit field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `edit_align()` function to the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In connection with this option, the text alignment of the text edit field will
    be changed with the `Alignment` flag of the `Qt` namespace of the `QtCore` module.
  prefs: []
  type: TYPE_NORMAL
- en: The Options option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next option is a `Run` sub-option. This can realize some functionality
    of the Python standard library in that part of script execution straight from
    the text edit field. This will demonstrate the essence of the Python interpreter
    very clearly. We will save the content of the text field to the file and run with
    it using the `subprocess` module. We will also realize another construction of
    the thread that was described previously. Let''s implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to add some lines to the `u_tools.py` files. Change the
    line of the `import` section by adding the `QObject` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case of the PyQt5 `u_tools.py` file, add this line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in the case of the PySide2 `u_tools.py` file, add this line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `RunThread` class that will realize the functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple class that inherits the `QObject` class of the **`QtCore`**
    module. When the `on_run_code()` function is called, it will write to the file
    and run the file with a sub-process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `run_code()` function to the `UTools` class of the `u_tools.py` files,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This function, in relation to threads created previously, uses the `moveToThread()`
    method of the **`QObject`** class. It is important to note that we can see the
    need to start the `on_run_code()` function of the `RunThread` class using the `started()`
    signal of the thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can realize the option in the `UApp` class of the `u_app.py` files.
    We need to add to the `import` section of the `u_app.py` files, the standard library
    time module for working with time and data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `time` module to the `u_app.py` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we can add the new option to the `options()` function of the `UApp`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this option, we disable the `"Run"` item in the top panel menu. Then, we
    retrieve the text from the text field, call the function of the `UTools` class
    from the `u_tools.py` files, and receive a tuple that contains threads and used
    classes. We create two nested functions that receive the signals. The first receives
    signals from the `RunThread` class, and the second from the thread with the `finished()`
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: The Configuration option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Configuration` item is optional and the reader can add their own favorite
    functionality. Using this option, we will provide some information about Python
    and its installed packages. For this, create the `u_widget.py` file in both the `App/App_PyQt5/`
    and `App/App_PySide2/` directories, and incorporate therein the widget that will
    be used for additional informative tasks in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the following lines to the `import` section of this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case of the PyQt5 `u_widget.py` file, add this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in the case of the PySide2 `u_widget.py` file, add this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The only difference entails the importing of the `QtWidgets` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `UWidget` class to these `u_widget.py` files, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The simple class for a widget to be used depends on tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the lines to the `u_app.py` files of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `import` section, add the line that will import the widget, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the option to the `options()` function of the `UApp` class that will
    show information about the version of Python used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Selecting this option will show the imported widget with the title of the window
    set. Add the items to the combobox with options to run commands with subprocesses
    of your choice. If Anaconda is installed and used with this application, the `conda`
    packages will be shown, or the Python packages can be checked using the `pip` option.
  prefs: []
  type: TYPE_NORMAL
- en: The Help option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step that you need to complete is a `Help` option in the top panel.
    We will use some of the web functionality of the Qt library to demonstrate additional
    features. First, the `Online Help` sub-option will set HTML tags and then will
    load URLs. Let''s implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to add some lines to the `u_widget.py` files. In the
    `import` section, add the following line as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case of the PyQt5 `u_widget.py` file, add this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in the case of the PySide2 `u_widget.py` file, add this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `QtWebEngineWidgets` module realizes web functionality in the Qt library
    by providing classes to represent content in the widget and additional settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add the following lines to the `UWidget` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Add the **`QWebEngineView`** with settings to the layout in the first position.
    Also, this renders this view invisible.
  prefs: []
  type: TYPE_NORMAL
- en: For the realization of the `Help` option in the application, we need to add
    the signal and function to the `UApp` class of the `u_app.py` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the signal to the `UApp` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This signal will connect to the `on_help()` function when the `Help` option
    is selected. Now, we need to add the `on_help()` function to the `UApp` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `on_help()` function and the first `Online Help` option, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This option selection will set HTML from the file and show the widget. The `help.html`
    file can be any created HTML file that represents a link to some helpful resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, complete the `on_help()` function by adding the `Documentation` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This option will load URLs according to the combo box options selected and visualize
    these sources in the widget. These examples are use cases that we have not covered
    before, such as the web functionality of Qt, and it is recommended that you learn
    about these classes using the related documentation. Moreover, depending on the
    environment used, additional configurations and settings may be required.
  prefs: []
  type: TYPE_NORMAL
- en: The `help.html` file can be found on the GitHub repository of this book at: [https://github.com/PacktPublishing/Hands-On-Qt-for-Python-Developers/tree/master/Chapter17/App/App_PyQt5](https://github.com/PacktPublishing/Hands-On-Qt-for-Python-Developers/tree/master/Chapter17/App/App_PyQt5).
  prefs: []
  type: TYPE_NORMAL
- en: The Visualization tab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will consolidate the material of this book by adding a simple example of
    the possibility of viewing the data used by the application and fill the `Visualization` tab
    component. This is a demonstration of data visualization and can be further improved
    at any time. To create this data visualization, we will use an existing CSV file
    and use the values from one of its columns. Let''s implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `u_tools.py` file and add the following lines after all the used classes
    with threading implementations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This  `PaintThread` class will realize the thread that will read data with pandas,
    transform the received data into a form that can interpret the position from these
    values, and emit these values for the realization on the graphical scene of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the signal to the `UTools` class of the `u_tools.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This signal will be used to emit data to the `PaintThread` class, such as width
    and height.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `draws()` function to the `UTools` class. This will manipulate
    and communicate with the `PaintThread` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function will start the thread and get it to draw on the graphics scene,
    while emitting data with the width and height that was retrieved from the `PaintThread` class.
    This construction of threading is similar to the previous constructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to open the `u_app.py` file and complete this task by adding some
    lines. Let''s add the scene, view, and painter to the `__init__()` function of
    the `UApp` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will declare the graphics scene, graphics view, the painter that can be
    used, and will add a scene with a view to the second tab widget, and arrange these
    elements with a grid layout. We also need to change the calling function of the
    second push button signal connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `vis()` function to the `UApp` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This function will set the second tab widget as the current tab widget. The
    geometry of the application will be changed to the desktop device’s available
    size. We will run this function to visualize data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the `visualize()` function to the `UApp` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will use the graphics view and graphics scene to visualize data
    on the tab widget. Lines will be added to the scene with the color specified in
    the pen, position, and height that have been interpreted from data values. On
    clicking the Ok, we can see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e61983d1-ff6c-4652-b590-e3cea26518b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we only have linear data, the visualization will be somewhat ordinary,
    but, if some data is to be used with various values and not in such a linear form,
    we will get a different result.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to embedded devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Qt library provides a varied toolset that supports the realization of the
    GUI application with most modern platforms and embedded devices. For example,
    on Linux systems, we can easily create the desktop file and start this file, if
    necessary, to run the application from the desktop workplace or any favorite folder.
    The `uapp.desktop` file looks like the following example, which realizes desktop
    entry for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In terms of the binding used, PyQt5 can be changed to PySide2\. On Windows systems,
    this can be done (not so simply) by using third-party Python packages such as
    PyInstaller and py2exe, which convert Python scripts to executable (`.exe` files)
    and realize functionality accordingly. Also, the PyInstaller tool can be used
    for macOS X systems. It is recommended that you become familiar with the documentation
    pertaining to PyInstaller by visiting [https://pythonhosted.org/PyInstaller/](https://pythonhosted.org/PyInstaller/).
    These tools provide simple operations to create the executable quickly and easily.
    Another case involves deploying applications to mobile devices. The tools and
    libraries that can help to do this are usually available under a commercial license
    and, actually, PyQt and PySide bindings are not so well suited to these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: A better way to realize mobile versions of the application is to use the Kivy
    framework, the Toga cross-platform GUI toolkit, and so on, which specialize in
    mobile development. The official Qt source provides embedded tooling and solutions
    under a commercial license that help to build and deploy Qt GUI applications with
    Android and iOS mobile platforms. The QML-based applications can easily be implemented
    with Qt, incidentally, along the lines of the example provided in the [Chapter
    1](9de812dc-9446-4955-8437-4aebb2d991b3.xhtml), *Introduction to Python and Qt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source at [https://www.riverbankcomputing.com](https://www.riverbankcomputing.com) provides
    mobile solutions with the `pyqtdeploy` library for PyQt5 GUIs accordingly. This
    realizes deployment of the PyQt5 application on the iOS and Android platforms.
    The `pyqtdeploy` library is realized in order to convert the Python GUI application,
    the Python interpreter, the Python standard library, Python C extensions, and
    third-party extensions and packages, to the single, target-specific executable
    that can be run with most popular desktop and mobile platforms. The `pyqtdeploy`
    mechanism is released under the BSD license and will be demonstrated in detail. To
    use it, we need to install this package with `pip` on the Python installation
    that contains the PyQt5 binding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `pyqtdeploy` in Anaconda using the Python 3.x version and PyQt5 with
    `pip`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create, for example, in the `App/` folder (optional), the
    `pyqtdeploy` project by typing these commands in the command line/Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`pqtd`is the name of the project and `pqtd.pdy` is a file with this project.
    When hitting the *Enter* button, the `pyqtdeploy` GUI window will be displayed
    with the option to include the parameters required, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: The name of the application executable that will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Main script file: The filename of the executable Python script file that will
    be used to invoke this application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Entry point: The entry point of a Setuptools-based application that should
    not be specified if the main script file is specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'sys.path: Additional paths that will be used to specify additional directories
    for `sys.path`, such as application directories, ZIP files, and EGG. The list
    contains strings of paths, such as `[''/Path/to/the/App'', ''/path/to/the/App/App_PyQt5'',
    ''/path/to/the/App/App_PyQt5/qmls'', ...]`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we need to hit the Scan... button, select the `App/App_PyQt5/` directory,
    and push Include all. We will have the application directory trees similar to
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b299594d-87f5-4b0d-8b8f-2eb5ae60b042.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Uncheck the `data` folder of this tree. Then, we need to define the PyQt5 modules
    that will be used. For this, select the ***PyQt Modules*** tab and choose modules
    that were used in the application, similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c12dc17-e7e2-4746-b83a-7d02935e38f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of them are selected by hints, and this is easy to do. Go to the Standard
    Library tab and select all the Python standard library modules and packages that
    will be used, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ed21215-ee72-40c9-aabf-c313482aa76b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can choose all and uncheck the `sysconfig` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, go to the Other Packages tab and select all the additional packages that
    are required for the application. As we recall, there are `pymysql`, `couchdb`,
    and so on. For this, click on the top of the Packages Directory section, open
    the directory that will be scanned for packages (usually, this is `/Path/to/the/installed/Python/site-packages`),
    look at the ones available, and select what is needed. Then, hit Scan, and all
    packages of the `site-packages/directory` will be shown. We need to select the
    packages that were used, such as `pandas`, `pymysql`, `psycopg2`, `pymongo`, and
    `couchdb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0c72d238-6eee-4263-8760-23faf3157e9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Locations tab, we will configure the host and target Python locations
    similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ef8b3120-83a5-45f3-a98e-94afb2d05faa.png)'
  prefs: []
  type: TYPE_IMG
- en: Your paths will be relative to the installed Python interpreter directories.
    And now, we need to save previous operations to the XML document by clicking the
    Save option of the File menu. This file will be saved to the `App/` folder with
    the name `pqtd.pdy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that the features are selected and saved, we need to build this project
    using commands in the cmd/Terminal as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The architectures that can be used with the `--target` option are the `android-32`,
    `android-64`, `ios-64`, `linux-64`, `macos-64`, `win-32`, and `win-64` platforms.
    Now the generated package can be used for further deployment with different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any completed application requires testing of the working parts and components
    inside. In this section, we will cover unit testing of the created application
    with Qt's library instruments, such as the **`QtTest`** module. In addition, this
    module allows extensions for testing GUIs. The Python standard library unit testing
    framework, `unittest`, or third-party tools, such as `pytest`, can also be used.
    In the real world of testing, the `unittest` module is usually used in conjunction
    with the **`QtTest`** module. The **`QSignalSpy`** class of PyQt5's **`QtTest`**
    module introspects the emissions of the signals.
  prefs: []
  type: TYPE_NORMAL
- en: QtTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module provides a realization of the unit testing of Qt applications and
    libraries. To use this module, we need to add the following import statements
    to the files where testing functions will be used. The best way is to create the
    `u_tests.py` files in both the `App/App_PyQt5/` and `App/App_PySide2/` directories
    of the applications and add the `import` sections, respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the PyQt5 `u_tests.py` file, add this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in the case of the PySide2 `u_tests.py` file, add this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `QtTest` module provides the `QTest` class that can be used for the unit
    testing of the application. It should be noted that the PySide2 `QTest` namespace
    and the PyQt5 `QTest` class are different. The `QTest` namespace of the PySide2
    binding realizes functions and declarations of the framework for unit testing
    Qt-based applications and libraries with extensions for GUIs. The PyQt5's `QTest`
    class does not implement the complete Qt unit test framework and assumes that
    Python's `stdlib` `unittest` module will be used with `QTest`. Therefore, PyQt5's
    `QTest` cannot be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: QTest (PySide2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This namespace realizes the unit testing framework of the Qt library. The declaration
    syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QTest` improves functionality by means of the following commonly used
    functions. A full list is available with the official PySide2 documentation ([https://doc.qt.io/qtforpython/PySide2/QtTest/index.html](https://doc.qt.io/qtforpython/PySide2/QtTest/index.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.asciiToKey("ascii")`: This converts the ASCII character key value, specified
    in the parameter, to a Qt key value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.currentAppName()`: This returns the name of the currently executed binary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.currentDataTag()`: This returns the name of the current test data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.currentTestFailed()`: This returns `True` if the test function failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.currentTestFunction()`: This returns the name of the current test function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.ignoreMessage(QtMsgType, message)`: This ignores `qDebug()`, `qInfo()`,
    or `qWarning()` messages. In the instance when a message (the second parameter)
    of the global type (the first parameter) is returned in the output, it will be
    removed from the test log. If the test finishes and the message was not displayed
    in the output, it will be appended to the test log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.keyToAscii(key)`: This converts the Qt key value, specified in the parameter,
    to the ASCII character key value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.qExtractTestData("dirName")`: This extracts a directory, specified in
    the parameter, from resources to disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.setBenchmarkResult(float, QTest.QBenchmarkMetric)`: This sets the benchmark
    result (the first parameter) with a metric (the second parameter) that specifies
    how the Qt test should interpret the results in relation to this test function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.toPrettyCString(str, int)`: This returns the same `QtCore.QByteArray`,
    but with only the ASCII characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QTest (PyQt5)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class contains functions that enable unit testing of the PyQt5 applications.
    The `QTest` class improves functionality by means of the following commonly used
    functions. A full list is available with the official PyQt5 documentation ([https://www.riverbankcomputing.com/static/Docs/PyQt5/](https://www.riverbankcomputing.com/static/Docs/PyQt5/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.keyClick(QtWidgets.QWidget, QtCore.Qt.Key, QtCore.Qt.KeyboardModifiers,
    int)`: This simulates clicking a key (the second parameter) with a modifier (the
    third parameter) on a widget (the first parameter), with a test delay (the fourth
    parameter) in milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.keyClicks(QtWidgets.QWidget, str, QtCore.Qt.KeyboardModifiers, int)`:
    This simulates clicking a sequence of keys (the second parameter) with a modifier
    (the third parameter) on a widget (the first parameter), with a test delay (the
    fourth parameter) in milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.keyEvent(QtTest.QTest.KeyAction, QtWidgets.QWidget, QtCore.Qt.Key, QtCore.Qt.KeyboardModifiers,
    int)`: This sends a Qt key event to a widget (the second parameter) with a key
    (the third parameter) and associated action (the first parameter), as well as
    with a modifier (the fourth parameter), and a test delay (the fifth parameter)
    in milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.keyPress(QtWidgets.QWidget, QtCore.Qt.Key, QtCore.Qt.KeyboardModifiers,
    int)`: This simulates pressing a key (the second parameter) with a modifier (the
    third parameter) on a widget (the first parameter), with a test delay (the fourth
    parameter) in milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.keyRelease(QtWidgets.QWidget, QtCore.Qt.Key, QtCore.Qt.KeyboardModifiers,
    int)`: This simulates releasing a key (the second parameter) with a modifier (the
    third parameter) on a widget (the first parameter), with a test delay (the fourth
    parameter) in milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.mouseClick(QtWidgets.QWidget, QtCore.Qt.MouseButton, QtCore.Qt.KeyboardModifiers,
    QtCore.QPoint, int)`: This simulates clicking a mouse button (the second parameter)
    with a modifier (the third parameter) on a widget (the first parameter), with
    a test delay (the fifth parameter) in milliseconds. The position of the click
    (the fourth parameter), by default, is the center of the widget.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.mouseDClick(QtWidgets.QWidget, QtCore.Qt.MouseButton, QtCore.Qt.KeyboardModifiers,
    QtCore.QPoint, int)`: This simulates double-clicking a mouse button (the second
    parameter) with a modifier (the third parameter) on a widget (the first parameter),
    with a test delay (the fifth parameter) in milliseconds. The position (the fourth
    parameter), by default, is the center of the widget.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.mouseMove(QtWidgets.QWidget, QtCore.QPoint, int)`: This moves the mouse
    pointer to a widget (the first parameter), with a test delay (the fifth parameter)
    in milliseconds. It will be moved to a position (the fourth parameter), by default,
    to the center of the widget.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.mouseRelease(QtWidgets.QWidget, QtCore.Qt.MouseButton, QtCore.Qt.KeyboardModifiers,
    QtCore.QPoint, int)`: This simulates releasing a mouse button (the second parameter)
    with a modifier (the third parameter) on a widget (the first parameter), with
    a test delay (the fifth parameter) in milliseconds. The position (the fourth parameter),
    by default, is the center of the widget.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.qSleep(int)`: This sleeps for a number of milliseconds, specified in
    the parameter, blocking execution of this test.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.qWait(int)`: This waits for a number of milliseconds, specified in the
    parameter; the events will be processed and this test will stay responsive to
    events.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.qWaitForWindowActive(QtWidgets.QWidget, int)`: This waits for a number
    of milliseconds (the second parameter) until the widget''s window (the first parameter)
    is active.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.qWaitForWindowExposed(QtWidgets.QWidget, int)`: This waits for a number
    of milliseconds (the second parameter) until the widget''s window (the first parameter)
    is exposed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.touchEvent(QtWidgets.QWidget, QtGui.QTouchDevice)`: This creates and
    returns a sequence of the  `QtTest.QTest.QTouchEventSequence` type for the device
    (the second parameter) to simulate events for the widget (the first parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: QTest examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we can see, the PyQt5 binding realizes just a part of the Qt test framework.
    The tests of the GUI app can be demonstrated with PyQt5-related construction of
    the simple example, which can also be used with the PySide2 binding. It should
    be noted that the methods described in the *QTest (PyQt5)* section are available
    for the PySide2 binding. By way of a simple example, add the following lines to
    the `import` sections of the `u_tests.py` files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the PyQt5 `u_tests.py` file, add this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in the case of the PySide2 `u_tests.py` file, add this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The test element will be elements of the `UWindow` class that realizes the application
    window of the GUI. We can add any widget to this import line.
  prefs: []
  type: TYPE_NORMAL
- en: Now add to the `u_tests.py` files the class that inherits the `TestCase` base class
    of the Python standard library `unittest` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `UTests` class to the `u_tests.py` files by completing the file with
    the line that will call the `main()` function of the `unittest` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `setUp()` method operates with instances that are required to start the
    test, such as application, the class instance of the imported `UWindow` class,
    and the window menu bar. The `test_menu()` function realizes this test and completes
    it with `tear_down()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run the `u_tests.py` files in the cmd/Terminal by typing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3b47eff-7d52-4c81-877d-cf35eb5d7aa8.png)'
  prefs: []
  type: TYPE_IMG
- en: We can test any widget in this way, and enhance the current construction depending
    on our own tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter completes the GUI application that we created within this book.
    This application does not pretend to be a special tool to solve special tasks,
    but it can be easily extended and modernized for almost all GUI implementations
    commonly used today. Almost all of the useful graphical elements were described
    previously in this book. The process of deploying the GUI to the various platforms
    and architectures is not easy, and requires additional knowledge of the material
    and examples. Also, some restrictions may arise, depending on the versions and
    supported environments of the device. Hence, learning the requirements related
    to using the devices is recommended. Testing the application requires a thorough
    understanding of the elements that can be tested, and why, and how. Correct implementation
    of the tests can help to avoid a lot of the mistakes and errors associated with
    application development.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter completes this book, and the reader must know what to learn next.
    Moreover, the Python world is so very vast.
  prefs: []
  type: TYPE_NORMAL
