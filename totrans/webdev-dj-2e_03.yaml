- en: 3\. URL Mapping, Views, and Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces you to three core concepts of Django: **views**, **templates**,
    and **URL mapping**. You will start by exploring the two main types of views in
    Django: **function-based views** and **class-based views**. Next, you will learn
    the basics of Django template language and template inheritance. Using these concepts,
    you will create a page to display the list of all the books in the **Bookr** application.
    You will also create another page to display the details, review comments, and
    ratings of books.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we were introduced to databases, and we learned how
    to store, retrieve, update, and delete records from a database. We also learned
    how to create Django models and apply database migrations.
  prefs: []
  type: TYPE_NORMAL
- en: However, these database operations alone cannot display the application's data
    to a user. We need a way to display all the stored information in a meaningful
    way to the user; for example, displaying all the books present in our Bookr application's
    database, in a browser, in a presentable format. This is where Django views, templates,
    and URL mapping come into play. Views are the part of a Django application that
    takes in a web request and provides a web response. For example, a web request
    could be a user trying to view a website by entering the website address, and
    a web response could be the web site's home page loading in the user's browser.
    Views are one of the most important parts of a Django application, where the application
    logic is written. This application logic controls interactions with the database,
    such as creating, reading, updating, or deleting records from the database. It
    also controls how the data can be displayed to the user. This is done with the
    help of Django HTML templates, which we will explore in detail in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: Django views can be broadly classified into two types, **function-based views**
    and **class-based views**. In this chapter, we will learn about function-based
    views in Django.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn only about function-based views. Class-based
    views, which is a more advanced topic, will be discussed in detail in *Chapter 11*,
    *Advanced Templating and Class-Based Views*.
  prefs: []
  type: TYPE_NORMAL
- en: Function-Based Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name implies, function-based views are implemented as Python functions.
    To understand how they work, consider the following snippet, which shows a simple
    view function named `home_page`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The view function defined here, named `home_page`, takes a `request` object
    as an argument and returns an `HttpResponse` object having the `Welcome to my
    Website` message. The advantage of using function-based views is that, since they
    are implemented as simple Python functions, they are easier to learn and also
    easily readable for other programmers. The major disadvantage of function-based
    views is that the code cannot be re-used and made as concise as class-based views
    for generic use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Class-Based Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name implies, class-based views are implemented as Python classes. Using
    the principles of class inheritance, these classes are implemented as subclasses
    of Django''s generic view classes. Unlike function-based views, where all the
    view logic is expressed explicitly in a function, Django''s generic view classes
    come with various pre-built properties and methods that can provide shortcuts
    to writing clean, reusable views. This property comes in handy quite often during
    web development; for example, developers often need to render an HTML page without
    needing any data inserted from the database, or any customization specific to
    the user. In this case, it is possible to simply inherit from Django''s `TemplateView`,
    and specify the path of the HTML file. The following is an example of a class-based
    view that can display the same message as in the function-based view example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, `HomePage` is a class-based view inheriting
    Django''s `TemplateView` from the `django.views.generic` module. The class attribute
    `template_name` defines the template to render when the view is invoked. For the
    template, we add an HTML file to our `templates` folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a very basic example of class-based views, which will be explored further
    in *Chapter 11*, *Advanced Templating and Class-Based Views*. The major advantage
    of using class-based views is that fewer lines of code need to be used to implement
    the same functionality as compared to function-based views. Also, by inheriting
    Django's generic views, we can keep the code concise and avoid the duplication
    of code. However, a disadvantage of class-based views is that the code is often
    less readable for someone new to Django, which means that learning about it is
    usually a longer process, as compared to function-based views.
  prefs: []
  type: TYPE_NORMAL
- en: URL Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django views cannot work on their own in a web application. When a web request
    is made to the application, Django''s URL configuration takes care of routing
    the request to the appropriate view function to process the request. A typical
    URL configuration in the `urls.py` file in Django looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `urlpatterns` is the variable defining the list of URL paths, and `'url-path/'`
    defines the path to match.
  prefs: []
  type: TYPE_NORMAL
- en: '`views.my_view` is the view function to invoke when there is a URL match, and
    `name=''my-view''` is the name of the view function used to refer to the view.
    There may be a situation wherein, elsewhere in the application, we want to get
    the URL of this view. We wouldn''t want to hardcode the value, as it would then
    have to be specified twice in the codebase. Instead, we can access the URL by
    using the name of the view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If needed, we can also use a regular expression in a URL path to match string
    patterns using `re_path()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `name` refers to the pattern name, which can be any Python regular expression
    pattern, and this needs to be matched before calling the defined view function.
    You can also pass parameters from the URL into the view itself, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `<int:id>` tells Django to look for URLs that contain
    an integer at this position in the string, and to assign the value of that integer
    to the `id` argument. This means that if the user navigates to `/url-path/14/`,
    the `id=14` keyword argument is passed to the view. This is often useful when
    a view needs to look up a specific object in the database and return corresponding
    data. For example, suppose we had a `User` model, and we wanted the view to display
    the user's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view could be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the user accesses `/url-path/14/`, the preceding view is called, and the
    argument `id=14` is passed into the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the typical workflow when a URL such as `http://0.0.0.0:8000/url-path/`
    is invoked using a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTP request would be made to the running application for the URL path.
    Upon receiving the request, it reaches for the `ROOT_URLCONF` setting present
    in the `settings.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This determines the URL configuration file to be used first. In this case, it
    is the URL file present in the project directory `project_name/urls.py`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, Django goes through the list named `urlpatterns`, and once it matches
    the `url-path/` with the path present in the URL `http://0.0.0.0:8000/url-path/`,
    it invokes the corresponding view function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: URL configuration is sometimes also referred to as URL conf or URL mapping,
    and these terms are often used interchangeably. To understand views and URL mapping
    better, let's start with a simple exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.01: Implementing a Simple Function-Based View'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will write a very basic function-based view and use the
    associated URL configuration to display the message `Welcome to Bookr!` in a web
    browser. We will also tell the user how many books we have in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, ensure that `ROOT_URLCONF` in `bookr/settings.py` is pointing to the
    project''s URL file by adding in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `bookr/reviews/views.py` file and add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we import the `HttpResponse` class from the `django.http` module. Next,
    we define the `welcome_view` function, which can display the message `Welcome
    to Bookr!` in a web browser. The request object is a function parameter that carries
    the HTTP `request` object. The next line defines the `message` variable, which
    contains HTML that displays the header, followed by a line that counts the number
    of books available in the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the last line, we return an `HttpResponse` object with the string associated
    with the message variable. When the `welcome_view` view function is called, it
    will display the message `Welcome to Bookr! 2 Books and counting` in the web browser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create the URL mapping to call the newly created view function. Open the
    project URL file, `bookr/urls.py`, and add the list of `urlpatterns` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line in the list of `urlpatterns`, that is, `path('admin/', admin.site.urls)`
    routes to the admin URLs if `admin/` is present in the URL path (for example,
    `http://0.0.0.0:8000/admin`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, consider the second line, `path('', include('reviews.urls'))`. Here,
    the path mentioned is an empty string, `''`. If the URL does not have any specific
    path after `http://hostname:port-number/` (for example, `http://0.0.0.0:8000/`),
    it includes the `urlpatterns` present in `review.urls`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `include` function is a shortcut that allows you to combine URL configurations.
    It is common to keep one URL configuration per application in your Django project.
    Here, we've created a separate URL configuration for the `reviews` app and have
    added it to our project-level URL configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since we do not have the URL module `reviews.urls` yet, create a file called
    `bookr/reviews/urls.py`, and add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have used an empty string again for the URL path. So, when the URL
    `http://0.0.0.0:8000/` is invoked, after getting routed from `bookr/urls.py` into
    `bookr/reviews/urls.py`, this pattern invokes the `welcome_view` view function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After making changes to the two files, we have the necessary URL configuration
    ready to call the `welcome_view` view. Now, start the Django server with `python
    manage.py runserver` and type in `http://0.0.0.0:8000` or `http://127.0.0.1:8000`
    in your web browser. You should be able to see the message `Welcome to Bookr!`:![Figure
    3.1: Displaying "Welcome to Bookr!" and the number of books on the home page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_03_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.1: Displaying "Welcome to Bookr!" and the number of books on the home
    page'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If there is no URL match, Django invokes error handling, such as displaying
    a `404 Page not found` message or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to write a basic view function and do the associated
    URL mapping. We have created a web page that displays a simple message to the
    user and reports how many books are currently in our database.
  prefs: []
  type: TYPE_NORMAL
- en: However, the astute reader will have noticed that it doesn't look very nice
    to have HTML code sitting inside our Python function as in the preceding example.
    As our views get bigger, this will become even more unsustainable. Therefore,
    we now turn our attention to where our HTML code is supposed to be – inside templates.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Exercise 3.01*, *Implementing a Simple Function-Based View*, we saw how
    to create a view, do the URL mapping, and display a message in the browser. But
    if you recall, we hardcoded the HTML message `Welcome to Bookr!` in the view function
    itself and returned an `HttpResponse` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Hardcoding of HTML inside Python modules is not a good practice, because as
    the content to be rendered in a web page increases, so does the amount of HTML
    code we need to write for it. Having a lot of HTML code among Python code can
    make the code hard to read and maintain in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, Django templates provide us with a better way to write and
    manage HTML templates. Django's templates not only work with static HTML content
    but also dynamic HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django''s template configuration is done in the `TEMPLATES` variable present
    in the `settings.py` file. This is how the default configuration looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through each keyword present in the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''BACKEND'': ''django.template.backends.django.DjangoTemplates''`: This refers
    to the template engine to be used. A template engine is an API used by Django
    to work with HTML templates. Django is built with Jinja2 and the `DjangoTemplates`
    engine. The default configuration is the `DjangoTemplates` engine and Django template
    language. However, this can be changed to use a different one if required, such
    as Jinja2 or any other third-party template engine. For our Bookr application
    though, we will leave this configuration as it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''DIRS'': []`: This refers to the list of directories where Django searches
    for the templates in the given order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''APP_DIRS'': True`: This tells the Django template engine whether it should
    look for templates in the installed apps defined under `INSTALLED_APPS` in the
    `settings.py` file. The default option for this is `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''OPTIONS''`: This is a dictionary containing template engine-specific settings.
    Inside this dictionary, there is a default list of context processors, which helps
    the Python code to interact with templates to create and render dynamic HTML templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The current default settings are mostly fine for our purposes. However, in
    the next exercise, we will create a new directory for our templates, and we will
    need to specify the location of this folder. For example, if we have a directory
    called `my_templates`, we need to specify its location by adding it to the `TEMPLATES`
    settings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`BASE_DIR` is the directory path to the project folder. This is defined in
    the `settings.py` file. The `os.path.join()` method joins the project directory
    with the `templates` directory, returning the full path for the templates directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.02: Using Templates to Display a Greeting Message'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create our first Django template, and, just as we
    did in the previous exercise, we will display the `Welcome to Bookr!` message
    using the templates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory called `templates` in the `bookr` project directory and
    inside it, create a file called `base.html`. The directory structure should look
    like *Figure 3.2*:![Figure 3.2: Directory structure for bookr'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_03_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.2: Directory structure for bookr'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the default configuration is used, that is when `DIRS` is an empty list,
    Django searches for templates present only in the app folders' `template` directory
    (the `reviews/templates` folder in the case of a book review application). Since
    we included the new template directory in the main project directory, Django's
    template engine would not be able to find the directory unless the directory is
    included in the `'DIRS'` list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the folder to the `TEMPLATES` settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines of code into the `base.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is simple HTML that displays the message `Welcome to Bookr!` in the header.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the code inside `bookr/reviews/views.py` so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we have already configured the `'templates'` directory in the `TEMPLATES`
    configuration, `base.html` is available for use for the template engine. The code
    renders the file `base.html` using the imported `render` method from the `django.shortcuts`
    module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Save the files, run `python manage.py runserver`, and open the `http://0.0.0.0:8000/`
    or `http://127.0.0.1:8000/` URL to check the newly added template loading in the
    browser:![Figure 3.3: Displaying "Welcome to Bookr!" on the home page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_03_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.3: Displaying "Welcome to Bookr!" on the home page'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we created an HTML template and used Django templates and
    views to return the message `Welcome to Bookr!`. Next, we will learn about the
    Django template language, which can be used to render the application's data along
    with HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: Django Template Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django templates not only return static HTML templates but can also add dynamic
    application data while generating the templates. Along with data, we can also
    include some programmatic elements in the templates. All of these put together
    form the basics of **Django's template language**. This section looks at some
    of the basic parts of the Django template language.
  prefs: []
  type: TYPE_NORMAL
- en: Template Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A template variable is represented in between two curly braces, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is present in the template, the value carried by the variables will
    be replaced in the template. Template variables help in adding the application''s
    data into the templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Template Tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A tag is similar to a programmatic control flow, such as an `if` condition
    or a `for` loop. A tag is represented between two curly braces and percentage
    signs, as shown. Here is an example of a `for` loop iterating over a list using
    template tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike Python programming, we also add the end of the control flow by adding
    the `end` tag, such as `{% endfor %}`. This can be used along with template variables
    to display the elements in the list, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comments in the Django template language can be written as shown here; anything
    in-between `{% comment %}` and `{% endcomment %}` will be commented out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Filters can be used to modify a variable to represent it in a different format.
    The syntax for a filter is a variable separated from the filter name using a pipe
    (`|`) symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of built-in filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ variable|lower }}`: This converts the variable string into lowercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{ variable|title}}`: This converts the first letter of every word into uppercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's use the concepts we have learned up till now to develop the book review application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.03: Displaying a List of Books and Reviews'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a web page that can display a list of all
    books, their ratings, and the number of reviews present in the book review application.
    For this, we will be using some features of the Django template language such
    as variables and template tags to pass the book review application data into the
    templates to display meaningful data on the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `utils.py` under `bookr/reviews/utils.py` and add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a helper method that will be used to calculate the average rating of
    a book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remove all the code present inside `bookr/reviews/views.py` and add the following
    code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a view to display the list of books for the book review application.
    The first three lines import Django modules, model classes, and the helper method
    we just added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, `books_list` is the view method. In this method, we start by querying
    the list of all books. Next, for every book, we calculate the average rating and
    the number of reviews posted. All this information for each book is appended to
    a list called `book_list` as a list of dictionaries. This list is then added to
    a dictionary named context and is passed to the render function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The render function takes three parameters, the first one being the request
    object that was passed into the view, the second being the HTML template `books_list.html`,
    which will display the list of books, and the third is context, which we pass
    to the template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we have passed `book_list` as a part of the context, the template will
    be using this to render the list of books using template tags and template variables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `book_list.html` file in the path `bookr/reviews/templates/reviews/books_list.html`
    and add the following HTML code in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a simple HTML template with template tags and variables iterating over
    `book_list` to display the list of books.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `bookr/reviews/urls.py`, add the following URL pattern to invoke the `books_list`
    view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This does the URL mapping for the `books_list` view function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Save all the modified files and wait for the Django service to restart. Open
    `http://0.0.0.0:8000/books/` in the browser, and you should see something similar
    to *Figure 3.4*:![Figure 3.4: List of books present in the book review application'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_03_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.4: List of books present in the book review application'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we created a view function, created templates, and also did
    the URL mapping, which can display a list of all books present in the application.
    Although we were able to display a list of books using a single template, next,
    let's explore a bit about how to work with multiple templates in an application
    that has common or similar code.
  prefs: []
  type: TYPE_NORMAL
- en: Template Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we build the project, the number of templates will increase. It is highly
    probable that when we design the application, some of the pages will look similar
    and have common HTML code for certain features. Using template inheritance, we
    can inherit the common HTML code into other HTML files. This is similar to class
    inheritance in Python, where the parent class has all the common code, and the
    child class has those extras that are unique to the child's requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s consider the following to be a parent template that is
    named `base.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a child template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the line `{% extends ''base.html'' %}` extends the
    template from `base.html`, which is the parent template. After extending from
    the parent template, any HTML code in-between the block content will be displayed
    along with the parent template. Once the child template is rendered, here is how
    it looks in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: Greeting message after extending the base.html template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.5: Greeting message after extending the base.html template'
  prefs: []
  type: TYPE_NORMAL
- en: Template Styling with Bootstrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to display all the books using views, templates, and URL mapping.
    Although we were able to display all the information in the browser, it would
    be even better if we could add some styling and make the web page look better.
    For this, we can add a few elements of **Bootstrap**. Bootstrap is an open-source
    **Cascading Style Sheets** (**CSS**) framework that is particularly good for designing
    responsive pages that work across desktop and mobile browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Bootstrap is simple. First, you need to add the Bootstrap CSS to your
    HTML. You can experiment yourself by creating a new file called `example.html`.
    Populate it with the following code and open it in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The Bootstrap CSS link in the preceding code adds the bootstrap CSS library
    to your page. This means that certain HTML element types and classes will inherit
    their styles from Bootstrap. For example, if you add the `btn-primary` class to
    the class of a button, the button will be rendered as blue with white text. Try
    adding the following between `<body>` and `</body>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the title and button are both styled nicely, using Bootstrap''s
    default styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: Display after applying Bootstrap'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.6: Display after applying Bootstrap'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because in the Bootstrap CSS code, it specifies the color of the `btn-primary`
    class with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can see that using third-party CSS libraries such as Bootstrap allows you
    to quickly create nicely styled components without needing to write too much CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend that you explore Bootstrap further with their tutorial here: [https://getbootstrap.com/docs/4.4/getting-started/introduction/](https://getbootstrap.com/docs/4.4/getting-started/introduction/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.04: Adding Template Inheritance and a Bootstrap Navigation Bar'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use template inheritance to inherit the template
    elements from a base template and re-use them in the `book_list` template to display
    the list of books. We will also use certain elements of Bootstrap in the base
    HTML file to add a navigation bar to the top of our page. The bootstrap code for
    `base.html` was taken from [https://getbootstrap.com/docs/4.4/getting-started/introduction/](https://getbootstrap.com/docs/4.4/getting-started/introduction/)
    and [https://getbootstrap.com/docs/4.4/components/navbar/](https://getbootstrap.com/docs/4.4/components/navbar/):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `base.html` file from the location `bookr/templates/base.html`. Remove
    any existing code and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a `base.html` file with all the Bootstrap elements for styling and the
    navigation bar.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, open the template at `bookr/reviews/templates/reviews/books_list.html`,
    remove all the existing code, and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This template has been configured to inherit the `base.html` file and it has
    also been added with a few styling elements to display the list of books. The
    part of the template that helps in inheriting the `base.html` file is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After adding the two new templates, open either of the URLs `http://0.0.0.0:8000/books/`
    or `http://127.0.0.1:8000/books/` in your web browser to see the books list page,
    which should now look neatly formatted:![Figure 3.7: Neatly formatted book list
    page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_03_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.7: Neatly formatted book list page'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we added some styling into the application using Bootstrap
    and we also used template inheritance while we displayed the list of books from
    the book review application. So far, we have worked extensively on displaying
    all the books present in the application. In the next activity, you will display
    details and reviews of an individual book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.01: Implement the Book Details View'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you will implement a new view, template, and URL mapping,
    to display these details of a book: title, publisher, publication date, and overall
    rating. In addition to these details, the page should also display all the review
    comments, specifying the name of the commenter and the dates on which the comments
    were written and (if applicable) modified. The following steps will help you complete
    this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a book details endpoint that extends the base template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a book details view that takes a specific book's primary key as the argument
    and returns an HTML page listing the book's details and any associated reviews.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the required URL mapping in `urls.py`. The book details view URL should be
    `http://0.0.0.0:8000/books/1/` (where `1` will represent the `ID` of the book
    being accessed). You can use the `get_object_or_404` method to retrieve the book
    with the given primary key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `get_object_or_404` function is a useful shortcut for retrieving an instance
    based on its primary key. You could also do this using the .`get()` method described
    in *Chapter 2*, *Models and Migrations*, `Book.objects.get(pk=pk)`. However, `get_object_or_404`
    has the added advantage of returning an `HTTP 404 Not Found` response if the object
    does not exist. If we simply use `get()` and someone attempts to access an object
    that does not exist, our Python code will hit an exception and return an `HTTP
    500 Server Error` response. This is undesirable because it looks as though our
    server has failed to handle the request correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the end of the activity, you should be able to click the `Reviews` button
    on the book list page and get the detail view of the book. The detail view should
    have all the details displayed in the following screenshot:![Figure 3.8: Page
    displaying the book details'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_03_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.8: Page displaying the book details'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the core infrastructure required to handle an HTTP request
    to our website. The request is first mapped via URL patterns to an appropriate
    view. Parameters from the URL are also passed into the view to specify the object
    displayed on the page. The view is responsible for compiling any necessary information
    to display on the website, and then passes this dictionary through to a template
    that renders the information as HTML code that can be returned as a response to
    the user. We covered both class- and function-based views and learned about the
    Django template language and template inheritance. We created two new pages for
    the book review application, one displaying all the books present and the other
    being the book details view page. In the next chapter, we will learn about Django
    admin and superuser, registering models, and performing CRUD operations using
    the admin site.
  prefs: []
  type: TYPE_NORMAL
