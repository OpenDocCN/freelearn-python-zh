["```py\nclass MediaLoader(abc.ABC):\n    @abc.abstractmethod\n    def play(self) -> None:\n        ...\n    @property\n    @abc.abstractmethod\n    def ext(self) -> str:\n        ... \n```", "```py\n>>> MediaLoader.__abstractmethods__\nfrozenset({'ext', 'play'}) \n```", "```py\n>>> class Wav(MediaLoader): \n...     pass \n... \n>>> x = Wav() \nTraceback (most recent call last): \n  File \"<stdin>\", line 1, in <module> \nTypeError: Can't instantiate abstract class Wav with abstract methods ext, play \n>>> class Ogg(MediaLoader): \n...     ext = '.ogg' \n...     def play(self): \n...         pass \n... \n>>> o = Ogg() \n```", "```py\n>>> from collections.abc import Container\n>>> Container.__abstractmethods__ \nfrozenset({'__contains__'}) \n```", "```py\n>>> help(Container.__contains__)\nHelp on function __contains__ in module collections.abc:\n__contains__(self, x) \n```", "```py\nfrom collections.abc import Container\nclass OddIntegers:\n    def __contains__(self, x: int) -> bool:\n        return x % 2 != 0 \n```", "```py\n>>> odd = OddIntegers()\n>>> isinstance(odd, Container)\nTrue\n>>> issubclass(OddIntegers, Container)\nTrue \n```", "```py\n>>> odd = OddIntegers()\n>>> 1 in odd\nTrue\n>>> 2 in odd\nFalse\n>>> 3 in odd\nTrue \n```", "```py\nBaseMapping = abc.Mapping[Comparable, Any] \n```", "```py\n>>> x = dict({\"a\": 42, \"b\": 7, \"c\": 6})\n>>> y = dict([(\"a\", 42), (\"b\", 7), (\"c\", 6)])\n>>> x == y\nTrue \n```", "```py\nBaseMapping = abc.Mapping[Comparable, Any]\nclass Lookup(BaseMapping):\n    @overload\n    def __init__(\n          self, \n          source: Iterable[tuple[Comparable, Any]]\n    ) -> None:\n        ...\n    @overload\n    def __init__(self, source: BaseMapping) -> None:\n        ...\n    def __init__(\n          self, \n          source: Union[Iterable[              tuple[Comparable, Any]]\n              BaseMapping,\n              None] = None,\n    ) -> None:\n        sorted_pairs: Sequence[tuple[Comparable, Any]]\n        if isinstance(source, Sequence):\n            sorted_pairs = sorted(source)\n        elif isinstance(source, abc.Mapping):\n            sorted_pairs = sorted(source.items())\n        else:\n            sorted_pairs = []\n        self.key_list = [p[0] for p in sorted_pairs]\n        self.value_list = [p[1] for p in sorted_pairs] \n```", "```py\nfrom __future__ import annotations\nfrom collections import abc\nfrom typing import Protocol, Any, overload, Union\nimport bisect\nfrom typing import Iterator, Iterable, Sequence, Mapping \n```", "```py\n def __len__(self) -> int:\n        return len(self.key_list)\n    def __iter__(self) -> Iterator[Comparable]:\n        return iter(self.key_list)\n    def __contains__(self, key: object) -> bool:\n        index = bisect.bisect_left(self.key_list, key)\n        return key == self.key_list[index]\n    def __getitem__(self, key: Comparable) -> Any:\n        index = bisect.bisect_left(self.key_list, key)\n        if key == self.key_list[index]:\n            return self.value_list[index]\n        raise KeyError(key) \n```", "```py\n>>> x = Lookup(\n...     [\n...         [\"z\", \"Zillah\"],\n...         [\"a\", \"Amy\"],\n...         [\"c\", \"Clara\"],\n...         [\"b\", \"Basil\"],\n...     ]\n... )\n>>> x[\"c\"]\n'Clara' \n```", "```py\n>>> x[\"m\"] = \"Maud\" \n```", "```py\nTypeError: 'Lookup' object does not support item assignment \n```", "```py\nfrom typing import Protocol, Any\nclass Comparable(Protocol):\n    def __eq__(self, other: Any) -> bool: ...\n    def __ne__(self, other: Any) -> bool: ...\n    def __le__(self, other: Any) -> bool: ...\n    def __lt__(self, other: Any) -> bool: ...\n    def __ge__(self, other: Any) -> bool: ...\n    def __gt__(self, other: Any) -> bool: ... \n```", "```py\nimport abc\nclass Die(abc.ABC):\n    def __init__(self) -> None:\n        self.face: int\n        self.roll()\n    @abc.abstractmethod\n    def roll(self) -> None:\n        ...\n    def __repr__(self) -> str:\n        return f\"{self.face}\" \n```", "```py\n>>> class Bad(Die):\n...     def roll(self, a: int, b: int) -> float:\n...         return (a+b)/2 \n```", "```py\nclass D4(Die):\n    def roll(self) -> None:\n        self.face = random.choice((1, 2, 3, 4))\nclass D6(Die):\n    def roll(self) -> None:\n        self.face = random.randint(1, 6) \n```", "```py\nclass Dice(abc.ABC):\n    def __init__(self, n: int, die_class: Type[Die]) -> None:\n        self.dice = [die_class() for _ in range(n)]\n    @abc.abstractmethod\n    def roll(self) -> None:\n        ...\n    @property\n    def total(self) -> int:\n        return sum(d.face for d in self.dice) \n```", "```py\nclass SimpleDice(Dice):\n    def roll(self) -> None:\n        for d in self.dice:\n            d.roll() \n```", "```py\n>>> sd = SimpleDice(6, D6)\n>>> sd.roll()\n>>> sd.total\n23 \n```", "```py\nclass YachtDice(Dice):\n    def __init__(self) -> None:\n        super().__init__(5, D6)\n        self.saved: Set[int] = set()\n    def saving(self, positions: Iterable[int]) -> \"YachtDice\":\n        if not all(0 <= n < 6 for n in positions):\n            raise ValueError(\"Invalid position\")\n        self.saved = set(positions)\n        return self\n    def roll(self) -> None:\n        for n, d in enumerate(self.dice):\n            if n not in self.saved:\n                d.roll()\n        self.saved = set() \n```", "```py\n>>> sd = YachtDice()\n>>> sd.roll()\n>>> sd.dice\n[2, 2, 2, 6, 1]\n>>> sd.saving([0, 1, 2]).roll()\n>>> sd.dice\n[2, 2, 2, 6, 6] \n```", "```py\n>>> from dice import Die\n>>> Die.__abstractmethods__\nfrozenset({'roll'})\n>>> Die.roll.__isabstractmethod__\nTrue \n```", "```py\nclass DieM(metaclass=abc.ABCMeta):\n    def __init__(self) -> None:\n        self.face: int\n        self.roll()\n    @abc.abstractmethod\n    def roll(self) -> None:\n        ... \n```", "```py\ndef len(object: Sized) -> int:\n    return object.__len__() \n```", "```py\n>>> from pathlib import Path\n>>> home = Path.home()\n>>> home / \"miniconda3\" / \"envs\"\nPosixPath('/Users/slott/miniconda3/envs') \n```", "```py\nclass DDice:\n    def __init__(self, *die_class: Type[Die]) -> None:\n        self.dice = [dc() for dc in die_class]\n        self.adjust: int = 0\n    def plus(self, adjust: int = 0) -> \"DDice\":\n        self.adjust = adjust\n        return self\n    def roll(self) -> None:\n        for d in self.dice:\n            d.roll()\n    @property\n    def total(self) -> int:\n        return sum(d.face for d in self.dice) + self.adjust \n```", "```py\ndef __add__(self, die_class: Any) -> \"DDice\":\n    if isinstance(die_class, type) and issubclass(die_class, Die):\n        new_classes = [type(d) for d in self.dice] + [die_class]\n        new = DDice(*new_classes).plus(self.adjust)\n        return new\n    elif isinstance(die_class, int):\n        new_classes = [type(d) for d in self.dice]\n        new = DDice(*new_classes).plus(die_class)\n        return new\n    else:\n        return NotImplemented\ndef __radd__(self, die_class: Any) -> \"DDice\":\n    if isinstance(die_class, type) and issubclass(die_class, Die):\n        new_classes = [die_class] + [type(d) for d in self.dice]\n        new = DDice(*new_classes).plus(self.adjust)\n        return new\n    elif isinstance(die_class, int):\n        new_classes = [type(d) for d in self.dice]\n        new = DDice(*new_classes).plus(die_class)\n        return new\n    else:\n        return NotImplemented \n```", "```py\ndef __mul__(self, n: Any) -> \"DDice\":\n    if isinstance(n, int):\n        new_classes = [type(d) for d in self.dice for _ in range(n)]\n        return DDice(*new_classes).plus(self.adjust)\n    else:\n        return NotImplemented\ndef __rmul__(self, n: Any) -> \"DDice\":\n    if isinstance(n, int):\n        new_classes = [type(d) for d in self.dice for _ in range(n)]\n        return DDice(*new_classes).plus(self.adjust)\n    else:\n        return NotImplemented \n```", "```py\n>>> y = DDice(D6, D6)\n>>> y += D6 \n```", "```py\ndef __iadd__(self, die_class: Any) -> \"DDice\":\n    if isinstance(die_class, type) and issubclass(die_class, Die):\n        self.dice += [die_class()]\n        return self\n    elif isinstance(die_class, int):\n        self.adjust += die_class\n        return self\n    else:\n        return NotImplemented \n```", "```py\n>>> y = DDice(D6, D6)\n>>> y += D6\n>>> y += 2 \n```", "```py\n>>> d = {\"a\": 42, \"a\": 3.14}\n>>> d\n{'a': 3.14} \n```", "```py\n>>> {1: \"one\", True: \"true\"}\n{1: 'true'} \n```", "```py\n>>> from typing import Dict, Hashable, Any, Mapping, Iterable\n>>> class NoDupDict(Dict[Hashable, Any]):\n...     def __setitem__(self, key, value) -> None:\n...         if key in self:\n...             raise ValueError(f\"duplicate {key!r}\")\n...         super().__setitem__(key, value) \n```", "```py\n>>> nd = NoDupDict()\n>>> nd[\"a\"] = 1\n>>> nd[\"a\"] = 2\nTraceback (most recent call last):\n  ...\n  File \"<doctest examples.md[10]>\", line 1, in <module>\n    nd[\"a\"] = 2\n  File \"<doctest examples.md[7]>\", line 4, in __setitem__\n    raise ValueError(f\"duplicate {key!r}\")\nValueError: duplicate 'a' \n```", "```py\n>>> NoDupDict({\"a\": 42, \"a\": 3.14})\n{'a': 3.14} \n```", "```py\nfrom __future__ import annotations\nfrom typing import cast, Any, Union, Tuple, Dict, Iterable, Mapping\nfrom collections import Hashable\nDictInit = Union[\n    Iterable[Tuple[Hashable, Any]],     Mapping[Hashable, Any], \n    None]\nclass NoDupDict(Dict[Hashable, Any]):\n    def __setitem__(self, key: Hashable, value: Any) -> None:\n        if key in self:\n            raise ValueError(f\"duplicate {key!r}\")\n        super().__setitem__(key, value)\n    def __init__(self, init: DictInit = None, **kwargs: Any) -> None:\n        if isinstance(init, Mapping):\n            super().__init__(init, **kwargs)\n        elif isinstance(init, Iterable):\n            for k, v in cast(Iterable[Tuple[Hashable, Any]], init):\n                self[k] = v\n        elif init is None:\n            super().__init__(**kwargs)\n        else:\n            super().__init__(init, **kwargs) \n```", "```py\nimport logging\nfrom functools import wraps\nfrom typing import Type, Any\nclass DieMeta(abc.ABCMeta):\n    def __new__(\n        metaclass: Type[type],\n        name: str,\n        bases: tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwargs: Any,\n    ) -> \"DieMeta\":\n        if \"roll\" in namespace and not getattr(\n            namespace[\"roll\"], \"__isabstractmethod__\", False\n        ):\n            namespace.setdefault(\"logger\", logging.getLogger(name))\n            original_method = namespace[\"roll\"]\n            @wraps(original_method)\n            def logged_roll(self: \"DieLog\") -> None:\n                original_method(self)\n                self.logger.info(f\"Rolled {self.face}\")\n            namespace[\"roll\"] = logged_roll\n        new_object = cast(\n            \"DieMeta\", abc.ABCMeta.__new__(\n                 metaclass, name, bases, namespace)\n        )\n        return new_object \n```", "```py\nclass DieLog(metaclass=DieMeta):\n    logger: logging.Logger\n    def __init__(self) -> None:\n        self.face: int\n        self.roll()\n    @abc.abstractmethod\n    def roll(self) -> None:\n        ...\n    def __repr__(self) -> str:\n        return f\"{self.face}\" \n```", "```py\nclass D6L(DieLog):\n    def roll(self) -> None:\n        \"\"\"Some documentation on D6L\"\"\"\n        self.face = random.randrange(1, 7) \n```", "```py\n>>> import sys\n>>> logging.basicConfig(stream=sys.stdout, level=logging.INFO)\n>>> d2 = D6L()\nINFO:D6L:Rolled 1\n>>> d2.face\n1 \n```", "```py\nclass SamplePartition(List[SampleDict], abc.ABC):\n    @overload\n    def __init__(self, *, training_subset: float = 0.80) -> None:\n        ...\n    @overload\n    def __init__(\n        self,\n        iterable: Optional[Iterable[SampleDict]] = None,\n        *,\n        training_subset: float = 0.80,\n    ) -> None:\n        ...\n    def __init__(\n        self,\n        iterable: Optional[Iterable[SampleDict]] = None,\n        *,\n        training_subset: float = 0.80,\n    ) -> None:\n        self.training_subset = training_subset\n        if iterable:\n            super().__init__(iterable)\n        else:\n            super().__init__()\n    @abc.abstractproperty\n    @property\n    def training(self) -> List[TrainingKnownSample]:\n        ...\n    @abc.abstractproperty\n    @property\n    def testing(self) -> List[TestingKnownSample]:\n        ... \n```", "```py\nclass SampleDict(TypedDict):\n    sepal_length: float\n    sepal_width: float\n    petal_length: float\n    petal_width: float\n    species: str \n```", "```py\nclass ShufflingSamplePartition(SamplePartition):\n    def __init__(\n        self,\n        iterable: Optional[Iterable[SampleDict]] = None,\n        *,\n        training_subset: float = 0.80,\n    ) -> None:\n        super().__init__(iterable, training_subset=training_subset)\n        self.split: Optional[int] = None\n    def shuffle(self) -> None:\n        if not self.split:\n            random.shuffle(self)\n            self.split = int(len(self) * self.training_subset)\n    @property\n    def training(self) -> List[TrainingKnownSample]:\n        self.shuffle()\n        return [TrainingKnownSample(**sd) for sd in self[: self.split]]\n    @property\n    def testing(self) -> List[TestingKnownSample]:\n        self.shuffle()\n        return [TestingKnownSample(**sd) for sd in self[self.split :]] \n```", "```py\n>>> import random\n>>> from model import ShufflingSamplePartition\n>>> from pprint import pprint\n>>> data = [\n...     {\n...         \"sepal_length\": i + 0.1,\n...         \"sepal_width\": i + 0.2,\n...         \"petal_length\": i + 0.3,\n...         \"petal_width\": i + 0.4,\n...         \"species\": f\"sample {i}\",\n...     }\n...     for i in range(10)\n... ]\n>>> random.seed(42)\n>>> ssp = ShufflingSamplePartition(data)\n>>> pprint(ssp.testing)\n[TestingKnownSample(sepal_length=0.1, sepal_width=0.2, petal_length=0.3, petal_width=0.4, species='sample 0', classification=None, ),\n TestingKnownSample(sepal_length=1.1, sepal_width=1.2, petal_length=1.3, petal_width=1.4, species='sample 1', classification=None, )] \n```", "```py\nssp = ShufflingSamplePartition(training_subset=0.67)\nfor row in data:\n    ssp.append(row) \n```", "```py\nclass DealingPartition(abc.ABC):\n    @abc.abstractmethod\n    def __init__(\n        self,\n        items: Optional[Iterable[SampleDict]],\n        *,\n        training_subset: Tuple[int, int] = (8, 10),\n    ) -> None:\n        ...\n    @abc.abstractmethod\n    def extend(self, items: Iterable[SampleDict]) -> None:\n        ...\n    @abc.abstractmethod\n    def append(self, item: SampleDict) -> None:\n        ...\n    @property\n    @abc.abstractmethod\n    def training(self) -> List[TrainingKnownSample]:\n        ...\n    @property\n    @abc.abstractmethod\n    def testing(self) -> List[TestingKnownSample]:\n        ... \n```", "```py\nclass CountingDealingPartition(DealingPartition):\n    def __init__(\n        self,\n        items: Optional[Iterable[SampleDict]],\n        *,\n        training_subset: Tuple[int, int] = (8, 10),\n    ) -> None:\n        self.training_subset = training_subset\n        self.counter = 0\n        self._training: List[TrainingKnownSample] = []\n        self._testing: List[TestingKnownSample] = []\n        if items:\n            self.extend(items)\n    def extend(self, items: Iterable[SampleDict]) -> None:\n        for item in items:\n            self.append(item)\n    def append(self, item: SampleDict) -> None:\n        n, d = self.training_subset\n        if self.counter % d < n:\n            self._training.append(TrainingKnownSample(**item))\n        else:\n            self._testing.append(TestingKnownSample(**item))\n        self.counter += 1 \n```", "```py\n @property\n    def training(self) -> List[TrainingKnownSample]:\n        return self._training\n    @property\n    def testing(self) -> List[TestingKnownSample]:\n        return self._testing \n```"]