- en: Chapter 7. Writing a Flappy Bird Clone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.html "Chapter 6. Making the 2048 Game"), *Making the 2048
    Game*, we already fiddled with simple game development, exemplified by the well-known
    **2048** puzzle. This is the logical continuation: we''re going to build an arcade
    game, more specifically a **Flappy Bird**-style side scroller.'
  prefs: []
  type: TYPE_NORMAL
- en: Flappy Bird is an incredibly simple yet very addictive mobile game released
    by Dong Nguyen back in 2013; by the end of January 2014, it was the most downloaded
    free game in the iOS App Store. The Flappy Bird phenomenon is very interesting,
    game design-wise. The game features exactly one action (tap anywhere on screen
    to bump the bird, changing its trajectory) and one player activity (fly through
    gaps in obstacles without touching them). This simple and repetitive gameplay
    has become quite a trend lately, as explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Asceticism in mobile game design**'
  prefs: []
  type: TYPE_NORMAL
- en: The *classical* two-dimensional arcade genre was recently reborn on mobile.
    There are currently lots of commercial re-issues of retro games, with the price
    tag being about the only difference from the original 30-year-old titles—these
    include Dizzy, Sonic, Double Dragon, and R-Type, to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'One huge letdown many of these games share in a new environment is control
    scheme awkwardness: the touch screen and gyroscope that are commonly present in
    modern gadgets just don''t replace a gamepad very well, if at all. This fact also
    became a selling point of new titles—designing a game from the ground up with
    the available control scheme in mind can be a huge win.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some developers tackled with this problem by radically simplifying things upfront:
    it turns out that there is a huge market for simplistic toys, especially for low-cost
    or free (optionally, ad-supported) titles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Games that feature very limited controls and gameplay can indeed become very
    popular, and Flappy Bird just landed in a sweet spot, providing extremely challenging
    yet minimalistic and easily accessible gameplay. In this chapter, we will be re-implementing
    this particular gem of a game design using Kivy. We are going to introduce a number
    of new things:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulating very simple arcade physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kivy widgets as fully featured game sprites, complete with arbitrary positioning
    and two-dimensional transformations, such as rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing and implementing sound effects for games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game we're building doesn't have a winning condition, and the slightest
    collision with an obstacle ends the game. In the original Flappy Bird title, players
    competed for a higher score (number of pipes passed without crashing into something).
    Similar to the previous chapter though, the implementation of a scoreboard is
    purposefully left out as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re aiming to create a game conceptually similar to the original Flappy
    Bird, but with different visuals. It''s unimaginatively called **Kivy Bird**.
    The end result is depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project overview](img/7849OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Kivy Bird gameplay screenshot
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the game and dissect it into logical parts, creating
    a project outline that will be used for development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Background**: The scenery consists of a number of layers moving at different
    speeds, resulting in a neat fake depth (parallax effect). The movement is constant
    and not related to any game events; this makes the background an ideal starting
    point for the implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obstacles (pipes)**: This is a separate graphical layer that also advances
    towards the player at a constant speed. As opposed to the background, the pipes
    are procedurally adjusted to have different relative heights, keeping the gap
    between them passable for the player. A collision with a pipe ends the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playable character (the bird)**: This sprite moves only vertically, constantly
    falling down. The player bumps it by clicking or tapping anywhere on the screen,
    this pushes the bird upwards. As soon as the bird meets floor, ceiling, or a pipe,
    the game ends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is roughly the order in which we're going to write the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an animated background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use the following images to create the background for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an animated background](img/7849OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Images for the background
  prefs: []
  type: TYPE_NORMAL
- en: Note that all of these can be seamlessly tiled horizontally—this isn't a strict
    requirement, but a desirable property nonetheless, as the background looks nicer
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in the description, the background is always in motion, disconnected
    from the rest of the game. This effect can be achieved in at least two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the straightforward approach, we can just move a huge textured polygon
    (or any number of polygons) in the background. Creating seamless looping animation
    in this case may require a bit of work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more efficient way to achieve the same visual effect is to create a number
    of static polygons (one per layer) that span the whole viewport, and then animate
    just texture coordinates. With a tileable texture, this approach produces seamless
    and visually pleasing results, and amounts to less work overall—there is no need
    to reposition objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will implement the second approach, as it''s both easier and more effective.
    Let''s start with the `kivybird.kv` file that contains the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All "magic numbers" from here on refer mostly to texture dimensions: `96` is
    the ground level, `64` is the height of grass, and `144` is a somewhat arbitrary
    level of clouds. Hardcoding things like that in production code is usually frowned
    upon, but we shall do it occasionally for the sake of simplicity and to minimize
    code size of examples.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are no moving parts here at all, just three rectangles
    positioned along the top and bottom edges of the screen. This scene depends on
    textures being exposed as properties (beginning with `tx_`) of the `Background`
    class, which we're going to implement next.
  prefs: []
  type: TYPE_NORMAL
- en: Loading tileable textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We shall start with the helper function for loading tileable textures: this
    functionality will be used a lot in the following code, so it''s a good idea to
    abstract it up front.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do so is creating an intermediate `Widget` subclass, which will
    then serve as a base class for our custom widgets (in `main.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The bit that warrants creating the helper function is `t.wrap = 'repeat'`. We
    need to apply this to every tiled texture.
  prefs: []
  type: TYPE_NORMAL
- en: While we're at that, we also store the newly loaded texture using the naming
    convention of `tx_` followed by the filename of an image. For example, a call
    to `load_tileable('grass')` will load the file called `grass.png` and store the
    resulting texture in a `self.tx_grass` attribute. This naming logic should be
    easy to follow.
  prefs: []
  type: TYPE_NORMAL
- en: The Background widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Being able to conveniently load textures, we can now implement the `Background`
    widget as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code at this point, you'll see distorted textures stretched to
    fill corresponding rectangles; this happens in the absence of explicitly given
    texture coordinates. To fix this, we need to adjust the `uvsize` property of each
    texture, which denotes how many times a texture is repeated to fill a polygon.
    For example, a `uvsize` of `(2, 2)` means that a texture fills one fourth of a
    rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This helper method will be used to set `uvsize` to an appropriate value so
    that our textures aren''t distorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Negative texture coordinates, as seen in this example, mean that the texture
    gets flipped. Kivy uses this effect to avoid costly raster operations, shifting
    the load to the GPU (graphics card), which is designed to handle these operations
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method depends on the width of a background, so it''s appropriate to invoke
    it every time the widget''s `size` property changes, using the `on_size()` callback.
    This keeps each texture''s `uvsize` in sync, for example, when the user resizes
    the application window manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If done properly, the code so far produces a background similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Background widget](img/7849OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Static background with textures
  prefs: []
  type: TYPE_NORMAL
- en: Animating the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last thing that we need to do before moving on to other parts of the application
    is a background animation. First, we add a monotonous timer running at roughly
    60 ticks per second to the `KivyBirdApp` application class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `update()` method just passes control to a similar method of the `Background`
    widget for now. The scope of this method is going to expand later, when we have
    more moving parts in our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Background.update()`, we change the texture origin (namely, a property
    called `uvpos`) to simulate movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the interesting stuff happens in a helper function, `set_background_uv()`:'
  prefs: []
  type: TYPE_NORMAL
- en: It increments the first component of the `uvpos` property, shifting the texture
    origin horizontally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls `dispatch()` on the texture property, signaling that it has changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canvas instructions (in `kivybird.kv`) listen to this change and react accordingly,
    rendering the texture with updated origin. This results in a smooth animation.
  prefs: []
  type: TYPE_NORMAL
- en: Multipliers that control the animation speed of different layers (see the second
    argument of all `set_background_uv()` calls) are selected arbitrarily to create
    the desired parallax effect. This is purely cosmetic; go ahead and change them
    to witness the effect it has on the animation.
  prefs: []
  type: TYPE_NORMAL
- en: The background is now complete, and the next thing on our list is making pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Making pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pipe is divided into two parts, lower and upper, with a gap in between for
    player to pass through. Each part, in turn, consists of variable-length body and
    the pipe cap, or *pcap*—a fixed-size thickening at the end of the pipe facing
    the gap. We are going to use the following images to draw pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making pipes](img/7849OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Images for pipes
  prefs: []
  type: TYPE_NORMAL
- en: If the preceding explanation doesn't ring the bell, see the first illustration
    in this chapter and you'll immediately understand what this means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the layout in the `kivybird.kv` file provides a convenient starting
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Conceptually, this is very simple: four rectangles are being rendered on canvas,
    listed in the order of appearance in the source:'
  prefs: []
  type: TYPE_NORMAL
- en: Lower pipe body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower pipe cap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upper pipe body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upper pipe cap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Making pipes](img/7849OS_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Composition of pipes from rectangles
  prefs: []
  type: TYPE_NORMAL
- en: This listing depends on many attributes of the `Pipe` object; similar to how
    the `Background` widget is implemented, these properties are used to connect the
    Python implementation of an algorithm to a graphical representation of the widget
    (canvas instructions).
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the pipe properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the interesting attributes of the `Pipe` widget are shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'First, constants are set in `ALL_CAPS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FLOOR`: This is the ground level (height of the floor texture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PCAP_HEIGHT`: This is the height of a pipe cap, also derived from the corresponding
    texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PIPE_GAP`: This is the size of passage left for the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next come the texture properties `tx_pipe` and `tx_pcap`. They are used in
    the same fashion as those found in the `Background` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ratio` property indicates where the gap is located: the value of `0.5`
    (the default) means center, `0` is the bottom of the screen (on the ground), and
    `1` is the top of the screen (in the sky).'
  prefs: []
  type: TYPE_NORMAL
- en: The `lower_len` and `upper_len` properties represent pipe lengths, excluding
    the cap. These are derived from `ratio` and the available screen height.
  prefs: []
  type: TYPE_NORMAL
- en: The `upper_y` alias is a helper introduced to reduce typing; it's computed on
    the fly and is always equal to `height - upper_len` (see the implementation).
  prefs: []
  type: TYPE_NORMAL
- en: This leaves us with two important properties used to set texture coordinates
    for canvas instructions, namely `lower_coords` and `upper_coords`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting texture coordinates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the implementation of the `Background` widget, we were tweaking the texture's
    own attributes, such as `uvsize` and `uvpos`, to control its rendering. The problem
    with this approach is that it affects all instances of the texture.
  prefs: []
  type: TYPE_NORMAL
- en: This is perfectly fine as long as textures aren't reused on different geometries,
    which is exactly the case with the background. This time around, however, we need
    to control texture coordinates per canvas primitive, so we're not going to touch
    `uvsize` and `uvpos` at all. Instead, we will use `Rectangle.tex_coords`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Rectangle.tex_coords` property accepts a list or tuple of eight numbers,
    assigning texture coordinates to corners of the rectangle in question. The mapping
    of coordinates to indices in the `tex_coords` list is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting texture coordinates](img/7849OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mapping of texture coordinates to a rectangular polygon
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Texture mapping commonly uses *u* and *v* variables instead of *x* and *y*.
    This makes it easier to tell apart geometry and texture coordinates, which are
    often interleaved in code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This whole topic may sound confusing at first, so let''s simplify things a
    bit: we''re only going to fix tiling on pipes vertically, and we just need to
    adjust the fifth and seventh elements of `tex_coords` to achieve our noble goal.
    Moreover, the values in `tex_coords` have the same meaning as those in `uvsize`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Long story short, the following function adjusts the coordinates for correct
    tiling based on pipe length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Easy, right? What''s left to do is a boring, yet also not at all complicated
    math: computing the length of pipes based on `ratio` and screen height. The code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This pretty self-evident code lives in the `on_size()` handler to keep all
    related properties in sync with the screen size. To also reflect changes to `ratio`,
    we can issue the following function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that we don't change this property in our code yet. This
    is because the whole lifecycle of the pipes will be handled by the application
    class, `KivyBirdApp`, as you will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out that to create an illusion of an endless forest of pipes, we need
    just a screenful of them, as we can recycle ones that went off the screen and
    push them to the back of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to create pipes about half screen width apart from one another to
    give the player some wiggle room; this means that only three pipes can be seen
    on the screen at the same time. We will create four of them for a good measure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet contains an implementation of the described algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The use of the `pipes` list should be considered an implementation detail. We
    could have traversed the list of child widgets to access pipes, but it's just
    nicer this way.
  prefs: []
  type: TYPE_NORMAL
- en: The cleanup code at the beginning of the `spawn_pipes()` method will allow us
    to easily restart the game later.
  prefs: []
  type: TYPE_NORMAL
- en: We also randomize each pipe's `ratio` in this function. Notice that the range
    is artificially constrained to [0.25, 0.75], while technically it's [0, 1]—narrowing
    this space makes the game somewhat easier to play, with fewer vertical maneuvers
    necessary to go from gate to gate.
  prefs: []
  type: TYPE_NORMAL
- en: Moving and recycling pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike the background where we shifted the textures'' `uvpos` attribute to
    imitate movement, pipes actually move. This is the revised `KivyBirdApp.update()`
    method that involves repositioning and recycling pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous animations, `96` is an ad hoc time multiplier that just
    happens to work; increasing it makes the game more fast-paced.
  prefs: []
  type: TYPE_NORMAL
- en: 'When pushing back a pipe, we randomize its `ratio` again, creating a unique
    path for the player to follow. The following screenshot summarizes the endlessly
    looping result so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving and recycling pipes](img/7849OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Moving pipes and background – a Flappy Bird-themed screensaver
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kivy Bird
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next on our list is the playable character, that is, the biologically improbable
    Kivy Bird:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Kivy Bird](img/7849OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rare species, the Kivy Bird sprite
  prefs: []
  type: TYPE_NORMAL
- en: There will be nothing fancy related to textures this time; in fact, the `Bird`
    class will be derived from Kivy's `Image` widget (`kivy.uix.image.Image`) to completely
    avoid doing any clever rendering whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `kivybird.kv` we need a bare minimum of properties involving the bird image
    depicted earlier; its initial position and size are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the initial implementation of the `Bird` class in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Yup, it does nothing at all. Soon, we're going to spoil it by adding rudimentary
    physics and other things, but first we need to lay some groundwork in the application
    class in order to make the game stateful.
  prefs: []
  type: TYPE_NORMAL
- en: Revised application flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we shall mimic the original game somewhat:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, we'll just show the bird sitting there without any pipes or gravitation.
    Such a state will be denoted by `playing = False` in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As soon as the user interacts with the game (either clicks or taps anywhere
    on the screen, or presses the space bar on the keyboard), the state changes to
    `playing = True`, pipes start spawning, and gravity starts to affect the bird,
    which falls as a rock to an imaginary death. The user needs to continue interacting
    with the game to keep the bird airborne.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the event of collision with something, the game goes back to `playing = False`
    and everything sits in place until the next user interaction, which in turn restarts
    the process from step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to implement this, we need to receive user input. Thankfully, this
    is borderline trivial, especially since we're interested just in the fact that
    an event occurred (we aren't checking where the click or tap landed, for example—the
    whole screen is one big button for the purposes of this game).
  prefs: []
  type: TYPE_NORMAL
- en: Accepting user input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation right away, since there is very little
    left to discuss on this particular topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the whole user input handling we''re going to need: the `on_key_down`
    event handles the keyboard input, checking for a specific key (in this case, the
    spacebar). The `on_touch_down` event handles the rest—clicking, tapping, and whatnot.
    Both ultimately end up calling the `user_action()` method, which in turn runs
    `spawn_pipes()` and sets `playing` to `True` (only when needed).'
  prefs: []
  type: TYPE_NORMAL
- en: Learning to fly straight down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we're going to implement gravity so that our bird could fly in at least
    one direction. For this, we will introduce a new `Bird.speed` property and a new
    constant—the acceleration of free fall. The speed vector will grow downwards each
    frame, resulting in a uniformly accelerated animation of falling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing contains the implementation of a described shooting bird:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gravity_on()` method will be called when `playing` becomes `True`. Insert
    the highlighted line into the `KivyBirdApp.user_action()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This method effectively resets the initial position of a bird and allows vertical
    motion by removing the `'center_y'` constraint from `pos_hint`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `self.bird` reference is similar to `self.background` that we''ve seen
    earlier. The following code snippet should reside in the `KivyBirdApp.on_start()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is done for convenience alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to call `Bird.update()` from `KivyBirdApp.update()`. At the same
    time, this is the perfect opportunity to put a guard preventing useless updates
    to game objects while not playing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Background.update()` method gets called no matter what;
    everything else is invoked only when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: What's missing from this implementation is the ability to stay in the air. This
    will be our next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Remaining in flight
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Implementing the Flappy Bird-style jumpy flight is incredibly easy. We can
    just override the `Bird.speed` momentarily, setting it to a positive value and
    then letting it decay normally as the bird continues to fall. Let''s add the following
    method to the `Bird` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to put a call to `self.bird.bump()` at the end of the `KivyBirdApp.user_action()`
    function, and there, all done: we can stay in the air by mashing the spacebar
    or clicking inside the viewport repeatedly.'
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the bird
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rotating the bird is a brief topic and isn''t related to the physics of the
    bird, but instead focuses on the eye candy. It would be nice if the bird would
    rotate accordingly to its trajectory: if it''s going up, its nose should point
    in a general direction of the top-right corner of the screen and towards the bottom-right
    corner when it declines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to approximate the angle is by using the value of `Bird.speed`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Again, the multiplier shown here is completely arbitrary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to actually rotate the sprite, we can introduce the following
    definition to the `kivybird.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This operation changes the local coordinate system that OpenGL uses for this
    sprite, potentially affecting all subsequent rendering. Don't forget to save (`PushMatrix`)
    and restore (`PopMatrix`) the coordinate system state; otherwise, catastrophic
    glitches may occur, and the whole scene can end up skewed or spinning.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The opposite is also true: if you''re experiencing inexplicable application-wide
    rendering problems, look for low-level OpenGL instructions that aren''t properly
    scoped.'
  prefs: []
  type: TYPE_NORMAL
- en: After these changes, the bird should properly align itself with the trajectory
    of the flight.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing that is absolutely vital for the gameplay is the collision detection,
    which ends the game when the bird collides with either the floor, the ceiling,
    or a pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether we've met floor or ceiling is as simple as comparing `bird.y`
    to a ground level or screen height (taking into account the height of the bird
    itself in the second comparison). In `KivyBirdApp`, we have the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a bit more complex when looking for a collision with pipes, but not substantially
    so. We can subdivide this next check in two: first, we test for a horizontal collision
    using Kivy''s built-in `collide_widget()` method, and then check whether vertical
    coordinates are within limits imposed by the `lower_len` and `upper_len` attributes
    of a pipe we''re flying into.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the revised version of the `KivyBirdApp.test_game_over()` method is
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This function returns `False` only if every check failed. This could be further
    optimized to test a maximum of one pipe at a time (the one which is roughly in
    the same area on screen as the bird; there is always at most one such pipe, given
    enough spacing between them).
  prefs: []
  type: TYPE_NORMAL
- en: Game over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So what happens when a collision was indeed found? As it turns out, very little;
    we just switch `self.playing` to `False`, and that''s it. The check can be added
    to the bottom of `KivyBirdApp.update()` after all other computations take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This stops the world until the user triggers another interaction, restarting
    the game. The most rewarding part of writing the collision detection code is playtesting
    it, triggering the game over state in a multitude of amusing ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game over](img/7849OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exploring different approaches to failing (collage)
  prefs: []
  type: TYPE_NORMAL
- en: If there is no winning condition, then at least losing should be fun.
  prefs: []
  type: TYPE_NORMAL
- en: Producing sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part will be less focused on the Kivy Bird game specifically; it's more
    of an overview of various tools that can be employed to add sound effects to a
    game or application.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with sound effects is rarely a technical one. Creating good-quality
    sound effects is no small task, and software engineers oftentimes aren't skilled
    musicians or audio engineers. Moreover, most applications are actually usable
    with no sound, which is why audio can easily be purposefully neglected or just
    overlooked during development.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are tools that facilitate producing okay-quality sound effects
    while possessing zero domain-specific knowledge. A perfect example is **Bfxr**,
    a synthesizer specifically aimed at sporadic game development. It is available
    for free at [www.bfxr.net](http://www.bfxr.net).
  prefs: []
  type: TYPE_NORMAL
- en: The usage of Bfxr family of tools boils down to clicking preset buttons until
    it generates a nice sound, and then hitting **Save to Disk** to store the result
    as a `.wav` (uncompressed sound) file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Producing sound effects](img/7849OS_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bfxr's user interface may not seem friendly at first, but it's actually very
    easy to use
  prefs: []
  type: TYPE_NORMAL
- en: This is a great tool in terms of productivity. Using Bfxr, you can create passable
    sound effects literally within minutes—and they will be (mostly) unique to your
    app. For many hobbyist game developers, this program is truly a game changer,
    pun intended.
  prefs: []
  type: TYPE_NORMAL
- en: Kivy sound playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the programmatic side of things, the API for playback that Kivy provides
    is dead simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `play()` method starts playback, and that''s it. Well, not really: there
    is a slight problem with this simplistic approach, especially for games.'
  prefs: []
  type: TYPE_NORMAL
- en: In many game situations, it may be desirable to play the same sound over and
    over in rapid succession so that samples overlap. Take, for example, automatic
    fire. The problem with Kivy's `Sound` class (not unique to it, however—for example,
    the `<audio>` tag in HTML5 behaves similarly) is that it allows only one instance
    of the sample to play at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait until the previous playback has ended (the default behavior, all subsequent
    events will be silent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop and restart the playback for each event, which is also problematic (this
    may introduce unnecessary delays, clicks, or other audio artifacts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To solve this issue, we need to create a pool (actually a queue) of `Sound`
    objects so that each subsequent call to `play()` involves another `Sound`. When
    the queue is exhausted, we rewind it and start from the beginning. Given a queue
    large enough, we can get rid of the aforementioned `Sound` limitation completely.
    In practice, such pool rarely exceeds a size of 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of the described technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The second argument to the constructor stands for pool size. Note how we keep
    rudimentary compatibility with the existing `Sound` API, namely the `play()` method.
    This allows using the code as a drop-in replacement of a `Sound` object in simple
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound to the Kivy Bird game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To finish things off with a practical example, let's add sound effects to the
    Kivy Bird game we've written over the course of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are two frequent events that could use a soundtrack, namely, the bird
    climbing and the bird colliding with objects and triggering the game over state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The former event, initiated by clicking or tapping, can indeed happen very
    frequently in a rapid succession; we''ll use a sample pool for this one. The latter,
    game over, can''t possibly occur quite as fast, so it''s fine to leave it as a
    plain `Sound` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This code makes use of the `MultiAudio` class laid out earlier. The only thing
    left is to put calls to the `play()` method at the appropriate points, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: From now on, the gameplay will be accompanied by heart-rending sounds. This
    concludes the Kivy Bird game tutorial; I hope you liked it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made a small Kivy game from simple building blocks such
    as canvas instructions and widgets.
  prefs: []
  type: TYPE_NORMAL
- en: As a UI toolkit, Kivy gets many things right and its remarkable flexibility
    allows you to build pretty much anything, be it another boring Twitter client
    or a video game. One aspect that deserves special mention is Kivy's implementation
    of properties—these are immensely helpful to organize data flow across the board
    and help us to effectively eliminate useless updates (such as redraws in the absence
    of changed properties).
  prefs: []
  type: TYPE_NORMAL
- en: Another thing about Kivy that may be surprising and counterintuitive at first
    is its relatively high performance—especially since Python isn't exactly famous
    for being extremely quick. This is partly because low-level subsystems in Kivy
    are written in Cython and compiled to a blazing fast machine code, with performance
    levels about the same as, for example, the C language. Also, the use of hardware-accelerated
    graphics all but guarantees smooth animations, if done properly.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the topic of cranking up the rendering performance in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
