- en: Chapter 7. Writing a Flappy Bird Clone
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。编写Flappy Bird克隆版
- en: 'In [Chapter 6](ch06.html "Chapter 6. Making the 2048 Game"), *Making the 2048
    Game*, we already fiddled with simple game development, exemplified by the well-known
    **2048** puzzle. This is the logical continuation: we''re going to build an arcade
    game, more specifically a **Flappy Bird**-style side scroller.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。制作2048游戏")《制作2048游戏》中，我们已经对简单的游戏开发进行了尝试，以著名的**2048**谜题为例。这是逻辑上的延续：我们将构建一个街机游戏，更具体地说是一个**Flappy
    Bird**风格的横版滚动游戏。
- en: Flappy Bird is an incredibly simple yet very addictive mobile game released
    by Dong Nguyen back in 2013; by the end of January 2014, it was the most downloaded
    free game in the iOS App Store. The Flappy Bird phenomenon is very interesting,
    game design-wise. The game features exactly one action (tap anywhere on screen
    to bump the bird, changing its trajectory) and one player activity (fly through
    gaps in obstacles without touching them). This simple and repetitive gameplay
    has become quite a trend lately, as explained in the following section.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Flappy Bird是由Dong Nguyen在2013年发布的一款简单却极具吸引力的移动游戏；到2014年1月底，它已成为iOS应用商店下载量最大的免费游戏。从游戏设计角度来看，Flappy
    Bird现象非常有趣。游戏只包含一个动作（在屏幕上任意位置点击以弹起小鸟，改变其轨迹）和一个玩家活动（在不触碰障碍物的情况下飞过障碍物间的缝隙）。这种简单且重复的游戏玩法最近已经成为一种趋势，以下章节将进行解释。
- en: '**Asceticism in mobile game design**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动游戏设计中的简约主义**'
- en: The *classical* two-dimensional arcade genre was recently reborn on mobile.
    There are currently lots of commercial re-issues of retro games, with the price
    tag being about the only difference from the original 30-year-old titles—these
    include Dizzy, Sonic, Double Dragon, and R-Type, to name a few.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*经典*的二维街机游戏类型最近在移动设备上重新焕发生机。目前有很多复古游戏的商业再发行，价格标签几乎是唯一与30年前的原始标题不同的地方——这些包括Dizzy、Sonic、Double
    Dragon和R-Type等，仅举几个例子。'
- en: 'One huge letdown many of these games share in a new environment is control
    scheme awkwardness: the touch screen and gyroscope that are commonly present in
    modern gadgets just don''t replace a gamepad very well, if at all. This fact also
    became a selling point of new titles—designing a game from the ground up with
    the available control scheme in mind can be a huge win.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些游戏在新环境中共享的一个巨大失望是控制方案的不便：现代设备中普遍存在的触摸屏和陀螺仪并不能很好地替代游戏手柄，甚至不能替代。这一事实也成为新标题的卖点——从零开始设计一个考虑到可用控制方案的游戏可以是一个巨大的胜利。
- en: 'Some developers tackled with this problem by radically simplifying things upfront:
    it turns out that there is a huge market for simplistic toys, especially for low-cost
    or free (optionally, ad-supported) titles.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者通过在前期彻底简化事物来解决这个问题：事实证明，简单玩具市场非常大，尤其是低成本或免费（可选，广告支持）的标题。
- en: 'Games that feature very limited controls and gameplay can indeed become very
    popular, and Flappy Bird just landed in a sweet spot, providing extremely challenging
    yet minimalistic and easily accessible gameplay. In this chapter, we will be re-implementing
    this particular gem of a game design using Kivy. We are going to introduce a number
    of new things:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 特征非常有限的控制和游戏玩法的游戏确实可以变得非常受欢迎，Flappy Bird刚好落在了甜蜜的点上，提供了极具挑战性、简约且易于接触的游戏玩法。在本章中，我们将使用Kivy重新实现这款特定的游戏设计。我们将介绍许多新事物：
- en: Simulating very simple arcade physics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟非常简单的街机物理
- en: Using Kivy widgets as fully featured game sprites, complete with arbitrary positioning
    and two-dimensional transformations, such as rotation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kivy小部件作为功能齐全的游戏精灵，包括任意定位和二维变换，如旋转
- en: Implementing basic collision detection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基本的碰撞检测
- en: Producing and implementing sound effects for games
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作和实现游戏音效
- en: The game we're building doesn't have a winning condition, and the slightest
    collision with an obstacle ends the game. In the original Flappy Bird title, players
    competed for a higher score (number of pipes passed without crashing into something).
    Similar to the previous chapter though, the implementation of a scoreboard is
    purposefully left out as an exercise for you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的游戏没有胜利条件，与障碍物最轻微的碰撞就会结束游戏。在原始的Flappy Bird标题中，玩家们竞争更高的分数（通过不撞到任何东西而通过的管道数量）。尽管如此，与上一章类似，计分板的实现故意留给你作为练习。
- en: Project overview
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'We''re aiming to create a game conceptually similar to the original Flappy
    Bird, but with different visuals. It''s unimaginatively called **Kivy Bird**.
    The end result is depicted as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个在概念上与原始《Flappy Bird》相似但视觉不同的游戏。它被不富有想象力地称为**Kivy Bird**。最终结果如下所示：
- en: '![Project overview](img/7849OS_07_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![项目概览](img/7849OS_07_01.jpg)'
- en: Kivy Bird gameplay screenshot
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy Bird 游戏截图
- en: 'Let''s take a closer look at the game and dissect it into logical parts, creating
    a project outline that will be used for development:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看游戏，将其分解成逻辑部分，创建一个用于开发的工程概要：
- en: '**Background**: The scenery consists of a number of layers moving at different
    speeds, resulting in a neat fake depth (parallax effect). The movement is constant
    and not related to any game events; this makes the background an ideal starting
    point for the implementation.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景**：场景由多个以不同速度移动的层组成，从而产生整洁的虚假深度（视差效果）。这种运动是恒定的，与任何游戏事件无关；这使得背景成为实现的一个理想起点。'
- en: '**Obstacles (pipes)**: This is a separate graphical layer that also advances
    towards the player at a constant speed. As opposed to the background, the pipes
    are procedurally adjusted to have different relative heights, keeping the gap
    between them passable for the player. A collision with a pipe ends the game.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**障碍物（管道）**：这是一个独立的图形层，它以恒定的速度向玩家移动。与背景不同，管道会以不同的相对高度进行程序化调整，以保持玩家可以通过的间隙。与管道碰撞将结束游戏。'
- en: '**Playable character (the bird)**: This sprite moves only vertically, constantly
    falling down. The player bumps it by clicking or tapping anywhere on the screen,
    this pushes the bird upwards. As soon as the bird meets floor, ceiling, or a pipe,
    the game ends.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可玩角色（小鸟）**：这个精灵只垂直移动，不断向下坠落。玩家可以通过点击或轻触屏幕上的任何位置来推动小鸟向上，一旦小鸟碰到地面、天花板或管道，游戏就结束了。'
- en: This is roughly the order in which we're going to write the implementation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致是我们将要编写的实现顺序。
- en: Creating an animated background
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个动画背景
- en: 'We are going to use the following images to create the background for our game:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下图像来创建游戏的背景：
- en: '![Creating an animated background](img/7849OS_07_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![创建动画背景](img/7849OS_07_02.jpg)'
- en: Images for the background
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 背景图像
- en: Note that all of these can be seamlessly tiled horizontally—this isn't a strict
    requirement, but a desirable property nonetheless, as the background looks nicer
    this way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些都可以无缝水平平铺——这不是一个严格的要求，但仍然是一个期望的特性，因为这样背景看起来更美观。
- en: 'As mentioned in the description, the background is always in motion, disconnected
    from the rest of the game. This effect can be achieved in at least two ways:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如描述中提到的，背景始终在运动，与游戏的其他部分无关。这种效果可以通过至少两种方式实现：
- en: Using the straightforward approach, we can just move a huge textured polygon
    (or any number of polygons) in the background. Creating seamless looping animation
    in this case may require a bit of work.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直接的方法，我们只需在背景中移动一个巨大的纹理多边形（或任意数量的多边形）。在这种情况下创建无缝循环动画可能需要一些工作。
- en: A more efficient way to achieve the same visual effect is to create a number
    of static polygons (one per layer) that span the whole viewport, and then animate
    just texture coordinates. With a tileable texture, this approach produces seamless
    and visually pleasing results, and amounts to less work overall—there is no need
    to reposition objects.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现相同视觉效果的一种更有效的方法是创建多个静态多边形（每个层一个），覆盖整个视口，然后仅对纹理坐标进行动画处理。使用可平铺的纹理，这种方法会产生无缝且视觉上令人愉悦的结果，并且总体工作量更小——无需重新定位对象。
- en: 'We will implement the second approach, as it''s both easier and more effective.
    Let''s start with the `kivybird.kv` file that contains the layout:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用第二种方法，因为它既简单又有效。让我们从包含布局的`kivybird.kv`文件开始：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'All "magic numbers" from here on refer mostly to texture dimensions: `96` is
    the ground level, `64` is the height of grass, and `144` is a somewhat arbitrary
    level of clouds. Hardcoding things like that in production code is usually frowned
    upon, but we shall do it occasionally for the sake of simplicity and to minimize
    code size of examples.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，“魔法数字”主要指的是纹理尺寸：`96`是地面高度，`64`是草的高度，`144`是云的某种任意高度。在生产代码中硬编码这类东西通常是不受欢迎的，但为了简单和最小化示例代码的大小，我们偶尔会这样做。
- en: As you can see, there are no moving parts here at all, just three rectangles
    positioned along the top and bottom edges of the screen. This scene depends on
    textures being exposed as properties (beginning with `tx_`) of the `Background`
    class, which we're going to implement next.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里根本没有任何移动部件，只是沿着屏幕顶部和底部边缘定位了三个矩形。此场景依赖于纹理作为 `Background` 类的属性（以 `tx_`
    开头）公开，我们将实现它。
- en: Loading tileable textures
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载可平铺纹理
- en: 'We shall start with the helper function for loading tileable textures: this
    functionality will be used a lot in the following code, so it''s a good idea to
    abstract it up front.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个用于加载可平铺纹理的辅助函数开始：此功能将在以下代码中大量使用，因此最好在前面将其抽象化。
- en: 'One way to do so is creating an intermediate `Widget` subclass, which will
    then serve as a base class for our custom widgets (in `main.py`):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 做法之一是创建一个中间的 `Widget` 子类，然后将其用作自定义小部件的基类（在 `main.py` 中）：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The bit that warrants creating the helper function is `t.wrap = 'repeat'`. We
    need to apply this to every tiled texture.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建辅助函数的部分是 `t.wrap = 'repeat'`。我们需要将此应用于每个平铺纹理。
- en: While we're at that, we also store the newly loaded texture using the naming
    convention of `tx_` followed by the filename of an image. For example, a call
    to `load_tileable('grass')` will load the file called `grass.png` and store the
    resulting texture in a `self.tx_grass` attribute. This naming logic should be
    easy to follow.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，我们还使用 `tx_` 命名约定后跟图像文件名的方式存储新加载的纹理。例如，调用 `load_tileable('grass')` 将加载名为
    `grass.png` 的文件，并将生成的纹理存储在 `self.tx_grass` 属性中。这种命名逻辑应该很容易理解。
- en: The Background widget
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景小部件
- en: 'Being able to conveniently load textures, we can now implement the `Background`
    widget as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 能够方便地加载纹理后，我们现在可以按照以下方式实现 `Background` 小部件：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run the code at this point, you'll see distorted textures stretched to
    fill corresponding rectangles; this happens in the absence of explicitly given
    texture coordinates. To fix this, we need to adjust the `uvsize` property of each
    texture, which denotes how many times a texture is repeated to fill a polygon.
    For example, a `uvsize` of `(2, 2)` means that a texture fills one fourth of a
    rectangle.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此处运行代码，您将看到扭曲的纹理拉伸以填充相应的矩形；在没有明确给出纹理坐标的情况下会发生这种情况。为了修复此问题，我们需要调整每个纹理的 `uvsize`
    属性，该属性表示纹理重复多少次以填充多边形。例如，`uvsize` 为 `(2, 2)` 表示纹理填充矩形的一个四分之一。
- en: 'This helper method will be used to set `uvsize` to an appropriate value so
    that our textures aren''t distorted:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此辅助方法将用于设置 `uvsize` 到适当的值，以便我们的纹理不会扭曲：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Negative texture coordinates, as seen in this example, mean that the texture
    gets flipped. Kivy uses this effect to avoid costly raster operations, shifting
    the load to the GPU (graphics card), which is designed to handle these operations
    with ease.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 负纹理坐标，如本例所示，意味着纹理会被翻转。Kivy 使用此效果来避免昂贵的光栅操作，将加载任务转移到 GPU（显卡），后者设计用于轻松处理这些操作。
- en: 'This method depends on the width of a background, so it''s appropriate to invoke
    it every time the widget''s `size` property changes, using the `on_size()` callback.
    This keeps each texture''s `uvsize` in sync, for example, when the user resizes
    the application window manually:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法依赖于背景的宽度，因此每次小部件的 `size` 属性更改时，使用 `on_size()` 回调来调用它是合适的。这保持了每个纹理的 `uvsize`
    同步，例如，当用户手动调整应用程序窗口大小时：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If done properly, the code so far produces a background similar to the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果做得正确，到目前为止的代码将生成类似于以下背景：
- en: '![The Background widget](img/7849OS_07_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![背景小部件](img/7849OS_07_03.jpg)'
- en: Static background with textures
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 带纹理的静态背景
- en: Animating the background
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画背景
- en: 'The last thing that we need to do before moving on to other parts of the application
    is a background animation. First, we add a monotonous timer running at roughly
    60 ticks per second to the `KivyBirdApp` application class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理应用程序的其他部分之前，我们需要做的是添加背景动画。首先，我们向 `KivyBirdApp` 应用程序类添加一个大约每秒运行 60 次的单调计时器：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `update()` method just passes control to a similar method of the `Background`
    widget for now. The scope of this method is going to expand later, when we have
    more moving parts in our program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 `update()` 方法只是将控制权传递给 `Background` 小部件的类似方法。此方法的范围将在我们程序中有更多移动部件时扩展。
- en: 'In `Background.update()`, we change the texture origin (namely, a property
    called `uvpos`) to simulate movement:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Background.update()` 中，我们更改纹理原点（即名为 `uvpos` 的属性）以模拟移动：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Again, the interesting stuff happens in a helper function, `set_background_uv()`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，有趣的事情发生在辅助函数 `set_background_uv()` 中：
- en: It increments the first component of the `uvpos` property, shifting the texture
    origin horizontally
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加 `uvpos` 属性的第一个组件，水平移动纹理原点
- en: It calls `dispatch()` on the texture property, signaling that it has changed
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在纹理属性上调用 `dispatch()`，表示它已更改
- en: Canvas instructions (in `kivybird.kv`) listen to this change and react accordingly,
    rendering the texture with updated origin. This results in a smooth animation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 画布指令（在 `kivybird.kv` 中）监听此变化并相应地做出反应，以更新的原点渲染纹理。这导致动画平滑。
- en: Multipliers that control the animation speed of different layers (see the second
    argument of all `set_background_uv()` calls) are selected arbitrarily to create
    the desired parallax effect. This is purely cosmetic; go ahead and change them
    to witness the effect it has on the animation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 控制不同图层动画速度的乘数（参见所有 `set_background_uv()` 调用的第二个参数）被任意选择以创建所需的视差效果。这纯粹是装饰性的；你可以随意更改它们，以见证它对动画的影响。
- en: The background is now complete, and the next thing on our list is making pipes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 背景现在已经完成，接下来我们列表上的下一件事是制作管道。
- en: Making pipes
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作管道
- en: 'A pipe is divided into two parts, lower and upper, with a gap in between for
    player to pass through. Each part, in turn, consists of variable-length body and
    the pipe cap, or *pcap*—a fixed-size thickening at the end of the pipe facing
    the gap. We are going to use the following images to draw pipes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 管道分为两部分，下部和上部，中间有一个间隙供玩家通过。每一部分，反过来，又由可变长度的主体和管道盖，或 *pcap*（管道面对间隙的固定大小加厚部分）组成。我们将使用以下图像来绘制管道：
- en: '![Making pipes](img/7849OS_07_04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![制作管道](img/7849OS_07_04.jpg)'
- en: Images for pipes
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 管道图像
- en: If the preceding explanation doesn't ring the bell, see the first illustration
    in this chapter and you'll immediately understand what this means.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的解释没有引起你的共鸣，请参阅本章的第一幅插图，你将立即理解这是什么意思。
- en: 'Again, the layout in the `kivybird.kv` file provides a convenient starting
    point:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`kivybird.kv` 文件中的布局提供了一个方便的起点：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Conceptually, this is very simple: four rectangles are being rendered on canvas,
    listed in the order of appearance in the source:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，这非常简单：在画布上渲染了四个矩形，按照源文件中出现的顺序列出：
- en: Lower pipe body
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下部管道主体
- en: Lower pipe cap
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下部管道盖
- en: Upper pipe body
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上部管道主体
- en: Upper pipe cap
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上部管道盖
- en: '![Making pipes](img/7849OS_07_09.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![制作管道](img/7849OS_07_09.jpg)'
- en: Composition of pipes from rectangles
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从矩形组成管道
- en: This listing depends on many attributes of the `Pipe` object; similar to how
    the `Background` widget is implemented, these properties are used to connect the
    Python implementation of an algorithm to a graphical representation of the widget
    (canvas instructions).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表依赖于 `Pipe` 对象的许多属性；类似于 `Background` 小部件的实现，这些属性用于将算法的 Python 实现与小部件的图形表示（画布指令）连接起来。
- en: An overview of the pipe properties
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道属性的概述
- en: 'All the interesting attributes of the `Pipe` widget are shown in the following
    code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pipe` 小部件的所有有趣属性都在以下代码片段中展示：'
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, constants are set in `ALL_CAPS`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `ALL_CAPS` 中设置常量：
- en: '`FLOOR`: This is the ground level (height of the floor texture)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLOOR`：这是地面水平（地板纹理的高度）'
- en: '`PCAP_HEIGHT`: This is the height of a pipe cap, also derived from the corresponding
    texture'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PCAP_HEIGHT`：这是管道盖的高度，也来自相应的纹理'
- en: '`PIPE_GAP`: This is the size of passage left for the player'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PIPE_GAP`：这是留给玩家的通道大小'
- en: 'Next come the texture properties `tx_pipe` and `tx_pcap`. They are used in
    the same fashion as those found in the `Background` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是纹理属性 `tx_pipe` 和 `tx_pcap`。它们的使用方式与 `Background` 类中找到的方式相同：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `ratio` property indicates where the gap is located: the value of `0.5`
    (the default) means center, `0` is the bottom of the screen (on the ground), and
    `1` is the top of the screen (in the sky).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ratio` 属性指示间隙的位置：`0.5`（默认值）表示中心，`0` 是屏幕底部（在地面上），而 `1` 是屏幕顶部（在天空）。'
- en: The `lower_len` and `upper_len` properties represent pipe lengths, excluding
    the cap. These are derived from `ratio` and the available screen height.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower_len` 和 `upper_len` 属性表示管道长度，不包括盖子。这些是从 `ratio` 和可用的屏幕高度派生出来的。'
- en: The `upper_y` alias is a helper introduced to reduce typing; it's computed on
    the fly and is always equal to `height - upper_len` (see the implementation).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper_y` 别名是一个辅助工具，用于减少输入；它是即时计算的，始终等于 `height - upper_len`（参见实现）。'
- en: This leaves us with two important properties used to set texture coordinates
    for canvas instructions, namely `lower_coords` and `upper_coords`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们留下了两个重要的属性，用于为画布指令设置纹理坐标，即`lower_coords`和`upper_coords`。
- en: Setting texture coordinates
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置纹理坐标
- en: In the implementation of the `Background` widget, we were tweaking the texture's
    own attributes, such as `uvsize` and `uvpos`, to control its rendering. The problem
    with this approach is that it affects all instances of the texture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Background`小部件的实现中，我们调整了纹理的自身属性，如`uvsize`和`uvpos`，以控制其渲染。这种方法的问题在于它会影响所有纹理实例。
- en: This is perfectly fine as long as textures aren't reused on different geometries,
    which is exactly the case with the background. This time around, however, we need
    to control texture coordinates per canvas primitive, so we're not going to touch
    `uvsize` and `uvpos` at all. Instead, we will use `Rectangle.tex_coords`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只要纹理不在不同的几何形状上重复使用，这正好是背景的情况。然而，这一次，我们需要按画布原语控制纹理坐标，所以我们不会触摸`uvsize`和`uvpos`。相反，我们将使用`Rectangle.tex_coords`。
- en: 'The `Rectangle.tex_coords` property accepts a list or tuple of eight numbers,
    assigning texture coordinates to corners of the rectangle in question. The mapping
    of coordinates to indices in the `tex_coords` list is shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle.tex_coords`属性接受一个包含八个数字的列表或元组，将纹理坐标分配给矩形的角落。以下截图显示了坐标到`tex_coords`列表索引的映射：'
- en: '![Setting texture coordinates](img/7849OS_07_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![设置纹理坐标](img/7849OS_07_05.jpg)'
- en: Mapping of texture coordinates to a rectangular polygon
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标到矩形多边形的映射
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Texture mapping commonly uses *u* and *v* variables instead of *x* and *y*.
    This makes it easier to tell apart geometry and texture coordinates, which are
    often interleaved in code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理映射通常使用`u`和`v`变量而不是`x`和`y`，这使得区分几何和纹理坐标更容易，这些坐标在代码中通常交织在一起。
- en: Implementing pipes
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现管道
- en: 'This whole topic may sound confusing at first, so let''s simplify things a
    bit: we''re only going to fix tiling on pipes vertically, and we just need to
    adjust the fifth and seventh elements of `tex_coords` to achieve our noble goal.
    Moreover, the values in `tex_coords` have the same meaning as those in `uvsize`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题一开始可能听起来很复杂，所以让我们稍微简化一下：我们只会在管道上垂直调整平铺，我们只需要调整`tex_coords`的第五和第七个元素来实现我们的高尚目标。此外，`tex_coords`中的值与`uvsize`中的值具有相同的意义。
- en: 'Long story short, the following function adjusts the coordinates for correct
    tiling based on pipe length:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以下函数根据管道长度调整坐标以实现正确的平铺：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Easy, right? What''s left to do is a boring, yet also not at all complicated
    math: computing the length of pipes based on `ratio` and screen height. The code
    is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很简单吗？接下来要做的是一项既无聊又并不复杂的数学工作：根据`ratio`和屏幕高度计算管道的长度。代码如下：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This pretty self-evident code lives in the `on_size()` handler to keep all
    related properties in sync with the screen size. To also reflect changes to `ratio`,
    we can issue the following function call:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常明显，位于`on_size()`处理程序中，以保持所有相关属性与屏幕大小同步。为了反映对`ratio`的更改，我们可以发出以下函数调用：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may have noticed that we don't change this property in our code yet. This
    is because the whole lifecycle of the pipes will be handled by the application
    class, `KivyBirdApp`, as you will see shortly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们还没有更改这个属性。这是因为管道的整个生命周期将由应用程序类`KivyBirdApp`处理，你很快就会看到。
- en: Spawning pipes
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建管道
- en: It turns out that to create an illusion of an endless forest of pipes, we need
    just a screenful of them, as we can recycle ones that went off the screen and
    push them to the back of the queue.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，为了创建一个看似无尽的管道森林的错觉，我们只需要一屏幕的管道，因为我们可以在屏幕外回收它们并将它们推到队列的后面。
- en: We're going to create pipes about half screen width apart from one another to
    give the player some wiggle room; this means that only three pipes can be seen
    on the screen at the same time. We will create four of them for a good measure.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建间距约为屏幕宽度一半的管道，给玩家留出一些操作空间；这意味着屏幕上一次只能看到三个管道。为了保险起见，我们将创建四个管道。
- en: 'The following code snippet contains an implementation of the described algorithm:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段包含了对所述算法的实现：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The use of the `pipes` list should be considered an implementation detail. We
    could have traversed the list of child widgets to access pipes, but it's just
    nicer this way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 应将`pipes`列表的使用视为实现细节。我们本可以遍历子小部件的列表来访问管道，但这样做更方便。
- en: The cleanup code at the beginning of the `spawn_pipes()` method will allow us
    to easily restart the game later.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spawn_pipes()`方法的开始处的清理代码将允许我们稍后轻松地重新启动游戏。
- en: We also randomize each pipe's `ratio` in this function. Notice that the range
    is artificially constrained to [0.25, 0.75], while technically it's [0, 1]—narrowing
    this space makes the game somewhat easier to play, with fewer vertical maneuvers
    necessary to go from gate to gate.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在这个函数中随机化每个管道的`ratio`。请注意，范围被人为地限制在[0.25, 0.75]，而技术上它是[0, 1]——缩小这个空间使得游戏更容易玩，从一门到另一门需要的垂直操作更少。
- en: Moving and recycling pipes
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动和回收管道
- en: 'Unlike the background where we shifted the textures'' `uvpos` attribute to
    imitate movement, pipes actually move. This is the revised `KivyBirdApp.update()`
    method that involves repositioning and recycling pipes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们移动纹理的`uvpos`属性以模仿移动的背景不同，管道实际上是移动的。这是修改后的`KivyBirdApp.update()`方法，它涉及重新定位和回收管道：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As with the previous animations, `96` is an ad hoc time multiplier that just
    happens to work; increasing it makes the game more fast-paced.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的动画一样，`96`是一个临时的时间乘数，恰好适用；增加它会使游戏节奏更快。
- en: 'When pushing back a pipe, we randomize its `ratio` again, creating a unique
    path for the player to follow. The following screenshot summarizes the endlessly
    looping result so far:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当推回一个管道时，我们再次随机化它的`ratio`，为玩家创造一条独特的路径。以下截图总结了到目前为止无限循环的结果：
- en: '![Moving and recycling pipes](img/7849OS_07_06.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![移动和回收管道](img/7849OS_07_06.jpg)'
- en: Moving pipes and background – a Flappy Bird-themed screensaver
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 移动管道和背景 – 一个Flappy Bird主题的屏保
- en: Introducing Kivy Bird
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍基维鸟
- en: 'Next on our list is the playable character, that is, the biologically improbable
    Kivy Bird:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在我们的列表中是可玩的角色，即生物上不可能存在的基维鸟：
- en: '![Introducing Kivy Bird](img/7849OS_07_07.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![介绍基维鸟](img/7849OS_07_07.jpg)'
- en: Rare species, the Kivy Bird sprite
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 稀有物种，基维鸟精灵
- en: There will be nothing fancy related to textures this time; in fact, the `Bird`
    class will be derived from Kivy's `Image` widget (`kivy.uix.image.Image`) to completely
    avoid doing any clever rendering whatsoever.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这次将不会有与纹理相关的任何花哨的东西；实际上，`Bird`类将从Kivy的`Image`小部件（`kivy.uix.image.Image`）派生出来，以完全避免进行任何复杂的渲染。
- en: 'In `kivybird.kv` we need a bare minimum of properties involving the bird image
    depicted earlier; its initial position and size are given as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kivybird.kv`中，我们需要涉及之前描述的鸟的图像的最小属性；其初始位置和大小如下所示：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the initial implementation of the `Bird` class in Python:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python中`Bird`类的初始实现：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Yup, it does nothing at all. Soon, we're going to spoil it by adding rudimentary
    physics and other things, but first we need to lay some groundwork in the application
    class in order to make the game stateful.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它什么也不做。很快，我们将通过添加基本的物理和其他东西来破坏它，但首先我们需要在应用程序类中做一些基础工作，以便使游戏状态化。
- en: Revised application flow
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改后的应用程序流程
- en: 'Now, we shall mimic the original game somewhat:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将模仿原始游戏：
- en: At first, we'll just show the bird sitting there without any pipes or gravitation.
    Such a state will be denoted by `playing = False` in the code.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将只显示小鸟坐在那里，没有任何管道或重力。这种状态在代码中将表示为`playing = False`。
- en: As soon as the user interacts with the game (either clicks or taps anywhere
    on the screen, or presses the space bar on the keyboard), the state changes to
    `playing = True`, pipes start spawning, and gravity starts to affect the bird,
    which falls as a rock to an imaginary death. The user needs to continue interacting
    with the game to keep the bird airborne.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户一旦与游戏互动（无论是点击或触摸屏幕上的任何位置，还是按下键盘上的空格键），状态就会变为`playing = True`，管道开始生成，重力开始影响小鸟，它像一块石头一样掉入想象中的死亡。用户需要继续与游戏互动，以保持小鸟在空中。
- en: In the event of collision with something, the game goes back to `playing = False`
    and everything sits in place until the next user interaction, which in turn restarts
    the process from step 2.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生碰撞，游戏将回到`playing = False`状态，直到下一次用户互动，然后从步骤2重新启动这个过程。
- en: In order to implement this, we need to receive user input. Thankfully, this
    is borderline trivial, especially since we're interested just in the fact that
    an event occurred (we aren't checking where the click or tap landed, for example—the
    whole screen is one big button for the purposes of this game).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要接收用户输入。幸运的是，这几乎是微不足道的，特别是我们只对事件发生的事实感兴趣（例如，我们不是检查点击或触摸的位置——在这个游戏中，整个屏幕就是一个大按钮）。
- en: Accepting user input
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受用户输入
- en: 'Let''s take a look at the implementation right away, since there is very little
    left to discuss on this particular topic:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即查看实现，因为在这个特定主题上几乎没有讨论的余地：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is the whole user input handling we''re going to need: the `on_key_down`
    event handles the keyboard input, checking for a specific key (in this case, the
    spacebar). The `on_touch_down` event handles the rest—clicking, tapping, and whatnot.
    Both ultimately end up calling the `user_action()` method, which in turn runs
    `spawn_pipes()` and sets `playing` to `True` (only when needed).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要需要的整个用户输入处理：`on_key_down`事件处理键盘输入，检查特定键（在这种情况下，是空格键）。`on_touch_down`事件处理其余操作——点击、轻触等。两者最终都会调用`user_action()`方法，该方法进而调用`spawn_pipes()`并将`playing`设置为`True`（仅在需要时）。
- en: Learning to fly straight down
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习直线下降飞行
- en: Next, we're going to implement gravity so that our bird could fly in at least
    one direction. For this, we will introduce a new `Bird.speed` property and a new
    constant—the acceleration of free fall. The speed vector will grow downwards each
    frame, resulting in a uniformly accelerated animation of falling.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现重力，使我们的鸟至少能向一个方向飞行。为此，我们将引入一个新的`Bird.speed`属性和一个新的常量——自由落体的加速度。速度向量将每帧向下增长，从而产生均匀加速的下降动画。
- en: 'The following listing contains the implementation of a described shooting bird:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含描述的射击小鸟的实现：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `gravity_on()` method will be called when `playing` becomes `True`. Insert
    the highlighted line into the `KivyBirdApp.user_action()` method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当`playing`变为`True`时，将调用`gravity_on()`方法。将高亮行插入到`KivyBirdApp.user_action()`方法中：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method effectively resets the initial position of a bird and allows vertical
    motion by removing the `'center_y'` constraint from `pos_hint`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法实际上重置了小鸟的初始位置，并通过从`pos_hint`中移除`'center_y'`约束来允许垂直运动。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `self.bird` reference is similar to `self.background` that we''ve seen
    earlier. The following code snippet should reside in the `KivyBirdApp.on_start()`
    method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.bird`引用与之前见过的`self.background`类似。以下代码片段应位于`KivyBirdApp.on_start()`方法中：'
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is done for convenience alone.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了方便。
- en: 'We also need to call `Bird.update()` from `KivyBirdApp.update()`. At the same
    time, this is the perfect opportunity to put a guard preventing useless updates
    to game objects while not playing:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`KivyBirdApp.update()`中调用`Bird.update()`。同时，这也是放置一个保护器的完美机会，防止在游戏对象未播放时进行无用的更新：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, the `Background.update()` method gets called no matter what;
    everything else is invoked only when necessary.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，无论发生什么情况，都会调用`Background.update()`方法；其他所有操作只有在必要时才会被调用。
- en: What's missing from this implementation is the ability to stay in the air. This
    will be our next topic.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中缺少的是保持空中飞行的能力。这是我们下一个要讨论的主题。
- en: Remaining in flight
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持飞行状态
- en: 'Implementing the Flappy Bird-style jumpy flight is incredibly easy. We can
    just override the `Bird.speed` momentarily, setting it to a positive value and
    then letting it decay normally as the bird continues to fall. Let''s add the following
    method to the `Bird` class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Flappy Bird风格的跳跃飞行非常简单。我们只需暂时覆盖`Bird.speed`，将其设置为正值，然后让它在小鸟继续下落时正常衰减。让我们向`Bird`类添加以下方法：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we need to put a call to `self.bird.bump()` at the end of the `KivyBirdApp.user_action()`
    function, and there, all done: we can stay in the air by mashing the spacebar
    or clicking inside the viewport repeatedly.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在`KivyBirdApp.user_action()`函数的末尾添加对`self.bird.bump()`的调用，在那里，一切就绪：我们可以通过连续按空格键或点击视口内部来保持在空中。
- en: Rotating the bird
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转小鸟
- en: 'Rotating the bird is a brief topic and isn''t related to the physics of the
    bird, but instead focuses on the eye candy. It would be nice if the bird would
    rotate accordingly to its trajectory: if it''s going up, its nose should point
    in a general direction of the top-right corner of the screen and towards the bottom-right
    corner when it declines.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转小鸟是一个简短的主题，与小鸟的物理特性无关，而是专注于视觉效果。如果小鸟向上飞行，它的鼻子应该指向屏幕右上角的一般方向，当它下降时，则指向屏幕右下角。
- en: 'The easiest way to approximate the angle is by using the value of `Bird.speed`
    instead:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 估算角度的最简单方法是用`Bird.speed`的值：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Again, the multiplier shown here is completely arbitrary.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里显示的乘数完全是任意的。
- en: 'Now, in order to actually rotate the sprite, we can introduce the following
    definition to the `kivybird.kv` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了实际上旋转精灵，我们可以在`kivybird.kv`文件中引入以下定义：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This operation changes the local coordinate system that OpenGL uses for this
    sprite, potentially affecting all subsequent rendering. Don't forget to save (`PushMatrix`)
    and restore (`PopMatrix`) the coordinate system state; otherwise, catastrophic
    glitches may occur, and the whole scene can end up skewed or spinning.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作改变了 OpenGL 为这个精灵使用的本地坐标系，可能会影响所有后续的渲染。别忘了保存（`PushMatrix`）和恢复（`PopMatrix`）坐标系状态；否则，可能会发生灾难性的故障，整个场景可能会扭曲或旋转。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The opposite is also true: if you''re experiencing inexplicable application-wide
    rendering problems, look for low-level OpenGL instructions that aren''t properly
    scoped.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来也是如此：如果你遇到无法解释的应用程序范围内的渲染问题，查找未正确作用域的低级 OpenGL 指令。
- en: After these changes, the bird should properly align itself with the trajectory
    of the flight.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，鸟应该正确地调整自己的飞行轨迹。
- en: Collision detection
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: The last thing that is absolutely vital for the gameplay is the collision detection,
    which ends the game when the bird collides with either the floor, the ceiling,
    or a pipe.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏玩法来说，最重要的是碰撞检测，当鸟与地面、天花板或管道碰撞时，游戏结束。
- en: Checking whether we've met floor or ceiling is as simple as comparing `bird.y`
    to a ground level or screen height (taking into account the height of the bird
    itself in the second comparison). In `KivyBirdApp`, we have the following code
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们是否达到了地面或天花板，就像比较 `bird.y` 与地面水平或屏幕高度（在第二次比较时考虑到鸟本身的高度）。在 `KivyBirdApp` 中，我们有以下代码
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It''s a bit more complex when looking for a collision with pipes, but not substantially
    so. We can subdivide this next check in two: first, we test for a horizontal collision
    using Kivy''s built-in `collide_widget()` method, and then check whether vertical
    coordinates are within limits imposed by the `lower_len` and `upper_len` attributes
    of a pipe we''re flying into.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当寻找与管道的碰撞时，情况稍微复杂一些，但并不十分复杂。我们可以将接下来的检查分为两部分：首先，我们使用 Kivy 内置的 `collide_widget()`
    方法测试水平碰撞，然后检查垂直坐标是否在进入的管道的 `lower_len` 和 `upper_len` 属性所规定的范围内。
- en: 'Hence, the revised version of the `KivyBirdApp.test_game_over()` method is
    shown as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`KivyBirdApp.test_game_over()` 方法的修订版如下所示：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function returns `False` only if every check failed. This could be further
    optimized to test a maximum of one pipe at a time (the one which is roughly in
    the same area on screen as the bird; there is always at most one such pipe, given
    enough spacing between them).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数仅在所有检查都失败时返回 `False`。这可以进一步优化，以一次测试最多一个管道（在屏幕上与鸟大致在同一区域的管道；考虑到它们之间有足够的间隔，这样的管道最多只有一个）。
- en: Game over
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束
- en: 'So what happens when a collision was indeed found? As it turns out, very little;
    we just switch `self.playing` to `False`, and that''s it. The check can be added
    to the bottom of `KivyBirdApp.update()` after all other computations take place:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当确实发现碰撞时会发生什么？实际上，非常少；我们只需将 `self.playing` 切换为 `False`，就结束了。检查可以在所有其他计算完成后添加到
    `KivyBirdApp.update()` 的底部：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This stops the world until the user triggers another interaction, restarting
    the game. The most rewarding part of writing the collision detection code is playtesting
    it, triggering the game over state in a multitude of amusing ways:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止游戏，直到用户触发另一个交互，重新开始游戏。编写碰撞检测代码最有回报的部分是进行游戏测试，以多种有趣的方式触发游戏结束状态：
- en: '![Game over](img/7849OS_07_08.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束](img/7849OS_07_08.jpg)'
- en: Exploring different approaches to failing (collage)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 探索失败的不同方法（拼贴）
- en: If there is no winning condition, then at least losing should be fun.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有胜利条件，那么至少失败应该是有趣的。
- en: Producing sound effects
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作音效
- en: This part will be less focused on the Kivy Bird game specifically; it's more
    of an overview of various tools that can be employed to add sound effects to a
    game or application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将不会特别关注 Kivy 鸟游戏本身；更多的是概述可以用于向游戏或应用程序添加音效的各种工具。
- en: The biggest problem with sound effects is rarely a technical one. Creating good-quality
    sound effects is no small task, and software engineers oftentimes aren't skilled
    musicians or audio engineers. Moreover, most applications are actually usable
    with no sound, which is why audio can easily be purposefully neglected or just
    overlooked during development.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 声音效果的最大问题很少是技术性的。创建高质量的音效不是一件小事，而且软件工程师通常不是技艺高超的音乐家或音频工程师。此外，大多数应用程序实际上在没有声音的情况下也是可用的，这就是为什么音频很容易在开发过程中被故意忽视或忽略。
- en: Fortunately, there are tools that facilitate producing okay-quality sound effects
    while possessing zero domain-specific knowledge. A perfect example is **Bfxr**,
    a synthesizer specifically aimed at sporadic game development. It is available
    for free at [www.bfxr.net](http://www.bfxr.net).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些工具可以方便地制作出质量不错的音效，同时不需要任何特定领域的知识。一个完美的例子是**Bfxr**，这是一个专门针对偶尔进行游戏开发的合成器。它可以在[www.bfxr.net](http://www.bfxr.net)免费获得。
- en: The usage of Bfxr family of tools boils down to clicking preset buttons until
    it generates a nice sound, and then hitting **Save to Disk** to store the result
    as a `.wav` (uncompressed sound) file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Bfxr工具系列的用法归结为点击预设按钮，直到生成一个好听的声音，然后点击**保存到磁盘**以将结果存储为`.wav`（未压缩声音）文件。
- en: '![Producing sound effects](img/7849OS_07_10.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![制作音效](img/7849OS_07_10.jpg)'
- en: Bfxr's user interface may not seem friendly at first, but it's actually very
    easy to use
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Bfxr的用户界面一开始可能看起来不太友好，但实际上非常容易使用
- en: This is a great tool in terms of productivity. Using Bfxr, you can create passable
    sound effects literally within minutes—and they will be (mostly) unique to your
    app. For many hobbyist game developers, this program is truly a game changer,
    pun intended.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一款在提高生产力方面非常出色的工具。使用Bfxr，你可以在几分钟内就创造出可用的音效——而且这些音效将（大部分）仅适用于你的应用程序。对于许多业余游戏开发者来说，这个程序真正是一个变革性的工具，这不是字面上的意思。
- en: Kivy sound playback
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kivy音效播放
- en: 'On the programmatic side of things, the API for playback that Kivy provides
    is dead simple:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序方面，Kivy提供的播放API非常简单：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `play()` method starts playback, and that''s it. Well, not really: there
    is a slight problem with this simplistic approach, especially for games.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`play()`方法开始播放，就这么多。嗯，实际上并不是：这种简单的方法存在一些问题，尤其是在游戏中。'
- en: In many game situations, it may be desirable to play the same sound over and
    over in rapid succession so that samples overlap. Take, for example, automatic
    fire. The problem with Kivy's `Sound` class (not unique to it, however—for example,
    the `<audio>` tag in HTML5 behaves similarly) is that it allows only one instance
    of the sample to play at any given time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多游戏场景中，可能需要连续快速地播放相同的音效，以便样本重叠。以自动射击为例。Kivy的`Sound`类（尽管并非特有，例如HTML5中的`<audio>`标签也有类似行为）的问题在于它只允许在任何给定时间播放一个样本实例。
- en: 'The options are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 选项如下：
- en: Wait until the previous playback has ended (the default behavior, all subsequent
    events will be silent)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待之前的播放结束（默认行为，所有后续事件都将静音）
- en: Stop and restart the playback for each event, which is also problematic (this
    may introduce unnecessary delays, clicks, or other audio artifacts)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个事件停止并重新开始播放，这也是一个问题（这可能会引入不必要的延迟、点击或其他音频伪影）
- en: To solve this issue, we need to create a pool (actually a queue) of `Sound`
    objects so that each subsequent call to `play()` involves another `Sound`. When
    the queue is exhausted, we rewind it and start from the beginning. Given a queue
    large enough, we can get rid of the aforementioned `Sound` limitation completely.
    In practice, such pool rarely exceeds a size of 10.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要创建一个`Sound`对象的池（实际上是一个队列），以便每次调用`play()`都涉及另一个`Sound`。当队列耗尽时，我们将其重置并从头开始。给定足够大的队列，我们可以完全消除上述`Sound`限制。实际上，这样的池的大小很少超过10。
- en: 'Let''s take a look at the implementation of the described technique:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看描述技术的实现：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The usage is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The second argument to the constructor stands for pool size. Note how we keep
    rudimentary compatibility with the existing `Sound` API, namely the `play()` method.
    This allows using the code as a drop-in replacement of a `Sound` object in simple
    scenarios.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的第二个参数代表池的大小。注意我们如何保持与现有`Sound` API的基本兼容性，即`play()`方法。这允许在简单场景中使用代码作为`Sound`对象的直接替换。
- en: Adding sound to the Kivy Bird game
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Kivy Bird游戏添加音效
- en: To finish things off with a practical example, let's add sound effects to the
    Kivy Bird game we've written over the course of this chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用一个实际例子结束，让我们为我们在本章中编写的Kivy Bird游戏添加音效。
- en: There are two frequent events that could use a soundtrack, namely, the bird
    climbing and the bird colliding with objects and triggering the game over state.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种常见的事件可能需要配乐，即鸟儿爬升和鸟儿与物体碰撞触发游戏结束状态。
- en: 'The former event, initiated by clicking or tapping, can indeed happen very
    frequently in a rapid succession; we''ll use a sample pool for this one. The latter,
    game over, can''t possibly occur quite as fast, so it''s fine to leave it as a
    plain `Sound` object:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前者事件，由点击或轻触引发，确实可能非常频繁地连续发生；我们将为此使用一个样本池。后者，游戏结束，不可能发生得那么快，所以将其保留为普通的 `Sound`
    对象是完全可以的：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code makes use of the `MultiAudio` class laid out earlier. The only thing
    left is to put calls to the `play()` method at the appropriate points, as shown
    in the following code snippet:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用了之前布置的 `MultiAudio` 类。唯一剩下的事情就是在适当的位置放置对 `play()` 方法的调用，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: From now on, the gameplay will be accompanied by heart-rending sounds. This
    concludes the Kivy Bird game tutorial; I hope you liked it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，游戏玩法将伴随着撕心裂肺的声音。这标志着 Kivy 鸟游戏教程的结束；我希望你们喜欢。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we made a small Kivy game from simple building blocks such
    as canvas instructions and widgets.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用简单的构建块，如画布指令和小部件，制作了一个小的 Kivy 游戏。
- en: As a UI toolkit, Kivy gets many things right and its remarkable flexibility
    allows you to build pretty much anything, be it another boring Twitter client
    or a video game. One aspect that deserves special mention is Kivy's implementation
    of properties—these are immensely helpful to organize data flow across the board
    and help us to effectively eliminate useless updates (such as redraws in the absence
    of changed properties).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 UI 工具包，Kivy 做了很多正确的事情，其非凡的灵活性允许你构建几乎任何东西，无论是另一个无聊的 Twitter 客户端还是一款视频游戏。值得特别提一下的是
    Kivy 对属性的实现——这些属性在组织数据流方面非常有帮助，并帮助我们有效地消除无用的更新（例如，在属性未更改的情况下重绘）。
- en: Another thing about Kivy that may be surprising and counterintuitive at first
    is its relatively high performance—especially since Python isn't exactly famous
    for being extremely quick. This is partly because low-level subsystems in Kivy
    are written in Cython and compiled to a blazing fast machine code, with performance
    levels about the same as, for example, the C language. Also, the use of hardware-accelerated
    graphics all but guarantees smooth animations, if done properly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Kivy 的另一件可能令人惊讶且反直觉的事情是其相对较高的性能——尤其是在 Python 并非以其极快的速度而闻名的情况下。这主要是因为 Kivy
    的底层子系统是用 Cython 编写的，并编译成非常快速的机器码，性能水平与例如 C 语言相当。此外，如果正确实施，使用硬件加速的图形几乎可以保证平滑的动画。
- en: We will explore the topic of cranking up the rendering performance in the next
    chapter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章探讨提高渲染性能的主题。
