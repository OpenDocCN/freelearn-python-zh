<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-216"><a id="_idTextAnchor226"/>9</h1>
<h1 id="_idParaDest-217"><a id="_idTextAnchor227"/>Animation Drivers</h1>
<p>A <strong class="bold">driver</strong> is<a id="_idIndexMarker607"/> a function that controls the value of a property. It can take the value of other properties as input, creating a connection between two or more properties. For example, a driver might set the <em class="italic">X</em> location of an object based on the rotation of another object.</p>
<p>Drivers are similar to animations, with which they share the update system and f-curve data but are way more flexible and can be combined with Python to create custom setups.</p>
<p>They are an essential part of technical animation and are used for creating simple controls or complex mechanics. Drivers don’t have a specific purpose: they are designed to create custom behaviors. For that reason, they are ubiquitous in rigging and help connect properties, even between entities of different types, such as objects and shaders.</p>
<p>In this chapter, you will learn how to create and test your Python drivers easily, as well as how to script their creation. Besides helping with automating rig mechanics, this knowledge will also make it easier for you to understand formulas and implement them in Blender.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Creating drivers</li>
<li>Using Python expressions in drivers</li>
<li>Scripting mathematic formulas</li>
<li>Automating the driver setup</li>
</ul>
<h1 id="_idParaDest-218"><a id="_idTextAnchor228"/>Technical requirements</h1>
<p>We will use Blender and <strong class="bold">Visual Studio Code</strong> in this chapter, but any IDE will do. The examples that were created for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch9">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch9</a>.</p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor229"/>Creating drivers</h1>
<p>The <a id="_idIndexMarker608"/>procedure for creating <strong class="bold">drivers</strong> is very similar to the one for creating animations. While the animation time is the only input of animation curves, drivers can depend on one or more of the following:</p>
<ul>
<li>The result of Python expressions</li>
<li>Any property that can be animated</li>
<li>The transform channels of objects</li>
<li>The difference in rotations between objects</li>
<li>The distance between objects</li>
</ul>
<p>When we create a driver, we must specify at least one input. In this section, we will learn how to set up a simple wheel by creating new drivers with the user interface.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor230"/>Creating quick drivers via the right-click menu</h2>
<p>There are <a id="_idIndexMarker609"/>a few shortcuts for creating drivers quickly.</p>
<p>Let’s take a look at an example to understand these shortcuts. Suppose that, to animate a wheel, we want an object’s <strong class="bold">Location Y</strong> to drive its <strong class="bold">Rotation X</strong> channel. We can set this up for Blender’s default cube:</p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">General</strong>.</li>
<li>Select the default <strong class="bold">Cube</strong> to make it active.</li>
<li>Press <em class="italic">N</em> to display the Transform properties.</li>
</ol>
<p><strong class="bold">Location Y</strong> is our input. Rather than look for its data path, we will copy it to the clipboard:</p>
<ol>
<li>Right-click on <strong class="bold">Location Y</strong> to display the <strong class="bold">Y:</strong> menu.</li>
<li>From the menu, pick <strong class="bold">Copy As </strong><strong class="bold">New Driver</strong>.</li>
</ol>
<p>The driver doesn’t exist yet, so we must create it for the property we want to affect:</p>
<ol>
<li>Right-click on <strong class="bold">Rotation X</strong> to display the <strong class="bold">X:</strong> menu.</li>
<li>From the menu, pick <strong class="bold">Paste Driver</strong>.</li>
</ol>
<p>The <strong class="bold">Rotation X</strong> channel will be colored purple, which is the color that’s used for driven properties. Moving the <strong class="bold">Cube</strong> object along its <strong class="bold">Y</strong>-axis will also make it roll:</p>
<div><div><img alt="Figure 9.1: The Y location drives the X rotation" height="640" src="img/Figure_9.01_B18375.jpg" width="1024"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: The Y location drives the X rotation</p>
<p>The <a id="_idIndexMarker610"/>driver that’s using <code>5</code> radians is equivalent to about <code>286</code> degrees of rotation, as reflected in the values we can see in <em class="italic">Figure 9</em><em class="italic">.1</em>.</p>
<p>Switching <strong class="bold">Rotation Unit</strong> to <strong class="bold">Radians</strong>, as shown in <em class="italic">Figure 9</em><em class="italic">.2</em>, makes a one-to-one relationship between <strong class="bold">Location Y</strong> and <strong class="bold">Rotation </strong><strong class="bold">X</strong> evident:</p>
<div><div><img alt="Figure 9.2: Location X and Rotation X display the same value using radians" height="640" src="img/Figure_9.02_B18375.jpg" width="1024"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: Location X and Rotation X display the same value using radians</p>
<p>Even if the<a id="_idIndexMarker611"/> cube rolls when it is moved, it doesn’t look like a wheel: a wheel rotates the other way around. We can set that up using the <strong class="bold">Drivers </strong><strong class="bold">Editor</strong> area.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor231"/>Setting up a wheel with the Drivers Editor</h2>
<p>In the <strong class="bold">Drivers Editor</strong> area, we <a id="_idIndexMarker612"/>can display and edit the drivers of the <a id="_idIndexMarker613"/>objects present in the scene. It can be brought up following these steps:</p>
<ol>
<li>Right-click on a <strong class="bold">Driven Property</strong>.</li>
<li>Select <strong class="bold">Open </strong><strong class="bold">Drivers Editor</strong>.</li>
</ol>
<p>It’s very similar to the <strong class="bold">Graph Editor</strong> area that we looked at in first <em class="italic">section </em>of <a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>, except it displays drivers rather than animation curves:</p>
<div><div><img alt="Figure 9.3: The driver f-curve in the Drivers Editor area" height="651" src="img/Figure_9.03_B18375.jpg" width="1189"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: The driver f-curve in the Drivers Editor area</p>
<p>We can get a better view of the curve by selecting <strong class="bold">View</strong> | <strong class="bold">Frame All</strong> from the <strong class="bold">Drivers Editor</strong> menu bar or pressing <em class="italic">Home</em> on the keyboard.</p>
<p>The default driver’s f-curve is the diagonal of the positive cartesian plane, with control points at coordinates (<code>0.0</code>, <code>0.0</code>) and (<code>1.0</code>, <code>1.0</code>). We can see that the result of the curve, displayed in the <code>5.0</code>, the same value as the <strong class="bold">location</strong> input variable.</p>
<p>Since the <a id="_idIndexMarker614"/>rotation of a wheel is opposite to its motion, we need to <a id="_idIndexMarker615"/>invert that result by changing the curve. To do that, follow these steps:</p>
<ol>
<li>In the <strong class="bold">Drivers Editor</strong> properties, select the <strong class="bold">F-Curve</strong> tab.</li>
<li>Select the top-right point of the f-curve by left-clicking.</li>
<li>In the <code>1.0</code> to <code>-1.0</code>:</li>
</ol>
<div><div><img alt="Figure 9.4: The driver’s f-curve pointing downwards" height="665" src="img/Figure_9.04_B18375.jpg" width="1336"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4: The driver’s f-curve pointing downwards</p>
<p>Now, moving the cube over its <strong class="bold">Y</strong>-axis makes it roll in the right direction. If you look carefully, something will still be off: this driver is rolling slightly too slowly.</p>
<p>The ratio between a circle of size 1 and the length it covers in one round is π, the mathematical constant pi, which is approximately 3.14.</p>
<p>That distance only takes a half round to a wheel twice as large, like our default cube of size <code>2</code> x <code>2</code> x <code>2</code>, so typing <code>pi/2</code> in the <code>1.571</code>, a multiplier slightly faster than <code>1</code>. Translating the cube on its <strong class="bold">Y</strong>-axis now <a id="_idIndexMarker616"/>makes it roll like a wheel, albeit a square<a id="_idIndexMarker617"/> one.</p>
<p>We used a division to get that result, but we can also use Python formulas in drivers. We can also create drivers by just typing a formula.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor232"/>Creating driver expressions in properties</h2>
<p>A different type of driver, one <a id="_idIndexMarker618"/>that relies on Python math formulas, can be created by typing a hash symbol (<code>#</code>) in a property field. Here are the steps for creating a driver expression:</p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">General</strong>.</li>
<li>Select the default cube to make it active.</li>
<li>Left-click on the <code>rotation_euler.x</code> property to edit its value.</li>
<li>Type <code>#sin(frame)</code> and press <em class="italic">Enter</em>:</li>
</ol>
<div><div><img alt="Figure 9. 5: Typing Python expressions in object properties" height="158" src="img/Figure_9.05_B18375.jpg" width="276"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9. 5: Typing Python expressions in object properties</p>
<p>The expression we have just written is already active. If we start the playback by pressing the triangular <strong class="bold">Play</strong> button in the <strong class="bold">media controls</strong> area, or with <em class="italic">Alt</em> + <em class="italic">A</em>, the cube will jitter quickly on its <strong class="bold">X</strong>-axis.</p>
<p>The <code>sin(frame)</code> expression<a id="_idIndexMarker619"/> depends on time, as animations do, but the value per frame is the output of a Python instruction, and we can enrich it for more complex results.</p>
<p>In the next section, we will combine the <code>frame</code> variable, the <code>sin</code> function, and the driver inputs to create a procedural, parametric animation of a pendulum.</p>
<p class="callout-heading">We DON’T want results!</p>
<p class="callout">Omitting the <code>#</code> symbol will set the result of the expression rather than creating a driver. Typing <code>frame</code> sets the property to the numeric value of the current frame, such as <code>1</code> or <code>24</code>. If we type <code>#frame</code>, the value will change as we play the animation.</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor233"/>Driving a cyclic motion</h1>
<p>A pendulum<a id="_idIndexMarker620"/> is a weight suspended from a fixed point, free to swing back and forth. It has many real-life applications in time, gravity, and geographic measurements, while in 3D, an oscillating motion is used for displaying clock mechanisms, hanging <a id="_idIndexMarker621"/>props, and other cyclic motions. The trigonometric function <strong class="bold">sine</strong> is commonly used to simulate this kind of motion.</p>
<p>The <code>sin</code> function<a id="_idIndexMarker622"/> from the <code>math</code> module is the Python syntax for <em class="italic">sine</em>. We encountered <em class="italic">sine</em> in <a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>, where we used its inverse, <em class="italic">arcsine</em>, to orient objects using Python. Sine is a periodic wave function – it repeats itself at fixed intervals:</p>
<div><div><img alt="Figure 9.6: The sine function" height="606" src="img/Figure_9.6_B18375.jpg" width="1236"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6: The sine function</p>
<p>Playing the <a id="_idIndexMarker623"/>animation will make the cube jitter very fast. To slow it down, we can click <strong class="bold">Driven Property</strong> and give the formula a slower pace.</p>
<p>For instance, we can change it to <code>sin(frame/10)</code> and it will slow down tenfold. Now, the cube rocks back and forth gently. We can do even better and set up a rotation pivot for a proper swing.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor234"/>Changing the rotation pivot via constraints</h2>
<p>The easier way <a id="_idIndexMarker624"/>to affect an object’s pivot is by using <strong class="bold">constraints</strong>. We came across constraints in <a href="B18375_04.xhtml#_idTextAnchor075"><em class="italic">Chapter 4</em></a>, and <a id="_idIndexMarker625"/>used them to change an object’s position without altering its transform properties. This time, we will use a <strong class="bold">Pivot Constraint</strong> to alter the center of rotation.</p>
<h3>Adding a Pivot Constraint in Blender</h3>
<p>A <a id="_idIndexMarker626"/><strong class="bold">Pivot Constraint</strong> moves an object’s center of rotation to a different object’s position or specific coordinates. We are going to use an <strong class="bold">Empty</strong>, a Blender object that doesn’t contain any geometry:</p>
<ol>
<li>Add an empty to the scene via <strong class="bold">Add</strong> | <strong class="bold">Empty</strong> | <strong class="bold">Plain Axes</strong> from the <strong class="bold">3D View</strong> area. This object will be the new rotation pivot.</li>
<li>Move this <strong class="bold">Empty</strong> somewhere above the <strong class="bold">Cube</strong> object so that it can act as a suspension point.</li>
</ol>
<p>Now, we can create the constraint:</p>
<ol>
<li>Select the <strong class="bold">Cube</strong> object and reach its <strong class="bold">Constraints</strong> tab in the properties. It is marked with the icon of a connection rod.</li>
<li>Select <strong class="bold">Pivot</strong> from<a id="_idIndexMarker627"/> the <strong class="bold">Add Object Constraint</strong> drop-down. A new constraint will be created:</li>
</ol>
<div><div><img alt="Figure 9.7: Creating a Pivot Constraint" height="558" src="img/Figure_9.07_B18375.jpg" width="837"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7: Creating a Pivot Constraint</p>
<ol>
<li value="3">Click the <strong class="bold">Target</strong> field in the <strong class="bold">Pivot Constraint</strong> panel, and select <strong class="bold">Empty</strong> among the list of objects.</li>
<li>Now, click the <strong class="bold">Rotation Range</strong> property and change it to <strong class="bold">Always</strong> so that rotations in all directions are affected.</li>
</ol>
<p>If we play the animation, the cube oscillates left and right:</p>
<div><div><img alt="Figure 9.8: The Pivot Constraint changing the rotation center of the Cube object" height="560" src="img/Figure_9.08_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8: The Pivot Constraint changing the rotation center of the Cube object</p>
<p>It starts to<a id="_idIndexMarker628"/> look like a pendulum, but the speed of a swinging motion should depend on the length of the cord, which we are not considering in our formula. To improve our driver, we must learn how the sine function works and how to control its period. Then, we must study pendulum physics and write an expression that takes the cord length into account.</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor235"/>Controlling the period of the sin function</h2>
<p>To have better <a id="_idIndexMarker629"/>control of the sine period, we need to observe its graph, as shown in <em class="italic">Figure 9</em><em class="italic">.9</em>. Its value is <code>0</code> at frame <code>0</code>, and after rising between frames <code>1</code> and <code>2</code>, it goes back to zero just a little bit after frame <code>3</code>:</p>
<div><div><img alt="Figure 9.9: The sine function" height="605" src="img/Figure_9.9_B18375.jpg" width="1236"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9: The sine function</p>
<p>This happens because sine, an angle-related function, depends on the mathematical constant π, and its value is zero at points <code>3.14</code>, <code>6.28</code>, and so on. The relationship between angles and circles is due to how angles describe circular arcs.</p>
<p>If the sine function repeats at every full circle, and a full circle measures 2 * π radians, we can say that the period of the <code>sin(frame)</code> formula is <code>2 * </code><code>pi</code> frames.</p>
<p>By using <code>2 * pi</code> as an argument of <code>sin</code>, we get a formula whose period is just one frame:</p>
<pre class="source-code">
sin(frame * 2 * pi)</pre>
<p>The result of this formula is always <code>0</code>, but that’s more useful than it seems: dividing <code>frame * 2 * pi</code> by a specific number of frames, we can set how much it takes for the formula to repeat – that is, we now have control over the period.</p>
<p>For instance, the<a id="_idIndexMarker630"/> result of the following formula repeats every 10 frames:</p>
<pre class="source-code">
sin(frame * 2 * pi <code>/ 10</code>)</pre>
<p>Now, we can look up the pendulum formula and set up a physically correct oscillation.</p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor236"/>Implementing the pendulum equation</h2>
<p>According to<a id="_idIndexMarker631"/> Wikipedia (<a href="https://en.wikipedia.org/wiki/Pendulum">en.wikipedia.org/wiki/Pendulum</a>), the period of a pendulum<a id="_idIndexMarker632"/> depends on the <a id="_idIndexMarker633"/>length of its cord, and is approximated with the following formula:</p>
<p class="author-quote"><em class="italic">2π√(L/g)</em></p>
<p>It reads <code>2</code> times <code>pi</code> times the <code>length</code> over <code>gravity</code>. In Python, this <a id="_idTextAnchor237"/>looks as follows:</p>
<pre class="source-code">
2 * pi * <strong class="bold">sqrt</strong>(length / 9.8)</pre>
<p>Here, <code>sqrt</code> is the square root operation and <code>9.8</code> is the gravity on Earth following the <strong class="bold">International System of Units</strong> (<strong class="bold">SI</strong>). The time <a id="_idIndexMarker634"/>unit is seconds in this system, so we need to express the formulas in our driver in seconds.</p>
<p>The expression for repeating <code>sin</code> in one frame was as follows:</p>
<pre class="source-code">
sin(frame * 2 * pi)</pre>
<p>And since we need to apply a period in seconds, we divide that expression by the frames per second:</p>
<pre class="source-code">
sin(frame/fps * 2 * pi)</pre>
<p>This slows down our expression to a period of 1 second.</p>
<p>We aim to end up with a period of <code>2 * pi * sqrt(length / 9.8)</code> seconds, so we divide the argument of <code>sin</code> by that amount.</p>
<p>After the division, we end up with a function of two variables, <code>fps</code> and <code>length</code>:</p>
<pre class="source-code">
sin((frame / <code>fps</code>) * <code>length</code>/9.8)))</pre>
<p>The value of <code>2 * pi / 2 *pi</code> is <code>1</code> and can be removed from the multiplication. Now, our formula looks much better:</p>
<pre class="source-code">
sin(frame / <code>fps</code> / sqrt(<code>length</code>/9.8))</pre>
<p>Typing it inside <strong class="bold">Rotation X</strong> creates a <em class="italic">driver</em>:</p>
<div><div><img alt="Figure 9.10: Implementation of the pendulum formula" height="333" src="img/Figure_9.10_B18375.jpg" width="454"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10: Implementation of the pendulum formula</p>
<p>The driver won’t<a id="_idIndexMarker635"/> work yet, though – the <code>frame</code> variable is <a id="_idIndexMarker636"/>already defined by Blender, but <code>length</code> and <code>fps</code> do not exist and cause an error. We need to add these two variables to the driver properties.</p>
<h3>Adding variables to drivers</h3>
<p>We could <a id="_idIndexMarker637"/>perform this operation in the <strong class="bold">Drivers Editor</strong> area we used in the <em class="italic">Creating drivers</em> section of this chapter, but since we don’t need to edit the <em class="italic">f-curve</em>, we can use a simpler interface.</p>
<h4>Displaying the Driven Property window</h4>
<p>The <strong class="bold">Driven Property</strong> window <a id="_idIndexMarker638"/>displays the details of a single driver. It is quick to access, and its content is the same as the <strong class="bold">Drivers</strong> tab in the <strong class="bold">Drivers </strong><strong class="bold">Editor</strong> area.</p>
<p>The steps for displaying and editing a driven property are as follows:</p>
<ol>
<li>Right-click on a driven property.</li>
<li>Select <strong class="bold">Edit Driver</strong> from the context menu.</li>
</ol>
<p>The <strong class="bold">Driven Property</strong> window recaps the path of the affected property, which <strong class="bold">Type</strong> of driver it is, if there are errors in the driver, and which variables have been created:</p>
<div><div><img alt="Figure 9.11: Properties of a scripted expression driver" height="558" src="img/Figure_9.11_B18375.jpg" width="330"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11: Properties of a scripted expression driver</p>
<p>At this stage, the driver type will be set to <strong class="bold">Scripted Expression</strong>; the <strong class="bold">Expression</strong> field contains our pendulum formula, while the error label informs us that something went wrong with the Python expression.</p>
<p>This error is caused by the<a id="_idIndexMarker639"/> missing <code>fps</code> and <code>length</code> variables. Adding them will fix it.</p>
<p class="callout-heading">Hold on to your window!</p>
<p class="callout"><strong class="bold">Driven Property</strong> is a popover window that disappears when the mouse pointer moves back outside of its borders. Don’t worry, though; every change will still be there when you open the window again.</p>
<h4>Getting the frame per seconds property</h4>
<p>Clicking the <code>var</code>, and it’s an <strong class="bold">RNA property</strong> variable – that is, it reads the value from another property in Blender. To get that value, we need to specify the following:</p>
<ul>
<li>The type of the entity (object, scene, action, and so on)</li>
<li>The name of the entity</li>
<li>The name of the property</li>
</ul>
<p>These properties can be set in the <strong class="bold">Variable</strong> panel:</p>
<div><div><img alt="Figure 9.12: A newly created variable" height="177" src="img/Figure_9.12_B18375.jpg" width="330"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12: A newly created variable</p>
<p>Here are the steps to get the <strong class="bold">Frames Per Second</strong> render setting of the scene through this variable:</p>
<ol>
<li>Select <strong class="bold">Scene</strong> from the property type list, which is displayed with the left button below the variable’s name:</li>
</ol>
<div><div><img alt="Figure 9.13: Setting the property variable type" height="587" src="img/Figure_9.13_B18375.jpg" width="550"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13: Setting the property variable type</p>
<ol>
<li value="2">A Blender file can contain more than one scene. We can display a list of them with the right list button and pick one. The name of the default scene is <strong class="bold">Scene</strong>.</li>
<li>Now that<a id="_idIndexMarker641"/> a scene has been selected, another field, <code>render.fps</code> gets the frame per second, as set in the render settings.</li>
<li>We must rename the variable from <code>var</code> to <code>fps</code> by clicking the current name just right of the genetic code (RNA) icon:</li>
</ol>
<div><div><img alt="Figure 9.14: The fps variable in the render settings" height="226" src="img/Figure_9.14_B18375.jpg" width="315"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14: The fps variable in the render settings</p>
<p>Now, the variable<a id="_idIndexMarker642"/> name matches the one used in the driver expression so that <code>frame/fps</code> is the time at the current frame, in seconds. This allows the next variable, <code>length</code>, to influence the period with a seconds-based formula.</p>
<h4>Getting the pendulum length with a distance variable</h4>
<p>There <a id="_idIndexMarker643"/>are four types of driver variables:</p>
<ul>
<li><strong class="bold">Single Property</strong></li>
<li><strong class="bold">Transform Channel</strong></li>
<li><strong class="bold">Rotational Difference</strong></li>
<li><strong class="bold">Distance</strong></li>
</ul>
<p>While the first two, <strong class="bold">Single Property</strong> and <strong class="bold">Transform Channel</strong>, depend on the value of a property, <strong class="bold">Rotational Difference</strong> and <strong class="bold">Distance</strong> result from the difference between the transformations of two objects.</p>
<p>In this case, the length of the cord is the distance between the driven object and its pivot – that is, between <code>length</code>:</p>
<ol>
<li>Add a new variable by clicking the <strong class="bold">+ Add Input </strong><strong class="bold">Variable</strong> button.</li>
<li>Click the RNA icon to change the type to <strong class="bold">Distance</strong>. The panel will change, allowing you to select two objects:</li>
</ol>
<div><div><img alt="Figure 9.15: Changing the variable type" height="225" src="img/Figure_9.15_B18375.jpg" width="316"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15: Changing the variable type</p>
<ol>
<li value="3">Select <code>length</code>:</li>
</ol>
<div><div><img alt="Figure 9.16: Variables settings for the pendulum driver" height="903" src="img/Figure_9.16_B18375.jpg" width="541"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16: Variables settings for the pendulum driver</p>
<p>Moving the <strong class="bold">Empty</strong> or <strong class="bold">Cube</strong> object closer to each other while the animation plays makes the swing becomes faster, while setting them apart slows them down.</p>
<p>The maximum value of sin is <code>1</code>, which, converted from <em class="italic">radians</em>, gives us the maximum angle reached by this driver:</p>
<pre class="source-code">
&gt;&gt;&gt; degrees(1)
57.29577951308232</pre>
<p>This <a id="_idIndexMarker644"/>value is the amplitude of the oscillation. The amplitude of a pendulum depends on its initial position. In real life, the amplitude decreases progressively because of the friction of air, until the pendulum reaches its resting position and stops. We are not implementing air drag in our driver, but we can still add a control to influence the amplitude of the motion.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor238"/>Controlling the amplitude</h2>
<p>While the <a id="_idIndexMarker645"/>term <strong class="bold">amplitude</strong> has a specific meaning when dealing with wave graphs, for our goal, we can consider it a multiplier of motion.</p>
<p>Since we are programming for animation, it’s more important for our amplitude control to make sense visually rather than physically.</p>
<h3>Adding a custom property</h3>
<p>We already control the <a id="_idIndexMarker646"/>pivot’s position with an object of the <strong class="bold">empty</strong> type. Since moving <strong class="bold">Empty</strong> already alters the periodic motion, we can add a new property to it, to control the amplitude of the oscillation. This way, we can affect the behavior of the pendulum by selecting a single object.</p>
<p>The procedure for adding a property to an object is as follows:</p>
<ol>
<li>Select the <strong class="bold">Empty</strong> object that we are using as a pivot.</li>
<li>In the <strong class="bold">Object Properties</strong> panel, find the <strong class="bold">Custom </strong><strong class="bold">Properties</strong> section.</li>
<li>Click the <strong class="bold">+ New</strong> button to add a property. It will be named <strong class="bold">prop</strong> by default:</li>
</ol>
<div><div><img alt="Figure 9.17: Adding custom properties to the active object" height="623" src="img/Figure_9.17_B18375.jpg" width="378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17: Adding custom properties to the active object</p>
<ol>
<li value="4">Click the cog icon and change <strong class="bold">Property Name</strong> to <strong class="bold">amplitude</strong>.</li>
<li>Right-click on the value (the default, <code>1.00</code>, is good) and select <strong class="bold">Copy </strong><strong class="bold">Data Path</strong>.</li>
</ol>
<p>This copies the path of the property to the clipboard. This will be useful when we add the next driver variable.</p>
<h3>Using custom properties in drivers</h3>
<p>Multiplying the driver <a id="_idIndexMarker647"/>expression by the <code>amp</code> variable affects its result and allows us to modulate its amplitude. To do that, follow these steps:</p>
<ol>
<li>Select the oscillating <strong class="bold">Cube</strong>.</li>
<li>Right-click on the driven rotation channel and select <strong class="bold">Edit Driver</strong> to bring up the <strong class="bold">Driven </strong><strong class="bold">Property</strong> editor.</li>
<li>Click <code>amp</code>.</li>
<li>Click the <strong class="bold">Prop:</strong> field on the right and pick <strong class="bold">Empty</strong> as the property object.</li>
<li>Click the <code>["amplitude"]</code>. The square brackets are part of the <em class="italic">custom properties</em> Python path:</li>
</ol>
<div><div><img alt="Figure 9.18: Custom property as a driver variable" height="140" src="img/Figure_9.18_B18375.jpg" width="311"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18: Custom property as a driver variable</p>
<p>We could just add <code>* amp</code> to the driver expression, but we can do even better: since the driver affects a rotation, we can add <code>pi</code> to the multiplication too:</p>
<pre class="source-code">
sin(frame / fps / sqrt(length/9.8)) * <code>amp * pi</code></pre>
<p>The <code>sin</code> function oscillates between <code>-1.0</code> and <code>1.0</code>, so the result of our driver when <code>1.0</code> ranges between <code>-pi</code> to <code>pi</code>.</p>
<p>Keeping in mind that a full circle arc measures <code>2 * pi</code>, it’s fair to expect a value of <code>pi</code> to describe a half-circle rotation in radians. If we play the animation now, we’ll see the pendulum oscillate up to its vertical direction – that is, rotate half circle to the left, go back, and then rotate half circle to the right: an amplitude of <code>1.0</code> makes the pendulum describe a full circle.</p>
<p>If we select the <code>0.5</code>, the pendulum will swing through a half-circle arc. An amplitude equal to <code>0.25</code> gives better results: a 45-degree maximum rotation on each side; a value of <code>0.0</code> would stop the pendulum.</p>
<p>A control<a id="_idIndexMarker648"/> ranging from <code>0.0</code> for a still pendulum to <code>1.0</code> for an entire rotation has an immediate meaning to animators and 3D users because it allows them to set up the fraction of the circle that they wish by changing the amplitude.</p>
<p>We used a Python formula in our driver, but we created the entire setup manually. In the next section, we will write a Python add-on to automate this procedure.</p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor239"/>Writing the pendulum add-on</h1>
<p>Using <a id="_idIndexMarker649"/>what we have learned so far, we can write an add-on that sets up a pendulum for the active object.</p>
<p>We will start with the steps from <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, and create a <code>.py</code> file for our add-on.</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor240"/>Setting the environment</h2>
<p>Let’s create a <a id="_idIndexMarker650"/>folder for <a href="B18375_09.xhtml#_idTextAnchor226"><em class="italic">Chapter 9</em></a> in our <code>ch9</code> folder as the <strong class="bold">Scripts Folder</strong> property and restart the application. We can create our new files and folder in our IDE (VS Code in this book) so that we can start editing:</p>
<ol>
<li>Select <code>PythonScriptingBlender/ch9/addons</code> in <strong class="bold">VS Code</strong>.</li>
<li>Create a new file by clicking the <strong class="bold">New </strong><strong class="bold">File</strong> icon.</li>
<li>Name the new file <code>pendulum.py</code>.</li>
<li>Open the file by double-clicking it.</li>
</ol>
<p>We can now add the standard elements of most add-ons:</p>
<ul>
<li>Add-on information</li>
<li>The <code>Operator</code> class</li>
<li>The menu function</li>
<li>Registration<a id="_idIndexMarker651"/> functions</li>
</ul>
<p>Next, we’ll learn how to write this information.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor241"/>Writing the information</h2>
<p>As usual, the information about<a id="_idIndexMarker652"/> our add-on goes into the <code>bl_info</code> dictionary:</p>
<pre class="source-code">
bl_info = {
    "name": "Object Pendulum",
    "author": "John Packt",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Add swing motion to active object",
    "category": "Learning",
}</pre>
<p>This dictionary is just for Blender to display the add-on’s name and description in the list. The next step is writing the <code>Operator</code> class.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor242"/>Writing the Operator class</h2>
<p>The <code>Operator</code> class<a id="_idIndexMarker653"/> carries on the actual work. We derive <code>bpy.types.Operator</code> and fill in the information in the static section of the class:</p>
<pre class="source-code">
import bpy
class ObjectPendulum(bpy.types.Operator):
    """Set up swinging motion on active object"""
    bl_idname = "object.shaker_animation"
    bl_label = "Make Pendulum"
    bl_description = "Add swinging motion to Active Object"
    bl_options = {'REGISTER', 'UNDO'}</pre>
<p><code>bl_idname</code> starts with <code>object.</code> so that it will be added to the <code>bpy.ops.object</code> operators. We are doing that because everything we do in this operator affects the scene at the object level.</p>
<p>Now, we must add the oscillation parameters to the static attributes:</p>
<pre class="source-code">
    amplitude: bpy.props.FloatProperty(default=0.25,
                                       min=0.0)
    length: bpy.props.FloatProperty(default=5.0, min=0.0)</pre>
<p>They will determine the <code>amplitude</code> and <code>length</code> variables of the motion. By using <code>'REGISTER'</code> and <code>'UNDO'</code> as <code>bl_options</code>, the operator will allow live changes:</p>
<pre class="source-code">
bl_options = {'REGISTER', 'UNDO'}</pre>
<p>Now, it’s the <code>poll</code> method’s turn, where the conditions for running the operator are checked. It must return <code>True</code> if there is an active object. We can use the <code>bool</code> function to convert <code>context.object</code> on the fly:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return bool(context.object)</pre>
<p>Finally, we have<a id="_idIndexMarker654"/> the <code>execute</code> method. It performs all the operations from the previous section of this chapter:</p>
<ul>
<li>Creates the pivot object</li>
<li>Adds a custom property for the amplitude</li>
<li>Creates a driver with the pendulum formula and variables</li>
</ul>
<p>At the start of the function, we store the active object in the <code>ob</code> variable, then create a new object that will be the pivot. In <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, we learned that new objects can be created in two steps:</p>
<ol>
<li>Get a new object via <code>bpy.data.objects.new</code>.</li>
<li>Link the object to a <code>Collection</code> present in the scene.</li>
</ol>
<p>We will use <code>context.collection</code> and link the pivot to the active collection:</p>
<pre class="source-code">
    def execute(self, context):
        ob = context.object
        pivot_name = f"EMP-{ob.name}_pivot"
        pivot = bpy.data.objects.new(pivot_name, None)
        context.collection.objects.link(pivot)</pre>
<p>Using <code>None</code> as the second argument of <code>new</code> creates a transform with no geometry data – that is, an <code>matrix_world</code>. The pivot should be placed above the active object, and since <code>location</code> is stored in the fourth column of the transform matrix, we can raise the value of <code>[2][3]</code>):</p>
<pre class="source-code">
        pivot.matrix_world = ob.matrix_world
        pivot.matrix_world[2][3] += self.length</pre>
<p>Now, it’s time for the<a id="_idIndexMarker655"/> custom properties. We have seen how the data path to our <em class="italic">amplitude</em> property was <code>["amplitude"]</code>. That’s because Python’s access to custom properties follows the same syntax as Python dictionaries.</p>
<p>In Python dictionaries, the <code>dictionary["new_key"] = new_value</code> syntax adds a new item. Likewise, the Python code for creating the <code>amplitude</code> float property and assigning it the value of the operator’s parameter of the same name is as follows:</p>
<pre class="source-code">
        pivot["amplitude"] = self.amplitude</pre>
<p><code>amplitude</code> will now appear under our pivot object. We will use that later in the driver. For now, we will add a <strong class="bold">Pivot Constraint</strong> to the active object:</p>
<pre class="source-code">
        constr = ob.constraints.new('PIVOT')
        constr.target = pivot
        constr.rotation_range = 'ALWAYS_ACTIVE'</pre>
<p>Now, it’s time to create our driver. Drivers, as objects, are slightly more complex than constraints as they contain other entities, such as the f-curve, and are part of the animation data. So, rather than using the <code>drivers.new</code> method from <code>animation_data</code>, we will resort to the <code>driver_add</code> method of the object, which sets up all the requirements. It returns the driver curve:</p>
<pre class="source-code">
        driver_crv = ob.driver_add('rotation_euler', 0)
        driver = driver_crv.driver</pre>
<p class="callout-heading">Who drives the driver?</p>
<p class="callout">The <code>driver_add</code> method returns the f-curve rather than the driver itself. The actual driver can be accessed via the <code>curve.driver</code> attribute. This makes it easier to access the new curve, but it would have been reasonable to expect that <code>driver_add</code> would return the driver instead.</p>
<p>Our driver uses a <a id="_idIndexMarker656"/>Python expression, so must we set the <code>type</code> and <code>expression</code> attributes:</p>
<pre class="source-code">
        driver.type = "SCRIPTED"
        xpr = "sin(frame/fps/sqrt(length/9.8)) * amp * pi"
        driver.expression = xpr</pre>
<p>The <code>fps</code>, <code>length</code>, and <code>amp</code> variables can be added using <code>variables.new</code>.</p>
<p>Once we’ve created a variable, we can set its targets. The current <code>render.fps</code> property of <code>context.scene</code>, so it’s only one target. We will set the variable type to a single property and fill <code>id_type</code>, <code>id</code>, and <code>data_path</code> of <code>targets[0]</code>:</p>
<pre class="source-code">
        fps = driver.variables.new()
        fps.name = "fps"
        fps.type = <code>"SINGLE_PROP"</code>
        fps.targets[0].id_type = <strong class="bold">'SCENE'</strong>
        fps.targets[0].id = context.scene
        fps.targets[0].data_path = <code>"render.fps"</code></pre>
<p>Our pendulum length is the distance between <code>pivot</code> and <code>ob</code>, so it has two targets:</p>
<pre class="source-code">
        len = driver.variables.new()
        len.name = "length"
        len.type = <code>"LOC_DIFF"</code>
        len.targets[0].id = pivot
        len.targets[1].id = ob</pre>
<p>Finally, we can<a id="_idIndexMarker657"/> look at the amplitude. It’s a custom property of the pivot and the variable is of the <code>'SINGLE_PROP'</code> type, but this time, <code>id_type</code> is a Blender object. Once the driver setup is complete, we can exit the function by returning the <code>'</code><code>FINISHED'</code> state:</p>
<pre class="source-code">
        amp = driver.variables.new()
        amp.name = "amp"
        amp.type = <code>"SINGLE_PROP"</code>
        amp.targets[0].id_type = <code>"OBJECT"</code>
        amp.targets[0].id = pivot
        amp.targets[0].data_path =<a id="_idTextAnchor243"/> <code>"["amplitude"]"</code>
        return {'FINISHED'}</pre>
<p>The <code>ObjectPendulum</code> class is complete as it now covers the entire setup process. As usual, we must also add an entry to one of the Blender menus to make it easier to launch.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor244"/>Writing the menu and registering the class</h2>
<p>In <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, we<a id="_idIndexMarker658"/> learned that we can add our<a id="_idIndexMarker659"/> items to menus by writing a menu function. The argument self and context are, respectively, the menu instance and the application context. We must add the operator’s <code>bl_idname</code> to the menu’s <code>layout</code>:</p>
<pre class="source-code">
def menu_func(self, context):
    self.layout.separator()
    <code>self.layout</code>.operator(ObjectPendulum.bl_idname)</pre>
<p>Then, in the register function, we must add <code>menu_func</code> to one of Blender’s menus. In this example, we will use the right-click menu that’s available in object mode. We learned how to look for menu class names in <a href="B18375_08.xhtml#_idTextAnchor206"><em class="italic">Chapter 8</em></a>, and the object context menu class is <code>VIEW3D_MT_object_context_menu</code>. We must also register the operator class, <code>ObjectPendulum</code>:</p>
<pre class="source-code">
def register():
    bpy.utils.register_class(ObjectPendulum)
    ob_menu =  bpy.types.VIEW3D_MT_object_context_menu
    ob_menu.append(menu_func)</pre>
<p>This adds our new functionality to Blender when the <strong class="bold">Object Pendulum</strong> add-on is enabled. Of course, we must reverse those operations to clean up our add-on elements when it is disabled:</p>
<pre class="source-code">
def unregister():
    ob_menu =  bpy.types.VIEW3D_MT_object_context_menu
    ob_menu.remove(menu_func)
    bpy.utils.unregister_class(ObjectPendulum)</pre>
<p>Now that our add-on is ready, the steps for setting up a pendulum instantly are as follows:</p>
<ol>
<li>In <strong class="bold">Object Mode</strong>, select an object to make it active.</li>
<li>Right-click and choose <strong class="bold">Make Pendulum</strong> to invoke the add-on.</li>
<li>Set<a id="_idIndexMarker660"/> values for <code>length</code> and <code>amplitude</code> in the <a id="_idIndexMarker661"/>operator properties.</li>
</ol>
<p>Writing this add-on put many of the techniques you learned in the previous chapters to use. Drivers are a very creative area of scripting, and this was just a taste of what we can do with them.</p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor245"/>Summary</h1>
<p>Drivers are powerful tools that sit at a crossroads between animation, rigging, and programming. On one hand, they can contain Python expressions and implement custom mechanics on their own, while on the other hand, the entire driver setup process can be automated via scripting.</p>
<p>The tool we wrote in this chapter is a small <strong class="bold">auto-rig</strong> that replicates the same mechanism, with editable parameters, on any Blender object.</p>
<p>The ability to combine drivers, constraints, and custom properties, as well as automate the whole procedure, is an essential part of 3D production as it allows non-technical users to carry on with technical tasks.</p>
<p>As a plus, by using Python, we converted a formula from physics into a working driver expression, a task that can sometimes be intimidating but can be carried out with observation and a little ingenuity.</p>
<p>This topic ends our tour of the animation system. In the next chapter, <a href="B18375_10.xhtml#_idTextAnchor247"><em class="italic">Chapter 10</em></a>, we will learn how our operators can interact with the user and listen to events.</p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor246"/>Questions</h1>
<ol>
<li>What color is used for driven properties in the interface?</li>
<li>Can we set keyframes for purple properties?</li>
<li>Can a metric property, such as <strong class="bold">Location</strong>, drive an angular property, such as <strong class="bold">Rotation</strong>?</li>
<li>Can we change the ratio between the driving and driven properties?</li>
<li>Can we type Python expressions when we set values in the interface?</li>
<li>How do we tell Blender that the expressions we have typed should be a driver?</li>
<li>How do we edit a driver property in the user interface? Is there only one way?</li>
<li>Can we add custom properties to an object and use them to control other objects?</li>
<li>In Python, can we create new drivers using the <code>collection.new</code> method, as we do with constraints? If yes, why do we use <code>object.driver_add</code> instead?</li>
<li>Why is the <code>targets</code> attribute of driver variables a list? Which type of variable has more than one target?</li>
</ol>
</div>
</div></body></html>