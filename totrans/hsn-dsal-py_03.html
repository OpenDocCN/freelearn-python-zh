<html><head></head><body>
  <div id="_idContainer076" class="Basic-Text-Frame">
    <h1 class="chapterNumber">3</h1>
    <h1 id="_idParaDest-64" class="chapterTitle">Algorithm Design Techniques and Strategies</h1>
    <p class="normal">In the field of computing, algorithm design<a id="_idIndexMarker200"/> is very important for IT professionals for improving their skills and enabling growth in the industry. The algorithm design process starts with a substantial number of real-world computing problems, which must be clearly formulated for efficiently building the solution using one of the possible techniques from the range of algorithm design techniques available. The world of algorithms contains a plethora of techniques and design principles, mastery of which is required to tackle more difficult problems in the field. Algorithm designs are important in computer science, in general, to efficiently design the solution for a precisely formulated problem since a very sophisticated and complex problem can easily be solved with an appropriate algorithm design technique.</p>
    <p class="normal">In this chapter, we will discuss the ways in which different kinds of algorithms can be categorized. Design techniques will be described and illustrated, and we will further discuss the analysis of algorithms. Finally, we will provide detailed implementations for a few very important algorithms.</p>
    <p class="normal">In this chapter, we will look at the following algorithm design techniques:</p>
    <ul>
      <li class="bulletList">Divide and conquer</li>
      <li class="bulletList">Dynamic programming</li>
      <li class="bulletList">Greedy algorithms</li>
    </ul>
    <h1 id="_idParaDest-65" class="heading-1">Algorithm design techniques</h1>
    <p class="normal">Algorithm design <a id="_idIndexMarker201"/>is a powerful tool for viewing and clearly understanding well-posed, real-world problems. A straightforward, or <strong class="keyWord">brute-force</strong>, approach is available that is very simple, yet effective, for many problems. The brute-force approach<a id="_idIndexMarker202"/> is trying all possible combinations of solutions in order to solve any problem. For example, suppose a salesperson has to visit 10 cities across the country. In which order should the cities be visited in order to minimize the total distance traveled? The brute-force approach to this problem will be to calculate the total distance for all possible combinations of routes, and then select the route that provides the smallest distance.</p>
    <p class="normal">As you might guess, the brute-force algorithm is not efficient.</p>
    <p class="normal">It can provide useful solutions for limited input sizes, but it becomes very inefficient when the input size becomes large. Therefore, we will break the process down into two fundamental components for finding the optimal solution for a computing problem:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Formulate the problem clearly</li>
      <li class="numberedList">Identify the appropriate algorithm design technique based on the structure of the problem for an efficient solution</li>
    </ol>
    <p class="normal">That is why the study of algorithm design becomes very important when developing scalable and robust systems. Design and analysis are important in the first instance because they assist in developing algorithms that are organized and easy to understand. Design technique guidelines also help in developing new algorithms easily for complex problems. Moreover, design techniques can also be used to categorize the algorithms and this also helps to understand them better. There are several algorithm paradigms as follows:</p>
    <ul>
      <li class="bulletList">Recursion</li>
      <li class="bulletList">Divide and conquer</li>
      <li class="bulletList">Dynamic programming</li>
      <li class="bulletList">Greedy algorithms</li>
    </ul>
    <p class="normal">Since we will be using recursion many times while discussing different algorithm design techniques, let us first understand the concept of recursion, and thereafter, we will discuss different algorithm design techniques.</p>
    <h1 id="_idParaDest-66" class="heading-1">Recursion</h1>
    <p class="normal">A recursive algorithm <a id="_idIndexMarker203"/>calls itself repeatedly in order to solve the <a id="_idIndexMarker204"/>problem until a certain condition is fulfilled. Each recursive call itself spins off other recursive calls. A recursive function can be in an infinite loop; therefore, it is required that each recursive function adheres to certain properties. At the core of a recursive function are two types of cases:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="keyWord">Base cases</strong>: These<a id="_idIndexMarker205"/> tell the recursion when to terminate, meaning the recursion will be stopped once the base condition is met</li>
      <li class="numberedList"><strong class="keyWord">Recursive cases</strong>: The <a id="_idIndexMarker206"/>function calls itself recursively, and we progress toward achieving the base criteria</li>
    </ol>
    <p class="normal">A simple problem that naturally lends itself to a recursive solution is calculating factorials. The recursive factorial algorithm defines two cases: the base case when <em class="italic">n</em> is zero (the terminating condition) and the recursive case when <em class="italic">n</em> is greater than zero (the call of the function itself). A typical implementation is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">factorial</span><span class="hljs-function">(</span><span class="hljs-params">n</span><span class="hljs-function">):</span>
<span class="hljs-comment">    # test for a base case</span>
<span class="hljs-keyword">    if</span> n == <span class="hljs-number">0</span>:
<span class="hljs-keyword">        return</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">    else</span>:
<span class="hljs-comment">    # make a calculation and a recursive call</span>
<span class="hljs-keyword">        return</span> n*factorial(n-<span class="hljs-number">1</span>) 
<span class="hljs-built_in">print</span>(factorial(<span class="hljs-number">4</span>))
</code></pre>
    <p class="normal">This produces the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">24
</code></pre>
    <p class="normal">To calculate the <a id="_idIndexMarker207"/>factorial of <code class="inlineCode">4</code>, we require four recursive calls, plus the initial parent call, as can be seen in <em class="italic">Figure 3.1</em>. The details of how these recursive calls work is as follows. Initially, the number <code class="inlineCode">4</code> is passed to the factorial function, which will return the value <code class="inlineCode">4</code> multiplied by the factorial of (4-1=3). For this, the number <code class="inlineCode">3</code> is again passed to the factorial function, which will return the value <code class="inlineCode">3</code> multiplied by the factorial of (3-1=2). Similarly, in the next iteration, the value <code class="inlineCode">2</code> is multiplied by the factorial of (2-1 =1). </p>
    <p class="normal">This continues until we reach the factorial of <code class="inlineCode">0</code>, which returns <code class="inlineCode">1</code>. Now, each function returns the value to finally compute <code class="inlineCode">1*1*2*3*4=24</code>, which is the final output of the function.</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 3.1: The flow of execution of the factorial 4</p>
    <p class="normal">We discussed the <a id="_idIndexMarker208"/>concept of recursion, which will be very <a id="_idIndexMarker209"/>useful in understanding the implementation of different algorithm paradigms. So, now let us move on to the distinct algorithm design strategies in turn, starting with the divide-and-conquer technique in the next section.</p>
    <h1 id="_idParaDest-67" class="heading-1">Divide and conquer</h1>
    <p class="normal">One of the<a id="_idIndexMarker210"/> important and effective techniques for <a id="_idIndexMarker211"/>solving a complex problem is divide and conquer. The divide-and-conquer paradigm divides a problem into smaller sub-problems, and then solves these; finally, it combines the results to obtain a global, optimal solution. More specifically, in divide-and-conquer design, the problem is divided into two smaller sub-problems, with each of them being solved recursively. The partial solutions are merged to obtain a final solution. This is a very common problem-solving technique, and is, arguably, the most commonly used approach in algorithm design.</p>
    <p class="normal">Some examples of the divide-and-conquer design technique are as follows:</p>
    <ul>
      <li class="bulletList">Binary search</li>
      <li class="bulletList">Merge sort</li>
      <li class="bulletList">Quick sort</li>
      <li class="bulletList">Algorithm for fast multiplication</li>
      <li class="bulletList">Strassen’s matrix multiplication</li>
      <li class="bulletList">Closest pair of points</li>
    </ul>
    <p class="normal">Let’s have a look at<a id="_idIndexMarker212"/> two examples, the binary<a id="_idIndexMarker213"/> search and merge sort algorithms, to understand how the divide-and-conquer design technique works.</p>
    <h2 id="_idParaDest-68" class="heading-2">Binary search</h2>
    <p class="normal">The <a id="_idIndexMarker214"/>binary search algorithm is based on the divide-and-conquer<a id="_idIndexMarker215"/> design technique. This algorithm is used to find a given element from a sorted list of elements. It first compares the search element with the middle element of the list; if the search element is smaller than the middle element, then the half of the list of elements greater than the middle element is discarded; the process repeats recursively until the search element is found or we reach the end of the list. It is important to note that in each iteration, half of the search space is discarded, which improves the performance of the overall algorithm because there are fewer elements to search through.</p>
    <p class="normal">Take the example shown in <em class="italic">Figure 3.2</em>; let’s say we want to search for element 4 in the given sorted list of elements. The list is divided in half in each iteration; with the divide-and-conquer strategy, the element is searched <em class="italic">O</em>(<em class="italic">logn</em>) times.</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_02.1.png" alt=""/></figure>
    <p class="packt_figref">Figure 3.2: The process of searching for an element using a binary search algorithm</p>
    <p class="normal">The Python <a id="_idIndexMarker216"/>code for searching for an element in a<a id="_idIndexMarker217"/> sorted list of elements is shown here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">binary_search</span><span class="hljs-function">(</span><span class="hljs-params">arr, start, end, key</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">while</span> start &lt;= end:  
        mid = start + (end - start)/<span class="hljs-number">2</span>
        <span class="hljs-keyword">if</span> arr[mid] == key:  
            <span class="hljs-keyword">return</span> mid  
        <span class="hljs-keyword">elif</span> arr[mid] &lt; key:  
            start = mid + <span class="hljs-number">1</span>  
        <span class="hljs-keyword">else</span>:  
            end = mid - <span class="hljs-number">1</span>  
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  
arr = [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">24</span>, <span class="hljs-number">38</span>] 
x = <span class="hljs-number">13</span>
result = binary_search(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span>, x)  
<span class="hljs-built_in">print</span>(result)
</code></pre>
    <p class="normal">When we search for <code class="inlineCode">13</code> in the given list of elements, the output of the preceding code is <code class="inlineCode">3</code>, which is the position of the searched item.</p>
    <p class="normal">In the code, initially, the start and end index give the position of the first and last index of the input array <code class="inlineCode">[4, 6, 9, 13, 14, 18, 21, 24, 38]</code>. The item to be searched that is stored in the variable <code class="inlineCode">key</code> is firstly matched with the mid element of the array, and then we discard half of the list and search for the item in another half of the list. The process is iterated until we find the item to be searched, or we reach the end of the list, and we don’t find the element.</p>
    <p class="normal">When analyzing <a id="_idIndexMarker218"/>the workings of the binary search<a id="_idIndexMarker219"/> algorithm in the worst case, we can see that for a given array of 8 elements, following the first unsuccessful attempt, the list is halved, and then again for an unsuccessful search attempt, the list is of length 2, and finally, only 1 element is left. So, the binary search requires 4 searches. If the size of the list is doubled, in other words, to 16, following the first unsuccessful search, we will have a list of size 8, and that will take a total of 4 searches. Therefore, the binary search algorithm will require 5 searches for a list of 16 items. Thus, we can observe that when we double the number of items in the list, the number of searches required also increments by 1. We can say this as when we have a list of length n, the total number of searches required will be the number of times we repeated halving the list until we are left with 1 element plus 1, which is mathematically equivalent to (log<sub class="subscript">2</sub> <em class="italic">n</em> + 1). For example, if n=8, the output will be 3, meaning the number of searches required will be 4. The list is divided in half in each iteration; with the divide-and-conquer strategy, the worst-case time complexity of the binary search algorithm is <em class="italic">O(log </em><em class="italic">n)</em>.</p>
    <p class="normal">Merge sort is another popular algorithm that is based on the divide-and-conquer design strategy. We will be discussing merge sort in more detail in the next section.</p>
    <h2 id="_idParaDest-69" class="heading-2">Merge sort</h2>
    <p class="normal">Merge sort is an<a id="_idIndexMarker220"/> algorithm for sorting a list of <em class="italic">n</em> natural <a id="_idIndexMarker221"/>numbers in increasing order. Firstly, the given list of elements is divided iteratively into equal parts until each sublist contains one element, and then these sublist are combined to create a new list in a sorted order. This programming approach to problem-solving is based on the divide-and-conquer methodology and emphasizes the need to break down a problem into smaller sub-problems of the same type or form as the original problem. These sub-problems are solved separately and then results are combined to obtain the solution of the original problem.</p>
    <p class="normal">In this case, given <a id="_idIndexMarker222"/>a list of unsorted elements, we <a id="_idIndexMarker223"/>split the list into two approximate halves. We continue to divide the list into halves recursively. </p>
    <p class="normal">After a while, the sublist created as a result of the recursive call will contain only one element. At that point, we begin to merge the solutions in the conquer or merge step. This process is shown in <em class="italic">Figure 3.3</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 3.3: Overview of the merge sort algorithm</p>
    <p class="normal">The<a id="_idIndexMarker224"/> implementation of the merge sort algorithm <a id="_idIndexMarker225"/>is implemented using primarily two methods, namely, the <code class="inlineCode">merge_sort</code> method, which recursively divides the list. Afterward, we will introduce the <code class="inlineCode">merge</code> method to combine the results:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">merge_sort</span><span class="hljs-function">(</span><span class="hljs-params">unsorted_list</span><span class="hljs-function">):</span> 
<span class="hljs-keyword">    if</span> <span class="hljs-built_in">len</span>(unsorted_list) == <span class="hljs-number">1</span>: 
<span class="hljs-keyword">        return</span> unsorted_list
    mid_point = int(<span class="hljs-built_in">len</span>(unsorted_list)/<span class="hljs-number">2</span>)
    first_half = unsorted_list[:mid_point] 
    second_half = unsorted_list[mid_point:] 
    half_a = merge_sort(first_half) 
    half_b = merge_sort(second_half) 
<span class="hljs-keyword">    return</span> merge(half_a, half_b) 
</code></pre>
    <p class="normal">The<a id="_idIndexMarker226"/> implementation starts by accepting the list<a id="_idIndexMarker227"/> of unsorted elements into the <code class="inlineCode">merge_sort</code> function. The <code class="inlineCode">if</code> statement is used to establish the base case, where, if there is only one element in the <code class="inlineCode">unsorted_list</code>, we simply return that list again. If there is more than one element in the list, we find the approximate middle using <code class="inlineCode">mid_point = len(unsorted_list)//2</code>.</p>
    <p class="normal">Using this <code class="inlineCode">mid_point</code>, we divide the list into two sublists, namely, <code class="inlineCode">first_half</code> and <code class="inlineCode">second_half</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    first_half = unsorted_list[:mid_point] 
    second_half = unsorted_list[mid_point:] 
</code></pre>
    <p class="normal">A recursive call is made by passing the two sublist to the <code class="inlineCode">merge_sort</code> function again:</p>
    <pre class="programlisting code"><code class="hljs-code">    half_a = merge_sort(first_half)
    half_b = merge_sort(second_half)
</code></pre>
    <p class="normal">Now, for the merge step, <code class="inlineCode">half_a</code> and <code class="inlineCode">half_b</code> are sorted. When <code class="inlineCode">half_a</code> and <code class="inlineCode">half_b</code> have passed their values, we call the <code class="inlineCode">merge</code> function, which will merge or combine the two solutions stored in <code class="inlineCode">half_a</code> and <code class="inlineCode">half_b</code>, which are lists:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">merge</span><span class="hljs-function">(</span><span class="hljs-params">first_sublist, second_sublist</span><span class="hljs-function">):</span> 
    i = j = <span class="hljs-number">0</span>
    merged_list = []
<span class="hljs-keyword">    while</span> i &lt; <span class="hljs-built_in">len</span>(first_sublist) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(second_sublist):
<span class="hljs-keyword">        if</span> first_sublist[i] &lt; second_sublist[j]:
            merged_list.append(first_sublist[i]) 
            i += <span class="hljs-number">1</span> 
<span class="hljs-keyword">        else</span>:
            merged_list.append(second_sublist[j]) 
            j += <span class="hljs-number">1</span>
<span class="hljs-keyword">    while</span> i &lt; <span class="hljs-built_in">len</span>(first_sublist): 
        merged_list.append(first_sublist[i]) 
        i += <span class="hljs-number">1</span> 
<span class="hljs-keyword">    while</span> j &lt; <span class="hljs-built_in">len</span>(second_sublist):
        merged_list.append(second_sublist[j]) 
        j += <span class="hljs-number">1</span>
<span class="hljs-keyword">    return</span> merged_list 
</code></pre>
    <p class="normal">The <code class="inlineCode">merge</code> function takes the two lists we want to merge, <code class="inlineCode">first_sublist</code> and <code class="inlineCode">second_sublist</code>. The <code class="inlineCode">i</code> and <code class="inlineCode">j</code> variables are initialized to 0 and are used as pointers to tell us where we are in the two lists with respect to the merging process. </p>
    <p class="normal">The final <code class="inlineCode">merged_list</code> will contain the merged list.</p>
    <p class="normal">The <code class="inlineCode">while</code> loop starts comparing the elements in <code class="inlineCode">first_sublist</code> and <code class="inlineCode">second_sublist</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(first_sublist) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(second_sublist): 
        <span class="hljs-keyword">if</span> first_sublist[i] &lt; second_sublist[j]: 
            merged_list.append(first_sublist[i]) 
            i += <span class="hljs-number">1</span> 
        <span class="hljs-keyword">else</span>: 
            merged_list.append(second_sublist[j]) 
            j += <span class="hljs-number">1</span> 
</code></pre>
    <p class="normal">The <code class="inlineCode">if</code> statement <a id="_idIndexMarker228"/>selects the smaller of the two, <code class="inlineCode">first_sublist[i]</code> or <code class="inlineCode">second_sublist[j]</code>, and appends it to <code class="inlineCode">merged_list</code>. The <code class="inlineCode">i</code> or <code class="inlineCode">j</code> index<a id="_idIndexMarker229"/> is incremented to reflect where we are with the merging step. The <code class="inlineCode">while</code> loop stops when either sublist is empty.</p>
    <p class="normal">There may be elements left behind in either <code class="inlineCode">first_sublist</code> or <code class="inlineCode">second_sublist</code>. The last two <code class="inlineCode">while</code> loops make sure that those elements are added to <code class="inlineCode">merged_list</code> before it is returned. The last call to <code class="inlineCode">merge(half_a, half_b)</code> will return the sorted list. The following code shows how to pass an array to sort the elements using merge sort:</p>
    <pre class="programlisting code"><code class="hljs-code">a= [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">7</span>, <span class="hljs-number">41</span>, <span class="hljs-number">61</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">14</span>] 
<span class="hljs-built_in">print</span>(merge_sort(a))
</code></pre>
    <p class="normal">The output will be:</p>
    <pre class="programlisting con"><code class="hljs-con">[7, 11, 12, 14, 16, 41, 61]
</code></pre>
    <p class="normal">Let’s give the algorithm a dry run by merging the two sublists <code class="inlineCode">[4, 6, 8]</code> and <code class="inlineCode">[5, 7, 11, 40]</code>, shown in <em class="italic">Table 3.1</em>. In this example, initially, the two sorted sublists are given, and then the, first elements are matched, and since the first element of the first list is smaller, it is moved to <code class="inlineCode">merge_list</code>. Next, in <em class="italic">step 2</em>, again, the starting elements from both of the lists are matched, and the smaller element, which is from the second list, is moved to <code class="inlineCode">merge_list</code>. The same process is repeated until one of the lists becomes empty.</p>
    <table id="table001-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Step</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">first_sublist</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">second_sublist</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">merged_list</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">[4 6 8]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[5 7 11 40]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[]</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">[ 6 8]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[5 7 11 40]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[4]</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">[ 6 8]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[ 7 11 40]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[4 5]</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">3</p>
          </td>
          <td class="table-cell">
            <p class="normal">[ 8]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[ 7 11 40]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[4 5 6]</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">4</p>
          </td>
          <td class="table-cell">
            <p class="normal">[ 8]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[ 11 40]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[4 5 6 7]</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
          <td class="table-cell">
            <p class="normal">[ ]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[ 11 40]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[4 5 6 7 8]</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">6</p>
          </td>
          <td class="table-cell">
            <p class="normal">[]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[ ]</p>
          </td>
          <td class="table-cell">
            <p class="normal">[4 5 6 7 8 11 40]</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 3.1: Example of merging two lists</p>
    <p class="normal">This<a id="_idIndexMarker230"/> process can <a id="_idIndexMarker231"/>also be seen in <em class="italic">Figure 3.4</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 3.4: The process of merging the two sublists</p>
    <p class="normal">After one of the lists becomes empty, like after <em class="italic">step 4</em> in this example, at this point in the execution, the third <code class="inlineCode">while</code> loop in the <code class="inlineCode">merge</code> function kicks in to move <code class="inlineCode">11</code> and <code class="inlineCode">40</code> into <code class="inlineCode">merged_list</code>. The returned <code class="inlineCode">merged_list</code> will contain the fully sorted list.</p>
    <p class="normal">The worst-case <a id="_idIndexMarker232"/>running time complexity of the <a id="_idIndexMarker233"/>merge sort will depend on the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Firstly, the divide step will take a constant time since it just computes the midpoint, which can be done in <em class="italic">O</em>(<em class="italic">1</em>) time</li>
      <li class="numberedList">Then, in each iteration, we divide the list into half recursively, which will take <em class="italic">O</em>(<em class="italic">log n</em>), which is quite similar to what we have seen in the binary search algorithm</li>
      <li class="numberedList">Further, the combine/merge step merges all the <em class="italic">n</em> elements into the original array, which will take (<em class="italic">n</em>) time.</li>
    </ol>
    <p class="normal">Hence, the merge sort algorithm has a runtime complexity of <em class="italic">O</em>(<em class="italic">log n</em>) <em class="italic">T</em>(<em class="italic">n</em>) = <em class="italic">O</em>(<em class="italic">n</em>) * <em class="italic">O</em>(<em class="italic">log n</em>) = <em class="italic">O</em>(<em class="italic">n log n</em>).</p>
    <p class="normal">We have discussed the divide-and-conquer algorithm design technique with the help of a few examples. In the next section, we will discuss another algorithm design technique: dynamic programming.</p>
    <h1 id="_idParaDest-70" class="heading-1">Dynamic programming</h1>
    <p class="normal">Dynamic programming <a id="_idIndexMarker234"/>is the most powerful design technique for solving <a id="_idIndexMarker235"/>optimization problems. Such problems generally have many possible solutions. The basic idea of dynamic programming is based on the intuition of the divide-and-conquer technique. Here, essentially, we explore the space of all the possible solutions by decomposing the problem into a series of sub-problems and then combining the results to compute the correct solution for the large problem. The divide-and-conquer algorithm is used to solve a problem by combining the solutions of the non-overlapping (disjoint) sub-problems, whereas dynamic programming is used when the sub-problems are overlapping, meaning that the sub-problems share sub-sub-problems. The dynamic programming technique is similar to divide and conquer in that a problem is broken down into smaller problems. However, in divide and conquer, each sub-problem has to be solved before its results can be used to solve bigger problems. In contrast, dynamic programming-based techniques solve each sub-sub-problems only once and do not recompute the solution to an already-encountered sub-problem. Rather, it uses a remembering technique to avoid the re-computation.</p>
    <p class="normal">Dynamic programming problems have<a id="_idIndexMarker236"/> two important characteristics:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Optimal substructure</strong>: Given any problem, if the solution can be obtained by combining the solutions of its sub-problems, then the problem is said to have an optimal substructure. In other words, an optimal substructure means that the optimal solution of the problem can be obtained from the optimal solution of its sub-problems. For example, the i<sup class="superscript">th</sup> Fibonacci number from its series can be computed from (i-1)<sup class="superscript">th</sup> and (i-2)<sup class="superscript">th</sup> Fibonacci numbers; for example, fib(6) can be computed from fib(5) and fib(4).</li>
      <li class="bulletList"><strong class="keyWord">Overlapping sub-problem</strong>: If an <a id="_idIndexMarker237"/>algorithm has to repeatedly solve the same sub-problem again and again, then the problem has overlapping sub-problems. For example, fib(5) will have multiple time computations for fib(3) and fib(2).</li>
    </ul>
    <p class="normal">If a problem has these characteristics, then the dynamic programming approach is useful, since the implementation can be improved by reusing the same solution computed before. In a dynamic programming strategy, the problem is broken down into independent sub-problems, and the intermediate results are cached, which can then be used in subsequent operations.</p>
    <p class="normal">In the dynamic approach, we divide a given problem into smaller sub-problems. In recursion also, we divide the problem into sub-problems. However, the difference between recursion and dynamic programming is that similar sub-problems can be solved any number of times, but in dynamic programming, we keep track of previously solved sub-problems, and care is taken not to recompute any of the previously encountered sub-problems. One property that makes a problem an ideal candidate for being solved with dynamic <a id="_idIndexMarker238"/>programming is that it has an <strong class="keyWord">overlapping set of sub-problems</strong>. Once we realize that the form of sub-problems has repeated itself during computation, we need not compute it again. Instead, we return a pre computed result for that previously encountered sub-problem.</p>
    <p class="normal">Dynamic programming takes account of the fact that each sub-problem should be solved only once, and to ensure that we never re-evaluate a sub-problem, we need an efficient way to store the results of each sub-problem. The following two techniques are readily available:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Top-down with memoization</strong>: This <a id="_idIndexMarker239"/>technique starts from the initial problem set and divides it into small sub-problems. After the solution to a sub-program has been determined, we store the result of that particular sub-problem. In the future, when this sub-problem is encountered, we only return its pre computed result. Therefore, if the solution to a given problem can be formulated recursively using the solution of the sub-problems, then the solution of the overlapping sub-problems can easily be memoized. </li>
    </ul>
    <p class="normal">Memoization means storing the solution of the sub-problem in an array or hash table. Whenever a solution to a sub-problem needs to be computed, it is first referred to the saved values if it is already computed, and if it is not stored, then it is computed in the usual manner. This procedure is called <em class="italic">memoized</em>, which means it “remembers” the results of the operation that has been computed before.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Bottom-up approach</strong>: This <a id="_idIndexMarker240"/>approach depends upon the “size” of the sub-problems. We solve the smaller sub-problems first, and then while solving a particular sub-problem, we already have a solution of the smaller sub-problems on which it depends. Each sub-problem is solved only once, and whenever we try to solve any sub-problem, solutions to all the prerequisite smaller sub-problems are available, which can be used to solve it. In this approach, a given problem is solved by dividing it into sub-problems recursively, with the smallest possible sub-problems then being solved. Furthermore, the solutions to the sub-problems are combined in a bottom-up fashion to arrive at the solution to the bigger sub-problem in order to recursively reach the final solution.</li>
    </ul>
    <p class="normal">Let’s consider an example to understand how dynamic programming works. Let us solve the problem of the Fibonacci series using dynamic programming.</p>
    <h2 id="_idParaDest-71" class="heading-2">Calculating the Fibonacci series</h2>
    <p class="normal">The Fibonacci series <a id="_idIndexMarker241"/>can be demonstrated using a recurrence relation. Recurrence relations are recursive functions that are used to define mathematical functions or sequences. For example, the following recurrence relation defines the Fibonacci sequence <code class="inlineCode">[1, 1, 2, 3, 5, 8 ...]</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">func(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span> 
func(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>  
func(n) = func(n-<span class="hljs-number">1</span>) + func(n-<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> n&gt;<span class="hljs-number">1</span>
</code></pre>
    <p class="normal">Note that the Fibonacci sequence can be generated by putting the values of <em class="italic">n</em> in sequence <code class="inlineCode">[0, 1, 2, 3, 4, ...]</code>. Let’s take an example to generate the Fibonacci series to the fifth term: </p>
    <pre class="programlisting con"><code class="hljs-con">    1 1 2 3 5 
</code></pre>
    <p class="normal">A recursive-style program to generate the sequence would be as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">fib</span><span class="hljs-function">(</span><span class="hljs-params">n</span><span class="hljs-function">):</span>   
     <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:   
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>   
     <span class="hljs-keyword">else</span>:  
        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>)  
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):
    <span class="hljs-built_in">print</span>(fib(i))
</code></pre>
    <p class="normal">This will produce<a id="_idIndexMarker242"/> output like the following:</p>
    <pre class="programlisting con"><code class="hljs-con">1
1
2
3
5
</code></pre>
    <p class="normal">In this code, we can see that the recursive calls are being called in order to solve the problem. When the base case is met, the <code class="inlineCode">fib()</code> function returns <code class="inlineCode">1</code>. If <em class="italic">n</em> is equal to or less than 1, the base case is met. If the base case is not met, we call the <code class="inlineCode">fib()</code> function again. The recursion tree to solve up to the fifth term in the Fibonacci sequence is shown in <em class="italic">Figure 3.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 3.5: Recursion tree for fib(5)</p>
    <p class="normal">We can observe from the overlapping sub-problems from the recursion tree as shown in <em class="italic">Figure 3.6</em> that the call to <strong class="keyWord">fib(1)</strong> happens twice, the call to <strong class="keyWord">fib(2)</strong> happens three times, and the call to <strong class="keyWord">fib(3)</strong> occurs twice. The return values of the same function call never change; for example, the return value for <strong class="keyWord">fib(2)</strong> will always be the same whenever we call it. Likewise, it will also be the same for <strong class="keyWord">fib(1)</strong> and <strong class="keyWord">fib(3)</strong>. So, they are overlapping problems, thus, computational time will be wasted if we compute the same function again whenever it is encountered. These repeated calls to a function with the same parameters and output <a id="_idIndexMarker243"/>suggest that there is an overlap. Certain computations reoccur down in the smaller sub-problem.</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 3.6: Overlapping sub-problems shown in the recursion tree for fib(5)</p>
    <p class="normal">In dynamic programming using the memoization technique, we store the results of the computation of <strong class="keyWord">fib(1)</strong> the first time it is encountered. Similarly, we store return values for <strong class="keyWord">fib(2)</strong> and <strong class="keyWord">fib(3)</strong>. Later, whenever we encounter a call to <strong class="keyWord">fib(1)</strong>, <strong class="keyWord">fib(2)</strong>, or <strong class="keyWord">fib(3)</strong>, we simply return their respective results. The recursive tree diagram is shown in <em class="italic">Figure 3.7</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_07.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.7: Recursion tree for fib(5) showing re-use of the already computed values</p>
    <p class="normal">Thus, in dynamic programming, we have eliminated the need to compute <strong class="keyWord">fib(3)</strong>, <strong class="keyWord">fib(2)</strong>, and <strong class="keyWord">fib(1)</strong> if they are encountered multiple times. This is called the memoization technique, wherein there is no recomputation of overlapping calls to functions when breaking a problem down into its sub-problems.</p>
    <p class="normal">Hence, the overlapping<a id="_idIndexMarker244"/> function calls in our Fibonacci example are <strong class="keyWord">fib(1)</strong>, <strong class="keyWord">fib(2)</strong>, and <strong class="keyWord">fib(3)</strong>. Below is the code for the dynamic programming-based implementation for the Fibonacci series.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">dyna_fib</span><span class="hljs-function">(</span><span class="hljs-params">n</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>  
    <span class="hljs-keyword">if</span> lookup[n] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> lookup[n]
  
    lookup[n] = dyna_fib(n-<span class="hljs-number">1</span>) + dyna_fib(n-<span class="hljs-number">2</span>)
    <span class="hljs-keyword">return</span> lookup[n]
lookup = [<span class="hljs-literal">None</span>]*(<span class="hljs-number">1000</span>)
 
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>): 
    <span class="hljs-built_in">print</span>(dyna_fib(i))
</code></pre>
    <p class="normal">This will produce an output like the following:</p>
    <pre class="programlisting con"><code class="hljs-con">0
1
1
2
3
5
</code></pre>
    <p class="normal">In the dynamic<a id="_idIndexMarker245"/> implementation of the Fibonacci series, we store the results of previously solved sub-problems in a list (in other words, a lookup in this example code). We first check whether the Fibonacci of any number is already computed; if it is already computed, then we return the stored value from the <code class="inlineCode">lookup[n]</code>. Otherwise, when we compute its value, it is done through the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> lookup[n] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> lookup[n]
</code></pre>
    <p class="normal">After computing the solution of the sub-problem, it is again stored in the lookup list. The Fibonacci number of the given value is returned as shown in the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">lookup[n] = dyna_fib(n-<span class="hljs-number">1</span>) + dyna_fib(n-<span class="hljs-number">2</span>)
</code></pre>
    <p class="normal">Furthermore, in order to store a list of 1,000 elements, we create a list lookup using the <code class="inlineCode">dyna_fib</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">    lookup = [<span class="hljs-literal">None</span>]*(<span class="hljs-number">1000</span>)
</code></pre>
    <p class="normal">So, in dynamic programming-based solutions, we use the precomputed solutions in order to compute the final results.</p>
    <p class="normal">Dynamic programming improves the running time complexity of the algorithm. In the recursive approach, for every value, two functions are called; for example, <strong class="keyWord">fib(5)</strong> calls <strong class="keyWord">fib(4)</strong> and <strong class="keyWord">fib(3)</strong>, and then <strong class="keyWord">fib(4)</strong> calls <strong class="keyWord">fib(3)</strong> and <strong class="keyWord">fib(2)</strong>, and so on. Thus, the time complexity for the recursive approach is O(2<sup class="superscript">n</sup>), whereas, in the dynamic programming approach, we do not recompute the sub-problems, so for <strong class="keyWord">fib(n)</strong>, we have <em class="italic">n</em> total values to be computed, in other words, <strong class="keyWord">fib(0)</strong>, <strong class="keyWord">fib(1)</strong>, <strong class="keyWord">fib(2)</strong>… <strong class="keyWord">fib(n)</strong>. Thus, we only solve these values once, so the total running time complexity is O(n). Thus, dynamic programming in general improves <a id="_idIndexMarker246"/>performance.</p>
    <p class="normal">In this section, we have discussed the dynamic programming design technique, and in the next section, we discuss the design techniques for greedy algorithms.</p>
    <h1 id="_idParaDest-72" class="heading-1">Greedy algorithms</h1>
    <p class="normal">Greedy algorithms<a id="_idIndexMarker247"/> often involve optimization and combinatorial problems. In<a id="_idIndexMarker248"/> greedy algorithms, the objective is to obtain the optimum solution from many possible solutions in each step. We try to get the local optimum solution, which may eventually lead us to obtain the global optimum solution. The greedy strategy does not always produce the optimal solution. However, the sequence of locally optimal solutions generally approximates the globally optimal solution.</p>
    <p class="normal">For example, consider that you are given some random digits, say <code class="inlineCode">1</code>, <code class="inlineCode">4</code>, <code class="inlineCode">2</code>, <code class="inlineCode">6</code>, <code class="inlineCode">9</code>, and <code class="inlineCode">5</code>. Now you have to make the biggest number by using all the digits without repeating any digit. To create the biggest number from the given digits using the greedy strategy, we perform the following steps. Firstly, we select the largest digit from the given digits, and then append it to the number and remove the digit from the list until we have no digits left in the list. Once all the digits have been used, we get the largest number that can be formed by using these digits: <code class="inlineCode">965421</code>. The stepwise solution to this problem is shown in <em class="italic">Figure 3.8</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_08.png" alt=""/></figure>
    <figure class="mediaobject"><img src="../Images/B17217_03_08.1.png" alt=""/></figure>
    <p class="packt_figref">Figure 3.8: Example of a greedy algorithm</p>
    <p class="normal">Let us consider another<a id="_idIndexMarker249"/> example to better understand the greedy <a id="_idIndexMarker250"/>approach. Say you have to give 29 Indian rupees to someone in the minimum number of notes, giving one note at a time, but never exceeding the owed amount. Assume that we have notes in denominations of 1, 2, 5, 10, 20, and 50. To solve this using the greedy approach, we will start by handing over the 20-rupee note, then for the remaining 9 rupees, we will give a 5-rupee note; for the remaining 4 rupees, we will give the 2-rupee note, and then another 2-rupee note.</p>
    <p class="normal">In this approach, at each step, we chose the best possible solution and gave the largest available note. Assume that, for this example, we have to use the notes of 1, 14, and 25. Then, using the greedy approach, we will pick the 25-rupee note, and then four 1-rupee notes, which makes a total of 5 notes. However, this is not the minimum number of notes possible . The better solution would be to give notes of 14, 14, and 1. Thus, it is also clear that the greedy approach does not always give the best solution, but a feasible and simple one.</p>
    <p class="normal">The classic example is to <a id="_idIndexMarker251"/>apply the greedy algorithm to the traveling salesperson problem, where a greedy approach always chooses the closest destination first. In this problem, a greedy approach always chooses the closest unvisited city in relation to the current city; in this way, we are not sure that we will get the best solution, but we surely get an optimal solution. This shortest-path strategy involves finding the best solution to a local problem in the hope that this will lead to a global solution.</p>
    <p class="normal">Listed here are many <a id="_idIndexMarker252"/>popular standard problems where we can use greedy algorithms to obtain the optimum solution:</p>
    <ul>
      <li class="bulletList">Kruskal’s minimum spanning tree</li>
      <li class="bulletList">Dijkstra’s shortest path problem</li>
      <li class="bulletList">The Knapsack problem</li>
      <li class="bulletList">Prim’s minimal spanning tree algorithm</li>
      <li class="bulletList">The traveling salesperson problem</li>
    </ul>
    <p class="normal">Let us discuss one of the popular problems, in other words, the shortest path problem, which can be solved using the greedy approach, in the next section.</p>
    <h2 id="_idParaDest-73" class="heading-2">Shortest path problem</h2>
    <p class="normal">The shortest <a id="_idIndexMarker253"/>path problem<a id="_idIndexMarker254"/> requires us to find out the shortest possible route between nodes on a graph. Dijkstra’s algorithm is a very popular method for solving this using the greedy approach. The algorithm is used to find the shortest distance from a source to a destination node in a graph.</p>
    <p class="normal">Dijkstra’s algorithm works for weighted directed and undirected graphs. The algorithm produces the output of a list of the shortest path from a given source node, A, in a weighted graph. The algorithm works as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Initially, mark all the nodes as unvisited, and set their distance from the given source node to infinity (the source node is set to zero).</li>
      <li class="numberedList">Set the source node as the current one.</li>
      <li class="numberedList">For the current node, look for all the unvisited adjacent nodes, and compute the distance to that node from the source node through the current node. Compare the newly computed distance to the currently assigned distance, and if it is smaller, set this as the new value.</li>
    </ol>
    <p class="normal">Once we have considered all the unvisited adjacent nodes of the current node, we mark it as visited.</p>
    <p class="normal">If the destination node has been marked visited, or if the list of unvisited nodes is empty, meaning we have considered all the unvisited nodes, then the algorithm is finished.</p>
    <p class="normal">We next consider <a id="_idIndexMarker255"/>the next unvisited node that has the shortest distance from the source node. Repeat <em class="italic">steps 2</em> to <em class="italic">6</em>.</p>
    <p class="normal">Consider the example<a id="_idIndexMarker256"/> in <em class="italic">Figure 3.9</em> of a weighted graph with six nodes [A, B, C, D, E, and F] to understand how Dijkstra’s algorithm works.</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_09.png" alt="A picture containing text, clock, watch  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.9: Example weighted graph with six nodes</p>
    <p class="normal">By manual inspection, the <a id="_idIndexMarker257"/>shortest path between nodes <strong class="keyWord">A</strong> and <strong class="keyWord">D</strong>, at first glance, seems to be the direct line with a distance of 9. However, the shortest route means the lowest total distance, even if this comprises several parts. By comparison, traveling from node <strong class="keyWord">A</strong> to <strong class="keyWord">E</strong>, then from <strong class="keyWord">E</strong> to <strong class="keyWord">F</strong>, and finally to <strong class="keyWord">D</strong> will incur a total distance of 7, making it a shorter route.</p>
    <p class="normal">We would implement the shortest path algorithm with a single source. It would determine the shortest path from the origin, which in this case is <strong class="keyWord">A</strong>, to any other node in the graph. In <em class="chapterRef">Chapter 9</em>, <em class="italic">Graphs and Other Algorithms</em>, we will discuss how to represent a graph with an adjacency list. We use an adjacency list along with the weight/cost/distance on every edge to represent the graph, as shown in the following Python code. The adjacency list for the diagram and table is as follows:</p>
    <pre class="programlisting gen"><code class="hljs"><code class="inlineCode">    graph = dict() </code>
<code class="inlineCode">    graph['A'] = {'B': 5, 'D': 9, 'E': 2} </code>
<code class="inlineCode">    graph['B'] = {'A': 5, 'C': 2} </code>
<code class="inlineCode">    graph['C'] = {'B': 2, 'D': 3} </code>
<code class="inlineCode">    graph['D'] = {'A': 9, 'F': 2, 'C': 3} </code>
<code class="inlineCode">    graph['E'] = {'A': 2, 'F': 3} </code>
<code class="inlineCode">    graph['F'] = {'E': 3, 'D': 2} </code>
</code></pre>
    <p class="normal">We will return to the rest <a id="_idIndexMarker258"/>of the code after a visual demonstration, but<a id="_idIndexMarker259"/> don’t forget to declare the graph to ensure the code runs correctly. </p>
    <p class="normal">The nested dictionary holds the distance and adjacent nodes. A table is used to keep track of the shortest distance from the source in the graph to any other node. <em class="italic">Table 3.2</em> is the starting table:</p>
    <table id="table002-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Shortest distance from source</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Previous node</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">A</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">B</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><img src="../Images/B17217_03_001.png" alt=""/></p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">C</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><img src="../Images/B17217_03_002.png" alt=""/></p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">D</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><img src="../Images/B17217_03_003.png" alt=""/></p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">E</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><img src="../Images/B17217_03_004.png" alt=""/></p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">F</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><img src="../Images/B17217_03_005.png" alt=""/></p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 3.2: Initial table showing the shortest distance from the source</p>
    <p class="normal">When the algorithm starts, the<a id="_idIndexMarker260"/> shortest distance from the given source node (<strong class="keyWord">A</strong>) to any of the<a id="_idIndexMarker261"/> nodes is unknown. Thus, we initially set the distance to all other nodes to infinity, with the exception of node <strong class="keyWord">A</strong>, as the distance from node <strong class="keyWord">A</strong> to node <strong class="keyWord">A</strong> is <strong class="keyWord">0</strong>. No prior nodes have been visited when the algorithm begins. Therefore, we mark the previous node column of node <strong class="keyWord">A</strong> as <strong class="keyWord">None</strong>.</p>
    <p class="normal">In <em class="italic">step 1</em> of the algorithm, we start by examining the adjacent nodes to node <strong class="keyWord">A</strong>. To find the shortest distance from node <strong class="keyWord">A</strong> to node <strong class="keyWord">B</strong>, we need to find the distance from the start node to the previous node of node <strong class="keyWord">B</strong>, which happens to be <strong class="keyWord">A</strong>, and add it to the distance from node <strong class="keyWord">A</strong> to node <strong class="keyWord">B</strong>. We do this for the other adjacent nodes of <strong class="keyWord">A</strong>, these being <strong class="keyWord">B</strong>, <strong class="keyWord">E</strong>, and <strong class="keyWord">D</strong>. This is shown in <em class="italic">Figure 3.10</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_10.png" alt="A picture containing text, watch, clock  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.10: A sample graph for Dijkstra’s algorithm</p>
    <p class="normal">Firstly, we take the adjacent node <strong class="keyWord">E</strong> as its distance from node <strong class="keyWord">A</strong> is the minimum; the distance from the start node (<strong class="keyWord">A</strong>) to the previous node (<strong class="keyWord">None</strong>) is 0, and the distance from the previous node to the current node (<strong class="keyWord">E</strong>) is <strong class="keyWord">2</strong>. </p>
    <p class="normal">This sum is compared with the data in the shortest distance column of <a id="_idIndexMarker262"/>node <strong class="keyWord">E</strong> (refer to <em class="italic">Table 3.3</em>). Since <strong class="keyWord">2</strong> is less than infinity (<img src="../Images/B17217_03_006.png" alt="" style="height: 0.8em !important; vertical-align: -0.10em !important;"/>), we replace <img src="../Images/B17217_03_007.png" alt="" style="height: 0.8em !important; vertical-align: -0.10em !important;"/> with the smaller of the two, in other words, <strong class="keyWord">2</strong>. Similarly, the distance from node <strong class="screenText">A</strong> to nodes <strong class="screenText">B</strong> and <strong class="screenText">D</strong> is compared with the existing shortest distance to these nodes from node <strong class="screenText">A</strong>. Any time the shortest distance of a node is replaced by a smaller value, we need to update the previous node column for all the adjacent nodes of the current node.</p>
    <p class="normal">After this, we mark node <strong class="keyWord">A</strong> as visited (represented in blue in <em class="italic">Figure 3.11</em>):</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_11.png" alt="Chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.11: Shortest distance graph after visiting node A using Dijkstra’s algorithm</p>
    <p class="normal">At the end of <em class="italic">step 1</em>, the table<a id="_idIndexMarker263"/> looks like that shown in <em class="italic">Table 3.3</em>, in which the shortest<a id="_idIndexMarker264"/> distance from node <strong class="screenText">A</strong> to nodes <strong class="screenText">B</strong>, <strong class="screenText">D</strong>,and <strong class="screenText">E</strong> are updated.</p>
    <table id="table003-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Shortest distance from source</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Previous node</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">A*</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">B</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">C</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><img src="../Images/B17217_03_008.png" alt=""/></p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">D</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">9</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">E</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">F</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><img src="../Images/B17217_03_009.png" alt=""/></p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 3.3: Shortest distance table after visiting node A</p>
    <p class="normal">At this point, node <strong class="keyWord">A</strong> is considered visited. As such, we add node <strong class="keyWord">A</strong> to the list of visited nodes. In the table, we show that node <strong class="keyWord">A</strong> has been visited by appending an asterisk sign to it. </p>
    <p class="normal">In the second step, we find the node with the shortest distance using <em class="italic">Table 3.3</em> as a guide. Node <strong class="keyWord">E</strong>, with its value of 2, has the shortest distance. To reach node <strong class="keyWord">E</strong>, we must visit node <strong class="keyWord">A</strong> and cover a distance of <strong class="keyWord">2</strong>.</p>
    <p class="normal">Now, the adjacent nodes of node <strong class="keyWord">E</strong> are nodes <strong class="keyWord">A</strong> and <strong class="keyWord">F</strong>. Since node <strong class="keyWord">A</strong> has already been visited, we will only consider node <strong class="keyWord">F</strong>. To find the shortest route or distance to node <strong class="keyWord">F</strong>, we must find the distance from the starting node to node <strong class="keyWord">E</strong> and add it to the distance between nodes <strong class="keyWord">E</strong> and <strong class="keyWord">F</strong>. We can find the distance from the starting node to node <strong class="keyWord">E</strong> by looking at the shortest distance column of node <strong class="keyWord">E</strong>, which has a value of <strong class="keyWord">2</strong>. The distance from nodes <strong class="keyWord">E</strong> to <strong class="keyWord">F</strong> can be <a id="_idIndexMarker265"/>obtained from the adjacency list, which is <strong class="keyWord">3</strong>. These two total 5, which <a id="_idIndexMarker266"/>is less than infinity. Remember that we are examining the adjacent node <strong class="keyWord">F</strong>. Since there are no more adjacent nodes to node <strong class="keyWord">E</strong>, we mark node <strong class="keyWord">E</strong> as visited. Our updated table and the figure will have the following values, shown in <em class="italic">Table 3.4</em> and <em class="italic">Figure 3.12</em>:</p>
    <table id="table004-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Shortest distance from source</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Previous node</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">A*</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">B</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">C</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><img src="../Images/B17217_03_010.png" alt=""/></p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">D</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">9</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">E*</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">F</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
          <td class="table-cell">
            <p class="normal">E</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 3.4: Shortest distance table after visiting node E</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_12.png" alt="Chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.12: Shortest distance graph after visiting node E using Dijkstra’s algorithm</p>
    <p class="normal">After visiting node <strong class="keyWord">E</strong>, we find<a id="_idIndexMarker267"/> the smallest value in the Shortest distance column of <em class="italic">Table 3.4</em>, which is 5 for nodes <strong class="keyWord">B</strong> and <strong class="keyWord">F</strong>. Let us choose <strong class="keyWord">B</strong> instead of <strong class="keyWord">F</strong> for alphabetical <a id="_idIndexMarker268"/>reasons. The adjacent nodes of <strong class="keyWord">B</strong> are nodes <strong class="keyWord">A</strong> and <strong class="keyWord">C</strong> since node <strong class="keyWord">A</strong> has already been visited. Using the rule we established earlier, the shortest distance from <strong class="keyWord">A</strong> to <strong class="keyWord">C</strong> is 7, which is computed as the distance from the starting node to node <strong class="keyWord">B</strong>, which is 5, while the distance from node <strong class="keyWord">B</strong> to <strong class="keyWord">C</strong> is 2. Since 7 is less than infinity, we update the shortest distance to 7 and update the previous node column with node <strong class="keyWord">B</strong> in <em class="italic">Table 3.4</em>.</p>
    <p class="normal">Now, <strong class="keyWord">B</strong> is also marked as visited (represented in blue in <em class="italic">Figure 3.13</em>).</p>
    <table id="table005-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Shortest distance from source</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Previous node</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">A*</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">B*</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">C</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">7</p>
          </td>
          <td class="table-cell">
            <p class="normal">B</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">D</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">9</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">E*</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">F</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
          <td class="table-cell">
            <p class="normal">E</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 3.5: Shortest distance table after visiting node B</p>
    <p class="normal">The new state of the table is as follows, in <em class="italic">Table 3.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_13.png" alt="Chart, schematic  Description automatically generated"/></figure>
    <figure class="mediaobject">Figure 3.13: Shortest distance graph after visiting node B using Dijkstra’s algorithm</figure>
    <p class="normal">The node with the <a id="_idIndexMarker269"/>shortest distance yet unvisited is node <strong class="keyWord">F</strong>. The adjacent nodes to <strong class="keyWord">F</strong> are <a id="_idIndexMarker270"/>nodes <strong class="keyWord">D</strong> and <strong class="keyWord">E</strong>. Since node <strong class="keyWord">E</strong> has already been visited, we will focus on node <strong class="screenText">D</strong>. To find the shortest distance from the starting node to node <strong class="keyWord">D</strong>, we calculate this distance by adding the distance from nodes <strong class="keyWord">A</strong> to <strong class="keyWord">F</strong> to the distance from nodes <strong class="keyWord">F</strong> to <strong class="keyWord">D</strong>. This totals 7, which is less than <strong class="keyWord">9</strong>. Thus, we update the <strong class="keyWord">9</strong> with <strong class="keyWord">7</strong> and replace <strong class="keyWord">A</strong> with <strong class="keyWord">F</strong> in node <strong class="keyWord">D</strong>’s previous node column of <em class="italic">Table 3.5</em>.</p>
    <p class="normal">Node <strong class="keyWord">F</strong> is now <a id="_idIndexMarker271"/>marked as<a id="_idIndexMarker272"/> visited (represented in blue in <em class="italic">Figure 3.14</em>).</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_14.png" alt="Chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.14: Shortest distance graph after visiting node F using Dijkstra’s algorithm</p>
    <p class="normal">Here is the updated table, as shown in <em class="italic">Table 3.6</em>:</p>
    <table id="table006-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Shortest distance from source</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Previous node</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">A*</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">B*</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">C</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">7</p>
          </td>
          <td class="table-cell">
            <p class="normal">B</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">D</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">7</p>
          </td>
          <td class="table-cell">
            <p class="normal">F</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">E*</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">F*</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
          <td class="table-cell">
            <p class="normal">E</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 3.6: Shortest distance table after visiting node F</p>
    <p class="normal">Now, only two unvisited <a id="_idIndexMarker273"/>nodes are left, <strong class="keyWord">C</strong> and <strong class="keyWord">D</strong>, both with a distance cost of <strong class="keyWord">7</strong>. In <a id="_idIndexMarker274"/>alphabetical order, we choose to consider node <strong class="keyWord">C</strong> because both nodes have the same shortest distance from the starting node <strong class="keyWord">A</strong>.</p>
    <p class="normal">However, all the adjacent nodes to <strong class="keyWord">C</strong> have been visited (represented in blue in <em class="italic">Figure 3.15</em>). Thus, we have nothing to do but mark node <strong class="keyWord">C</strong> as visited. The table remains unchanged at this point.</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_15.png" alt="Chart, diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.15: Shortest distance graph after visiting node C using Dijkstra’s algorithm</p>
    <p class="normal">Lastly, we take node <strong class="keyWord">D</strong> and<a id="_idIndexMarker275"/> find out that all its adjacent nodes have been visited too. We only mark it as visited (represented in blue in <em class="italic">Figure 3.16</em>).</p>
    <figure class="mediaobject"><img src="../Images/B17217_03_16.png" alt="Chart, diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.16: Shortest distance graph after visiting node D using Dijkstra’s algorithm</p>
    <p class="normal">The table remains <a id="_idIndexMarker276"/>unchanged, as <a id="_idIndexMarker277"/>shown in <em class="italic">Table 3.7</em>:</p>
    <table id="table007-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Shortest distance from source</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Previous node</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">A*</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">B*</p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">C*</p>
          </td>
          <td class="table-cell">
            <p class="normal">7</p>
          </td>
          <td class="table-cell">
            <p class="normal">B</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">D*</p>
          </td>
          <td class="table-cell">
            <p class="normal">7</p>
          </td>
          <td class="table-cell">
            <p class="normal">F</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">E*</p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">F*</p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
          <td class="table-cell">
            <p class="normal">E</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 3.7: Shortest distance table after visiting node F</p>
    <p class="normal">Let’s verify <em class="italic">Table 3.7</em> with our initial graph. From the graph, we know that the shortest distance from <strong class="keyWord">A</strong> to <strong class="keyWord">F</strong> is <strong class="keyWord">5</strong>.</p>
    <p class="normal">According to the table, the shortest distance from the source column for node <strong class="keyWord">F</strong> is 5. This is true. It also tells us that to get to node <strong class="keyWord">F</strong>, we need to visit node <strong class="keyWord">E</strong>, and from <strong class="keyWord">E</strong> to node <strong class="keyWord">A</strong>, which is our starting node. This is actually the shortest path from node <strong class="screenText">A</strong> to node <strong class="screenText">F</strong>.</p>
    <p class="normal">Now, we will discuss the Python implementation of Dijkstra’s algorithm to find the shortest path. We begin the program for finding the shortest distance by representing the table that enables us to track the changes in the graph. For the initial <em class="italic">Figure 3.8</em> that we used, here is a dictionary representation of the table to accompany the graph representation we showed earlier in the section:</p>
    <pre class="programlisting code"><code class="hljs-code">    table = { 
    <span class="hljs-string">'A'</span>: [<span class="hljs-number">0</span>, <span class="hljs-literal">None</span>], 
    <span class="hljs-string">'B'</span>: [<span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>), <span class="hljs-literal">None</span>], 
    <span class="hljs-string">'C'</span>: [<span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>), <span class="hljs-literal">None</span>], 
    <span class="hljs-string">'D'</span>: [<span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>), <span class="hljs-literal">None</span>], 
    <span class="hljs-string">'E'</span>: [<span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>), <span class="hljs-literal">None</span>], 
    <span class="hljs-string">'F'</span>: [<span class="hljs-built_in">float</span>(<span class="hljs-string">"inf"</span>), <span class="hljs-literal">None</span>], 
}
</code></pre>
    <p class="normal">The initial state of the<a id="_idIndexMarker278"/> table uses <code class="inlineCode">float("inf")</code> to represent infinity. Each key <a id="_idIndexMarker279"/>in the dictionary maps to a list. At the first index of the list, the shortest distance from the source, node A is stored. At the second index, the previous node is stored:</p>
    <pre class="programlisting code"><code class="hljs-code">DISTANCE = <span class="hljs-number">0</span> 
PREVIOUS_NODE = <span class="hljs-number">1</span> 
INFINITY = <span class="hljs-built_in">float</span>(<span class="hljs-string">'</span><span class="hljs-string">inf'</span>) 
</code></pre>
    <p class="normal">Here, the shortest path’s column index is referenced by <code class="inlineCode">DISTANCE</code>. The previous node column’s index is referenced by <code class="inlineCode">PREVIOUS_NODE</code>.</p>
    <p class="normal">Firstly, we discuss the helper methods that we will be using while implementing the main function to find the shortest path, in other words, <code class="inlineCode">find_shortest_path</code>. The first helper method is <code class="inlineCode">get_shortest_distance</code>, which returns the shortest distance of a node from the source node: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_shortest_distance</span><span class="hljs-function">(</span><span class="hljs-params">table, vertex</span><span class="hljs-function">):</span> 
    shortest_distance = table[vertex][DISTANCE] 
    <span class="hljs-keyword">return</span> shortest_distance 
</code></pre>
    <p class="normal">The <code class="inlineCode">get_shortest_distance</code> function returns the value stored in index 0 of the table. At that index, we always store the shortest distance from the starting node up to <code class="inlineCode">vertex</code>. The <code class="inlineCode">set_shortest_distance</code> function only sets this value as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">set_shortest_distance</span><span class="hljs-function">(</span><span class="hljs-params">table, vertex, new_distance</span><span class="hljs-function">):</span> 
    table[vertex][DISTANCE] = new_distance 
</code></pre>
    <p class="normal">When we update the shortest distance of a node, we update its previous node using the following method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">set_previous_node</span><span class="hljs-function">(</span><span class="hljs-params">table, vertex, previous_node</span><span class="hljs-function">):</span> 
    table[vertex][PREVIOUS_NODE] = previous_node 
</code></pre>
    <p class="normal">Remember that the <code class="inlineCode">PREVIOUS_NODE</code> constant equals 1. In the table, we store the value of <code class="inlineCode">previous_node</code> at <code class="inlineCode">table[vertex][PREVIOUS_NODE]</code>. To find the distance between any two nodes, we use the <code class="inlineCode">get_distance</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_distance</span><span class="hljs-function">(</span><span class="hljs-params">graph, first_vertex, second_vertex</span><span class="hljs-function">):</span> 
    <span class="hljs-keyword">return</span> graph[first_vertex][second_vertex] 
</code></pre>
    <p class="normal">The last helper <a id="_idIndexMarker280"/>method<a id="_idIndexMarker281"/> is the <code class="inlineCode">get_next_node</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_next_node</span><span class="hljs-function">(</span><span class="hljs-params">table, visited_nodes</span><span class="hljs-function">):</span> 
        unvisited_nodes = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(table.keys()).difference(<span class="hljs-built_in">set</span>(visited_nodes))) 
        assumed_min = table[unvisited_nodes[<span class="hljs-number">0</span>]][DISTANCE] 
        min_vertex = unvisited_nodes[<span class="hljs-number">0</span>] 
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> unvisited_nodes: 
            <span class="hljs-keyword">if</span> table[node][DISTANCE] &lt; assumed_min: 
                assumed_min = table[node][DISTANCE] 
                min_vertex = node 
        <span class="hljs-keyword">return</span> min_vertex 
</code></pre>
    <p class="normal">The <code class="inlineCode">get_next_node</code> function resembles a function to find the smallest item in a list. The function starts off by finding the unvisited nodes in our table by using <code class="inlineCode">visited_nodes</code> to obtain the difference between the two sets of lists. The very first item in the list of <code class="inlineCode">unvisited_nodes</code> is assumed to be the smallest in the shortest distance column of <code class="inlineCode">table</code>.</p>
    <p class="normal">If a lesser value is found while the <code class="inlineCode">for</code> loop runs, <code class="inlineCode">min_vertex</code> will be updated. The function then returns <code class="inlineCode">min_vertex</code> as the unvisited vertex or node with the smallest shortest distance from the source.</p>
    <p class="normal">Now all is set<a id="_idIndexMarker282"/> up for the <a id="_idIndexMarker283"/>main function of the algorithm, in other words, <code class="inlineCode">find_shortest_path</code>, as shown here: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">find_shortest_path</span><span class="hljs-function">(</span><span class="hljs-params">graph, table, origin</span><span class="hljs-function">):</span> 
    visited_nodes = [] 
    current_node = origin 
    starting_node = origin 
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: 
        adjacent_nodes = graph[current_node] 
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">set</span>(adjacent_nodes).issubset(<span class="hljs-built_in">set</span>(visited_nodes)): 
            <span class="hljs-comment"># Nothing here to do. All adjacent nodes have been visited. </span>
            <span class="hljs-keyword">pass</span> 
        <span class="hljs-keyword">else</span>: 
            unvisited_nodes = 
                <span class="hljs-built_in">set</span>(adjacent_nodes).difference(<span class="hljs-built_in">set</span>(visited_nodes)) 
            <span class="hljs-keyword">for</span> vertex <span class="hljs-keyword">in</span> unvisited_nodes: 
                distance_from_starting_node = 
                    get_shortest_distance(table, vertex) 
                <span class="hljs-keyword">if</span> distance_from_starting_node == INFINITY <span class="hljs-keyword">and</span> 
                   current_node == starting_node: 
                    total_distance = get_distance(graph, vertex, 
                                                  current_node) 
                <span class="hljs-keyword">else</span>: 
                    total_distance = get_shortest_distance (table, 
                    current_node) + get_distance(graph, current_node, 
                                                 vertex) 
                <span class="hljs-keyword">if</span> total_distance &lt; distance_from_starting_node: 
                    set_shortest_distance(table, vertex, 
                                          total_distance) 
                    set_previous_node(table, vertex, current_node) 
        visited_nodes.append(current_node)
<span class="hljs-comment">        #print(visited_nodes)</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(visited_nodes) == <span class="hljs-built_in">len</span>(table.keys()): 
            <span class="hljs-keyword">break</span> 
        current_node = get_next_node(table,visited_nodes) 
      <span class="hljs-keyword">return</span> (table)
</code></pre>
    <p class="normal">In the preceding code, the function takes the graph, represented by the adjacency list, the table, and the starting node as input parameters. We keep the list of visited nodes in the <code class="inlineCode">visited_nodes</code> list. The <code class="inlineCode">current_node</code> and <code class="inlineCode">starting_node</code> variables both point to the node in the graph that we choose to make our starting node. The <code class="inlineCode">origin</code> value is the reference point for all other nodes with respect to finding the shortest path.</p>
    <p class="normal">The main process of the function is implemented by the <code class="inlineCode">while</code> loop. Let’s break down what the <code class="inlineCode">while</code> loop is doing. In the body of the <code class="inlineCode">while</code> loop, we consider the current node in the graph that we want to investigate and initially get all the adjacent nodes of the current node with <code class="inlineCode">adjacent_nodes = graph[current_node]</code>. The <code class="inlineCode">if</code> statement is used to find out whether all the adjacent nodes of <code class="inlineCode">current_node</code> have been visited.</p>
    <p class="normal">When the <code class="inlineCode">while</code> loop is<a id="_idIndexMarker284"/> executed for the first time, <code class="inlineCode">current_node</code> will contain<a id="_idIndexMarker285"/> node <strong class="keyWord">A</strong> and <code class="inlineCode">adjacent_nodes</code> will contain nodes <strong class="keyWord">B</strong>, <strong class="keyWord">D</strong>, and <strong class="keyWord">E</strong>. Furthermore, <code class="inlineCode">visited_nodes</code> will be empty. If all nodes have been visited, we only move on to the statements further down the program, otherwise, we begin a whole new step.</p>
    <p class="normal">The <code class="inlineCode">set(adjacent_nodes).difference(set(visited_nodes))</code> statement returns the nodes that have not been visited. The loop iterates over this list of unvisited nodes:</p>
    <pre class="programlisting code"><code class="hljs-code">    distance_from_starting_node = get_shortest_distance(table, vertex) 
</code></pre>
    <p class="normal">The <code class="inlineCode">get_shortest_distance(table, vertex)</code> helper method will return the value stored in the shortest distance column of our table, using one of the unvisited nodes referenced by <code class="inlineCode">vertex</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> distance_from_starting_node == INFINITY <span class="hljs-keyword">and</span> current_node == starting_node: 
         total_distance = get_distance(graph, vertex, current_node) 
</code></pre>
    <p class="normal">When we are examining the adjacent nodes of the starting node, <code class="inlineCode">distance_from_starting_node == INFINITY and current_node == starting_node</code> will evaluate to <code class="inlineCode">True</code>, in which case we only have to find the distance between the starting node and vertex by referencing the graph:</p>
    <pre class="programlisting code"><code class="hljs-code">    total_distance = get_distance(graph, vertex, current_node)
</code></pre>
    <p class="normal">The <code class="inlineCode">get_distance</code> method is another helper method we use to obtain the value (distance) of the edge between <code class="inlineCode">vertex</code> and <code class="inlineCode">current_node</code>. If the condition fails, then we assign to <code class="inlineCode">total_distance</code> the sum of the distance from the starting node to <code class="inlineCode">current_node</code> and the distance between <code class="inlineCode">current_node</code> and <code class="inlineCode">vertex</code>.</p>
    <p class="normal">Once we have our total distance, we need to check whether <code class="inlineCode">total_distance</code> is less than the existing data in the shortest distance column of our table. If it is less, then we use the two helper methods to update that row:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> total_distance &lt; distance_from_starting_node: 
        set_shortest_distance(table, vertex, total_distance)
        set_previous_node(table, vertex, current_node)
</code></pre>
    <p class="normal">At this point, we add <code class="inlineCode">current_node</code> to the list of visited nodes:</p>
    <pre class="programlisting code"><code class="hljs-code">    visited_nodes.append(current_node) 
</code></pre>
    <p class="normal">If all nodes have been visited, then we must exit the <code class="inlineCode">while</code> loop. To check whether this is the case, we compare the length of the <code class="inlineCode">visited_nodes</code> list with the number of keys in our table. If they have become equal, we simply exit the <code class="inlineCode">while</code> loop.</p>
    <p class="normal">The <code class="inlineCode">get_next_node</code> helper<a id="_idIndexMarker286"/> method is used to fetch the next node to visit. It is this <a id="_idIndexMarker287"/>method that helps us find the minimum value in the shortest distance column from the starting nodes using our table. The whole method ends by returning the updated table. To print the table, we use the following statements:</p>
    <pre class="programlisting code"><code class="hljs-code">shortest_distance_table = find_shortest_path(graph, table, <span class="hljs-string">'A'</span>) 
<span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(shortest_distance_table): 
     <span class="hljs-built_in">print</span>(<span class="hljs-string">"{} - {}"</span>.<span class="hljs-built_in">format</span>(k,shortest_distance_table[k])) 
</code></pre>
    <p class="normal">This is the output for the preceding code snippet:</p>
    <pre class="programlisting con"><code class="hljs-con">A - [0, None]
B - [5, 'A']
C - [7, 'B']
D - [7, 'F']
E - [2, 'A']
F - [5, 'E']
</code></pre>
    <p class="normal">The running time complexity of Dijkstra’s algorithm depends on how the vertices are stored and retrieved. Generally, the min-priority queue is used to store the vertices of the graph, thus, the time complexity of Dijkstra’s algorithm depends on how the min-priority queue is implemented.</p>
    <p class="normal">In the first case, the vertices are stored numbered from 1 to |<em class="italic">V</em>| in an array. Here, each operation for searching a vertex from the entire array will take O(V) time, making the total time complexity O(V2 V<sup class="superscript">2</sup> + E) = O(V<sup class="superscript">2</sup>). Furthermore, if the min-priority queue is implemented using the Fibonacci heap, the time taken for each iteration of the loop and extracting the minimum node will take O(|<em class="italic">V</em>|) time. Further, iterating over all the vertices’ adjacent nodes and updating the shortest distance takes O(|<em class="italic">E</em>|) time, and each priority value<a id="_idIndexMarker288"/> update takes O(log|<em class="italic">V</em>|) time, which makes O(|<em class="italic">E</em>| + log|<em class="italic">V</em>|). Thus, the <a id="_idIndexMarker289"/>total running time complexity of the algorithm becomes O(|<em class="italic">E</em>| + |<em class="italic">V</em>|<em class="italic">log</em> |<em class="italic">V</em>|), where |<em class="italic">V</em>| is the number of vertices and |<em class="italic">E</em>| is the number of edges.</p>
    <h1 id="_idParaDest-74" class="heading-1">Summary</h1>
    <p class="normal">Algorithm design techniques are very important in order to formulate, understand, and develop an optimal solution to a complex problem. In this chapter, we have discussed algorithm design techniques, which are very important in the field of computer science. Important categories of algorithm design, such as dynamic programming, greedy approach, and divide and conquer, we discussed in detail along with implementations of important algorithms.</p>
    <p class="normal">The dynamic programming and divide-and-conquer techniques are quite similar in the sense that both solve a bigger problem by combining the solutions of the sub-problems. Here, the divide-and-conquer technique partitions the problem into disjointed sub-problems, solving them recursively, and then combines the solutions of the sub-problems to obtain the solution of the original problem, whereas, in dynamic programming, this technique is employed when sub-problems overlap, and recomputation of the same sub-problem is avoided. Furthermore, in the greedy approach-based algorithm design technique, at each step in the algorithm, the best choice is taken that looks likely to attain the solution.</p>
    <p class="normal">In the next chapter, we will be discussing important data structures such as <code class="inlineCode">Linked</code> <code class="inlineCode">Lists</code> and <code class="inlineCode">Pointer</code> <code class="inlineCode">Structures</code>.</p>
    <h1 id="_idParaDest-75" class="heading-1">Exercises</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Which of the following options will be correct when a top-down approach of dynamic programming will be applied to solve a given problem related to the space and time complexity?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">It will increase both time and space complexity.  </li>
          <li class="alphabeticList">It will increase the time complexity, and decrease the space complexity  </li>
          <li class="alphabeticList">It will increase the space complexity, and decrease the time complexity  </li>
          <li class="alphabeticList">It will decrease both time and space complexities.</li>
        </ol>
      </li>
      <li class="numberedList">Dijkstra’s single shortest path algorithm is applied on edge weighted directed graph shown in Figure 3.17. What will be the order of the nodes for the shortest path distance path (Assume A as source) ? </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B17217_03_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 3.17: An edge-weighted directed graph</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Consider the weights and values of the items listed in <em class="italic">Table 3.8</em>. Note that there is only one unit of each item.
    <table id="table008-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Item</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Weight</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Value</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">10</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">B</p>
          </td>
          <td class="table-cell">
            <p class="normal">10</p>
          </td>
          <td class="table-cell">
            <p class="normal">8</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">C</p>
          </td>
          <td class="table-cell">
            <p class="normal">4</p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">D</p>
          </td>
          <td class="table-cell">
            <p class="normal">7</p>
          </td>
          <td class="table-cell">
            <p class="normal">6</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 3.8: The weights and values of different items</p>

      <p class="normal">We need to maximize the value; the maximum weight should be 11 kg. No item may be split. Establish the values of the items using a greedy approach.</p>
</li>
    </ol>

    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4"><span class="url">https://packt.link/MEvK4</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>