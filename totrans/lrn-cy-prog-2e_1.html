<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Cython Won't Bite</h1></div></div></div><p>Cython<a id="id0" class="indexterm"/> is much more than a programming language. Its origin can be traced to <a id="id1" class="indexterm"/>SAGE, the mathematics software package, where it is used to increase the performance of mathematical computations such as those involving matrices. More generally, I tend to consider Cython as an alternative to SWIG<a id="id2" class="indexterm"/> to generate really good Python bindings to native code.</p><p>Language bindings have been around for years, and SWIG was one of the first and best tools to generate bindings for multitudes of languages. Cython generates bindings for Python code only, and this single purpose approach means it generates the best Python bindings you can get outside of doing it all manually, which should be attempted only if you're a Python core developer.</p><p>For me, taking control of legacy software by generating language bindings is a great way to reuse any software package. Consider a legacy application written in C/C++. Adding advanced modern features such as a web server for a dashboard or message bus is not a trivial thing to do. More importantly, Python comes with thousands of packages that have been developed, tested, and used by people for a long time that can do exactly that. Wouldn't it be great to take advantage of all of this code? With Cython, we can do exactly this, and I will demonstrate approaches with plenty of example codes along the way.</p><p>This first chapter will be dedicated to the core concepts on using Cython, including compilation, and should provide a solid reference and introduction for all the Cython core concepts.</p><p>In this first chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing Cython</li><li class="listitem" style="list-style-type: disc">Getting started - Hello World</li><li class="listitem" style="list-style-type: disc">Using distutils with Cython</li><li class="listitem" style="list-style-type: disc">Calling C functions from Python</li><li class="listitem" style="list-style-type: disc">Type conversion</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Installing Cython</h1></div></div></div><p>Since <a id="id3" class="indexterm"/>Cython is a programming language, we must install its respective compiler, which <a id="id4" class="indexterm"/>just so happens to be the aptly named <em>Cython</em>.</p><p>There are many different ways to install Cython. The preferred one would be to use <code class="literal">pip</code>:</p><div><pre class="programlisting">$ pip install Cython</pre></div><p>This should work on both Linux and Mac. Alternatively, you can use your Linux distribution's package manager to install Cython:</p><div><pre class="programlisting">$ yum install cython     # will work on Fedora and Centos
$ apt-get install cython # will work on Debian based systems.</pre></div><p>For Windows, although there are a <a id="id5" class="indexterm"/>plethora of options available, following this wiki is the safest option to stay up-to-date: <a class="ulink" href="http://wiki.cython.org/InstallingOnWindows">http://wiki.cython.org/InstallingOnWindows</a>.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Emacs mode</h2></div></div></div><p>There is an <strong>emacs</strong> mode <a id="id6" class="indexterm"/>available for Cython. Although the syntax is nearly the same as Python, there are differences that conflict in simply using Python-mode. You can grab <code class="literal">cython-mode.el</code> from the Cython source code (inside the <code class="literal">Tools</code> directory.) The preferred way of installing packages to emacs would be to use a package repository like <code class="literal">MELPA</code>:</p><p>To add the package repository to emacs, open your <code class="literal">~/.emacs</code> configuration file and add:</p><div><pre class="programlisting">(when (&gt;= emacs-major-version 24)
  (require 'package)
  (add-to-list
   'package-archives
   '("melpa" . "http://melpa.org/packages/")
   t)
  (package-initialize))</pre></div><p>Once you add this and reload your configuration to install the Cython mode, you can simply run:</p><div><pre class="programlisting">'M-x package-install RET cython-mode'</pre></div><p>Once this is installed, you can activate the mode by adding this into your emacs config file:</p><div><pre class="programlisting">(require 'cython-mode)</pre></div><p>You can activate the mode manually at any time with:</p><div><pre class="programlisting">'M-x cython-mode RET'</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Getting the code examples</h2></div></div></div><p>Throughout this book, I intend to show real examples that are easy to digest in order to help you get a feel of the different things you can achieve with Cython. To access and download the code used, please clone this repository:</p><div><pre class="programlisting">$ git clone git://github.com/redbrain/cython-book.git</pre></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Getting started – Hello World</h1></div></div></div><p>As you will see when running the <a id="id7" class="indexterm"/><strong>Hello World </strong>program, Cython generates native Python modules. Therefore, running any Cython code, you will reference it via a module import in Python. Let's build the module:</p><div><pre class="programlisting">$ cd cython-book/chapter1/helloworld
$ make</pre></div><p>You should now have created <code class="literal">helloworld.so</code>! This is a Cython module of the same name as the Cython source code file. While in the same directory of the shared object module, you can invoke this code by running a respective Python import:</p><div><pre class="programlisting">$ python
Python 2.7.3 (default, Aug  1 2012, 05:16:07)
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import helloworld
Hello World from cython!</pre></div><p>As you can see by opening <code class="literal">helloworld.pyx</code>, it looks just like a normal Python Hello World application, but as previously stated, Cython generates modules. These modules need a name so that they can be correctly imported by the Python runtime. The Cython compiler simply uses the name of the source code file. It then requires us to compile this to the same shared object name.</p><p>Overall, Cython source code files have the <code class="literal">.pyx</code>,<code class="literal">.pxd</code>, and <code class="literal">.pxi</code> extensions. For now, all we care about are the <code class="literal">.pyx</code> files; the others are for <strong>cimports</strong><a id="id8" class="indexterm"/> and <strong>includes</strong><a id="id9" class="indexterm"/> respectively within a <code class="literal">.pyx</code> module file.</p><p>The following screenshot depicts the compilation flow required to have a callable native Python module:</p><div><img src="img/B04685_01_01.jpg" alt="Getting started – Hello World"/></div><p>I wrote a<a id="id10" class="indexterm"/> basic <code class="literal">makefile</code> so that you can simply run <code class="literal">make</code> to compile these examples. Here's the code to do this manually:</p><div><pre class="programlisting">$ cython helloworld.pyx
$ gcc/clang -g -O2 -fpic `python-config --cflags` -c helloworld.c -o helloworld.o
$ gcc/clang -shared -o helloworld.so helloworld.o `python-config –libs`</pre></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Using distutils with Cython</h2></div></div></div><p>You <a id="id11" class="indexterm"/>can also <a id="id12" class="indexterm"/>compile this HelloWorld example module using Python <code class="literal">distutils</code> and <code class="literal">cythonize</code>. Open the <code class="literal">setup.py</code> along side the Makefile and you can see the alternate way to compile Cython modules:</p><div><pre class="programlisting">from distutils.core import setup
from Cython.Build import cythonize

setup(
    ext_modules = cythonize("helloworld.pyx")
)</pre></div><p>Using the <code class="literal">cythonize</code> function as part of the <code class="literal">ext_modules</code> section will build any specified Cython source into an installable Python module. This will compile <code class="literal">helloworld.pyx</code> into the same shared library. This provides the Python practice to distribute native modules as part of <code class="literal">distutils</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Calling C functions from Python</h2></div></div></div><p>We should be <a id="id13" class="indexterm"/>careful for clarity when talking about Python and<a id="id14" class="indexterm"/> Cython since the syntax is so similar. Let's wrap a simple <code class="literal">AddFunction</code> in C and make it callable from Python.</p><p>First, open a file called <code class="literal">AddFunction.c</code>, and write a simple function in it:</p><div><pre class="programlisting">#include &lt;stdio.h&gt;

int AddFunction(int a, int b) {
    printf("look we are within your c code!\n");
    return a + b;
}</pre></div><p>This is the C code that we will call—just a simple function to add two integers. Now, let's get Python to call it. Open a file called <code class="literal">AddFunction.h</code>, wherein we will declare our prototype:</p><div><pre class="programlisting">#ifndef __ADDFUNCTION_H__
#define __ADDFUNCTION_H__

extern int AddFunction (int, int);

#endif //__ADDFUNCTION_H__</pre></div><p>We need this so that Cython can see the prototype for the function we want to call. In practice, you will already have your headers in your own project with your prototypes and declarations already available.</p><p>Open a file called <code class="literal">AddFunction.pyx</code>, and insert the following code in it:</p><div><pre class="programlisting">cdef extern from "AddFunction.h":
    cdef int AddFunction(int, int)</pre></div><p>Here, we have to declare which code we want to call. The <code class="literal">cdef</code> is a keyword signifying that this is from the C code that will be linked in. Now, we need a Python entry point:</p><div><pre class="programlisting">def Add(a, b):
     return AddFunction(a, b)</pre></div><p>This <code class="literal">Add</code> function is a Python callable inside a <code class="literal">PyAddFunction</code> module this acts as a wrapper for Python code to be able to call directly into the C code. Again, I have provided a handy <code class="literal">makefile</code> to produce the module:</p><div><pre class="programlisting">$ cd cython-book/chapter1/ownmodule
$ make
cython -2 PyAddFunction.pyx
gcc -g -O2 -fpic -c PyAddFunction.c -o PyAddFunction.o `python-config --includes`
gcc -g -O2 -fpic -c AddFunction.c -o AddFunction.o
gcc -g -O2 -shared -o PyAddFunction.so AddFunction.o PyAddFunction.o `python-config --libs`</pre></div><p>Notice that <code class="literal">AddFunction.c</code> is compiled into the same <code class="literal">PyAddFunction.so</code> shared object. Now, let's call this <code class="literal">AddFunction</code> and check to see if C can add numbers correctly:</p><div><pre class="programlisting">$ python
&gt;&gt;&gt; from PyAddFunction import Add
&gt;&gt;&gt; Add(1,2)
look we are within your c code!!
3</pre></div><p>Notice that the print statement inside the <code class="literal">AddFunction</code> and the final result are printed correctly. Therefore, we know that the control hit the C code and did the calculation in C, and not inside the Python runtime. This is a revelation of what is possible. Python can be cited to be slow in some circumstances. Using this technique makes it possible for Python code to bypass its own runtime and<a id="id15" class="indexterm"/> to run in an unsafe context, which is unrestricted by the Python runtime <a id="id16" class="indexterm"/>which is much faster.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Type conversion in Cython</h2></div></div></div><p>Notice that we had to<a id="id17" class="indexterm"/> declare a <a id="id18" class="indexterm"/>prototype inside the Cython source code <code class="literal">PyAddFunction.pyx</code>:</p><div><pre class="programlisting">cdef extern from "AddFunction.h":
    cdef int AddFunction(int, int)</pre></div><p>It lets the compiler know that there is a function called <code class="literal">AddFunction</code> and it takes two ints and returns an int. This is all the information the compiler needs to know beside the host and target operating system's calling convention to call this function safely. Then, we created the Python entry point, which is a Python callable that takes two parameters:</p><div><pre class="programlisting">def Add(a, b):
     return AddFunction(a, b)</pre></div><p>Inside this entry point, it simply returned the native <code class="literal">AddFunction</code> and passed the two Python objects as parameters. This is what makes Cython so powerful. Here, the Cython compiler must inspect the function call and generate code to safely try and convert these Python objects to native C integers. This becomes difficult when precision is taken into account as well as potential overflow, which just so happens to be a major use case since it handles everything so well. Also, remember that this function returns an integer, and Cython also generates code to convert the integer return into a valid Python object.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p><strong>Downloading the example code</strong></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.PacktPub.com">http://www.PacktPub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.PacktPub.com/support">http://www.PacktPub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Summary</h1></div></div></div><p>Overall, we installed the Cython compiler, ran the Hello World example, and took into consideration that we need to compile all code into native shared objects. We also saw how to wrap native C code to make it callable from Python. We have also seen the implicit type conversion which Cython does for us to make calling C work. In the next chapter, we will delve deeper into Cython programming with discussion on how to make Python code callable from C and manipulate native C data structures from Cython.</p></div></div>
</body></html>