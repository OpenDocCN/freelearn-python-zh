- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Creating an IoT Joystick
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建物联网游戏手柄
- en: In this chapter, we will create an IoT joystick for remotely controlling a ROS
    TurtleSim robot. We will build upon our experience from [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107)’s
    IoT button project as well as [*Chapter 11*](B21282_11.xhtml#_idTextAnchor173)’s
    introduction to the TurtleSim virtual robot.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个用于远程控制ROS TurtleSim机器人的物联网游戏手柄。我们将基于第7章的物联网按钮项目以及第11章对TurtleSim虚拟机器人的介绍来构建我们的经验。
- en: Utilizing the Raspberry Pi Pico WH’s Wi-Fi capabilities, we will demonstrate
    the practical application of IoT in robotics. The chapter outlines the design
    and construction of a USB-powered joystick, integrating components such as a PS2
    joystick module, an LED, and an arcade button. We will use this IoT joystick to
    control our A.R.E.S. robot in the coming chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Raspberry Pi Pico WH的Wi-Fi功能，我们将展示物联网在机器人领域的实际应用。本章概述了设计并构建一个USB供电的游戏手柄，集成了PS2游戏手柄模块、LED和街机按钮等组件。我们将使用这个物联网游戏手柄在接下来的章节中控制我们的A.R.E.S.机器人。
- en: We will use a Raspberry Pi Pico WH for this chapter, although a Raspberry Pi
    Pico W would work just as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Raspberry Pi Pico W也可以，但我们将使用Raspberry Pi Pico WH本章。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding our IoT joystick application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解我们的物联网游戏手柄应用
- en: Wiring up our circuit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接我们的电路
- en: Developing the code for our IoT joystick
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发我们的物联网游戏手柄代码
- en: Creating a custom ROS node for our application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用创建一个定制的ROS节点
- en: Constructing the IoT joystick case
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建物联网游戏手柄外壳
- en: Let’s begin!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you will require the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你需要以下内容：
- en: Intermediate knowledge of Python programming
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中级Python编程知识
- en: Basic knowledge of the Linux command line.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的Linux命令行知识。
- en: A CloudAMQP account for the MQTT server instance
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于MQTT服务器实例的CloudAMQP账户
- en: Ubuntu-ROS installed computer from the previous chapter
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上一章安装的Ubuntu-ROS计算机
- en: Access to a 3D printer or 3D printing service
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以访问3D打印机或3D打印服务
- en: Raspberry Pi Pico WH
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico WH
- en: Raspberry Pi Pico WH GPIO expander
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico WH GPIO扩展器
- en: PS2 joystick module
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PS2游戏手柄模块
- en: LED with 220 Ohm resistor
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有220欧姆电阻的LED
- en: 24 mm arcade-style pushbutton
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 24毫米街机式按钮
- en: 4 x M3 10 mm bolts
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4个M3 10毫米螺栓
- en: 4 x M2 5 mm screws
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4个M2 5毫米螺丝
- en: 8 x M2.5 5 mm bolts
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8个M2.5 5毫米螺栓
- en: 4 x M2.5 10 mm standoffs
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4个M2.5 10毫米支撑螺母
- en: 1 x 8 mm LED holder
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个8毫米LED支架
- en: Wires to connect Raspberry Pi Pico WH to GPIO expander
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接Raspberry Pi Pico WH到GPIO扩展器的电线
- en: Build files for custom cases may be found in our GitHub repository
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制外壳的构建文件可以在我们的GitHub仓库中找到
- en: 'The code for this chapter may be found here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下链接找到：
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter12%0D)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter12%0D)'
- en: Understanding our IoT joystick application
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解我们的物联网游戏手柄应用
- en: In [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107), we developed a device to
    remotely arm an IoT alarm system. Building on this experience, our application
    in this chapter involves creating an IoT joystick using a Raspberry Pi Pico WH.
    This joystick will remotely control a ROS TurtleSim robot and thus display a practical
    application of IoT in robotics.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B21282_07.xhtml#_idTextAnchor107)中，我们开发了一个远程启动物联网报警系统的设备。基于这一经验，本章的应用涉及使用Raspberry
    Pi Pico WH创建一个物联网游戏手柄。这个游戏手柄将远程控制ROS TurtleSim机器人，从而展示物联网在机器人领域的实际应用。
- en: 'We will use the Raspberry Pi Pico WH for our design given Wi-Fi capability
    and pre-soldered pin headers. In our application, we’ll integrate a PS2 joystick
    module, an LED, and an arcade-style pushbutton with a Raspberry Pi Pico WH. The
    Raspberry Pi Pico WH will be programmed to transmit MQTT messages that reflect
    the joystick’s movements, the status of the joystick button, and the arcade button’s
    state. Additionally, the LED will serve a dual-purpose role, indicating both the
    Wi-Fi connectivity status and the MQTT connection status sequentially:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Wi-Fi功能和预先焊接的引脚头，我们将使用Raspberry Pi Pico WH进行设计。在我们的应用中，我们将集成PS2游戏手柄模块、LED和街机式按钮与Raspberry
    Pi Pico WH。Raspberry Pi Pico WH将被编程以传输反映游戏手柄动作、游戏手柄按钮状态和街机按钮状态的MQTT消息。此外，LED将具有双重功能，依次指示Wi-Fi连接状态和MQTT连接状态：
- en: '![Figure 12.1 – Overview of the IoT joystick application](img/B21282_12_1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 物联网游戏手柄应用概述](img/B21282_12_1.jpg)'
- en: Figure 12.1 – Overview of the IoT joystick application
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 物联网游戏手柄应用概述
- en: As we see in *Figure 12**.1*, our Raspberry Pi Pico WH transmits the state of
    the *x* axis, *y* axis, and two buttons as an MQTT message under the `JoystickPosition`
    topic to our `robot_control` custom ROS node. Our ROS node then in turn transmits
    `vel_msg` messages to an instance of a TurtleSim robot.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 *图 12**.1* 中所见，我们的 Raspberry Pi Pico WH 将 *x* 轴、*y* 轴和两个按钮的状态作为 MQTT 消息，在
    `JoystickPosition` 主题下发送到我们的自定义 ROS 节点 `robot_control`。然后，我们的 ROS 节点反过来将 `vel_msg`
    消息发送到 TurtleSim 机器人的一个实例。
- en: We will start by wiring up the circuit for our IoT joystick.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先连接我们的物联网游戏手柄的电路。
- en: Wiring up our circuit
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接电路
- en: 'To simplify wiring, we’re using a GPIO expander along with our Raspberry Pi
    Pico WH. The case that we will build later allows for easy transfer of the test
    circuit wiring, highlighting the practicality of using a GPIO expander. We can
    see the components that make up the IoT joystick in the following figure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化布线，我们正在使用 GPIO 扩展器以及我们的 Raspberry Pi Pico WH。我们稍后将要构建的机箱允许轻松转移测试电路的布线，突出了使用
    GPIO 扩展器的实用性。我们可以在以下图中看到组成物联网游戏手柄的组件：
- en: '![Figure 12.2 – Components of the IoT joystick](img/B21282_12_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 物联网游戏手柄的组件](img/B21282_12_2.jpg)'
- en: Figure 12.2 – Components of the IoT joystick
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 物联网游戏手柄的组件
- en: In *Figure 12**.2*, the components we are using include a 24 mm arcade-style
    button, a green LED (any color will do) soldered to a 220 Ohm resistor (refer
    to [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048) for directions on this), and
    a PS2 joystick module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 12**.2* 中，我们使用的组件包括一个 24 毫米的街机风格按钮，一个绿色 LED（任何颜色都可以）焊接到一个 220 欧姆电阻上（有关此处的说明，请参阅
    [*第 3 章*](B21282_03.xhtml#_idTextAnchor048)），以及一个 PS2 游戏手柄模块。
- en: 'This setup makes it easier to transfer our components to a custom case for
    final installation. Using these components, we wire up our circuit using *Figure
    12**.3* as a reference:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置使得将我们的组件转移到定制机箱以进行最终安装变得更加容易。使用这些组件，我们根据 *图 12**.3* 作为参考连接电路：
- en: '![Figure 12.3 – Wiring up the IoT joystick](img/B21282_12_3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 连接物联网游戏手柄](img/B21282_12_3.jpg)'
- en: Figure 12.3 – Wiring up the IoT joystick
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 连接物联网游戏手柄
- en: 'The connections are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 连接如下：
- en: The arcade-style button connects to GP0 and GND.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 街机风格按钮连接到 GP0 和 GND。
- en: The positive end of the LED with a 220 Ohm resistor connects to GP5.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 220 欧姆电阻的 LED 正端连接到 GP5。
- en: The negative end of the LED connects to GND.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 的负端连接到 GND。
- en: SW (switch) from the PS2 joystick module connects to GP22.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SW（开关）从 PS2 游戏手柄模块连接到 GP22。
- en: VRY (*y* axis) from the PS2 joystick module connects to GP26.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VRY (*y* 轴) 从 PS2 游戏手柄模块连接到 GP26。
- en: VRX (*x* axis) from the PS2 joystick module connects to GP27.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VRX (*x* 轴) 从 PS2 游戏手柄模块连接到 GP27。
- en: +5V (power) from the PS2 joystick module connects to 3V3.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +5V（电源）从 PS2 游戏手柄模块连接到 3V3。
- en: GND from the PS2 joystick module connects to GND.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PS2 游戏手柄模块的 GND 连接到 GND。
- en: With our circuit wired up, we are ready to start coding our application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在电路布线完成后，我们就可以开始编写我们的应用程序了。
- en: Developing the code for our IoT joystick
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的物联网游戏手柄的代码
- en: We will install CircuitPython on our Raspberry Pi Pico WH and use Thonny for
    development. Our Pico WH code will consist of two files, one to encapsulate the
    joystick functionalities and the other to transmit MQTT messages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Raspberry Pi Pico WH 上安装 CircuitPython 并使用 Thonny 进行开发。我们的 Pico WH 代码将包括两个文件，一个用于封装游戏手柄功能，另一个用于发送
    MQTT 消息。
- en: We will start by setting up our Raspberry Pi Pico WH for development.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置我们的 Raspberry Pi Pico WH 以进行开发。
- en: Setting up our Raspberry Pi Pico WH
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的 Raspberry Pi Pico WH
- en: For our IoT joystick, we will install CircuitPython and use the Adafruit MiniMQTT
    library. We could just as easily use MicroPython and the `micropython-umqtt.simple`
    package. However, using CircuitPython for the Raspberry Pi Pico WH in our IoT
    joystick application offers more stable and well-maintained libraries compared
    to MicroPython.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的物联网游戏手柄，我们将安装 CircuitPython 并使用 Adafruit MiniMQTT 库。我们同样可以使用 MicroPython
    和 `micropython-umqtt.simple` 包。然而，在物联网游戏手柄应用中使用 CircuitPython 的 Raspberry Pi Pico
    WH 提供了比 MicroPython 更稳定、维护得更好的库。
- en: 'To install CircuitPython on our Raspberry Pi Pico WH, we do the following same
    steps as we did in [*Chapter 9*](B21282_09.xhtml#_idTextAnchor140):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Raspberry Pi Pico WH 上安装 CircuitPython，我们执行以下与我们在 [*第 9 章*](B21282_09.xhtml#_idTextAnchor140)
    中所做的相同步骤：
- en: If Thonny is not available on our operating system, we visit the Thonny website
    and download an appropriate version ([https://thonny.org](https://thonny.org)).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的操作系统上没有 Thonny，我们访问 Thonny 网站，下载适当的版本 ([https://thonny.org](https://thonny.org))。
- en: We then launch Thonny using the appropriate method for our operating system.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用适合我们操作系统的适当方法启动 Thonny。
- en: While holding the *BOOTSEL* button on the Pico WH (the small white button near
    the USB port), we insert it into an available USB port and disregard any pop-up
    windows that may appear.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住 Pico WH 上的 *BOOTSEL* 按钮（USB 端口附近的小白按钮）的同时，我们将它插入一个可用的 USB 端口，并忽略可能出现的任何弹出窗口。
- en: 'We then click on the interpreter information at the bottom right-hand side
    of the screen and select **Install CircuitPython…**:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们点击屏幕右下角的解释器信息，并选择 **安装 CircuitPython…**：
- en: '![Figure 12.4 – Install CircuitPython… option](img/B21282_12_4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 安装 CircuitPython… 选项](img/B21282_12_4.jpg)'
- en: Figure 12.4 – Install CircuitPython… option
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 安装 CircuitPython… 选项
- en: 'For our target volume, we select our Pico WH (**RPI-RP2 (D:)** in our example).
    We then select the latest version of the CircuitPython variant – **Raspberry Pi
    • Pico W /** **Pico WH**:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的目标版本，我们选择我们的 Pico WH（在我们的示例中为 **RPI-RP2 (D:)**）。然后我们选择 CircuitPython 变种的最新版本
    – **Raspberry Pi • Pico W /** **Pico WH**：
- en: '![Figure 12.5 – Installing CircuitPython on the Raspberry Pi Pico WH](img/B21282_12_5.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 在 Raspberry Pi Pico WH 上安装 CircuitPython](img/B21282_12_5.jpg)'
- en: Figure 12.5 – Installing CircuitPython on the Raspberry Pi Pico WH
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 在 Raspberry Pi Pico WH 上安装 CircuitPython
- en: We click on the **Install** button and then the **Close** button once the installation
    has completed.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，我们点击 **安装** 按钮，然后点击 **关闭** 按钮。
- en: 'To have Thonny configured to run the CircuitPython interpreter on our Pico,
    we select it from the bottom right-hand side of the screen:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 Thonny 配置为在我们的 Pico 上运行 CircuitPython 解释器，我们从屏幕右下角选择它：
- en: '![Figure 12.6 – Selecting the CircuitPython interpreter from our Pico WH](img/B21282_12_6.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 从我们的 Pico WH 选择 CircuitPython 解释器](img/B21282_12_6.jpg)'
- en: Figure 12.6 – Selecting the CircuitPython interpreter from our Pico WH
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 从我们的 Pico WH 选择 CircuitPython 解释器
- en: With CircuitPython installed on our Raspberry Pi Pico WH, the next step is to
    install the Adafruit MiniMQTT library. To do so, we follow the steps outlined
    in [*Chapter 10*](B21282_10.xhtml#_idTextAnchor157), in the *Installing the CircuitPython
    library for* *MQTT* section.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 Raspberry Pi Pico WH 上安装好 CircuitPython 后，下一步是安装 Adafruit MiniMQTT 库。为此，我们遵循
    [*第 10 章*](B21282_10.xhtml#_idTextAnchor157) 中 *安装 CircuitPython 库的* *MQTT* 部分中概述的步骤。
- en: With our Raspberry Pi Pico WH ready for development, it’s time to create a `Joystick`
    class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 Raspberry Pi Pico WH 准备好开发时，是时候创建一个 `Joystick` 类了。
- en: Creating a Joystick class
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 Joystick 类
- en: As mentioned, our Pico WH code is broken down into two files, one to encapsulate
    the joystick in a class we call `Joystick` and the other to send MQTT messages
    based on the values of this class. We start with the joystick code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的 Pico WH 代码分为两个文件，一个用于将摇杆封装在我们称为 `Joystick` 的类中，另一个基于该类的值发送 MQTT 消息。我们首先从摇杆代码开始。
- en: 'To write the joystick code, we do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写摇杆代码，我们执行以下操作：
- en: We connect our Raspberry Pi Pico WH to a USB port and launch Thonny. We may
    use our Raspberry Pi or another operating system for this.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 Raspberry Pi Pico WH 连接到 USB 端口并启动 Thonny。我们可以使用 Raspberry Pi 或其他操作系统来完成此操作。
- en: We then activate the CircuitPython environment on our Pico WH by selecting it
    from the bottom right-hand side of the screen.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后通过从屏幕的右下角选择它来激活 Pico WH 上的 CircuitPython 环境。
- en: 'In a new editor, we start our code with the imports:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的编辑器中，我们开始编写代码，使用导入语句：
- en: '[PRE0]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our code, we have the following:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: '`import board`: Accesses the board-specific pins and hardware interfaces, crucial
    for interfacing with the GPIO pins on the Raspberry Pi Pico W.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import board`：访问特定于板的引脚和硬件接口，这对于与 Raspberry Pi Pico W 上的 GPIO 引脚进行接口至关重要。'
- en: '`import digitalio`: Manages digital input and output, such as reading the state
    of buttons or controlling LEDs, essential for digital signal interactions.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import digitalio`：管理数字输入和输出，例如读取按钮的状态或控制 LED，这对于数字信号交互至关重要。'
- en: '`import analogio`: Facilitates analog input functionalities, such as reading
    sensor data that vary over a range, a common requirement in projects involving
    variable inputs such as potentiometers.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import analogio`：促进模拟输入功能，例如读取在一定范围内变化的传感器数据，这在涉及如电位计等可变输入的项目中是常见的要求。'
- en: '`import time`: Provides time-related functions, enabling tasks such as introducing
    delays in the program execution, which is useful in controlling the flow and timing
    of operations.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import time`：提供时间相关函数，使任务如引入程序执行延迟成为可能，这在控制操作流程和时机方面很有用。'
- en: 'We then define a `Joystick` class and set the variables:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着定义一个`Joystick`类并设置变量：
- en: '[PRE1]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In our code, we have the following:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: 'Initialization (`__init__()` method): Our code sets up the `Joystick` class.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化（`__init__()`方法）：我们的代码设置了`Joystick`类。
- en: '`self.adc_x` and `self.adc_y`: These are analog input objects for the *x* and
    *y* axes of the joystick, connected to the GP27 and GP26 pins, respectively. They
    read the analog values from the joystick’s potentiometers.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.adc_x`和`self.adc_y`：这些是摇杆*x*和*y*轴的模拟输入对象，分别连接到GP27和GP26引脚。它们从摇杆的电位计读取模拟值。'
- en: '`self.button`: A digital input/output object for a button, connected to the
    GP0 pin. It’s configured as an input with a pull-up resistor, which is a common
    setup for buttons. This variable represents the state of our arcade-style button.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.button`：一个按钮的数字输入/输出对象，连接到GP0引脚。它配置为输入并带有上拉电阻，这是按钮的常见设置。此变量代表我们的街机风格按钮的状态。'
- en: '`self.button2`: Similar to `self.button`. This represents a second button connected
    to the GP22 pin, also set as an input with a pull-up resistor. This variable represents
    the state of the joystick button (activated by pushing down on the joystick).'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.button2`：类似于`self.button`。这代表一个连接到GP22引脚的第二个按钮，也设置为输入并带有上拉电阻。此变量代表摇杆按钮的状态（通过按下摇杆激活）。'
- en: '`self.mid`: The midpoint value for the analog readings, used to determine the
    neutral position of the joystick.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.mid`：模拟读数的中间值，用于确定摇杆的中性位置。'
- en: '`self.dead_zone`: The dead zone threshold determines the joystick’s sensitivity,
    distinguishing slight, unintentional movements from deliberate ones. This accounts
    for minor variances when the joystick is in its neutral position.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.dead_zone`：死区阈值决定了摇杆的灵敏度，区分轻微的无意动作和有意动作。这解释了当摇杆处于中性位置时的微小差异。'
- en: 'With our variables set, we write our first method, which we call `get_binary_value()`.
    This function is designed to interpret the joystick’s position as a binary output.
    It first checks if the joystick’s current position, represented by `value`, is
    within a predefined dead zone around the midpoint (`self.mid`). If so, it returns
    `0`, indicating the joystick is in a neutral position. If the joystick’s position
    is outside this dead zone, the function returns `-1` for positions below the midpoint
    (negative direction) and `1` for positions above it (positive direction):'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好我们的变量后，我们编写了第一个方法，我们称之为`get_binary_value()`。此函数旨在将摇杆的位置解释为二进制输出。它首先检查摇杆的当前位置，由`value`表示，是否在围绕中点的预定义死区（`self.mid`）内。如果是这样，它返回`0`，表示摇杆处于中性位置。如果摇杆的位置超出此死区，则函数返回`-1`（对于低于中点的位置，表示负方向）和`1`（对于高于中点的位置，表示正方向）：
- en: '[PRE2]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then define our second method, `read()`. This method consolidates the joystick’s
    and buttons’ statuses into a single output. It computes binary values for the
    *x* and *y* axes of the joystick using the `get_binary_value()` method, translating
    analog readings into binary (`-1`, `0`, or `1`) based on position. It also assesses
    the states of two buttons, converting their digital values into a Boolean format
    (pressed or not pressed). The method then returns a tuple containing these binary
    values and button states:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着定义我们的第二个方法，`read()`。此方法将摇杆和按钮的状态合并为一个单一输出。它使用`get_binary_value()`方法计算摇杆的*x*和*y*轴的二进制值，根据位置将模拟读数转换为二进制（`-1`、`0`或`1`）。它还评估两个按钮的状态，将它们的数字值转换为布尔格式（按下或未按下）。然后，该方法返回一个包含这些二进制值和按钮状态的元组：
- en: '[PRE3]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then write our test code. We use this code to test our `Joystick` class.
    It initializes an instance of the `Joystick` class and enters an infinite loop
    to continuously test the functionality of the joystick. In each iteration of the
    loop, it reads the current positions of the joystick’s *x* and *y* axes and the
    states of the two buttons using the `read()` method. These values are then printed
    to the console, displaying the joystick’s *x* and *y* positions along with the
    press status of each button. The `if __name__ == "__main__":` block ensures that
    this main loop runs only if the script is executed as the main program, not when
    imported as a module, allowing us to easily test our `Joystick` class:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后编写测试代码。我们使用此代码来测试我们的`Joystick`类。它初始化`Joystick`类的一个实例，并进入一个无限循环以连续测试摇杆的功能。在循环的每次迭代中，它使用`read()`方法读取摇杆的*x*和*y*轴的当前位置以及两个按钮的状态。然后，这些值被打印到控制台，显示摇杆的*x*和*y*位置以及每个按钮的按下状态。`if
    __name__ == "__main__":`块确保只有当脚本作为主程序执行时，这个主循环才会运行，而不是当作为模块导入时，这使得我们能够轻松地测试我们的`Joystick`类：
- en: '[PRE4]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To save the file, we click on `joystick.py` to our Raspberry Pi Pico WH.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们点击`joystick.py`到我们的Raspberry Pi Pico WH。
- en: To run our code, we click on the green **Run** button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top, and then **Run** **current script**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色的**运行**按钮，在键盘上按*F5*，或者点击顶部的**运行**菜单选项，然后选择**运行****当前脚本**。
- en: 'In the shell, we should observe the joystick values change as we move the joystick
    and press the buttons:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell中，我们应该观察到摇杆值随着摇杆的移动和按钮的按下而改变：
- en: '![Figure 12.7 – Joystick and button state](img/B21282_12_7.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 摇杆和按钮状态](img/B21282_12_7.jpg)'
- en: Figure 12.7 – Joystick and button state
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 摇杆和按钮状态
- en: With our `Joystick` class and `joystick.py` file written and successfully tested,
    we are now ready to write the code to send out the joystick status via MQTT messaging.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Joystick`类和`joystick.py`文件编写并成功测试后，我们现在可以编写代码以通过MQTT消息发送摇杆状态。
- en: Sending MQTT messages from our IoT joystick
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从我们的物联网摇杆发送MQTT消息
- en: With the `Joystick` class created and tested, it is time to write the code to
    send the joystick and button status in an MQTT message.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建并测试了`Joystick`类之后，现在是时候编写代码以通过MQTT消息发送摇杆和按钮状态了。
- en: 'To write the joystick code, we do the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写摇杆代码，我们执行以下操作：
- en: We connect our Raspberry Pi Pico WH to a USB port and launch Thonny. We may
    use our Raspberry Pi or another operating system for this.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将Raspberry Pi Pico WH连接到USB端口并启动Thonny。我们可以使用Raspberry Pi或其他操作系统来完成此操作。
- en: We then activate the CircuitPython environment on our Pico WH by selecting it
    from the bottom right-hand side of the screen (see *Figure 12**.6*).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后通过从屏幕的右下角选择它来激活Pico WH上的CircuitPython环境（参见*图12.6**）。
- en: 'In a new editor, we start our code with the imports:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的编辑器中，我们以导入开始我们的代码：
- en: '[PRE5]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our code, we have the following:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: '`import time`: Incorporates time-related functions, useful for delays and timing
    control in the code.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import time`: 包含时间相关函数，在代码中用于延迟和定时控制。'
- en: '`import board`: Provides access to the hardware-specific details of the Raspberry
    Pi Pico WH, particularly its GPIO pins.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import board`: 提供了对Raspberry Pi Pico WH硬件特定细节的访问，特别是其GPIO引脚。'
- en: '`import wifi`: Enables Wi-Fi functionality, crucial for network connectivity
    in IoT applications.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import wifi`: 启用Wi-Fi功能，对于物联网应用中的网络连接至关重要。'
- en: '`import socketpool`: Manages network sockets, used for network communications,
    such as MQTT messaging.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import socketpool`: 管理网络套接字，用于网络通信，如MQTT消息传递。'
- en: '`import digitalio`: Allows for digital input and output control, useful for
    managing LEDs, buttons, and other digital components.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import digitalio`: 允许进行数字输入和输出控制，这对于管理LED、按钮和其他数字组件很有用。'
- en: '`from adafruit_minimqtt.adafruit_minimqtt import MQTT`: Imports the Adafruit
    MiniMQTT library, which is used for handling MQTT protocol communication, a standard
    for IoT messaging.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from adafruit_minimqtt.adafruit_minimqtt import MQTT`: 导入Adafruit MiniMQTT库，用于处理MQTT协议通信，这是物联网消息的标准。'
- en: '`from joystick import Joystick`: Imports our custom `Joystick` class for handling
    the logic for interfacing with our joystick module.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from joystick import Joystick`: 导入我们的自定义`Joystick`类，用于处理与我们的摇杆模块的接口逻辑。'
- en: 'We then set our variable declarations:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后设置变量声明：
- en: '[PRE6]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our code, we have the following:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: '`WIFI_SSID` and `WIFI_PASSWORD`: These variables store the credentials for
    the Wi-Fi network, essential for connecting the Raspberry Pi Pico WH to the internet.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WIFI_SSID` 和 `WIFI_PASSWORD`: 这些变量存储Wi-Fi网络的凭据，对于将Raspberry Pi Pico WH连接到互联网至关重要。'
- en: '`MQTT_SERVER`, `MQTT_PORT`, `USERNAME`, `PASSWORD`: These settings are for
    configuring the MQTT client. They specify the server address, port number, and
    authentication credentials needed to connect to our CloudAMQP server.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MQTT_SERVER`、`MQTT_PORT`、`USERNAME`、`PASSWORD`: 这些设置用于配置MQTT客户端。它们指定了连接到我们的CloudAMQP服务器所需的服务器地址、端口号和认证凭据。'
- en: '`MQTT_TOPIC`: Defines the MQTT topic under which the messages will be published.
    In this case, it’s set to `JoystickPosition`, indicating that messages related
    to the joystick’s position will be sent to this topic.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MQTT_TOPIC`: 定义了消息将要发布的MQTT主题。在这种情况下，它设置为 `JoystickPosition`，表示与摇杆位置相关的消息将被发送到这个主题。'
- en: '`led = digitalio.DigitalInOut(board.GP5)`: Initializes a digital output on
    pin GP5 of the Raspberry Pi Pico W for our LED.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`led = digitalio.DigitalInOut(board.GP5)`: 在Raspberry Pi Pico W的GP5引脚上初始化一个数字输出，用于我们的LED。'
- en: '`led.direction = digitalio.Direction.OUTPUT`: Sets the direction of the pin
    to output, allowing our program to control the LED (for example, turning it on
    or off).'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`led.direction = digitalio.Direction.OUTPUT`: 将引脚方向设置为输出，允许我们的程序控制LED（例如，打开或关闭）。'
- en: 'We use the `flash_led()` method to turn on and off our LED to use it as a status
    indicator. Our method takes in times and duration values to allow for custom flashing
    of the LED based on a particular program state:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `flash_led()` 方法打开和关闭我们的LED，将其用作状态指示器。我们的方法接受时间和持续时间值，以便根据特定的程序状态自定义LED的闪烁：
- en: '[PRE7]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `connect_to_wifi()` method is used to connect our Raspberry Pi Pico WH
    to our Wi-Fi router and the internet. This function continuously attempts to connect
    to Wi-Fi, using the `WIFI_SSID` and `WIFI_PASSWORD` credentials. On failure, it
    prints an error message, flashes an LED, and retries after a 3-second pause:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect_to_wifi()` 方法用于将我们的Raspberry Pi Pico WH连接到我们的Wi-Fi路由器和互联网。此函数持续尝试连接到Wi-Fi，使用
    `WIFI_SSID` 和 `WIFI_PASSWORD` 凭据。在失败的情况下，它将打印错误消息，闪烁LED，并在3秒暂停后重试：'
- en: '[PRE8]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `connect_to_mqtt()` function attempts to establish a connection to the
    MQTT server in a loop. If the connection is successful, it prints a confirmation
    message and exits the loop. In case of a connection failure, it reports the failure,
    activates a half-second LED flash as an error indicator, and then waits for 3
    seconds before retrying:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect_to_mqtt()` 函数尝试在循环中建立与MQTT服务器的连接。如果连接成功，它将打印确认消息并退出循环。在连接失败的情况下，它将报告失败，激活半秒的LED闪烁作为错误指示，然后等待3秒后重试：'
- en: '[PRE9]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our code then calls `connect_to_wifi()` to establish a Wi-Fi connection. Next,
    a socket pool is created from `wifi.radio` to manage network communication. An
    MQTT client is then instantiated with the specified server, port, and user credentials
    and connected to the MQTT broker using `connect_to_mqtt(mqtt_client)`. After establishing
    an MQTT connection, the LED is set to a steady on state (`led.value = True`) as
    an indicator of successful setup. Finally, an instance of the `Joystick` class
    is created, readying it for capturing user inputs:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们的代码调用 `connect_to_wifi()` 来建立Wi-Fi连接。接下来，从 `wifi.radio` 创建一个套接字池来管理网络通信。然后，使用指定的服务器、端口和用户凭据实例化一个MQTT客户端，并通过
    `connect_to_mqtt(mqtt_client)` 连接到MQTT代理。在建立MQTT连接后，将LED设置为持续开启状态（`led.value =
    True`），作为设置成功的指示。最后，创建一个 `Joystick` 类的实例，准备捕获用户输入：
- en: '[PRE10]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `send_mqtt_message()` function in the code is responsible for formatting
    and sending joystick data over MQTT. It accepts the joystick’s *x* and *y* axes’
    values and the states of two buttons. The states of the buttons are converted
    to `True` or `False` based on whether they are pressed. The function then constructs
    a message string that includes the *x* and *y* positions and the states of both
    buttons. This message is published to the MQTT topic defined by `MQTT_TOPIC`,
    allowing the joystick’s status to be transmitted via the MQTT protocol:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码中的 `send_mqtt_message()` 函数负责格式化和发送摇杆数据通过MQTT。它接受摇杆的*x*和*y*轴的值以及两个按钮的状态。按钮的状态根据它们是否被按下转换为`True`或`False`。然后，该函数构建一个包含*x*和*y*位置以及两个按钮状态的消息字符串。该消息被发布到由
    `MQTT_TOPIC` 定义的MQTT主题，允许通过MQTT协议传输摇杆的状态：
- en: '[PRE11]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `main()` function in the code represents the primary loop for reading joystick
    inputs and sending corresponding MQTT messages. Within an infinite loop, it continually
    calls the `joystick.read()` method to get the current positions of the joystick’s
    *x* and *y* axes and the states of two buttons. It then passes these values to
    the `send_mqtt_message()` function to format and transmit them as MQTT messages.
    A 1-second delay (`time.sleep(1)`) is included at the end of each loop iteration
    to manage the frequency of MQTT transmissions. The `if __name__ == "__main__":`
    block ensures that this main loop runs only if the script is executed as the main
    program, not when imported as a module:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码中的 `main()` 函数代表读取摇杆输入并发送相应 MQTT 消息的主要循环。在无限循环中，它不断调用 `joystick.read()` 方法以获取摇杆的
    *x* 和 *y* 轴的当前位置以及两个按钮的状态。然后，它将这些值传递给 `send_mqtt_message()` 函数以格式化和传输它们作为 MQTT
    消息。每个循环迭代结束时包含一个 1 秒延迟 (`time.sleep(1)`)，以管理 MQTT 传输的频率。`if __name__ == "__main__":`
    块确保只有当脚本作为主程序执行时，此主循环才会运行，而不是当作为模块导入时：
- en: '[PRE12]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To save the file, we click on `code.py` to our Raspberry Pi Pico WH.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们点击 `code.py` 到我们的 Raspberry Pi Pico WH。
- en: To run our code, we click on the green **Run** button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top, and then **Run** **current script**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色的 **运行** 按钮，在键盘上按 *F5*，或者点击顶部的 **运行** 菜单选项，然后点击 **运行** **当前脚本**。
- en: To test our code, we connect the MQTT-Explorer app to our CloudAMQP server and
    observe the messages received.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的代码，我们将 MQTT-Explorer 应用程序连接到我们的 CloudAMQP 服务器，并观察接收到的消息。
- en: 'We should observe outputs as three distinct values: `1`, `0`, and `-1`, indicating
    their neutral, positive, and negative positions respectively. Additionally, we
    should see the state of two buttons (`True` or `False`): `Button 1` corresponds
    to the arcade-style button, and `Button 2` indicates the joystick’s click action.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到三个不同的输出值：`1`、`0` 和 `-1`，分别表示它们的中间、正和负位置。此外，我们还应该看到两个按钮的状态（`True` 或 `False`）：`Button
    1` 对应于街机风格的按钮，而 `Button 2` 表示摇杆的点击动作。
- en: With the code completed for our IoT joystick, it is time to create our custom
    `robot_control` ROS node so that we may control the TurtleSim robot.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的物联网摇杆代码完成后，是时候创建我们的自定义 `robot_control` ROS 节点，以便我们可以控制 TurtleSim 机器人。
- en: Creating a custom ROS node for our application
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建一个自定义的 ROS 节点
- en: In [*Chapter 11*](B21282_11.xhtml#_idTextAnchor173)’s *Creating an ROS workspace
    and package* section, we outlined how to set up a `circle` node for TurtleSim
    robot control. Following this blueprint, we’ll now create a `robot_control` node
    on the ROS-equipped Ubuntu system from [*Chapter 11*](B21282_11.xhtml#_idTextAnchor173).
    This involves setting up a new ROS workspace and package for the `robot_control`
    node, enabling us to control the TurtleSim robot using our new IoT joystick.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 11 章*](B21282_11.xhtml#_idTextAnchor173) 的 *创建 ROS 工作空间和包* 部分，我们概述了如何设置用于
    TurtleSim 机器人控制的 `circle` 节点。遵循此蓝图，我们现在将在 [*第 11 章*](B21282_11.xhtml#_idTextAnchor173)
    中提到的 ROS 配备的 Ubuntu 系统上创建一个 `robot_control` 节点。这包括为 `robot_control` 节点设置一个新的 ROS
    工作空间和包，使我们能够使用新的物联网摇杆控制 TurtleSim 机器人。
- en: To ensure clarity and avoid any potential mix-up with the existing `circle`
    node, we’ll create a new workspace and package for the `robot_control` node, despite
    the possibility of reusing those from [*Chapter 11*](B21282_11.xhtml#_idTextAnchor173).
    This approach allows us to maintain distinct environments for each project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保清晰并避免与现有的 `circle` 节点发生任何潜在的混淆，尽管有可能重用 [*第 11 章*](B21282_11.xhtml#_idTextAnchor173)
    中的那些，我们将为 `robot_control` 节点创建一个新的工作空间和包。这种方法使我们能够为每个项目维护独立的环境。
- en: Creating our custom robot_control node
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的自定义 `robot_control` 节点
- en: As we have already installed the `paho-mqtt` Python library onto our Ubuntu
    installation, we will not need to install it again.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在 Ubuntu 安装上安装了 `paho-mqtt` Python 库，因此我们不需要再次安装它。
- en: 'To create our new node, we do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的新节点，我们执行以下操作：
- en: 'We open an Ubuntu Terminal and execute the following command in our home directory:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 Ubuntu 终端中打开并执行以下命令，在主目录下：
- en: '[PRE13]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: cd ch12_ws/src
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cd ch12_ws/src
- en: '[PRE14]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To initialize the ROS environment, we execute the following command:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要初始化 ROS 环境，我们执行以下命令：
- en: '[PRE15]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then create our package by executing the following command:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过执行以下命令创建我们的包：
- en: '[PRE16]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'robot_control.py file in a text editor, we execute the following command:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 `robot_control.py` 文件，我们执行以下命令：
- en: '[PRE17]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We start by deleting all the code. We then start our new code with imports:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先删除所有代码。然后，我们用导入语句开始我们的新代码：
- en: '[PRE19]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our code, we have the following:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: '`import rclpy`: Imports the ROS 2 client library for Python, allowing the script
    to interact with ROS 2 functionalities and create ROS 2 nodes'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import rclpy`: 导入 ROS 2 的 Python 客户端库，允许脚本与 ROS 2 功能交互并创建 ROS 2 节点'
- en: '`from rclpy.node import Node`: Imports the `Node` class from the `rclpy` module,
    enabling the script to define custom nodes for ROS 2 applications'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from rclpy.node import Node`: 从 `rclpy` 模块导入 `Node` 类，使脚本能够为 ROS 2 应用程序定义自定义节点'
- en: '`from geometry_msgs.msg import Twist`: Imports the `Twist` message type from
    the `geometry_msgs` package; we use this for sending commands to move the TurtleSim
    robot'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from geometry_msgs.msg import Twist`: 从 `geometry_msgs` 包导入 `Twist` 消息类型；我们使用它来发送移动
    TurtleSim 机器人的命令'
- en: '`import paho.mqtt.client as mqtt`: Imports the Paho MQTT client library we
    will use for MQTT protocol communication'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import paho.mqtt.client as mqtt`: 导入我们将用于 MQTT 协议通信的 Paho MQTT 客户端库'
- en: 'In our code, we create an `MQTTMessage` class. This class effectively parses
    and updates its properties based on the content of an MQTT message, which contains
    joystick position data and button states:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们创建了一个 `MQTTMessage` 类。此类根据 MQTT 消息的内容有效地解析和更新其属性，该消息包含摇杆位置数据和按钮状态：
- en: '[PRE20]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our code, we have the following:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: '`class MQTTMessage`: Defines a class for handling MQTT messages.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class MQTTMessage`: 定义用于处理 MQTT 消息的类。'
- en: '`__init__()` method:'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()` 方法：'
- en: Initializes `x` and `y` to `0`, representing default positions.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `x` 和 `y` 初始化为 `0`，代表默认位置。
- en: Sets `button1` and `button2` to `False`, indicating their default unpressed
    state.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `button1` 和 `button2` 设置为 `False`，表示它们的默认未按下状态。
- en: '`update_values()` method:'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_values()` 方法：'
- en: Takes a `message` string as input and splits it into parts based on commas.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `message` 字符串作为输入，并根据逗号将其分割成部分。
- en: Parses the `message` to extract and convert `X` and `Y` values to floats.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析 `message` 以提取并将 `X` 和 `Y` 值转换为浮点数。
- en: Determines the states of `button1` and `button2` by splitting the string parts
    and comparing them with `"True"`. The `strip()` method is used to remove any leading/trailing
    whitespace.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过分割字符串部分并将它们与 `"True"` 进行比较来确定 `button1` 和 `button2` 的状态。使用 `strip()` 方法来删除任何前导/尾随空格。
- en: 'The `RobotController` class is a subclass of the `Node` class:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RobotController` 类是 `Node` 类的子类：'
- en: '[PRE21]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In our code, we have the following:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: We define `RobotController` as a subclass of `Node`
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `RobotController` 定义为 `Node` 的子类
- en: '`__init__()` method:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()` 方法：'
- en: Initializes the node with the name `robot_controller`
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用名称 `robot_controller` 初始化节点
- en: Stores `mqtt_message` passed as a parameter
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储作为参数传递的 `mqtt_message`
- en: Creates a publisher for ROS `Twist` messages on the `turtle1/cmd_vel` topic
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `turtle1/cmd_vel` 主题上创建 ROS `Twist` 消息的发布者
- en: Sets a timer for a periodic callback function with a 0.1-second interval
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个周期性回调函数的定时器，间隔为 0.1 秒
- en: Initializes `self.vel_msg` as a `Twist` object for velocity commands
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `self.vel_msg` 初始化为用于速度命令的 `Twist` 对象
- en: 'MQTT client configuration:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MQTT 客户端配置：
- en: Creates a new MQTT client
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 MQTT 客户端
- en: Sets up connection and message callbacks (`on_connect()` and `on_message()`
    methods)
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置连接和消息回调（`on_connect()` 和 `on_message()` 方法）
- en: Configures the client with a username and password for MQTT
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置客户端以 MQTT 的用户名和密码
- en: 'Establishes a connection to the MQTT server at `driver.cloudmqtt.com` on port
    `18756` (verify port number in the `on_connect()` method is used to handle MQTT
    client connections. Upon successfully connecting (indicated by `rc` being `0`),
    it prints a confirmation message and subscribes the client to the `JoystickPosition`
    topic, enabling the client to receive related messages. If the connection fails,
    it displays an error message with the specific `rc` code to help diagnose the
    issue. The method’s parameters follow the Paho MQTT library’s conventions:'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立与 `driver.cloudmqtt.com` 上端口 `18756` 的 MQTT 服务器连接（在 `on_connect()` 方法中验证端口号用于处理
    MQTT 客户端连接。在成功连接（由 `rc` 为 `0` 表示）后，它打印一条确认消息并将客户端订阅到 `JoystickPosition` 主题，使客户端能够接收相关消息。如果连接失败，它将显示一个包含特定
    `rc` 代码的错误消息，以帮助诊断问题。该方法参数遵循 Paho MQTT 库的约定：
- en: '[PRE22]'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `on_message()` method is used to handle incoming MQTT messages. Upon receiving
    a message, it decodes the message payload from bytes to a string and then updates
    the MQTT `message` object with the new values using the `update_values()` method:'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_message()` 方法用于处理传入的 MQTT 消息。在接收到消息后，它将消息有效载荷从字节解码为字符串，然后使用 `update_values()`
    方法更新 MQTT `message` 对象的新值：'
- en: '[PRE23]'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `timer_callback()` method is the final method in the `RobotController`
    class. It adjusts the robot’s movement based on the state of two buttons. If `button1`
    is pressed, it sets the robot to draw a circle in the counterclockwise direction.
    Pressing `button2` does the opposite, making the robot move in the clockwise direction.
    If neither button is pressed, the robot’s linear and angular velocities are set
    based on the joystick’s `Y` and `X` positions, respectively. After setting the
    velocities, the updated `vel_msg()` function is published to control the robot’s
    movement:'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timer_callback()`方法是`RobotController`类中的最后一个方法。它根据两个按钮的状态调整机器人的移动。如果按下`button1`，则将机器人设置为逆时针画圆。按下`button2`则相反，使机器人沿顺时针方向移动。如果两个按钮都没有按下，则根据摇杆的`Y`和`X`位置分别设置机器人的线性和角速度。设置速度后，更新的`vel_msg()`函数被发布以控制机器人的移动：'
- en: '[PRE24]'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `main()` function is executed outside any class and serves as the entry
    point for running a ROS 2 node integrated with MQTT for robot control. It begins
    with initializing the ROS client library, then creates an instance of the `MQTTMessage`
    and `RobotController` classes, passing the MQTT message object to the latter.
    The application enters a ROS event loop to process callbacks, including MQTT messages,
    ensuring the robot responds to joystick commands. Upon exit, it shuts down by
    destroying the ROS node and terminating the ROS client library:'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()` 函数在任意类外部执行，作为运行集成MQTT的ROS 2节点的入口点。它首先初始化ROS客户端库，然后创建`MQTTMessage`和`RobotController`类的实例，并将MQTT消息对象传递给后者。应用程序进入ROS事件循环以处理回调，包括MQTT消息，确保机器人对摇杆命令做出响应。退出时，通过销毁ROS节点和终止ROS客户端库来关闭：'
- en: '[PRE25]'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With our code completed, we save the file using the same name, `robot_control.py`.
    Our next step is to update the `package.xml` file to include Python library dependencies
    for our code (refer to [*Chapter 11*](B21282_11.xhtml#_idTextAnchor173) for more
    information on ROS packages). To do so, we open an Ubuntu Terminal and navigate
    to the folder containing the `package.xml` file:'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码完成后，我们使用相同的名称`robot_control.py`保存文件。我们的下一步是更新`package.xml`文件，以包含我们的代码的Python库依赖项（有关ROS包的更多信息，请参阅[*第11章*](B21282_11.xhtml#_idTextAnchor173)）。为此，我们打开一个Ubuntu终端并导航到包含`package.xml`文件的文件夹：
- en: '[PRE26]'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '</package>):'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '</package>):'
- en: '[PRE27]'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We save our changes and close the editor.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们保存我们的更改并关闭编辑器。
- en: With updates to `robot_control.py` and `package.xml`, we are now ready to compile
    our code and run our new node.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新`robot_control.py`和`package.xml`，我们现在可以编译我们的代码并运行我们的新节点。
- en: Controlling a ROS TurtleSim robot using our IoT joystick
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们的物联网摇杆控制ROS TurtleSim机器人
- en: 'Before we can run our new node, we must compile it. As we did in [*Chapter
    11*](B21282_11.xhtml#_idTextAnchor173), we compile our code using the `colcon`
    ROS tool. To compile and execute our new code, we do the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以运行我们的新节点之前，我们必须编译它。正如我们在[*第11章*](B21282_11.xhtml#_idTextAnchor173)中所做的那样，我们使用`colcon`
    ROS工具编译我们的代码。为了编译和执行我们的新代码，我们执行以下操作：
- en: 'In Ubuntu, we open a new Terminal and source our ROS 2 environment:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ubuntu中，我们打开一个新的终端并源码我们的ROS 2环境：
- en: '[PRE29]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then navigate to the root of our workspace:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们导航到工作区的根目录：
- en: '[PRE30]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To compile our code, we execute the following command:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译我们的代码，我们执行以下命令：
- en: '[PRE31]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Upon completion, a message confirming a successful build will appear in the
    terminal.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，终端将显示一条确认成功构建的消息。
- en: 'With our code compiled, it is time to source our new ROS environment. We do
    this with the following command:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码编译完成后，现在是时候源码我们的新ROS环境了。我们使用以下命令执行此操作：
- en: '[PRE32]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is similar to how we source the ROS environment. To run our node, we execute
    the following command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这与我们的ROS环境源码方式类似。要运行我们的节点，我们执行以下命令：
- en: '[PRE33]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Figure 12.8 – Running the robot_control node](img/B21282_12_8.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – 运行robot_control节点](img/B21282_12_8.jpg)'
- en: Figure 12.8 – Running the robot_control node
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 运行robot_control节点
- en: 'In a separate Ubuntu Terminal, we launch an instance of the TurtleSim robot
    with the following commands:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个Ubuntu终端中，我们使用以下命令启动TurtleSim机器人的实例：
- en: '[PRE34]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We should observe that we can navigate the TurtleSim robot with our IoT joystick.
    Pressing and holding the main arcade-style button will make the robot draw a circle
    in the counterclockwise direction, while clicking and holding the joystick control
    down should make the robot draw a circle in the clockwise direction:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到我们可以使用我们的物联网摇杆导航TurtleSim机器人。按下并保持主街机式按钮将使机器人逆时针画圆，而点击并保持摇杆控制下应该使机器人顺时针画圆：
- en: '![Figure 12.9 – Results of pressing the arcade-style button on the IoT joystick
    followed by pressing the joystick control button](img/B21282_12_9.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 按压物联网摇杆上的街机风格按钮后，再按摇杆控制按钮的结果](img/B21282_12_9.jpg)'
- en: Figure 12.9 – Results of pressing the arcade-style button on the IoT joystick
    followed by pressing the joystick control button
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 按压物联网摇杆上的街机风格按钮后，再按摇杆控制按钮的结果
- en: With this, we have successfully managed the remote control of a virtual robot
    using our IoT joystick, demonstrating the system’s global reach. This application
    demonstrates the vast potential for IoT and robotics integration.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们成功管理了使用我们的物联网摇杆对虚拟机器人的远程控制，展示了系统的全球覆盖范围。这个应用展示了物联网和机器人集成的大量潜力。
- en: For our final step, we’ll encase the IoT joystick’s components in a custom-designed
    housing. This enhances usability by making the device easier to manage and operate.
    Additionally, the custom case offers protection for the electronics and gives
    our application a professional finish.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们将物联网摇杆的组件封装在一个定制设计的外壳中。这通过使设备更容易管理和操作来提高可用性。此外，定制外壳为电子设备提供保护，并使我们的应用具有专业的外观。
- en: Constructing the IoT joystick case
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建物联网摇杆外壳
- en: As mentioned, our custom case gives our IoT joystick a professional look and
    gives us something to place in our hands. We assemble the custom case using 3D-printed
    parts and some common components.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的定制外壳使我们的物联网摇杆看起来更专业，并给我们提供了一个可以握在手中的东西。我们使用3D打印部件和一些常用组件来组装定制外壳。
- en: 'The `.stl` files for the 3D-printed parts of our case may be found under the
    `Build Files` section of this chapter’s GitHub repository. We may see the parts
    that make up the case in the following figure:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们案例的3D打印部件的`.stl`文件可以在本章GitHub仓库的`Build Files`部分找到。我们可以在以下图中看到组成外壳的部件：
- en: '![](img/B21282_12_10.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21282_12_10.jpg)'
- en: Figure 12.10 – Parts that make up the IoT joystick case
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – 组成物联网摇杆外壳的部件
- en: 'The parts that make up the IoT joystick case from *Figure 12**.10* are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 组成物联网摇杆外壳的部件，如*图12.10*所示，如下：
- en: '*A*: Backplate. 3D printed from the `.``stl` file.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*: 后盖板。从`.stl`文件中3D打印而成。'
- en: '*B*: Front shell. 3D printed from the `.stl` file (the part in the figure has
    been painted).'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*B*: 前壳。从`.stl`文件中3D打印而成（图中的部件已被上色）。'
- en: '*C*: 4 x M2.5 10 mm stand-offs.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*: 4个M2.5 10毫米支撑件。'
- en: '*D*: 8 mm LED holder.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*: 8毫米LED支架。'
- en: '*E*: Thumbstick for PS2 joystick stick module. 3D printed from the `.``stl`
    file.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*: PS2摇杆模块的摇杆。从`.stl`文件中3D打印而成。'
- en: '*F*: Drilling guide for PS2 joystick module. 3D printed from the `.stl` file.
    We use a drilling guide as there are discrepancies in the position of mounting
    holes for various versions of the PS2 joystick module. The version we are using
    in our example has mounting holes that are 20.5 mm apart on the *y* axis and 26
    mm apart on the *x* axis.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F*: PS2摇杆模块的钻孔引导。从`.stl`文件中3D打印而成。我们使用钻孔引导，因为不同版本的PS2摇杆模块的安装孔位置存在差异。我们示例中使用的版本在*y*轴上安装孔间距为20.5毫米，在*x*轴上为26毫米。'
- en: '*G*: 1 x M2 8 mm screw (not shown).'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*G*: 1个M2 8毫米螺丝（未显示）。'
- en: '*H*: 4 x M2 5 mm screws (not shown).'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*H*: 4个M2 5毫米螺丝（未显示）。'
- en: '*I*: 8 x M2.5 5 mm bolts (not shown).'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*I*: 8个M2.5 5毫米螺栓（未显示）。'
- en: '*J*: 4 x M3 10 mm bolts (not shown).'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*J*: 4个M3 10毫米螺栓（未显示）。'
- en: 'To construct the IoT joystick case, we begin by securing the thumbstick (*E*
    from *Figure 12**.10*) to the PS2 joystick (as shown in *Figure 12**.11*). We
    are replacing the thumbstick that comes with the PS2 joystick with our own to
    allow for more range. We can see the construction of the IoT joystick in the following
    figure:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 构建物联网摇杆外壳时，我们首先将摇杆（*图12.10*中的*E*）固定到PS2摇杆上（如*图12.11*所示）。我们用我们自己的摇杆替换PS2摇杆附带的摇杆，以便有更大的范围。我们可以在以下图中看到物联网摇杆的构建过程：
- en: '![](img/B21282_12_11.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21282_12_11.jpg)'
- en: Figure 12.11 – Preparing our custom case for the PS2 joystick
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 为PS2摇杆准备我们的定制外壳
- en: 'To prepare our case for the PS2 joystick, we do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备我们的PS2摇杆外壳，我们执行以下操作：
- en: Secure the M2 8 mm screw to the thumbstick such that a portion of it extends
    through the thumbstick (*Step 1* from *Figure 12**.11*).
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将M2 8毫米螺丝固定到摇杆上，使其部分穿过摇杆（*图12.11*中的*步骤1*）。
- en: Fasten the thumbstick to the stem of the PS2 joystick by screwing it in by hand
    (*Step 2* from *Figure 12**.11*).
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过手动拧紧螺丝将摇杆固定到PS2摇杆的茎部（*图12.11*中的*步骤2*）。
- en: Attach the four M2.5 10 mm standoffs to the PS2 joystick using four M2.5 5 mm
    bolts (*Step 3* from *Figure 12**.11*).
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用四个 M2.5 5 毫米螺栓将四个 M2.5 10 毫米支撑件固定到 PS2 摇杆上（图 12**.11* 中的 *步骤 3*）。
- en: Line up the drilling guide to the joystick hole of the front shell matching
    the orientation shown in *Step 4* of *Figure 12**.11*. The PS2 joystick will be
    installed such that the pins will extend out to the right.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将钻孔引导器对准前壳的摇杆孔，使其与图 12**.11** 中 *步骤 4* 所示的方向一致。PS2 摇杆将被安装，使得引脚向右延伸。
- en: Using an appropriately sized drill bit, drill four holes into the front shell
    (*Step 5* from *Figure 12**.11*).
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当尺寸的钻头，在前壳上钻四个孔（图 12**.11** 中的 *步骤 5*）。
- en: 'With the thumbstick installed and the holes drilled, it is now time to construct
    the case. To do so, we follow the steps in the following figure:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在摇杆安装并钻孔后，现在是时候构建外壳了。为此，我们遵循以下图中的步骤：
- en: '![Figure 12.12 – Constructing the IoT joystick case](img/B21282_12_12.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – 构建 IoT 摇杆外壳](img/B21282_12_12.jpg)'
- en: Figure 12.12 – Constructing the IoT joystick case
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 构建 IoT 摇杆外壳
- en: 'Using *Figure 12**.12* as a reference, we construct the IoT joystick case as
    follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以图 12**.12* 为参考，我们按照以下步骤构建物联网摇杆外壳：
- en: We start by securing the Raspberry Pi Pico WH to the back plate using four M2
    5 mm screws, positioning the USB port downward for easy access. This setup ensures
    the Pico’s *Reset* button is accessible through a designated hole in the back
    plate. Opting for a Pico WH provides easy integration with our GPIO expander from
    the test circuit. While a Raspberry Pi Pico W can also be used, it requires soldering
    to install, making the Pico WH a more convenient choice for this application (*Step
    1* from *Figure 12**.12*).
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用四个 M2 5 毫米螺丝将 Raspberry Pi Pico WH 固定在背板上，将 USB 端口向下定位以便于访问。这种设置确保 Pico
    的 *复位* 按钮可以通过背板上的指定孔访问。选择 Pico WH 可以方便地与测试电路中的 GPIO 扩展器集成。虽然 Raspberry Pi Pico
    W 也可以使用，但需要焊接来安装，这使得 Pico WH 对于这个应用来说更加方便（图 12**.12* 中的 *步骤 1*）。
- en: We then secure the PS2 joystick to the front shell using four M2.5 5 mm bolts.
    We must ensure that we install the P2 joystick such that the pins are pointing
    to the right of the case (*Step 2* from *Figure 12**.12*).
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用四个 M2.5 5 毫米螺栓将 PS2 摇杆固定在前壳上。我们必须确保安装 P2 摇杆，使得引脚指向外壳的右侧（图 12**.12* 中的
    *步骤 2*）。
- en: Using the LED holder, we attach the LED with the resistor to the front shell.
    We secure the arcade-style button to the front shell, as well as using the appropriate
    hole (*Step 3* from *Figure 12**.12*).
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 LED 座，我们将带有电阻的 LED 连接到前壳。我们使用适当的孔将街机风格的按钮固定在前壳上（图 12**.12* 中的 *步骤 3*）。
- en: We secure the backplate to the front shell using four M3 10 mm bolts (*Step
    4* from *Figure 12**.12*).
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用四个 M3 10 毫米螺栓将背板固定在前壳上（图 12**.12* 中的 *步骤 4*）。
- en: To power the IoT joystick, we attach a micro-USB cord to the USB port of the
    Raspberry Pi Pico WH.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给物联网摇杆供电，我们将一根微型 USB 线缆连接到 Raspberry Pi Pico WH 的 USB 端口。
- en: We may now plug in our IoT joystick and use it to control a TurtleSim robot.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的物联网摇杆插入并使用它来控制 TurtleSim 机器人。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we assembled our IoT joystick and used it to control a TurtleSim
    virtual robot. We started with component wiring and then proceeded to write code
    for transmitting joystick movements via MQTT messages.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们组装了我们的物联网摇杆，并使用它来控制 TurtleSim 虚拟机器人。我们从组件接线开始，然后继续编写代码，通过 MQTT 消息传输摇杆动作。
- en: Our application culminated in encasing the components in a custom 3D-printed
    case, enhancing the joystick’s usability and durability. Through this application,
    we displayed the seamless integration of IoT devices with robotic systems.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组件封装在一个定制的 3D 打印外壳中，增强了摇杆的可用性和耐用性。通过这个应用，我们展示了物联网设备与机器人系统的无缝集成。
- en: In the next chapter, we will convert our virtual TurtleSim robot into a real-life
    physical robot and control it with our new IoT joystick.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们的虚拟 TurtleSim 机器人转换为现实生活中的物理机器人，并使用我们新的物联网摇杆来控制它。
