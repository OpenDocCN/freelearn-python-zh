- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an IoT Joystick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create an IoT joystick for remotely controlling a ROS
    TurtleSim robot. We will build upon our experience from [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107)’s
    IoT button project as well as [*Chapter 11*](B21282_11.xhtml#_idTextAnchor173)’s
    introduction to the TurtleSim virtual robot.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the Raspberry Pi Pico WH’s Wi-Fi capabilities, we will demonstrate
    the practical application of IoT in robotics. The chapter outlines the design
    and construction of a USB-powered joystick, integrating components such as a PS2
    joystick module, an LED, and an arcade button. We will use this IoT joystick to
    control our A.R.E.S. robot in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a Raspberry Pi Pico WH for this chapter, although a Raspberry Pi
    Pico W would work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding our IoT joystick application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring up our circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the code for our IoT joystick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom ROS node for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing the IoT joystick case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Python programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of the Linux command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CloudAMQP account for the MQTT server instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu-ROS installed computer from the previous chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 3D printer or 3D printing service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi Pico WH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi Pico WH GPIO expander
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PS2 joystick module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED with 220 Ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 24 mm arcade-style pushbutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 x M3 10 mm bolts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 x M2 5 mm screws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 x M2.5 5 mm bolts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 x M2.5 10 mm standoffs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 8 mm LED holder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wires to connect Raspberry Pi Pico WH to GPIO expander
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build files for custom cases may be found in our GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter may be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter12%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding our IoT joystick application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107), we developed a device to
    remotely arm an IoT alarm system. Building on this experience, our application
    in this chapter involves creating an IoT joystick using a Raspberry Pi Pico WH.
    This joystick will remotely control a ROS TurtleSim robot and thus display a practical
    application of IoT in robotics.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Raspberry Pi Pico WH for our design given Wi-Fi capability
    and pre-soldered pin headers. In our application, we’ll integrate a PS2 joystick
    module, an LED, and an arcade-style pushbutton with a Raspberry Pi Pico WH. The
    Raspberry Pi Pico WH will be programmed to transmit MQTT messages that reflect
    the joystick’s movements, the status of the joystick button, and the arcade button’s
    state. Additionally, the LED will serve a dual-purpose role, indicating both the
    Wi-Fi connectivity status and the MQTT connection status sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Overview of the IoT joystick application](img/B21282_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Overview of the IoT joystick application
  prefs: []
  type: TYPE_NORMAL
- en: As we see in *Figure 12**.1*, our Raspberry Pi Pico WH transmits the state of
    the *x* axis, *y* axis, and two buttons as an MQTT message under the `JoystickPosition`
    topic to our `robot_control` custom ROS node. Our ROS node then in turn transmits
    `vel_msg` messages to an instance of a TurtleSim robot.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by wiring up the circuit for our IoT joystick.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up our circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simplify wiring, we’re using a GPIO expander along with our Raspberry Pi
    Pico WH. The case that we will build later allows for easy transfer of the test
    circuit wiring, highlighting the practicality of using a GPIO expander. We can
    see the components that make up the IoT joystick in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Components of the IoT joystick](img/B21282_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Components of the IoT joystick
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 12**.2*, the components we are using include a 24 mm arcade-style
    button, a green LED (any color will do) soldered to a 220 Ohm resistor (refer
    to [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048) for directions on this), and
    a PS2 joystick module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This setup makes it easier to transfer our components to a custom case for
    final installation. Using these components, we wire up our circuit using *Figure
    12**.3* as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Wiring up the IoT joystick](img/B21282_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Wiring up the IoT joystick
  prefs: []
  type: TYPE_NORMAL
- en: 'The connections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The arcade-style button connects to GP0 and GND.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The positive end of the LED with a 220 Ohm resistor connects to GP5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The negative end of the LED connects to GND.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SW (switch) from the PS2 joystick module connects to GP22.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VRY (*y* axis) from the PS2 joystick module connects to GP26.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VRX (*x* axis) from the PS2 joystick module connects to GP27.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: +5V (power) from the PS2 joystick module connects to 3V3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND from the PS2 joystick module connects to GND.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our circuit wired up, we are ready to start coding our application.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the code for our IoT joystick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will install CircuitPython on our Raspberry Pi Pico WH and use Thonny for
    development. Our Pico WH code will consist of two files, one to encapsulate the
    joystick functionalities and the other to transmit MQTT messages.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by setting up our Raspberry Pi Pico WH for development.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Raspberry Pi Pico WH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our IoT joystick, we will install CircuitPython and use the Adafruit MiniMQTT
    library. We could just as easily use MicroPython and the `micropython-umqtt.simple`
    package. However, using CircuitPython for the Raspberry Pi Pico WH in our IoT
    joystick application offers more stable and well-maintained libraries compared
    to MicroPython.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install CircuitPython on our Raspberry Pi Pico WH, we do the following same
    steps as we did in [*Chapter 9*](B21282_09.xhtml#_idTextAnchor140):'
  prefs: []
  type: TYPE_NORMAL
- en: If Thonny is not available on our operating system, we visit the Thonny website
    and download an appropriate version ([https://thonny.org](https://thonny.org)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then launch Thonny using the appropriate method for our operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While holding the *BOOTSEL* button on the Pico WH (the small white button near
    the USB port), we insert it into an available USB port and disregard any pop-up
    windows that may appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then click on the interpreter information at the bottom right-hand side
    of the screen and select **Install CircuitPython…**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Install CircuitPython… option](img/B21282_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Install CircuitPython… option
  prefs: []
  type: TYPE_NORMAL
- en: 'For our target volume, we select our Pico WH (**RPI-RP2 (D:)** in our example).
    We then select the latest version of the CircuitPython variant – **Raspberry Pi
    • Pico W /** **Pico WH**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Installing CircuitPython on the Raspberry Pi Pico WH](img/B21282_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Installing CircuitPython on the Raspberry Pi Pico WH
  prefs: []
  type: TYPE_NORMAL
- en: We click on the **Install** button and then the **Close** button once the installation
    has completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To have Thonny configured to run the CircuitPython interpreter on our Pico,
    we select it from the bottom right-hand side of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Selecting the CircuitPython interpreter from our Pico WH](img/B21282_12_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Selecting the CircuitPython interpreter from our Pico WH
  prefs: []
  type: TYPE_NORMAL
- en: With CircuitPython installed on our Raspberry Pi Pico WH, the next step is to
    install the Adafruit MiniMQTT library. To do so, we follow the steps outlined
    in [*Chapter 10*](B21282_10.xhtml#_idTextAnchor157), in the *Installing the CircuitPython
    library for* *MQTT* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our Raspberry Pi Pico WH ready for development, it’s time to create a `Joystick`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Joystick class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, our Pico WH code is broken down into two files, one to encapsulate
    the joystick in a class we call `Joystick` and the other to send MQTT messages
    based on the values of this class. We start with the joystick code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write the joystick code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico WH to a USB port and launch Thonny. We may
    use our Raspberry Pi or another operating system for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the CircuitPython environment on our Pico WH by selecting it
    from the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new editor, we start our code with the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import board`: Accesses the board-specific pins and hardware interfaces, crucial
    for interfacing with the GPIO pins on the Raspberry Pi Pico W.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import digitalio`: Manages digital input and output, such as reading the state
    of buttons or controlling LEDs, essential for digital signal interactions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import analogio`: Facilitates analog input functionalities, such as reading
    sensor data that vary over a range, a common requirement in projects involving
    variable inputs such as potentiometers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import time`: Provides time-related functions, enabling tasks such as introducing
    delays in the program execution, which is useful in controlling the flow and timing
    of operations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then define a `Joystick` class and set the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Initialization (`__init__()` method): Our code sets up the `Joystick` class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.adc_x` and `self.adc_y`: These are analog input objects for the *x* and
    *y* axes of the joystick, connected to the GP27 and GP26 pins, respectively. They
    read the analog values from the joystick’s potentiometers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.button`: A digital input/output object for a button, connected to the
    GP0 pin. It’s configured as an input with a pull-up resistor, which is a common
    setup for buttons. This variable represents the state of our arcade-style button.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.button2`: Similar to `self.button`. This represents a second button connected
    to the GP22 pin, also set as an input with a pull-up resistor. This variable represents
    the state of the joystick button (activated by pushing down on the joystick).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.mid`: The midpoint value for the analog readings, used to determine the
    neutral position of the joystick.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.dead_zone`: The dead zone threshold determines the joystick’s sensitivity,
    distinguishing slight, unintentional movements from deliberate ones. This accounts
    for minor variances when the joystick is in its neutral position.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With our variables set, we write our first method, which we call `get_binary_value()`.
    This function is designed to interpret the joystick’s position as a binary output.
    It first checks if the joystick’s current position, represented by `value`, is
    within a predefined dead zone around the midpoint (`self.mid`). If so, it returns
    `0`, indicating the joystick is in a neutral position. If the joystick’s position
    is outside this dead zone, the function returns `-1` for positions below the midpoint
    (negative direction) and `1` for positions above it (positive direction):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define our second method, `read()`. This method consolidates the joystick’s
    and buttons’ statuses into a single output. It computes binary values for the
    *x* and *y* axes of the joystick using the `get_binary_value()` method, translating
    analog readings into binary (`-1`, `0`, or `1`) based on position. It also assesses
    the states of two buttons, converting their digital values into a Boolean format
    (pressed or not pressed). The method then returns a tuple containing these binary
    values and button states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then write our test code. We use this code to test our `Joystick` class.
    It initializes an instance of the `Joystick` class and enters an infinite loop
    to continuously test the functionality of the joystick. In each iteration of the
    loop, it reads the current positions of the joystick’s *x* and *y* axes and the
    states of the two buttons using the `read()` method. These values are then printed
    to the console, displaying the joystick’s *x* and *y* positions along with the
    press status of each button. The `if __name__ == "__main__":` block ensures that
    this main loop runs only if the script is executed as the main program, not when
    imported as a module, allowing us to easily test our `Joystick` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To save the file, we click on `joystick.py` to our Raspberry Pi Pico WH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run our code, we click on the green **Run** button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top, and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the shell, we should observe the joystick values change as we move the joystick
    and press the buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Joystick and button state](img/B21282_12_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Joystick and button state
  prefs: []
  type: TYPE_NORMAL
- en: With our `Joystick` class and `joystick.py` file written and successfully tested,
    we are now ready to write the code to send out the joystick status via MQTT messaging.
  prefs: []
  type: TYPE_NORMAL
- en: Sending MQTT messages from our IoT joystick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `Joystick` class created and tested, it is time to write the code to
    send the joystick and button status in an MQTT message.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write the joystick code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico WH to a USB port and launch Thonny. We may
    use our Raspberry Pi or another operating system for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the CircuitPython environment on our Pico WH by selecting it
    from the bottom right-hand side of the screen (see *Figure 12**.6*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new editor, we start our code with the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import time`: Incorporates time-related functions, useful for delays and timing
    control in the code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import board`: Provides access to the hardware-specific details of the Raspberry
    Pi Pico WH, particularly its GPIO pins.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import wifi`: Enables Wi-Fi functionality, crucial for network connectivity
    in IoT applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import socketpool`: Manages network sockets, used for network communications,
    such as MQTT messaging.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import digitalio`: Allows for digital input and output control, useful for
    managing LEDs, buttons, and other digital components.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from adafruit_minimqtt.adafruit_minimqtt import MQTT`: Imports the Adafruit
    MiniMQTT library, which is used for handling MQTT protocol communication, a standard
    for IoT messaging.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from joystick import Joystick`: Imports our custom `Joystick` class for handling
    the logic for interfacing with our joystick module.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then set our variable declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`WIFI_SSID` and `WIFI_PASSWORD`: These variables store the credentials for
    the Wi-Fi network, essential for connecting the Raspberry Pi Pico WH to the internet.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MQTT_SERVER`, `MQTT_PORT`, `USERNAME`, `PASSWORD`: These settings are for
    configuring the MQTT client. They specify the server address, port number, and
    authentication credentials needed to connect to our CloudAMQP server.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MQTT_TOPIC`: Defines the MQTT topic under which the messages will be published.
    In this case, it’s set to `JoystickPosition`, indicating that messages related
    to the joystick’s position will be sent to this topic.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`led = digitalio.DigitalInOut(board.GP5)`: Initializes a digital output on
    pin GP5 of the Raspberry Pi Pico W for our LED.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`led.direction = digitalio.Direction.OUTPUT`: Sets the direction of the pin
    to output, allowing our program to control the LED (for example, turning it on
    or off).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use the `flash_led()` method to turn on and off our LED to use it as a status
    indicator. Our method takes in times and duration values to allow for custom flashing
    of the LED based on a particular program state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `connect_to_wifi()` method is used to connect our Raspberry Pi Pico WH
    to our Wi-Fi router and the internet. This function continuously attempts to connect
    to Wi-Fi, using the `WIFI_SSID` and `WIFI_PASSWORD` credentials. On failure, it
    prints an error message, flashes an LED, and retries after a 3-second pause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `connect_to_mqtt()` function attempts to establish a connection to the
    MQTT server in a loop. If the connection is successful, it prints a confirmation
    message and exits the loop. In case of a connection failure, it reports the failure,
    activates a half-second LED flash as an error indicator, and then waits for 3
    seconds before retrying:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our code then calls `connect_to_wifi()` to establish a Wi-Fi connection. Next,
    a socket pool is created from `wifi.radio` to manage network communication. An
    MQTT client is then instantiated with the specified server, port, and user credentials
    and connected to the MQTT broker using `connect_to_mqtt(mqtt_client)`. After establishing
    an MQTT connection, the LED is set to a steady on state (`led.value = True`) as
    an indicator of successful setup. Finally, an instance of the `Joystick` class
    is created, readying it for capturing user inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `send_mqtt_message()` function in the code is responsible for formatting
    and sending joystick data over MQTT. It accepts the joystick’s *x* and *y* axes’
    values and the states of two buttons. The states of the buttons are converted
    to `True` or `False` based on whether they are pressed. The function then constructs
    a message string that includes the *x* and *y* positions and the states of both
    buttons. This message is published to the MQTT topic defined by `MQTT_TOPIC`,
    allowing the joystick’s status to be transmitted via the MQTT protocol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main()` function in the code represents the primary loop for reading joystick
    inputs and sending corresponding MQTT messages. Within an infinite loop, it continually
    calls the `joystick.read()` method to get the current positions of the joystick’s
    *x* and *y* axes and the states of two buttons. It then passes these values to
    the `send_mqtt_message()` function to format and transmit them as MQTT messages.
    A 1-second delay (`time.sleep(1)`) is included at the end of each loop iteration
    to manage the frequency of MQTT transmissions. The `if __name__ == "__main__":`
    block ensures that this main loop runs only if the script is executed as the main
    program, not when imported as a module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To save the file, we click on `code.py` to our Raspberry Pi Pico WH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run our code, we click on the green **Run** button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top, and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test our code, we connect the MQTT-Explorer app to our CloudAMQP server and
    observe the messages received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should observe outputs as three distinct values: `1`, `0`, and `-1`, indicating
    their neutral, positive, and negative positions respectively. Additionally, we
    should see the state of two buttons (`True` or `False`): `Button 1` corresponds
    to the arcade-style button, and `Button 2` indicates the joystick’s click action.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the code completed for our IoT joystick, it is time to create our custom
    `robot_control` ROS node so that we may control the TurtleSim robot.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom ROS node for our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 11*](B21282_11.xhtml#_idTextAnchor173)’s *Creating an ROS workspace
    and package* section, we outlined how to set up a `circle` node for TurtleSim
    robot control. Following this blueprint, we’ll now create a `robot_control` node
    on the ROS-equipped Ubuntu system from [*Chapter 11*](B21282_11.xhtml#_idTextAnchor173).
    This involves setting up a new ROS workspace and package for the `robot_control`
    node, enabling us to control the TurtleSim robot using our new IoT joystick.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure clarity and avoid any potential mix-up with the existing `circle`
    node, we’ll create a new workspace and package for the `robot_control` node, despite
    the possibility of reusing those from [*Chapter 11*](B21282_11.xhtml#_idTextAnchor173).
    This approach allows us to maintain distinct environments for each project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our custom robot_control node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already installed the `paho-mqtt` Python library onto our Ubuntu
    installation, we will not need to install it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our new node, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We open an Ubuntu Terminal and execute the following command in our home directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: cd ch12_ws/src
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To initialize the ROS environment, we execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create our package by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'robot_control.py file in a text editor, we execute the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We start by deleting all the code. We then start our new code with imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import rclpy`: Imports the ROS 2 client library for Python, allowing the script
    to interact with ROS 2 functionalities and create ROS 2 nodes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from rclpy.node import Node`: Imports the `Node` class from the `rclpy` module,
    enabling the script to define custom nodes for ROS 2 applications'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from geometry_msgs.msg import Twist`: Imports the `Twist` message type from
    the `geometry_msgs` package; we use this for sending commands to move the TurtleSim
    robot'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import paho.mqtt.client as mqtt`: Imports the Paho MQTT client library we
    will use for MQTT protocol communication'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our code, we create an `MQTTMessage` class. This class effectively parses
    and updates its properties based on the content of an MQTT message, which contains
    joystick position data and button states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`class MQTTMessage`: Defines a class for handling MQTT messages.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__init__()` method:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes `x` and `y` to `0`, representing default positions.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets `button1` and `button2` to `False`, indicating their default unpressed
    state.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_values()` method:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Takes a `message` string as input and splits it into parts based on commas.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parses the `message` to extract and convert `X` and `Y` values to floats.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Determines the states of `button1` and `button2` by splitting the string parts
    and comparing them with `"True"`. The `strip()` method is used to remove any leading/trailing
    whitespace.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `RobotController` class is a subclass of the `Node` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We define `RobotController` as a subclass of `Node`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__init__()` method:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes the node with the name `robot_controller`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores `mqtt_message` passed as a parameter
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a publisher for ROS `Twist` messages on the `turtle1/cmd_vel` topic
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets a timer for a periodic callback function with a 0.1-second interval
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes `self.vel_msg` as a `Twist` object for velocity commands
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MQTT client configuration:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new MQTT client
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets up connection and message callbacks (`on_connect()` and `on_message()`
    methods)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configures the client with a username and password for MQTT
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Establishes a connection to the MQTT server at `driver.cloudmqtt.com` on port
    `18756` (verify port number in the `on_connect()` method is used to handle MQTT
    client connections. Upon successfully connecting (indicated by `rc` being `0`),
    it prints a confirmation message and subscribes the client to the `JoystickPosition`
    topic, enabling the client to receive related messages. If the connection fails,
    it displays an error message with the specific `rc` code to help diagnose the
    issue. The method’s parameters follow the Paho MQTT library’s conventions:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The `on_message()` method is used to handle incoming MQTT messages. Upon receiving
    a message, it decodes the message payload from bytes to a string and then updates
    the MQTT `message` object with the new values using the `update_values()` method:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The `timer_callback()` method is the final method in the `RobotController`
    class. It adjusts the robot’s movement based on the state of two buttons. If `button1`
    is pressed, it sets the robot to draw a circle in the counterclockwise direction.
    Pressing `button2` does the opposite, making the robot move in the clockwise direction.
    If neither button is pressed, the robot’s linear and angular velocities are set
    based on the joystick’s `Y` and `X` positions, respectively. After setting the
    velocities, the updated `vel_msg()` function is published to control the robot’s
    movement:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main()` function is executed outside any class and serves as the entry
    point for running a ROS 2 node integrated with MQTT for robot control. It begins
    with initializing the ROS client library, then creates an instance of the `MQTTMessage`
    and `RobotController` classes, passing the MQTT message object to the latter.
    The application enters a ROS event loop to process callbacks, including MQTT messages,
    ensuring the robot responds to joystick commands. Upon exit, it shuts down by
    destroying the ROS node and terminating the ROS client library:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'With our code completed, we save the file using the same name, `robot_control.py`.
    Our next step is to update the `package.xml` file to include Python library dependencies
    for our code (refer to [*Chapter 11*](B21282_11.xhtml#_idTextAnchor173) for more
    information on ROS packages). To do so, we open an Ubuntu Terminal and navigate
    to the folder containing the `package.xml` file:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '</package>):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We save our changes and close the editor.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With updates to `robot_control.py` and `package.xml`, we are now ready to compile
    our code and run our new node.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling a ROS TurtleSim robot using our IoT joystick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can run our new node, we must compile it. As we did in [*Chapter
    11*](B21282_11.xhtml#_idTextAnchor173), we compile our code using the `colcon`
    ROS tool. To compile and execute our new code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ubuntu, we open a new Terminal and source our ROS 2 environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then navigate to the root of our workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To compile our code, we execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon completion, a message confirming a successful build will appear in the
    terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With our code compiled, it is time to source our new ROS environment. We do
    this with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is similar to how we source the ROS environment. To run our node, we execute
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 12.8 – Running the robot_control node](img/B21282_12_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Running the robot_control node
  prefs: []
  type: TYPE_NORMAL
- en: 'In a separate Ubuntu Terminal, we launch an instance of the TurtleSim robot
    with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should observe that we can navigate the TurtleSim robot with our IoT joystick.
    Pressing and holding the main arcade-style button will make the robot draw a circle
    in the counterclockwise direction, while clicking and holding the joystick control
    down should make the robot draw a circle in the clockwise direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Results of pressing the arcade-style button on the IoT joystick
    followed by pressing the joystick control button](img/B21282_12_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Results of pressing the arcade-style button on the IoT joystick
    followed by pressing the joystick control button
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have successfully managed the remote control of a virtual robot
    using our IoT joystick, demonstrating the system’s global reach. This application
    demonstrates the vast potential for IoT and robotics integration.
  prefs: []
  type: TYPE_NORMAL
- en: For our final step, we’ll encase the IoT joystick’s components in a custom-designed
    housing. This enhances usability by making the device easier to manage and operate.
    Additionally, the custom case offers protection for the electronics and gives
    our application a professional finish.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the IoT joystick case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, our custom case gives our IoT joystick a professional look and
    gives us something to place in our hands. We assemble the custom case using 3D-printed
    parts and some common components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.stl` files for the 3D-printed parts of our case may be found under the
    `Build Files` section of this chapter’s GitHub repository. We may see the parts
    that make up the case in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21282_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Parts that make up the IoT joystick case
  prefs: []
  type: TYPE_NORMAL
- en: 'The parts that make up the IoT joystick case from *Figure 12**.10* are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A*: Backplate. 3D printed from the `.``stl` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*B*: Front shell. 3D printed from the `.stl` file (the part in the figure has
    been painted).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C*: 4 x M2.5 10 mm stand-offs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: 8 mm LED holder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E*: Thumbstick for PS2 joystick stick module. 3D printed from the `.``stl`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F*: Drilling guide for PS2 joystick module. 3D printed from the `.stl` file.
    We use a drilling guide as there are discrepancies in the position of mounting
    holes for various versions of the PS2 joystick module. The version we are using
    in our example has mounting holes that are 20.5 mm apart on the *y* axis and 26
    mm apart on the *x* axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*G*: 1 x M2 8 mm screw (not shown).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*H*: 4 x M2 5 mm screws (not shown).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I*: 8 x M2.5 5 mm bolts (not shown).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*J*: 4 x M3 10 mm bolts (not shown).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To construct the IoT joystick case, we begin by securing the thumbstick (*E*
    from *Figure 12**.10*) to the PS2 joystick (as shown in *Figure 12**.11*). We
    are replacing the thumbstick that comes with the PS2 joystick with our own to
    allow for more range. We can see the construction of the IoT joystick in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21282_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Preparing our custom case for the PS2 joystick
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare our case for the PS2 joystick, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Secure the M2 8 mm screw to the thumbstick such that a portion of it extends
    through the thumbstick (*Step 1* from *Figure 12**.11*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fasten the thumbstick to the stem of the PS2 joystick by screwing it in by hand
    (*Step 2* from *Figure 12**.11*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the four M2.5 10 mm standoffs to the PS2 joystick using four M2.5 5 mm
    bolts (*Step 3* from *Figure 12**.11*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Line up the drilling guide to the joystick hole of the front shell matching
    the orientation shown in *Step 4* of *Figure 12**.11*. The PS2 joystick will be
    installed such that the pins will extend out to the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using an appropriately sized drill bit, drill four holes into the front shell
    (*Step 5* from *Figure 12**.11*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the thumbstick installed and the holes drilled, it is now time to construct
    the case. To do so, we follow the steps in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Constructing the IoT joystick case](img/B21282_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Constructing the IoT joystick case
  prefs: []
  type: TYPE_NORMAL
- en: 'Using *Figure 12**.12* as a reference, we construct the IoT joystick case as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by securing the Raspberry Pi Pico WH to the back plate using four M2
    5 mm screws, positioning the USB port downward for easy access. This setup ensures
    the Pico’s *Reset* button is accessible through a designated hole in the back
    plate. Opting for a Pico WH provides easy integration with our GPIO expander from
    the test circuit. While a Raspberry Pi Pico W can also be used, it requires soldering
    to install, making the Pico WH a more convenient choice for this application (*Step
    1* from *Figure 12**.12*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then secure the PS2 joystick to the front shell using four M2.5 5 mm bolts.
    We must ensure that we install the P2 joystick such that the pins are pointing
    to the right of the case (*Step 2* from *Figure 12**.12*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the LED holder, we attach the LED with the resistor to the front shell.
    We secure the arcade-style button to the front shell, as well as using the appropriate
    hole (*Step 3* from *Figure 12**.12*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We secure the backplate to the front shell using four M3 10 mm bolts (*Step
    4* from *Figure 12**.12*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To power the IoT joystick, we attach a micro-USB cord to the USB port of the
    Raspberry Pi Pico WH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We may now plug in our IoT joystick and use it to control a TurtleSim robot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we assembled our IoT joystick and used it to control a TurtleSim
    virtual robot. We started with component wiring and then proceeded to write code
    for transmitting joystick movements via MQTT messages.
  prefs: []
  type: TYPE_NORMAL
- en: Our application culminated in encasing the components in a custom 3D-printed
    case, enhancing the joystick’s usability and durability. Through this application,
    we displayed the seamless integration of IoT devices with robotic systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will convert our virtual TurtleSim robot into a real-life
    physical robot and control it with our new IoT joystick.
  prefs: []
  type: TYPE_NORMAL
