- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python Entities and API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blender expands Python by making the **modules** of its **Application Programming
    Interface** (**API**) available inside the app.
  prefs: []
  type: TYPE_NORMAL
- en: These modules provide **wrappers** that translate Blender’s internal data into
    Python objects. Comprehensive documentation and an API reference are available
    online and can be reached from inside the application. Plus, there are some extra
    features to help programmers in their journey.
  prefs: []
  type: TYPE_NORMAL
- en: Much like the syntax highlight that we have met in [*Chapter 1*](B18375_01.xhtml#_idTextAnchor014),
    some features for developers are common-place in the programming world. Others,
    such as property tooltips and variables display, are specific to Blender.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at some **snippets**, that is, chunks
    of code, that will help you become confident with the architecture of Blender’s
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the API is designed to be very friendly to programmers that are already
    experienced with Python, only deviating a few times from the standards.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to inspect Blender objects from
    the Python console and change their properties, use and expand Blender collections,
    and check the current state of the user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to become familiar with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Features of Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blender modules and their structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data and Context Access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only Blender is needed to follow along with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Useful features of Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already met the *Python* elements of the **Scripting** workspace in [*Chapter
    1*](B18375_01.xhtml#_idTextAnchor014). Now we are going to look at some useful
    features that can help us get the most out of them. When it comes to programming,
    automation can speed up the search for attributes and terms. That can happen both
    in the console, through conventional methods such as **autocompletion**, or in
    the interface, via shortcuts that display the Python address of a graphic element.
    Some of these features are already available when Blender starts, while others
    are left for the users to enable.
  prefs: []
  type: TYPE_NORMAL
- en: Options for developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developer features are disabled by default. They can be enabled in the **Preferences**
    dialog from the **Edit** menu in the top bar of Blender. We need to select the
    **Interface** tab on the left and look at the first panel: **Display**. Programmers
    usually enable the **Developer Extras** and **Python** **Tooltips** options.'
  prefs: []
  type: TYPE_NORMAL
- en: Developer Extras
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Developer Extras** adds a right-click menu entry that can display the Python
    source code of the UI in the *Text Editor*. It also shows the geometry index of
    mesh components when the user switches to **Edit Mode**. Among other things, it
    allows the **search bar** to execute operators that cannot be accessed via the
    UI.'
  prefs: []
  type: TYPE_NORMAL
- en: Python tooltips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hovering the mouse cursor over an attribute displays a tooltip with a small
    description. If Python tooltips are enabled, information about how to invoke that
    attribute in scripts is displayed as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Blender’s display preferences](img/Figure_2.1_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Blender’s display preferences'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in the 3D Viewport, we can press the *N* key to display the **transform
    channels** on the right-hand side of the screen. Leaving the mouse pointer over
    a coordinate, such as **Location:** **X**, for a while will show two additional
    lines in the description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Python tooltip of an object location](img/Figure_2.2_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Python tooltip of an object location'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python tooltip consists of two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line provides the Python name of the attribute; in this case, `location`
    is the `Object` position in space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line is more specific: the location of this object (`''Cube''`)
    can be reached by typing that line in the console. This is usually referred to
    as the **full data path** of the property or, on some occasions, the **RNA** path.
    The latter term comes from a playful analogy to genetics: if Blender’s internal
    code makes its *DNA*, its *Python* access can be seen as the *RNA* of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: An object’s location is a simple case, other attributes can be more complex.
    Anyway, we can copy data paths to the clipboard following the steps in the next
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Copying the data path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Right-clicking on a property opens a *context* menu. Some entries, such as
    **Insert Keyframes** and **Reset to Default Value**, are useful for animation.
    In this section, we will focus on the programming entries, **Copy Data Path**
    and **Copy Full** **Data Path**:'
  prefs: []
  type: TYPE_NORMAL
- en: Select an object in the 3D Viewport.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no transform properties are displayed on the right, press *N* to summon the
    **Transform** sidebar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Item** tab, right-click on the first location channel (**X**), then
    click **Copy Full** **Data Path**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3: Right-click menu for location X](img/Figure_2.3_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Right-click menu for location X'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Python console, press *Ctrl* + *V* to paste, and then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The console will display the location value for the *X* coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The full data path allows to access an attribute and, unless it is a read-only
    property, change its value. We can see how the copied line ends with an index,
    which is due to `location` being a three-dimensional attribute – each index refers
    to an axis of the space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Data paths can be convoluted sometimes, but in the next section, we are going
    to look at some console tools that help a lot when looking for the right attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Python console’s utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Python console* offers some helpful utilities. Some of them, such as text
    completion and history, are common among programmers’ tools. Others, such as the
    3D representation of variables, are typical of Blender. This section provides
    an overview of how the Python console is used in day-to-day programming.
  prefs: []
  type: TYPE_NORMAL
- en: Autocompletion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pressing the *Tab* button while typing in the console suggests a few possible
    ways to complete the line. On top of that, if the current statement is associated
    with internal documentation (`print()`:'
  prefs: []
  type: TYPE_NORMAL
- en: In Blender, select **Scripting Workspace** in the tabs at the top of the screen,
    as we learned in the *The Scripting Workspace* section, in *First steps with Python*,
    in [*Chapter 1*](B18375_01.xhtml#_idTextAnchor014).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Python console, type only `prin`, then press *Tab*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The console fills in the missing letters and displays `print(`, with an open
    bracket, and its documentation. Then, it lets the programmer finish the line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Autocompletion in the Python console](img/Figure_2.4_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Autocompletion in the Python console'
  prefs: []
  type: TYPE_NORMAL
- en: History
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previous commands executed in Blender’s Python console can be retrieved using
    the up/down arrow keys. This can be tested with any code. Here is an example to
    run in the Python console:'
  prefs: []
  type: TYPE_NORMAL
- en: Type `print('Line One')`, then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press the *↑* key. The current text will change to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the last letters and change the line to `print('Line Two')`, then press
    *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *↑* twice to display `>>> print('Line` `One')` again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternate between pressing *↓* and *↑* to switch between the two commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiline input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Snippets consisting of two or more lines can be pasted to the console and executed
    by pressing *Enter* twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since blank lines mark the end of a snippet, they can make valid code fail
    when present inside indented blocks. Let’s look at a simple example: a condition
    containing two `print` statements separated by a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works in the *Text Editor* but fails in the *Python console*. Here
    is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After the first two lines are executed, the indentation of the second `print()`
    is considered wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blank lines should be replaced with comments (`#`) in every snippet meant for
    the console. The following code will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Displaying 3D variables in the 3D Viewport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables that represent a 3D point or transformation can be displayed in the
    three-dimensional space. This is made possible by the **Math Vis (Console)** add-on.
    **Add-ons** are Python extensions that can be enabled at need. We are going to
    write our own add-ons in this book. For now, we will see how to enable an add-on
    that ships with Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Math Vis (Console) add-on
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add-ons can be enabled in the preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: From the top-bar menu, select **Edit |** **Preferences**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Add-ons** tab in the left column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `Math Vis` in the search filter marked with the magnifier icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the checkbox to the left of the add-on name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating 3D variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Blender provides additional Python types for 3D entities. For instance, coordinates
    can be stored using a `Vector` type. We can store a vector in a variable by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since we have enabled the *Math Vis (Console)* add-on, a pink dot followed by
    the variable name will appear in the 3D Viewport.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: Vector coordinates [1.0, 2.0, 3.0], as displayed in the 3D Viewport](img/Figure_2._05_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Vector coordinates [1.0, 2.0, 3.0], as displayed in the 3D Viewport'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are visualized only when the console is visible, as long as they
    exist. The drawing stops once they are deleted with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `del` statement is a standard Python command. We should keep in mind that
    it deletes Python variables, not Blender objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to delete objects in Blender, we can use Blender’s `delete()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`ops` in the preceding command stands for `bpy.ops.object.delete()`, this means
    pressing the *X* key or selecting the **Delete** action from the **Object** menu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Types with a geometrical meaning, such as `Vector`, `Matrix`, and `Euler`,
    are mathematical constructs and belong to the `mathutils` module. This module
    is imported into the *console* automatically. There is no need to import it again
    in the console. If we were to use it in a script, we would have to import it from
    the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are going to explore `mathutils` in the next chapters, when dealing with
    3D objects and elements. In the next section, we’ll get familiar with how Blender
    objects translate into Python.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Blender modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blender’s additional modules are available throughout the application and can
    be used via the standard `import` statement. They are available in the Python
    console, the Text Editor, and generally in the scripts that are installed in the
    Blender system and user paths.
  prefs: []
  type: TYPE_NORMAL
- en: Some modules are very specific; for instance, the `freestyle` module handles
    the settings of the freestyle stylized rendering and cannot be used for any other
    purpose. Others, such as `mathutils`, come into play whenever numbers are concerned.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `bpy` module and its submodules play a bigger role in Blender scripts,
    as they grant access to objects and data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will have a closer look at `bpy`, how it is already present
    in the console, and how we can use it in our scripts. We will also learn where
    to find more information about the API and its elements.
  prefs: []
  type: TYPE_NORMAL
- en: The bpy module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B18375_01.xhtml#_idTextAnchor014), we copied the lines from
    the console using **Console**->**Copy** from the Python console editor and pasted
    them into a text block. In doing so, we found a few extra lines at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line imports `bpy`, the main module of the programming interface.
    Lines two and three import `data` and `context` and assign them, respectively,
    the `D` and `C` letters as convenience shortcuts. This is pointed out in the initial
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Python console’s convenience variables](img/Figure_2.6_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Python console’s convenience variables'
  prefs: []
  type: TYPE_NORMAL
- en: '`data` represents the storage of Blender objects and `context` is the current
    state of the user interaction, such as the selection or the current mode (**Object**,
    **Edit**, **Pose**, etc.).'
  prefs: []
  type: TYPE_NORMAL
- en: Because of their nature, `context` and `data` are always present in Blender
    scripts. The autocompletion gives a glimpse of the other modules. If we type `bpy.`
    and press *Tab*, we’ll get a list of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: bpy’s submodules](img/Figure_2.7_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: bpy’s submodules'
  prefs: []
  type: TYPE_NORMAL
- en: Each attribute of `bpy` covers a specific aspect of Blender. For instance, `bpy.app`
    contains the properties of the software (executable and version) and `bpy.ops`
    contains the operators, that is, functions that can be invoked in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '`bpy` and the other Blender modules contain a multitude of classes, methods,
    and utilities. These entities are documented in the *Python API Reference*, which
    is available online and can be downloaded if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: API documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reference website can be reached via **Help** | **Python API Reference**
    from the top menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: The link to the Python API Reference](img/Figure_2.8_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: The link to the Python API Reference'
  prefs: []
  type: TYPE_NORMAL
- en: The *Python Help* for the current version will open in the web browser. The
    documentation is generated from the docstrings using software called `help()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Comparison between the help() function and online help for the
    Euler class](img/Figure_2.9_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Comparison between the help() function and online help for the
    Euler class'
  prefs: []
  type: TYPE_NORMAL
- en: The online help has the advantage of a search bar and doesn’t take space from
    our Blender session. It contains an index of the available modules and their content.
  prefs: []
  type: TYPE_NORMAL
- en: An API reference is very useful to navigate the various modules and the attributes
    of `bpy`.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll focus on `bpy.data` and `bpy.context`, leaving the specific
    functionalities of the other modules to the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Blender data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the entities created in the current session are available as part of `bpy.data`.
    They are grouped in categories that follow the `bpy.data.armatures`, `bpy.data.curves`,
    and so on. Each category is a `bpy_collection`, a Blender type that contains more
    elements. Their content can be accessed with indices, like in a Python `list`,
    or with keywords, like in dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Objects access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use Python to access the objects of a scene. For example, we can query
    the content of Blender’s default scene, which contains a **Cube**, a **Camera**
    and a **Light**:'
  prefs: []
  type: TYPE_NORMAL
- en: Open or restart Blender and select **Scripting Workspace** in the workspace
    tabs at the top of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.10: The workspace tabs](img/Figure_2.10_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: The workspace tabs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `len(bpy.data.objects)` and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the Python console, type `bpy.data.objects`, then press *Tab*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11: Blender’s default objects](img/Figure_2.11_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Blender’s default objects'
  prefs: []
  type: TYPE_NORMAL
- en: It might be confusing at first, since objects of different types all belong
    to `bpy.data.objects`, rather than to `bpy.data.cameras`, `bpy.data.meshes`, and
    `bpy.data.lights`.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, everything that can be placed and displayed in the 3D Viewport is of
    the `bpy.data.objects` type. An **object** is a generic container in which any
    kind of data, or **datablock**, can be stored. The *object*/*datablock* system
    is a tenet of Blender. We are going to get a better grasp of it in the next chapters.
    For now, we will focus on object-level access.
  prefs: []
  type: TYPE_NORMAL
- en: List-like access
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Like Python lists, individual elements of `bpy_collection` can be accessed
    by appending an index number surrounded by brackets, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we know the name of an object we are looking for, we can get it through string
    keywords rather than indices.
  prefs: []
  type: TYPE_NORMAL
- en: Dict-like access
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Besides using their ordinal index, we can access the elements of `bpy.data.objects`
    using their names as keywords, as we do with Python dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Iterating through collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To execute an expression on all the objects of an aggregate type, we need to
    *iterate* through the collection. **Iteration** describes the action of scrolling
    through the elements. By iterating using loop statements, we can carry the same
    operation on many objects.
  prefs: []
  type: TYPE_NORMAL
- en: List-like looping
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The typical `for element in list` loop works with `bpy_collection`. The following
    snippets print out a list of the existing objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we use the following if we need their collection index as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the output, we can see that the elements of `bpy.data.objects` are
    ordered alphabetically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That implies that renaming the objects changes the order in which they are listed.
    It can be an issue if we rename an element while we are still iterating through
    its collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, this snippet adds the letter`''z''` in front of the name of the
    first object (**Camera**). That changes its position in the *Outliner* from first
    to last displayed object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.12: Before and after renaming – the order of the objects has changed](img/Figure_2._12_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Before and after renaming – the order of the objects has changed'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will experience a reordering issue if we execute the same operation inside
    a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It would be reasonable to end up with `'z'` is repeated for a long span.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13: Renaming added way too many “z”s](img/Figure_2._13_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Renaming added way too many “z”s'
  prefs: []
  type: TYPE_NORMAL
- en: This is a bug in which neither our code nor the application does anything inherently
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why that happens, we need to break it down into individual steps.
    Blender renames the first, second, and third objects, then it should stop. But
    since they were renamed, `"Light"` is renamed and put last, so after that, Blender
    proceeds to rename `"zCamera"` to `"zzCamera"`, and the process keeps going.
  prefs: []
  type: TYPE_NORMAL
- en: That lasts until the names become too long to be renamed.
  prefs: []
  type: TYPE_NORMAL
- en: Bugs like this can cause software halts and be very hard to find. Whenever our
    script renames the content of a collection, we must make sure that reordering
    is not going to be an issue. We are going to look at some possible workarounds.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding reordering via list conversion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first and easiest way to avoid re-iteration is to convert `bpy_collection`
    into a Python list. Press *Ctrl* + *Z* to undo the renaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will use a slightly different line that converts the collection into
    a pure Python list, via the `list()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.14: The objects have been renamed properly](img/Figure_2._14_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: The objects have been renamed properly'
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we’ll see that dictionary methods are also supported.
    They are, among other things, immune to reordering.
  prefs: []
  type: TYPE_NORMAL
- en: Dict-like looping
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Like in Python dictionaries, the `keys()` method returns all the names present
    in a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can obtain a list of the objects using the `values()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can iterate both using `items()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Creating new objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blender classes purposely lack a `new()` method of their `bpy_collection`. For
    instance, 3D objects are created using `bpy.data.objects.new()`.
  prefs: []
  type: TYPE_NORMAL
- en: The new() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding an object to the scene takes one step with the Blender interface. Doing
    it in Python requires some extra work: the `new()` command stores a new object
    in the memory, but then we need to add it to our scene explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typing `bpy.data.objects.new` and pressing *Tab* in the Python console displays
    its documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The new function requires two parameters: the name that we want to give to
    our object and the *datablock* that it’s going to contain. If we don’t have any
    *datablocks* yet, we can create an `None` type to the argument `object_data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `print()` line will confirm that the object has been created. It doesn’t
    show up in the 3D Viewport, but we can check that `bpy.data.objects`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15: The new Empty shows up in the Python collection](img/Figure_2.15_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: The new Empty shows up in the Python collection'
  prefs: []
  type: TYPE_NORMAL
- en: This object is not part of a 3D scene yet. In order to be part of a scene, objects
    must belong to a **collection**.
  prefs: []
  type: TYPE_NORMAL
- en: Object collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The term *collection* carries some ambiguity, as we have referred to `bpy_collection`
    as part of data access. `bpy_collection` types, such as `bpy.data.objects`, are
    two distinct concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene collections** are groups of objects displayed as folders in the **Outliner**.
    They are used to organize 3D objects in the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bpy_collection` without being part of any scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the scene collections can be accessed in Python using `bpy.data.collections`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are one step away from adding our object to the scene: we need to add `my_empty`
    to a scene collection, using the collection method `link`.'
  prefs: []
  type: TYPE_NORMAL
- en: Linking to the scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is only one collection in the default scene, so if we type `bpy.data.collections`
    and press *Tab*, we get it from the autocompletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The default collection is named `Collection.objects` attribute. The Python
    line for linking `my_empty` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**My Empty** is now part of the scene and shows up in the outliner.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16: Our Empty sitting along with the other objects](img/Figure_2._16_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: Our Empty sitting along with the other objects'
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like we can create new elements with `new()`, we can use the method `remove()`
    from `bpy.data.objects` to remove them. This line removes `my_empty` from blender:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Collections that link existing objects via `link()`, such as `Collection.objects`,
    have an `unlink()` method for removal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In that case, `bpy.data.objects`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have accessed the Blender objects via Python using `bpy.data`.
  prefs: []
  type: TYPE_NORMAL
- en: How would we fetch the current scene if there is more than just one, or the
    current object and active selection?
  prefs: []
  type: TYPE_NORMAL
- en: We will see how states of user interaction can be tracked in the `bpy.context`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the user context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current state of interaction, the current scene, and the selection are available
    via `bpy.context`. Since it depends on the user actions, `bpy.context` is read-only;
    that is, it cannot be changed directly. Anyway, we can affect the state of the
    current activity via *Python*. Rather than changing the attributes of `bpy.context`,
    we must look for the selection and activity properties of Blender’s objects, layers,
    and scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Active scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `.blend` file, or an unsaved session for that matter, can contain more than
    one **scene**. That differs from the standard in 3D packages, where a saved file
    is equivalent to one scene. If more scenes are available, they can be selected
    from the list menu at the top right of Blender’s header.
  prefs: []
  type: TYPE_NORMAL
- en: Each scene can contain any of the objects from `bpy.data.objects`, and one object
    can belong to more than one scene. Changes made to an object in one scene retained
    in the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen how to create new objects using `bpy.data.objects.new()`. We can
    create new scenes in the same way, using `bpy.data.scenes.new()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The new scene will then be available in the top-right widget.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17: Blender scene menu](img/Figure_2._17_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: Blender scene menu'
  prefs: []
  type: TYPE_NORMAL
- en: The currently displayed scene is contained in `bpy.context.window`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to create a new scene and make it active, we can assign it to the
    `window.scene` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing this snippet, the 3D Viewport will switch to a new, empty scene.
    The current scene itself is part of `bpy.context` and can be retrieved via Python
    using `bpy.context.scene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: View Layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**View Layers** are used to render the objects of a scene separately and put
    them back together using **compositing**. This is done either to speed up the
    rendering process, for instance, rendering the background only once, or for artistic
    necessities. In the UI, View Layers are created in the same way as scenes, using
    the widget on the top bar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating them in Python, we must keep in mind that they always belong
    to their scene rather than to `bpy.data`. Despite that, if we want to set the
    active layer, we still have to use an attribute of `bpy.context.window`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The active layer must belong to the active scene. A statement that tries to
    assign a layer from a different scene to the current window will be ignored. Take
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Layers can store rendering and pass properties, but also their visibility, activity,
    and selection status. In the next section, we’ll see how a layer stores the **active
    object**.
  prefs: []
  type: TYPE_NORMAL
- en: Active object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the user selects an object, that becomes the **active object** of the current
    layer. Its properties are displayed in the interface, and it will be the main
    target of the user actions.
  prefs: []
  type: TYPE_NORMAL
- en: When Blender opens, a cube is the active object by default. We can see that
    from the **Text Info** in the top-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18: Blender’s default active object](img/Figure_2._18_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: Blender’s default active object'
  prefs: []
  type: TYPE_NORMAL
- en: 'The active object can be retrieved in multiple places in the API, the most
    immediate being `bpy.context.object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All three attributes point to the same object, but since `bpy.context` is read-only,
    only the `view_layer` attribute can be changed programmatically. If more layers
    are present, switching between layers can change the active object. Or we can
    change it using Python by following the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the active object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The active object is a property of the active View Layer. With that in mind,
    we can just set the `view_layer.active` attribute to a different object. For instance,
    here is how to pick the camera instead:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Blender or revert to the default scene via **File**->**New**->**General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Scripting Workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following lines in the Python console and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the active object has changed from the 3D Viewport, the properties,
    and the status information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19: Camera is now the active object](img/Figure_2.19_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: Camera is now the active object'
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that the cube is still selected, and that the camera, despite
    being the active object, isn’t. That’s because the active and selected statuses
    are two distinct concepts. We are going to see, in the next section, how they
    differ, and how we can query and change the current selection.
  prefs: []
  type: TYPE_NORMAL
- en: Keep your focus
  prefs: []
  type: TYPE_NORMAL
- en: The Blender focus policy can be confusing at first. The area under the mouse
    cursor takes the keyboard inputs.
  prefs: []
  type: TYPE_NORMAL
- en: That’s less of a problem for artists since their tasks usually involve keeping
    the cursor in the area in which they are operating. But it’s different for programmers;
    we might think of typing lines of code for the console only to find out that we
    are triggering shortcuts in the 3D Viewport, or the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: Selected objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s select all the objects in the scene by pressing the *A* key in the 3D
    Viewport (**Select | All** from the menu bar). Then, in the console, we type the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`selected_objects` is a Python list. Unlike `bpy.data.objects`, it sorts the
    objects by their creation time and not alphabetically. Objects are *never* sorted
    by their selection time; Blender doesn’t keep that information at all. Should
    our tool require selecting objects in a specific sequence, we would have to store
    the order somewhere else.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting an object usually makes it the active object of the current layer.
    We can print out which object is active using comparisons against `bpy.context.object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this snippet with all default objects selected will produce this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern is useful whenever we want to propagate a property from the active
    object to the selection. We have already seen that we should not assume that the
    active object is always selected. Inverting the selection unselects the active
    object, but it will remain active. Or there might be no active object at all;
    it can be deleted or set to `None` via the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A way to check whether the active object belongs to the selection is with the
    `in` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better, we can use the `select_get()` and `select_set()` object properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Like the active object, the selection status of an object is stored per View
    Layer. In the next section, we’ll learn how to affect the current selection and
    where it is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Changing selected objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The selection status of an object is queried and set using `object.select_get()`
    and `object.select_set()` as, respectively, the `select_set` function works, we
    can start to type it in the Python console, stopping at the parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Pressing the *Tab* key will display a description of the function and its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If no View Layer is given, the selection of the current layer is used. For
    instance, this snippet will deselect all the objects in the current layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create layers dynamically and assign them a different selection. Here
    is a snippet that creates a View Layer where mesh objects are selected, and another
    where cameras are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Selecting is the most immediate way for the user to pick objects from the scene.
    For this reason, `bpy.context` holds a pivotal role and is usually available in
    scripts, or even passed as a Python object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how Python can access the content of Blender via `bpy.data`
    and introduced space entities such as vectors. We also saw how to interact with
    the user activity through `bpy.context`, and how read-only attributes of context
    are changed by affecting the status of objects and layers.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), we will see how to insert
    our routines in our own add-ons and make them ready to install and use in Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which helper utilities are typical of Blender?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we store and display space coordinates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which attribute of `bpy` gives access to all Blender entities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do Python classes of Blender objects have a constructor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we create new Blender objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean that an object is active?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the active object a property of the Blender scene?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we affect the selection using `bpy.context`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we affect the selection using `bpy.context.view_layer`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
