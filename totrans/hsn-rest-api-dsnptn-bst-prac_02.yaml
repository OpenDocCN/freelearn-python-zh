- en: Design Strategy, Guidelines, and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the today's digitalized world, the challenges are about interconnecting various
    heterogeneous devices with abundant software services available across the internet
    and intranets. The **applicatio****n programmable interface** (**API**) is one
    of the most promising software paradigms to address a*nything*, *anytime*, *anywhere*,and
    *any device,* which is the one substantial need of the digital world at the moment.
    This chapter discusses how APIs and API designs help to address those challenges
    and bridge the gaps.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses a few essential API design guidelines, such as consistency,
    standardization, reusability, and accessibility through REST interfaces, which
    could equip API designers with better thought processes for their API modeling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are this chapter''s objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about REST API and its importance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goals of RESTful API design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API designer roles and responsibilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful API design rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, this chapter intends to introduce a few traits and constituents of better
    REST API implementations along with a few common, but avoidable, mistakes of API
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is primarily intended to introduce readers to various RESTful design
    concepts involving design strategies and best practices; we expect that readers
    already have a basic understanding of software design concepts, client-server
    architecture, and basic data exchange formats, such as JSON and XML.
  prefs: []
  type: TYPE_NORMAL
- en: We assume readers have a basic understanding of web architecture, HTTP methods,
    headers, and related client-server concepts. However, we strongly encourage our
    readers to refresh their knowledge of design principles such as SOLID, OO designs,
    enterprise integration, SOA, and microservice architecture fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about REST API and its importance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we learned about RESTful principles such as client-server,
    statelessness, cacheable, and layered, and we'll recognize and apply those principles
    to the low-level yet functional APIs in this chapter. Also, we will learn RESTful
    API design strategies and best practices that can help us to meet the challenge
    of *any time**, anywhere, *and* any device*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think of an example—assume you're going to an event, where along with
    other activities there will be a screening of the film *Solo* (the latest in the
    *Star Wars* series), and you know that some of your friends joining the party
    aren't familiar with *Star Wars* and the earlier sequels. So being a tech geek,
    you wanted to help your friends with a simple mobile application that can send
    search results to your WhatsApp group as messages with details about *Star Wars*
    characters, lists of films, starships, and so on; also it sends messages when
    any of your friends ask for any specific information.
  prefs: []
  type: TYPE_NORMAL
- en: But how can a standalone mobile application get data about *Star Wars*, how
    will it use WhatsApp to reply, how can we integrate three different systems (mobile,
    messaging, and data) and help your friends with their *Star Wars* queries?
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to create a massive dataset of *Star Wars* by ourselves? How will
    the mobile app leverage WhatsApp messaging abilities to send star wars information?
    How can the message be a search string for our app? And we don't know yet how
    many more unknowns that we need to solve as part of the development.
  prefs: []
  type: TYPE_NORMAL
- en: And you think it would be great if the *Star Wars* dataset was readily available
    and searchable, and there should be an ability within WhatsApp to programmatically
    send messages to your friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some research say we found the following list of items that gave us the
    confidence to build a mobile app within a short time:'
  prefs: []
  type: TYPE_NORMAL
- en: A readily available dataset about *Star Wars* at SWAPI ([https://swapi.co/](https://swapi.co/))
    that the app can leverage, and, not only that, it also exposes a mechanism that
    we can search and get responses, so we have a solution for the dataset/data store
    about star wars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WhatsApp also provides out-of-the-box messaging capabilities that your program
    can use to send the messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding information, let''s put the following cues in sequence to
    visualize the app:'
  prefs: []
  type: TYPE_NORMAL
- en: A friend is asking about Beru on Whatsapp, and so the app picks it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app uses [https://swapi.co/api/people/?search=beru](https://swapi.co/api/people/?search=beru).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SWAPI REST API sends a response to the app's request. The app creates a
    text with details about Beru from the received response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app builds a *click chat* API request and sends the message to the group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`https://api.whatsapp.com/send?text=<"Beru Whitesun Lars, born: ''47BBY'',
    she belongs to *Human* Species and from *Tatooine* Planet">`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your friend/groups receive the message—`Beru Whitesun Lars, born: "47BBY",
    she belongs to "Human" Species and from "Tatooine" Planet`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, by having all necessary details about those REST APIs, you gain confidence
    to build a mobile app that helps you to send search results as a message to your
    WhatsApp group, and you are ready to rock the party. Interesting, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: So, now you know SWAPI and click chat ([http://api.whatsapp.com](http://api.whatsapp.com))
    are REST APIs and can be consumed by any applications as your mobile app consumes
    those APIs. With our example, can we say that the app is an attempt to address
    the digitization challenge of *any time, anywhere,* and* any device* with RESTful
    APIs?
  prefs: []
  type: TYPE_NORMAL
- en: Google Maps and Locations, Apple iTunes, Google Books, UK police forces ([https://data.police.uk/api/forces](https://data.police.uk/api/forces)),
    sunrise and sunset timings ([https://sunrise-sunset.org/api](https://sunrise-sunset.org/api)),
    and the British National Bibliography ([http://bnb.data.bl.uk](http://bnb.data.bl.uk))
    are few examples of public APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The REST API examples that we have so far are more reading operations. However,
    in reality, the APIs can do a lot more, and we will show how well we can design
    RESTful APIs that can support **create, read, update, and delete (CRUD**) operations,
    pagination, filtering, sorting, searching, and much more as you read through this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to get to know various publicly available APIs, their purpose,
    response formats, and so on as it will help you to understand and follow the further
    discussions in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Goals of RESTful API design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the API examples that we've seen so far, you might have observed that they're
    straightforward, unambiguous, easy to consume, well-structured, and most importantly
    accessible with well-known and standardized HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, we have a fair understanding of the APIs, and that they are one of
    the best possible solutions for resolving many digitization challenges out of
    the box; with our earlier examples, we also know who is consuming those APIs.
    Now let''s ponder how we can create such usable APIs and expose them for consumption.
    Are there any basic and necessary principles for designing APIs that we must take
    into account even before we delve into API design? What should the API allow the
    consumers to do with it? What do the consumers want to do with it? To answer our
    questions, we will need to understand the following API design goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Affordance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage existing web architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss them in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Affordance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss a fundamental design concept called **affordance** as it can
    yield answers to the various questions that we had. Affordance means how an object
    and its properties are perceived by its design. Here it provides a clue about
    its operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8468786-89f1-446e-88ae-76bf0aecb188.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram helps us to understand what affordance is in the design
    world that we're talking about; among the switches that we see, the first one
    represents a swivel operation, and another indicates an upward and downward operation.
    So, by merely seeing those objects, we can perceive what it supports and how.
    In the case of API design, affordance undoubtedly plays a crucial role, and it
    is an essential aspect of our API designs.
  prefs: []
  type: TYPE_NORMAL
- en: Loosely coupled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the whole purpose of an API is to connect heterogeneous clients with the
    same backend code, it's inevitable that APIs should be as independent as possible
    and as loosely coupled as possible with the calling clients.
  prefs: []
  type: TYPE_NORMAL
- en: In a loosely coupled design, APIs are independent, and modifications in one
    won't impact the operation of consumers. Within an API, the components get added,
    modified, or replaced. However, the loose coupling approach offers clients better
    flexibility and reusability of APIs while its elements are added, replaced, or
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: Having a loosely coupled architecture in REST API server designs facilitates
    the client and server as both follow and respect common semantics. If the API
    modifies the meaning of its response, then the client needs to be aware of it
    and act on those new responses accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Well-designed APIs exhibit loose coupling and well-composed functionalities
    across service boundaries to maximize scalability factors.
  prefs: []
  type: TYPE_NORMAL
- en: Leverage web architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since its invention by Sir Tim Berners-Lee in 1989, the fundamentals of the
    web remain as the foundations of all web architecture even today. As you all know,
    HTTP is the lifeline of the web architecture, and it powers every single client
    request, server response, and transfer of a document/content over all of the web.
    So, it is imperative that REST APIs should embrace its bursting power by building
    interfaces that can be consumed by any device or operating system.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs should use HTTP as a transport layer since the infrastructure,
    server and client libraries for HTTP are widely available already.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs should take advantage of HTTP methods, or verbs, such as `GET`,
    `PUT` and `POST` defined by the RFC 2616 protocol.
  prefs: []
  type: TYPE_NORMAL
- en: RFC 2616 ([https://tools.ietf.org/html/rfc2616](https://tools.ietf.org/html/rfc2616))
    defines Internet standards for HTTP (the application-level protocol for distributed,
    collaborative, and hypermedia information systems).
  prefs: []
  type: TYPE_NORMAL
- en: API designer roles and responsibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we discuss API design goals, principles and practices, let's touch upon
    the primary roles of a software architect, solution architect, software designer,
    or anyone who's ready to take responsibility for designing RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce successful APIs, an API designer should have or do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Be well-versed in REST fundamentals and API design best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be acquainted with API design patterns to create a modern API design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on the factors discussed in this chapter such as API design goals and
    best practices that can improve the application developer's experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translate the business domain into several APIs by having a clear understanding
    of the business vision and its functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closely work with API developers and help them with their day-to-day constraints
    and to deal with their existing legacy architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up feedback loops that involve developer feedback sessions, prototypes,
    beta users, release, and versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the feedback loops to incorporate acumens in their API design and move faster
    with API development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create best-in-class documentation, reusable code libraries, sample codes, and
    tutorials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the API designer's roles and responsibilities, let's
    move on to how one can design successful APIs with some of the industry API best
    practices in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: API design best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's think about who the consumers of any web service APIs are. Will it be
    another system, another software application, or an end-user? Mostly, the consumers
    of the APIs are another software application or another system itself. So, we
    can conclude that the customers of any API will be the app developers who give
    life to the software make it purposeful and usable by their programming codes.
    So the APIs are heavily dependent on the application developers or app developers.
  prefs: []
  type: TYPE_NORMAL
- en: So application developers should be the primary focus of API design, and for
    them to consume the APIs, there should be defined and accessible business functions.
    Please do remember that without any application developer or app developers ready
    to use the API, the API will cease to exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of best practices used by API designers to produce
    APIs that app developers like to use:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep APIs simple and easy to use—simplified, friendly, and intuitive APIs always
    attract APP developers (clients for our API), get the best out of the APP developer,
    and make the APP developer's life more comfortable, less painful, and more productive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose well-defined and instantly recognizable business functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make APIs accessible with any standard web browsers—exposing APIs with existing
    web infrastructure (HTTPs `GET`, `POST`, `PUT` , and `DELETE`) and so accessible
    through a standard browser makes underlying APIs platform independent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract service internals and domain models—the best APIs expose only URIs
    and payloads and not the service internals or domain models. An example is [https://www.googleapis.com/books/v1/volumes](https://www.googleapis.com/books/v1/volumes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure RESTful API payloads don't have any traces of SOAP payloads as the clients
    are not the same (machines versus humans).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be consistent—API implementations should be free from variation or contradiction;
    carry consistency across APIs by setting clear standards to help consumers with
    what to expect from the API, and implement similar behaviours such as searching
    and filtering (or pagination and limits) in the same way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the standard URL pattern—an example of the standard URL pattern is `/collection/item/collection/item` ,
    and the `/collection` can be books, dogs, events (plural), and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise standard terminology—following standard and meaningful elements in
    the URI is critical for API success. An example of standard terminology would
    be `bookId`, `dogId` and `eventId`, and not `bId`, `dId` and `eId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be flexible—APIs are flexible to accept input from clients. An example would
    be `/planner/v1/tasks or /planner/v1/Tasks or /planner/v1/TASKS`; lowercase, uppercase,
    or camel case in the preceding example should be acceptable and should behave
    in the same way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be stable—incremental modifications to the APIs are inevitable, but it should
    be independent of the client applications. In other words, no forced amendments
    to the clients who consume the APIs that undergo modifications. Say, `/books/v1/volumes` involves
    no changes to the clients and provide additional benefits/defect fixes when the
    volume module goes through some changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be a clear handle for errors and error messages—API implementations
    shouldn't just provide better business functions; it is critical that it handles
    the errors and error messages well to help clients with useful and human-readable
    error messages, including diagnostic information that can be understood by the
    app developer, as error messages give hints and assist the APP developers to resolve
    issues that may otherwise result in an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation—APIs are discoverable and documented, so publishing the API documentation
    is a must. API documentation includes a getting-started guide, sample codes, sample
    requests, sample responses, sample implementations, elaborate explanations about
    authentication and error handling, information about feedback avenues, and so
    forth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide feedback and support mechanism for API users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Would it be good to have API design practices so you can jump-start the API
    design? No, not yet. We need to get to know about a few core API design principles,
    which we will review next.
  prefs: []
  type: TYPE_NORMAL
- en: API design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create flexible, scalable, and secure APIs, an API designer needs a set
    of guidelines. We''ll discuss the following essential principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous web standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API flexibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API standardization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API granularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API sandbox or playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing so, we will be able to understand how following them will help us to
    design high-quality RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous web standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in the *Goals of RESTful API design* section, API designers
    should embrace the existing web standards and develop their API design and platforms,
    resulting in ubiquitous communication between the RESTful APIs and clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s ask ourselves a few questions that will help us to derive better design
    principles for our APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Who will be consuming our APIs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the business functions that the API needs to support?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How granular should the API be?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should APIs always stick to the existing web standards and provide consistency?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The REST architecture style insists on embracing the existing web standards
    and so leveraging those standards should be the primary focus of any API design.
    The following diagram depicts a few common web methods, namely, `GET`, `POST`,
    `PUT` and `DELETE` , and the interactions with **REST API** by the clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ce6ae6b-a64e-4f43-a11b-7917e3d422b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After web methods, there are few essential design aspects that APIs should
    adhere to, and they address the questions about standardization, consumers of
    API, and API consistency as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Any application client should be able to use the API ideally without having
    to refer to much documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use standard HTTP method call-outs, available on every language and platform,
    to make requests and retrieve information from APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't make any assumptions about the software development technologies used
    by consumer applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web protocol HTTP and responses such as JSON or ATOM help API clients to find
    a library that connects to any language or platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data from the API should be independent of resources or methods. It implies
    REST API should handle multiple types of calls and return various data formats,
    even with some change in the structure representing hypermedia. In other words,
    the data of the API response isn't tied to the resources or methods.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub API summary representations and detailed representations may be examples
    of API flexibility. List of repository API `GET /orgs/myorg/repos` gets the summary
    representation, and single repository API `GET /repos/myorg/myhelloworld.rb` fetches
    the detailed description of the indicated repository.
  prefs: []
  type: TYPE_NORMAL
- en: The Salesforce API provides flexibility with its response formats, so API developers
    can serialize the data in either XML or JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL endpoint implementation for API developers is another best example
    of API flexibility. With GraphQL, developers can request the data that they want
    based on a predefined schema and so the API can respond according to the predefined
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6bdcc86-0241-4d6b-b58e-0d93164f8be9.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot reflects a sample GraphQL request (schema) for specific
    fields (book name and rating) and response with specified fields.
  prefs: []
  type: TYPE_NORMAL
- en: Granularity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Granularity** is an essential principle of REST API design. As we understand
    business functions divided into many small actions are fine-grained, then business
    functions divided into large operations are coarse-grained. However, discussions
    about what level of granularity that needs to be in APIs may vary; we will get
    distinct suggestions and even end up in debates. Regardless, it is best to decide
    based on business functions and its use cases, as granularity decisions would
    undoubtedly vary on a case by case basis.'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, calls across the network may be expensive and so, to minimize
    them a coarse-grained API may be the best fit, as each request from the client
    forces lot of work at the server side and, in fine-grained APIs, many calls are
    required to do the same amount of work at the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following example. A service returns customer orders (say *n* orders)
    in a single call; this is a coarse-grained API in action. In case of fine-grained,
    it returns only the customer IDs, and for each customer ID, the client needs to
    make an additional request to get details, so *n+1* calls need to be made by the
    clients; these may be expensive round trips regarding its performance and response
    times over the network.
  prefs: []
  type: TYPE_NORMAL
- en: In a few other cases, APIs should be designed at the lowest practical level
    of granularity, because combining them is possible and allowed in ways that suit
    customer needs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, check out this example, an electronic form submission may need to collect
    an address as well as, say, tax information. In this case, there are two functions
    one is a collection of the applicant's whereabouts, and another is a collection
    of tax details. Each task needs to be addressed with distinct API and requires
    a separate service because an address change is logically a different event and
    not related to tax time reporting, that is, why one needs to submit the tax information
    (again) for an address change.
  prefs: []
  type: TYPE_NORMAL
- en: Level of granularity should satisfy the specific needs of the business functions
    or use cases. While the goal is to minimize the calls across the network and for
    better performance, understanding the set of operations that API consumers require
    and how they would give a better idea of the right grained APIs in our designs is
    important.
  prefs: []
  type: TYPE_NORMAL
- en: Say internal services consumers for those who multiple calls to the API servers
    are acceptable and those APIs can be designed as fine-grained, and the external
    consumers and if they need to avoid several round-trips to the API then plan as
    coarse-grained.
  prefs: []
  type: TYPE_NORMAL
- en: At times it may be appropriate that the API design supports both coarse-grained
    as well as fine-grained to give the flexibility for the API developers to choose
    the right APIs for their use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points may serve as some basic guidelines for the readers to
    decide their API granularity levels in their API modelling:'
  prefs: []
  type: TYPE_NORMAL
- en: In general, consider services coarse-grained and APIs fine-grained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain a balance between the amount of response data and the number of resources
    required to provide that data will help to decide the granularity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of performed operations on the data should also be considered as part
    of the design when defining the granularity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read requests are normally coarse-grained. Returning all information as required
    to render the page won't hurt as much as two separate API calls in some cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, write requests must be fine-grained. Find out common operations
    clients need, and provide a specific API for that use case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At times, you should use medium-grained, that is, neither fine-grained or coarse-grained.
    An example could be as seen in the following sample where the nested resources
    are within two levels deep.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following snapshot that reflects a medium-grained API response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a37e2d13-dd63-47a5-a15f-926d13d9be9b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's conclude this section with a broad guideline that helps to determine the
    right service granularity—identify the vital business entities that the service
    impacts and model the life cycles accordingly; that is, there should be only one
    API operation for one business outcome.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding guideline may lead to a number of API deployment units, and this
    can cause annoyances down the line. There are patterns, especially the API gateway,
    which brings a better orchestration with those numerous APIs. Orchestrating the
    APIs with optimized endpoints, request collapsing, and much more helps in addressing
    granularity challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Optimized APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses adopting better optimization for the API. There's no
    concept of one-size-fits-all. In the real world, multiple APIs may support the
    same service as that service might be serving different types of users and use
    cases. As we quoted earlier in this chapter, the API should be modeled after the
    design according to the use case it fulfils and not by the backend services or
    applications it exposes.
  prefs: []
  type: TYPE_NORMAL
- en: So optimization applies to a specific business request in a particular context.
    Let's take an example, a web service enables its mobile app consumers to clear
    electricity bills. In the context of the mobile, the constraints of mobile application
    should be our primary consideration, as a mobile app is sensitive to network latency,
    numerous network trips, the size of the data compared to a standard web application,
    and so on. So, our API design should focus on limiting the backend calls and minimize
    the size of the data returned.
  prefs: []
  type: TYPE_NORMAL
- en: Concerning granularity, let's consider the preceding example will consume few
    fine-grained independently invokable APIs. On the other hand, to make the payment,
    the app may need to use a coarse-grained API from another service (which, in turn,
    may have many fine-grained APIs). So, our mobile app can use a few other fine-grained
    APIs directly to fetch the due amount, get the user address, and access account
    details of the bank that the user wants to use to pay the outstanding amount,
    and may even need more fine-grained APIs to be incorporated in future and so on.
    So, designers should consider the layered or tiered approach that we discussed
    in [Chapter 1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml), *Introduction to the
    Basics of RESTful Architecture,* to orchestrate and manage those fine-grained
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: So, API designs can expose fine-grained APIs for consumers who can access them
    directly, and coarse-grained services on top of them would support broader use
    cases, so that the service clients may decide to call the fine-grained APIs directly,
    or they may decide to use the coarse-grained APIs if they need the combined functionality
    of multiple fine-grained API calls.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/011d8264-421a-4d64-b8b2-6569b9ff24a3.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts a logical structure of APIs with their granularities
    and how those APIs are consumed by the service clients, and it is an example of
    optimized APIs for the use case that we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design principle suggests that the API design should support the full process
    of the life cycle as a single window. For instance, in an e-commerce site, when
    a consumer purchases an item, they shouldn't have to go to the bank portal to
    check their balance or to make a payment, and perhaps it should be integrated
    within that same e-commerce portal. The API used by the e-commerce portal should
    cover the full process of the life cycle. Partial, unbaked APIs severely affect
    the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect to think about for APIs is to provide full coverage in today's
    financial world; as the rapid expansion of services in cash management, automatic
    transfers, stock exchange orders, and so on are inevitable, APIs are the perfect
    solution for interconnecting these third-party services and banking services.
  prefs: []
  type: TYPE_NORMAL
- en: The same entity life cycle modelling approach that we saw earlier in the section
    to identify service granularity will also help us to understand which services
    are necessary to support the full business process life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about unusual circumstances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the real world, there are some strange problems that can be solved only with
    specialized or proprietary technology. Those situations are unusual, and examples
    of those circumstances may arise in smart home platforms, IoT (fieldbus) implementations
    with standardized models for B2B, ebMS3/AS4 messaging, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are always situations and cases in the pragmatic REST service world where
    API designers will land in unusual circumstances and need some trade-offs for
    their API design, for example, enhancing legacy applications to RESTful service
    scenarios. Practically it isn't feasible to migrate the whole legacy software,
    especially in the case of propitiatory codes, and we call them special situations.
    However, there are design principles and patterns such as domain-driven design
    patterns that come in handy in those particular situations. These unusual or unique
    situations also come under design principles, and they advise APIs to provide
    specialized technologies only for such cases where it is absolutely necessary
    to solve a specific problem and not just because the situation is complicated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applicability Statement 4** (**AS4**) is an open standard protocol specification
    for the secure and payload-agnostic **business-to-business** (**B2B**) documents
    (OASIS ebMS) using web services.'
  prefs: []
  type: TYPE_NORMAL
- en: You're encouraged to refer the book [Architectural Patterns](https://www.packtpub.com/application-development/architectural-patterns)
    published by Packt. It has one dedicated chapter about **domain driven design**
    (**DDD**) patterns and discusses many DDD patterns in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Community standardization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following standards and naming conventions described by open consortiums make
    our APIs much more usable and interoperable. **Open Travel Alliance** (**OTA**)
    and **Open Geospatial Consortium** (**OGC**) are two examples of these consortiums.
  prefs: []
  type: TYPE_NORMAL
- en: The community standardization principle suggests that API implementations should
    be designed using industry standard information components when they are available.
    The iCalendar for calendar invites and events, vCard for the name and address
    information, and **Keyhole Markup Language** (**KML**) for geospatial data are
    a few examples of those well-defined standards our API can make the best use of.
  prefs: []
  type: TYPE_NORMAL
- en: API playgrounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API providers should develop and expose an associated website/developer portal,
    for developers to quickly get on board with their APIs. It serves the new clients
    with documentation, forums, and self-service provisioning with secure API access
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: APP developers learning about APIs and their offerings, not only with documentation
    but also with straightforward tools and techniques in an environment in which
    they can test and manipulate data in a controlled, monitored way, is of paramount
    importance and brings massive interest among developers to learn and use the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: An interactive and in-browser API playground is one of the best ways for potential
    users to identify the API endpoints and test their code to experience the API
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxes, virtualization, and API playgrounds are three different ways that
    API providers can attract app developers to play with the API functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: An API sandbox is a controlled environment in a limited area with specific rules
    and provides simple API calls. Virtualization is a mirror image of the real API
    and offers APP developers production-like environments to do more accurate testing.
    API playgrounds provide greater capabilities than the sandboxes, yet unlike virtualization,
    they come as a limited and controlled system emulation. API playgrounds are most
    suitable for developers to test and get more datasets out of the API; at the same
    time, the API providers also have better control of those environments.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful API design rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand the roles and responsibilities of an API designer, the
    API design best practices, and the API design core principles, we can cover one
    more essential API design aspect called the **rules of APIs**. The best practices
    and design principles are guidelines that API designers try to incorporate in
    their API design. However, the rules of API need to be amended in the API design
    to make our APIs RESTful. So, this section is dedicated to RESTful API rules such
    as  the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use of Uniform Resource Identifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URI authority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource modelling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource archetypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URI path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URI query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata design rules (HTTP headers and returning error codes) and representations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client concerns (versioning, security, and hypermedia processing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're confident that having a clear understanding of these rules will move us
    closer to design and begin our journey towards delivering the finest RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Uniform Resource Identifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'REST APIs should use **Uniform Resource Identifiers** (**URIs**) to represent
    their resources. The resource indications should be clear and straightforward
    so that they communicate the APIs resources crisp and clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: A sample of a simple to understand URI is `https://xx.yy.zz/sevenwonders/tajmahal/india/agra`,
    as you may observe that the emphasized texts clearly indicates the intention or
    representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A harder to understand URI is `https://xx.yy.zz/books/36048/9780385490627`;
    in this sample, the text after *books* is very hard for anyone to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So having simple, understandable representation in the URI is critical in RESTful
    API design.
  prefs: []
  type: TYPE_NORMAL
- en: The following section deals with many such URI aspects for RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: URI formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per RFC 3986, the syntax of the generic URI is `scheme "://" authority "/"
    path [ "?" query ] [ "#" fragment ]` and following are the rules for API designs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use forward slash (`/`) separator**: This is used to indicate the hierarchical
    relationship between resources, for example, `http://xx.yy.zz/shapes/polygons/quadrilaterals/squares`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t use a trailing forward slash**: A trailing forward slash in the URI
    doesn''t have any meaning and may create confusion, for example, `http://xx.yy.zz/shapes/polygons/`
    and  `http://api.examples.org/shapes/polygons` (note the trailing / at the end
    of the URI). REST API should neither expect trailing slash nor include them in
    the links that they provide to clients as responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use hyphens (**`*-*`**)**: Hyphens improve the readability of URI names,
    paths, and segments, and help clients to scan and interpret easily, for example,
    `https://xx.yy.zz/seven-wonders/taj-mahal/india/agra` (note the hyphen segregates
    the space between seven wonders and Taj Mahal).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid underscores (**`_`**)**: Designers should avoid _ (underscore) representation
    in the path, as the character *underscore* may be partially obscured or hidden
    while rendering on any visual cues due to computer fonts, for example, `https://xx.yy.zz/seven_wonders/taj_mahal/india/agra`
    (note that we can''t make out the underscore as its made as a hyperlink). It should
    use hyphens instead `https://xx.yy.zz/seven-wonders/taj-mahal/india/agra` (with
    a hyphen, it''s visible even if it is a hyperlink).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prefer all lowercase letters in a URI path**: API designers should give preference
    to lowercase letters over any other representations, as RFC 3986 defines URIs
    as case sensitive except for the scheme and host components. Some examples include, `http://xx.yy.zz/shapes/polygons`
    and  `HTTP://XX.YY.ZZ/shapes/polygons` are the same, while `http://xx.yy.zz/shapes/polygons`
    and `HTTP://XX.YY.ZZ/SHAPES/Polygons` are *not* the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not include file extensions**: As you know, a dot (`.`) prefixed after
    the filename denotes its file types. However, a URI shouldn''t use dots to represent
    any file extensions; instead, it should rely on media types communicated through
    a content-type header (refer to the *media types and media type design rules*
    section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST API URI authority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen different rules for URIs in general, we will discuss the authority
    *(*`scheme "://" authority "/" path [ "?" query ] [ "#" fragment ]`*)* portion
    of the REST API URI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use consistent sub-domain names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consistent sub-domain names for an API include the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The top-level domain and the first sub-domain names indicate the service owner
    and an example could be `baseball.restfulapi.org`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you see in `http://api.baseball.restfulapi.org`, the API domain should have
    `api` as part of its sub-domain
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consistent sub-domain names for a developer portal  include the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As we saw in the *API playgrounds* section, the API providers should have exposed
    sites for APP developers to test their APIs called a developer portal. So, by
    convention, the developer portal's sub-domain should have `developer` in it. An
    example of a sub-domain with the developer for a developer portal would be `http://developer.baseball.restfulapi.org`*.*
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource modelling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resource modeling is one of the primary aspects for API designers as it helps
    to establish the API's fundamental concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In an earlier section, we saw details about the URI; let's consider, in general,
    the URI path always convey REST resources, and each part of the URI is separated
    by a forward slash (`/`) to indicate a unique resource within it model's hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following sample URI designs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/accountbalance](https://api-test.lufthansa.com/v1/profiles/customers/accountbalance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each resource separated by a forward slash indicates an addressable resource,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles](https://api-test.lufthansa.com/v1/profiles)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com](https://api-test.lufthansa.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customers, profiles, and APIs are all unique resources in the preceding individual
    URI models. So, resource modelling is a crucial design aspect, and API designers
    need to think about the API resource model before they move on to designing URI
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: Resource archetypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each service provided by the API is an archetype, and they indicate the structures
    and behaviors of REST API designs. Resource modelling should start with a few
    fundamental resource archetypes, and usually, the REST API is composed of four
    unique archetypes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document**: The document is the base for a resource representation with a
    field and link-based structure. In the following, each sample URI represents unique
    document resources, and the first one is also called the doc-root or parent resource
    ( the API endpoint):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com](https://api-test.lufthansa.com)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles](https://api-test.lufthansa.com/v1/profiles)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/accountbalance](https://api-test.lufthansa.com/v1/profiles/customers/accountbalance)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection**: A collection is also a resource, and it is a directory of resources
    managed by the API providers or servers. If a collection allows creating a new
    resource, then the clients can add new resources to the collections. A collection
    resource decides the URIs of each contained or added resources. In the following,
    each URI sample found identifies a collection resource:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/accountbalance](https://api-test.lufthansa.com/v1/profiles/customers/accountbalance)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stores**: A store is a resource repository managed by the client. The store
    allows the API client to put resources in, choose URIs for the resources that
    get added, get them out, and delete them when it decides. (URI stores never generate
    a new URI, and it is the client who chooses when resources initially get added.)
    Some of the following examples of interaction show a user of a client program
    of a cart- and song-management API inserting a document resource named carts and
    playlists respectively against his/her user ID denoted by `{id}`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://api.example.com/cart-management/users/{id}/carts](http://api.example.com/cart-management/users/%7Bid%7D/carts)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://api.example.com/song-management/users/{id}/playlists](http://api.example.com/song-management/users/%7Bid%7D/playlists)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: Controller resources are similar to executable methods, with
    parameters and return values. REST API relies on controller resources to perform
    application-specific actions that do not come under any of the CRUD methods. Controller
    names should always appear as the last segment in a URI path, with no child resources
    to follow them in the hierarchy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /alerts/245245/resend` is an example of a controller resource that allows
    a client to resend an alert to a user'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: URI path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses rules relating to the design of meaningful URI paths
    (`scheme "://" authority "/" path [ "?" query ] [ "#" fragment ]`) portion of
    the REST API URIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the rules about URI paths:'
  prefs: []
  type: TYPE_NORMAL
- en: Use singular nouns for document names, for example, [https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use plural nouns for collections and stores:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collections**: [https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stores**: [https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/prefernces](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/prefernces)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As controller names represent an action, use a verb or verb phrase for controller
    resources. An example would be [https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/reset](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/reset).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do not use CRUD function names in URIs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Correct URI example**: `DELETE /users/1234`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incorrect URIs**: `GET /user-delete?id=1234`, `GET /user-delete /1234`, `DELETE
    /user-delete /1234`, and `POST /users/1234/delete`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: URI query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses rules relating to the design of the query (`scheme "://"
    authority "/" path [ "?" query ] [ "#" fragment ]`*)* portion of the REST API
    URIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The query component of the URI also represents the unique identification of
    the resource, and following are the rules about URI queries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the query to filter collections or stores:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of the limit in the query: `https://api.lufthansa.com/v1/operations/flightstatus/arrivals/ZRH/2018-05-21T06:30?limit=40`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the query to paginate collection or store results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example with the offset in the query: `https://api.lufthansa.com/v1/operations/flightstatus/arrivals/ZRH/2018-05-21T06:30?limit=40&offset=10`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A REST API doesn't suggest any special transport layer mechanisms, and all it
    needs is basic Hyper Text Transfer Protocol and its methods to represent its resources
    over the web. We will touch upon how REST should utilize those basic HTTP methods
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Request methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client specifies the intended interaction with well-defined semantic HTTP
    methods, such as `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD,` and `OPTIONS`.
    The following are the rules that an API designer should take into account when
    planning their design:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't tunnel to other requests with the `GET` and `POST` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `GET` method to retrieve a representation of a resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `HEAD` method to retrieve response headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `PUT` method to update and insert a stored resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `PUT` method to update mutable resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `POST` method to create a new resource in a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `POST` method for controller's execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `DELETE` method to remove a resource from its parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `OPTIONS` method to retrieve metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP specification defines standard status codes, and REST API can use the same
    status codes to deliver the results of a client request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The status code categories and a few associated REST API rules are as follows
    so that the APIs can apply those rules according to the process status:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1xx: Informational**: This provides protocol-level information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2xx: Success**: Client requests are accepted (successfully), as in the following
    examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200`: OK'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use for indicating client request success
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use to communicate the errors in the response body
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201`: Created'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply for successful resource creation
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`202`: Accepted'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use for reporting the successful asynchronous action
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`204`: No content'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When an API wants to send empty or no content in the response body
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3xx: Redirection**: Client requests are redirected by the server to the different
    endpoints to fulfil the client request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`301`: Moved Permanently'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use for relocated resources
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`302`: Found'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note not to use `302`, as it would create confusion among the developers
    related to the initiation of automatic redirections from the client
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`303`: See other'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply to refer the client to a different URI (in place of `302`, it's recommended
    the API should use `303`)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`304`: Not modified'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use so that the client can preserve bandwidth
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use in conjunction with conditional HTTP requests
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`307`: Temporarily redirect'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use to indicate to the clients to resubmit the request to another URI
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4xx: Client error**: Errors at client side:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400`: Bad request'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be used to indicate generic or nonspecific failures
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401`: Unauthorized'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply for unauthorized access from the client side or problem with the client
    credentials
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403`: Forbidden'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use to forbid access regardless of the authorization state
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use to enforce application-level permission (allowed to access only a few resources
    and not all the resources)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404`: Not found'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Must use when client request doesn't map to any of the API resources
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`405`: Method not allowed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use when the client accesses unintended HTTP methods
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Example read-only resource might only support `GET` and `HEAD` , and the client
    tried to use `PUT` or `DELETE`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that `405` response should be part of the Allow header *(Allow—`GET`.
    `POST`)*
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`406`: Not acceptable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Must use when the server can't serve the requested media type
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`409`: Conflict'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use for client violation of a resource state
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An example could be an API returns this error when the client tries to delete
    a non-empty store resource
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`412`: Precondition failed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use to support conditional operations. The client sends one or more preconditions
    in the request headers to indicate to the API to execute only those conditions
    that are satisfied; if not, the API should send a `412` error code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`415`: Unsupported media type'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be used when the API is not able to process the request's payload media
    type (indicated in the content-type request header)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5xx: Server error**: These relate to errors at server side:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500`: Internal server error'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use to report the API/server-side issues, and when it's certainly not the client's
    side fault
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section looks at the rules for metadata designs, including HTTP headers
    and media types.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might already know, HTTP specifications have a set of standard headers,
    through which a client can get information about a requested resource, and carry
    the messages that indicate its representations and may serve as directives to
    control intermediary caches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points suggest a few sets of rules conforming to the HTTP standard
    headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Should use content-type**: Client and servers rely on this header to indicate
    how to process the message''s body, as the value of the content-type specifies
    the form of the data contained in the request or response message body called
    **media types**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Should use content-length**: The client should know the size of the message
    body that it is about to read. The other benefit is that the client gets to know
    how large the response body is that it needs to download, without needing to download
    the whole response by making a `HEAD` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Should use last-modified in responses**: The response should specify the
    timestamp when the representational state of the required resource was modified
    or updated so that the client and cache intermediaries can rely on this header
    to determine the freshness of their local copies of a resource''s state representation.
    The last-modified header should be part of their requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Should use ETag in responses**: **Entity tag** (**ETag**) is an HTTP header
    that helps the client to identify a specific version of the resources they asked
    for. The server should always respond with the ETag as a header for the client `GET`
    requests. The value of the ETag is commonly a digest (hash value, for instance,
    MD5 hash) of the resource contents so that the server can identify whether the
    cached contents of the resources are different from the latest version of the
    resources. ETag differs from the last-modified header by the value (resource content
    as digest versus timestamp). This header value enables the client to choose whether
    or not to send the representation again by using `If-Non-Match` conditionals in
    the future `GET` requests. If the ETag value hasn''t changed, then the client
    can decide to save time and bandwidth by not sending the representation again
    in their subsequent `GET` requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stores must support conditional `PUT` requests**: REST API can support conditional
    `PUT` requests by relying on client requests with `If-Unmodified-Since`, and/or
    `If-Match` request headers. As the store resources use the `PUT` method for both
    inserts and updates, the REST API should know the client''s intent of the `PUT`
    requests. `PUT` is the same as `POST` except `PUT` is *idempotent. Please note
    that HTTP supports conditional requests with the `GET`, `POST` , and `DELETE`
    methods; this is an essential pattern for allowing writable REST APIs to help
    collaboration among API clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a RESTful service standpoint, the idempotent of a service call means the
    calls that the client makes produce the same results for all calls; that is, multiple
    requests from the clients produce the same effect as a single request. Please
    note that the same result or behavior is on the server. However, the response
    that the client receives may not be the same as the resource state may change
    between the requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should use the location to specify the URI of newly created resources (through**
    `PUT`**)**: In response to the successful creation of resources through collections
    or stores, the API should provide the location (URI) of the newly created resource
    as a response header. The location header can be part of the status code `202`
    response to direct the clients about the status of their asynchronous call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Should leverage HTTP cache headers**: This is to encourage caching, provide
    cache-control, Expires, and date-response headers to leverage caching at various
    levels, such as the API server side, **content delivery networks** (**CDN**),
    or even at the client''s network. Some examples are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cache-Control: max-age=90, must-revalidate` (`max-age` is in seconds)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`For HTTP 1.0 based caches,``Date: Tue, 29 Apr 2018 08:12:31 GMT``Expires:
    Fri, 04 May 2018 16:00:00 GMT`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To discourage caching, add cache-control headers with `no-cache` and `no-store`,
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For HTTP 1.0 legacy caches
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `Pragma—no-cache` and `Expires—0` header values
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: However, unless necessary, REST API should always provoke caching of responses,
    maybe by shorter duration instead of using a no-cache directive. So the clients
    get faster responses for frequent access requests by fetching the short-lived
    response copies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should use expiration headers with** `200` **("OK") responses**: Setting
    expiration caching headers in response to the successful `GET` and `HEAD` requests
    encourages caching at the client side. Please note that the `POST` method is also
    cacheable, and so don''t treat this method as non-cacheable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**May use expiration caching headers with 3xx and 4xx responses**: In addition
    to status code `200` (`"OK": successful responses`), the APIs can include caching
    headers for 3xx and 4xx responses, also known as negative caching. It helps the
    REST API server with a reduction in loads due to some redirection and error triggers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mustn''t use custom HTTP headers: **The primary purpose of custom HTTP headers
    is to provide additional information and troubleshooting tips for app developers;
    however, for some distinctive cases at the server side, it comes in handy unless
    those cases do not change the behavior of the HTTP methods. An example could be
    an API that makes use of the X-cache header to let app developers know whether
    the resource is delivered by the origin server or by the edge server. If the information
    that should go through a custom HTTP header is critical in that it needs an accurate
    interpretation of the request or response, then it is better for it to be included
    in the body of the request or response or in the URI used for that request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Media types and media type design rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the *Manipulation of Resources* section of [Chapter 1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml), *Introduction
    to the Basics of RESTful Architecture,* media types help to identify the form
    of the data in a request or response message body, and the content-type header
    value represents a media type also known as the **Multipurpose Internet Mail Extensions**
    (**MIME**) type.
  prefs: []
  type: TYPE_NORMAL
- en: Media type design influences many aspects of a REST API design, including hypermedia,
    opaque URIs, and different and descriptive media types so that app developers
    or clients can rely on the self-descriptive features of the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points discuss the rules of media type design in brief:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Uses application-specific media types**: REST APIs treat the body of an HTTP
    request or response as part of an application-specific interaction. While the
    request or response body is built with languages such as JSON or XML, it typically
    has semantics that requires special processing beyond merely parsing the language''s
    syntax. An example representation of such a REST API URI is [https://swapi.co/api/planets/1](https://swapi.co/api/planets/1)
    that responds to the `GET` requests with a representation of the *Star Wars* planet
    resource that''s formatted using JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports media type negotiations in case of multiple representations**: The
    client may require different formats and schema by submitting the desired media
    type as part of the `Accept` header, so the API should allow the clients to get
    the response in the desired format.Following is an example representation of the
    media type negotiations from `developer.atlassian.com` for the following `Accept`
    header:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the following curl execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can conclude the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Support media type selection using a query parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To support clients with simple links and debugging, REST APIs should support
    media type selection through a query parameter named accept, with a value format
    that mirrors that of the accept HTTP request header
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An example is REST APIs should prefer a more precise and generic approach as
    following media type, using the `GET` `https://swapi.co/api/planets/1/?format=json` query
    parameter identification over the other alternatives
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows OS users can use MobaXterm ([https://mobaxterm.mobatek.net/](https://mobaxterm.mobatek.net/))
    or any SSH clients that supports Unix commands.
  prefs: []
  type: TYPE_NORMAL
- en: Representations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, machine-readable description of a resource's current state with
    a request or response is a representation, and it can be in different formats.
    The following section discusses the rules for most common resource formats, such
    as JSON and hypermedia, and error types in brief.
  prefs: []
  type: TYPE_NORMAL
- en: Message body format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'REST API communications in the distributed environment are most often as a
    text-based format, and we will discuss the JSON text-format representation rules
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use JSON for resource representation and it should be well-formed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may use XML and other formats as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't create additional envelopes or any custom transport wrappers and leverage
    only HTTP envelopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hypermedia representation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have understood from [Chapter 1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml),
    *Introduction to the Basics of RESTful Architecture*, REST API clients can programmatically
    navigate using a uniform link structure as a HATEOAS response, and following are
    a few rules related to hypermedia representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot helps us to recollect from [Chapter 1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml),
    *Introduction to the Basics of RESTful Architecture,* the HATEOAS representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e7bbc3f-121f-43b4-9a1f-aa646b7bd01c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, it can help us to relate to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a consistent form to represent links, link relations, and link announcements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a self-linking representation in a response message body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the number of the advertised *entry point* or API URIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use links to advertise any resource actions in a state-sensitive manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Media type representation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `GET` request won't have a request body, and the response body is always a
    resource representation. So, for every client request, except for `GET` requests,
    the API should define the media type in the request body and response body. The
    API media type relates to features such as sorting, filtering, paginating, and
    linking. So, media type formats and schemas should be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Errors representation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Error status codes of HTTP methods (4xx and 5xx) can carry client-readable
    information in the response body. The following rules present consistent forms
    of errors and error responses:'
  prefs: []
  type: TYPE_NORMAL
- en: Errors and error responses should be consistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error types for generic and for common error conditions should also be consistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram depicts a sample JSON response and addresses how errors
    and error codes predominate in API responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65f87d9f-a696-4c8f-bbd0-dc4c60aa0534.png)'
  prefs: []
  type: TYPE_IMG
- en: Client concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know from the *API design best practices* section, the REST API clients in
    the REST API world are APP developers and REST APIs are designed to suit the needs
    of their client programs (APP developer code). This section deals with a set of
    REST API design principles to address common client concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A REST API is a collection of interlinked resources or resource models. The
    representational resources communicate their state through the versions. So versioning
    is one of the essential design principles, and we will look at the versioning
    of APIs before we state the rules for versioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'APIs should be versioned (increase the major version) when it undergoes a breaking
    change; breaking changes include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Response data changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response type changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing any part of the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'APIs should undergo version changes even when it involves minor or non-breaking
    modifications, such as adding new endpoints or new response parameters. Minor
    versions help to track the APIs'' small changes and assist in customer support,
    who may be receiving cached versions of data or may be experiencing other API
    issues. Following are a few of the rules about REST API versioning:'
  prefs: []
  type: TYPE_NORMAL
- en: Use new URIs to introduce new models or conceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use schemas for managing representational form versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make use of ETags to manage representational state versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general versioning practices follow schematic versioning ([https://semver.org/](https://semver.org/));
    however, the versioning practices in RESTful API attract lots of discussions,
    and please be aware that, as API designers, we may need to make decisions aligned
    with business needs and impacts.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'REST APIs may expose resources that contain secure information intended to
    be revealed only to restricted clients, and the following rules help to secure
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Use OAuth, an HTTP-based authorization protocol, to protect resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use API management solutions, such as reverse proxy, to protect resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've provided a sample implementation as an example in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Response representation composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When REST APIs evolve with new features, the client may require new resources
    from its supporting REST API. However, for many practical reasons, the client
    may need new resources from the REST API. So a REST API can provide a measure
    to control the composition of its response representations. It''s crucial that
    REST APIs maintain a consistent resource model design, so clients can benefit
    from the composite responses. The following two rules enable the client to tune
    the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: It should support partial response by using the query component of a URI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should embed linked resources by using the query component of a URI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For examples, you may refer back the *URI query* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Processing hypermedia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed earlier two hypermedia structures, link and link relation. They
    help clients to process the response structure using a consistent algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client should interact with a specific REST API response representation
    link. The following points discuss a simple flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The client processing program starts by looking up the link using its relation's
    name, and interacts with the link lookup using the appropriate HTTP request method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client code inspects the method field of the link's relation document resource
    and decides whether the content should be submitted in the request message body
    or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's most common that JavaScript clients wish to interact with REST APIs. However,
    there are restrictions imposed (sandboxed) by the web browsers same-origin, also
    known as **same domain policy**. It restricts the JavaScript client from accessing
    resources if the resources aren't from the same domain/own source. The URI scheme,
    host, and port components indicate whether the resource origin is from the same
    domain. The browsers impose the same-origin policy to prevent leaking of confidential
    user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in most cases, the REST API needs to provide multi-origin read/write
    access from JavaScript for its JavaScript clients, and we will see how the following
    rules enable such flexibility:'
  prefs: []
  type: TYPE_NORMAL
- en: Support multi-origin read access with **JSON with padding** (**JSONP**) from
    JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support **cross-origin resource sharing** (**CORS**) to provide multi-origin
    read/write access from JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of design strategies, we looked at what an API is and its importance
    for connecting devices with various other devices and technologies in the digitization
    era. We examined a few essential API design characteristics, such as affordance,
    leveraging, and maximizing existing web infrastructure, along with API design
    goals, such as consistency, simplification, flexible yet stable APIs, and how
    it is essential for an API designer to focus on the APP developers—the consumers
    of the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We also briefly discussed the role of an API designer and how they need to follow
    design principles and rules, so that they can create better RESTful APIs. We concluded
    this chapter by giving the necessary rules for RESTful APIs, along with some dos
    and don'ts.
  prefs: []
  type: TYPE_NORMAL
- en: So, we've set a strong foundation and the path for you to get your hands on
    API programming in our next two chapters as they deal with hands-on REST API programs
    implementations, with various RESTful API design patterns and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We encourage readers to refer to [https://www.packtpub.com/all](https://www.packtpub.com/all)
    for various reference materials and a vast collection of books on RESTful services
    and APIs.
  prefs: []
  type: TYPE_NORMAL
