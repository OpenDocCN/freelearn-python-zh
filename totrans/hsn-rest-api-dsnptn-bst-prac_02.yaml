- en: Design Strategy, Guidelines, and Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计策略、指南和最佳实践
- en: In the today's digitalized world, the challenges are about interconnecting various
    heterogeneous devices with abundant software services available across the internet
    and intranets. The **applicatio****n programmable interface** (**API**) is one
    of the most promising software paradigms to address a*nything*, *anytime*, *anywhere*,and
    *any device,* which is the one substantial need of the digital world at the moment.
    This chapter discusses how APIs and API designs help to address those challenges
    and bridge the gaps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今数字化世界中，挑战在于将各种异构设备与互联网和内网中丰富的软件服务相互连接。**应用程序编程接口**（**API**）是解决**任何**、**任何时间**、**任何地点**和**任何设备**的最有前途的软件范例之一，这是数字世界当前的一个基本需求。本章讨论了
    API 和 API 设计如何帮助解决这些挑战并弥合差距。
- en: This chapter discusses a few essential API design guidelines, such as consistency,
    standardization, reusability, and accessibility through REST interfaces, which
    could equip API designers with better thought processes for their API modeling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了一些基本的 API 设计指南，例如一致性、标准化、可重用性和通过 REST 接口的可访问性，这些可以帮助 API 设计者更好地思考他们的 API
    模型。
- en: 'The following are this chapter''s objectives:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的目标：
- en: Learning about REST API and its importance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 REST API 及其重要性
- en: Goals of RESTful API design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API 设计的目标
- en: API designer roles and responsibilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 设计师的角色和责任
- en: API design principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 设计原则
- en: RESTful API design rules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API 设计规则
- en: Also, this chapter intends to introduce a few traits and constituents of better
    REST API implementations along with a few common, but avoidable, mistakes of API
    strategies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章旨在介绍一些更好的 REST API 实现的特征和组成部分，以及一些常见但可避免的 API 策略错误。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is primarily intended to introduce readers to various RESTful design
    concepts involving design strategies and best practices; we expect that readers
    already have a basic understanding of software design concepts, client-server
    architecture, and basic data exchange formats, such as JSON and XML.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要旨在向读者介绍涉及设计策略和最佳实践的多种 RESTful 设计概念；我们期望读者已经对软件设计概念、客户端-服务器架构以及基本的数据交换格式（如
    JSON 和 XML）有基本的了解。
- en: We assume readers have a basic understanding of web architecture, HTTP methods,
    headers, and related client-server concepts. However, we strongly encourage our
    readers to refresh their knowledge of design principles such as SOLID, OO designs,
    enterprise integration, SOA, and microservice architecture fundamentals.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设读者对网络架构、HTTP 方法、头部以及相关的客户端-服务器概念有基本的了解。然而，我们强烈建议我们的读者刷新他们对设计原则（如 SOLID、面向对象设计、企业集成、SOA
    和微服务架构基础）的知识。
- en: Learning about REST API and its importance
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 REST API 及其重要性
- en: In the first chapter, we learned about RESTful principles such as client-server,
    statelessness, cacheable, and layered, and we'll recognize and apply those principles
    to the low-level yet functional APIs in this chapter. Also, we will learn RESTful
    API design strategies and best practices that can help us to meet the challenge
    of *any time**, anywhere, *and* any device*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们学习了 RESTful 原则，如客户端-服务器、无状态、可缓存和分层，我们将在本章中识别并应用这些原则到低级但功能性的 API 中。此外，我们还将学习
    RESTful API 设计策略和最佳实践，这些可以帮助我们应对**任何时间**、**任何地点**和**任何设备**的挑战。
- en: Let's think of an example—assume you're going to an event, where along with
    other activities there will be a screening of the film *Solo* (the latest in the
    *Star Wars* series), and you know that some of your friends joining the party
    aren't familiar with *Star Wars* and the earlier sequels. So being a tech geek,
    you wanted to help your friends with a simple mobile application that can send
    search results to your WhatsApp group as messages with details about *Star Wars*
    characters, lists of films, starships, and so on; also it sends messages when
    any of your friends ask for any specific information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子——假设你将参加一个活动，其中除了其他活动外，还将放映电影 *《索洛》*（*星球大战*系列中的最新作品），而你知道将参加派对的你的某些朋友对
    *《星球大战》* 和早期续集并不熟悉。所以作为一个技术极客，你想要通过一个简单的移动应用程序帮助你朋友，该应用程序可以将有关 *《星球大战》* 角色详情、电影列表、星际飞船等的信息以消息的形式发送到你的
    WhatsApp 群组；同时，当你的任何朋友请求任何特定信息时，它也会发送消息。
- en: But how can a standalone mobile application get data about *Star Wars*, how
    will it use WhatsApp to reply, how can we integrate three different systems (mobile,
    messaging, and data) and help your friends with their *Star Wars* queries?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一个独立的移动应用如何获取*星球大战*的数据，它将如何使用WhatsApp进行回复，我们如何将三个不同的系统（移动、消息和数据）集成，并帮助你的朋友解决他们的*星球大战*查询？
- en: Do we need to create a massive dataset of *Star Wars* by ourselves? How will
    the mobile app leverage WhatsApp messaging abilities to send star wars information?
    How can the message be a search string for our app? And we don't know yet how
    many more unknowns that we need to solve as part of the development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要自己创建一个庞大的*星球大战*数据集吗？移动应用将如何利用WhatsApp的消息功能来发送星球大战信息？消息如何成为我们应用的搜索字符串？我们还不清楚我们还需要解决多少未知的问题作为开发的一部分。
- en: And you think it would be great if the *Star Wars* dataset was readily available
    and searchable, and there should be an ability within WhatsApp to programmatically
    send messages to your friends.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为如果*星球大战*数据集可以随时可用并可搜索，那就太棒了，而且WhatsApp应该具备向朋友发送消息的编程能力。
- en: 'After some research say we found the following list of items that gave us the
    confidence to build a mobile app within a short time:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些研究，我们发现以下清单，这让我们有信心在短时间内开发出移动应用：
- en: A readily available dataset about *Star Wars* at SWAPI ([https://swapi.co/](https://swapi.co/))
    that the app can leverage, and, not only that, it also exposes a mechanism that
    we can search and get responses, so we have a solution for the dataset/data store
    about star wars
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SWAPI ([https://swapi.co/](https://swapi.co/))上关于*星球大战*的可用数据集，该应用可以利用，不仅如此，它还提供了一个我们可以搜索并获取响应的机制，因此我们有了关于星球大战数据集/数据存储的解决方案
- en: WhatsApp also provides out-of-the-box messaging capabilities that your program
    can use to send the messages
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WhatsApp还提供了现成的消息功能，你的程序可以使用它来发送消息
- en: 'With the preceding information, let''s put the following cues in sequence to
    visualize the app:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的信息，让我们将这些提示按顺序排列，以可视化该应用：
- en: A friend is asking about Beru on Whatsapp, and so the app picks it up.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个朋友在WhatsApp上询问关于Beru的事情，因此应用捕捉到了这个信息。
- en: The app uses [https://swapi.co/api/people/?search=beru](https://swapi.co/api/people/?search=beru).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用使用[https://swapi.co/api/people/?search=beru](https://swapi.co/api/people/?search=beru)。
- en: The SWAPI REST API sends a response to the app's request. The app creates a
    text with details about Beru from the received response.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SWAPI REST API向应用请求发送响应。应用根据收到的响应创建关于Beru的详细信息文本。
- en: The app builds a *click chat* API request and sends the message to the group.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用构建一个*点击聊天*API请求，并将消息发送到群组。
- en: '`https://api.whatsapp.com/send?text=<"Beru Whitesun Lars, born: ''47BBY'',
    she belongs to *Human* Species and from *Tatooine* Planet">`.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`https://api.whatsapp.com/send?text=<"Beru Whitesun Lars, born: ''47BBY'',
    she belongs to *Human* Species and from *Tatooine* Planet">`。'
- en: 'Your friend/groups receive the message—`Beru Whitesun Lars, born: "47BBY",
    she belongs to "Human" Species and from "Tatooine" Planet`.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '你的朋友/群组收到消息——`Beru Whitesun Lars, born: "47BBY", she belongs to "Human" Species
    and from "Tatooine" Planet`。'
- en: So, by having all necessary details about those REST APIs, you gain confidence
    to build a mobile app that helps you to send search results as a message to your
    WhatsApp group, and you are ready to rock the party. Interesting, isn't it?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过拥有所有必要的REST API详细信息，你将获得信心来构建一个移动应用，帮助你将搜索结果作为消息发送到WhatsApp群组，你准备好摇滚派对了。有趣，不是吗？
- en: So, now you know SWAPI and click chat ([http://api.whatsapp.com](http://api.whatsapp.com))
    are REST APIs and can be consumed by any applications as your mobile app consumes
    those APIs. With our example, can we say that the app is an attempt to address
    the digitization challenge of *any time, anywhere,* and* any device* with RESTful
    APIs?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你知道SWAPI和点击聊天([http://api.whatsapp.com](http://api.whatsapp.com))都是REST
    API，可以被任何应用消费，就像你的移动应用消费那些API一样。在我们的例子中，我们是否可以说该应用是尝试通过RESTful API解决*随时随地*和*任何设备*的数字化挑战？
- en: Google Maps and Locations, Apple iTunes, Google Books, UK police forces ([https://data.police.uk/api/forces](https://data.police.uk/api/forces)),
    sunrise and sunset timings ([https://sunrise-sunset.org/api](https://sunrise-sunset.org/api)),
    and the British National Bibliography ([http://bnb.data.bl.uk](http://bnb.data.bl.uk))
    are few examples of public APIs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps和位置、Apple iTunes、Google Books、英国警方([https://data.police.uk/api/forces](https://data.police.uk/api/forces))、日出和日落时间([https://sunrise-sunset.org/api](https://sunrise-sunset.org/api))以及英国国家书目([http://bnb.data.bl.uk](http://bnb.data.bl.uk))是公共API的几个例子。
- en: The REST API examples that we have so far are more reading operations. However,
    in reality, the APIs can do a lot more, and we will show how well we can design
    RESTful APIs that can support **create, read, update, and delete (CRUD**) operations,
    pagination, filtering, sorting, searching, and much more as you read through this
    book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的REST API示例主要是读取操作。然而，在现实中，API可以做得更多，我们将展示如何设计RESTful API，它能够支持**创建、读取、更新和删除（CRUD**）操作、分页、过滤、排序、搜索等等，正如您阅读这本书时所见。
- en: We encourage you to get to know various publicly available APIs, their purpose,
    response formats, and so on as it will help you to understand and follow the further
    discussions in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您了解各种公开可用的API，包括它们的目的、响应格式等内容，这将有助于您理解并跟进本章的后续讨论。
- en: Goals of RESTful API design
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API设计的目标
- en: From the API examples that we've seen so far, you might have observed that they're
    straightforward, unambiguous, easy to consume, well-structured, and most importantly
    accessible with well-known and standardized HTTP methods.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们迄今为止看到的API示例中，您可能已经注意到它们简单直接、明确、易于消费、结构良好，最重要的是，可以通过众所周知的标准化HTTP方法访问。
- en: 'By now, we have a fair understanding of the APIs, and that they are one of
    the best possible solutions for resolving many digitization challenges out of
    the box; with our earlier examples, we also know who is consuming those APIs.
    Now let''s ponder how we can create such usable APIs and expose them for consumption.
    Are there any basic and necessary principles for designing APIs that we must take
    into account even before we delve into API design? What should the API allow the
    consumers to do with it? What do the consumers want to do with it? To answer our
    questions, we will need to understand the following API design goals:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对API有了相当的了解，并且它们是解决许多数字化挑战的最佳解决方案之一；通过我们之前的示例，我们也知道谁在使用这些API。现在让我们思考如何创建这样的可用API并将其公开供消费。在深入API设计之前，我们是否必须考虑一些基本和必要的原则？API应该允许消费者做什么？消费者想用它做什么？为了回答我们的问题，我们需要了解以下API设计目标：
- en: Affordance
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便利性
- en: Loosely coupled
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合
- en: Leverage existing web architecture
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用现有的网络架构
- en: Let's discuss them in a bit more detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论一下。
- en: Affordance
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 便利性
- en: 'Let''s discuss a fundamental design concept called **affordance** as it can
    yield answers to the various questions that we had. Affordance means how an object
    and its properties are perceived by its design. Here it provides a clue about
    its operation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个基本的设计概念，称为**便利性**，因为它可以回答我们之前提出的各种问题。便利性意味着对象及其属性是如何被其设计所感知的。在这里，它提供了关于其操作的线索：
- en: '![](img/c8468786-89f1-446e-88ae-76bf0aecb188.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8468786-89f1-446e-88ae-76bf0aecb188.png)'
- en: The preceding diagram helps us to understand what affordance is in the design
    world that we're talking about; among the switches that we see, the first one
    represents a swivel operation, and another indicates an upward and downward operation.
    So, by merely seeing those objects, we can perceive what it supports and how.
    In the case of API design, affordance undoubtedly plays a crucial role, and it
    is an essential aspect of our API designs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表帮助我们理解我们所谈论的设计世界中的“便利性”是什么；在我们看到的开关中，第一个代表旋转操作，另一个表示上下操作。因此，仅通过观察这些物体，我们就能感知它们支持什么以及如何支持。在API设计的情况下，便利性无疑起着至关重要的作用，并且是我们API设计的一个基本方面。
- en: Loosely coupled
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合
- en: As the whole purpose of an API is to connect heterogeneous clients with the
    same backend code, it's inevitable that APIs should be as independent as possible
    and as loosely coupled as possible with the calling clients.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API的整个目的是将异构客户端与相同的后端代码连接起来，因此API尽可能地独立和尽可能地与调用客户端松散耦合是不可避免的。
- en: In a loosely coupled design, APIs are independent, and modifications in one
    won't impact the operation of consumers. Within an API, the components get added,
    modified, or replaced. However, the loose coupling approach offers clients better
    flexibility and reusability of APIs while its elements are added, replaced, or
    changed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散耦合的设计中，API是独立的，一个API的修改不会影响消费者的操作。在API内部，组件会被添加、修改或替换。然而，松散耦合的方法在组件被添加、替换或更改时，为客户端提供了更好的API灵活性和可重用性。
- en: Having a loosely coupled architecture in REST API server designs facilitates
    the client and server as both follow and respect common semantics. If the API
    modifies the meaning of its response, then the client needs to be aware of it
    and act on those new responses accordingly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST API服务器设计中采用松耦合架构，使得客户端和服务器都遵循并尊重共同的语义。如果API修改了其响应的含义，那么客户端需要意识到这一点，并相应地采取行动。
- en: Well-designed APIs exhibit loose coupling and well-composed functionalities
    across service boundaries to maximize scalability factors.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的API展现出跨服务边界松耦合和良好组成的函数，以最大化可扩展性因素。
- en: Leverage web architecture
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用网络架构
- en: Since its invention by Sir Tim Berners-Lee in 1989, the fundamentals of the
    web remain as the foundations of all web architecture even today. As you all know,
    HTTP is the lifeline of the web architecture, and it powers every single client
    request, server response, and transfer of a document/content over all of the web.
    So, it is imperative that REST APIs should embrace its bursting power by building
    interfaces that can be consumed by any device or operating system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 自1989年由蒂姆·伯纳斯-李爵士发明以来，网络的基本原理仍然是所有网络架构的基础，即使今天也是如此。正如你们所知，HTTP是网络架构的生命线，它为所有客户端请求、服务器响应以及整个网络上的文档/内容的传输提供动力。因此，确保REST
    API通过构建任何设备或操作系统都可以消费的接口来拥抱其强大的爆发力是至关重要的。
- en: RESTful APIs should use HTTP as a transport layer since the infrastructure,
    server and client libraries for HTTP are widely available already.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API应使用HTTP作为传输层，因为HTTP的基础设施、服务器和客户端库已经广泛可用。
- en: RESTful APIs should take advantage of HTTP methods, or verbs, such as `GET`,
    `PUT` and `POST` defined by the RFC 2616 protocol.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API应利用HTTP方法，或动词，如由RFC 2616协议定义的`GET`、`PUT`和`POST`。
- en: RFC 2616 ([https://tools.ietf.org/html/rfc2616](https://tools.ietf.org/html/rfc2616))
    defines Internet standards for HTTP (the application-level protocol for distributed,
    collaborative, and hypermedia information systems).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2616（[https://tools.ietf.org/html/rfc2616](https://tools.ietf.org/html/rfc2616)）定义了HTTP（分布式、协作和超媒体信息系统应用层协议）的互联网标准。
- en: API designer roles and responsibilities
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API设计者角色和责任
- en: Before we discuss API design goals, principles and practices, let's touch upon
    the primary roles of a software architect, solution architect, software designer,
    or anyone who's ready to take responsibility for designing RESTful APIs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论API设计目标、原则和实践之前，让我们简要谈谈软件架构师、解决方案架构师、软件设计师或任何准备承担设计RESTful API责任的角色的主要职责。
- en: 'To produce successful APIs, an API designer should have or do the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要生产出成功的API，API设计者应该具备或做以下事情：
- en: Be well-versed in REST fundamentals and API design best practices
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精通REST基础和API设计最佳实践
- en: Be acquainted with API design patterns to create a modern API design
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉API设计模式，以创建现代API设计
- en: Focus on the factors discussed in this chapter such as API design goals and
    best practices that can improve the application developer's experience
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注本章讨论的因素，例如API设计目标和最佳实践，这些可以改善应用程序开发者的体验
- en: Translate the business domain into several APIs by having a clear understanding
    of the business vision and its functions
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对业务愿景及其功能的清晰理解，将业务领域转换为几个API
- en: Closely work with API developers and help them with their day-to-day constraints
    and to deal with their existing legacy architecture
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与API开发者紧密合作，帮助他们处理日常限制，并处理他们现有的遗留架构
- en: Set up feedback loops that involve developer feedback sessions, prototypes,
    beta users, release, and versioning
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置涉及开发者反馈会议、原型、测试用户、发布和版本控制的反馈循环
- en: Use the feedback loops to incorporate acumens in their API design and move faster
    with API development
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反馈循环将经验融入他们的API设计中，并加快API开发速度
- en: Create best-in-class documentation, reusable code libraries, sample codes, and
    tutorials
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一流的文档、可重用代码库、示例代码和教程
- en: Now that we understand the API designer's roles and responsibilities, let's
    move on to how one can design successful APIs with some of the industry API best
    practices in the following section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们了解了API设计者的角色和责任，那么让我们继续讨论如何通过一些行业API最佳实践来设计成功的API。
- en: API design best practices
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API设计最佳实践
- en: Let's think about who the consumers of any web service APIs are. Will it be
    another system, another software application, or an end-user? Mostly, the consumers
    of the APIs are another software application or another system itself. So, we
    can conclude that the customers of any API will be the app developers who give
    life to the software make it purposeful and usable by their programming codes.
    So the APIs are heavily dependent on the application developers or app developers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下任何网络服务API的消费者是谁。会是另一个系统、另一个软件应用，还是最终用户？大多数情况下，API的消费者是另一个软件应用或另一个系统本身。因此，我们可以得出结论，任何API的客户将是那些赋予软件生命、使其通过编程代码变得有目的性和可用性的应用开发者。因此，API在很大程度上依赖于应用开发者或应用开发者。
- en: So application developers should be the primary focus of API design, and for
    them to consume the APIs, there should be defined and accessible business functions.
    Please do remember that without any application developer or app developers ready
    to use the API, the API will cease to exist.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用开发者应该是API设计的首要关注点，并且为了让他们能够使用API，应该定义并使业务功能可访问。请务必记住，如果没有任何应用开发者或应用开发者准备好使用API，该API将不复存在。
- en: 'The following is a list of best practices used by API designers to produce
    APIs that app developers like to use:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由API设计者使用的最佳实践列表，以产生应用开发者喜欢使用的API：
- en: Keep APIs simple and easy to use—simplified, friendly, and intuitive APIs always
    attract APP developers (clients for our API), get the best out of the APP developer,
    and make the APP developer's life more comfortable, less painful, and more productive.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持API简单易用——简化、友好和直观的API总是吸引应用开发者（我们API的客户端），最大限度地发挥应用开发者的潜力，使应用开发者的生活更加舒适、痛苦更少、更高效。
- en: Expose well-defined and instantly recognizable business functions.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供定义良好且易于识别的业务功能。
- en: Make APIs accessible with any standard web browsers—exposing APIs with existing
    web infrastructure (HTTPs `GET`, `POST`, `PUT` , and `DELETE`) and so accessible
    through a standard browser makes underlying APIs platform independent.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使API可通过任何标准网络浏览器访问——通过现有的网络基础设施（HTTPs `GET`、`POST`、`PUT`和`DELETE`）暴露API，并通过标准浏览器访问，使得底层API平台无关。
- en: Abstract service internals and domain models—the best APIs expose only URIs
    and payloads and not the service internals or domain models. An example is [https://www.googleapis.com/books/v1/volumes](https://www.googleapis.com/books/v1/volumes).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象服务内部和领域模型——最好的API只暴露URI和有效负载，而不暴露服务内部或领域模型。一个例子是[https://www.googleapis.com/books/v1/volumes](https://www.googleapis.com/books/v1/volumes)。
- en: Ensure RESTful API payloads don't have any traces of SOAP payloads as the clients
    are not the same (machines versus humans).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保RESTful API有效负载不包含任何SOAP有效负载的痕迹，因为客户端不同（机器与人类）。
- en: Be consistent—API implementations should be free from variation or contradiction;
    carry consistency across APIs by setting clear standards to help consumers with
    what to expect from the API, and implement similar behaviours such as searching
    and filtering (or pagination and limits) in the same way.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持一致性——API实现应无变化或矛盾；通过设定明确的标准，帮助消费者了解从API中可以期待什么，并在API中实施类似的行为，如搜索和过滤（或分页和限制）。
- en: Implement the standard URL pattern—an example of the standard URL pattern is `/collection/item/collection/item` ,
    and the `/collection` can be books, dogs, events (plural), and so on.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现标准URL模式——标准URL模式的一个例子是`/collection/item/collection/item`，其中`/collection`可以是书籍、狗、事件（复数）等等。
- en: Exercise standard terminology—following standard and meaningful elements in
    the URI is critical for API success. An example of standard terminology would
    be `bookId`, `dogId` and `eventId`, and not `bId`, `dId` and `eId`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习标准术语——在URI中遵循标准和有意义的元素对于API的成功至关重要。标准术语的一个例子是`bookId`、`dogId`和`eventId`，而不是`bId`、`dId`和`eId`。
- en: Be flexible—APIs are flexible to accept input from clients. An example would
    be `/planner/v1/tasks or /planner/v1/Tasks or /planner/v1/TASKS`; lowercase, uppercase,
    or camel case in the preceding example should be acceptable and should behave
    in the same way.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持灵活性——API能够接受来自客户端的输入。一个例子是`/planner/v1/tasks`或`/planner/v1/Tasks`或`/planner/v1/TASKS`；在上面的例子中，小写、大写或驼峰式命名法应该是可接受的，并且应该以相同的方式表现。
- en: Be stable—incremental modifications to the APIs are inevitable, but it should
    be independent of the client applications. In other words, no forced amendments
    to the clients who consume the APIs that undergo modifications. Say, `/books/v1/volumes` involves
    no changes to the clients and provide additional benefits/defect fixes when the
    volume module goes through some changes.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持稳定——API的增量修改是不可避免的，但它应该独立于客户端应用程序。换句话说，不应该对使用经过修改的API的客户端进行强制修改。比如说，`/books/v1/volumes`不涉及对客户端的任何更改，当体积模块经过一些更改时，提供额外的利益/缺陷修复。
- en: There should be a clear handle for errors and error messages—API implementations
    shouldn't just provide better business functions; it is critical that it handles
    the errors and error messages well to help clients with useful and human-readable
    error messages, including diagnostic information that can be understood by the
    app developer, as error messages give hints and assist the APP developers to resolve
    issues that may otherwise result in an error.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个清晰的错误处理和错误消息处理机制——API实现不仅应该提供更好的业务功能；它处理错误和错误消息的能力至关重要，它应该提供有用且易于理解的错误消息，包括应用程序开发者可以理解的诊断信息，因为错误消息提供了提示并帮助应用程序开发者解决可能导致的错误。
- en: Documentation—APIs are discoverable and documented, so publishing the API documentation
    is a must. API documentation includes a getting-started guide, sample codes, sample
    requests, sample responses, sample implementations, elaborate explanations about
    authentication and error handling, information about feedback avenues, and so
    forth.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档——API是可发现和有文档记录的，因此发布API文档是必须的。API文档包括入门指南、示例代码、示例请求、示例响应、示例实现、关于认证和错误处理的详细说明、关于反馈途径的信息等等。
- en: Provide feedback and support mechanism for API users.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为API用户提供反馈和支持机制。
- en: Would it be good to have API design practices so you can jump-start the API
    design? No, not yet. We need to get to know about a few core API design principles,
    which we will review next.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有API设计实践会很好，这样你就可以快速启动API设计？不，还不是时候。我们需要了解一些核心的API设计原则，我们将在下一部分回顾。
- en: API design principles
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API设计原则
- en: 'To create flexible, scalable, and secure APIs, an API designer needs a set
    of guidelines. We''ll discuss the following essential principles:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建灵活、可扩展和安全的API，API设计者需要一套指导方针。我们将讨论以下基本原则：
- en: Ubiquitous web standards
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普遍的网络标准
- en: API flexibility
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API灵活性
- en: API standardization
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API标准化
- en: API optimization
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API优化
- en: API granularity
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API粒度
- en: API sandbox or playground
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API沙盒或游乐场
- en: By doing so, we will be able to understand how following them will help us to
    design high-quality RESTful APIs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将能够理解遵循这些原则将如何帮助我们设计高质量的RESTful API。
- en: Ubiquitous web standards
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 普遍的网络标准
- en: As we discussed in the *Goals of RESTful API design* section, API designers
    should embrace the existing web standards and develop their API design and platforms,
    resulting in ubiquitous communication between the RESTful APIs and clients.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*RESTful API设计目标*部分所讨论的，API设计者应该采用现有的网络标准，并开发他们的API设计和平台，从而实现RESTful API和客户端之间的普遍通信。
- en: 'Let''s ask ourselves a few questions that will help us to derive better design
    principles for our APIs:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提出一些问题，这些问题将帮助我们为我们的API推导出更好的设计原则：
- en: Who will be consuming our APIs?
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁将使用我们的API？
- en: What are the business functions that the API needs to support?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API需要支持哪些业务功能？
- en: How granular should the API be?
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API应该有多细粒度？
- en: Should APIs always stick to the existing web standards and provide consistency?
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API是否应该始终遵循现有的网络标准并提供一致性？
- en: 'The REST architecture style insists on embracing the existing web standards
    and so leveraging those standards should be the primary focus of any API design.
    The following diagram depicts a few common web methods, namely, `GET`, `POST`,
    `PUT` and `DELETE` , and the interactions with **REST API** by the clients:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: REST架构风格坚持采用现有的网络标准，因此利用这些标准应该是任何API设计的首要关注点。以下图表展示了几个常见的网络方法，即`GET`、`POST`、`PUT`和`DELETE`，以及客户端与**REST
    API**的交互：
- en: '![](img/0ce6ae6b-a64e-4f43-a11b-7917e3d422b0.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ce6ae6b-a64e-4f43-a11b-7917e3d422b0.png)'
- en: 'After web methods, there are few essential design aspects that APIs should
    adhere to, and they address the questions about standardization, consumers of
    API, and API consistency as well:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络方法之后，还有一些基本的设计方面，API应该遵守，它们解决了关于标准化、API消费者和API一致性的问题：
- en: Any application client should be able to use the API ideally without having
    to refer to much documentation
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何应用程序客户端都应该能够在不参考大量文档的情况下理想地使用API
- en: Use standard HTTP method call-outs, available on every language and platform,
    to make requests and retrieve information from APIs
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准HTTP方法调用，在每种语言和平台上都可用，来向API发送请求和检索信息
- en: Don't make any assumptions about the software development technologies used
    by consumer applications
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要对消费者应用使用的软件开发技术做出任何假设
- en: Web protocol HTTP and responses such as JSON or ATOM help API clients to find
    a library that connects to any language or platform
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络协议HTTP以及JSON或ATOM等响应有助于API客户端找到连接到任何语言或平台的库
- en: Flexibility
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活性
- en: The data from the API should be independent of resources or methods. It implies
    REST API should handle multiple types of calls and return various data formats,
    even with some change in the structure representing hypermedia. In other words,
    the data of the API response isn't tied to the resources or methods.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: API的数据应独立于资源或方法。这意味着REST API应处理多种类型的调用并返回各种数据格式，即使超媒体表示的结构有所变化。换句话说，API响应的数据不绑定到资源或方法。
- en: The GitHub API summary representations and detailed representations may be examples
    of API flexibility. List of repository API `GET /orgs/myorg/repos` gets the summary
    representation, and single repository API `GET /repos/myorg/myhelloworld.rb` fetches
    the detailed description of the indicated repository.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub API的摘要表示和详细表示可能是API灵活性的示例。仓库API `GET /orgs/myorg/repos` 获取摘要表示，而单个仓库API
    `GET /repos/myorg/myhelloworld.rb` 获取指定仓库的详细描述。
- en: The Salesforce API provides flexibility with its response formats, so API developers
    can serialize the data in either XML or JSON format.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Salesforce API通过其响应格式提供灵活性，因此API开发者可以将数据序列化为XML或JSON格式。
- en: 'GraphQL endpoint implementation for API developers is another best example
    of API flexibility. With GraphQL, developers can request the data that they want
    based on a predefined schema and so the API can respond according to the predefined
    schema:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为API开发者实现的GraphQL端点实现是API灵活性的另一个最佳示例。使用GraphQL，开发者可以根据预定义的模式请求他们想要的数据，因此API可以按照预定义的模式进行响应：
- en: '![](img/b6bdcc86-0241-4d6b-b58e-0d93164f8be9.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6bdcc86-0241-4d6b-b58e-0d93164f8be9.png)'
- en: The preceding screenshot reflects a sample GraphQL request (schema) for specific
    fields (book name and rating) and response with specified fields.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图反映了针对特定字段（书名和评分）的样本GraphQL请求（模式）和指定字段的响应。
- en: Granularity
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒度
- en: '**Granularity** is an essential principle of REST API design. As we understand
    business functions divided into many small actions are fine-grained, then business
    functions divided into large operations are coarse-grained. However, discussions
    about what level of granularity that needs to be in APIs may vary; we will get
    distinct suggestions and even end up in debates. Regardless, it is best to decide
    based on business functions and its use cases, as granularity decisions would
    undoubtedly vary on a case by case basis.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**粒度**是REST API设计的基本原则。正如我们所理解的，将业务功能划分为许多小的动作是细粒度的，那么将业务功能划分为大操作则是粗粒度的。然而，关于API需要达到何种粒度级别的讨论可能会有所不同；我们可能会得到不同的建议，甚至陷入辩论。无论如何，最好基于业务功能和其用例来决定，因为粒度决策无疑会根据具体情况而有所不同。'
- en: In some cases, calls across the network may be expensive and so, to minimize
    them a coarse-grained API may be the best fit, as each request from the client
    forces lot of work at the server side and, in fine-grained APIs, many calls are
    required to do the same amount of work at the client side.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，网络调用可能很昂贵，因此，为了最小化这些调用，粗粒度API可能是最佳选择，因为客户端的每个请求都会在服务器端强制执行大量工作，而在细粒度API中，需要许多调用才能在客户端完成相同的工作量。
- en: Consider the following example. A service returns customer orders (say *n* orders)
    in a single call; this is a coarse-grained API in action. In case of fine-grained,
    it returns only the customer IDs, and for each customer ID, the client needs to
    make an additional request to get details, so *n+1* calls need to be made by the
    clients; these may be expensive round trips regarding its performance and response
    times over the network.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。一个服务在一次调用中返回客户订单（例如*n*个订单）；这是粗粒度API的实际应用。在细粒度的情况下，它只返回客户ID，而对于每个客户ID，客户端需要额外发起一个请求以获取详细信息，因此客户端需要发起*n+1*次调用；这可能是在性能和网络响应时间上昂贵的往返调用。
- en: In a few other cases, APIs should be designed at the lowest practical level
    of granularity, because combining them is possible and allowed in ways that suit
    customer needs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他一些情况下，API应该设计在最低的实际粒度级别，因为可以通过满足客户需求的方式将它们组合起来。
- en: Now, check out this example, an electronic form submission may need to collect
    an address as well as, say, tax information. In this case, there are two functions
    one is a collection of the applicant's whereabouts, and another is a collection
    of tax details. Each task needs to be addressed with distinct API and requires
    a separate service because an address change is logically a different event and
    not related to tax time reporting, that is, why one needs to submit the tax information
    (again) for an address change.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看这个例子，电子表单提交可能需要收集地址以及，比如说，税务信息。在这种情况下，有两个功能：一个是收集申请人的位置信息，另一个是收集税务详细信息。每个任务都需要通过不同的API来处理，并需要单独的服务，因为地址变更在逻辑上是一个不同的事件，与税务时间报告无关，也就是说，为什么在地址变更时需要再次提交税务信息。
- en: Level of granularity should satisfy the specific needs of the business functions
    or use cases. While the goal is to minimize the calls across the network and for
    better performance, understanding the set of operations that API consumers require
    and how they would give a better idea of the right grained APIs in our designs is
    important.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 粒度级别应该满足业务功能或用例的特定需求。虽然目标是最大限度地减少网络调用并提高性能，但了解API消费者需要的操作集以及这些操作如何有助于我们设计中的正确粒度API是很重要的。
- en: Say internal services consumers for those who multiple calls to the API servers
    are acceptable and those APIs can be designed as fine-grained, and the external
    consumers and if they need to avoid several round-trips to the API then plan as
    coarse-grained.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于那些可以接受多次调用API服务器的内部服务消费者，这些API可以设计为细粒度，而对于外部消费者，如果他们需要避免多次往返API，则可以设计为粗粒度。
- en: At times it may be appropriate that the API design supports both coarse-grained
    as well as fine-grained to give the flexibility for the API developers to choose
    the right APIs for their use cases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，API设计可能需要同时支持粗粒度和细粒度，以给API开发者提供灵活性，让他们为他们的用例选择正确的API。
- en: 'The following points may serve as some basic guidelines for the readers to
    decide their API granularity levels in their API modelling:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点可以作为读者决定他们在API建模中的API粒度级别的一些基本指南：
- en: In general, consider services coarse-grained and APIs fine-grained.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，将服务视为粗粒度，将API视为细粒度。
- en: Maintain a balance between the amount of response data and the number of resources
    required to provide that data will help to decide the granularity.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在响应数据量和提供这些数据所需资源数量之间保持平衡，将有助于决定粒度。
- en: The types of performed operations on the data should also be considered as part
    of the design when defining the granularity.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义粒度时，还应考虑在数据上执行的操作类型。
- en: Read requests are normally coarse-grained. Returning all information as required
    to render the page won't hurt as much as two separate API calls in some cases.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取请求通常是粗粒度的。在某些情况下，返回所有必要的信息以渲染页面不会像两次单独的API调用那样造成太大的伤害。
- en: On the other hand, write requests must be fine-grained. Find out common operations
    clients need, and provide a specific API for that use case.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，写入请求必须是细粒度的。找出客户端需要的常见操作，并为该用例提供特定的API。
- en: At times, you should use medium-grained, that is, neither fine-grained or coarse-grained.
    An example could be as seen in the following sample where the nested resources
    are within two levels deep.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，你应该使用中等粒度，也就是说，既不是细粒度也不是粗粒度。以下示例中，嵌套资源位于两层深度内。
- en: 'Consider the following snapshot that reflects a medium-grained API response:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下快照，它反映了一个中等粒度的API响应：
- en: '![](img/a37e2d13-dd63-47a5-a15f-926d13d9be9b.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a37e2d13-dd63-47a5-a15f-926d13d9be9b.png)'
- en: Let's conclude this section with a broad guideline that helps to determine the
    right service granularity—identify the vital business entities that the service
    impacts and model the life cycles accordingly; that is, there should be only one
    API operation for one business outcome.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个广泛的指导方针来结束本节，这个指导方针有助于确定正确的服务粒度——识别服务影响的关键业务实体，并相应地建模生命周期；也就是说，对于每一个业务结果，应该只有一个API操作。
- en: The preceding guideline may lead to a number of API deployment units, and this
    can cause annoyances down the line. There are patterns, especially the API gateway,
    which brings a better orchestration with those numerous APIs. Orchestrating the
    APIs with optimized endpoints, request collapsing, and much more helps in addressing
    granularity challenges.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的指南可能导致许多API部署单元，这可能会在后续造成不便。有一些模式，特别是API网关，可以更好地协调这些众多的API。通过优化端点、请求合并等方式协调API有助于解决粒度挑战。
- en: Optimized APIs
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化API
- en: This section discusses adopting better optimization for the API. There's no
    concept of one-size-fits-all. In the real world, multiple APIs may support the
    same service as that service might be serving different types of users and use
    cases. As we quoted earlier in this chapter, the API should be modeled after the
    design according to the use case it fulfils and not by the backend services or
    applications it exposes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了为API采用更好的优化方法。没有一种适合所有情况的方案。在现实世界中，多个API可能支持相同的服务，因为该服务可能服务于不同类型的用户和用例。正如我们在本章前面引用的那样，API应根据其满足的用例进行建模，而不是根据其暴露的后端服务或应用程序。
- en: So optimization applies to a specific business request in a particular context.
    Let's take an example, a web service enables its mobile app consumers to clear
    electricity bills. In the context of the mobile, the constraints of mobile application
    should be our primary consideration, as a mobile app is sensitive to network latency,
    numerous network trips, the size of the data compared to a standard web application,
    and so on. So, our API design should focus on limiting the backend calls and minimize
    the size of the data returned.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，优化适用于特定上下文中的特定业务请求。让我们以一个例子来说明，一个网络服务允许其移动应用用户支付电费。在移动应用的环境中，我们应该首先考虑移动应用的限制，因为移动应用对网络延迟、多次网络请求、数据大小与标准网络应用相比等因素都很敏感。因此，我们的API设计应侧重于限制后端调用并最小化返回的数据大小。
- en: Concerning granularity, let's consider the preceding example will consume few
    fine-grained independently invokable APIs. On the other hand, to make the payment,
    the app may need to use a coarse-grained API from another service (which, in turn,
    may have many fine-grained APIs). So, our mobile app can use a few other fine-grained
    APIs directly to fetch the due amount, get the user address, and access account
    details of the bank that the user wants to use to pay the outstanding amount,
    and may even need more fine-grained APIs to be incorporated in future and so on.
    So, designers should consider the layered or tiered approach that we discussed
    in [Chapter 1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml), *Introduction to the
    Basics of RESTful Architecture,* to orchestrate and manage those fine-grained
    APIs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 关于粒度，让我们考虑前面的例子将消耗少量细粒度的独立可调用API。另一方面，为了进行支付，应用程序可能需要使用来自另一个服务的粗粒度API（该服务本身可能包含许多细粒度API）。因此，我们的移动应用可以直接使用一些其他细粒度API来获取应付款项、获取用户地址以及访问用户想要用来支付未付款项的银行的账户详情，甚至可能需要在未来集成更多细粒度API等。因此，设计者应考虑我们在[第1章](ce158181-8265-4afb-b858-348cc775d6d8.xhtml)中讨论的分层或分层方法，以协调和管理这些细粒度API。
- en: So, API designs can expose fine-grained APIs for consumers who can access them
    directly, and coarse-grained services on top of them would support broader use
    cases, so that the service clients may decide to call the fine-grained APIs directly,
    or they may decide to use the coarse-grained APIs if they need the combined functionality
    of multiple fine-grained API calls.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，API设计可以公开细粒度的API供消费者直接访问，并在其之上提供粗粒度的服务，以支持更广泛的使用案例，这样服务客户端可以选择直接调用细粒度API，或者如果他们需要多个细粒度API的合并功能，他们可以选择使用粗粒度API。
- en: '![](img/011d8264-421a-4d64-b8b2-6569b9ff24a3.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/011d8264-421a-4d64-b8b2-6569b9ff24a3.png)'
- en: The preceding diagram depicts a logical structure of APIs with their granularities
    and how those APIs are consumed by the service clients, and it is an example of
    optimized APIs for the use case that we discussed earlier.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图展示了API的逻辑结构及其粒度，以及这些API是如何被服务客户端消费的，这是我们之前讨论的使用案例的优化API示例。
- en: Functionality
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性
- en: This design principle suggests that the API design should support the full process
    of the life cycle as a single window. For instance, in an e-commerce site, when
    a consumer purchases an item, they shouldn't have to go to the bank portal to
    check their balance or to make a payment, and perhaps it should be integrated
    within that same e-commerce portal. The API used by the e-commerce portal should
    cover the full process of the life cycle. Partial, unbaked APIs severely affect
    the user experience.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计原则表明，API设计应该支持生命周期作为一个单一窗口的完整过程。例如，在电子商务网站上，当消费者购买商品时，他们不应该需要去银行门户网站检查余额或进行支付，也许它应该集成在同一电子商务门户网站内。电子商务门户网站使用的API应该涵盖生命周期的全过程。部分或未完成的API会严重影响用户体验。
- en: Another aspect to think about for APIs is to provide full coverage in today's
    financial world; as the rapid expansion of services in cash management, automatic
    transfers, stock exchange orders, and so on are inevitable, APIs are the perfect
    solution for interconnecting these third-party services and banking services.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于APIs来说，另一个需要考虑的方面是在当今金融世界中提供全面覆盖；随着现金管理、自动转账、证券交易所订单等服务领域的快速扩张，APIs是连接这些第三方服务和银行服务的完美解决方案。
- en: The same entity life cycle modelling approach that we saw earlier in the section
    to identify service granularity will also help us to understand which services
    are necessary to support the full business process life cycle.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中看到的用于识别服务粒度的相同实体生命周期建模方法，也有助于我们了解哪些服务是支持完整业务流程生命周期所必需的。
- en: Learning about unusual circumstances
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解不寻常情况
- en: In the real world, there are some strange problems that can be solved only with
    specialized or proprietary technology. Those situations are unusual, and examples
    of those circumstances may arise in smart home platforms, IoT (fieldbus) implementations
    with standardized models for B2B, ebMS3/AS4 messaging, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，有一些只能通过专用或专有技术解决的问题。这些情况是不寻常的，那些情况的一些例子可能出现在智能家居平台、具有标准化B2B模型的物联网（现场总线）实施、ebMS3/AS4消息等场景中。
- en: There are always situations and cases in the pragmatic REST service world where
    API designers will land in unusual circumstances and need some trade-offs for
    their API design, for example, enhancing legacy applications to RESTful service
    scenarios. Practically it isn't feasible to migrate the whole legacy software,
    especially in the case of propitiatory codes, and we call them special situations.
    However, there are design principles and patterns such as domain-driven design
    patterns that come in handy in those particular situations. These unusual or unique
    situations also come under design principles, and they advise APIs to provide
    specialized technologies only for such cases where it is absolutely necessary
    to solve a specific problem and not just because the situation is complicated.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在实用REST服务世界中，总会有一些情况，API设计者会遇到不寻常的情况，需要为他们的API设计做出一些权衡，例如，将遗留应用程序迁移到RESTful服务场景。实际上，迁移整个遗留软件是不切实际的，特别是在专有代码的情况下，我们将这些情况称为特殊情况。然而，在那些特定情况下，有一些设计原则和模式，如领域驱动设计模式，会派上用场。这些不寻常或独特的情况也属于设计原则范畴，它们建议API只为绝对必要解决特定问题的案例提供专门技术，而不仅仅是因为情况复杂。
- en: '**Applicability Statement 4** (**AS4**) is an open standard protocol specification
    for the secure and payload-agnostic **business-to-business** (**B2B**) documents
    (OASIS ebMS) using web services.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**适用性声明4**（**AS4**）是一个使用Web服务的开放标准协议规范，用于安全且与有效载荷无关的**企业到企业**（**B2B**）文档（OASIS
    ebMS）。'
- en: You're encouraged to refer the book [Architectural Patterns](https://www.packtpub.com/application-development/architectural-patterns)
    published by Packt. It has one dedicated chapter about **domain driven design**
    (**DDD**) patterns and discusses many DDD patterns in detail.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您参考由Packt出版的书籍[架构模式](https://www.packtpub.com/application-development/architectural-patterns)，其中有一章专门介绍**领域驱动设计**（**DDD**）模式，并详细讨论了许多DDD模式。
- en: Community standardization
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社区标准化
- en: Following standards and naming conventions described by open consortiums make
    our APIs much more usable and interoperable. **Open Travel Alliance** (**OTA**)
    and **Open Geospatial Consortium** (**OGC**) are two examples of these consortiums.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循由开放联盟描述的标准和命名约定，使我们的APIs更加易于使用和互操作性。**开放旅行联盟**（**OTA**）和**开放地理空间联盟**（**OGC**）是这些联盟的例子。
- en: The community standardization principle suggests that API implementations should
    be designed using industry standard information components when they are available.
    The iCalendar for calendar invites and events, vCard for the name and address
    information, and **Keyhole Markup Language** (**KML**) for geospatial data are
    a few examples of those well-defined standards our API can make the best use of.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 社区标准化原则建议，当可用时，API实现应使用行业标准信息组件进行设计。例如，iCalendar用于日历邀请和事件，vCard用于姓名和地址信息，**Keyhole
    Markup Language** (**KML**)用于地理空间数据，这些都是我们API可以充分利用的明确定义的标准。
- en: API playgrounds
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API游乐场
- en: API providers should develop and expose an associated website/developer portal,
    for developers to quickly get on board with their APIs. It serves the new clients
    with documentation, forums, and self-service provisioning with secure API access
    keys.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: API提供商应开发和公开一个相关的网站/开发者门户，以便开发者可以快速了解他们的API。它为新客户提供文档、论坛和带有安全API访问密钥的自助服务。
- en: APP developers learning about APIs and their offerings, not only with documentation
    but also with straightforward tools and techniques in an environment in which
    they can test and manipulate data in a controlled, monitored way, is of paramount
    importance and brings massive interest among developers to learn and use the APIs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: APP开发者了解API及其提供的内容，不仅通过文档，而且通过在可以以受控、监控的方式测试和操作数据的环境中使用的简单工具和技术，这一点至关重要，并在开发者中引发了巨大的兴趣去学习和使用API。
- en: An interactive and in-browser API playground is one of the best ways for potential
    users to identify the API endpoints and test their code to experience the API
    behavior.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个交互式且在浏览器中的API游乐场是潜在用户识别API端点和测试其代码以体验API行为的最有效方式之一。
- en: Sandboxes, virtualization, and API playgrounds are three different ways that
    API providers can attract app developers to play with the API functionalities.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒、虚拟化和API游乐场是API提供商吸引应用开发者体验API功能的三种不同方式。
- en: An API sandbox is a controlled environment in a limited area with specific rules
    and provides simple API calls. Virtualization is a mirror image of the real API
    and offers APP developers production-like environments to do more accurate testing.
    API playgrounds provide greater capabilities than the sandboxes, yet unlike virtualization,
    they come as a limited and controlled system emulation. API playgrounds are most
    suitable for developers to test and get more datasets out of the API; at the same
    time, the API providers also have better control of those environments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: API沙盒是一个在特定区域内具有特定规则的控制环境，提供简单的API调用。虚拟化是真实API的镜像，为APP开发者提供类似生产环境的测试环境。API游乐场比沙盒提供更多功能，但与虚拟化不同，它们是一个有限的、受控的系统模拟。API游乐场最适合开发者测试并从API中获得更多数据集；同时，API提供商对这些环境也有更好的控制。
- en: RESTful API design rules
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API设计规则
- en: 'Now that we understand the roles and responsibilities of an API designer, the
    API design best practices, and the API design core principles, we can cover one
    more essential API design aspect called the **rules of APIs**. The best practices
    and design principles are guidelines that API designers try to incorporate in
    their API design. However, the rules of API need to be amended in the API design
    to make our APIs RESTful. So, this section is dedicated to RESTful API rules such
    as  the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了API设计师的角色和职责、API设计最佳实践和API设计核心原则，我们可以再覆盖一个重要的API设计方面，即称为**API规则**。最佳实践和设计原则是API设计师试图在其API设计中融入的指南。然而，API规则需要在API设计中进行调整，以使我们的API符合RESTful风格。因此，本节专门介绍以下RESTful
    API规则：
- en: Use of Uniform Resource Identifiers
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一资源标识符的使用
- en: URI authority
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI权限
- en: Resource modelling
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源建模
- en: Resource archetypes
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源原型
- en: URI path
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI路径
- en: URI query
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI查询
- en: Metadata design rules (HTTP headers and returning error codes) and representations
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据设计规则（HTTP头和返回错误代码）以及表示
- en: Client concerns (versioning, security, and hypermedia processing)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户关注的问题（版本控制、安全性和超媒体处理）
- en: We're confident that having a clear understanding of these rules will move us
    closer to design and begin our journey towards delivering the finest RESTful APIs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信，对这些规则的清晰理解将使我们更接近设计，并开始我们的旅程，朝着提供最优质的RESTful API迈进。
- en: Learning about Uniform Resource Identifiers
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解统一资源标识符
- en: 'REST APIs should use **Uniform Resource Identifiers** (**URIs**) to represent
    their resources. The resource indications should be clear and straightforward
    so that they communicate the APIs resources crisp and clearly:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 应使用 **统一资源标识符（URIs**）来表示其资源。资源指示应清晰直接，以便它们能够清晰明确地传达API资源：
- en: A sample of a simple to understand URI is `https://xx.yy.zz/sevenwonders/tajmahal/india/agra`,
    as you may observe that the emphasized texts clearly indicates the intention or
    representation
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单易懂的URI示例是 `https://xx.yy.zz/sevenwonders/tajmahal/india/agra`，如您所观察到的，强调的文本清楚地表明了意图或表示
- en: A harder to understand URI is `https://xx.yy.zz/books/36048/9780385490627`;
    in this sample, the text after *books* is very hard for anyone to understand
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个难以理解的URI示例是 `https://xx.yy.zz/books/36048/9780385490627`；在这个示例中，“books”之后的文本对任何人来说都很难理解
- en: So having simple, understandable representation in the URI is critical in RESTful
    API design.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在RESTful API设计中，URI的简单、易懂的表示至关重要。
- en: The following section deals with many such URI aspects for RESTful services.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分讨论了针对RESTful服务的许多此类URI方面。
- en: URI formats
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URI格式
- en: 'As per RFC 3986, the syntax of the generic URI is `scheme "://" authority "/"
    path [ "?" query ] [ "#" fragment ]` and following are the rules for API designs:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC 3986，通用URI的语法是 `scheme "://" authority "/" path [ "?" query ] [ "#" fragment
    ]`，以下是为API设计制定的规则：
- en: '**Use forward slash (`/`) separator**: This is used to indicate the hierarchical
    relationship between resources, for example, `http://xx.yy.zz/shapes/polygons/quadrilaterals/squares`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用正斜杠（`/`）分隔符**：这用于表示资源之间的层次关系，例如，`http://xx.yy.zz/shapes/polygons/quadrilaterals/squares`。'
- en: '**Don''t use a trailing forward slash**: A trailing forward slash in the URI
    doesn''t have any meaning and may create confusion, for example, `http://xx.yy.zz/shapes/polygons/`
    and  `http://api.examples.org/shapes/polygons` (note the trailing / at the end
    of the URI). REST API should neither expect trailing slash nor include them in
    the links that they provide to clients as responses.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用尾部正斜杠**：URI中的尾部正斜杠没有任何意义，可能会造成混淆，例如，`http://xx.yy.zz/shapes/polygons/`
    和 `http://api.examples.org/shapes/polygons`（注意URI末尾的尾部斜杠）。REST API既不应期望尾部斜杠，也不应在提供给客户端作为响应的链接中包含它们。'
- en: '**Use hyphens (**`*-*`**)**: Hyphens improve the readability of URI names,
    paths, and segments, and help clients to scan and interpret easily, for example,
    `https://xx.yy.zz/seven-wonders/taj-mahal/india/agra` (note the hyphen segregates
    the space between seven wonders and Taj Mahal).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用连字符（**`*-*`**）**：连字符可以提高URI名称、路径和段落的可读性，并帮助客户端轻松扫描和解释，例如，`https://xx.yy.zz/seven-wonders/taj-mahal/india/agra`（注意连字符分隔了“七奇迹”和泰姬陵之间的空间）。'
- en: '**Avoid underscores (**`_`**)**: Designers should avoid _ (underscore) representation
    in the path, as the character *underscore* may be partially obscured or hidden
    while rendering on any visual cues due to computer fonts, for example, `https://xx.yy.zz/seven_wonders/taj_mahal/india/agra`
    (note that we can''t make out the underscore as its made as a hyperlink). It should
    use hyphens instead `https://xx.yy.zz/seven-wonders/taj-mahal/india/agra` (with
    a hyphen, it''s visible even if it is a hyperlink).'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免下划线（**`_`**）**：设计师应避免在路径中使用下划线（_）表示，因为字符下划线在计算机字体渲染时可能会部分遮挡或隐藏，例如，`https://xx.yy.zz/seven_wonders/taj_mahal/india/agra`（注意我们无法辨认下划线，因为它被作为超链接）。应使用连字符代替
    `https://xx.yy.zz/seven-wonders/taj-mahal/india/agra`（使用连字符，即使它是超链接，也能清晰可见）。'
- en: '**Prefer all lowercase letters in a URI path**: API designers should give preference
    to lowercase letters over any other representations, as RFC 3986 defines URIs
    as case sensitive except for the scheme and host components. Some examples include, `http://xx.yy.zz/shapes/polygons`
    and  `HTTP://XX.YY.ZZ/shapes/polygons` are the same, while `http://xx.yy.zz/shapes/polygons`
    and `HTTP://XX.YY.ZZ/SHAPES/Polygons` are *not* the same.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在URI路径中优先使用全部小写字母**：API设计师应优先考虑小写字母，而不是其他任何表示形式，因为RFC 3986将URI定义为大小写敏感，除了方案和主机组件。一些例子包括，`http://xx.yy.zz/shapes/polygons`
    和 `HTTP://XX.YY.ZZ/shapes/polygons` 是相同的，而 `http://xx.yy.zz/shapes/polygons` 和
    `HTTP://XX.YY.ZZ/SHAPES/Polygons` 则 **不是** 相同的。'
- en: '**Do not include file extensions**: As you know, a dot (`.`) prefixed after
    the filename denotes its file types. However, a URI shouldn''t use dots to represent
    any file extensions; instead, it should rely on media types communicated through
    a content-type header (refer to the *media types and media type design rules*
    section).'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要包含文件扩展名**：正如你所知，文件名后缀的点(`.`)表示其文件类型。然而，URI不应该使用点来表示任何文件扩展名；相反，它应该依赖于通过内容类型头（参考*媒体类型和媒体类型设计规则*部分）传达的媒体类型。'
- en: REST API URI authority
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API URI授权
- en: 'As we''ve seen different rules for URIs in general, we will discuss the authority
    *(*`scheme "://" authority "/" path [ "?" query ] [ "#" fragment ]`*)* portion
    of the REST API URI:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，对于通用URI有不同的规则，我们将讨论REST API URI的授权(*`scheme "://" authority "/" path
    [ "?" query ] [ "#" fragment ]`*)部分：
- en: 'Use consistent sub-domain names:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一致的子域名：
- en: 'Consistent sub-domain names for an API include the following:'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的一致子域名包括以下内容：
- en: The top-level domain and the first sub-domain names indicate the service owner
    and an example could be `baseball.restfulapi.org`
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级域名和第一个子域名表示服务所有者，一个例子可以是`baseball.restfulapi.org`
- en: As you see in `http://api.baseball.restfulapi.org`, the API domain should have
    `api` as part of its sub-domain
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如你所见在`http://api.baseball.restfulapi.org`，API域名应该包含子域名中的`api`
- en: 'Consistent sub-domain names for a developer portal  include the following:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者门户的一致子域名包括以下内容：
- en: As we saw in the *API playgrounds* section, the API providers should have exposed
    sites for APP developers to test their APIs called a developer portal. So, by
    convention, the developer portal's sub-domain should have `developer` in it. An
    example of a sub-domain with the developer for a developer portal would be `http://developer.baseball.restfulapi.org`*.*
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在*API游乐场*部分所看到的，API提供者应该为APP开发者提供测试API的网站，称为开发者门户。因此，按照惯例，开发者门户的子域名应该包含`developer`。一个包含开发者的开发者门户子域名的例子将是`http://developer.baseball.restfulapi.org`*.*
- en: Resource modelling
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源建模
- en: Resource modeling is one of the primary aspects for API designers as it helps
    to establish the API's fundamental concepts.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 资源建模是API设计者的主要方面之一，因为它有助于建立API的基本概念。
- en: In an earlier section, we saw details about the URI; let's consider, in general,
    the URI path always convey REST resources, and each part of the URI is separated
    by a forward slash (`/`) to indicate a unique resource within it model's hierarchy.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看到了关于URI的详细信息；让我们一般性地考虑，URI路径总是传达REST资源，并且URI的每一部分都由一个正斜杠(`/`)分隔，以表示模型层次结构中的唯一资源。
- en: 'Let''s take the following sample URI designs:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例URI设计：
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus)'
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/accountbalance](https://api-test.lufthansa.com/v1/profiles/customers/accountbalance)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles/customers/accountbalance](https://api-test.lufthansa.com/v1/profiles/customers/accountbalance)'
- en: 'Each resource separated by a forward slash indicates an addressable resource,
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源通过正斜杠分隔表示一个可寻址的资源，如下所示：
- en: '[https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
- en: '[https://api-test.lufthansa.com/v1/profiles](https://api-test.lufthansa.com/v1/profiles)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles](https://api-test.lufthansa.com/v1/profiles)'
- en: '[https://api-test.lufthansa.com](https://api-test.lufthansa.com)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com](https://api-test.lufthansa.com)'
- en: Customers, profiles, and APIs are all unique resources in the preceding individual
    URI models. So, resource modelling is a crucial design aspect, and API designers
    need to think about the API resource model before they move on to designing URI
    paths.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 客户、配置文件和API都是前面单个URI模型中的独特资源。因此，资源建模是一个关键的设计方面，API设计者在设计URI路径之前需要考虑API资源模型。
- en: Resource archetypes
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源原型
- en: 'Each service provided by the API is an archetype, and they indicate the structures
    and behaviors of REST API designs. Resource modelling should start with a few
    fundamental resource archetypes, and usually, the REST API is composed of four
    unique archetypes, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: API提供的每个服务都是一个原型，它们表示REST API设计的结构和行为。资源建模应该从几个基本的资源原型开始，通常REST API由四个独特的原型组成，如下所示：
- en: '**Document**: The document is the base for a resource representation with a
    field and link-based structure. In the following, each sample URI represents unique
    document resources, and the first one is also called the doc-root or parent resource
    ( the API endpoint):'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**: 文档是以字段和链接为基础结构的资源表示的基础。以下，每个样本URI代表唯一的文档资源，第一个也称为doc-root或父资源（API端点）：'
- en: '[https://api-test.lufthansa.com](https://api-test.lufthansa.com)'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com](https://api-test.lufthansa.com)'
- en: '[https://api-test.lufthansa.com/v1/profiles](https://api-test.lufthansa.com/v1/profiles)'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles](https://api-test.lufthansa.com/v1/profiles)'
- en: '[https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/accountbalance](https://api-test.lufthansa.com/v1/profiles/customers/accountbalance)'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles/customers/accountbalance](https://api-test.lufthansa.com/v1/profiles/customers/accountbalance)'
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus)'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus)'
- en: '**Collection**: A collection is also a resource, and it is a directory of resources
    managed by the API providers or servers. If a collection allows creating a new
    resource, then the clients can add new resources to the collections. A collection
    resource decides the URIs of each contained or added resources. In the following,
    each URI sample found identifies a collection resource:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**: 集合也是一种资源，它是API提供者或服务器管理的资源目录。如果集合允许创建新的资源，则客户端可以向集合中添加新资源。集合资源决定每个包含或添加的资源URI。以下，每个找到的URI样本标识一个集合资源：'
- en: '[https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/accountbalance](https://api-test.lufthansa.com/v1/profiles/customers/accountbalance)'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles/customers/accountbalance](https://api-test.lufthansa.com/v1/profiles/customers/accountbalance)'
- en: '[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus)'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus)'
- en: '**Stores**: A store is a resource repository managed by the client. The store
    allows the API client to put resources in, choose URIs for the resources that
    get added, get them out, and delete them when it decides. (URI stores never generate
    a new URI, and it is the client who chooses when resources initially get added.)
    Some of the following examples of interaction show a user of a client program
    of a cart- and song-management API inserting a document resource named carts and
    playlists respectively against his/her user ID denoted by `{id}`:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**: 存储是由客户端管理的资源仓库。存储允许API客户端将资源放入其中，为添加的资源选择URI，获取它们，并在决定时删除它们。（URI存储永远不会生成新的URI，并且是客户端决定资源最初何时添加。）以下的一些交互示例显示了购物车和歌曲管理API客户端程序的用户在其用户ID
    `{id}` 下分别插入名为carts和playlists的文档资源：'
- en: '[http://api.example.com/cart-management/users/{id}/carts](http://api.example.com/cart-management/users/%7Bid%7D/carts)'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://api.example.com/cart-management/users/{id}/carts](http://api.example.com/cart-management/users/%7Bid%7D/carts)'
- en: '[http://api.example.com/song-management/users/{id}/playlists](http://api.example.com/song-management/users/%7Bid%7D/playlists)'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://api.example.com/song-management/users/{id}/playlists](http://api.example.com/song-management/users/%7Bid%7D/playlists)'
- en: '**Controller**: Controller resources are similar to executable methods, with
    parameters and return values. REST API relies on controller resources to perform
    application-specific actions that do not come under any of the CRUD methods. Controller
    names should always appear as the last segment in a URI path, with no child resources
    to follow them in the hierarchy:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**: 控制器资源类似于可执行方法，具有参数和返回值。REST API依赖于控制器资源来执行不属于任何CRUD方法的应用特定操作。控制器名称应始终出现在URI路径的最后一段，后面没有子资源跟随：'
- en: '`POST /alerts/245245/resend` is an example of a controller resource that allows
    a client to resend an alert to a user'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /alerts/245245/resend` 是一个控制器资源的示例，允许客户端向用户重新发送警报'
- en: URI path
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URI路径
- en: This section discusses rules relating to the design of meaningful URI paths
    (`scheme "://" authority "/" path [ "?" query ] [ "#" fragment ]`) portion of
    the REST API URIs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论与 REST API URI 中有意义的 URI 路径（`scheme "://" authority "/" path [ "?" query
    ] [ "#" fragment ]`）设计相关的规则。
- en: 'The following are the rules about URI paths:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于 URI 路径的规则：
- en: Use singular nouns for document names, for example, [https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus).
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单数名词表示文档名称，例如：[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus)。
- en: 'Use plural nouns for collections and stores:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复数名词表示集合和存储：
- en: '**Collections**: [https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：[https://api-test.lufthansa.com/v1/profiles/customers](https://api-test.lufthansa.com/v1/profiles/customers)'
- en: '**Stores**: [https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/prefernces](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/prefernces)'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/prefernces](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/prefernces)'
- en: As controller names represent an action, use a verb or verb phrase for controller
    resources. An example would be [https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/reset](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/reset).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于控制器名称代表一个动作，因此对于控制器资源应使用动词或动词短语。例如：[https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/reset](https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/reset)。
- en: 'Do not use CRUD function names in URIs:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在 URI 中使用 CRUD 函数名称：
- en: '**Correct URI example**: `DELETE /users/1234`'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确的 URI 示例**：`DELETE /users/1234`'
- en: '**Incorrect URIs**: `GET /user-delete?id=1234`, `GET /user-delete /1234`, `DELETE
    /user-delete /1234`, and `POST /users/1234/delete`'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误的 URI**：`GET /user-delete?id=1234`，`GET /user-delete /1234`，`DELETE /user-delete
    /1234`，以及 `POST /users/1234/delete`'
- en: URI query
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URI 查询
- en: This section discusses rules relating to the design of the query (`scheme "://"
    authority "/" path [ "?" query ] [ "#" fragment ]`*)* portion of the REST API
    URIs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论与 REST API URI 的查询部分（`scheme "://" authority "/" path [ "?" query ] [ "#"
    fragment ]`*）设计相关的规则。
- en: 'The query component of the URI also represents the unique identification of
    the resource, and following are the rules about URI queries:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: URI 的查询部分也代表了资源的唯一标识，以下是一些关于 URI 查询的规则：
- en: 'Use the query to filter collections or stores:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询对集合或存储进行过滤：
- en: 'An example of the limit in the query: `https://api.lufthansa.com/v1/operations/flightstatus/arrivals/ZRH/2018-05-21T06:30?limit=40`'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询中的限制示例：`https://api.lufthansa.com/v1/operations/flightstatus/arrivals/ZRH/2018-05-21T06:30?limit=40`
- en: 'Use the query to paginate collection or store results:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询对集合或存储结果进行分页：
- en: 'An example with the offset in the query: `https://api.lufthansa.com/v1/operations/flightstatus/arrivals/ZRH/2018-05-21T06:30?limit=40&offset=10`'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询中的偏移量示例：`https://api.lufthansa.com/v1/operations/flightstatus/arrivals/ZRH/2018-05-21T06:30?limit=40&offset=10`
- en: HTTP interactions
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 交互
- en: A REST API doesn't suggest any special transport layer mechanisms, and all it
    needs is basic Hyper Text Transfer Protocol and its methods to represent its resources
    over the web. We will touch upon how REST should utilize those basic HTTP methods
    in the upcoming sections.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 不建议使用任何特殊的传输层机制，它只需要基本的超文本传输协议及其方法来在网络上表示其资源。我们将在接下来的章节中讨论 REST 应如何利用这些基本的
    HTTP 方法。
- en: Request methods
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求方法
- en: 'The client specifies the intended interaction with well-defined semantic HTTP
    methods, such as `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD,` and `OPTIONS`.
    The following are the rules that an API designer should take into account when
    planning their design:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过定义明确的语义 HTTP 方法（如 `GET`，`POST`，`PUT`，`DELETE`，`PATCH`，`HEAD`，和 `OPTIONS`）来指定预期的交互。以下是在设计时
    API 设计师应考虑的规则：
- en: Don't tunnel to other requests with the `GET` and `POST` methods
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用 `GET` 和 `POST` 方法进行其他请求的隧道传输
- en: Use the `GET` method to retrieve a representation of a resource
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GET` 方法检索资源的表示
- en: Use the `HEAD` method to retrieve response headers
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `HEAD` 方法检索响应头
- en: Use the `PUT` method to update and insert a stored resource
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `PUT` 方法更新和插入存储的资源
- en: Use the `PUT` method to update mutable resources
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `PUT` 方法更新可变资源
- en: Use the `POST` method to create a new resource in a collection
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `POST` 方法在集合中创建新的资源
- en: Use the `POST` method for controller's execution
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `POST` 方法执行控制器操作
- en: Use the `DELETE` method to remove a resource from its parent
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DELETE` 方法从其父资源中删除资源
- en: Use the `OPTIONS` method to retrieve metadata
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `OPTIONS` 方法检索元数据
- en: Response status codes
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应状态码
- en: HTTP specification defines standard status codes, and REST API can use the same
    status codes to deliver the results of a client request.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP规范定义了标准状态码，REST API可以使用相同的状态码来传递客户端请求的结果。
- en: 'The status code categories and a few associated REST API rules are as follows
    so that the APIs can apply those rules according to the process status:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码类别和一些相关的REST API规则如下，以便API可以根据进程状态应用这些规则：
- en: '**1xx: Informational**: This provides protocol-level information'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1xx: 信息性**: 这提供了协议级别的信息'
- en: '**2xx: Success**: Client requests are accepted (successfully), as in the following
    examples:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2xx: 成功**: 客户端请求被接受（成功），如下所示：'
- en: '`200`: OK'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`: OK'
- en: Use for indicating client request success
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于指示客户端请求成功
- en: Do not use to communicate the errors in the response body
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要用于在响应体中传达错误
- en: '`201`: Created'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201`: 已创建'
- en: Apply for successful resource creation
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于成功创建资源
- en: '`202`: Accepted'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`202`: 已接受'
- en: Use for reporting the successful asynchronous action
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于报告成功的异步操作
- en: '`204`: No content'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`204`: 无内容'
- en: When an API wants to send empty or no content in the response body
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当API想要在响应体中发送空或无内容时
- en: '**3xx: Redirection**: Client requests are redirected by the server to the different
    endpoints to fulfil the client request:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3xx: 重定向**: 服务器将客户端请求重定向到不同的端点以满足客户端请求：'
- en: '`301`: Moved Permanently'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`301`: 永久移动'
- en: Use for relocated resources
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于已移动的资源
- en: '`302`: Found'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`302`: 找到'
- en: Please note not to use `302`, as it would create confusion among the developers
    related to the initiation of automatic redirections from the client
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意不要使用`302`，因为它会在开发者中引起关于从客户端自动重定向的混淆
- en: '`303`: See other'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`303`: 看其他'
- en: Apply to refer the client to a different URI (in place of `302`, it's recommended
    the API should use `303`)
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于将客户端指向不同的URI（代替`302`，建议API应使用`303`）
- en: '`304`: Not modified'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`304`: 未修改'
- en: Use so that the client can preserve bandwidth
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以便客户端可以节省带宽
- en: Use in conjunction with conditional HTTP requests
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与条件HTTP请求一起使用
- en: '`307`: Temporarily redirect'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`307`: 临时重定向'
- en: Use to indicate to the clients to resubmit the request to another URI
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于指示客户端将请求重新提交到另一个URI
- en: '**4xx: Client error**: Errors at client side:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4xx: 客户端错误**: 客户端错误：'
- en: '`400`: Bad request'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400`: 错误请求'
- en: Can be used to indicate generic or nonspecific failures
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用来指示通用或非特定失败
- en: '`401`: Unauthorized'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401`: 未授权'
- en: Apply for unauthorized access from the client side or problem with the client
    credentials
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于客户端未经授权访问或客户端凭证问题
- en: '`403`: Forbidden'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`403`: 禁止'
- en: Use to forbid access regardless of the authorization state
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于禁止访问，无论授权状态如何
- en: Use to enforce application-level permission (allowed to access only a few resources
    and not all the resources)
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于强制应用级权限（仅允许访问少数资源而不是所有资源）
- en: '`404`: Not found'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404`: 未找到'
- en: Must use when client request doesn't map to any of the API resources
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端请求不映射到任何API资源时必须使用
- en: '`405`: Method not allowed'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`405`: 方法不允许'
- en: Use when the client accesses unintended HTTP methods
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端访问非预期HTTP方法时使用
- en: Example read-only resource might only support `GET` and `HEAD` , and the client
    tried to use `PUT` or `DELETE`
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 举例来说，只支持读取的资源配置可能只支持`GET`和`HEAD`，而客户端尝试使用`PUT`或`DELETE`
- en: Please note that `405` response should be part of the Allow header *(Allow—`GET`.
    `POST`)*
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，`405`响应应该是Allow头的一部分 *(Allow—`GET`. `POST`)*
- en: '`406`: Not acceptable'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`406`: 不可接受'
- en: Must use when the server can't serve the requested media type
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器无法提供请求的媒体类型时必须使用
- en: '`409`: Conflict'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`409`: 冲突'
- en: Use for client violation of a resource state
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于客户端违反资源状态
- en: An example could be an API returns this error when the client tries to delete
    a non-empty store resource
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，当客户端尝试删除非空存储资源时，API返回此错误
- en: '`412`: Precondition failed'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`412`: 预先条件失败'
- en: Use to support conditional operations. The client sends one or more preconditions
    in the request headers to indicate to the API to execute only those conditions
    that are satisfied; if not, the API should send a `412` error code.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于支持条件操作。客户端在请求头中发送一个或多个先决条件，以指示API仅执行满足条件的条件；如果不满足，API应发送`412`错误代码。
- en: '`415`: Unsupported media type'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`415`: 不支持的媒体类型'
- en: Must be used when the API is not able to process the request's payload media
    type (indicated in the content-type request header)
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当API无法处理请求的有效负载媒体类型（在内容类型请求头中指示）时必须使用
- en: '**5xx: Server error**: These relate to errors at server side:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5xx: 服务器错误**: 这些与服务器端错误相关：'
- en: '`500`: Internal server error'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`：内部服务器错误'
- en: Use to report the API/server-side issues, and when it's certainly not the client's
    side fault
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于报告API/服务器端问题，并且当这肯定不是客户端的过错时
- en: Metadata design
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元数据设计
- en: This section looks at the rules for metadata designs, including HTTP headers
    and media types.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了元数据设计的规则，包括HTTP头部和媒体类型。
- en: HTTP headers
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP头部
- en: As you might already know, HTTP specifications have a set of standard headers,
    through which a client can get information about a requested resource, and carry
    the messages that indicate its representations and may serve as directives to
    control intermediary caches.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经知道，HTTP规范有一组标准头部，通过这些头部，客户端可以获取有关请求资源的信息，并携带指示其表示的消息，这些消息可能作为控制中间缓存的方向。
- en: 'The following points suggest a few sets of rules conforming to the HTTP standard
    headers:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点提出了一组符合HTTP标准头部的规则：
- en: '**Should use content-type**: Client and servers rely on this header to indicate
    how to process the message''s body, as the value of the content-type specifies
    the form of the data contained in the request or response message body called
    **media types**.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应在响应中使用content-type**：客户端和服务器依赖于这个头部来指示如何处理消息体，因为content-type的值指定了请求或响应消息体中包含的数据的形式，称为**媒体类型**。'
- en: '**Should use content-length**: The client should know the size of the message
    body that it is about to read. The other benefit is that the client gets to know
    how large the response body is that it needs to download, without needing to download
    the whole response by making a `HEAD` request.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应在响应中使用content-length**：客户端应该知道即将读取的消息体的尺寸。另一个好处是，客户端可以知道需要下载的响应体的尺寸，而无需通过发送`HEAD`请求来下载整个响应。'
- en: '**Should use last-modified in responses**: The response should specify the
    timestamp when the representational state of the required resource was modified
    or updated so that the client and cache intermediaries can rely on this header
    to determine the freshness of their local copies of a resource''s state representation.
    The last-modified header should be part of their requests.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应在响应中使用last-modified**：响应应指定所需资源表示状态被修改或更新的时间戳，以便客户端和缓存中间件可以依赖此头部来确定其本地副本的资源状态表示的新鲜度。`last-modified`头部应作为其请求的一部分。'
- en: '**Should use ETag in responses**: **Entity tag** (**ETag**) is an HTTP header
    that helps the client to identify a specific version of the resources they asked
    for. The server should always respond with the ETag as a header for the client `GET`
    requests. The value of the ETag is commonly a digest (hash value, for instance,
    MD5 hash) of the resource contents so that the server can identify whether the
    cached contents of the resources are different from the latest version of the
    resources. ETag differs from the last-modified header by the value (resource content
    as digest versus timestamp). This header value enables the client to choose whether
    or not to send the representation again by using `If-Non-Match` conditionals in
    the future `GET` requests. If the ETag value hasn''t changed, then the client
    can decide to save time and bandwidth by not sending the representation again
    in their subsequent `GET` requests.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应在响应中使用ETag**：**实体标签**（**ETag**）是一个HTTP头部，帮助客户端识别他们请求的资源的具体版本。服务器应该始终在客户端的`GET`请求中以头部形式响应ETag。ETag的值通常是资源内容的摘要（例如，MD5哈希值），以便服务器可以识别缓存的资源内容是否与资源的最新版本不同。ETag与`last-modified`头部的区别在于值（作为摘要的资源内容与时间戳）。此头部值使客户端能够通过在未来的`GET`请求中使用`If-Non-Match`条件来选择是否再次发送表示。如果ETag值没有变化，那么客户端可以决定在随后的`GET`请求中节省时间和带宽，不再发送表示。'
- en: '**Stores must support conditional `PUT` requests**: REST API can support conditional
    `PUT` requests by relying on client requests with `If-Unmodified-Since`, and/or
    `If-Match` request headers. As the store resources use the `PUT` method for both
    inserts and updates, the REST API should know the client''s intent of the `PUT`
    requests. `PUT` is the same as `POST` except `PUT` is *idempotent. Please note
    that HTTP supports conditional requests with the `GET`, `POST` , and `DELETE`
    methods; this is an essential pattern for allowing writable REST APIs to help
    collaboration among API clients.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储必须支持条件 `PUT` 请求**：REST API 可以通过依赖于带有 `If-Unmodified-Since` 和/或 `If-Match`
    请求头的客户端请求来支持条件 `PUT` 请求。由于存储资源使用 `PUT` 方法进行插入和更新，REST API 应该知道客户端 `PUT` 请求的意图。`PUT`
    与 `POST` 相同，除了 `PUT` 是**幂等的**。请注意，HTTP 支持使用 `GET`、`POST` 和 `DELETE` 方法的条件请求；这是允许可写
    REST API 帮助 API 客户端之间协作的基本模式。'
- en: From a RESTful service standpoint, the idempotent of a service call means the
    calls that the client makes produce the same results for all calls; that is, multiple
    requests from the clients produce the same effect as a single request. Please
    note that the same result or behavior is on the server. However, the response
    that the client receives may not be the same as the resource state may change
    between the requests.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从 RESTful 服务角度来看，服务调用的幂等性意味着客户端发出的调用对所有调用产生相同的结果；也就是说，来自客户端的多个请求与单个请求产生相同的效果。请注意，相同的结果或行为在服务器上。然而，客户端收到的响应可能不与资源状态相同，因为请求之间资源状态可能发生变化。
- en: '**Should use the location to specify the URI of newly created resources (through**
    `PUT`**)**: In response to the successful creation of resources through collections
    or stores, the API should provide the location (URI) of the newly created resource
    as a response header. The location header can be part of the status code `202`
    response to direct the clients about the status of their asynchronous call.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应使用位置指定新创建资源的 URI（通过 `PUT`）**：在通过集合或存储成功创建资源后，API 应提供新创建资源的 URI（位置）作为响应头。位置头可以是状态码
    `202` 响应的一部分，以指导客户端其异步调用的状态。'
- en: '**Should leverage HTTP cache headers**: This is to encourage caching, provide
    cache-control, Expires, and date-response headers to leverage caching at various
    levels, such as the API server side, **content delivery networks** (**CDN**),
    or even at the client''s network. Some examples are as follows:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应利用 HTTP 缓存头**：这是为了鼓励缓存，提供缓存控制、过期和日期响应头，以在各种级别上利用缓存，例如 API 服务器端、**内容分发网络**（**CDN**）或甚至客户端的网络。以下是一些示例：'
- en: '`Cache-Control: max-age=90, must-revalidate` (`max-age` is in seconds)'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cache-Control: max-age=90, must-revalidate` （`max-age` 以秒为单位）'
- en: '`For HTTP 1.0 based caches,``Date: Tue, 29 Apr 2018 08:12:31 GMT``Expires:
    Fri, 04 May 2018 16:00:00 GMT`'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对于基于 HTTP 1.0 的缓存，``Date: Tue, 29 Apr 2018 08:12:31 GMT``Expires: Fri, 04
    May 2018 16:00:00 GMT`'
- en: 'To discourage caching, add cache-control headers with `no-cache` and `no-store`,
    with the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阻止缓存，添加带有 `no-cache` 和 `no-store` 的缓存控制头，具体如下：
- en: For HTTP 1.0 legacy caches
  id: totrans-320
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 HTTP 1.0 的遗留缓存
- en: Add the `Pragma—no-cache` and `Expires—0` header values
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `Pragma—no-cache` 和 `Expires—0` 头值
- en: However, unless necessary, REST API should always provoke caching of responses,
    maybe by shorter duration instead of using a no-cache directive. So the clients
    get faster responses for frequent access requests by fetching the short-lived
    response copies.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除非必要，REST API 应始终引发响应的缓存，可能通过较短的持续时间而不是使用无缓存指令来实现。这样，客户端可以通过获取短暂的生命周期响应副本来获得更快的响应，以满足频繁的访问请求。
- en: '**Should use expiration headers with** `200` **("OK") responses**: Setting
    expiration caching headers in response to the successful `GET` and `HEAD` requests
    encourages caching at the client side. Please note that the `POST` method is also
    cacheable, and so don''t treat this method as non-cacheable.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应使用过期头与 `200` （"OK"）响应一起使用**：对成功的 `GET` 和 `HEAD` 请求设置过期缓存头，鼓励客户端进行缓存。请注意，`POST`
    方法也是可缓存的，因此不要将此方法视为不可缓存。'
- en: '**May use expiration caching headers with 3xx and 4xx responses**: In addition
    to status code `200` (`"OK": successful responses`), the APIs can include caching
    headers for 3xx and 4xx responses, also known as negative caching. It helps the
    REST API server with a reduction in loads due to some redirection and error triggers.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可以使用 3xx 和 4xx 响应的过期缓存头**：除了状态码 `200` （"OK"：成功响应）之外，API 还可以包括 3xx 和 4xx 响应的缓存头，也称为负缓存。这有助于
    REST API 服务器通过减少由于某些重定向和错误触发而导致的负载。'
- en: '**Mustn''t use custom HTTP headers: **The primary purpose of custom HTTP headers
    is to provide additional information and troubleshooting tips for app developers;
    however, for some distinctive cases at the server side, it comes in handy unless
    those cases do not change the behavior of the HTTP methods. An example could be
    an API that makes use of the X-cache header to let app developers know whether
    the resource is delivered by the origin server or by the edge server. If the information
    that should go through a custom HTTP header is critical in that it needs an accurate
    interpretation of the request or response, then it is better for it to be included
    in the body of the request or response or in the URI used for that request.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不得使用自定义HTTP头**：自定义HTTP头的主要目的是为应用开发者提供额外的信息和故障排除提示；然而，对于服务器端的一些特定情况，除非这些情况不会改变HTTP方法的行为，否则它们会很有用。一个例子是使用X-cache头部的API，让应用开发者知道资源是由源服务器还是边缘服务器提供的。如果应该通过自定义HTTP头传递的信息是关键的，需要对其请求或响应进行准确解释，那么最好将其包含在请求或响应的主体中，或者在该请求使用的URI中。'
- en: Media types and media type design rules
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体类型和媒体类型设计规则
- en: As you saw in the *Manipulation of Resources* section of [Chapter 1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml), *Introduction
    to the Basics of RESTful Architecture,* media types help to identify the form
    of the data in a request or response message body, and the content-type header
    value represents a media type also known as the **Multipurpose Internet Mail Extensions**
    (**MIME**) type.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第1章](ce158181-8265-4afb-b858-348cc775d6d8.xhtml)的“资源操作”部分中看到的，*RESTful架构基础简介*，媒体类型有助于识别请求或响应消息主体中的数据形式，而内容类型头部的值代表一个媒体类型，也称为**多用途互联网邮件扩展**（**MIME**）类型。
- en: Media type design influences many aspects of a REST API design, including hypermedia,
    opaque URIs, and different and descriptive media types so that app developers
    or clients can rely on the self-descriptive features of the REST API.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体类型设计影响REST API设计的许多方面，包括超媒体、不透明URI以及不同和描述性的媒体类型，以便应用开发者或客户端可以依赖REST API的自描述特性。
- en: 'The following points discuss the rules of media type design in brief:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简要讨论媒体类型设计规则：
- en: '**Uses application-specific media types**: REST APIs treat the body of an HTTP
    request or response as part of an application-specific interaction. While the
    request or response body is built with languages such as JSON or XML, it typically
    has semantics that requires special processing beyond merely parsing the language''s
    syntax. An example representation of such a REST API URI is [https://swapi.co/api/planets/1](https://swapi.co/api/planets/1)
    that responds to the `GET` requests with a representation of the *Star Wars* planet
    resource that''s formatted using JSON.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用特定应用的媒体类型**：REST API将HTTP请求或响应的主体视为特定应用交互的一部分。虽然请求或响应主体是用JSON或XML等语言构建的，但它通常具有需要特殊处理的语义，而不仅仅是解析语言的语法。以下是一个此类REST
    API URI的示例表示，即[https://swapi.co/api/planets/1](https://swapi.co/api/planets/1)，它对`GET`请求响应以JSON格式表示的*星球大战*星球资源。'
- en: '**Supports media type negotiations in case of multiple representations**: The
    client may require different formats and schema by submitting the desired media
    type as part of the `Accept` header, so the API should allow the clients to get
    the response in the desired format.Following is an example representation of the
    media type negotiations from `developer.atlassian.com` for the following `Accept`
    header:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持多种表示形式的媒体类型协商**：客户端可能需要通过在`Accept`头中提交所需的媒体类型来要求不同的格式和模式，因此API应该允许客户端以所需的格式获取响应。以下是从`developer.atlassian.com`提供的媒体类型协商示例，针对以下`Accept`头：'
- en: '[PRE0]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Observe the following curl execution:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下curl执行情况：
- en: '[PRE1]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can conclude the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出以下结论：
- en: 'Support media type selection using a query parameter:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询参数支持媒体类型选择：
- en: To support clients with simple links and debugging, REST APIs should support
    media type selection through a query parameter named accept, with a value format
    that mirrors that of the accept HTTP request header
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持具有简单链接和调试功能的客户端，REST API应该通过名为`accept`的查询参数支持媒体类型选择，其值格式与`Accept` HTTP请求头中的格式相匹配
- en: An example is REST APIs should prefer a more precise and generic approach as
    following media type, using the `GET` `https://swapi.co/api/planets/1/?format=json` query
    parameter identification over the other alternatives
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，REST API应优先采用更精确和通用的方法，如下所示媒体类型，使用`GET` `https://swapi.co/api/planets/1/?format=json`查询参数标识，而不是其他替代方案
- en: Windows OS users can use MobaXterm ([https://mobaxterm.mobatek.net/](https://mobaxterm.mobatek.net/))
    or any SSH clients that supports Unix commands.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Windows操作系统用户可以使用MobaXterm ([https://mobaxterm.mobatek.net/](https://mobaxterm.mobatek.net/))
    或任何支持Unix命令的SSH客户端。
- en: Representations
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示
- en: As we know, machine-readable description of a resource's current state with
    a request or response is a representation, and it can be in different formats.
    The following section discusses the rules for most common resource formats, such
    as JSON and hypermedia, and error types in brief.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，资源当前状态的机器可读描述，无论是请求还是响应，都是表示，它可以采用不同的格式。以下部分讨论了最常见资源格式（如JSON和超媒体）以及错误类型的简要规则。
- en: Message body format
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息体格式
- en: 'REST API communications in the distributed environment are most often as a
    text-based format, and we will discuss the JSON text-format representation rules
    as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式环境中，REST API通信通常以文本格式进行，我们将讨论以下JSON文本格式表示规则：
- en: Use JSON for resource representation and it should be well-formed
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON进行资源表示，并且应该格式良好
- en: You may use XML and other formats as well
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您也可以使用XML和其他格式
- en: Don't create additional envelopes or any custom transport wrappers and leverage
    only HTTP envelopes
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要创建额外的封装或任何自定义传输封装，仅利用HTTP封装
- en: Hypermedia representation
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超媒体表示
- en: As we have understood from [Chapter 1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml),
    *Introduction to the Basics of RESTful Architecture*, REST API clients can programmatically
    navigate using a uniform link structure as a HATEOAS response, and following are
    a few rules related to hypermedia representations.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从[第一章](ce158181-8265-4afb-b858-348cc775d6d8.xhtml)，《RESTful架构基础介绍》所理解，REST
    API客户端可以使用统一链接结构作为HATEOAS响应进行编程导航，以下是一些与超媒体表示相关的规则。
- en: 'The following screenshot helps us to recollect from [Chapter 1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml),
    *Introduction to the Basics of RESTful Architecture,* the HATEOAS representation:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图帮助我们回忆[第一章](ce158181-8265-4afb-b858-348cc775d6d8.xhtml)，《RESTful架构基础介绍》，的HATEOAS表示：
- en: '![](img/6e7bbc3f-121f-43b4-9a1f-aa646b7bd01c.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e7bbc3f-121f-43b4-9a1f-aa646b7bd01c.png)'
- en: 'Also, it can help us to relate to the following rules:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以帮助我们关联以下规则：
- en: Use a consistent form to represent links, link relations, and link announcements
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一致的形式来表示链接、链接关系和链接公告
- en: Provide a self-linking representation in a response message body
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在响应消息体中提供一个自链接表示
- en: Minimize the number of the advertised *entry point* or API URIs
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化广告的*入口点*或API URI的数量
- en: Use links to advertise any resource actions in a state-sensitive manner
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用链接以状态敏感的方式宣传任何资源操作
- en: Media type representation
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体类型表示
- en: A `GET` request won't have a request body, and the response body is always a
    resource representation. So, for every client request, except for `GET` requests,
    the API should define the media type in the request body and response body. The
    API media type relates to features such as sorting, filtering, paginating, and
    linking. So, media type formats and schemas should be consistent.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`请求不会包含请求体，响应体始终是资源表示。因此，对于除`GET`请求之外的所有客户端请求，API应在请求体和响应体中定义媒体类型。API媒体类型与排序、过滤、分页和链接等特性相关。因此，媒体类型格式和模式应保持一致。'
- en: Errors representation
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误表示
- en: 'Error status codes of HTTP methods (4xx and 5xx) can carry client-readable
    information in the response body. The following rules present consistent forms
    of errors and error responses:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP方法的错误状态码（4xx和5xx）可以在响应体中携带客户端可读信息。以下规则展示了错误和错误响应的一致形式：
- en: Errors and error responses should be consistent
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误和错误响应应保持一致
- en: Error types for generic and for common error conditions should also be consistent
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用和常见错误条件的错误类型也应保持一致
- en: 'The following diagram depicts a sample JSON response and addresses how errors
    and error codes predominate in API responses:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了一个示例JSON响应，并说明了错误和错误代码如何在API响应中占主导地位：
- en: '![](img/65f87d9f-a696-4c8f-bbd0-dc4c60aa0534.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65f87d9f-a696-4c8f-bbd0-dc4c60aa0534.png)'
- en: Client concerns
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端关注点
- en: As we know from the *API design best practices* section, the REST API clients in
    the REST API world are APP developers and REST APIs are designed to suit the needs
    of their client programs (APP developer code). This section deals with a set of
    REST API design principles to address common client concerns.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从*API设计最佳实践*部分所知，REST API世界的REST API客户端是APP开发者，REST API旨在满足其客户端程序（APP开发者代码）的需求。本节讨论一系列REST
    API设计原则，以解决常见的客户端关注点。
- en: Versioning
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本化
- en: A REST API is a collection of interlinked resources or resource models. The
    representational resources communicate their state through the versions. So versioning
    is one of the essential design principles, and we will look at the versioning
    of APIs before we state the rules for versioning.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: REST API是一组相互链接的资源或资源模型。表示性资源通过版本传递其状态。因此，版本化是基本设计原则之一，在陈述版本化规则之前，我们将查看API的版本化。
- en: 'APIs should be versioned (increase the major version) when it undergoes a breaking
    change; breaking changes include the following:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当API经历破坏性更改时，应该对其进行版本化（增加主版本）；破坏性更改包括以下内容：
- en: Response data changes
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应数据更改
- en: Response type changes
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应类型更改
- en: Removing any part of the API
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除API的任何部分
- en: 'APIs should undergo version changes even when it involves minor or non-breaking
    modifications, such as adding new endpoints or new response parameters. Minor
    versions help to track the APIs'' small changes and assist in customer support,
    who may be receiving cached versions of data or may be experiencing other API
    issues. Following are a few of the rules about REST API versioning:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 即使涉及较小的或非破坏性修改，如添加新端点或新响应参数，API也应进行版本更改。小版本有助于跟踪API的小变化，并协助客户支持，他们可能正在接收缓存的数据版本或可能遇到其他API问题。以下是关于REST
    API版本化的几个规则：
- en: Use new URIs to introduce new models or conceptions
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的URI引入新的模型或概念
- en: Use schemas for managing representational form versions
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模式来管理表示形式版本
- en: Make use of ETags to manage representational state versions
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用ETags来管理表示状态版本
- en: The general versioning practices follow schematic versioning ([https://semver.org/](https://semver.org/));
    however, the versioning practices in RESTful API attract lots of discussions,
    and please be aware that, as API designers, we may need to make decisions aligned
    with business needs and impacts.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 通用版本化实践遵循方案版本化（[https://semver.org/](https://semver.org/)）；然而，RESTful API中的版本化实践引起了大量讨论，请注意，作为API设计者，我们可能需要根据业务需求和影响做出决策。
- en: Security
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: 'REST APIs may expose resources that contain secure information intended to
    be revealed only to restricted clients, and the following rules help to secure
    resources:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: REST API可能会暴露包含仅限于特定客户端查看的安全信息的资源，以下规则有助于保护这些资源：
- en: Use OAuth, an HTTP-based authorization protocol, to protect resources
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于HTTP的授权协议OAuth来保护资源
- en: Use API management solutions, such as reverse proxy, to protect resources
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API管理解决方案，如反向代理，来保护资源
- en: We've provided a sample implementation as an example in the next chapter.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下一章提供了一个示例实现。
- en: Response representation composition
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应表示组合
- en: 'When REST APIs evolve with new features, the client may require new resources
    from its supporting REST API. However, for many practical reasons, the client
    may need new resources from the REST API. So a REST API can provide a measure
    to control the composition of its response representations. It''s crucial that
    REST APIs maintain a consistent resource model design, so clients can benefit
    from the composite responses. The following two rules enable the client to tune
    the responses:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当REST API随着新功能的发展而演变时，客户端可能需要从其支持的REST API获取新的资源。然而，出于许多实际原因，客户端可能需要从REST API获取新的资源。因此，REST
    API可以提供一种控制其响应表示组成的措施。REST API保持一致的资源模型设计至关重要，这样客户端才能从组合响应中受益。以下两个规则使客户端能够调整响应：
- en: It should support partial response by using the query component of a URI
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该支持通过使用URI的查询组件进行部分响应
- en: It should embed linked resources by using the query component of a URI
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该通过使用URI的查询组件嵌入链接资源
- en: For examples, you may refer back the *URI query* section of this chapter.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以参考本章的*URI查询*部分。
- en: Processing hypermedia
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理超媒体
- en: We discussed earlier two hypermedia structures, link and link relation. They
    help clients to process the response structure using a consistent algorithm.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了两种超媒体结构，链接和链接关系。它们帮助客户端使用一致的算法处理响应结构。
- en: 'The client should interact with a specific REST API response representation
    link. The following points discuss a simple flow:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应与特定的REST API响应表示链接进行交互。以下要点讨论了一个简单的流程：
- en: The client processing program starts by looking up the link using its relation's
    name, and interacts with the link lookup using the appropriate HTTP request method
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端处理程序首先通过其关系名称查找链接，并使用适当的HTTP请求方法与链接查找进行交互。
- en: The client code inspects the method field of the link's relation document resource
    and decides whether the content should be submitted in the request message body
    or not
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端代码检查链接关系文档资源的method字段，以决定内容是否应该提交到请求消息体中。
- en: JavaScript clients
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript客户端
- en: It's most common that JavaScript clients wish to interact with REST APIs. However,
    there are restrictions imposed (sandboxed) by the web browsers same-origin, also
    known as **same domain policy**. It restricts the JavaScript client from accessing
    resources if the resources aren't from the same domain/own source. The URI scheme,
    host, and port components indicate whether the resource origin is from the same
    domain. The browsers impose the same-origin policy to prevent leaking of confidential
    user data.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是，JavaScript客户端希望与REST API交互。然而，网络浏览器对同源（也称为**同源策略**）施加了限制（沙盒化）。它限制了JavaScript客户端访问资源，如果资源不是来自同一域/自身来源。URI方案、主机和端口组件指示资源来源是否来自同一域。浏览器实施同源策略以防止泄露机密用户数据。
- en: 'However, in most cases, the REST API needs to provide multi-origin read/write
    access from JavaScript for its JavaScript clients, and we will see how the following
    rules enable such flexibility:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，REST API需要为其JavaScript客户端提供从JavaScript的多源读写访问，我们将看到以下规则如何实现这种灵活性：
- en: Support multi-origin read access with **JSON with padding** (**JSONP**) from
    JavaScript
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持从JavaScript使用**带填充的JSON**（**JSONP**）进行多源读取访问
- en: Support **cross-origin resource sharing** (**CORS**) to provide multi-origin
    read/write access from JavaScript
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持**跨源资源共享**（**CORS**）以提供从JavaScript的多源读写访问
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As part of design strategies, we looked at what an API is and its importance
    for connecting devices with various other devices and technologies in the digitization
    era. We examined a few essential API design characteristics, such as affordance,
    leveraging, and maximizing existing web infrastructure, along with API design
    goals, such as consistency, simplification, flexible yet stable APIs, and how
    it is essential for an API designer to focus on the APP developers—the consumers
    of the APIs.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计策略的一部分，我们探讨了API是什么以及它在数字化时代连接各种设备和技术的意义。我们考察了一些基本的API设计特性，如可用性、利用现有网络基础设施以及API设计目标，例如一致性、简化、灵活且稳定的API，以及API设计者如何关注APP开发者——API的消费者。
- en: We also briefly discussed the role of an API designer and how they need to follow
    design principles and rules, so that they can create better RESTful APIs. We concluded
    this chapter by giving the necessary rules for RESTful APIs, along with some dos
    and don'ts.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要讨论了API设计者的角色以及他们需要遵循的设计原则和规则，以便他们能够创建更好的RESTful API。我们通过给出RESTful API的必要规则以及一些应该做和不应该做的事情来结束本章。
- en: So, we've set a strong foundation and the path for you to get your hands on
    API programming in our next two chapters as they deal with hands-on REST API programs
    implementations, with various RESTful API design patterns and applications.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在下一章为你打下了坚实的基础和路径，以便你能够掌握API编程，因为它们涉及实际的REST API程序实现，以及各种RESTful API设计模式和应用程序。
- en: Further reading
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We encourage readers to refer to [https://www.packtpub.com/all](https://www.packtpub.com/all)
    for various reference materials and a vast collection of books on RESTful services
    and APIs.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励读者参考[https://www.packtpub.com/all](https://www.packtpub.com/all)以获取各种参考资料和大量关于RESTful服务和API的书籍。
