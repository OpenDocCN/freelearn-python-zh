<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Improving the User Experience</h1></div></div></div><p>This chapter presents an overview of useful components that Kivy provides to make the programmer's life easier when it is time to improve the user experience. Some Kivy components reviewed in this chapter are related to widgets that include very particular functionalities (for example, a color palette); in this case, you will learn the basic techniques to control them. Other widgets will help us expand the use of the canvas, for example, changing the color, rotating and scaling shapes, or handling gestures. Finally, we will quickly improve the look and feel of the application with a few tips. All the sections are intended to increase the usability of the application and are self-contained. The following is the list of topics we will review in the chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Switching between different screens</li><li class="listitem" style="list-style-type: disc">Using the Kivy palette widget to select colors</li><li class="listitem" style="list-style-type: disc">Controlling the visible area of the canvas</li><li class="listitem" style="list-style-type: disc">Rotating and scaling with multi-touch gestures</li><li class="listitem" style="list-style-type: disc">Creating single gestures to draw on the screen</li><li class="listitem" style="list-style-type: disc">Enhancing the design with a few global changes</li></ul></div><p>More importantly, we will discuss how to incorporate these topics into a current working project. This will reinforce your previously acquired knowledge and explore a new programming situation in which we need to add functionality to an existent code. At the end of this chapter, you should feel comfortable with exploring all the different widgets that the Kivy API offers, and quickly understand how to integrate them into your code.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>ScreenManager – selecting colors for the figures</h1></div></div></div><p>The <strong><code class="literal">ScreenManager</code></strong> class lets us handle different screens in the same window. In Kivy, screens <a id="id343" class="indexterm"/>are preferred over windows, because we are <a id="id344" class="indexterm"/>programming for different devices with different screen sizes. Therefore, it is difficult (if not impossible) to have windows that adapt properly to all devices. Just imagine yourself juggling windows with your fingers on your mobile phone.</p><p>So far, all our figures have been of the same color. Let's allow the user to add some color to make the <em>Comic Creator</em> more versatile. Kivy provides us with a <code class="literal">Widget</code> called <strong><code class="literal">ColorPicker</code></strong>, which<a id="id345" class="indexterm"/> is<a id="id346" class="indexterm"/> displayed<a id="id347" class="indexterm"/> in the following screenshot:</p><div><img src="img/B04244_04_01.jpg" alt="ScreenManager – selecting colors for the figures"/></div><p>As you can see, this <code class="literal">Widget</code> requires a wide space, so it would be difficult to accommodate it in our current interface.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>There is a bug in Kivy 1.9.0 that prevents <code class="literal">ColorPicker</code> from working in Python 3 (it is already fixed in the development version 1.9.1-dev, which is available at <a class="ulink" href="https://github.com/kivy/kivy/">https://github.com/kivy/kivy/</a>). You can use Python 2, or there is an alternative<a id="id348" class="indexterm"/> code for Python 3 included in the code that you can download from the Packt Publishing website. Instead of the <code class="literal">ColorPicker</code>, there is a widget based on <code class="literal">GridLayout</code> to select a few colors. The concepts that we will discuss in this section are also reflected in that code.</p></div></div><p>The <strong><code class="literal">ScreenManager</code></strong> class<a id="id349" class="indexterm"/> allows us to have multiple screens instead of just one <code class="literal">Widget</code> (<code class="literal">ComicCreator</code>), and also lets us switch easily between the screens. Here is a new Kivy file (<code class="literal">comicscreenmanager.kv</code>) that contains the <code class="literal">ComicScreenManager</code> class definition:</p><div><pre class="programlisting">1. # File name: comicscreenmanager.kv
2. #:import FadeTransition kivy.uix.screenmanager.FadeTransition
3. &lt;ComicScreenManager&gt;:
4.     transition: FadeTransition()
5.     color_picker: _color_picker
6.     ComicCreator:
7.     Screen:
8.         name: 'colorscreen'
9.         ColorPicker:
10.             id: _color_picker
11.             color: 0,.3,.6,1
12.             Button:
13.                 text: "Select"
14.                 pos_hint: {'center_x': .75, 'y': .05}
15.                 size_hint: None, None
16.                 size: 150, 50
17.                 on_press: root.current = 'comicscreen'</pre></div><p>We <a id="id350" class="indexterm"/>embedded <a id="id351" class="indexterm"/>the <code class="literal">ColorPicker</code> instance<a id="id352" class="indexterm"/> inside a <strong><code class="literal">Screen</code></strong> widget (line 7), instead of adding it directly to the <code class="literal">ComicScreenManager</code>.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>A <strong><code class="literal">ScreenManager</code></strong> instance must contain widgets of the <strong><code class="literal">Screen</code></strong> base class. No other <a id="id353" class="indexterm"/>types of <code class="literal">Widget</code> (label, button, or layouts) are allowed.</p></div></div><p>Since we have also added our <code class="literal">ComicCreator</code> to <code class="literal">ScreenManager</code> (line 6), we need to make sure that our <code class="literal">ComicCreator</code> inherits from the <code class="literal">Screen</code> class in the <code class="literal">comiccreator.kv</code> file, so we need to change the file header:</p><div><pre class="programlisting">18. # File name: comiccreator.kv
19. &lt;ComicCreator@Screen&gt;:
20.     name: 'comicscreen'
21.     AnchorLayout:…</pre></div><p>The <strong><code class="literal">name</code></strong> property (line 20) is used <a id="id354" class="indexterm"/>to identify the screen with an ID, in this <a id="id355" class="indexterm"/>case <code class="literal">comicscreen</code>, and it is used to change between the screens of <code class="literal">ScreenManeger</code> through its <strong><code class="literal">current</code></strong> property. For example, the <code class="literal">Button</code> instance that we added to <code class="literal">ColorPicker</code> (line 12), uses the <code class="literal">name</code> property to change the <code class="literal">current</code> screen in the <code class="literal">on_press</code> event (line 17). The <code class="literal">root</code> refers to the <code class="literal">ScreenManager</code> class <a id="id356" class="indexterm"/>and the <strong><code class="literal">current</code></strong> property tells it what the active <code class="literal">Screen</code> is. In this case <code class="literal">comicscreen</code>, the name we assigned to identify the <code class="literal">ComicCreator</code> instance. Notice that we add the Python code directly (line 17) instead of calling a method as we did in <a class="link" href="ch03.html" title="Chapter 3. Widget Events – Binding Actions">Chapter 3</a>, <em>Widget Events – Binding Actions</em>.</p><p>We also gave a name (<code class="literal">colorscreen</code>) to the screen that contains the <code class="literal">ColorPicker</code> instance. We will use this name to activate <code class="literal">ColorPicker</code> with the <strong>Color</strong> button in the <em>general options</em> area. We need to modify the <code class="literal">color</code> method of <code class="literal">generaloptions.py</code>:</p><div><pre class="programlisting">22. def color(self, instance):
23.     self.comic_creator.manager.current = 'colorscreen'</pre></div><p>The <strong>Color</strong> button<a id="id357" class="indexterm"/> now switches the screen in order to <a id="id358" class="indexterm"/>display the <code class="literal">ColorPicker</code> instance. Notice the way we access <code class="literal">ScreenManager</code> (line 23). First, we use the <code class="literal">comic_creator</code> reference in the <code class="literal">GeneralOptions</code> class to access the <code class="literal">ComicCreator</code> instance. Second, we <a id="id359" class="indexterm"/>use the <strong><code class="literal">manager</code></strong> attribute of <code class="literal">Screen</code> to access its corresponding <code class="literal">ScreenManager</code>. Finally, we change <code class="literal">current</code> <code class="literal">Screen</code>, analogous to line 17.</p><p>
<code class="literal">ComicScreenManager</code> now becomes the main <code class="literal">Widget</code> of the <code class="literal">ComicCreator</code> project so the <code class="literal">comicreator.py</code> file has to change accordingly:</p><div><pre class="programlisting">24. # File name: comiccreator.py
25. from kivy.app import App
26. from kivy.lang import Builder
27. from kivy.uix.screenmanager import ScreenManager
28. 
29. Builder.load_file('toolbox.kv')
30. Builder.load_file('comicwidgets.kv')
31. Builder.load_file('drawingspace.kv')
32. Builder.load_file('generaloptions.kv')
33. Builder.load_file('statusbar.kv')
34. Builder.load_file('comiccreator.kv')
35. 
36. class ComicScreenManager(ScreenManager):
37.     pass
38. 
39. class ComicScreenManagerApp(App):
40.     def build(self):
41.         return ComicScreenManager()
42. 
43. if __name__=="__main__":
44.     ComicScreenManagerApp().run()</pre></div><p>Since we changed the name of the app to <code class="literal">ComicScreenManagerApp</code> (line 44), we explicitly load the <code class="literal">comiccreator.kv</code> file (line 34). Remember that the <code class="literal">comicscreenmanager.kv</code> file is going to be called automatically since the name of the app is now <code class="literal">ComicScreenManagerApp</code>.</p><p>One <a id="id360" class="indexterm"/>last interesting thing about the <code class="literal">ScreenManager</code> is<a id="id361" class="indexterm"/> that we can use <strong>transitions</strong>. Just as an example, the lines 2 and 4 import and use a simple <strong><code class="literal">FadeTransition</code></strong>.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>Kivy<a id="id362" class="indexterm"/> provides<a id="id363" class="indexterm"/> a <a id="id364" class="indexterm"/>set of transitions (<strong><code class="literal">FadeTransition</code></strong>, <strong><code class="literal">SwapTransition</code></strong>, <strong><code class="literal">SlideTransition</code></strong>, and <strong><code class="literal">WipeTransition</code></strong>) to<a id="id365" class="indexterm"/> switch between the <code class="literal">Screen</code> instances of <code class="literal">ScreenManager</code>. Check the Kivy API for more information <a id="id366" class="indexterm"/>on how to customize them with different parameters at <a class="ulink" href="http://kivy.org/docs/api-kivy.uix.screenmanager.html">http://kivy.org/docs/api-kivy.uix.screenmanager.html</a>
</p></div></div><p>After<a id="id367" class="indexterm"/> these changes, we can switch between the two screens, <code class="literal">ColorPicker</code> and <code class="literal">ComicCreator</code>, by clicking on the <code class="literal">Color</code> button of <em>general options</em>, or the <code class="literal">Select</code> button of <code class="literal">ColorPicker</code>. We also set a different color in the <code class="literal">ColorPicker</code> instance<a id="id368" class="indexterm"/> with the <strong><code class="literal">color</code></strong> property (line 11); however, the selection of the color still has no effect on the drawing process. The next section covers how to set the selected color to the figures we draw.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Color control on the canvas – coloring figures</h1></div></div></div><p>The previous<a id="id369" class="indexterm"/> section focused on the selection of colors from a canvas <a id="id370" class="indexterm"/>but this selection didn't really have an effect yet. In this section, we will actually use the selected color. Assigning a color can be tricky if we are not careful. If you recall, in <a class="link" href="ch03.html" title="Chapter 3. Widget Events – Binding Actions">Chapter 3</a>, <em>Widget Events – Binding Actions</em>, <code class="literal">Color</code> is a context instruction that we must add to the canvas. Moreover, we have to be sure that we add the instruction before we draw the actual figure. Basically, selecting a color is similar to picking a crayon color to draw on a piece of paper. Until you change the crayon, you will continue drawing with its color.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>When the color of the context changes, it stays in that state until some other instruction modifies it explicitly. In <a class="link" href="ch02.html" title="Chapter 2. Graphics – the Canvas">Chapter 2</a>, <em>Graphics – the Canvas</em>, we use <code class="literal">PushMatrix</code> and <code class="literal">PopMatrix</code> for a similar problem but they only apply to transformation instructions (<code class="literal">Translate</code>, <code class="literal">Rotate</code>, and <code class="literal">Scale</code>) because they relate to the coordinate space (that explains the matrix part of the instructions names: <code class="literal">PushMatrix</code> and <code class="literal">PopMatrix</code>).</p></div></div><p>Let's study<a id="id371" class="indexterm"/> a small example (from the <em>Comic Creator</em> project) to<a id="id372" class="indexterm"/> understand this concept better:</p><div><pre class="programlisting">45. # File name: color.py
46. from kivy.app import App
47. from kivy.uix.gridlayout import GridLayout
48. from kivy.lang import Builder
49. 
50. Builder.load_string("""
51. &lt;GridLayout&gt;:
52.     cols:2
53.     Label:
54.         color: 0.5,0.5,0.5,1
55.         canvas:
56.             Rectangle:
57.                 pos: self.x + 10, self.y + 10
58.                 size: self.width - 20, self.height - 20
59.     Widget:
60.         canvas:
61.             Rectangle:
62.                 pos: self.x + 10, self.y + 10
63.                 size: self.width - 20, self.height - 20
64. """)
65. 
66. class LabelApp(App):
67.     def build(self):
68.         return GridLayout()
69. 
70. if __name__=="__main__":
71.     LabelApp().run()</pre></div><div><div><h3 class="title"><a id="note31"/>Note</h3><p>Notice<a id="id373" class="indexterm"/> that we use the <strong><code class="literal">load_string</code></strong> method of <a id="id374" class="indexterm"/>the <strong><code class="literal">Builder</code></strong> class instead of using the <strong><code class="literal">load_file</code></strong> method. This <a id="id375" class="indexterm"/>method allows us to embed Kivy language statements inside a Python code file.</p></div></div><p>One of the properties of <code class="literal">Label</code> is called <code class="literal">color</code>; it changes the color of the <code class="literal">Label</code> text. We change <code class="literal">color</code> to gray (line 54) in the first <code class="literal">Label</code> but it doesn't clean the context. Observe the result in the following screenshot:</p><div><img src="img/B04244_04_02.jpg" alt="Color control on the canvas – coloring figures"/></div><p>The rectangle of <code class="literal">Label</code> (line 56), but also the rectangle <a id="id376" class="indexterm"/>of <code class="literal">Widget</code> (Line 61) have both changed color. Kivy tries to keep all its components as simple as possible to avoid unnecessary instructions. We will follow this approach for the colors, so we won't worry about the color until we need to use it. Any other components can take care of their own color.</p><p>We can now implement the changes in the <em>Comic Creator</em>. There are only three methods where we draw in the <em>drawing space</em> (all of them are in the <code class="literal">toolbox.py</code> file). Here are those methods with the corresponding new lines highlighted:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">draw</code> method in the <code class="literal">ToolStickman</code> class:<div><pre class="programlisting">72. def draw(self, ds, x, y):
73.     sm = StickMan(width=48, height=48)
74.     sm.center = (x,y)
<strong>75.     screen_manager = self.parent.comic_creator.manager</strong>
<strong>76.     color_picker = screen_manager.color_picker</strong>
<strong>77.     sm.canvas.before.add(Color(*color_picker.color))</strong>
78.     ds.add_widget(sm)</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">draw</code> method in the <code class="literal">ToolFigure</code> class:<div><pre class="programlisting">79. def draw(self, ds, x, y):
80.     (self.ix, self.iy) = (x,y)
<strong>81.     screen_manager = self.parent.comic_creator.manager</strong>
<strong>82.     color_picker = screen_manager.color_picker</strong>
83.     with ds.canvas:
84.         Color(*color_picker.color)
<strong>85.         self.figure=self.create_figure(x,y,x+1,y+1)</strong>
86.     ds.bind(on_touch_move=self.update_figure)
87.     ds.bind(on_touch_up=self.end_figure)</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">widgetize</code> method in the <code class="literal">ToolFigure</code> class:<div><pre class="programlisting">88. def widgetize(self,ds,ix,iy,fx,fy):
89.     widget = self.create_widget(ix,iy,fx,fy)
90.     (ix,iy) = widget.to_local(ix,iy,relative=True)
91.     (fx,fy) = widget.to_local(fx,fy,relative=True)
<strong>92.     screen_manager = self.parent.comic_creator.manager</strong>
<strong>93.     color_picker = screen_manager.color_picker</strong>
<strong>94.     widget.canvas.add(Color(*color_picker.color))</strong>
95.     widget.canvas.add(self.create_figure(ix,iy,fx,fy))
96.     ds.add_widget(widget)</pre></div></li></ul></div><p>All three <a id="id377" class="indexterm"/>methods have a pair of specific instructions in common; you<a id="id378" class="indexterm"/> can find them in lines 75 and 76, 81 and 82, and 92 and 93. These are reference chains to get access to the <code class="literal">ColorPicker</code> instance. After this, we just add a <code class="literal">Color</code> instruction to the canvas (as we learned in <a class="link" href="ch02.html" title="Chapter 2. Graphics – the Canvas">Chapter 2</a>, <em>Graphics – the Canvas</em>) using the selected <code class="literal">color</code> in <code class="literal">color_picker</code> (lines 77, 84, and 94).</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>The "splat" operator (<code class="literal">*</code>) on lines 77, 84, and 94 is used in Python to unpack argument lists. In this case, the <code class="literal">Color</code> constructor is meant to receive three parameters<a id="id379" class="indexterm"/> with the red, green, and blue values, but we have a list stored in <strong><code class="literal">color_picker.color</code></strong>, for example, (<code class="literal">1,0,1</code>), so we need to unpack it to get three separated values <code class="literal">1,0,1</code>.</p></div></div><p>We also use <code class="literal">canvas.before</code> in the <code class="literal">draw</code> method of the <code class="literal">ToolStickman</code> class (line 77). This is used to ensure that the <code class="literal">Color</code> instruction is executed before the instructions we added in <code class="literal">canvas</code> of <code class="literal">Stickman</code> (the <code class="literal">comicwidgets.kv</code> file). This is not necessary in the other two methods because we have full control of the canvas order inside those methods.</p><p>Finally, we must import the <code class="literal">Color</code> class in the header of the file <code class="literal">from kivy.graphics import Line, Color</code>. We can now take a break and enjoy the result of our hard work with our <em>Comic Creator</em>:</p><div><img src="img/B04244_04_03.jpg" alt="Color control on the canvas – coloring figures"/></div><p>At a later point in time, we can discuss whether our drawing is just an avid <em>Comic Creator</em> fan or a narcissistic alien with an oversized t-shirt. For now, it seems more useful to learn how<a id="id380" class="indexterm"/> to limit the <em>drawing space</em> to the specific area that <a id="id381" class="indexterm"/>occupies the window.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>StencilView – limiting the drawing space</h1></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Widget Events – Binding Actions">Chapter 3</a>, <em>Widget Events – Binding Actions</em>, we avoided drawing outside of the <em>drawing space</em> by<a id="id382" class="indexterm"/> using simple mathematics and <code class="literal">collide_points</code>. It was far from perfect (for example, it fails in the group mode or when<a id="id383" class="indexterm"/> we resize it), and it was tedious and prone to programming mistakes.</p><p>That was sufficient for a first example, however, <strong><code class="literal">StencilView</code></strong> is the easier way to go here. <strong><code class="literal">StencilView</code></strong> limits the drawing area to the space occupied by itself. Anything drawn outside that area is hidden. First, let's modify the file <code class="literal">drawingspace.py</code> with the following header:</p><div><pre class="programlisting">97. # File name: drawingspace.py
98. from kivy.uix.stencilview import StencilView
99. 
100. class DrawingSpace(StencilView):
101.     ...</pre></div><p>
<code class="literal">The</code> <code class="literal">DrawingSpace</code> instance inherits now from <code class="literal">StencilView</code>, instead of <code class="literal">RelativeLayout</code>. The <code class="literal">StencilView</code> class doesn't use relative coordinates (as the <code class="literal">RelativeLayout</code> class does) but we would like to keep relative coordinates in the <em>drawing space</em> because they are convenient for drawing purposes. In order to do this, we can modify the top-right <code class="literal">AnchorLayout</code>, so the <code class="literal">DrawingSpace</code> instance is inside a <code class="literal">RelativeLayout</code> instance. We do this in the <code class="literal">comiccreator.kv</code> file:</p><div><pre class="programlisting">102.     AnchorLayout:
103.         anchor_x: 'right'
104.         anchor_y: 'top'
105.         RelativeLayout:
106.             size_hint: None,None
107.             width: root.width - _tool_box.width
108.             height: root.height - _general_options.height -     _status_bar.height
109.             DrawingSpace:
110.                 id: _drawing_space
111.                 general_options: _general_options
112.                 tool_box: _tool_box
113.                 status_bar: _status_bar</pre></div><p>When we <a id="id384" class="indexterm"/>embed the <code class="literal">DrawingSpace</code> instance (line 109) inside<a id="id385" class="indexterm"/> a <code class="literal">RelativeLayout</code> instance (line 105) of the same size (by default, the <code class="literal">DrawingSpace</code> instance uses <code class="literal">size_hint: 1, 1</code> occupying all the area of the <code class="literal">RelativeLayout</code> parent), then the coordinates inside the <code class="literal">DrawingSpace</code> instance are relative to the <code class="literal">RelativeLayout</code> instance. Since they are of the same size, then the coordinates are also relative to the <code class="literal">DrawingSpace</code> instance.</p><p>We kept the <code class="literal">DrawingSpace</code> ID (line 110) and attributes (lines 111 to 113). Since we have a new level of indentation and the <code class="literal">DrawingSpace</code> class is not relative itself, this affects the way we localize the coordinates in the <code class="literal">ToolBox</code> instance, specifically, in <code class="literal">on_touch_down</code> of the <code class="literal">ToolButton</code> class, and <code class="literal">update_figure</code> and <code class="literal">end_figure</code> of the <code class="literal">ToolFigure</code> class. The following is the new code for <code class="literal">on_touch_down</code> of the <code class="literal">ToolButton</code> class:</p><div><pre class="programlisting">114.     def on_touch_down(self, touch):
115.         ds = self.parent.drawing_space
116.         if self.state == 'down' and\ ds.parent.collide_point(touch.x, touch.y):
117.             (x,y) = ds.to_widget(touch.x, touch.y)
118.             self.draw(ds, x, y)
119.             return True
120.             return super(ToolButton, self).on_touch_down(touch)</pre></div><p>We receive absolute coordinates in this method since we are inside <code class="literal">ToolButton</code>, which doesn't belong to any <code class="literal">RelativeLayout</code> instance. The <em>drawing space</em> also receives absolute coordinates, but it will interpret them inside the context of the <code class="literal">RelativeLayout</code> instance that it is embedded in. The right approach for the <code class="literal">DrawingSpace</code> instance is to ask its <code class="literal">RelativeLayout</code> parent who will collide the coordinates (received in the <code class="literal">ToolButton</code>) correctly (line 116)</p><p>The following is the new code of <code class="literal">update_figure</code> and <code class="literal">end_figure</code> of the <code class="literal">ToolFigure</code> class:</p><div><pre class="programlisting">121. def update_figure(self, ds, touch):
122.     ds.canvas.remove(self.figure)
123.     with ds.canvas:
124.         self.figure = self.create_figure(self.ix, self.iy,touch.x,touch.y)
125. 
126. def end_figure(self, ds, touch):
127.     ds.unbind(on_touch_move=self.update_figure)
128.     ds.unbind(on_touch_up=self.end_figure)
129.     ds.canvas.remove(self.figure)
130.     self.widgetize(ds,self.ix,self.iy,touch.x,touch.y)</pre></div><p>We removed<a id="id386" class="indexterm"/> some instructions because we no longer need them. First <a id="id387" class="indexterm"/>off, we don't need to use the <code class="literal">to_widget</code> method anymore in either of the two methods, since we are already getting the coordinates from the <code class="literal">RelativeLayout</code> parent. And secondly, we don't need to worry about applying the <code class="literal">collide_point</code> method in the <code class="literal">update_figure</code> method because <code class="literal">StencilView</code> will be in charge of it; any drawing that takes place outside the bounds is discarded.</p><p>With just a few changes, we ensured that nothing will be drawn outside of the <em>drawing space</em>, and, with that guarantee, we can now proceed to discuss how to drag, rotate, and scale the figures.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Scatter – multi-touching to drag, rotate, and scale</h1></div></div></div><p>In the previous chapter (<a class="link" href="ch03.html" title="Chapter 3. Widget Events – Binding Actions">Chapter 3</a>, <em>Widget Events – Binding Actions</em>), you learned how to use events to drag <a id="id388" class="indexterm"/>widgets. You learned how to use the <code class="literal">on_touch_up</code>, <code class="literal">on_touch_move</code>, and <code class="literal">on_touch_down</code> events. However, the <strong><code class="literal">Scatter</code></strong> class <a id="id389" class="indexterm"/>already <a id="id390" class="indexterm"/>provides that functionality and also lets us scale and<a id="id391" class="indexterm"/> rotate using two fingers, as one would on a mobile or tablet screen. All the functionality is included inside the <strong><code class="literal">Scatter</code></strong> class; however, we need to apply a few changes to keep our project consistent. In particular, we still want our <em>group mode</em> to work, so that translating, scaling, and rotating can happen at the same time. Let us implement the changes in four big steps in the <code class="literal">comicwidgets.py</code> file:</p><div><ol class="orderedlist arabic"><li class="listitem">Replace the <code class="literal">DraggableWidget</code> base class. Let's use <code class="literal">Scatter</code> instead of <code class="literal">RelativeLayout</code> (line <code class="literal">132</code> and <code class="literal">135</code>):<div><pre class="programlisting">131. # File name: comicwidgets.py
132. from kivy.uix.scatter import Scatter
133. from kivy.graphics import Line
134. 
135. class DraggableWidget(Scatter):</pre></div><div><div><h3 class="title"><a id="note32"/>Note</h3><p>Both <code class="literal">Scatter</code> and <code class="literal">RelativeLayout</code> use relative coordinates.</p></div></div></li><li class="listitem">Make<a id="id392" class="indexterm"/> sure that<a id="id393" class="indexterm"/> the <code class="literal">on_touch_down</code> event <a id="id394" class="indexterm"/>of <code class="literal">DraggableWidget</code> is sent to the base <a id="id395" class="indexterm"/>class (<code class="literal">Scatter</code>) by calling the <code class="literal">super</code> method (line <code class="literal">140</code>) before <code class="literal">return True</code> (line <code class="literal">141</code>) inside the condition. If you don't do that, the <code class="literal">Scatter</code> base class will never receive the event <code class="literal">on_touch_down</code> and nothing will happen:<div><pre class="programlisting">136. def on_touch_down(self, touch):
137.     if self.collide_point(touch.x, touch.y):
138.         self.touched = True
139.         self.select()
140.         super(DraggableWidget, self).on_touch_down(touch)
141.         return True
142.     return super(DraggableWidget, self).on_touch_down(touch)</pre></div><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>The <code class="literal">super</code> method is useful for the base class (<code class="literal">Scatter</code>) and the <code class="literal">return</code> statement is useful for the parent (<code class="literal">DrawingSpace</code>)</p></div></div></li><li class="listitem">Remove the <code class="literal">on_touch_move</code> method and add an <code class="literal">on_pos</code> method, which is called when the <code class="literal">pos</code> property is modified. Since <code class="literal">Scatter</code> will be responsible for dragging, we don't need <code class="literal">on_touch_move</code> anymore. Instead, we will use the <code class="literal">pos</code> property that is modified by <code class="literal">Scatter</code>. Remember that the properties trigger an event that will call on the <code class="literal">on_pos</code> method:<div><pre class="programlisting">143. def on_pos(self, instance, value):
144.     if self.selected and self.touched:
145.         go = self.parent.general_options
146.         go.translation = (self.center_x- self.ix, self.center_y - self.iy)
147.         self.ix = self.center_x
148.         self.iy = self.center_y</pre></div></li><li class="listitem">Scatter has two other properties: <code class="literal">rotation</code> and <code class="literal">scale</code>. We can use the same idea as with <code class="literal">pos</code> and <code class="literal">on_pos</code>, and add the <code class="literal">on_rotation</code> and <code class="literal">on_scale</code> methods:<div><pre class="programlisting">149.     def on_rotation(self, instance, value):
150.         if self.selected and self.touched:
151.             go = self.parent.general_options
152.             go.rotation = value
153. 
154.     def on_scale(self, instance, value):
155.         if self.selected and self.touched:
156.             go = self.parent.general_options
157.             go.scale = value</pre></div></li></ol></div><p>The <code class="literal">on_rotation</code> and <code class="literal">on_scale</code> methods modify a couple of new properties (lines 152 and 157) that <a id="id396" class="indexterm"/>we <a id="id397" class="indexterm"/>need to add to the <code class="literal">GeneralOptions</code> class. This<a id="id398" class="indexterm"/> will help us to keep the group mode working. The following <a id="id399" class="indexterm"/>code is the new header of <code class="literal">generaloptions.py</code> that includes the new properties:</p><div><pre class="programlisting">158. # File name: generaloptions.py
159. from kivy.uix.boxlayout import BoxLayout
160. from kivy.properties import NumericProperty, ListProperty
161. 
162. class GeneralOptions(BoxLayout):
163.     group_mode = False
164.     translation = ListProperty(None)
165.     rotation = NumericProperty(0)
166.     scale = NumericProperty(0)</pre></div><p>We import <code class="literal">NumericProperty</code> along with <code class="literal">ListProperty</code> (line 160); and we create the two missing properties: <code class="literal">rotation</code> and <code class="literal">scale</code> (lines 165 and 166). We also need to add the <code class="literal">on_rotation</code> (line 167) and <code class="literal">on_scale</code> (line 172) methods (associated with the <code class="literal">rotation</code> and <code class="literal">scale</code> properties), which will ensure that all the <code class="literal">selected</code> components are rotated or scaled at once, by traversing the list of children that have been added to the <em>drawing space</em> (line 173 and 177):</p><div><pre class="programlisting">167    def on_rotation(self, instance, value):
168.         for child in self.drawing_space.children:
169.             if child.selected and not child.touched:
170.                 child.rotation = value
171. 
172.     def on_scale(self, instance, value):
173.         for child in self.drawing_space.children:
174.             if child.selected and not child.touched:
175.                 child.scale = value</pre></div><p>A final modification is necessary. We need to change the <code class="literal">on_translation</code> method to check that the current <code class="literal">child</code> in the loop is not the one being touched (if this happens, call the police!), because this could cause an infinitive recursion since we modify the properties that call on this event in the first place. Here <a id="id400" class="indexterm"/>is <a id="id401" class="indexterm"/>the new <code class="literal">on_translation</code> method<a id="id402" class="indexterm"/> in<a id="id403" class="indexterm"/> the <code class="literal">generaloptions.py</code> file:</p><div><pre class="programlisting">176.     def on_translation(self,instance,value):
177.         for child in self.drawing_space.children:
178.             if child.selected and not child.touched:
179.                 child.translate(*self.translation)</pre></div><p>At this point, we are able to translate, rotate, or scale the figures with our fingers, even in the <em>group mode</em>.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>Kivy provides a way to simulate multi-touch with the mouse. It is limited but you can still test this section with your one-mouse laptop. All you have to do is right-click on the figure you want to rotate. A translucent red circle will appear on the screen. Then, you can use the normal left dragging as if it were a second finger to rotate or scale. To clear the simulated multi-touch, you left-click on the red icon.</p></div></div><p>The next screenshot cut shows our <code class="literal">StickMan</code> being rotated and scaled at the same time as the line next to him. The small <code class="literal">StickMan</code> on the right is just a reference to compare against the original size. The simulated multi-touch gesture is being applied to the line on the right and that is why you can see a red (gray in the printed version) dot:</p><div><img src="img/B04244_04_04.jpg" alt="Scatter – multi-touching to drag, rotate, and scale"/></div><p>In <a class="link" href="ch01.html" title="Chapter 1. GUI Basics – Building an Interface">Chapter 1</a>, <em>GUI Basics – Building an Interface</em>, we briefly mention <strong><code class="literal">ScatterLayout</code></strong> but now the <a id="id404" class="indexterm"/>difference<a id="id405" class="indexterm"/> between <strong><code class="literal">ScatterLayout</code></strong> and <strong><code class="literal">Scatter</code></strong> may be clear.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>
<strong><code class="literal">ScatterLayout</code></strong> is a Kivy layout that inherits from <code class="literal">Scatter</code> and contains <code class="literal">FloatLayout</code>. This allows you to use the <code class="literal">size_hint</code> and <code class="literal">pos_hint</code> properties when you add widgets inside it. <code class="literal">ScatterLayout</code> also uses relative coordinates. This doesn't mean you cannot add other widgets inside a simple <code class="literal">Scatter</code>; it just means that <code class="literal">Scatter</code> doesn't honor <code class="literal">size_hint</code> or <code class="literal">pos_hint</code>.</p></div></div><p>With<a id="id406" class="indexterm"/> the <a id="id407" class="indexterm"/>use <a id="id408" class="indexterm"/>of <code class="literal">Scatter</code>, we are able <a id="id409" class="indexterm"/>to drag, rotate, and scale our figures. This is a great improvement of functionality in our <em>Comic Creator</em>. Let's now increase the interaction with the user even more, learn how to create our own gestures, and use them inside our project.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Recording gestures – line, circle, and cross</h1></div></div></div><p>What<a id="id410" class="indexterm"/> about drawing with one finger? Can we recognize gestures? It is possible to do this with Kivy. First, we need to record the gestures that we want to use. A gesture is represented as a long string that contains the points of a stroke over the screen. The following code uses the Kivy <code class="literal">Gesture</code> and <code class="literal">GestureDatabase</code> classes to record gesture strokes. It can be run with Python <code class="literal">gesturerecorder.py</code>:</p><div><pre class="programlisting">180. # File Name: gesturerecorder.py
181. from kivy.app import App
182. from kivy.uix.floatlayout import FloatLayout
183. from kivy.graphics import Line, Ellipse
184. from kivy.gesture import Gesture, GestureDatabase
185. 
186. class GestureRecorder(FloatLayout):
187. 
188.     def on_touch_down(self, touch):
189.         self.points = [touch.pos]
190.         with self.canvas:
191.             Ellipse(pos=(touch.x-5,touch.y-5),size=(10,10))
192.             self.Line = Line(points=(touch.x, touch.y))
193. 
194.     def on_touch_move(self, touch):
195.         self.points += [touch.pos]
196.         self.line.points += [touch.x, touch.y]
197. 
198.     def on_touch_up(self, touch):
199.         self.points += [touch.pos]
200.         gesture = Gesture()
201.         gesture.add_stroke(self.points)
202.         gesture.normalize()
203.         gdb = GestureDatabase()
204.         print ("Gesture:", gdb.gesture_to_str(gesture).decode(encoding='UTF-8'))
205. 
206. class GestureRecorderApp(App):
207.     def build(self):
208.         return GestureRecorder()
209. 
210. if __name__=="__main__":
211.     GestureRecorderApp().run()</pre></div><p>The <a id="id411" class="indexterm"/>previous code prints the gesture string representations using <a id="id412" class="indexterm"/>the <a id="id413" class="indexterm"/>
<strong><code class="literal">Gesture</code></strong> and <strong><code class="literal">GestureDatabase</code></strong> classes (line 184). The <code class="literal">on_touch_down</code>, <code class="literal">on_touch_move</code>, and <code class="literal">on_touch_up</code> methods collect <code class="literal">points</code> of the stroke lines 189, 195, and 199. The following screenshots are examples of strokes collected with <code class="literal">gesturerecorded.py</code>:</p><div><img src="img/B04244_04_05.jpg" alt="Recording gestures – line, circle, and cross"/></div><p>The<a id="id414" class="indexterm"/> small <code class="literal">Circle</code> in the preceding figures (lines 190 and 191) indicates the starting point, and the line indicates the path that the stroke follows. The most relevant part is coded in lines 200 to 204. We create <code class="literal">Gesture</code> (line 200), add <code class="literal">points</code> for the stroke<a id="id415" class="indexterm"/> with the <strong><code class="literal">add_stroke</code></strong> method (line 201), <strong><code class="literal">normalize</code></strong> to<a id="id416" class="indexterm"/> a default number of points (line 202), and create a <code class="literal">GestureDatabase</code> instance (line 203) that we use in line 204 to generate the string (<strong><code class="literal">gesture_to_str</code></strong>) and <a id="id417" class="indexterm"/>print it on the screen.</p><p>The following screenshot shows the terminal output for the stroke line (corresponding to the first figure on the left in the preceding figures set):</p><div><img src="img/B04244_04_06.jpg" alt="Recording gestures – line, circle, and cross"/></div><p>In the preceding screenshot, the long string starting with <code class="literal">'eNq1Vktu…'</code> is the gesture serialization. We use these long strings as descriptors of the gestures that Kivy understands and uses to associate the stroke with any action we want to perform. The next section explains how to achieve this.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Recognizing gestures – drawing with the finger</h1></div></div></div><p>The previous<a id="id418" class="indexterm"/> section explained how to obtain string representations from gestures. The current section explains how to use those string representations to recognize the gestures. Kivy has some tolerance error in the gesture recognition, so you don't have to worry about repeating exactly the same stroke.</p><p>To start, we copied the strings that were generated from the strokes in the previous section into a new file called <code class="literal">gestures.py</code>. The strings are assigned to different variables. The following code corresponds to <code class="literal">gestures.py</code>:</p><div><pre class="programlisting">212. # File Name: gestures.py
213. line45_str = 'eNq1VktuI0cM3fdFrM0I...
214. circle_str = 'eNq1WMtuGzkQvM+P2JcI/Sb5A9rrA...
215. cross_str = 'eNq1V9tuIzcMfZ8fSV5qiH...</pre></div><p>Only the first few characters of the strings are shown in the previous code but you can download the complete file from the Packt Publishing website, or use the previous section to generate your own strings.</p><p>Next, we will use these strings in the <code class="literal">drawingspace.py</code> file. Let's start importing the necessary classes in the header first:</p><div><pre class="programlisting">216. # File name: drawingspace.py
217. from kivy.uix.stencilview import StencilView
218. from kivy.gesture import Gesture, GestureDatabase
219. from gestures import line45_str, circle_str, cross_str
220. 
221. class DrawingSpace(StencilView):</pre></div><p>In the preceding code, we import the <code class="literal">Gesture</code> and <code class="literal">GestureDatabase</code> classes (line 218) along with the gesture string representations added to <code class="literal">gestures.py</code> (lines 219). We added several methods to the <code class="literal">DrawingSpace</code> class. Let's quickly review each of the methods, and, at the end, highlight the key parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">__init__</code>: This <a id="id419" class="indexterm"/>method creates the attributes of the class and fills <code class="literal">GestureDatabase</code> using <strong><code class="literal">str_to_gesture</code></strong> in<a id="id420" class="indexterm"/> order to transform the strings into<a id="id421" class="indexterm"/> gestures, and <strong><code class="literal">add_gesture</code></strong> to add the gestures to the database:<div><pre class="programlisting">222. def __init__(self, *args, **kwargs):
223.     super(DrawingSpace, self).__init__()
224.     self.gdb = GestureDatabase()
225.     self.line45 = self.gdb.str_to_gesture(line45_str)
226.     self.circle = self.gdb.str_to_gesture(circle_str)
227.     self.cross = self.gdb.str_to_gesture(cross_str)
228.     self.line135 = self.line45.rotate(90)
229.     self.line225 = self.line45.rotate(180)
230.     self.line315 = self.line45.rotate(270)
231.     self.gdb.add_gesture(self.line45)
232.     self.gdb.add_gesture(self.line135)
233.     self.gdb.add_gesture(self.line225)
234.     self.gdb.add_gesture(self.line315)
235.     self.gdb.add_gesture(self.circle)
236.     self.gdb.add_gesture(self.cross)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">activate</code> and <code class="literal">deactivate</code>: These methods bind or unbind the methods to the touch <a id="id422" class="indexterm"/>events in order to start the gesture recognition <a id="id423" class="indexterm"/>mode. These methods<a id="id424" class="indexterm"/> are called by the gesture <code class="literal">Button</code> of the <em>general options</em>:<div><pre class="programlisting">237. def activate(self):
238.     self.tool_box.disabled = True
239.     self.bind(on_touch_down=self.down,
240.              on_touch_move=self.move,
241.              on_touch_up=self.up)
242. 
243. def deactivate(self):
244.     self.unbind(on_touch_down=self.down,
245.              on_touch_move=self.move,
246.              on_touch_up=self.up)
247.     self.tool_box.disabled = False</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">down</code>, <code class="literal">move</code> and <code class="literal">ups</code>: These methods<a id="id425" class="indexterm"/> record <a id="id426" class="indexterm"/>the points of the<a id="id427" class="indexterm"/> stroke in a very similar way that the previous section did:<div><pre class="programlisting">248. def down(self, ds, touch):
249.    if self.collide_point(*touch.pos):
250.        self.points = [touch.pos]
251.        self.ix = self.fx = touch.x
252.        self.iy = self.fy = touch.y
253.    return True
254. 
255. def move(self, ds, touch):
256.     if self.collide_point(*touch.pos):
257.         self.points += [touch.pos]
258.         self.min_and_max(touch.x, touch.y)
259.     return True
260. 
261. def up(self, ds, touch):
262.     if self.collide_point(*touch.pos):
263.        self.points += [touch.pos]
264.        self.min_and_max(touch.x, touch.y)
265.        gesture = self.gesturize()
266.        recognized = self.gdb.find(gesture, minscore=0.50)
267.        if recognized:
268.            self.discriminate(recognized)
269.     return True</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">gesturize</code>: This <a id="id428" class="indexterm"/>method creates a <code class="literal">Gesture</code> instance <a id="id429" class="indexterm"/>from the collected points in the previous methods:<div><pre class="programlisting">270. def gesturize(self):
271.     gesture = Gesture()
272.     gesture.add_stroke(self.points)
273.     gesture.normalize()
274.     return gesture</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">min_and_max</code>: This method keeps <a id="id430" class="indexterm"/>track of the extreme points of the stroke:<div><pre class="programlisting">275. def min_and_max(self, x, y):
276.     self.ix = min(self.ix, x)
277.     self.iy = min(self.iy, y)
278.     self.fx = max(self.fx, x)
279.     self.fy = max(self.fy, y)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Discriminate</code>: This method calls <a id="id431" class="indexterm"/>the corresponding method according to the recognized gesture:<div><pre class="programlisting">280. def discriminate(self, recognized):
281.     if recognized[1] == self.cross: 
282.         self.add_stickman()
283.     if recognized[1] == self.circle: 
284.         self.add_circle()
285.     if recognized[1] == self.line45:
286.         self.add_line(self.ix,self.iy,self.fx,self.fy)
287.     if recognized[1] == self.line135:
288.         self.add_line(self.ix,self.fy,self.fx,self.iy)
289.     if recognized[1] == self.line225:
290.        self.add_line(self.fx,self.fy,self.ix,self.iy)
291.     if recognized[1] == self.line315:
292.         self.add_line(self.fx,self.iy,self.ix,self.fy)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">add_circle</code>, <code class="literal">add_Line</code>, <code class="literal">add_stickman</code>: These<a id="id432" class="indexterm"/> methods <a id="id433" class="indexterm"/>use the corresponding <code class="literal">ToolButton</code> of <code class="literal">ToolBox</code> to add a figure <a id="id434" class="indexterm"/>according to the recognized gesture:<div><pre class="programlisting">293. def add_circle(self):
294.     cx = (self.ix + self.fx)/2.0
295.     cy = (self.iy + self.fy)/2.0
296.    self.tool_box.tool_circle.widgetize(self, cx, cy, self .fx, self.fy)
297. 
298. def add_line(self,ix,iy,fx,fy):
299.     self.tool_box.tool_line.widgetize(self,ix,iy,fx,fy)
300. 
301. def add_stickman(self):
302.     cx = (self.ix + self.fx)/2.0
303.     cy = (self.iy + self.fy)/2.0
304.     self.tool_box.tool_stickman.draw(self,cx,cy)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">on_children</code>: This <a id="id435" class="indexterm"/>method<a id="id436" class="indexterm"/> keeps the counter of the <em>Status Bar</em> updated:<div><pre class="programlisting">305. def on_children(self, instance, value):
306.     self.status_bar.counter = len(self.children)</pre></div></li></ul></div><p>The <code class="literal">DrawingSpace</code> class is now in charge of capturing strokes on the screen, search for them in the gesture database (that contains the gestures of the last section), and draw a shape accordingly. It also offers the possibility of activating and deactivating the gesture recognition. Let's cover this in four parts.</p><p>First, we need to create the <code class="literal">GestureDatabase</code> instance (line 224) and use it to create the gestures from the strings (lines 225 to 227). We rotate the <code class="literal">line45</code> gesture by 90 degrees (lines 228 to 230) four <a id="id437" class="indexterm"/>times with the <strong><code class="literal">rotate</code></strong> method, so the <code class="literal">GestureDatabase</code> instance recognizes the line gesture in different directions. Then, we load <code class="literal">GestureDatabase</code> with the generated gestures (lines 231 to 236). We added all of these instructions in the constructor of the class, the <code class="literal">__init__</code> method (lines 222 to 236), so the <code class="literal">DrawingSpace</code> class has all the elements to recognize gestures.</p><p>Second, we need to capture the gesture stroke. In order to do this, we use the touch events. We have created the methods associated with them: <code class="literal">down</code> (line 248), <code class="literal">move</code> (line 255), and <code class="literal">up</code> (line 261). These methods are similar to the <code class="literal">on_touch_down</code>, <code class="literal">on_touch_move</code>, and <code class="literal">on_touch_up</code> methods of the last section in the sense that they register the points of the stroke. However, they also keep track of the <em>extreme</em> axes of the stroke to define a bounding box for the stroke as the following figure illustrates:</p><div><img src="img/B04244_04_07.jpg" alt="Recognizing gestures – drawing with the finger"/></div><p>These points are used to define the size of the shape we will draw. The <code class="literal">up</code> method, firstly, uses the registered points to create a <code class="literal">Gesture</code> instance (line 265), secondly, makes the query to<a id="id438" class="indexterm"/> the <code class="literal">GestureDatabase</code> instance using the <strong><code class="literal">find</code></strong> method (line 266), and <a id="id439" class="indexterm"/>thirdly, calls the <code class="literal">discriminate</code> method to draw the appropriate shape (line 280). The <strong><code class="literal">minscore</code></strong> parameter of the <strong><code class="literal">find</code></strong> method (line 266) is used to indicate the precision of the search.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>We use a low level (<code class="literal">0.50</code>) since we know that the strokes are very different, and that a mistake in this application can be easily undone.</p></div></div><p>Third, we <a id="id440" class="indexterm"/>implement the <code class="literal">discriminate</code> method (line 280) to discriminate the <code class="literal">recognized</code> variable from among the three possible shapes of our <em>tool box</em>. The recognized variable (returned by the <strong><code class="literal">find</code></strong> method of <code class="literal">GestureDatabase</code>) is a pair, where the first element is the score of the recognition, and the second element is the actual recognized gesture. We use the second value (<code class="literal">recognized[1]</code>) for the discrimination process (line 281) and then call the corresponding method (<code class="literal">add_stickman</code>, <code class="literal">add_line</code>, and <code class="literal">add_circle</code>). In the case of lines, it also decides the order in which to send the coordinates to match the direction.</p><p>Fourth, the <code class="literal">activate</code> and <code class="literal">deactivate</code> methods provide an interface in order to activate or deactivate the <em>gesture mode</em> (the application mode in which we can use gestures). To activate the mode, the <code class="literal">activate</code> method binds the <code class="literal">on_touch_up</code>, <code class="literal">on_touch_move</code>, and <code class="literal">on_tourch_down</code> events to the corresponding <code class="literal">up</code>, <code class="literal">move</code>, and <code class="literal">down</code> methods. It also uses the <strong><code class="literal">disabled</code></strong> property (lines 238) to<a id="id441" class="indexterm"/> disable the <em>tool box</em> widget when the gesture mode is on. The <code class="literal">deactivate</code> method unbinds the events and restores the <strong><code class="literal">disabled</code></strong> property.</p><div><div><h3 class="title"><a id="note35"/>Note</h3><p>We applied the <strong><code class="literal">disabled</code></strong> property to the entire <code class="literal">ToolBox</code> instance, but it automatically looks for the children that belong to it and deactivates them as well. Basically, the event is never sent to the children.</p></div></div><p>The gestures<a id="id442" class="indexterm"/> mode is activated and deactivated from the general options buttons with the gestures <code class="literal">ToggleButton</code>. We need to change the definition of the <code class="literal">gestures</code> method in the <code class="literal">generaloptions.py</code> file:</p><div><pre class="programlisting">307. def gestures(self, instance, value):
308.     if value == 'down':
309.         self.drawing_space.activate()
310.     else:
311.         self.drawing_space.deactivate()</pre></div><p>When <strong><code class="literal">gestures</code></strong> <code class="literal">ToggleButton</code> is <code class="literal">down</code>, then the <em>gesture mode</em> is activated; otherwise, the normal <a id="id443" class="indexterm"/>functionality of the <em>tool box</em> operates.</p><p>In the next lesson, we will learn how to enhance the functionality of our widgets using behaviors.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Behaviors – enhancing widget's functionality</h1></div></div></div><p>
<strong><code class="literal">Behaviors</code></strong> were<a id="id444" class="indexterm"/> introduced recently in the Kivy version 1.8.0, and allow us to increase the functionality and flexibility of the existing widgets. Basically, they let us inject classic behaviors of certain widgets into other behaviors. For example, we can<a id="id445" class="indexterm"/> use <strong><code class="literal">ButtonBehavior</code></strong> in order to add the <code class="literal">on_press</code> and <code class="literal">on_release</code> functionality to a <code class="literal">Label</code> or <code class="literal">Image</code> widget. Currently, there are<a id="id446" class="indexterm"/> three<a id="id447" class="indexterm"/> types<a id="id448" class="indexterm"/> of behavior (<strong><code class="literal">ButtonBehavior</code></strong>, <strong><code class="literal">ToggleButtonBehavior</code></strong>, and <strong><code class="literal">DragBehavior</code></strong>) and more will be coming in the next Kivy releases.</p><p>Let's add some credits to our application. We want to add some functionality to the <em>Status Bar</em> so that when we click, a <strong><code class="literal">Popup</code></strong> will appear and show some text. First, we will import the necessary <a id="id449" class="indexterm"/>components into the <code class="literal">statusbar.py</code> header, and also change the class definition of <code class="literal">StatusBar</code>:</p><div><pre class="programlisting">312. # File name: statusbar.py
313. import kivy
314. from kivy.uix.boxlayout import BoxLayout
315. from kivy.properties import NumericProperty, ObjectProperty
316. from kivy.uix.behaviors import ButtonBehavior
317. from kivy.uix.popup import Popup
318. from kivy.uix.label import Label
319. 
320. class StatusBar(ButtonBehavior, BoxLayout):</pre></div><p>In the<a id="id450" class="indexterm"/> previous<a id="id451" class="indexterm"/> code, we have added the <strong><code class="literal">ButtonBehavior</code></strong>, <strong><code class="literal">Popup</code></strong>, and <strong><code class="literal">Label</code></strong> class (lines 316 and 318). Moreover, we made <code class="literal">StatusBar</code><a id="id452" class="indexterm"/> inherit from both <code class="literal">ButtonBehavior</code> and <code class="literal">BoxLayout</code> at the same time with Python's multiple inheritance. We can add behaviors to any type of widget, and remember from <a class="link" href="ch01.html" title="Chapter 1. GUI Basics – Building an Interface">Chapter 1</a>, <em>GUI Basics – Building an Interface</em>, that layouts are also widgets. We take advantage of the <strong><code class="literal">ButtonBehavior</code></strong> that <strong><code class="literal">StatusBar</code></strong> is inheriting <a id="id453" class="indexterm"/>from, in order to use the <strong><code class="literal">on_press</code></strong> method:</p><div><pre class="programlisting">321.     def on_press(self):
322.         the_content = Label(text = "Kivy: Interactive Apps and Games in Python\nRoberto Ulloa, Packt Publishing")
323.         the_content.color = (1,1,1,1)
324.         popup = Popup(title='The Comic Creator', content = the_content, size_hint=(None, None), size=(350, 150))
325.         popup.open()</pre></div><p>We<a id="id454" class="indexterm"/> override the <strong><code class="literal">on_press</code></strong> method to display a <strong><code class="literal">Popup</code></strong> window on the screen with the credits of the application.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>Notice that behaviors don't change the appearance of the widget; only the functionality that is most often related to processing interactions based upon the users input.</p></div></div><p>In lines 322 and 323, we create a <code class="literal">Label</code> instance with the text we want to show, and make sure that the color is white. In line 324, we create the <code class="literal">Popup</code> instance with a title, and the <code class="literal">Label</code> instance as content. Finally, in line 325, we display the <code class="literal">Popup</code> instance. Here is the result we get after clicking the <em>Status Bar</em>:</p><div><img src="img/B04244_04_08.jpg" alt="Behaviors – enhancing widget's functionality"/></div><p>In theory, we <a id="id455" class="indexterm"/>can add behaviors to any widget. However, there are practical limitations that could lead to unexpected results. For example, what happens when we add <code class="literal">ButtonBehavior</code> to <code class="literal">ToggleButton</code>? <code class="literal">ToggleButton</code> inherits from <code class="literal">Button</code> and <code class="literal">Button</code> from <code class="literal">ButtonBehavior</code>. As a consequence, we inherit the same method twice. Multiple inheritance is indeed tricky sometimes. This example was obvious (why would we think about making a class that inherits from <code class="literal">ButtonBehavior</code> and <code class="literal">ToggleButton</code>?). However, there are many other complex widgets that already include functionality for the touch events.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>You should be careful when adding behaviors to widgets that overlap the functionality related to the behaviors. The current behaviors, <code class="literal">ButtonBehavior</code>, <code class="literal">ToggleButtonBehavior</code>, <code class="literal">DragBehavior</code>, <code class="literal">CompoundSelectionBehavior</code>, and <code class="literal">FocusBehavior</code> are related to touch events.</p></div></div><p>A special example of this is the <code class="literal">Video</code> widget, which we will explore in <a class="link" href="ch06.html" title="Chapter 6. Kivy Player – a TED Video Streamer">Chapter 6</a>, <em>Kivy Player – a TED Video Streamer</em>. This widget has a property called <code class="literal">state</code>, the same name as the state property of <code class="literal">ToggleButton</code>. This will cause a name conflict if we want to use multiple inheritances from both classes.</p><p>You may have noticed that we set the <strong><code class="literal">Label</code></strong> color of the label explicitly to white (line 323), which is the label's default color anyway. We did this in order to have everything ready for the next section in which we will decorate our interface.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Style – decorating the interface</h1></div></div></div><p>In this<a id="id456" class="indexterm"/> section, we will redecorate our interface to improve the look and feel of it. With very few strategic changes, we will completely renovate the way our application looks with a few steps. Let's start changing the background color from black to white. We will do this in the <code class="literal">comicreator.py</code> file, and here is its new header:</p><div><pre class="programlisting">326. # File name: comiccreator.py
327. import kivy
328. from kivy.app import App
329. from kivy.lang import Builder
330. from kivy.uix.screenmanager import ScreenManager
331. from kivy.core.window import Window
332. 
333. Window.clearcolor = (1, 1, 1, 1)
334. 
335. Builder.load_file('style.kv')</pre></div><p>We imported <a id="id457" class="indexterm"/>the <strong><code class="literal">Window</code></strong> class that manages the configurations of the application window, and controls some global parameters and events, such as the keyboard events, which will be covered in <a class="link" href="ch05.html" title="Chapter 5. Invaders Revenge – an Interactive Multi-touch Game">Chapter 5</a>, <em>Invaders Revenge – an Interactive Multitouch Game</em>. We use the <code class="literal">Window</code> class to change the background<a id="id458" class="indexterm"/> color of the application to white with the <strong><code class="literal">clearcolor</code></strong> property (line 333). Finally, we add a new file to <code class="literal">Builder</code>. The file called <code class="literal">style.kv</code> is presented here:</p><div><pre class="programlisting">336. # File name: style.kv
337. 
338. &lt;Label&gt;:
339.     bold: True
340.     color: 0,.3,.6,1
341. 
342. &lt;Button&gt;:
343.     background_normal: 'normal.png'
344.     background_down: 'down.png'
345.     color: 1,1,1,1</pre></div><p>We need colors that contrast with the white background that we just applied on the entire window. Therefore, we are making changes on two of the basic widgets of Kivy, <code class="literal">Label</code> and <code class="literal">Button</code>, and <a id="id459" class="indexterm"/>this affects all the components that inherit from them. We have set the <strong><code class="literal">bold</code></strong> property (line 339) of <code class="literal">Label</code> to <code class="literal">True</code>, and set the <code class="literal">color</code> property (line 340) to blue (gray in the printed version).</p><p>We have also changed the default background of the <code class="literal">Button</code> class and introduced how to create rounded buttons. The <strong><code class="literal">background_normal</code></strong> property (line 343) indicates the background image<a id="id460" class="indexterm"/> that <code class="literal">Button</code> uses in its normal state, whereas the <strong><code class="literal">background_down</code></strong> property (line 344) indicates the image that <code class="literal">Button</code> uses when<a id="id461" class="indexterm"/> it is pressed.</p><p>Finally, we<a id="id462" class="indexterm"/> have reset the <code class="literal">color</code> property (line 345) of <code class="literal">Button</code> to white. You may wonder why we did that if the default color of the text of the <code class="literal">Button</code> class is white. The problem is that we just changed the color of the <code class="literal">Label</code> class, and, since <code class="literal">Button</code> inherits from label, the change also affects the <code class="literal">Button</code> class.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>The order of the rules also matters. If we put the <code class="literal">&lt;Button&gt;:</code> rule first, then it won't work anymore because the <code class="literal">&lt;Label&gt;:</code> rule will overwrite the <code class="literal">&lt;Button&gt;:</code> rule.</p></div></div><p>We can see the result of our embellished interface:</p><div><img src="img/B04244_04_09.jpg" alt="Style – decorating the interface"/></div><p>There is still something not quite right with the new design. The lines of our figures are quite thin compared to the rest of the fonts, and somehow the contrast is lost with a white background. Let's learn a quick remedy to change the default properties of our lines.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Factory – replacing a vertex instruction</h1></div></div></div><p>This final section <a id="id463" class="indexterm"/>of <a id="id464" class="indexterm"/>this chapter teaches a valuable trick to change the default properties of the <a id="id465" class="indexterm"/>
<strong>vertex instructions</strong>. We want to change the width of all the lines on our interface. This includes the circles, lines, and stickmen. Of course, we could revisit all the classes that create the <code class="literal">Line</code> vertex instructions (remember that the circles are also <code class="literal">Line</code> instances, and the stickmen are composed of <code class="literal">Line</code> instances as well), and change the width property in all of them. Needless to say, that would be tedious.</p><p>Instead, we<a id="id466" class="indexterm"/> will replace the default <code class="literal">Line</code> class. Indeed, this <a id="id467" class="indexterm"/>is equivalent to what we just did in the previous section when we changed the label and button default properties. We have a problem in that we cannot create rules in the Kivy language to change the vertex instructions. But there is an equivalent way around this, using Python code in a new file called <code class="literal">style.py</code>:</p><div><pre class="programlisting">346. # File name: style.py
347. from kivy.graphics import Line
348. from kivy.factory import Factory
349. 
350. class NewLine (Line):
351.     def __init__(self, **kwargs):
352.         if not kwargs.get('width'):
353.             kwargs['width'] = 1.5
354.         Line.__init__(self, **kwargs)
355. 
356. Factory.unregister('Line')
357. Factory.register('Line', cls=NewLine)</pre></div><p>In this code, we have created our own <code class="literal">NewLine</code> class that inherits from the Kivy <code class="literal">Line</code> class (line 350). With a little Python trick, we have changed the <code class="literal">kwargs</code> parameter of the constructor method (<code class="literal">__init__</code>) in order to set a different default width (line 353). The <code class="literal">kwargs</code> parameter is a dictionary that contains all the properties that are explicitly set when a <code class="literal">Line</code> instance is created. In this case, if the <code class="literal">width</code> property is not indicated in the constructor (line 352), we set the width default to <code class="literal">1.5</code> (line 353). Then, we call the constructor of the base class with the adjusted <code class="literal">kwargs</code> (line 354).</p><p>Now, it is time to replace the default Kivy <code class="literal">Line</code> class with ours. We need to import the Kivy <strong><code class="literal">Factory</code></strong> (line 348) that we can use to register or unregister classes, and instance them in<a id="id468" class="indexterm"/> the<a id="id469" class="indexterm"/> Kivy language. First, we need to unregister the current <code class="literal">Line</code> with the <strong><code class="literal">unregister</code></strong> method (line 356). Then, we need to register<a id="id470" class="indexterm"/> our <code class="literal">NewLine</code> with the <strong><code class="literal">register</code></strong> method (line 357). In both methods, the first parameter represents the name that is used to instance the class from the Kivy language. Since we are replacing the class, we will register the <code class="literal">NewLine</code> class with the same name. In the <strong><code class="literal">register</code></strong> method (line 357), the second <a id="id471" class="indexterm"/>parameter (<code class="literal">cls</code>) indicates the class that we register.</p><div><div><h3 class="title"><a id="note39"/>Note</h3><p>We could <a id="id472" class="indexterm"/>use the <strong><code class="literal">Factory</code></strong> class to add different lines that we need to constantly use in the Kivy language. For example, we could register our new class with the name <code class="literal">ThickLine</code> and then instance it in the Kivy language.</p></div></div><p>We purposely<a id="id473" class="indexterm"/> avoided this strategy, since we actually<a id="id474" class="indexterm"/> want to replace the default <code class="literal">Line</code>, so we can affect all the <code class="literal">Line</code> instances that we create directly in the Kivy language. However, we shouldn't forget to use the <code class="literal">NewLine</code> class to create the instances that the user will create dynamically. We need to import <code class="literal">NewLine</code> from the style file and set an alias name (<code class="literal">Line</code>) so we can reference the class with the same name (line 362). We also need to remove the one we imported from <code class="literal">kivy.graphics</code> (line 362) in the <code class="literal">toolbox.py</code> file to avoid a name conflict:</p><div><pre class="programlisting">358. # File name: toolbox.py
359. import math
360. from kivy.uix.togglebutton import ToggleButton
361. from kivy.graphics import Color
362. from style import Line
363. from comicwidgets import StickMan, DraggableWidget</pre></div><p>Here is the final screenshot of our <em>Comic Creator</em>, which shows off the thicker lines:</p><div><img src="img/B04244_04_10.jpg" alt="Factory – replacing a vertex instruction"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Summary</h1></div></div></div><p>This chapter covered some specific and useful topics that improve the user experience. We added several screens and switched between them with <code class="literal">ScreenManager</code>. We learned how to use colors in the canvas, and we should now have a good understanding of how this works internally. We also learned how to limit the drawing area to the <strong><code class="literal">drawing space</code></strong> with <code class="literal">StencilView</code>. We used <code class="literal">Scatter</code> to add rotating and scaling capabilities to <code class="literal">DraggableWidget</code> and expanded the functionality through the use of properties and associated events. We also introduced the use of gestures to make the interface more dynamic. We covered how to enhance widget using behaviors. Finally, we learned how to improve the interface by modifying the default widgets and vertex instructions.</p><p>Here is a review of all the classes with their respective methods, properties, and attributes that we learned to use in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ScreenManager</code>: The <code class="literal">transistion</code> and <code class="literal">current</code> properties</li><li class="listitem" style="list-style-type: disc"><code class="literal">FadeTransition</code>, <code class="literal">SwapTransition</code>, <code class="literal">SlideTransition</code>, and <code class="literal">WipeTransition</code> transitions</li><li class="listitem" style="list-style-type: disc"><code class="literal">Screen</code>: The <code class="literal">name</code> and <code class="literal">manager</code> properties</li><li class="listitem" style="list-style-type: disc"><code class="literal">ColorPicker</code>: The <code class="literal">color</code> property</li><li class="listitem" style="list-style-type: disc"><code class="literal">StencilView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Scatter</code>: The <code class="literal">rotate</code> and <code class="literal">scale</code> properties, and the <code class="literal">on_translate</code>, <code class="literal">on_rotate</code> and <code class="literal">on_scale</code> methods (events)</li><li class="listitem" style="list-style-type: disc"><code class="literal">ScatterLayout</code>: The <code class="literal">size_hint</code> and <code class="literal">pos_hint</code> properties</li><li class="listitem" style="list-style-type: disc"><code class="literal">Gesture</code>: The <code class="literal">add_stroke</code>, <code class="literal">normalize</code>, and <code class="literal">rotate</code> methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">GestureDatabase</code>: The <code class="literal">gesture_to_str</code>, <code class="literal">str_to_gesture</code>, <code class="literal">add_gesture</code>, and <code class="literal">find</code> methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">Widget</code>: The <code class="literal">disabled</code> property</li><li class="listitem" style="list-style-type: disc"><code class="literal">ButtonBehavior</code>, <code class="literal">ToggleBehavior</code> and <code class="literal">DragBehavior</code>: The <code class="literal">on_press</code> method</li><li class="listitem" style="list-style-type: disc"><code class="literal">Popup</code>: The <code class="literal">title</code> and <code class="literal">content</code> properties</li><li class="listitem" style="list-style-type: disc"><code class="literal">Window</code>: The <code class="literal">clearcolor</code> attribute</li><li class="listitem" style="list-style-type: disc"><code class="literal">Factory</code>: The <code class="literal">register</code> and <code class="literal">unregister</code> methods</li></ul></div><p>These are all useful components that help us create more attractive and dynamic applications. In this chapter, we gave an example on how to demonstrate the possibilities of the classes. Although we didn't exhaustively explore all the options, we should feel comfortable to use any of these components to enhance applications. We can always check the Kivy API for a more comprehensive list of properties and methods.</p><p>The next chapter will introduce personalized multi-touch control, animations, as well as the clock and keyboard events. We will create a new interactive project, a game that resembles the Arcade game <em>Space Invaders</em>.</p></div></div>
</body></html>