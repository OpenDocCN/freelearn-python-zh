["```py\ndef func_foo():\n    pass\n```", "```py\n >>> def first_func(val):\n ...     print(val)\n ...\n >>> new_name = first_func\n >>> first_func(\"Spam!\")\n Spam!\n >>> new_name(\"Spam too!\")\n Spam too!\n```", "```py\n >>> def mult(x, y):\n ...     return x * y\n ... \n >>> def div(x, y):\n ...     return x / y\n ... \n >>> def math(func, x, y):\n ...     result = func(x, y)\n ...     return result\n ... \n >>> math(mult, 4, 2)\n 8\n >>> math(div, 4, 2)\n 2.0\n```", "```py\n >>> def person(name):\n ...     def greeting():\n ...         return \"Would you like some spam, \"\n ...     greet = greeting() + name + \"?\"\n ...     return greet\n ... \n >>> print(person(\"Sir Galahad\"))\n Would you like some spam, Sir Galahad?\n```", "```py\n >>> def greeting(name):\n ...     return \"'allo \" + name\n ...\n >>> def call_me(func):\n ...     nickname = \"mate\"\n ...     return func(nickname)\n ... \n >>> print(call_me(greeting))\n 'allo mate\n```", "```py\n >>> def func_creator():\n ...     def return_saying():\n ...         return \"Blessed are the cheese makers\"\n ...     return return_saying\n ... \n >>> statement = func_creator()\n >>> print(statement())\n Blessed are the cheese makers\n```", "```py\n >>> def func_creator2(name):\n ...     def greeting():\n ...         return \"Welcome, \" + name\n ...     return greeting\n ... \n >>> greet = func_creator2(\"Brian\")\n >>> print(greet())\n Welcome, Brian\n```", "```py\n        def fun_decorator(some_funct):\n            def wrapper():\n                print(\"Here is the decorator, doing its thing\")\n                for i in range(10):\n                    print(i)\n                print(\"The decorator is done, returning to the \n                       originally scheduled function\")\n                print(some_funct())\n            return wrapper\n```", "```py\n        def a_funct():\n            text = \"I am the original function call\"\n            return text\n```", "```py\n        a_funct = fun_decorator(a_funct)\n```", "```py\n        a_funct()\n```", "```py\n        def fun_decorator(some_funct):\n            def wrapper():\n                print(\"Here is the decorator, doing its thing\")\n                for i in range(10):\n                    print(i)\n                print(\"The decorator is done, returning to the \n                       originally scheduled function\")\n                print(some_funct())\n            return wrapper\n\n        def a_funct():\n            text = \"I am the original function call\"\n            return text\n\n        a_funct = fun_decorator(a_funct)\n        a_funct()\n```", "```py\n        def fun_decorator(some_funct):\n            def wrapper():\n                print(\"Here is the decorator, doing its thing\")\n                for i in range(10):\n                    print(i)\n                print(\"The decorator is done, returning to the \n                       originally scheduled function\")\n                print(some_funct())\n            return wrapper\n\n        @fun_decorator\n        def a_funct():\n            text = \"I am a decorated function call\"\n            return text\n\n        a_funct()\n```", "```py\n@foo_decorator\ndef my_function():\n    pass\n```", "```py\n        def arg_check(func):\n            def wrapper(num):\n                if type(num) != int:\n                    raise TypeError(\"Argument is not an integer\")\n                elif num <= 0:\n                    raise ValueError(\"Argument is not positive\")\n                else:\n                    return func(num)\n            return wrapper\n```", "```py\n        @arg_check\n        def circle_measures(radius):\n            circumference = 2 * pi * radius\n            area = pi * radius * radius\n            diameter = 2 * radius\n            return (diameter, circumference, area)\n```", "```py\n       from math import pi \n\n       def arg_check(func):\n           def wrapper(num):\n               if type(num) != int:\n                   raise TypeError(\"Argument is not an integer\")\n               elif num <= 0:\n                   raise ValueError(\"Argument is not positive\")\n               else:\n                   return func(num)\n           return wrapper\n\n        @arg_check\n        def circle_measures(radius):\n            circumference = 2 * pi * radius\n            area = pi * radius * radius\n            diameter = 2 * radius\n            return (diameter, circumference, area)\n\n        diameter, circumference, area = circle_measures(6)\n        print(\"The diameter is\", diameter, \"\\nThe circumference is\", \n              circumference, \"\\nThe area is\", area)\n```", "```py\nr = input(\"Input radius: \")\ndiameter, circumference, area = circle_measures(r)\n```", "```py\n        class Cat():\n            def __init__(self, breed, age):\n                \"\"\"Initialization method to auto-populate an instance\"\"\"\n\n                self.breed = breed\n                self.age = age\n\n            def cat_age(self):\n                \"\"\"Get the cat's age\"\"\"\n\n                return self.age\n\n            def breed(self):\n                \"\"\"Get the type of cat, e.g. short hair, long hair, etc.\"\"\"\n\n                return self.breed\n\n            def __repr__(self):\n                \"\"\"Return string representation of Cat object.\n\n                Without this method, only the object's \n                memory address will be printed.\n                \"\"\"\n                return \"{breed}, {age}\".format(breed = self.breed, age = self.age)\n```", "```py\n         chip = Cat(\"domestic shorthair\", 4)\n```", "```py\n        @staticmethod # This is required\n            def cry():\n                \"\"\"Static method, available to all instances and the class\n\n                Notice that 'self' is not a required argument\n                \"\"\"\n\n                return \"Nyao nyao\" # It's a Japanese cat\n```", "```py\n        @classmethod # This is required\n            def type(cls):\n                \"\"\"\n                Class method, available only to classes.\n\n                Notice that 'cls' is the argument, as opposed to 'self'\n                \"\"\"\n\n                if cls.__name__ == \"Cat\":\n                    return \"Some sort of domestic cat.\"\n                else:\n                    return cls.__name__\n```", "```py\n        from functools import wraps\n```", "```py\n        from flask import g, request, redirect, url_for\n```", "```py\n        def login_required(f):\n            @wraps(f)\n            def decorated_function(*args, **kwargs):\n                if g.user is None:\n                    return redirect(url_for('login', next=request.url))\n                return f(*args, **kwargs)\n            return decorated_function\n```", "```py\n        @app.route('/inventory')\n        @login_required\n        def inventory():\n            pass\n```", "```py\n        import time\n\n        def time_decorator(funct):\n            def wrapper(*arg)\n                result = funct(*arg)\n                print(time.perf_counter())\n                return result\n            return wrapper\n```", "```py\n        # Silly little number cruncher\n        import math\n\n        @time_decorator\n        def factorial_counter(x, y):\n            fact = math.factorial(x)\n            time.sleep(2)  # Force a delay to show the time decorator works\n            fact2 = math.factorial(y)\n            print(math.gcd(fact, fact2))\n\n        factorial_counter(10000, 10)\n```", "```py\n        def attrs(**kwds):\n            def decorate(f):\n                for k in kwds:\n                    setattr(f, k, kwds[k])\n                return f\n            return decorate\n\n        @attrs(versionadded=\"2.2\",\n               author=\"Guido van Rossum\")\n        def mymethod(f):\n            ...\n```", "```py\n        def accepts(*types):\n            def check_accepts(f):\n                assert len(types) == f.func_code.co_argcount\n                def new_f(*args, **kwds):\n                    for (a, t) in zip(args, types):\n                        assert isinstance(a, t), \\\n                           \"arg %r does not match %s\" % (a,t)\n                    return f(*args, **kwds)\n            new_f.func_name = f.func_name\n            return new_f\n        return check_accepts\n\n        def returns(rtype):\n            def check_returns(f):\n                def new_f(*args, **kwds):\n                    result = f(*args, **kwds)\n                    assert isinstance(result, rtype), \\\n                    \"return value %r does not match %s\" %\n                    (result,rtype)\n                return result\n                new_f.func_name = f.func_name\n            return new_f\n        return check_returns\n\n        @accepts(int, (int,float))\n        @returns((int,float))\n        def func(arg1, arg2):\n           return arg1 * arg2\n```", "```py\n        @parameters(\n            (2, 4, 6), \n            (5, 6, 11)\n        )\n        def test_add(a, b, expected):\n            assert a + b == expected\n```", "```py\n@app.route(\"/\") # Root (default) page to display when landing on web site\n@app.route(\"/page/<int:page>\") # Specific site page\n@login_required # Force authentication\ndef entries(page=1):\n    \"\"\"\n    Query the database entries of the blog.\n\n    :param page: The page number of the site.\n    :return: Template page with the number of entries specified, \n    Next/Previous links, page number, and total number of\n    pages in the site\n    \"\"\"\n    # Zero-indexed page\n    default_entries = 10\n    max_entries = 50\n\n    # Set the number of entries displayed per page\n    try:\n        entry_limit = int(request.args.get('limit', default_entries)) \n        # Get the limit from HTML argument 'limit'\n        assert entry_limit > 0 # Ensure positive number\n        assert entry_limit <= max_entries \n        # Ensure entries don't exceed max value\n    except (ValueError, AssertionError): \n        # Use default value if number of entries doesn't meet expectations\n        entry_limit = default_entries\n\n    page_index = page - 1\n\n    count = session.query(Entry).count()\n\n    start = page_index * PAGINATE_BY # Index of first entry on page\n    end = start + PAGINATE_BY # Index of last entry on page\n    total_pages = (count - 1) // PAGINATE_BY + 1 # Total number of pages\n    has_next = page_index < total_pages - 1 # Does following page exit?\n    has_prev = page_index > 0 # Does previous page exist?\n\n    entries = session.query(Entry)\n    entries = entries.order_by(Entry.datetime.desc())\n    entries = entries[start:end]\n\n    return render_template(\"entries.html\",\n                           entries=entries,\n                           has_next=has_next,\n                           has_prev=has_prev,\n                           page=page,\n                           total_pages=total_pages\n                           )\n```", "```py\n@app.route(\"/entry/add\", methods=[\"GET\"])\n@login_required # Force authentication\ndef add_entry_get():\n    \"\"\"Display the web form for a new blog entry\"\"\"\n    return render_template(\"add_entry.html\")\n\n@app.route(\"/entry/add\", methods=[\"POST\"])\n@login_required # Force authentication\ndef add_entry_post():\n    \"\"\"Take an entry form and put the data in the DB\"\"\"\n    entry = Entry(\n        title=request.form[\"title\"],\n        content=request.form[\"content\"],\n        author=current_user\n    )\n    session.add(entry)\n    session.commit()\n    return redirect(url_for(\"entries\"))\n\n@app.route(\"/login\", methods=[\"GET\"])\ndef login_get():\n    \"\"\"Display the login page\"\"\"\n    return render_template(\"login.html\")\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login_post():\n    \"\"\"Check if user is in database\"\"\"\n    email = request.form[\"email\"]\n    password = request.form[\"password\"]\n    user = session.query(User).filter_by(email=email).first()\n    if not user or not check_password_hash(user.password, password):\n        flash(\"Incorrect username or password\", \"danger\")\n        return redirect(url_for(\"login_get\"))\n\n    login_user(user)\n    return redirect(request.args.get('next') or url_for(\"entries\"))\n```", "```py\n        import functools\n        import time\n\n        def memoize_uw(func):\n            func.cache = {}\n\n            def memoize(*args, **kw):\n                if kw:  # frozenset is used to ensure hashability\n                    key = args, frozenset(kw.items())\n                else:\n                    key = args\n                if key not in func.cache:\n                    func.cache[key] = func(*args, **kw)\n                return func.cache[key]\n            return functools.update_wrapper(memoize, func)\n```", "```py\n        @memoize_uw\n        def f1(x):\n            \"Simulate some long computation\"\n            time.sleep(1)\n            return x\n```", "```py\n        import functools\n        import time\n        from decorator import *\n\n        def _memoize(func, *args, **kw):\n            if kw:  # frozenset is used to ensure hashability\n                key = args, frozenset(kw.items())\n            else:\n                key = args\n           cache = func.cache  # attribute added by memoize\n        if key not in cache:\n            cache[key] = func(*args, **kw)\n        return cache[key]\n\n```", "```py\n        def memoize(f): \n            \"\"\" A simple memoize implementation. \n            It works by adding a .cache dictionary to the  decorated \n            function. The cache will grow indefinitely, so it is your \n            responsibility to clear it, if needed. \n            \"\"\" \n            f.cache = {} \n            return decorate(f, _memoize)\n```", "```py\n        import time\n\n        @memoize\n        def data_simulator():\n            time.sleep(2)\n            return \"done\"\n```"]