<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Buttons</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will describe the main control elements of a GUI application—<strong>buttons</strong>. Buttons are the most commonly used graphical components of any GUI application. The different types of buttons provide the user with the option to operate an application according to its defined functionality. The user can click on a button to start a process and choose the option available, or open the file dialog window. All of these actions require an element that will realize these operations. The Qt framework, and the corresponding Python bindings (PySide2 and PyQt5), have extensive classes for creating buttons for a variety of tasks. These elements are very customizable and allow software developers to realize these components in a modern style.</p>
<p class="mce-root">The elements that will be covered in this chapter are as follows:</p>
<ul>
<li>Buttons</li>
<li>Checkbox</li>
<li>Additional components</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QAbstractButton</h1>
                </header>
            
            <article>
                
<p>This is an abstract base class that's used with button widgets and provides functionality related to buttons in the Qt framework. The buttons described in this chapter will inherit this class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QAbstractButton functions</h1>
                </header>
            
            <article>
                
<p><kbd>QAbstractButton</kbd> inherits the <kbd>QWidget</kbd> and improves functionality by means of the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> related to the setting of the parameters/properties in relation to the button, including the setting of text, alignment, or functionality</span>:</p>
<p><kbd>setAutoExclusive(bool)</kbd>: If the parameter is <kbd>True</kbd>, this<span> enables the autoexclusivity of the button</span>. This means that this button is a part of the exclusive button group with the same parent group. In the exclusive button group, only a single button can be checked at one time and, if a button was checked previously, it automatically gets unchecked.</p>
<p><kbd>setAutoRepeat(bool)</kbd><span>: If the parameter is</span> <kbd>True</kbd><span>, this </span><span>enables autorepetition for the button when pushed</span><span>. This is related to buttons that move the sliders, and so on.</span></p>
<p><kbd>setAutoRepeatDelay(int)</kbd><span>: This sets the delay for the autorepetition of the button, or when the repetition will begin after the number of milliseconds specified in the parameter.</span></p>
<p><kbd>setAutoRepeatInterval(int)</kbd><span>: This sets the interval that will be used for the autorepetition of this button, or the interval in milliseconds, as specified in the parameter, at which repetition will occur.</span></p>
<p><kbd>setChecked(bool)</kbd><span>: If the parameter is</span> <kbd>True</kbd><span>, this sets the button in the checked state.</span> This button needs to be capable of being checked.</p>
<p><kbd>setDown(bool)</kbd><span>: If the parameter is</span> <kbd>True</kbd><span>, this sets the button to a </span>pushed down <span>state.</span></p>
<p><kbd>setIcon(QtGui.QIcon)</kbd><span>: This specifies the icon for the button that will be used.</span></p>
<p><kbd>setIconSize(QtCore.QSize)</kbd><span>: This sets the size of the icon for the button.</span></p>
<p><kbd>setShortcut(QtGui.QKeySequence)</kbd><span>: This sets the mnemonic that will be associated with this button, or the keys that will be used together to perform an action as keyboard shortcuts.</span></p>
<p><kbd>setText("Okay")</kbd><span>: This sets the text for the button.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">is</h1>
                </header>
            
            <article>
                
<p><span>These are functions </span><span>that return a Boolean value (<kbd>bool</kbd>) related to the button states</span>:</p>
<p><kbd>isCheckable()</kbd>: This returns <kbd>True</kbd> if the button is checkable.</p>
<p><kbd>isChecked()</kbd><span>: This returns</span> <kbd>True</kbd> <span>if the button was checked and is checkable.</span></p>
<p><kbd>isDown()</kbd><span>: This returns</span> <kbd>True</kbd> <span>if the button is in a pushed down state.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are related to </span>the current values of the button, changes in functionality, and so on:</p>
<p><kbd>animateClick(int)</kbd>: This performs the animated click for the button.</p>
<p><kbd>autoExclusive()</kbd><span>: This returns</span> <kbd>True</kbd> <span>if auto-exclusivity is enabled for this button.</span></p>
<p><kbd>autoRepeat()</kbd><span>: This returns</span> <kbd>True</kbd> <span>if auto-repetition is enabled for this button.</span></p>
<p><kbd>autoRepeatDelay()</kbd><span>:</span> This <span>returns a delay in regard to the auto-repetition function of this button.</span></p>
<p><kbd>autoRepeatInterval()</kbd><span>: This returns</span> an interval <span>in regard to the auto-repetition function of this button.</span></p>
<p><kbd>click()</kbd><span>: This performs the clicking of the button. All the signals associated with a click on this button are emitted.</span></p>
<p><kbd>group()</kbd><span>: This returns the group that the button belongs to.</span></p>
<p><kbd>hitButton(QtCore.QPoint)</kbd><span>: This returns</span> <kbd>True</kbd> <span>if the position specified in the parameter is inside the button rectangle; otherwise, it returns</span> <kbd>False</kbd>.</p>
<p><kbd>icon()</kbd><span>: This returns the icon that this button contains, and is of the</span> <kbd>QtGui.QIcon</kbd> <span>type.</span></p>
<p><kbd>iconSize()</kbd><span>: This returns the size of the icon that this button contains, and is of the</span> <kbd>QtCore.QSize</kbd> <span>type.</span></p>
<p><kbd>shortcut()</kbd><span>: This returns the keyboard shortcut that is used with this button.</span></p>
<p><kbd>text()</kbd><span>: This returns the text that's displayed on this button.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are </span><span>related to the events, such as event handlers</span>:</p>
<p><kbd>changeEvent(QtCore.QEvent)</kbd>: This handles state changes associated with the button.</p>
<p><kbd>checkStateSet()</kbd><span>: This is the virtual handler that's called when</span> <kbd>QAbstractButton.setChecked()</kbd> <span>is used.</span></p>
<p><kbd>event(QtCore.QEvent)</kbd><span>: This is the</span> <kbd>QtCore.QObject</kbd> <span>function that receives events to the object, and should return</span> <kbd>True</kbd> <span>if the event is recognized and processed.</span></p>
<p><kbd>focusOutEvent(QtGui.QFocusEvent)</kbd><span>: T</span><span>his is an event handler that's designed to </span><span>receive the keyboard focus events for the buttons that are passed with </span>focus event <span>parameters when the focus is lost.</span></p>
<p><kbd>focusInEvent(QtGui.QFocusEvent)</kbd><span>: T</span><span>his is an event handler that's designed to </span><span>receive the keyboard focus events for the buttons that are passed with focus event parameters when the focus is received.</span></p>
<p><kbd>keyPressEvent(QtGui.QKeyEvent)</kbd><span>: T</span><span>his is an event handler that's designed to </span><span>receive key press events for the button, along </span>with the key event passed in the parameter.</p>
<p><kbd>keyReleaseEvent(QtGui.QKeyEvent)</kbd><span>: T</span><span>his is an event handler that's designed to </span><span>receive key release events for the button, along with the key event passed in the parameter.</span></p>
<p><kbd>mousePressEvent(QtGui.QMouseEvent)</kbd><span>: T</span><span>his is an event handler that's designed to </span><span>receive mouse press events for this button, along with mouse events passed in the parameter.</span></p>
<p><kbd>mouseReleaseEvent(QtGui.QMouseEvent)</kbd><span>: T</span><span>his is an event handler that's designed to </span><span>receive mouse release events for the button, along with mouse events passed in the parameter.</span></p>
<p><kbd>nextCheckState()</kbd><span>: This is the virtual handler that's called when the button is clicked.</span></p>
<p><kbd>paintEvent(QtGui.QPaintEvent)</kbd><span>: T</span><span>his is an event handler that's designed to </span><span>receive paint events for this button, along with paint events passed in the parameter.</span></p>
<p><kbd>timerEvent(QtCore.QTimerEvent)</kbd><span>: T</span><span>his is an event handler that's designed to </span><span>receive timer events for the button, along with timer events passed in the parameter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">signals</h1>
                </header>
            
            <article>
                
<p>The available signals for the <kbd>QAbstractButton</kbd> class are as follows:</p>
<p><kbd>clicked(bool)</kbd>: This signal is emitted once the button is activated, when the shortcut key is typed, or when we call the <kbd>click()</kbd> or <kbd>animateClick()</kbd> function. The parameter is <kbd>True</kbd> when checked and <kbd>False</kbd> if unchecked, if the button is checkable.</p>
<p><kbd>pressed()</kbd><span>: This signal is emitted when the button is</span> pushed down.</p>
<p><kbd>released()</kbd><span>: This signal is emitted when the button is released.</span></p>
<p><kbd>toggled(bool)</kbd><span>: This signal is emitted when the button changes state. The parameter is</span> <kbd>True</kbd> <span>when checked, and</span> <kbd>False</kbd> <span>if unchecked,</span> <span>if this button is checkable.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QPushButton</h1>
                </header>
            
            <article>
                
<p>The most commonly used graphical component in the application is the push button. The user can click on the button to perform an action or achieve an effect as a result of using their favorite app. The Qt framework provides the <kbd>QPushButton</kbd> class for implementing the standard push button in the application and can be used with the PySide and PyQt Python bindings. A wide variety of customization options give this element a modern style that can be used anywhere in a variety of forms. The declaration syntax of the push button in the application is as follows:</p>
<pre><strong>push_button</strong> = QtWidgets.QPushButton()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QPushButton functions</h1>
                </header>
            
            <article>
                
<p><kbd>QPushButton</kbd> inherits from the <kbd>QAbstractButton</kbd> class and improves functionality with the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> related to the setting of the parameters/properties in relation to the push button</span>:</p>
<p><kbd>push_button.setAutoDefault(bool)</kbd>: If the parameter is <kbd>True</kbd>, this establishes this push button as the auto default button.</p>
<p><kbd>push_button.setDefault(bool)</kbd><span>: If the parameter is</span> <kbd>True</kbd><span>,</span> <span>this establishes </span><span>this push button as the default button.</span></p>
<p><kbd>push_button.setFlat(bool)</kbd><span>: If the parameter is</span> <kbd>True</kbd><span>,</span> <span>this establishes </span><span>this push button as flat.</span></p>
<p><kbd>push_button.setMenu(QtWidgets.QMenu)</kbd><span>: This sets the popup menu specified in the parameter in relation to the push button.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">is</h1>
                </header>
            
            <article>
                
<p><span>These are functions </span><span>that return a Boolean value (<kbd>bool</kbd>) related to the</span> current states of the <span>push button</span>:</p>
<p><kbd>push_button.isDefault()</kbd>: This returns <kbd>True</kbd> if this push button is the default button.</p>
<p><kbd>push_button.isFlat()</kbd><span>: This returns</span> <kbd>True</kbd> <span>if this push button is flat.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are related to the </span>returns<span> of the current values of the push button</span><span>, changes in functionality, and so on</span>:</p>
<p><kbd>push_button.autoDefault()</kbd>: This returns <kbd>True</kbd> if the push button is the auto default button.</p>
<p><kbd>push_button.menu()</kbd><span>: This returns the popup menu of the</span> <kbd>QtWidgets.QMenu</kbd> <span>type</span> <span>associated with this push button.</span></p>
<p><kbd>push_button.showMenu()</kbd>: This shows the popup menu associated with this push button.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are </span><span>related to the events, such as event handlers</span>:</p>
<p><kbd>push_button.changeEvent(QtCore.QEvent)</kbd>: This handles state changes within the push button.</p>
<p><kbd>push_button.enterEvent(QtCore.QEvent)</kbd>: T<span>his is an event handler that's designed to </span>receive the enter events of the push button that is passed with an event parameter, and is sent when the mouse cursor enters the push button.</p>
<p><kbd>push_button.event(QtCore.QEvent)</kbd>: This receives events to the object and should return <kbd>True</kbd> if the event is recognized and processed.</p>
<p><kbd>push_button.focusOutEvent(QtGui.QFocusEvent)</kbd>: T<span>his is an event handler that's designed to </span>receive the keyboard focus events for this <span>push button</span> <span>and are passed with event parameters when the focus is lost.</span></p>
<p><kbd>push_button.focusInEvent(QtGui.QFocusEvent)</kbd>: T<span>his is an event handler that's designed to </span>receive the keyboard focus events for this <span>push button</span> and are passed with event parameters when the focus is received.</p>
<p><kbd>push_button.keyPressEvent(QtGui.QKeyEvent)</kbd>: T<span>his is an event handler that's designed </span>to receive key press events for this <span>push button,</span> with events passed in the parameter.</p>
<p><kbd>push_button.keyReleaseEvent(QtGui.QKeyEvent)</kbd>: T<span>his is an event handler that's designed </span>to receive key release events for this <span>push button,</span> with events passed in the parameter.</p>
<p><kbd>push_button.leaveEvent(QEvent)</kbd>: T<span>hi</span><span>s is an event handler that's designed </span>to receive leave events for this push button, with events passed in the parameter.</p>
<p><kbd>push_button.mousePressEvent(QtGui.QMouseEvent)</kbd>: T<span>his is an event handler that's designed</span> to receive mouse press events for this <span>push button,</span> with events passed in the parameter.</p>
<p><kbd>push_button.mouseReleaseEvent(QtGui.QMouseEvent)</kbd>: T<span>his is an event handler that's designed </span>to receive mouse release events for this <span>push button,</span> with events passed in the parameter.</p>
<p><kbd>push_button.paintEvent(QtGui.QPaintEvent)</kbd>: T<span>his is an event handler that's designed </span>to receive paint events for this <span>push button,</span> with events passed in the parameter.</p>
<p><kbd>push_button.timerEvent(QtCore.QTimerEvent)</kbd>: T<span>his is an event handler that's designed </span>to receive timer events for this <span>push button,</span> with events passed in the parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QToolButton</h1>
                </header>
            
            <article>
                
<p>The <kbd>QToolButton</kbd> class constructs the quick-access tool button in the application, which is used for the commands or options that are usually defined with the toolbar. The declaration syntax for this kind of button is as follows:</p>
<pre><strong>tool_button</strong> = QtWidgets.QToolButton()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QToolButton functions</h1>
                </header>
            
            <article>
                
<p><kbd>QToolButton</kbd> inherits from the <kbd>QAbstractButton</kbd> class and improves functionality by means of the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are </span><span>related to setting the parameters/properties in relation to the</span> tool button:</p>
<p><kbd>tool_button.setArrowType(QtCore.Qt.ArrowType)</kbd>: This sets the arrow type for this tool button, with the arrow displayed instead of the normal icon.</p>
<p><kbd>tool_button.setAutoRaise(bool)</kbd><span>: If the parameter is</span> <kbd>True</kbd><span>, this sets auto-raising to be enabled for this tool button.</span></p>
<p><kbd>tool_button.setDefaultAction(QtWidgets.QAction)</kbd><span>: This sets the default action specified in the parameter for this tool button.</span></p>
<p><kbd>tool_button.setMenu(QtWidgets.QMenu)</kbd><span>: This associates the menu specified in the parameter in relation to this tool button. The menu will be displayed according to the popup mode.</span></p>
<p><kbd>tool_button.setPopupMode(QtWidgets.QToolButton.ToolButtonPopupMode)</kbd><span>: This sets the popup mode for this tool button. The popup modes that are </span><span>available </span><span>are as follows:</span></p>
<ul>
<li><kbd>QtWidgets.QToolButton.DelayedPopup</kbd>—<kbd>0</kbd>: The menu will be displayed with some delay</li>
<li><kbd>QtWidgets.QToolButton.MenuButtonPopup</kbd>—<kbd>1</kbd>: The menu will be displayed with a special arrow</li>
<li><kbd>QtWidgets.QToolButton.InstantPopup</kbd>—<kbd>2</kbd>: The menu will be displayed without delay, and an action is not triggered</li>
</ul>
<p><kbd>tool_button.setToolButtonStyle(QtCore.Qt.ToolButtonStyle)</kbd>: This sets the style specified in the parameter for this tool button.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are </span><span>related to the </span>returns<span> of the current values of the tool button, changes in functionality, and so on</span>:</p>
<p><kbd>tool_button.arrowType()</kbd>: This returns the arrow of the <kbd>QtCore.Qt.ArrowType</kbd> type that is used with this tool button.</p>
<p><kbd>tool_button.autoRaise()</kbd><span>: This returns</span> <kbd>True</kbd> <span>if the auto-raising function is enabled for this tool button.</span></p>
<p><kbd>tool_button.defaultAction()</kbd><span>: This returns the default action of the</span> <kbd>QtWidgets.QAction</kbd> <span>type that's used with this tool button.</span></p>
<p><kbd>tool_button.menu()</kbd><span>: This returns the menu associated with this tool button.</span></p>
<p><kbd>tool_button.popupMode()</kbd><span>: This returns the mode of the </span><kbd>QtWidgets.QToolButton.ToolButtonPopupMode</kbd><span> type that is used with the popup menu of this tool button.</span></p>
<p><kbd>tool_button.showMenu()</kbd><span>: This shows the popup menu</span> <span>associated with </span><span>this tool button.</span></p>
<p><kbd>tool_button.toolButtonStyle()</kbd><span>: This returns the style of the</span> <kbd>QtCore.Qt.ToolButtonStyle</kbd> <span>type that is used with this tool button.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are</span><span> related to events, such as event handlers</span>:</p>
<p><kbd>tool_button.actionEvent(QtGui.QActionEvent)</kbd>: This event handler is called when actions are changed in relation to this tool button, with events passed in the parameter.</p>
<p><kbd>tool_button.changeEvent(QtCore.QEvent)</kbd><span>: This handles state changes associated with this tool button.</span></p>
<p><kbd>tool_button.enterEvent(QtCore.QEvent)</kbd><span>:</span> <span>This is an event handler that's designed </span><span>to receive the enter events of this tool button, which are passed with event parameters, and are sent when the mouse cursor enters the tool button.</span></p>
<p><kbd>tool_button.event(QtCore.QEvent)</kbd><span>: This receives events to the object and should return</span> <kbd>True</kbd> <span>if the event is recognized and processed.</span></p>
<p><kbd>tool_button.leaveEvent(QEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive</span><span> </span><span>leave events for this tool button, with events passed in the parameter.</span></p>
<p><kbd>tool_button.mousePressEvent(QtGui.QMouseEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive </span><span>mouse press events for this tool button, with mouse events passed in the parameter.</span></p>
<p><kbd>tool_button.mouseReleaseEvent(QtGui.QMouseEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive </span><span>mouse release events for this tool button, with mouse events passed in the parameter.</span></p>
<p><kbd>tool_button.nextCheckState()</kbd><span>: The virtual handler is called in the event that the tool button is clicked.</span></p>
<p><kbd>tool_button.paintEvent(QtGui.QPaintEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive </span><span>paint events for this tool button, with paint events passed in the parameter.</span></p>
<p><kbd>tool_button.timerEvent(QtCore.QTimerEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive </span><span>timer events for this tool button, with timer events passed in the parameter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">signals</h1>
                </header>
            
            <article>
                
<p>The available signal for the <kbd>QToolButton</kbd> class is as follows:</p>
<p><kbd>tool_button.triggered(QtWidgets.QAction)</kbd>: This signal is emitted when the action that's passed to the parameter is triggered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QRadioButton</h1>
                </header>
            
            <article>
                
<p>Another kind of button can be implemented within the application, and is known as a radio button. This component is an option button, as the user can make a choice between different options. Only one radio button of the group that contains the radio buttons can be checked at one time. If the radio button is selected by the user, other radio buttons within this group will be deselected. The <kbd>QRadioButton</kbd> class inherits from the <kbd>QAbstractButton</kbd> class and provides functions, signals, and events that are represented there. The radio button can also display text and icons. The declaration syntax for the radio button in the application is as follows:</p>
<pre><strong>radio_button</strong> = QtWidgets.QRadioButton("Choice #1")</pre>
<p>The icon for this button can be used like so:</p>
<pre><strong>radio_button</strong>.setIcon(QtGui.QIcon("Path/To/The/icon.png"))</pre>
<p>In the case of text, we have the following:</p>
<pre><strong>radio_button</strong>.setText("Choice #1")</pre>
<p>The radio button can be styled in the same way as every widget that uses the <kbd>setStyleSheet()</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QButtonGroup</h1>
                </header>
            
            <article>
                
<p>This class implements the container for groups of buttons. Containers with buttons are useful for creating a set of radio buttons with several options or check boxes to convey the complexity of the information. This class provides an abstract container and does not provide a visual representation. The button group manages the states of each button in the group. The declaration syntax for the button group in the application is as follows:</p>
<pre><strong>button_group</strong> = QtWidgets.QButtonGroup()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QButtonGroup functions</h1>
                </header>
            
            <article>
                
<p><kbd>QButtonGroup</kbd> inherits from the <kbd>QObject</kbd> class and improves functionality by means of the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">add</h1>
                </header>
            
            <article>
                
<p>The following function is related to the addition of elements to the button group:</p>
<p><kbd>button_group.addButton(QtWidgets.QAbstractButton, int)</kbd>: This adds the button specified in the first parameter to this button group with the ID specified in the second parameter. If the ID is <kbd>1</kbd> (the default), the ID will be assigned to the button that's <span>added</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are related to setting the parameters/properties in relation to the button group</span>:</p>
<p><kbd>button_group.setExclusive(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets this button group as exclusive. In this case, only one button in this group can be checked at any one time.</p>
<p><kbd>button_group.setId(QtWidgets.QAbstractButton, int)</kbd><span>: This sets the ID specified in the second parameter to the button specified in the first parameter of this button group.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p><span>These are functions that are related to the returns of the current values of the button group</span><span>, changes in functionality, and so on</span>:</p>
<p><kbd>button_group.button(int)</kbd>: This returns the button with the ID specified in the parameter.</p>
<p><kbd>button_group.buttons()</kbd><span>: This returns the list of buttons in this button group.</span></p>
<p><kbd>button_group.checkedButton()</kbd><span>: This returns the checked buttons within this button group, or</span> <kbd>0</kbd> <span>if the group does not contain the checked buttons.</span></p>
<p><kbd>button_group.checkedId()</kbd><span>: This returns the IDs of the checked buttons within this button group, or</span> <kbd>-1</kbd> <span>if the group</span> <span>does not contain the </span><span>checked buttons.</span></p>
<p><kbd>button_group.exclusive()</kbd><span>: This returns</span> <kbd>True</kbd> <span>if the button group is exclusive. This means that only one button in this group can be checked at any one time.</span></p>
<p><kbd>button_group.id(QtWidgets.QAbstractButton)</kbd><span>: This returns the ID of the button specified in the parameter.</span></p>
<p><kbd>button_group.removeButton(QtWidgets.QAbstractButton)</kbd><span>: This removes the button specified in the parameter from this button group.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">signals</h1>
                </header>
            
            <article>
                
<p>The available signals for the <kbd>QButtonGroup</kbd> class are as follows:</p>
<p><kbd>button_group.buttonClicked(QtWidgets.QAbstractButton)</kbd>: This signal is emitted when the button specified in the parameter is clicked.</p>
<p><kbd>button_group.buttonClicked(int)</kbd><span>: This signal is emitted when the button with the ID specified in the parameter is clicked.</span></p>
<p><kbd>button_group.buttonPressed(QtWidgets.QAbstractButton)</kbd><span>: This signal is emitted when the button specified in the parameter is pushed down.</span></p>
<p><kbd>button_group.buttonPressed(int)</kbd><span>: This signal is emitted when the button with the ID specified in the parameter is pushed down.</span></p>
<p><kbd>button_group.buttonReleased(QtWidgets.QAbstractButton)</kbd><span>: This signal is emitted when the button specified in the parameter is released.</span></p>
<p><kbd>button_group.buttonReleased(int)</kbd><span>: This signal is emitted when the button with the ID specified in the parameter is released.</span></p>
<p><kbd>button_group.buttonToggled(QtWidgets.QAbstractButton, bool)</kbd><span>: This signal is emitted when the button specified in the first parameter is toggled. The second parameter is</span> <kbd>True</kbd> <span>if the button is checked, or</span> <kbd>False</kbd> <span>if unchecked.</span></p>
<p><kbd>button_group.buttonToggled(int, bool)</kbd><span>: This signal is emitted when the button with the ID specified in the first parameter is toggled. The second parameter is</span> <kbd>True</kbd> <span>if the button is checked, or</span> <kbd>False</kbd> <span>if unchecked.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Buttons example</h1>
                </header>
            
            <article>
                
<p>Now, let's try and create a push button that will be used with the application. Other types of buttons, in addition to the ones described here, will be implemented, as required, later in this book. By way of an example, let's create the push button:</p>
<ol>
<li>First of all, construct the <kbd>UBut1</kbd><span> </span>class <span>in both </span><kbd>u_style.py</kbd><span> files:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>class UBut1(QtWidgets.QPushButton):<br/><br/>    def __init__(self, parent=None,<br/>            bg="rgba(9,219,190,140)",<br/>            bgh="rgba(9,219,190,255)",<br/>            txc="rgba(1,255,255,190)",<br/>            txch="rgba(1,255,255,255)",<br/>            minw=0, minh=0, maxw=None,<br/>            maxh=None, fixw=None, fixh=None,<br/>            mrg=0, pad=7, bds="solid",<br/>            bdr=3, bdw=0, bdc=color[3], checks=False):<br/>        super(UBut1, self).__init__(parent)<br/>        self.setFlat(True)<br/>        self.setMouseTracking(True)<br/>        self.setMinimumWidth(minw)<br/>        self.setMinimumHeight(minh)<br/>        if maxw is not None:<br/>            self.setMaximumWidth(maxw)<br/>        if maxh is not None:<br/>            self.setMaximumHeight(maxh)<br/>        if fixw is not None:<br/>            self.setFixedWidth(fixw)<br/>        if fixh is not None:<br/>            self.setFixedHeight(fixh)<br/>        self.checks = checks<br/>        self.setCheckable(self.checks)<br/>        self.bg, self.bgh, self.txc, self.txch = bg, bgh, txc, txch <br/>        self.mrg, self.pad = mrg, pad<br/>        self.bds, self.bdr, self.bdw, self.bdc = bds, bdr, bdw, bdc<br/>        self.setStyleSheet(self.but_style(self.mrg, self.pad, self.bg,<br/>                    self.txc, self.bds, self.bdr, self.bdw, self.bgh))<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We have added <span>various parameters </span>to the <kbd>__init__()</kbd> function of the <kbd>UBut1</kbd> class. The maximum width and height <span>can be adjusted with respect to the appearance of the button in the GUI</span>.</p>
<ol start="2">
<li>Add <span>the </span><kbd>but_style()</kbd><span> function, which will be used for styling this button, </span>to the <kbd>UBut1</kbd><strong> </strong>class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def but_style(self, mrg=None, pad=None, bg=None,<br/>                  txc=None, bds=None, bdr=None,<br/>                                bdw=None, bdc=None):<br/>        style = """margin: %spx; padding: %spx;<br/>                   background-color: %s; color: %s;<br/>                   border-style: %s; border-radius: %spx;<br/>                   border-width: %spx; border-color: %s;"""<br/>                % (mrg, pad, bg, txc, bds, bdr, bdw, bdc)<br/>        return style<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will be used to avoid repetition in the code and will style this button if events occur. Add the functions that will be used with events that occur; in the first instance, we will add the function that handles button resize events, or when the button is resized, depending on the window size, and changes the font of the text of this button. </p>
<ol start="3">
<li>Here is the function that handles resize events:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def resizeEvent(self, event):<br/>        self.fonts = UFonts(<br/>           size=int(<br/>              (self.width() + self.height())/self.pad),<br/>                                                weight=100)<br/>        self.setFont(self.fonts.font1)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function handles the resize event with the <kbd>event</kbd> passed in the parameter. It changes the font of the button, depending on the button's size.</p>
<ol start="4">
<li>Add<span> the <kbd>enterEvent</kbd> function, which handles the enter event of the button when the mouse </span>enters<span> the button area. </span>The <kbd>enterEvent</kbd> function is added as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def enterEvent(self, event):<br/>        self.setStyleSheet(self.but_style(self.mrg, self.pad,<br/>                           self.bgh, self.txch, self.bds,<br/>                           self.bdr, self.bdw, self.bdc))<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function handles the enter events of this button and changes the style accordingly.</p>
<ol start="5">
<li>Add the <kbd>leaveEvent</kbd> function for <span>this button's </span>leave events when the mouse pointer leaves this button:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def leaveEvent(self, event):.<br/>        self.setStyleSheet(self.but_style(self.mrg,<br/>                 self.pad, self.bg, self.txc, self.bds,<br/>                           self.bdr, self.bdw, self.bgh))<br/>    ...<br/>...</pre>
<p style="padding-left: 60px"><span>This function handles the leave events of this button and changes the style accordingly. </span>This is an example of an attempt to create a class that provides the push button for a variety of uses. Or, in other words, it gives the user the opportunity to style the button component, depending on the application tasks and functionality. All of these styling parameters can be changed within this class, as well as outside, for example, when used in the main application or elsewhere.</p>
<p>Now, we need to add the <kbd>UBut1</kbd> class to the main application class in the <kbd>u_app.py</kbd><span> files </span>with some customized parameters. Follow these steps to do so:</p>
<ol>
<li>Add the following line to the <kbd>import</kbd> section of the <kbd>u_app.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from u_style import UBut1<br/>...</pre>
<ol start="2">
<li>Then, we need to add this button to the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UApp(UWindow, UTools):<br/><br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.push_but1 = UBut1(self.frame2)<br/>        self.push_but1.setText("Ok")<br/>        self.layfr2_1 = QtWidgets.QGridLayout()<br/>        self.layfr2_1.addWidget(self.push_but1, 0, 1, 1, 1)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We have added the button instance and created the layout that will contain this button.</p>
<ol start="3">
<li>Then, add the layout that was <span>created </span>with this button to the layout of the second frame:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UApp(UWindow, UTools):<br/><br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.layfr2.addLayout(self.layfr2_1, 5, 0, 1, 1)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We will see the following result:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2ee6e5e9-3a6a-426f-8181-f77682cc109f.png" style="width:55.00em;height:47.83em;"/></p>
<p style="padding-left: 60px">In the right-bottom corner, we can see the <kbd>Ok</kbd> button. This will provide a hover effect of being a lighter green color if the mouse pointer rolls over the button. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QCheckBox</h1>
                </header>
            
            <article>
                
<p>Just like the radio button, the checkbox is an option button that allows the user to make a choice. These buttons are usually implemented in combination with the features that will be used with a particular action. These options can be switched on or off as per the user's preference. The checkbox can display the text of the option, as well as the icon. The declaration syntax for this kind of button is as follows:</p>
<pre><strong>check_box</strong> = QtWidgets.QCheckBox()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QCheckBox functions</h1>
                </header>
            
            <article>
                
<p><kbd>QCheckBox</kbd> inherits from the <kbd>QAbstractButton</kbd> class and improves functionality by means of the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are related to setting the parameters/properties in relation to the</span> checkbox:</p>
<p><kbd>check_box.setCheckState(QtCore.Qt.CheckState)</kbd>: This sets the check state for this checkbox.</p>
<p><kbd>check_box.setTristate(bool)</kbd><span>: This sets the three-state availability that will be used with this checkbox. The states that can be used are as follows:</span></p>
<ul>
<li><kbd>QtCore.Qt.Unchecked</kbd>: The checkbox is unchecked.</li>
<li><kbd>QtCore.Qt.PartiallyChecked</kbd>: The checkbox is partially checked.</li>
<li><kbd>QtCore.Qt.Checked</kbd>: The checkbox is checked.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">is</h1>
                </header>
            
            <article>
                
<p><span>This function returns a Boolean value (<kbd>bool</kbd>) related to the</span> checkbox states:</p>
<p><kbd>check_box.isTristate()</kbd>: This returns <kbd>True</kbd> if this checkbox has three states.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p><span>This function is related to the returns of the</span> current values of the checkbox:</p>
<p><kbd>check_box.checkState()</kbd>: This returns the check state of the <kbd>QtCore.Qt.CheckState</kbd> type for this checkbox.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p><span>These are functions that are</span><span> related to events, such as event handlers</span>:</p>
<p><kbd>check_box.event(QtCore.QEvent)</kbd>: This is the <kbd>QtCore.QObject</kbd> function that receives events to the object and should return <kbd>True</kbd> if the event is recognized and processed.</p>
<p><kbd>check_box.mouseMoveEvent(QtGui.QMouseEvent)</kbd><span>: This is an event handler that's designed to receive mouse move events for the checkbox, with events passed in the parameter.</span></p>
<p><kbd>check_box.paintEvent(QtGui.QPaintEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive paint events for the checkbox, with events passed in the parameter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">signals</h1>
                </header>
            
            <article>
                
<p>The available signal for the <kbd>QCheckBox</kbd> class is as follows:</p>
<p><kbd>check_box.stateChanged(int)</kbd>: This signal is emitted when the state of this checkbox is changed, with states passed in the parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional components</h1>
                </header>
            
            <article>
                
<p>Alongside what we've covered in this chapter, let's consider sliders and other useful components that can be used with GUI applications. The different types of sliders make it possible to provide the functionality with some additional special actions, such as scrolling windows and sliding values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QAbstractSlider</h1>
                </header>
            
            <article>
                
<p>This class is a super class for components, including the scrollbar, slider, and dial. <kbd>QAbstractSlider</kbd> inherits from the <kbd>QWidget</kbd> class and improves functionality by means of the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are related to setting the parameters/properties, including</span> size, range, and functionality:</p>
<p><kbd>setInvertedAppearance(bool)</kbd>: If the parameter is <kbd>True</kbd>, the inherited component will show its values inverted.</p>
<p><kbd>setInvertedControls(bool)</kbd><span>: If the parameter is</span> <kbd>True</kbd><span>, this sets the wheel and key events as inverted for the component that's </span><span>used</span><span>.</span></p>
<p><kbd>setMaximum(int)</kbd><span>: This sets the maximum value specified in the parameter for the component that's </span><span>used. In the case of the </span><span>slider, this will be the maximum value in the</span> range<span>.</span></p>
<p><kbd>setMinimum(int)</kbd><span>: This sets the minimum value specified in the parameter for the</span> <span>component that's </span><span>used. In the case of the </span><span>slider, this will be the minimum value in the range</span><span>.</span></p>
<p><kbd>setOrientation(QtCore.Qt.Orientation)</kbd><span>: This sets the orientation for the used component as</span> <kbd>QtCore.Qt.Horizontal</kbd> <span>or</span> <kbd>QtCore.Qt.Vertical</kbd> <span>(the default).</span></p>
<p><kbd>setPageStep(int)</kbd><span>: This sets the page step specified in the parameter that will be used with this component.</span></p>
<p><kbd>setRange(int, int)</kbd><span>: This sets the range values for the component</span> <span>used</span><span>, from minimum (the first parameter) to maximum (the second parameter).</span></p>
<p><kbd>setRepeatAction(QtWidgets.QAbstractSlider.SliderAction, int, int)</kbd><span>: This sets the action (the first parameter) that will be triggered at intervals (the third parameter), or with a delay (the second parameter).</span></p>
<p><kbd>setSingleStep(int)</kbd><span>: This sets the single step for the component</span> <span>used</span><span>, typically by responding to pushing an arrow key of one of the components.</span></p>
<p><kbd>setSliderDown(bool)</kbd><span>: If the parameter is</span> <kbd>True</kbd><span>, the slider will be pulled down.</span></p>
<p><kbd>setSliderPosition(int)</kbd><span>: This sets the current position specified in the parameter for the slider component.</span></p>
<p><kbd>setTracking(bool)</kbd><span>: If the parameter is</span> <kbd>True</kbd><span>, this sets the tracking as enabled. If this property is enabled, the component emits the</span> <kbd>valueChanged()</kbd> <span>signal when dragged. In another instance, this signal will only be emitted when released.</span></p>
<p><kbd>setValue(int)</kbd><span>: This sets the current value specified in the parameter of the component in the range. For example, the slider's handle will move to this value.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">is</h1>
                </header>
            
            <article>
                
<p><span>These function returns a Boolean value (<kbd>bool</kbd>) related to</span> states:</p>
<p><kbd>isSliderDown()</kbd>: This returns <kbd>True</kbd> if the component is pressed down</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p><span>These are functions that are related to the returns of the current</span> <span>values</span><span>, changes in functionality, and so on</span>:</p>
<p><kbd>invertedAppearance()</kbd>: This returns <kbd>True</kbd> if the inherited component shows its values inverted.</p>
<p><kbd>invertedControls()</kbd><span>: This returns</span> <kbd>True</kbd> <span>if the wheel and key events are inverted for the component being </span><span>used</span><span>.</span></p>
<p><kbd>maximum()</kbd><span>: This returns the maximum value of the integer type for the component being </span><span>used</span><span>. In the case of the </span><span>slider, this will be the maximum value in the range.</span></p>
<p><kbd>minimum()</kbd><span>: This returns the minimum value of the integer type</span> <span>for the component being </span><span>used</span><span>. In the case of the </span><span>slider, this will be the minimum value in the range.</span></p>
<p><kbd>orientation()</kbd><span>: This returns the orientation of the</span> <kbd>QtCore.Qt.Orientation</kbd> <span>type for the component being </span><span>used</span><span>.</span></p>
<p><kbd>pageStep()</kbd><span>: This returns the page step, as an integer value, of the component being </span><span>used</span><span>.</span></p>
<p><kbd>repeatAction()</kbd><span>: This returns the repeat action of the</span> <kbd>QtWidgets.QAbstractSlider.SliderAction</kbd> <span>type for the component being </span><span>used</span><span>.</span></p>
<p><kbd>singleStep()</kbd><span>: This returns the single step of the component being </span><span>used</span><span>.</span></p>
<p><kbd>sliderChange(QtWidgets.QAbstractSlider.SliderChange)</kbd><span>: This tracks slider changes with the available parameters, such as the following:</span></p>
<ul>
<li><kbd>QtWidgets.QAbstractSlider.SliderRangeChange</kbd>—<kbd>0</kbd>: Range changes.</li>
<li><kbd>QtWidgets.QAbstractSlider.SliderOrientationChange</kbd>—<kbd>1</kbd>: Orientation changes.</li>
<li><kbd>QtWidgets.QAbstractSlider.SliderStepsChange</kbd>—<kbd>2</kbd>: Step changes.</li>
<li><kbd>QtWidgets.QAbstractSlider.SliderValueChange</kbd>—<kbd>3</kbd>: Value changes.</li>
</ul>
<p><kbd>sliderPosition()</kbd>: This returns the current position of the slider component in the range.</p>
<p><kbd>triggerAction(QtWidgets.QAbstractSlider.SliderAction)</kbd><span>: This triggers the slider action specified in the parameter.</span></p>
<p><kbd>value()</kbd><span>: This returns the current value of the slider component.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p><span>These are functions that are</span><span> related to events such as event handlers, and so on</span>:</p>
<p><kbd>changeEvent(QtCore.QEvent)</kbd>: This handles state changes.</p>
<p><kbd>event(QtCore.QEvent)</kbd><span>: This is the</span> <kbd>QtCore.QObject</kbd> <span>function, which receives events to the object and should return</span> <kbd>True</kbd> <span>if the event is recognized and processed.</span></p>
<p><kbd>keyPressEvent(QtGui.QKeyEvent)</kbd><span>: T</span><span>his is an event handler that's designed to </span><span>receive key press events for the component being </span><span>used, </span><span>with a key event passed in the parameter.</span></p>
<p><kbd>timerEvent(QtCore.QTimerEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive timer events for the component being </span><span>used, </span><span>with a timer event passed in the parameter.</span></p>
<p><kbd>wheelEvent(QtGui.QWheelEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive mouse wheel events for the component being </span><span>used, </span><span>with a wheel event passed in the parameter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">signals</h1>
                </header>
            
            <article>
                
<p>The available signals for the <kbd>QAbstractSlider</kbd> class are as follows:</p>
<p><kbd>actionTriggered(int)</kbd>: This signal is emitted when the slider is triggered by an action that's passed in the parameter.</p>
<p><kbd>rangeChanged(int, int)</kbd><span>: This signal is emitted when the slider's range has been modified with new minimum and maximum range parameters.</span></p>
<p><kbd>sliderMoved(int)</kbd><span>: This signal is emitted when the slider moves and</span> <kbd>sliderDown()</kbd> <span>is</span> <kbd>True</kbd><span>, with a new slider position passed in the parameter.</span></p>
<p><kbd>sliderPressed()</kbd><span>: This signal is emitted when the slider is pressed, also programmatically with</span> <kbd>setSliderDown(True)</kbd>.</p>
<p><kbd>sliderReleased()</kbd><span>: This signal is emitted when the slider is released, also programmatically with</span> <kbd>setSliderDown(True)</kbd>.</p>
<p><kbd>valueChanged(int)</kbd><span>: This signal is emitted when the slider value is revised, with new values passed in the parameter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QSlider</h1>
                </header>
            
            <article>
                
<p>This class provides a vertical or horizontal slider in the GUI application that can be used to move a slider handle along a groove and translates the position of the handle into an integer value. <kbd>QSlider</kbd> inherits from the <kbd>QAbstractSlider</kbd> class. The declaration syntax for the slider is as follows:</p>
<pre><strong>slider</strong> = QtWidgets.QSlider()</pre>
<p>The <kbd>QSlider</kbd> class improves functionality by means of the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p><span>These are functions that are related to setting the parameters/properties in relation to the</span> slider:</p>
<p><kbd>slider.setTickInterval(int)</kbd>: This sets the interval between the tick marks of this slider.</p>
<p><kbd>slider.setTickPosition(QtWidgets.QSlider.TickPosition)</kbd><span>: This sets the tick mark position of this slider. The available parameters are as follows:</span></p>
<ul>
<li><kbd>QtWidgets.QSlider.NoTicks</kbd>—<kbd>0</kbd>: No tick marks.</li>
<li><kbd>QtWidgets.QSlider.TicksBothSides</kbd>—<kbd>3</kbd>: Tick marks on both sides.</li>
<li><kbd>QtWidgets.QSlider.TicksAbove</kbd>—<kbd>1</kbd>: Tick marks above (horizontal).</li>
<li><kbd>QtWidgets.QSlider.TicksBelow</kbd>—<kbd>2</kbd>: Tick marks below (horizontal).</li>
<li><kbd>QtWidgets.QSlider.TicksLeft</kbd>—<kbd>TicksAbove</kbd>: Tick marks left (vertical).</li>
<li><kbd>QtWidgets.QSlider.TicksRight</kbd>—<kbd>TicksBelow</kbd>: Tick marks right (vertical).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p><span>These are functions that return the current</span> values:</p>
<p><kbd>slider.tickInterval()</kbd>: This returns the interval between the tick marks of the slider.</p>
<p><kbd>slider.tickPosition()</kbd><span>: This returns the tick mark position of the</span> <kbd>QtWidgets.QSlider.TickPosition</kbd> <span>type.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p><span>These are functions that are</span><span> related to events, such as event handlers</span>:</p>
<p><kbd>slider.event(QtCore.QEvent)</kbd>: This is the <kbd>QtCore.QObject</kbd> function, which receives events to the object and should return <kbd>True</kbd> if the event is recognized and processed.</p>
<p><kbd>slider.mouseMoveEvent(QtGui.QMouseEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive mouse move events for the slider, with a mouse event passed in the parameter.</span></p>
<p><kbd>slider.mousePressEvent(QtGui.QMouseEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive mouse press events for the slider, with a mouse event passed in the parameter.</span></p>
<p><kbd>slider.mouseReleaseEvent(QtGui.QMouseEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive mouse release events for the slider, with a mouse event passed in the parameter.</span></p>
<p><kbd>slider.paintEvent(QtGui.QPaintEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive paint events for the slider, with a paint event passed in the parameter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QDial</h1>
                </header>
            
            <article>
                
<p>This class provides a rounded range component that can be wrapped around in a range of <kbd>0</kbd> to <kbd>359</kbd> degrees. <kbd>QDial</kbd> inherits from the <kbd>QAbstractSlider</kbd> class. The declaration syntax for the dial is as follows:</p>
<pre><strong>dial</strong> = QtWidgets.QDial()</pre>
<p>The <kbd>QDial</kbd>  class improves functionality by means of the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are related to setting parameters/properties in relation to the</span> dial:</p>
<p><kbd>dial.setNotchesVisible(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets the notches of this dial as being visible.</p>
<p><kbd>dial.setNotchTarget(float)</kbd><span>: This sets the target number in the pixels specified in the parameter between each notch of this dial.</span></p>
<p><kbd>dial.setWrapping(bool)</kbd><span>: If the parameter is</span> <kbd>True</kbd><span>, this sets wrapping as enabled for this dial.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p><span>These are functions that are related to the returns of the current</span> values:</p>
<p><kbd>dial.notchesVisible()</kbd>: This returns <kbd>True</kbd> if the notches are visible on this dial.</p>
<p><kbd>dial.notchSize()</kbd><span>: This returns the current size of the dial's notches.</span></p>
<p><kbd>dial.notchTarget()</kbd><span>: This returns the target number of pixels as float values, and are used between the notches of this dial.</span></p>
<p><kbd>dial.wrapping()</kbd><span>: This returns</span> <kbd>True</kbd> <span>if the wrapping is enabled for this dial.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p><span>These are functions that are</span><span> related to events such as event handlers, and so on</span>:</p>
<p><kbd>dial.event(QtCore.QEvent)</kbd>: This receives events to the object and should return <kbd>True</kbd> if the event is recognized and processed.</p>
<p><kbd>dial.mouseMoveEvent(QtGui.QMouseEvent)</kbd>: T<span>his is an event handler that's designed </span>to receive mouse move events for this dial, with a mouse event passed in the parameter.</p>
<p><kbd>dial.mousePressEvent(QtGui.QMouseEvent)</kbd>: T<span>his is an event handler that's designed </span>to receive mouse press events for this dial, with a mouse event passed in the parameter.</p>
<p><kbd>dial.mouseReleaseEvent(QtGui.QMouseEvent)</kbd>: T<span>his is an event handler that's designed </span>to receive mouse release events for this dial, with a mouse event passed in the parameter.</p>
<p><kbd>dial.paintEvent(QtGui.QPaintEvent)</kbd>: T<span>his is an event handler that's designed </span>to receive paint events for this dial, with a paint event passed in the parameter.</p>
<p><kbd>dial.resizeEvent(QtGui.QResizeEvent)</kbd>: T<span>his is an event handler that's designed </span>to receive widget resize events for this dial, with a resize event passed in the parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QProgressBar</h1>
                </header>
            
            <article>
                
<p>The progress bar provides a horizontal or vertical component to indicate the operation's progress. This can be implemented in the application. The declaration syntax for the application as is as follows:</p>
<pre><strong>progress</strong> = QtWidgets.QProgressBar()</pre>
<p><kbd>QProgressBar</kbd> inherits from the <kbd>QWidget</kbd> class and improves functionality by means of the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p><span>These are functions</span><span> that are related to the setting of the parameters/properties in relation to the</span> progress bar:</p>
<p><kbd>progress.setAlignment(QtCore.Qt.Alignment)</kbd>: This sets the alignment that will be used with the progress bar.</p>
<p><kbd>progress.setFormat("%p%")</kbd><span>: This sets the format for the text that will be used with progression. The available formats are as follows:</span></p>
<ul>
<li><kbd>"%p%"</kbd>: The values will be replaced by the percentage (the default)</li>
<li><kbd>"%v%"</kbd>: The values will be replaced by the current value</li>
<li><kbd>"%m%"</kbd>: The values will be replaced by the total number of completed steps</li>
</ul>
<p><kbd>progress.setInvertedAppearance(bool)</kbd>: If the parameter is <kbd>True</kbd>, the bar will display its progress as inverted.</p>
<p><kbd>progress.setMaximum(int)</kbd><span>: This sets the maximum value for this progress bar.</span></p>
<p><kbd>progress.setMinimum(int)</kbd><span>: This sets the minimum value for this progress bar.</span></p>
<p><kbd>progress.setOrientation(QtCore.Qt.Orientation)</kbd><span>: This sets the orientation of this progress bar. In the parameter, the</span> <kbd>QtCore.Qt.Vertical</kbd> <span>or</span> <kbd>QtCore.Qt.Horizontal</kbd> <span>(the default) orientations can be used.</span></p>
<p><kbd>progress.setRange(int, int)</kbd><span>: This sets the range for the values of the progress bar, with the minimum (the first parameter) and maximum (the second parameter) specified. By using</span> <kbd>setRange(0, 0)</kbd><span>, the progress bar will be set to an indeterminate state.</span></p>
<p><kbd>progress.setTextDirection(QtWidgets.QProgressBar.Direction)</kbd><span>: This sets the direction specified in the parameter for the text displayed with this progress bar. The available directions for the vertical progress bar are as follows:</span></p>
<ul>
<li><kbd>QtWidgets.QProgressBar.TopToBottom</kbd>—<kbd>0</kbd>: The text will be rotated by <kbd>90</kbd> degrees clockwise</li>
<li><kbd>QtWidgets.QProgressBar.BottomToTop</kbd>—<kbd>1</kbd>: The text will be rotated by <kbd>90</kbd> degrees counter-clockwise</li>
</ul>
<p><kbd>progress.setTextVisible(bool)</kbd>: If the parameter is <kbd>True</kbd>, the current completed percentage will be displayed through this progress bar.</p>
<p><kbd>progress.setValue(int)</kbd><span>: This sets the current value specified in the parameter for this progress bar.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">is</h1>
                </header>
            
            <article>
                
<p><span>This function returns a Boolean value (<kbd>bool</kbd>) related to</span> states:</p>
<p><kbd>progress.isTextVisible()</kbd>: This returns <kbd>True</kbd> if the current completed percentage is displayed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p><span>These functions are related to the returns of the current</span> <span>values</span><span>, changes in functionality, and so on</span>:</p>
<p><kbd>progress.alignment()</kbd>: This returns the alignment of the <kbd>QtCore.Qt.Alignment</kbd> type that will be used with this progress bar.</p>
<p><kbd>progress.format()</kbd><span>: This returns the string with the format that will be used to generate the text displayed in the progress bar.</span></p>
<p><kbd>progress.maximum()</kbd><span>: This returns the maximum value of the progress bar.</span></p>
<p><kbd>progress.minimum()</kbd><span>: This returns the minimum value of the progress bar.</span></p>
<p><kbd>progress.orientation()</kbd><span>: This returns the orientation of the</span> <kbd>QtCore.Qt.Orientation</kbd> <span>type for the progress bar.</span></p>
<p><kbd>progress.reset()</kbd><span>: This will reset the progress bar. The progress bar does not progress and rewinds.</span></p>
<p><kbd>progress.resetFormat()</kbd><span>: This will reset the format of the text used with the progress bar.</span></p>
<p><kbd>progress.text()</kbd><span>: This returns the text displayed with this progress bar.</span></p>
<p><kbd>progress.value()</kbd><span>: This returns the current value of this progress bar.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p><span>These functions are</span><span> related to events such as event handlers, and so on</span>:</p>
<p><kbd>progress.event(QtCore.QEvent)</kbd>: This receives events to the object and should return <kbd>True</kbd> if the event is recognized and processed.</p>
<p><kbd>progress.mouseMoveEvent(QtGui.QMouseEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive mouse move events for the progress bar, with a mouse event passed in the parameter.</span></p>
<p><kbd>progress.mousePressEvent(QtGui.QMouseEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive mouse press events for the progress bar, with a mouse event passed in the parameter.</span></p>
<p><kbd>progress.mouseReleaseEvent(QtGui.QMouseEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive mouse release events for the progress bar, with a mouse event passed in the parameter.</span></p>
<p><kbd>progress.paintEvent(QtGui.QPaintEvent)</kbd><span>: T</span><span>his is an event handler that's designed </span><span>to receive paint events for this progress bar, with a paint event passed in the parameter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">signals</h1>
                </header>
            
            <article>
                
<p>The available signal for the <kbd>QProgressBar</kbd> class is as follows:</p>
<p><kbd>valueChanged(int)</kbd>: This signal is emitted when the progress bar value has changed, with the new value passed in the parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QProgressBar example</h1>
                </header>
            
            <article>
                
<p>Now, we can create the progress bar for the application. This will indicate the progress of certain operations that will be run. To do this, create a class named <kbd>UProgress</kbd> in the <kbd>u_style.py</kbd> files:</p>
<ol>
<li>Add the <kbd>UProgress</kbd><span> </span>class for the progress bar:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UProgress(QtWidgets.QProgressBar):<br/><br/>    def __init__(self, parent=None,<br/>                 bg="rgba(0,190,255,140)",<br/>                 txc="rgba(1,255,255,190)",<br/>                 minw=0, minh=0, maxw=None, maxh=None,<br/>                 fixw=None, fixh=None, mrg=0, pad=7,<br/>                 bds="solid", bdr=3, bdw=0, bdc=color[3]):<br/>        super(UProgress, self).__init__(parent)<br/>        self.setMinimumWidth(minw)<br/>        self.setMinimumHeight(minh)<br/>        if maxw is not None:<br/>            self.setMaximumWidth(maxw)<br/>        if maxh is not None:<br/>            self.setMaximumHeight(maxh)<br/>        if fixw is not None:<br/>            self.setFixedWidth(fixw)<br/>        if fixh is not None:<br/>            self.setFixedHeight(fixh)<br/>        self.bg, self.txc, self.mrg, self.pad = bg, txc, mrg, pad <br/>        self.bds, self.bdr, self.bdw, self.bdc = bds, bdr, bdw, bdc<br/>        self.setStyleSheet(self.pgrs_style(self.mrg, self.pad,<br/>          self.bg, self.txc, self.bds, self.bdr, self.bdw, color[2]))<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We have successfully added the styling properties for the progress bar. These can be reimplemented in the application.</p>
<ol start="2">
<li>Then, add the <kbd>pgrs_style()</kbd> function  to this class. This will be used to style the progress bar:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def pgrs_style(self, mrg=None, pad=None, bg=None,<br/>          txc=None, bds=None, bdr=None, bdw=None, bdc=None):<br/>        style = """QProgressBar {margin: %spx; padding: %spx;<br/>                    border-style: %s; border-radius: %spx;<br/>                    border-width: %spx; border-color: %s;}<br/>                   QProgressBar::chunk {background-color: %s;<br/>                   color: %s;} """ % (mrg, pad, bds, bdr, bdw,<br/>                                                 bdc, bg, txc)<br/>        return style<br/>...</pre>
<p style="padding-left: 60px">This function will restyle the progress bar and is dependent on certain events. The handlers of these events can be added later. Now, we need to realize this progress bar in the GUI by adding some classes to the <kbd>u_app.py</kbd><span> files.</span></p>
<ol start="3">
<li>Add the <kbd>UProgress</kbd> class t<span>o the import section:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>from u_style import UProgress<br/>...</pre>
<ol start="4">
<li>Then, add the <span>progress bar to the </span><kbd>UApp</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def __init__(self, parent=None):<br/>        ... <br/>        self.progress1 = UProgress(self.frame2)<br/>        self.progress1.setRange(0, 0)<br/>        self.layfr2_1 = QtWidgets.QGridLayout()<br/>        self.layfr2_1.addWidget(self.push_but1, 0, 1, 1, 1)<br/>        self.layfr2_1.addWidget(self.progress1, 1, 0, 1, 2)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We are using the <kbd>setRange()</kbd> method of the bar to set the <span>progress in indeterminate mode. </span>When we run the <kbd>u_app.py</kbd> file, we will see the following result (the progress bar slides indefinitely in indeterminate mode):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5b3516fc-f18d-427e-a051-d8792f855b20.png" style="width:52.58em;height:46.58em;"/></p>
<p style="padding-left: 60px">We added the progress bar below the button. At the moment, it is in an <span>indeterminate state.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter demonstrated the basic features and properties of the most popular components that can be used in the GUI application. These elements are buttons, as well as some controls and indication bars. Not all of them were covered in our examples, but they can be used and added later, <span>as required,</span> in the implementation of the functionality to the app.</p>
<p>This chapter draws a line under the description of the main components of the GUI application. In the next chapter, we will dive into the basics of graphics in our GUI application.</p>


            </article>

            
        </section>
    </body></html>