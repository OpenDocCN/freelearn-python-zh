- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Adding Other Microservice Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加其他微服务功能
- en: Our long journey of exploring FastAPI’s extensibility in building microservice
    applications will end with this chapter, which covers standard recommendations
    on project setup, maintenance, and deployment using some microservice-related
    tools based on design patterns. This chapter will discuss the *OpenTracing* mechanism
    and its use in a distributed FastAPI architecture setup using tools such as *Jaeger*
    and `StarletteTracingMiddleWare`. The *service registry* and *client-side discovery*
    design patterns are included likewise in the detailed discussions on how to manage
    access to the API endpoints of the microservices. A microservice component that
    checks for the *health* of the API endpoints will also be part of the discussion.
    Moreover, the chapter will not end without recommendations on the FastAPI application’s
    *deployment*, which might lead to other design strategies and network setups.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索FastAPI在构建微服务应用程序中的可扩展性的漫长旅程将随着本章的结束而结束，本章涵盖了基于设计模式的项目设置、维护和部署的一些标准建议，使用了一些与微服务相关的工具。本章将讨论*OpenTracing*机制及其在分布式FastAPI架构设置中的应用，例如使用*Jaeger*和`StarletteTracingMiddleWare`等工具。同样，*服务注册*和*客户端发现*设计模式也包含在如何管理访问微服务API端点的详细讨论中。一个检查API端点*健康状态*的微服务组件也将是讨论的一部分。此外，本章在结束之前还将提供关于FastAPI应用程序的*部署*建议，这可能导致其他设计策略和网络设置。
- en: 'The main goal of this chapter is to complete the design architecture of a FastAPI
    application before its sign-off. Here are the topics that will complete our FastAPI
    application development venture:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是完成FastAPI应用程序的设计架构，在签发之前。以下是完成我们的FastAPI应用程序开发之旅的议题：
- en: Setting up the virtual environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置虚拟环境
- en: Checking the API properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查API属性
- en: Implementing open tracing mechanisms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施开放跟踪机制
- en: Setting up service registry and client-side service discovery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置服务注册和客户端服务发现
- en: Deploying and running applications using Docker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker部署和运行应用程序
- en: Using Docker Compose for deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose进行部署
- en: Utilizing NGINX as an API gateway
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用NGINX作为API网关
- en: Integrating Django and Flask sub-applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Django和Flask子应用程序
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Our last software prototype will be an `ch11` and other [*Chapter 11*](B17975_11.xhtml#_idTextAnchor321)-related
    projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的软件原型将是`ch11`和其他[*第11章*](B17975_11.xhtml#_idTextAnchor321)相关项目。
- en: Setting up the virtual environment
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置虚拟环境
- en: 'Let us start with the proper way of setting up the development environment
    of our FastAPI application. In Python development, it is common to manage the
    libraries and extension modules that are needed using a virtual environment. A
    virtual environment is a way of creating multiple different and parallel installations
    of Python interpreters and their dependencies where each has the application(s)
    to be compiled and run. Each instance has its own set of libraries depending on
    the requirements of its application(s). But first, we need to install the `virtualenv`
    module to pursue the creation of these instances:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置我们的FastAPI应用程序的开发环境的正确方式开始。在Python开发中，使用虚拟环境管理所需的库和扩展模块是很常见的。虚拟环境是一种创建多个不同且并行安装的Python解释器和它们的依赖项的方式，其中每个实例都有要编译和运行的应用程序。每个实例都有其自己的库集合，这取决于其应用程序的需求。但首先，我们需要安装`virtualenv`模块以追求创建这些实例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following list describes the benefits of having a virtual environment:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了拥有虚拟环境的好处：
- en: To avoid the overlapping of the library version
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免库版本的冲突
- en: To avoid broken installed module files due to namespace collisions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免由于命名空间冲突而导致的已安装模块文件损坏
- en: To localize the libraries to avoid conflicts with the globally installed modules
    on which some applications are very dependent
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将库本地化以避免与某些应用程序非常依赖的全局安装的模块冲突
- en: To create a template or baseline copy of the set of modules to be replicated
    on some related projects
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建要复制到某些相关项目的模块集的模板或基线副本
- en: To maintain operating system performance and setup
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护操作系统性能和设置
- en: 'After the installation, we need to run the `python -m virtualenv` command to
    create an instance. *Figure 11.1* shows how the `ch01-env` virtual environment
    for the `ch01` project is created:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们需要运行`python -m virtualenv`命令来创建一个实例。*图11.1*显示了如何为`ch01`项目创建`ch01-env`虚拟环境：
- en: '![Figure 11.1 – Creating a Python virtual environment'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – 创建Python虚拟环境'
- en: '](img/Figure_11.01_B17975.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.01_B17975.jpg)'
- en: Figure 11.1 – Creating a Python virtual environment
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 创建 Python 虚拟环境
- en: 'To use the virtual environment, we need to configure our *VS Code editor* to
    utilize the Python interpreter of the virtual environment instead of the global
    interpreter to install modules, compile, and run the application. Pressing *Ctrl*
    + *Shift* + *P* will open the *Command Palette* showing the Python command to
    *select the interpreter*. *Figure 11.2* shows the process of choosing the Python
    interpreter for the `ch01` project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用虚拟环境，我们需要配置我们的 *VS Code 编辑器* 以使用虚拟环境的 Python 解释器而不是全局解释器来安装模块、编译和运行应用程序。按下
    *Ctrl* + *Shift* + *P* 将会打开 *命令面板*，显示用于 *选择解释器* 的 Python 命令。*图 11.2* 展示了为 `ch01`
    项目选择 Python 解释器的过程：
- en: '![Figure 11.2 – Choosing the Python interpreter'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – 选择 Python 解释器'
- en: '](img/Figure_11.02_B17975.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.02_B17975.jpg)'
- en: Figure 11.2 – Choosing the Python interpreter
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 选择 Python 解释器
- en: 'The select command will open a pop-up Windows *File Explorer* window to search
    for the appropriate virtual environment with the Python interpreter, as shown
    in *Figure 11.3*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 选择命令将会打开一个弹出窗口 *文件资源管理器*，用于搜索带有 Python 解释器的适当虚拟环境，如图 *图 11.3* 所示：
- en: '![Figure 11.3 – Searching for the virtual environment'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – 搜索虚拟环境'
- en: '](img/Figure_11.03_B17975.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.03_B17975.jpg)'
- en: Figure 11.3 – Searching for the virtual environment
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 搜索虚拟环境
- en: 'Opening a *Terminal console* for the project will automatically activate the
    virtual environment by running the `/Scripts/activate.bat` command for the Windows
    operating system. Additionally, this `activate.bat` script can be manually run
    if the automated activation was not successful. By the way, the activation will
    not be feasible with the Powershell terminal, but only with the command console,
    as shown in *Figure 11.4*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目打开 *终端控制台* 将会自动通过运行 Windows 操作系统的 `/Scripts/activate.bat` 命令来激活虚拟环境。此外，如果自动激活不成功，可以手动运行此
    `activate.bat` 脚本。顺便说一句，使用 Powershell 终端无法激活，但只能使用命令控制台，如图 *图 11.4* 所示：
- en: '![Figure 11.4 – Activating the virtual environment'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4 – 激活虚拟环境'
- en: '](img/Figure_11.04_B17975.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.04_B17975.jpg)'
- en: Figure 11.4 – Activating the virtual environment
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 激活虚拟环境
- en: After activation, we can determine the name of the activated virtual environment
    from the leftmost part of the command line. *Figure 11.4* shows that the Python
    interpreter of `ch11-env` is the chosen interpreter for the project. Anything
    installed by its `pip` command will only be available within that instance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 激活后，我们可以从命令行的最左侧确定已激活的虚拟环境名称。*图 11.4* 显示 `ch11-env` 的 Python 解释器是项目选择的解释器。通过其
    `pip` 命令安装的任何内容都只在该实例中可用。
- en: 'Each of our projects has a virtual environment, thus having multiple virtual
    environments containing different set of installed module dependencies, as shown
    in *Figure 11.5*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个项目都有一个虚拟环境，因此拥有多个包含不同已安装模块依赖关系的虚拟环境，如图 *图 11.5* 所示：
- en: '![Figure 11.5 – Creating multiple virtual environments'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.5 – 创建多个虚拟环境'
- en: '](img/Figure_11.05_B17975.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.05_B17975.jpg)'
- en: Figure 11.5 – Creating multiple virtual environments
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 创建多个虚拟环境
- en: Setting up the virtual environment is only one of the best practices when it
    comes to initiating a Python microservice application. Aside from localizing the
    module installation, it helps prepare the deployment of the application in terms
    of identifying what modules to install in the cloud servers. However, before we
    discuss FastAPI deployment approaches, first, let us discuss what microservice
    utilities to include before deploying a project, such as **Prometheus**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 Python 微服务应用程序时，设置虚拟环境只是最佳实践之一。除了本地化模块安装外，它还有助于准备应用程序的部署，例如确定在云服务器上安装哪些模块。然而，在我们讨论
    FastAPI 部署方法之前，首先让我们讨论在部署项目之前应包含哪些微服务工具，例如 **Prometheus**。
- en: Checking the API properties
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 API 属性
- en: '**Prometheus** is a popular monitoring total that can monitor and check API
    services in any microservice application. It can check the number of concurrent
    request transactions, the number of responses at a certain period, and the total
    incoming requests of an endpoint. To apply Prometheus to FastAPI applications,
    first, we need to install the following module:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prometheus** 是一个流行的监控工具，可以监控和检查任何微服务应用程序中的 API 服务。它可以检查并发请求事务的数量、一定时期内的响应数量以及端点的总请求量。要将
    Prometheus 应用于 FastAPI 应用程序，首先，我们需要安装以下模块：'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we add `PrometheusMiddleware` to the application and enable its endpoint
    to observe the API’s properties at runtime. The following script shows the application
    setup with the Prometheus monitoring module:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `PrometheusMiddleware` 添加到应用程序中，并启用其端点以在运行时观察 API 的属性。以下脚本显示了使用 Prometheus
    监控模块的应用程序设置：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we add `PrometheusMiddleware` using the `add_middleware()` method of
    FastAPI. Then, we add an arbitrary URI pattern to the `handle_metrics()` utility
    to expose all of the API health details. Accessing `http://localhost:8000/metrics`
    will provide us with something as shown in *Figure 11.6*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 FastAPI 的 `add_middleware()` 方法添加 `PrometheusMiddleware`。然后，我们将一个任意的
    URI 模式添加到 `handle_metrics()` 工具中，以公开所有 API 健康细节。访问 `http://localhost:8000/metrics`
    将提供如图 *Figure 11.6* 所示的内容：
- en: '![Figure 11.6 – Monitoring the endpoints'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.6 – 监控端点'
- en: '](img/Figure_11.06_B17975.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.06_B17975.jpg](img/Figure_11.06_B17975.jpg)'
- en: Figure 11.6 – Monitoring the endpoints
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.6 – 监控端点
- en: The data in *Figure 11.6* displays the time duration, in seconds, used by each
    API in processing requests, providing response to clients, and emitting the status
    code of each API transaction. Additionally, it includes some buckets that are
    built-in values used by the tool to create histograms. Aside from the histogram,
    Prometheus also allows the customization of some metrics inherent to a particular
    application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 11.6* 中的数据显示了每个 API 在处理请求、向客户端提供响应和发出每个 API 事务状态码时所用的时间长度（以秒为单位）。此外，它还包括一些内置值，这些值由工具用于创建直方图。除了直方图之外，Prometheus
    还允许自定义特定应用程序的一些固有指标。'
- en: Another way of monitoring a FastAPI microservice application is by adding an
    open tracing tool.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 监控 FastAPI 微服务应用程序的另一种方式是通过添加一个开放跟踪工具。
- en: Implementing open tracing mechanisms
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现开放跟踪机制
- en: When monitoring multiple, independent, and distributed microservices, the *OpenTracing*
    mechanism is preferred when managing API logs and traces. Tools such as *Zipkin*,
    *Jaeger*, and *Skywalking* are popular distributed tracing systems that can provide
    the setup for trace and log collections. In this prototype, we will be using the
    Jaeger tool to manage the application’s API traces and logs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当监控多个独立且分布式的微服务时，在管理 API 日志和跟踪时，*OpenTracing* 机制是首选。如 *Zipkin*、*Jaeger* 和 *Skywalking*
    这样的工具是流行的分布式跟踪系统，可以提供跟踪和日志收集的设置。在这个原型中，我们将使用 Jaeger 工具来管理应用程序的 API 跟踪和日志。
- en: 'The current way to integrate an OpenTracing tool into FastAPI microservices
    is through the *OpenTelemetry* modules since the *Opentracing for Python* extension
    is already a deprecated module. To use Jaeger as the tracing service, OpenTelemetry
    has an *OpenTelemetry Jaeger Thrift Exporter* utility, which allows you to export
    traces to the Jaeger client applications. This exporter utility sends these traces
    to the configured agent using the Thrift compact protocol over UDP. But first,
    we need to install the following extension to utilize this exporter:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将 OpenTracing 工具集成到 FastAPI 微服务中的当前方式是通过 *OpenTelemetry* 模块，因为 *Opentracing
    for Python* 扩展已经是一个已弃用的模块。要使用 Jaeger 作为跟踪服务，OpenTelemetry 提供了一个 *OpenTelemetry
    Jaeger Thrift Exporter* 工具，它允许您将跟踪导出到 Jaeger 客户端应用程序。此导出工具使用 Thrift 压缩协议通过 UDP
    将这些跟踪发送到配置的代理。但首先，我们需要安装以下扩展来利用此导出工具：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Afterward, add the following configuration to the `main.py` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将以下配置添加到 `main.py` 文件中：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first step in the preceding setup is to create a tracing service with a
    name using OpenTelemetry’s `Resource` class. Then, we instantiate a tracer from
    the service resource. To complete the setup, we need to provide the tracer with
    `BatchSpanProcessor` instantiated through the `JaegerExporter` details to manage
    all of the traces and logs using a Jaeger client. A *trace* includes full-detailed
    information about the exchange of requests and responses among all API services
    and other components across the distributed setup. This is unlike a *log*, which
    only contains the details regarding a transaction within an application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述设置中的第一步是使用 OpenTelemetry 的 `Resource` 类创建一个具有名称的跟踪服务。然后，我们从服务资源实例化一个跟踪器。为了完成设置，我们需要向跟踪器提供通过
    `JaegerExporter` 详细信息实例化的 `BatchSpanProcessor`，以使用 Jaeger 客户端管理所有痕迹和日志。一个 *痕迹*
    包含关于所有 API 服务和其他组件之间请求和响应交换的完整详细信息。这与 *日志* 不同，它只包含关于应用程序内事务的详细信息。
- en: 'After the completed Jaeger tracer setup, we integrate the `tracer` client with
    FastAPI through `FastAPIInstrumentor`. To utilize this class, first, we need to
    install the following extension:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成 Jaeger 跟踪器设置后，我们通过 `FastAPIInstrumentor` 将 `tracer` 客户端与 FastAPI 集成。为了使用这个类，首先，我们需要安装以下扩展：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before we can run our application, first, we need to download a Jaeger client
    from `https://www.jaegertracing.io/download/`, unzip the `jaeger-xxxx-windows-amd64.tar.gz`
    file, and run `jaeger-all-in-one.exe`. Installers for Linux and macOS are also
    available.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以运行我们的应用程序之前，首先，我们需要从 `https://www.jaegertracing.io/download/` 下载一个 Jaeger
    客户端，解压缩 `jaeger-xxxx-windows-amd64.tar.gz` 文件，并运行 `jaeger-all-in-one.exe`。Linux
    和 macOS 的安装程序也都可以使用。
- en: 'Now, open a browser and access the Jaeger client through the default `http://localhost:16686`.
    *Figure 11.7* shows a snapshot of the tracer client:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开浏览器并通过默认的 `http://localhost:16686` 访问 Jaeger 客户端。*图 11.7* 展示了跟踪器客户端的快照：
- en: '![Figure 11.7 – Monitoring microservices through a Jaeger client'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.7 – 通过 Jaeger 客户端监控微服务'
- en: '](img/Figure_11.07_B17975.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.07_B17975.jpg)'
- en: Figure 11.7 – Monitoring microservices through a Jaeger client
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 通过 Jaeger 客户端监控微服务
- en: 'After some browser reloads, the Jaeger app will detect our tracer through its
    service name, `online-sports-tracer`, after running our microservice application.
    All accessed API endpoints are detected and monitored, thus creating traces and
    visual analyses regarding all requests and response transactions incurred by these
    endpoints. *Figure 11.8* shows the traces and graphical plots generated by Jaeger:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些浏览器刷新后，Jaeger 应用程序将在运行我们的微服务应用程序后通过其服务名称 `online-sports-tracer` 检测到我们的跟踪器。所有访问的
    API 端点都会被检测和监控，从而创建所有这些端点产生的请求和响应事务的痕迹和可视化分析。*图 11.8* 展示了 Jaeger 生成的痕迹和图形图表：
- en: '![Figure 11.8 – Searching the traces of every API transaction'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.8 – 搜索每个 API 事务的痕迹'
- en: '](img/Figure_11.08_B17975.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.08_B17975.jpg)'
- en: Figure 11.8 – Searching the traces of every API transaction
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 搜索每个 API 事务的痕迹
- en: 'A span in OpenTelemetry is equivalent to a trace with a unique *ID*, and we
    can scrutinize each span to view all the details by clicking on the search traces
    for every endpoint. Clicking on the searched trace for the `/ch11/login/list/all`
    endpoint, as shown in *Figure 11.8*, can provide us with the following trace details:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenTelemetry 中，一个跨度相当于一个具有唯一 *ID* 的 *痕迹*，我们可以通过点击每个端点的搜索痕迹来检查每个跨度以查看所有细节。点击如
    *图 11.8* 所示的 `/ch11/login/list/all` 端点的搜索痕迹，可以提供以下痕迹细节：
- en: '![Figure 11.9 – Scrutinizing the trace details of an endpoint'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.9 – 检查端点的痕迹细节'
- en: '](img/Figure_11.09_B17975.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.09_B17975.jpg)'
- en: Figure 11.9 – Scrutinizing the trace details of an endpoint
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 检查端点的痕迹细节
- en: Aside from the traces shown in *Figure 11.9*, the Jaeger client can also collect
    the *uvicorn logs* through an OpenTelemetry module called `opentelemetry-instrumentation-logging`.
    After installing the module, we can enable the integration by instantiating `LoggingInstrumentor`
    in the `main.py` file, as shown in the previous code snippet.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 *图 11.9* 中显示的痕迹外，Jaeger 客户端还可以通过名为 `opentelemetry-instrumentation-logging`
    的 OpenTelemetry 模块收集 *uvicorn 日志*。在安装模块后，我们可以在 `main.py` 文件中实例化 `LoggingInstrumentor`
    以启用集成，如前代码片段所示。
- en: Now, let us add the *service registry* and *client-side service discovery* mechanisms
    to our application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向我们的应用程序添加 *服务注册* 和 *客户端服务发现* 机制。
- en: Setting up service registry and client-side service discovery
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置服务注册和客户端服务发现
- en: A service registry tool such as *Netflix Eureka* enables the registration of
    microservice applications without knowing the exact DNS locations of their servers.
    It manages all access to these registered services using a load-balancing algorithm
    and dynamically assigns these service instances with network locations. This service
    registration is helpful to microservice applications deployed to servers with
    changing DNS names due to failures, upgrades, and enhancements.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册工具如*Netflix Eureka*允许在不知道其服务器确切DNS位置的情况下注册微服务应用程序。它使用负载均衡算法管理对所有已注册服务的访问，并动态地为这些服务实例分配网络位置。这种服务注册对于部署在DNS名称因故障、升级和增强而变化的服务器上的微服务应用程序非常有用。
- en: For the service registry to work, the service instances should have a mechanism
    to discover the registry server before the server registration. For FastAPI, we
    need to utilize the `py_eureka_client` module to implement the service discovery
    design pattern.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使服务注册能够工作，服务实例应该在服务器注册之前有一个机制来发现注册服务器。对于FastAPI，我们需要利用`py_eureka_client`模块来实现服务发现设计模式。
- en: Implementing client-side service discovery
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现客户端服务发现
- en: 'Creating a FastAPI microservice application to discover and register to a service
    registry server such as *Netflix Eureka* is straightforward. First, we need to
    install `py_eureka_client` through `pip`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于发现和注册到服务注册服务器（如*Netflix Eureka*）的FastAPI微服务应用程序是直接的。首先，我们需要通过`pip`安装`py_eureka_client`：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we instantiate its `EurekaClient` component class with the correct `eureka_server`,
    `app_name`, `instance_port`, and `instance_host` parameter details. The `eureka_server`
    parameter must be the exact machine address of the Eureka server and not `localhost`.
    Additionally, the client instance must have the appropriate `app_name` parameter
    for the FastAPI microservice application (or client app), with the `instance_port`
    parameter set to `8000` and the `instance_host` to `192.XXX.XXX.XXX` (not `localhost`
    or `127.0.0.1`). The following snippet depicts the location in `main.py` in which
    to instantiate the `EurekaClient` component class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用正确的`eureka_server`、`app_name`、`instance_port`和`instance_host`参数细节实例化其`EurekaClient`组件类。`eureka_server`参数必须是Eureka服务器的确切机器地址，而不是`localhost`。此外，客户端实例必须具有适用于FastAPI微服务应用程序（或客户端应用程序）的适当`app_name`参数，`instance_port`参数设置为`8000`，`instance_host`设置为`192.XXX.XXX.XXX`（不是`localhost`或`127.0.0.1`）。以下代码片段显示了在`main.py`中实例化`EurekaClient`组件类的位置：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The client discovery happens in the `startup` event of the application. It starts
    with the instantiation of the `EurekaClient` component class and invoking its
    `start()` method either asynchronously or not. The `EurekaClient` component class
    can handle asynchronous or synchronous FastAPI startup events. To close the server
    discovery process, always invoke `Eurek` `a` `Client`’s `stop()` method in the
    `shutdown` event. Now, let us build our Netflix Eureka server registry before
    running and performing the client-side service discovery.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发现发生在应用程序的`startup`事件中。它从实例化`EurekaClient`组件类并调用其`start()`方法（异步或非异步）开始。`EurekaClient`组件类可以处理异步或同步的FastAPI启动事件。要关闭服务器发现过程，始终在`shutdown`事件中调用`EurekaClient`的`stop()`方法。现在，在运行和执行客户端服务发现之前，让我们构建我们的Netflix
    Eureka服务器注册。
- en: Setting up the Netflix Eureka service registry
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Netflix Eureka服务注册
- en: 'Let us utilize the Spring Boot platform to create our Eureka server. We can
    create an application through `https://start.spring.io/` or the *Spring STS IDE*,
    using either a Maven- or Gradle-driven application. Ours is a Maven application
    with `pom.xml` that has the following dependency for the Eureka Server setup:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用Spring Boot平台来创建我们的Eureka服务器。我们可以通过`https://start.spring.io/`或*Spring STS
    IDE*创建一个应用程序，使用由Maven或Gradle驱动的应用程序。我们的是一个Maven应用程序，具有`pom.xml`，其中包含以下依赖项用于Eureka服务器设置：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, `application.properties` must have `server.port` set to `8761`,
    `server.shutdown` enabled for a `graceful` server shutdown, and a `spring.cloud.inetutils.timeout-seconds`
    property set to `10` for its hostname calculation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`application.properties`必须将`server.port`设置为`8761`，启用`server.shutdown`以实现`graceful`服务器关闭，并将`spring.cloud.inetutils.timeout-seconds`属性设置为`10`以进行主机名计算。
- en: 'Now, run the Eureka Server application before the FastAPI client application.
    The Eureka server’s logs will show us the automatic detection and registration
    of FastAPI’s `EurekaClient`, as shown in *Figure 11.10*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在运行FastAPI客户端应用程序之前运行Eureka服务器应用程序。Eureka服务器的日志将显示FastAPI的`EurekaClient`的自动检测和注册，如图*11.10*所示：
- en: '![Figure 11.10 – Discovering the FastAPI microservice application'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.10 – 发现FastAPI微服务应用'
- en: '](img/Figure_11.10_B17975.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.10_B17975.jpg)'
- en: Figure 11.10 – Discovering the FastAPI microservice application
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 发现FastAPI微服务应用
- en: 'The result of the client-side service discovery is also evident on the Eureka
    server’s dashboard at `http://localhost:8761`. The page will show us all the services
    that consist of the registry and through which we can access and test each service.
    *Figure 11.11* shows a sample snapshot of the dashboard:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端服务发现的成果在Eureka服务器的仪表板`http://localhost:8761`上也很明显。页面将显示所有包含注册表的服务，我们可以通过这些服务访问和测试每个服务。*图11.11*显示了仪表板的示例快照：
- en: '![Figure 11.11 – Creating the service registry'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.11 – 创建服务注册表'
- en: '](img/Figure_11.11_B17975.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.11_B17975.jpg)'
- en: Figure 11.11 – Creating the service registry
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 创建服务注册表
- en: Our **SPORTS_SERVICE** being part of the Eureka server registry, as depicted
    in *Figure 11.11*, means we successfully implemented the *client-side service
    discovery design pattern*, and it is time to deploy our application to a Docker
    container.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图11.11*所示，我们的**SPORTS_SERVICE**作为Eureka服务器注册表的一部分，意味着我们成功实现了*客户端服务发现设计模式*，现在是时候将我们的应用程序部署到Docker容器中。
- en: Deploying and running applications using Docker
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker部署和运行应用程序
- en: '*Dockerization* is a process of packaging, deploying, and running applications
    using Docker containers. Containerizing FastAPI microservices saves installation
    and setup time, space, and resources. And containerized apps are replaceable,
    replicable, efficient, and scalable compared to the usual deployment packaging.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*Docker化*是一个使用Docker容器打包、部署和运行应用程序的过程。将FastAPI微服务容器化可以节省安装和设置时间、空间和资源。与传统的部署打包相比，容器化应用程序具有可替换性、可复制性、高效性和可扩展性。'
- en: To pursue Dockerization, we need to install *Docker Hub* and/or *Docker Engine*
    for the CLI commands. But be aware of the new Docker Desktop License Agreement
    ([https://www.docker.com/legal/docker-software-end-user-license-agreement/](https://www.docker.com/legal/docker-software-end-user-license-agreement/))
    regarding its new subscription model. This chapter mainly focuses on how to run
    CLI commands rather than the Docker Hub GUI tool. Now, let us generate the list
    of modules to be installed in the docker image.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了追求Docker化，我们需要安装*Docker Hub*和/或*Docker Engine*以使用CLI命令。但请注意关于其新订阅模式的新Docker
    Desktop许可协议([https://www.docker.com/legal/docker-software-end-user-license-agreement/](https://www.docker.com/legal/docker-software-end-user-license-agreement/))。本章主要关注如何运行CLI命令，而不是Docker
    Hub的GUI工具。现在，让我们生成要安装到docker镜像中的模块列表。
- en: Generating the requirements.txt file
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成requirements.txt文件
- en: 'Since we are using a virtual environment instance for module management, it
    is easy to identify what extension modules to install in the Docker image. We
    can run the following command to generate a complete list of modules and their
    versions to the `requirements.txt` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用虚拟环境实例进行模块管理，因此很容易确定在Docker镜像中要安装哪些扩展模块。我们可以运行以下命令将模块及其版本完整列表生成到`requirements.txt`文件中：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, we can create a command to copy this file to the image through the `Dockerfile`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个命令通过`Dockerfile`将此文件复制到镜像中。
- en: Creating the Docker image
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Docker镜像
- en: 'The next step is to build a container image from any available Linux-based
    container images in *Docker Hub*. But we need a `Dockerfile` containing all the
    commands associated with pulling an available Python image from Docker Hub, creating
    a working directory, and copying project files from the local directory. The following
    is a `Dockerfile` set of instructions we use to deploy our prototype to a Python
    image:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从*Docker Hub*中任何可用的基于Linux的容器镜像构建容器镜像。但我们需要一个包含所有与从Docker Hub拉取可用Python镜像、创建工作目录和从本地目录复制项目文件相关的命令的`Dockerfile`。以下是我们用于将原型部署到Python镜像的`Dockerfile`指令集：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first line is an instruction that will derive a Python image, usually Linux-based,
    with an installed Python 3.9 interpreter. The command after that creates an arbitrary
    folder, `/code`, which will become the application’s main folder. The `COPY` command
    copies our `requirements.txt` file to the `/code` folder, and then the `RUN` instruction
    installs the updated modules from the `requirements.txt` list using the following
    command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个指令，它将导出一个安装了Python 3.9解释器的Python镜像，通常是基于Linux的。之后的命令创建了一个任意文件夹`/code`，它将成为应用程序的主要文件夹。`COPY`命令将我们的`requirements.txt`文件复制到`/code`文件夹，然后`RUN`指令使用以下命令从`requirements.txt`列表中安装更新的模块：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Afterward, the second `COPY` command copies our `ch11` application to the working
    directory. The `EXPOSE` command binds port `8000` to the local machine’s port
    `8000` to run the `CMD` command, which is the last instruction of the `Dockerfile`.
    The `CMD` instruction uses *uvicorn* to run the application at port `8000` using
    host `0.0.0.0` and not `localhost` to automatically map and utilize the IP address
    assigned to the image.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，第二个 `COPY` 命令将我们的 `ch11` 应用程序复制到工作目录。`EXPOSE` 命令将端口 `8000` 绑定到本地机器的端口 `8000`
    以运行 `CMD` 命令，这是 `Dockerfile` 的最后一条指令。`CMD` 指令使用 *uvicorn* 在端口 `8000` 上使用主机 `0.0.0.0`
    运行应用程序，而不是 `localhost` 以自动映射并利用分配给镜像的 IP 地址。
- en: 'The `Dockerfile` must be in the same folder as the `requirements.txt` file
    and the `ch11` application. *Figure 11.12* shows the organization of the files
    and folders that needed to be Dockerized to a Python container image:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 必须与 `requirements.txt` 文件和 `ch11` 应用程序在同一文件夹中。*图 11.12* 展示了需要将文件和文件夹
    Docker 化到 Python 容器镜像中的组织结构：'
- en: '![Figure 11.12 – Setting up the Docker folder structure'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.12 – 设置 Docker 文件夹结构'
- en: '](img/Figure_11.12_B17975.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.12_B17975.jpg)'
- en: Figure 11.12 – Setting up the Docker folder structure
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 设置 Docker 文件夹结构
- en: 'Once all the files and folders are complete, we run the following CLI command
    within the folder using the terminal console:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有文件和文件夹都准备好了，我们就在终端控制台使用以下 CLI 命令在该文件夹内运行：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To check the image, run the `docker image ls` CLI command.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查镜像，运行 `docker image ls` CLI 命令。
- en: Using the Mongo Docker image
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Mongo Docker 镜像
- en: 'The backend of our application is MongoDB, so we need to pull the latest `mongo`
    image from Docker Hub using the following CLI command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的后端是 MongoDB，因此我们需要使用以下 CLI 命令从 Docker Hub 拉取最新的 `mongo` 镜像：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And before we run both the `ch11-app` application and the `mongo:latest` images,
    first, we need to create a `ch11-network` by running the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行 `ch11-app` 应用程序和 `mongo:latest` 镜像之前，首先需要通过运行以下命令创建一个 `ch11-network`：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This network becomes a bridge between `mongo` and `ch11-app` once they are deployed
    as containers. It will establish the connectivity between the two containers to
    pursue the *Motor-ODM* transactions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它们作为容器部署，这个网络就成为了 `mongo` 和 `ch11-app` 之间的桥梁。它将建立两个容器之间的连接，以追求 *Motor-ODM*
    事务。
- en: Creating the containers
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建容器
- en: 'A `docker run` command to start and run a pulled or created image. So, running
    the Mongo image using the `ch11-network` routes requires the execution of the
    following CLI command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `docker run` 命令用于启动和运行已拉取或创建的镜像。因此，使用 `ch11-network` 路由运行 Mongo 镜像需要执行以下
    CLI 命令：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Inspect the `mongo:latest` container using the `docker inspect` command to derive
    and use its IP address for Motor-ODM’s connectivity. Replace the `localhost` used
    in `AsyncIOMotorClient`, which is found in the `config/db.py` module of `ch11-app`
    with the “inspected” IP address. Be sure to re-build the `ch11-app` Docker image
    after the update.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker inspect` 命令检查 `mongo:latest` 容器，以获取并使用其 IP 地址为 Motor-ODM 的连接性。将 `AsyncIOMotorClient`
    中使用的 `localhost` 替换为“检查到的”IP地址，该地址位于 `ch11-app` 的 `config/db.py` 模块中。更新后，务必重新构建
    `ch11-app` Docker 镜像。
- en: 'Now, run the `ch11-app` image with `ch11-network` using the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令运行 `ch11-app` 镜像，并使用 `ch11-network`：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Access the application through `http://localhost:8000/docs` to check all the
    API endpoints from the OpenAPI documentation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `http://localhost:8000/docs` 访问应用程序，以检查 OpenAPI 文档中的所有 API 端点。
- en: Now, another approach to simplifying containerization is to use the *Docker
    Compose* tool.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，另一种简化容器化的方法是使用 *Docker Compose* 工具。
- en: Using Docker Compose for deployment
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 进行部署
- en: 'However, you need to install the Docker Compose utility in your operating system,
    which requires Docker Engine as the pre-installation requirement. After the installation,
    the next step is to create the `docker-decompose.yaml` file containing all the
    services needed to build the images, process the Dockerfile, build the Docker
    network, and create and run the containers. The following snippet shows the content
    of our configuration file that sets up the `mongo` and `ch11-app` containers:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您需要在操作系统上安装 Docker Compose 工具，这需要 Docker 引擎作为预安装要求。安装后，下一步是创建包含构建镜像、处理 Dockerfile、构建
    Docker 网络以及创建和运行容器的所有所需服务的 `docker-decompose.yaml` 文件。以下片段显示了我们的配置文件内容，该文件设置了
    `mongo` 和 `ch11-app` 容器：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Instead of running separate Docker CLI commands, Docker Compose creates services,
    such as `ch11-mongo` and `ch11-app`, to manage the containerization and only uses
    one CLI command to execute these services, `docker-compose up`. The command not
    only creates the network of images but also runs all the containers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会运行单独的 Docker CLI 命令，Docker Compose 创建服务，如 `ch11-mongo` 和 `ch11-app`，以管理容器化，并且只使用一个
    CLI 命令来执行这些服务，即 `docker-compose up`。该命令不仅创建图像网络，还运行所有容器。
- en: 'One advantage of using Docker Compose is the ease of ORM and ODM configuration.
    Instead of performing a container inspection to understand which IP address to
    use, we can use the *service name of the database setup* as the hostname to establish
    database connectivity. It is convenient since the IP address of the `mongo` container
    varies for every instance created. The following is the new `AsyncIOMotorClient`
    with the `ch11-mongo` service as the hostname:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 的一个优点是 ORM 和 ODM 配置的简便性。我们不需要执行容器检查来了解使用哪个 IP 地址，我们可以使用数据库设置的
    *服务名称* 作为主机名来建立数据库连接。这很方便，因为每个创建的 `mongo` 容器的 IP 地址都不同。以下是将 `ch11-mongo` 服务作为主机名的新
    `AsyncIOMotorClient`：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let us implement an API Gateway design pattern for the containerized applications
    using the *NGINX* utility.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 *NGINX* 工具为容器化应用程序实现 API 网关设计模式。
- en: Using NGINX as an API Gateway
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NGINX 作为 API 网关
- en: In [*Chapter 4*](B17975_04.xhtml#_idTextAnchor080)*, Building the Microservice
    Application*, we implemented the API Gateway design pattern using only some FastAPI
    components. In this last chapter, we will build a *reverse proxy server* through
    NGINX that will assign a proxy IP address to each containerized microservice application.
    These proxy IPs will redirect client requests to the actual microservices running
    on their respective containers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B17975_04.xhtml#_idTextAnchor080)*，构建微服务应用程序* 中，我们仅使用一些 FastAPI
    组件实现了 API 网关设计模式。在本章的最后，我们将通过 NGINX 建立一个 *反向代理服务器*，将为每个容器化的微服务应用程序分配一个代理 IP 地址。这些代理
    IP 将将客户端请求重定向到各自容器上运行的相应微服务。
- en: 'Instead of building an actual NGINX environment, we will be pulling an available
    NGINX image from Docker Hub to implement the reverse proxy server. This image
    creation requires a new Docker app folder with a different `Dockerfile` containing
    the following instructions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会构建实际的 NGINX 环境，而是从 Docker Hub 拉取可用的 NGINX 镜像来实现反向代理服务器。此镜像创建需要一个包含以下指令的新
    Docker 应用程序文件夹和不同的 `Dockerfile`：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Dockerfile` instructs the creation of the latest *NGINX* image and a copy
    of a `nginx_config.conf` file to that image. The file is an *NGINX configuration
    file* that contains the mapping of a proxy IP address to the actual container
    address of each microservice application. It also exposes `8080` as its official
    port. The following is the content of our `nginx_config.conf` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 指示创建最新的 *NGINX* 镜像，并将 `nginx_config.conf` 文件复制到该镜像中。该文件是一个 *NGINX
    配置文件*，其中包含将代理 IP 地址映射到每个微服务应用程序的实际容器地址的映射。它还公开 `8080` 作为其官方端口。以下是我们 `nginx_config.conf`
    文件的内容：'
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The application’s OpenAPI documentation can now be accessed through `http://localhost:8080/docs`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的 OpenAPI 文档现在可以通过 `http://localhost:8080/docs` 访问。
- en: The Dockerization of NGINX must come after deploying applications to the containers.
    But another approach is to include NGINX’s `Dockerfile` instructions in the application’s
    `Dockerfile` to save time and effort. Or we can create another service in the
    `docker-decompose.yaml` file to build and run the NGINX image.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 的 Docker 化必须在将应用程序部署到容器之后进行。但另一种方法是将在应用程序的 `Dockerfile` 中包含 NGINX 的 `Dockerfile`
    指令，以节省时间和精力。或者我们可以在 `docker-decompose.yaml` 文件中创建另一个服务来构建和运行 NGINX 镜像。
- en: And for the last time, let us explore the power of FastAPI in its integration
    with other popular Python frameworks such as *Flask* and *Django*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次，让我们探索 FastAPI 与其他流行的 Python 框架（如 *Flask* 和 *Django*）集成的强大功能。
- en: Integrating Flask and Django sub-applications
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 Flask 和 Django 子应用程序
- en: '*Flask* is a lightweight framework that is popular for its *Jinja2* templates
    and *WSGI* server. On the other hand, *Django* is a Python framework that promotes
    rapid development using CLI commands and applies the scaffolding of files and
    folders to build projects and applications. Django applications can run on either
    WSGI- or ASGI-based servers.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flask* 是一个轻量级框架，因其 *Jinja2* 模板和 *WSGI* 服务器而受到欢迎。另一方面，*Django* 是一个 Python 框架，它通过
    CLI 命令促进快速开发，并将文件和文件夹的脚手架应用于构建项目和应用程序。Django 应用程序可以在基于 WSGI 或 ASGI 的服务器上运行。'
- en: We can create, deploy, and run Flask and Django projects inside a FastAPI microservice
    application. The framework has `WSGIMiddleware` to wrap both Flask and Django
    applications and integrate them into the FastAPI platform. Running the FastAPI
    application through *uvicorn* will also run both applications.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the two, it is easier to integrate the Flask application with a project
    than Django. We only need to import the Flask `app` object into the `main.py`
    file, wrap it with `WSGIMiddleware`, and mount it into the FastAPI `app` object.
    The following script shows the part of `main.py` that integrates our `ch11_flask`
    project:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All API endpoints implemented in `ch11_flask` will be accessed using the URL
    prefix, `/ch11/flask`, as indicated in the `mount()` method. *Figure 11.13* shows
    the location of `ch11_flask` inside the `ch11` project:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Creating a Flask application inside the FastAPI project'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.13_B17975.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.13 – Creating a Flask application inside the FastAPI project
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the following `main.py` script integrates our `ch11_django`
    application into the `ch11` project:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The Django framework has a `get_wsgi_application()` method that is uses to retrieve
    its `app` instance. This instance needs to be wrapped by `WSGIMiddleware` and
    mounted into the FastAPI `app` object. Moreover, we need to load the `settings.py`
    module of the `ch11_django` project into the FastAPI platform for global access.
    Also, we need to mount all the static files of the `django.contrib.main` module,
    which includes some HTML templates of the Django *security module*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'All views and endpoints created by the `sports` application of the `ch11_django`
    project must be accessed using the `/ch11/django` URL prefix. *Figure 11.14* shows
    the placement of the `ch11_django` project within the ch11 app:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Creating a Django project and application inside a FastAPI
    object'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.14_B17975.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.14 – Creating a Django project and application inside a FastAPI object
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last chapter has given us the avenue on how to start, deploy, and run a
    FastAPI microservice application that follows the standards and best practices.
    It introduces the use of a virtual environment instance to control and manage
    the installation of modules from the start of the development until the deployment
    of our applications to Docker containers. The chapter has extensively explained
    the approaches on how to package, deploy, and run containerized applications.
    And lastly, the chapter has implemented an NGINX reverse proxy server for the
    application to build the API Gateway for our specimen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Right from the start, we have witnessed the simplicity, power, adaptability,
    and scalability of the FastAPI framework, from creating background processes to
    rendering data using HTML templates. Its fast execution of API endpoints through
    its coroutines gives the framework the edge to become one of the most popular
    Python frameworks in the future. As the community of FastAPI continues to grow,
    we hope for more promising features in its future updates, such as support for
    reactive programming, circuit breakers, and a signature security module. We're
    hoping for the best for the FastAPI framework!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们就见证了 FastAPI 框架的简洁性、强大、适应性和可扩展性，从创建后台进程到使用 HTML 模板渲染数据。它通过协程快速执行 API
    端点，使该框架在未来有望成为最受欢迎的 Python 框架之一。随着 FastAPI 社区的持续增长，我们期待其在未来的更新中带来更多有前景的功能，例如支持响应式编程、断路器和签名安全模块。我们对
    FastAPI 框架充满期待！
