<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Database Abstraction Layer</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem"><p>Creating a new model</p></li><li class="listitem"><p>Creating a model from a csv file</p></li><li class="listitem"><p>Batch upload of your data</p></li><li class="listitem"><p>Moving your data from one database to another</p></li><li class="listitem"><p>Creating a model from existing MySQL and PostgreSQL databases</p></li><li class="listitem"><p>Efficiently searching by tag</p></li><li class="listitem"><p>Accessing your database from multiple applications</p></li><li class="listitem"><p>Hierarchical category tree</p></li><li class="listitem"><p>Creating records on demand</p></li><li class="listitem"><p>OR, LIKE, BELONGS, and more on Google App Engine</p></li><li class="listitem"><p>Replacing slow virtual fields with DB views</p></li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec01"/>Introduction</h1></div></div></div><p>The<strong> Database Abstraction Layer (DAL)</strong>  is probably the major strength of web2py. The DAL exposes a simple<strong> Applications Programming Interface (API)</strong>  to the underlying SQL syntax, and this may hide its true power. In the recipes of this chapter, we provide examples of non-trivial applications of the DAL, such as building queries to search by tags efficiently and building a hierarchical category tree.<a id="id106" class="indexterm"/>
</p></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec02"/>Creating a new model</h1></div></div></div><p>As shown in the recipes in the previous chapter, most applications require a database, and building the database model is the first step in the design of the application.<a id="id107" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec01"/>Getting ready</h2></div></div></div><p>Here we assume that you have a newly created application, and you will be putting the models in a file called<code class="literal"> models/db_custom.py</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec02"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>First of all, you need a database connection. This is created by the DAL object. For example:</p><div><pre class="programlisting">db = DAL('sqlite://storage.sqlite')
</pre></div><p>Notice that this line is already in the file <code class="literal">models/db.py</code>, and therefore you may not need it, unless you deleted it or need to connect to a different database. By default, web2py connects to an <code class="literal">sqlite</code> database stored in file storage.sqlite. This file is located in the application's databases folder. If the file is not there, it is created by web2py when the application is first executed.
<a id="id108" class="indexterm"/>
</p><p>SQLite is fast, and stores all data in one single file. This means that your data can be easily transferred from one application to another. In fact, the <code class="literal">sqlite</code> database(s) are packaged by web2py together with the applications. It provides full SQL support, including translations, joins, and aggregates. Moreover SQLite comes standard with Python 2.5 and later, and therefore, it is already available to your web2py installation.
</p><p>There are two disadvantages of SQLite. One is that it does not enforce column types, and there is no <code class="literal">ALTER TABLE</code> except for adding and dropping columns. The other disadvantage is that the entire database is locked by any transaction that requires write access. Therefore, the database cannot be accessed concurrently except for reading.
</p><p>These features make it a good option for development purposes and low-traffic websites, but not a viable solution for high-traffic sites.
</p><p>In the following recipe, we will show you how to connect to a different type of database.
</p></li><li class="listitem"><p>Once we have a<code class="literal"> db</code> object, we can use the<code class="literal"> define_table</code> method to define new tables. For example:</p><div><pre class="programlisting">db.define_table('invoice',Field('name'))
</pre></div><p>The syntax is always the same. The first argument is the <strong>table name</strong>, and it is followed by a list of Field(s). The field constructor takes the following arguments:
</p><div><ul class="itemizedlist"><li class="listitem"><p>
<strong>The field name</strong>
</p></li><li class="listitem"><p>
<strong>The field type:</strong> This can take values having any of the following datatypes -<code class="literal"> string</code> (default),<code class="literal"> text, boolean, integer, double, password, date, time, datetime, upload, blob, reference other_table, list:string, list:integer</code>, and<code class="literal"> list:reference other_table</code>. Internally,<code class="literal"> upload, password</code>, and<code class="literal"> list</code> types are equivalent to<code class="literal"> string</code>, but at the web2py level, they are handled differently.</p></li><li class="listitem"><p>
<code class="literal">length=512:</code> This is the maximum length for string-based fields. It is ignored for non-text based fields.</p></li><li class="listitem"><p>
<code class="literal">default=None:</code> This is the default value when a new record is inserted. The value of this attribute can be a function that is called when a value is needed (for example, on record insert, if no value is specified).</p></li><li class="listitem"><p>
<code class="literal">update=None:</code> This works the same as default, but the value is used only on update, not on insert.</p></li><li class="listitem"><p>
<code class="literal">ondelete='CASCADE':</code> This maps onto the corresponding SQL<code class="literal"> ON DELETE</code> attribute.</p></li><li class="listitem"><p>
<code class="literal">notnull=False:</code> This specifies whether the field value can be<code class="literal"> NULL</code> or not (enforced at database level).</p></li><li class="listitem"><p>
<code class="literal">unique=False:</code> This specifies whether the field value must be unique or not (enforced at database level).</p></li><li class="listitem"><p>
<code class="literal">requires=[]:</code> This is a list of web2py validators (enforced at the level of web2py forms). Most field types have default validators.</p></li><li class="listitem"><p>
<code class="literal">required=False:</code> This is not to be confused with requires, and it tells web2py that a value for this field must be specified during insert and update. For a<code class="literal"> required</code> field, default and update values are ignored. Unless used together with<code class="literal"> notnull=True</code>, the<code class="literal"> None</code> value is an acceptable value, even if the field is required.</p></li><li class="listitem"><p>
<code class="literal">readable=True:</code> This specifies whether the field is readable in forms or not.</p></li><li class="listitem"><p>
<code class="literal">writable=True:</code> This specifies whether the field is writable in forms or not.</p></li><li class="listitem"><p>
<code class="literal">represent=(lambda value: value):</code> This is a function that is used to display the value of the field in forms and tables.</p></li><li class="listitem"><p>
<code class="literal">widget=SQLHTML.widgets.string.widget:</code> This is a function that will build the input widget in forms.</p></li><li class="listitem"><p>
<code class="literal">label="Field Name":</code> This is the label to be used for this field in forms.</p></li><li class="listitem"><p>
<code class="literal">comment="...":</code> This is a comment to be added to this field in forms.</p><p>The <code class="literal">Field</code> constructor has other attributes that are specific to upload type fields. See the web2py book for further information.
</p></li></ul></div></li><li class="listitem"><p>The<code class="literal"> define_table</code> method also takes three named arguments:</p><div><pre class="programlisting">
db.define_table('....',
	migrate=True,
	fake_migrate=False,
	format='%(id)s')
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">migrate=True:</code> This instructs web2py to create the table if it does not exist, or alter it if it does not match the model definition. This process is accompanied by the creation of metadata files. The metadata files have the form<code class="literal"> databases/&lt;hash&gt;_&lt;name&gt;.table</code>, and will be used to keep track of changes in the model, and perform automatic migrations. Set<code class="literal"> migrate=False</code> to disable automatic migrations.<a id="id109" class="indexterm"/>
</p></li><li class="listitem"><p>
<code class="literal">fake_migrate=False:</code> Sometimes the above metadata gets corrupt (or accidentally deleted), and needs to be re-created. If the model matches the database table content, then set<code class="literal"> fake_migrate=True</code>, and web2py will rebuild the metadata.</p></li><li class="listitem"><p>
<code class="literal">format='%(id)s':</code> This is a format string that determines how records of this table should be represented when referenced by another table in forms (for example in select dropboxes). The format can be a function that takes a row object that returns a string.</p></li></ul></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec03"/>There's more...</h2></div></div></div><p>In all databases, but SQLite and Google App Engine datastore, if you change a table definition, an<code class="literal"> ALTER TABLE</code> is issued to make sure the database matches the model. In SQLite, the<code class="literal"> ALTER TABLE</code> is only performed when a column is added or deleted, not when a field type changes (because SQLite does not enforce it). In Google App Engine datastore, there is no concept of<code class="literal"> ALTER TABLE</code>, and columns can be added but not deleted; web2py will ignore columns not listed in the model.</p><p>Completely removing a<code class="literal"> define_table</code> from the model does not result in a<code class="literal"> DROP TABLE</code>. The table simply becomes inaccessible to web2py until the corresponding<code class="literal"> define_table</code> is put back. This prevents accidental deletion of data. You can drop tables in web2py using the command<code class="literal"> db.&lt;name&gt;.drop()</code>.</p></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec03"/>Creating a model from a CSV file</h1></div></div></div><p>Consider the scenario in which you have a CSV file and you do not know much about it. Yet you want to create a web application to access the data in the CSV file.<a id="id110" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec04"/>Getting ready</h2></div></div></div><p>I will assume you have the csv file in a folder</p><p>
<code class="literal">/tmp/mydata.csv</code>
</p><p>You will also need a program called<code class="literal"> csvstudio</code>, which you can download from<a class="ulink" href="http://csvstudio.googlecode.com/hg/csvstudio.py"> http://csvstudio.googlecode.com/hg/csvstudio.py</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec05"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>This first step consists of looking at the csv file:</p><div><pre class="programlisting"><strong>python csvstudio.py -a &lt; /tmp/mydata.csv</strong>
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>If the file is not corrupt, and it is in a standard csv format, then csvstudio will generate a report listing the CSV columns, data types, and data ranges.
</p><p>If the file is in a non-standard CSV format, or is, for example, in XLS, try importing it in Excel, and save it again in CSV.
</p><p>You may also want to try using <strong>Google Refine</strong> to clean up the CSV file.
</p></li></ul></div></li><li class="listitem"><p>Once you know that<code class="literal"> csvstudio</code> can correctly read the file, run the following command:<a id="id111" class="indexterm"/>
</p><div><pre class="programlisting"><strong>python csvstudio.py -w mytable -i /tmp/mydata.csv &gt; db1.py</strong>
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>csvstudio creates a file called db1.py that contains a web2py model that is compatible with the data. mytable, here, is the name you choose to give to the table.
</p></li></ul></div></li><li class="listitem"><p>Move this file into your application's<code class="literal"> models</code> folder.</p></li><li class="listitem"><p>Now you need to clean up the data, so that you can import it in web2py.</p><div><pre class="programlisting"><strong>python csvstudio.py -f csv -i /tmp/mydata.csv -o /tmp/mydata2.csv</strong>	
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>The file, <code class="literal">mydata2.csv</code>, now contains the same data as the original file, but the column names have been cleaned up to be compatible with the generated model. The field values have been stripped of any leading and trailing spaces.
</p></li></ul></div></li><li class="listitem"><p>At this point, all you have to do is run your application and call<code class="literal"> appadmin</code>.</p><div><pre class="programlisting">http://.../app/appadmin
</pre></div></li><li class="listitem"><p>You should see the model you generated. Click on the model name, and you will see an upload link at the bottom. Upload the<code class="literal"> mydata2.csv</code> file to populate your table.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec06"/>There's more...</h2></div></div></div><p>If you prefer to upload the csv file from a shell instead of using the<code class="literal"> appadmin</code> interface, you can do so.</p><p>From insider the main web2py folder, run the following command:</p><div><pre class="programlisting"><strong>python web2py.py -S app -M -N</strong>
</pre></div><p>You will get a web2py shell (-S app opens the shell in the application context,<code class="literal"> -M</code> loads the models, and<code class="literal"> -N</code> prevents cron jobs from running).</p><p>From inside the shell do the following:</p><div><pre class="programlisting"><strong>
&gt;&gt;&gt; f = open('/tmp/mydata2.csv','rb')
&gt;&gt;&gt; db.mytable.import_from_csv_file(f)
&gt;&gt;&gt; db.commit()</strong>
</pre></div><p>Et voila, the data is in the database. When you use the shell do not forget to<code class="literal"> db.commit()</code>.</p><p>If for any reason this does not work (perhaps because the CSV file is non-standard, and there is no way to normalize it), try following our next recipe.<a id="id112" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec04"/>Batch upload of your data</h1></div></div></div><p>Here, we will assume you have data in a flat file of known<code class="literal"> structure</code>. You want to create a database model and import the data in the database.<a id="id113" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec07"/>Getting ready</h2></div></div></div><p>For same of the argument, we will assume the file is in /tmp/data.txt, and has the following structure:</p><div><pre class="programlisting">Clayton Troncoso|234523
Malinda Gustavson|524334
Penelope Sharpless|151555
Serena Ruggerio|234565
Lenore Marbury|234656
Amie Orduna|256456
Margery Koeppel|643124
Loraine Merkley|234555
Avis Bosserman|234523
...
Elinor Erion|212554
</pre></div><p>Each row is a record ending in<code class="literal"> \n</code>. The fields are separated by &amp;mdash;. The first column contains<code class="literal">&lt;first name&gt; &lt;last name&gt;</code>. The second column contains an annual salary value.</p><p>As usual, we will assume you have a new application called<code class="literal"> app</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec08"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>The first thing you do is create a model in your<code class="literal"> app</code> called<code class="literal"> models/db1.py</code> containing the following data:</p><div><pre class="programlisting">
db.define_table('employees',
	Field('first_name'),
	Field('last_name'),
	Field('salary','double'))
</pre></div></li><li class="listitem"><p>Then, you would write a script, for example:</p></li></ol></div><div><pre class="programlisting"><strong>applications/app/private/importer.py</strong>
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>This script can read the data, parse it, and put it into the db, as follows:
</p><div><pre class="programlisting">
for line in open('/tmp/data.txt','r'):
	fullname,salary = line.strip().split('|')
	first_name,last_name = fullname.split(' ')
	db.employees.insert(first_name=first_name,
		last_name=last_name,
		salary=float(salary))
db.commit()
</pre></div></li><li class="listitem"><p>Finally, from the web2py folder run the following script:</p></li></ul></div><div><pre class="programlisting"><strong>python web2py.py -S app -M -N -R applications/app/private/
importer.py</strong>
</pre></div><p>Notice that the importer is a Python script, but not a module (that is why we put it in the<code class="literal"> private</code> folder and not the<code class="literal"> modules</code> folder. It is executed in our application context, as if it were a controller. In fact, you can copy the code into a controller, and run it from a browser as well.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec09"/>There's more...</h2></div></div></div><p>The previous script works fine if the data is clean. You may need to validate each record before inserting it. This is again a two-step procedure. First you need to add validators to your model, for example:<a id="id114" class="indexterm"/>
</p><div><pre class="programlisting">
db.define_table('employees',
	Field('first_name', requires=IS_NOT_EMPTY()),
	Field('last_name', requires=SI_NOT_EMPTY()),
	Field('salary','double', requires=IS_FLOAT_IN_RANGE(0,10**7)))
</pre></div><p>Then you need to call validators on import and check for errors:</p><div><pre class="programlisting">
for line in open('/tmp/data.txt','r'):
	fullname,salary = line.strip().split('|')
	first_name,last_name = fullname.split(' ')
	r = db.employee.validate_and_insert(
		first_name=first_name,
		last_name=last_name,
		salary=float(salary))
if r.errors: print line, r.errors
	db.commit()
</pre></div><p>Records that cause errors will not be inserted, and you can deal with them manually.</p></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec05"/>Moving your data from one database to another</h1></div></div></div><p>So, at this point, you have built your application, and you have data in your SQLite database. But let's say you need to move to a production MySQL or PostgreSQL environment.<a id="id115" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec10"/>Getting ready</h2></div></div></div><p>Here we assume you have an application called<code class="literal"> app</code>, data in the<code class="literal"> sqlite://storage.sqlite</code> database, and you want to move your data to a different database:</p><div><pre class="programlisting">mysql://username:password@hostname:port/dbname
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec11"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>Edit your model<code class="literal"> db.py</code>, and replace the following:</p><div><pre class="programlisting">db=DAL('sqlite://storage.sqlite')
</pre></div><p>With the following:
</p><div><pre class="programlisting">
production=False
URI = 'mysql://username:password@hostname:port/dbname'
if production:
	db=DAL(URI, pool_size=20)
else:
	db=DAL('sqlite://storage.sqlite')
</pre></div></li><li class="listitem"><p>Create a file called<code class="literal"> applications/app/private/mover.py</code> that contains the following data:</p><div><pre class="programlisting">
def main():
	other_db = DAL(URI)
	print 'creating tables...'
	for table in db:
		other_db.define_table(table._tablename,*[field for field in
			table])
	print 'exporting data...'
	db.export_to_csv_file(open('tmp.sql','wb'))
	print 'importing data...'
	other_db.import_from_csv_file(open('tmp.sql','rb'))
	other_db.commit()
	print 'done!'
if __name__() == "__main__":
	main()
</pre></div></li><li class="listitem"><p>Run this file with the following command (run it only once or you end up with duplicate records):</p><div><pre class="programlisting"><strong>python web2py.py -S app -M -N -R applications/app/private/mover.py</strong>
</pre></div></li><li class="listitem"><p>Change the model<code class="literal"> db.py</code>, and change the following:</p><div><pre class="programlisting">production=False
</pre></div><p>To the following:
</p><div><pre class="programlisting">production=True
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch03lvl2sec12"/>There's more...</h3></div></div></div><p>Actually, web2py comes with the following script:</p><div><pre class="programlisting"><strong>script/cpdb.py</strong>
</pre></div><p>This script performs tasks and variations using command-line options. Read the file for more information.<a id="id116" class="indexterm"/>
</p></div></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec06"/>Creating a model from existing MySQL and PostgreSQL databases</h1></div></div></div><p>It is often necessary to access an existing database from a web2py application. This is possible under some conditions.<a id="id117" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec13"/>Getting ready</h2></div></div></div><p>In order to connect to an existing database, it must be one that's supported. At the time of writing, this includes<strong> MySQL, PostgreSQL, MSSQL, DB2, Oracle, Informix, FireBase</strong>, and<strong> Sybase</strong>. You must know the database type (for example<code class="literal"> mysql</code> or<code class="literal"> postgres)</code>, the database name (for example,<code class="literal"> mydb)</code>, and the hostname and port where the database server is running (for example<code class="literal"> 127.0.0.1:3306</code> for<code class="literal"> mysql</code> or<code class="literal"> 127.0.0.1:5432</code> for<code class="literal"> postgres)</code>. You must have a valid username and password to access the database. In summary, you must know the following URI strings:</p><div><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">mysql://username:password@127.0.0.1:3306/mydb</code>
</p></li><li class="listitem"><p>
<code class="literal">postgres://username:password@127.0.0.1:5432/mydb</code>
</p></li></ul></div><p>Assuming you can connect to this database, you will only be able to access those tables that meet the following conditions:</p><div><ul class="itemizedlist"><li class="listitem"><p>Each table to be accessed must have a unique auto-increment integer primary key (whether called<code class="literal"> id</code> or not). For PostgreSQL, you can also have compound primary keys (comprised of several fields), and not necessarily of<code class="literal"> SERIAL</code> type (see<strong> keyed tables</strong> on web2py book).</p></li><li class="listitem"><p>Records must be referenced by their primary key.</p></li><li class="listitem"><p>The web2py model must include a<code class="literal"> define_table</code> statement for each table to be accessed, listing all fields and their types.</p></li></ul></div><p>In the following, we will also assume your system supports the<code class="literal"> mysql</code> command to access the database locally (to extract MySQL models), or your system has installed the<code class="literal"> psycopg2</code> python module (to extract PostgreSQL models, see installation recipes).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec14"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>First you need to query the database and come up with a possible model compatible with the content of the database. This can be done by running the following scripts that comes with web2py:<a id="id118" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>To build web2py models from a MySQL database, use:</p><pre class="programlisting"><strong>python scripts/extract_mysql_models.py username:password@databasename &gt; db1.py</strong>
</pre></li><li class="listitem"><p>To build web2py models from a PostgreSQL database, use:</p></li></ul></div><pre class="programlisting"><strong>python scripts/extract_pgsql_models.py databasename localhost 5432 username password &gt; db1.py</strong>
</pre><p>The scripts are not perfect, but they will generate a db1.py file that describes the database tables.
</p></li><li class="listitem"><p>Edit this model to remove tables that you do not need to access. Improve the field types (for example, a string field may be a password), and add validators.</p></li><li class="listitem"><p>Then move this file into the<code class="literal"> models/</code> folder of your application.</p></li><li class="listitem"><p>Finally, edit the original<code class="literal"> db.py</code> model, and replace the URI string with the one for this database.</p><div><ul class="itemizedlist"><li class="listitem"><p>For MySQL, write:</p></li></ul></div><div><pre class="programlisting">
db = DAL('mysql://username:password@127.0.0.1:8000/databasename',
	migrate_enabled=False, pool_size=20)
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>For PostgreSQL, write:</p></li></ul></div><div><pre class="programlisting">
db = DAL(
	"postgres://username:password@localhost:5432/databasename", migrate_enabled=False, pool_size=10)
	migrate = False # you can control migration per define_table
</pre></div><p>We disable all migrations, because the table already exists and web2py should not attempt to create or alter it.
</p></li></ol></div><p>Unfortunately, accessing the existing database is one of the most tricky tasks in web2py, because the database was not created by web2py, and web2py needs to make some guesses. The only way to fix these problems is by manually editing the model file, and using independent knowledge of the database content.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec15"/>There's more...</h2></div></div></div><p>Actually, the<code class="literal"> extract_pgsql_models.py</code> has the following additional features:</p><div><ul class="itemizedlist"><li class="listitem"><p>It uses ANSI Standard<code class="literal"> INFORMATION_SCHEMA</code> (this might work with other RDBMS)</p></li><li class="listitem"><p>It detects legacy keyed tables (not having an<code class="literal"> id</code> as its primary key)</p></li><li class="listitem"><p>It connects directly to running databases, so there's no need to do an SQL dump</p></li><li class="listitem"><p>It handles<code class="literal"> notnull, unique</code>, and referential constraints</p></li><li class="listitem"><p>It detects the most common datatypes and default values</p></li><li class="listitem"><p>It supports PostgreSQL columns comments (that is, for documentation)</p></li></ul></div><p>If you have to use it against other RDBMS that support ANSI<code class="literal"> INFORMATION_SCHEMA</code> (for example, MSSQL Server), import and use the proper Python connector, and remove the<code class="literal"> postgreSQL</code> specific queries (pg_<code class="literal"> tables</code> for comments)</p><div><h3 class="title"><a id="note04"/>Note</h3><p>You cannot mix references between normal auto-increment primary keys tables (type='id') and keyed tables (primarykey=['field1',<code class="literal">'field2'])</code>. If you use both in your database, you have to manually define auto-increment primary keys as keyed tables at the web2py model (removing<code class="literal"> id</code> type, and adding the primary key parameter to<code class="literal"> define_table)</code>.</p></div></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec07"/>Efficiently searching by tag</h1></div></div></div><p>Whether you are building a social network, a content management system, or an ERP system, you eventually need the ability to tag records. This recipe shows you a way to efficiently search for records by tag.<a id="id119" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Getting ready</h2></div></div></div><p>Here we assume the following two models:</p><div><ol class="orderedlist"><li class="listitem"><p>A model for containing the data:</p><div><pre class="programlisting">db.define_table('data', Field('value'))
</pre></div></li><li class="listitem"><p>A model for storing the tags:</p><div><pre class="programlisting">db.define_table('tag', Field('record_id', db.data), Field('name'))
</pre></div></li></ol></div><p>Here,<code class="literal"> name</code> is the tag name.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec17"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>We want to search all records having at least one of the tags in the list:</p><div><pre class="programlisting">tags = [...]
</pre></div><p>For this purpose, we create a search function:
</p><div><pre class="programlisting">
def search_or(data=db.data, tag=db.tag, tags=[]):
	rows = db(data.id==tag.record_id)\ (tag.name.belongs(tags)).select(
		data.ALL,
		orderby=data.id,
		groupby=data.id,
		distinct=True)
	return rows
</pre></div></li><li class="listitem"><p>Similarly, if you want to search for records that have all the tags (as opposed to one of those in the list):</p><div><pre class="programlisting">
def search_and(data=db.data,tag=db.tag,tags=[]):
	n = len(tags):
	rows = db(data.id==tag.record_id)\
		(tag.name.belongs(tags)).select(
		data.ALL,
		orderby=data.id,
		groupby=data.id,
		having=data.id.count()==n)
	return rows
</pre></div></li></ol></div><p>Notice that these two functions work for any table that is passed as first argument.<a id="id120" class="indexterm"/>
</p><p>In both functions, the query involves two tables.</p><div><pre class="programlisting">data.id==tag.record_id
</pre></div><p>web2py interprets this as join.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec18"/>There's more...</h2></div></div></div><p>This system works great if users are free to choose the tag names. Sometimes, you want to restrict tags to a well defined set. In that case, the model needs to be updated:</p><div><pre class="programlisting">db.define_table('data', Field('value'))
db.define_table('tag', Field('name', unique=True))
db.define_table('link', Field('record_id',db.data), Field('tag_id',db.
tag))
</pre></div><p>Here, the link table implements a many-to-many relation between data records and tag items.</p><p>In this case, we need to modify our search functions, so first we convert a list of tag names (tags) into a list of tag IDs, and then perform the previous query. This can be done using a<code class="literal"> subquery:</code>
</p><div><pre class="programlisting">
def search_or(data=db.data, tag=db.tag,link=db.link,tags=[]):
	subquery = db(db.tag.name.belongs(tags)).select(db.tag.id)
	rows = db(data.id==link.record_id)\
	(link.tag_id.belongs(subquery)).select(
		data.ALL,
		orderby=data.id,
		groupby=data.id,
		distinct=True)
	return rows
def search_and(data=db.data, tag=db.tag, link=db.link, tags=[]):
	n = len(tags)
	subquery = db(db.tag.name.belongs(tags)).select(db.tag.id)
	rows = db(data.id==link.record_id)\
		(link.tag_id.belongs(subquery)).select(
			data.ALL,
			orderby=data.id,
			groupby=data.id,
			having=data.id.count()==n)
	return rows
</pre></div><p>The technique we implemented here is known as the<strong> Toxi</strong> method, and is described in a more general and abstract way at the following link:<a id="id121" class="indexterm"/>
</p><p>
<a class="ulink" href="http://www.pui.ch/phred/archives/2005/04/tags-database-schemas.html">http://www.pui.ch/phred/archives/2005/04/tags-database-schemas.html</a>.</p></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec08"/>Accessing your database from multiple applications</h1></div></div></div><p>One way to build distributed applications, is by having the same database available to multiple applications. Unfortunately, this is more than a matter of connecting to the database. In fact, the different applications need to be aware of the table content and other metadata, which is stored in the model definition.<a id="id122" class="indexterm"/>
</p><p>There are three ways to do this, and they are not equivalent. It depends on whether the applications share a file system, and the degree of autonomy you want to give to the two applications.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Getting ready</h2></div></div></div><p>We will assume you have two web2py applications, one called<code class="literal"> app1</code>, and one called<code class="literal"> app2</code>, where<code class="literal"> app1</code> connects to a database through the following:</p><div><pre class="programlisting">db = DAL(URI)
</pre></div><p>Here, URI is some connection string. It does not matter whether this is SQLite or a client/server database. We will also assume that the model used by<code class="literal"> app1</code> is stored in<code class="literal"> models/db1.py</code>, although the name is unimportant here.</p><p>Now we want<code class="literal"> app2</code> to connect to the same database.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>How to do it...</h2></div></div></div><p>It is also a common scenario that you want the two applications to be autonomous, although able to share data.<strong> Autonomous</strong> means that you want to be able to distribute each application without the other one.</p><p>If this is the case, each application needs its own copy of the model and its own database metadata. The only way to achieve this is by duplication of code.</p><p>You must follow these steps:</p><div><ol class="orderedlist"><li class="listitem"><p>Edit the URI string of<code class="literal"> app2</code> so that it looks the same as<code class="literal"> app1</code>, but disable migrations:</p><div><pre class="programlisting">db = DAL(URI, migrate_enabled=False)
</pre></div></li><li class="listitem"><p>Copy the model file<code class="literal"> models/d1.py</code> from<code class="literal"> app1</code> into<code class="literal"> app2</code>.</p></li></ol></div><p>Notice that only<code class="literal"> app1</code> will be able to perform migrations (if both were able to do it, the situation would get very confused). If you change the model in<code class="literal"> app1</code>, you will have to copy the model file again.<a id="id123" class="indexterm"/>
</p><p>Although this solution breaks the<strong> Don't Repeat Yourself</strong> (DRY) pattern, it guarantees complete autonomy to each application, and they can access the same database even if running on separate servers.</p><p>If the two applications are running on the same server, instead of copying the model file, you can just make a symbolic link:</p><div><pre class="programlisting">ln applications/app1/models/db1.py applications/app2/models/db1.py
</pre></div><p>Now you have only one model file.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>There's more...</h2></div></div></div><p>Sometimes you need a script (not a web application) to be able to access a web2py model. This can be done by accessing the metadata only, without executing the actual model file.</p><p>Here is a python script (not a web2py model) that can do it:</p><div><pre class="programlisting"><strong># file myscript.py
from gluon.dal import DAL
db = DAL(URI, folder='/path/to/web2py/applications/app1', auto_
import=True)
print db.tables
# add your code here</strong>
</pre></div><p>Notice the<code class="literal"> auto_import=True</code>. It tells the DAL to look in the specified folder for the meta-data associated to the URI connection, and rebuilds the models on the fly, in memory. Models defined in this way have the right names and field types, but they will not have the correct values of other attributes, such as readable, writable, default, validators, and so on. This is because those attributes cannot be serialized in the metadata, and are probably not needed in this scenario.<a id="id124" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec09"/>Hierarchical category tree</h1></div></div></div><p>Sooner or later, any application needs a way to categorize data, and categories must be stored in a tree, because each category has a parent and possibly subcategories. A category without a subcategory is a leaf of the tree. If there are categories without a parent, we create a fictitious root tree node, and append all of them as subcategories of the root.<a id="id125" class="indexterm"/>
</p><p>The main issue is how to store categories with parent-child relations in a database table, and efficiently add nodes and queries for ancestors and descendants of a node.</p><p>This can be done using a modified pre-order tree traversal algorithm, described as follows.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>How to do it...</h2></div></div></div><p>The key trick consists of storing each node in its own record with two integer attributes, left and right, so that all its ancestors have a left attribute lower than or equal to the left attribute of the current node, and a right attribute larger than the one of the current node. Similarly, all descendants will have a left larger or equal than the current left and a right smaller than the current right. In formula:</p><p>
<code class="literal">A</code> is parent of<code class="literal"> B</code> if<code class="literal"> A.ileft&lt;=B.ileft</code>, and<code class="literal"> A.iright&gt;B.iright</code>.</p><p>Notice that<code class="literal"> A.iright - A.ileft</code> is always the number of descendants.</p><p>The following is a possible implementation:</p><div><pre class="programlisting">
from gluon.dal import Table

class TreeProxy(object):
	skeleton = Table(None,'tree',
		Field('ileft','integer'),
		Field('iright','integer'))
	def __init__(self,table):
		self.table=table
	def ancestors(self,node):
		db = self.table._db
	return
		db(self.table.ileft&lt;=node.ileft)(self.table.iright&gt;node.iright)
	def descendants(self,node):
		db = self.table._db
	return
		db(self.table.ileft&gt;=node.ileft)(self.table.iright&lt;node.iright)
	  def add_leaf(self,parent_id=None,**fields):
		if not parent_id:
			nrecords = self.table._db(self.table).count()
			fields.update(dict(ileft=nrecords,iright=nrecords))
		else:
			node = self.table(parent_id)
			fields.update(dict(ileft=node.iright,iright=node.iright))
			node.update_record(iright=node.iright+1)
			ancestors = self.ancestors(node).select()
		for ancestor in ancestors:
			ancestor.update_record(iright=ancestor.iright+1)
			ancestors = self.ancestors(node).select()
		for ancestor in ancestors:
			ancestor.update_record(iright=ancestor.iright+1)
	return self.table.insert(**fields)
	
	  def del_node(self,node):
		delta = node.iright-node.ileft
		deleted = self.descendants(node).delete()
		db = self.table._db
		db(self.table.iright&gt;node.iright).
			update(iright=self.table.iright-delta)
		del self.table[node.id]
	return deleted + 1
</pre></div><p>This allows us to perform the following operations:<a id="id126" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>Define your own tree table (mytree) and proxy object (treeproxy):</p><div><pre class="programlisting">
treeproxy =
	TreeProxy(db.define_table('mytree',Field('name'),Tree.skeleton))
</pre></div></li><li class="listitem"><p>Insert a new node:</p><div><pre class="programlisting">id = treeproxy.add_leaf(name="root")
</pre></div></li><li class="listitem"><p>Append some nodes:</p><div><pre class="programlisting">treeproxy.add_leaf(parent_id=id,name="child1")
treeproxy.add_leaf(parent_id=id,name="child2")
</pre></div></li><li class="listitem"><p>Search ancestors and descendants:</p><div><pre class="programlisting">
for node in treeproxy.ancestors(db.tree(id)).select():
	print node.name
for node in treeproxy.descendants(db.tree(id)).select():
print node.name
</pre></div></li><li class="listitem"><p>Delete a node and all its descendants:</p><div><pre class="programlisting">treeproxy.del_node(db.tree(id))
</pre></div></li></ul></div></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec10"/>Creating records on demand</h1></div></div></div><p>It is common that we need to get a record or update a record, based on a condition, yet the record may not exist. If the record does not exist, we want to create it. In this recipe, we will show two utility functions that can serve this purpose:<a id="id127" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">get_or_create</code>
</p></li><li class="listitem"><p>
<code class="literal">update_or_create</code>
</p></li></ul></div><p>For this to work, we need to pass enough<code class="literal"> field:value</code> pairs to create the missing record.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>Here is the code for<code class="literal"> get_or_create:</code>
</p><div><pre class="programlisting">
def get_or_create(table, **fields):
	"""
	Returns record from table with passed field values.
	Creates record if it does not exist.
	'table' is a DAL table reference, such as 'db.invoice'
	fields are field=value pairs
	"""
	return table(**fields) or table.insert(**fields)
</pre></div><p>Notice how table(**fields) selects a record from the table, matching the requested fields, and returns None if the record does not exist. In this latter case, the record is inserted. Then, table.insert(...) returns a reference to the inserted record, which, for practical purposes, gets the record just inserted.
</p></li><li class="listitem"><p>Here is an example of usage:</p><div><pre class="programlisting">db.define_table('person', Field('name'))
john = get_or_create(db.person, name="John")
</pre></div></li><li class="listitem"><p>The code for<code class="literal"> update_or_create</code> is very similar, but we need two sets of variables&amp;mdash; variables for the<strong> search</strong> (before update) and variables to be<strong> updated:</strong>
</p><div><pre class="programlisting">
def update_or_create(table, fields, updatefields):
	"""
	Modifies record that matches 'fields' with 'updatefields'.
	If record does not exist then create it.
	
	'table' is a DAL table reference, such as 'db.person'
	'fields' and 'updatefields' are dictionaries
	"""
	row = table(**fields)
	if row:
		row.update_record(**updatefields)
	else:
		fields.update(updatefields)
		row = table.insert(**fields)
	return row
</pre></div></li><li class="listitem"><p>And here is an example of usage:<a id="id128" class="indexterm"/>
</p><div><pre class="programlisting">tim = update_or_create(db.person, dict(name="tim"),
dict(name="Tim"))
</pre></div></li></ol></div></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec11"/>OR, LIKE, BELONGS, and more on Google App Engine</h1></div></div></div><p>A major limitation of the<strong> Google App Engine</strong> (GAE) is the inability to perform queries that use the OR, BELONGS(IN), and LIKE operators.<a id="id129" class="indexterm"/>
</p><p>The web2py DAL provides a system for abstracting database queries, and it works on<strong> Relational Databases</strong> (RDBS) as well as on GAE but, still, it is crippled by the limitations mentioned. Here we show some workarounds.</p><p>We have created an additional API that allows merging, filtering, and sorting records after they are extracted from the GAE storage, at the web2py level. They can be used to mimic the missing features, and will make your GAE code portable to RDBS too.</p><p>Current supported RDBS are SQLite, MySQL, PostgreSQL, MSSQL, DB2, Informix, Oracle, FireBird, and Ingres.</p><p>GAE is the only currently supported NoDB. Other adapters are under development.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Getting ready</h2></div></div></div><p>In the following recipe, we plan to develop an application to run on GAE, and we connect to the database using the following logic:</p><div><pre class="programlisting">
if request.env.web2py_runtime_gae:
	db = DAL('google:datastore')
else:
	db = DAL('sqlite://storage.sqlite')
</pre></div><p>We assume the following models, as an example:</p><div><pre class="programlisting">
product = db.define_table('product',
	Field('name'),
	Field('price','double'))
	
buyer = db.define_table('buyer',
	Field('name'))
	
purchase = db.define_table('purchase',
	Field('product',db.product),
	Field('buyer',db.buyer),
	Field('quantity','integer'),
	Field('order_date','date',default=request.now))
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>How to do it...</h2></div></div></div><p>After setting up the GAE model that we described previously, let's see how to do insert and update records, do joins and other manipulations in the following sections.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec01"/>Record insert</h3></div></div></div><p>To test the rest of the code, you may want to insert some records in the tables. You can do this with<code class="literal"> appadmin</code> or programmatically. The following code will work fine on GAE with the caveats that the IDs returned by the<code class="literal"> insert</code> method are not sequential on GAE:</p><div><pre class="programlisting">
icecream = db.product.insert(name='Ice Cream',price=1.50)
kenny = db.buyer.insert(name='Kenny')
cartman = db.buyer.insert(name='Cartman')
db.purchase.insert(product=icecream,buyer=kenny,quantity=1,
	order_date=datetime.datetime(2009,10,10))
db.purchase.insert(product=icecream,buyer=cartman,quantity=4,
	order_date=datetime.datetime(2009,10,11))
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec02"/>Record update</h3></div></div></div><p>The<code class="literal"> update</code> on GAE works as you would normally expect. Both syntaxes are supported:</p><div><pre class="programlisting">icecream.update_record(price=1.99)
</pre></div><p>And also:</p><div><pre class="programlisting">icecream.price=1.99
icecream.update_record()
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Joins</h3></div></div></div><p>On a relational database, you can do the following:</p><div><pre class="programlisting">
rows = db(purchase.product==product.id)
	(purchase.buyer==buyer.id).select()
for row in rows:
	print row.product.name, row.product.price,
	row.buyer.name, row.purchase.quantity
</pre></div><p>This produces the following:</p><div><pre class="programlisting">Ice Cream 1.99 Kenny 1
Ice Cream 1.99 Cartman 4
</pre></div><p>This does not work on GAE. You have to perform the query without the join, using recursive<code class="literal"> selects</code>.</p><div><pre class="programlisting">
rows = db(purchase.id&gt;0).select()
for row in rows:
	print row.product.name, row.product.price, row.buyer.name,
	row.quantity
</pre></div><p>Here,<code class="literal"> row.product.name</code> performs recursive<code class="literal"> selects</code>, and gets you the name of the product referenced by<code class="literal"> row.product.</code>
</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec04"/>Logical OR</h3></div></div></div><p>On an RDBS, you can implement<code class="literal"> OR</code> in queries using the &amp;mdash; operator:</p><div><pre class="programlisting">rows = db((purchase.buyer==kenny)|(purchase.buyer==cartman)).select()
</pre></div><p>This does not work on GAE, because<code class="literal"> OR</code> is not supported (at the time of writing). If the queries involve the same field, you can use the<code class="literal"> IN</code> operator:</p><div><pre class="programlisting">rows = db(purchase.buyer.contains((kenny,cartman))).select()
</pre></div><p>This is a portable and efficient solution. In the most general case, you may need to perform the<code class="literal"> OR</code> operation at the web2py level as opposed to at the database level.</p><div><pre class="programlisting">rows_kenny = db(purchase.buyer==kenny).select()
rows_cartman = db(purchase.buyer==cartman).select()
rows = rows_kenny|rows_cartman
</pre></div><p>In this latter case, the<code class="literal">&amp;mdash</code>; is not between queries, but between rows object, and it is performed after the records are fetched. This presents some problems because the original order is lost, and because of the increased memory and resource consumption penalty.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec05"/>OR with orderby</h3></div></div></div><p>On a relational database you can do the following:<a id="id130" class="indexterm"/>
</p><div><pre class="programlisting">
rows = db((purchase.buyer==kenny)|(purchase.buyer==cartman))\
	.select(orderby=purchase.quantity)
</pre></div><p>But, again on GAE, you have to perform the<code class="literal"> OR</code> at web2py level. Therefore you also have to sort at the web2py level:</p><div><pre class="programlisting">rows_kenny = db(purchase.buyer==kenny).select()
rows_cartman = db(purchase.buyer==cartman).select()
rows = (rows_kenny|rows_cartman).sort(lambda row:row.quantity)
</pre></div><p>The<code class="literal"> sort</code> method of the<code class="literal"> rows</code> objects take a function of the row, and must return an expression to sort about. They can also be used with RDBS to implement sorting, when the expression is too complex to implement at the database level.<a id="id131" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec06"/>OR with more complex orderby</h3></div></div></div><p>Consider the following query that involves a<code class="literal"> OR</code>, a<code class="literal"> JOIN</code>, and an ordering, and would only work on RDBS:<a id="id132" class="indexterm"/>
</p><div><pre class="programlisting">
rows = db((purchase.buyer==kenny)|(purchase.buyer==cartman))\
	(purchase.buyer==buyer.id).select(orderby=buyer.name)
</pre></div><p>You can rewrite it for GAE using the<code class="literal"> sort</code> method, and a recursive<code class="literal"> select</code> in the<code class="literal"> sort</code> argument:</p><div><pre class="programlisting">
rows = (rows_kenny|rows_cartman).sort( \
	lambda row:row.buyer.name)
</pre></div><p>This works, but it may be inefficient. You may want to cache the mapping of<code class="literal"> row.buyer</code> into<code class="literal"> buyer_names:</code>
</p><div><pre class="programlisting">
buyer_names = cache.ram('buyer_names',
	lambda:dict(*[(b.id,b.name) for b in db(db.buyer).select()]),
	3600)
rows = (rows_kenny|rows_cartman).sort(
	lambda row: buyer_names.get(row.buyer,row.buyer.name))
</pre></div><p>Here,<code class="literal"> buyer_names</code> is a mapping between<code class="literal"> ids</code> and<code class="literal"> names</code>, and it is cached every hour (3600 seconds).<code class="literal"> sort</code> tries to pick the names from<code class="literal"> buyer_names</code> if possible, or else it performs the recursive select.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec07"/>LIKE</h3></div></div></div><p>On a relational database, you can, for example, search all records with a name starting with the letter<code class="literal"> C</code> followed by anything (%):</p><div><pre class="programlisting">rows = db(buyer.name.like('C%')).select()
print rows
</pre></div><p>But GAE neither supports full text search, nor anything that resembles the SQL<code class="literal"> LIKE</code> operator. Once more, we have to select all records and perform the filtering at the web2py level. We can use the<code class="literal"> find</code> method of the<code class="literal"> rows</code> object:</p><div><pre class="programlisting">
rows = db(buyer.id&gt;0).select().find(lambda
	row:row.name.startswith('C'))
</pre></div><p>Of course, this is expensive, and not recommended for large tables (more than a few hundred records). If this kind of search is critical for your application, perhaps you should not be using GAE.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec08"/>date and datetime manipulations</h3></div></div></div><p>The same problem occurs for queries involving other expressions, such as date and datetime manipulations. Consider the following query that works on relational databases but not on GAE:</p><div><pre class="programlisting">rows = db(purchase.order_date.day==11).select()
</pre></div><p>On GAE you would have to rewrite it as follows:</p><div><pre class="programlisting">
rows = db(purchase.id&gt;0).select().find(lambda
	row:row.order_date.day==11)
</pre></div></div></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec12"/>Replacing slow virtual fields with DB views</h1></div></div></div><p>Consider the following table:<a id="id133" class="indexterm"/>
</p><div><pre class="programlisting">
db.define_table('purchase', Field('product'),
	Field('price', 'double'),
	Field('quantity','integer'))
</pre></div><p>You need to add a field called<code class="literal"> total price</code> that is computed when records are retrieved, and is defined as the product of price by quantity for each record.</p><p>The normal way to do it is by using<strong> virtual fields:</strong>
</p><div><pre class="programlisting">
class MyVirtualFields(object):
	def total_price(self):
		return self.purchase.price * self.purchase.quantity
db.purchase.virtualfields.append(MyVirtualFields())
</pre></div><p>Then you can do the following:</p><div><pre class="programlisting">
for row in db(db.purchase).select():
	print row.name, row.total_price
</pre></div><p>This is fine, but computing virtual fields at the web2py level can be slow. Moreover, you would not be used to involving the virtual fields in queries.</p><p>Here we propose an alternate solution that involves creating a database view for the table, which includes the column with computed fields, and provides a way for web2py to access it.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>How to do it...</h2></div></div></div><p>Given the table, do the following:</p><div><pre class="programlisting">
if not db.executesql("select * from information_schema.tables where
table_name='purchase_plus' limit 1;"):
	db.executesql("create view purchase_plus as select purchase.*,
		purchase.price * purchase.quantity as total_price from purchase")
db.define_table('purchase_plus', db.purchase, Field('total_price',
	'double'),
	migrate=False)
</pre></div><p>Now, you can use<code class="literal"> db.purchase_plus</code> anywhere you would use<code class="literal"> db.numbers_plus</code>, except for inserts, with a performance increase when compared to the<code class="literal"> VirtualFields</code> solution.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>How it works...</h2></div></div></div><p>The following line checks whether the view has been created already:<a id="id134" class="indexterm"/>
</p><div><pre class="programlisting">if not db.executesql("select ...")
</pre></div><p>If not, it instructs the database to create it:</p><div><pre class="programlisting">db.executesql("create view ...")
</pre></div><p>Finally, it defines a new web2py model, which maps into the table:</p><div><pre class="programlisting">db.define_table('purchase_plus',...)
</pre></div><p>This model includes all fields from the<code class="literal"> db.purchase</code> table, the new field<code class="literal"> total_price</code>, and sets<code class="literal"> migrate=False</code>, so that web2py does not attempt to create the table (it should not because this is not a new table, it's a view, and has been already created).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>There's more...</h2></div></div></div><p>Notice that not all supported databases support views, and not all of those that do have an<code class="literal"> information_schema.tables</code>. Therefore, this recipe is not guaranteed to work on all supported databases, and will make your application not portable.</p></div></div></div></div>
</body></html>