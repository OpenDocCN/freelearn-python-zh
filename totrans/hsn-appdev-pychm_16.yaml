- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Your Next Steps with PyCharm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PyCharm 的下一步
- en: PyCharm’s features are so extensive, and improvements from JetBrains come so
    rapidly that it’s been hard to keep up.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 的功能非常广泛，JetBrains 的改进又如此迅速，以至于很难跟上。
- en: 'In this, my parting chapter, I want to do a few more things to try to do justice
    to this amazing piece of software. In this chapter, we’ll cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个，我即将告别的章节中，我想做几件事情，以公正地评价这款令人惊叹的软件。在本章中，我们将涵盖以下内容：
- en: I’ll do the obligatory wrap-up by briefly summarizing and commenting on our
    journey together so far.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将进行例行总结，简要总结并评论我们迄今为止的旅程。
- en: I’ll cover a few cool features to help with your productivity that just didn’t
    fit neatly into the chapter topics presented so far.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将介绍一些有助于提高你生产力的酷炫功能，这些功能之前没有很好地融入章节主题。
- en: I’ll cover some cool new features that were introduced over the course of the
    8 months it took me to write the book. I’ve been covering version 2023.1, and
    I have avoided updating it so I can stay consistent with screenshots of the UI
    used throughout the book. The 2023.2 release is out and there are some amazing
    changes, including a beta of the new **AI Assistant**!
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将介绍一些在撰写本书的 8 个月期间引入的酷炫新功能。我一直在介绍 2023.1 版本，为了避免与书中使用的 UI 截图不一致，我避免更新它。2023.2
    版本已经发布，其中有一些惊人的变化，包括新 **AI 助手** 的测试版！
- en: I’ll raise a glass and shed a tear as we part company until the next book comes
    out.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们分别，我会举杯畅饮，泪眼朦胧，直到下一本书出版。
- en: I’ll do my best not to get emotional on you. We’ve been together for a while
    now and it’s going to be hard to take this victory lap with you knowing the book
    is almost finished. I’m getting a little misty over here just thinking about it,
    so let’s keep moving.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我会尽力不让你感到伤感。我们已经在一起有一段时间了，知道这本书即将完成，和你一起庆祝这个胜利的时刻将会很难。我想到这里，眼眶都有点湿润了，所以我们还是继续前进吧。
- en: 'In order to proceed through this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续本章的学习，你需要以下内容：
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并运行良好的 Python 解释器。我将使用来自 [https://python.org](https://python.org) 的最新版本。
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and macOS includes them on every system. If you
    are using Linux, you need to install the package managers (such as `pip`) and
    the virtual environment tools (e.g., `virtualenv`) separately. Our examples will
    use `pip` and `virtualenv`.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并运行良好的 `pip` 和 `virtualenv`。当你将 Python 安装在 Windows 上时，你会自动获得这些，macOS 在每个系统上都会包含它们。如果你使用
    Linux，你需要单独安装包管理器（如 `pip`）和虚拟环境工具（例如 `virtualenv`）。我们的示例将使用 `pip` 和 `virtualenv`。
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028). The screenshots in this chapter come from
    version 2023.2.1.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并运行良好的 PyCharm 版本。安装过程已在 [*第 2 章*](B19644_02.xhtml#_idTextAnchor028) 中介绍。本章中的截图来自
    2023.2.1 版本。
- en: This book’s sample source code from GitHub can be found at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-16](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-16).
    We covered cloning the code in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation* *and Configuration*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书从 GitHub 上的示例源代码可以在 [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-16](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-16)
    找到。我们已在 [*第 2 章*](B19644_02.xhtml#_idTextAnchor028) 中介绍了代码的克隆，*安装* *和配置*。
- en: Miscellaneous topics in PyCharm
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCharm 中的杂项主题
- en: As I said, the sheer volume of features in this IDE is staggering. In this section,
    I’ll cover a few things that didn’t fit neatly into other chapters. I’ll be presenting
    them more in the spirit of my saying “Hey, look at this!”, rather than presenting
    a full tutorial on each feature.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所说，这个 IDE 的功能数量令人震惊。在本节中，我将介绍一些没有很好地融入其他章节的内容。我将更多地以“嘿，看看这个！”的精神来展示它们，而不是为每个功能提供完整的教程。
- en: Remote virtual environments
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程虚拟环境
- en: We’ve had this feature for a while now, and I think it is likely outshined by
    the newer remote development features we covered in [*Chapter 15*](B19644_15.xhtml#_idTextAnchor379).
    This feature allows you to work with an interpreter on another computer accessible
    via SSH. There are a couple of use cases for this. I have used this feature to
    debug a copy of an application using the virtual environment on the production
    server. I have a copy of the production code on my computer, but the venv is on
    the production system. This allows me to reproduce a bug and fix it locally using
    the exact environment where it normally lives. This was especially effective back
    when I used Mac and Windows laptops as my main development environment while the
    production environment ran in Linux. As we’ve pointed out, lots of packages deploy
    differently based on the operating system. I’ve always had challenges with **NumPy**,
    **pandas**, and **pymssql** (the Microsoft supported driver for SQL Server), which
    work very differently in these different environments, especially Windows. To
    build your third-party packages that leverage C code, you need a compiler. In
    Linux it’s *cmake*. On Windows, it is the Microsoft C++ compiler. There is a big
    difference between the two, and testing an application only on Windows doesn’t
    cut it for me. I want a more realistic test, and using this feature I can use
    the exact environment where it will run.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有这个功能一段时间了，我认为它可能被我们在[*第15章*](B19644_15.xhtml#_idTextAnchor379)中介绍的新远程开发功能所超越。这个功能允许您通过SSH访问另一台计算机上的解释器进行工作。这个功能有几个用例。我曾使用这个功能来调试一个在生产服务器上使用虚拟环境的应用程序副本。我在我的电脑上有一个生产代码的副本，但虚拟环境在生产系统上。这让我能够在它通常运行的环境中重现错误并本地修复它。当我在使用Mac和Windows笔记本电脑作为主要开发环境，而生产环境在Linux上运行时，这种方法特别有效。正如我们指出的，许多软件包根据操作系统部署方式不同。我一直在**NumPy**、**pandas**和**pymssql**（Microsoft支持的SQL
    Server驱动程序）上遇到挑战，这些软件包在这些不同的环境中工作方式非常不同，尤其是在Windows上。要构建利用C代码的第三方软件包，您需要一个编译器。在Linux上，它是*cmake*。在Windows上，它是Microsoft
    C++编译器。两者之间有很大的区别，仅在对Windows进行应用程序测试对我来说是不够的。我想要一个更真实的测试，使用这个功能，我可以在它将运行的确切环境中使用。
- en: You can create or use a virtual environment on a remote computer by setting
    up an SSH connection to it. We covered creating an SSH connection back in [*Chapter
    15*](B19644_15.xhtml#_idTextAnchor379), so I won’t repeat the instructions here.
    The options for using a remote environment are alongside the normal options in
    the project interpreter settings shown in *Figure 16**.1*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过设置到远程计算机的SSH连接来创建或使用一个虚拟环境。我们之前在[*第15章*](B19644_15.xhtml#_idTextAnchor379)中介绍了如何创建SSH连接，所以这里不再重复说明。使用远程环境的选项与项目解释器设置中的常规选项并列，如*图16.1*所示。
- en: '![Figure 16.1: Use the interpreter settings dialog along with a previously
    configured SSH connection to set up your virtual environment on a remote Linux
    system](img/B19644_16_001.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1：使用解释器设置对话框以及之前配置的SSH连接来在远程Linux系统上设置您的虚拟环境](img/B19644_16_001.jpg)'
- en: 'Figure 16.1: Use the interpreter settings dialog along with a previously configured
    SSH connection to set up your virtual environment on a remote Linux system'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：使用解释器设置对话框以及之前配置的SSH连接来在远程Linux系统上设置您的虚拟环境
- en: Naturally there is going to be a pretty big performance hit when you work this
    way; at least there was for me. For my use case, it was well worth it!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，以这种方式工作可能会带来相当大的性能损失；至少对我来说是这样的。对于我的用例来说，这非常值得！
- en: You’ll note there is also an option for **On Vagrant**, which is effectively
    the same option, but instead of a random remote server it’s on a local virtual
    machine managed by **HashiCorp’s Vagrant**. What is Vagrant you ask?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到还有一个**在Vagrant上**的选项，这实际上是一个相同的选项，但它不是在随机的远程服务器上，而是在由**HashiCorp的Vagrant**管理的本地虚拟机上。您可能会问，Vagrant是什么？
- en: Working with HashiCorp Vagrant
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HashiCorp Vagrant
- en: Within the field of DevOps, a movement called **Infrastructure as Code** (**IaC**)
    has become very important. The idea is that nobody really runs anything on bare
    metal anymore; everything is run on a virtual machine. Regardless, one of the
    challenges I’ve faced over the years is when I go to set up my testing and production
    environments, I have to do it all by hand and it takes quite a while. My objective
    is to set up at least two or three nearly identical environments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevOps领域，一个名为**基础设施即代码**（**IaC**）的潮流变得非常重要。其理念是，没有人再在裸金属上运行任何东西；所有东西都是在虚拟机上运行的。尽管如此，多年来我面临的一个挑战是，当我去设置我的测试和生产环境时，我必须全部手动完成，而且需要相当长的时间。我的目标是设置至少两个或三个几乎完全相同的环境。
- en: 'Let’s say I’m creating a product using Flask that uses React for the frontend,
    and Microsoft SQL Server as the database. In order to run this using best practices,
    I need a few servers:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我正在使用Flask创建一个产品，该产品使用React作为前端，并使用Microsoft SQL Server作为数据库。为了按照最佳实践运行，我需要几个服务器：
- en: I need a web server such as Nginx or Apache to serve my React app along with
    any static assets that might be needed.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要一个像Nginx或Apache这样的Web服务器来为我的React应用提供服务，以及可能需要的任何静态资源。
- en: I need an application server. Flask’s development server isn’t going to cut
    it in production. I need a server that runs something like **Green Unicorn** (*gunicorn*
    for short), which is a production-grade WSGI server capable of handling production
    loads. **WSGI** stands for **Web Server Gateway Interface** in the realm of Python
    development. It is a specification for a standardized interface between web servers
    and Python web applications or frameworks such as Flask, FastAPI, and Django.
    WSGI defines a set of rules and conventions that allow web servers to communicate
    with Python applications in a consistent and interoperable way.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要一个应用服务器。Flask的开发服务器在生产环境中是不够用的。我需要一个运行类似**绿色独角兽**（简称**gunicorn**）的服务器，这是一个能够处理生产负载的生产级WSGI服务器。**WSGI**代表Python开发领域的**Web服务器网关接口**。它是一个规范，用于定义Web服务器和Python
    Web应用或框架（如Flask、FastAPI和Django）之间的标准化接口。WSGI定义了一套规则和约定，允许Web服务器以一致和互操作的方式与Python应用通信。
- en: I need a dedicated database server for SQL Server.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要一个专用的数据库服务器来运行SQL Server。
- en: 'Keeping it simple, that’s three servers, each replicated three times: one for
    development testing, one for staging or **user acceptance testing** (**UAT**),
    and one for production. For each server, I need to install, patch, and harden
    the operating system. Then I need to set up each type of server. The web server
    is easy, I just need to install nginx and configure it so it uses SSL, redirects
    any requests not using HTTPS, caches the static content, and reverse-proxies API
    requests to the API server running Flask.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是三个服务器，每个服务器复制三次：一个用于开发测试，一个用于预发布或**用户验收测试**（**UAT**），一个用于生产。对于每个服务器，我需要安装、打补丁和加固操作系统。然后我需要设置每种类型的服务器。Web服务器很简单，我只需要安装nginx，并配置它使用SSL，重定向任何不使用HTTPS的请求，缓存静态内容，并将API请求反向代理到运行Flask的API服务器。
- en: The Flask server is more involved since best practice calls for having nginx
    on that system as well, forwarding traffic to Green Unicorn. I’ll usually set
    up firewall rules on this server to reject any traffic not coming from the web
    server, and block any ports that are not needed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Flask服务器更为复杂，因为最佳实践要求在该系统上也要有nginx，将流量转发到Green Unicorn。我通常会在该服务器上设置防火墙规则，拒绝来自Web服务器的任何流量，并封锁任何不需要的端口。
- en: The database server is the toughest one. Ideally, I need separate partitions
    for OS, logging, and data to prevent IO performance bottlenecks. All totaled,
    it can easily take a week for me to set up and validate a small environment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库服务器是最困难的一个。理想情况下，我需要为操作系统、日志和数据分别设置分区，以防止I/O性能瓶颈。总计，仅设置和验证一个小型环境就可能需要一周时间。
- en: If I were to use IaC, I could write a script that automates setting up and tearing
    down each of the three environments. It would take just as long to write the script
    as it does to manually set everything up, but when it comes time to scale or update
    my infrastructure, having it in code will be very helpful. Since it is in the
    code, everything is documented. If I want to update the OS, say from Ubuntu 20
    to 22, I just change a variable and I can rebuild all new servers or update the
    ones I have. IaC is worth the time investment in every single case beyond a throw-away
    prototype.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要使用IaC，我可以编写一个脚本来自动设置和拆除三个环境中的每一个。编写脚本所需的时间与手动设置所有内容所需的时间一样长，但到了扩展或更新我的基础设施的时候，将其以代码的形式存在将非常有帮助。由于它在代码中，所以一切都有文档记录。如果我想更新操作系统，比如从Ubuntu
    20更新到22，我只需更改一个变量，就可以重建所有新的服务器或更新现有的服务器。在所有超出一次性原型的情况中，IaC都是值得投入时间的。
- en: One of the more popular IaC frameworks is **HashiCorp’s Terraform**. You’ll
    find plugins for the **HashiCorp language** (**HCL**) in JetBrains Marketplace
    that allow you to work with Terraform files with the usual syntax coloring and
    auto-complete functionality. Terraform is designed to help you configure virtual
    machines by way of providers. There’s a provider for VMware and that’s what converts
    your IaC into actual virtual machines. There are providers for cloud services
    too, including Azure, AWS, and Digital Ocean.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更受欢迎的IaC（基础设施即代码）框架之一是**HashiCorp的Terraform**。你可以在JetBrains市场找到针对**HashiCorp语言**（**HCL**）的插件，这些插件允许你使用常规的语法高亮和自动完成功能来处理Terraform文件。Terraform旨在通过提供程序来帮助你配置虚拟机。有针对VMware的提供程序，这就是将你的IaC转换为实际虚拟机的方式。还有针对云服务的提供程序，包括Azure、AWS和Digital
    Ocean。
- en: HashiCorp also makes a product called **Vagrant**. Vagrant is designed to be
    IaC for your local computer. I’ve been saying all along that you should use Linux
    for development if you plan to run your final application on a Linux server. But
    most people would rather not give up working on Windows or Mac. Since Mac is based
    on a Linux-like operating system, the Mac is at least close, but it won’t be identical
    if you’re running your work in Ubuntu, Red Hat, or Fedora.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp还生产一个名为**Vagrant**的产品。Vagrant旨在为你的本地计算机提供IaC。我一直在说，如果你打算在Linux服务器上运行最终应用程序，你应该使用Linux进行开发。但大多数人宁愿不放弃在Windows或Mac上工作。由于Mac基于类似Linux的操作系统，Mac至少很接近，但如果你在Ubuntu、Red
    Hat或Fedora上运行工作，它不会完全相同。
- en: Vagrant is a program that, when coupled with a local hypervisor such as VMware
    Workstation, Oracle VirtualBox, or Microsoft’s Hyper-V, allows you to create a
    script that generates a local virtual machine, called a *box*, that can match
    your production environment. Essentially you are automating the creation and maintenance
    of virtual machines on your local computer the same way you’d use Terraform for
    your servers. Vagrant does some neat things, such as automatically mapping your
    project’s folder to the virtual machine, so you don’t need to constantly copy
    your code to the VM manually. Your terminal in PyCharm is automatically connected
    to the VM using SSH, so when you execute commands you are using your local terminal
    in the IDE, but the VM is handling the execution. You could do this with **Windows
    Subsystem for Linux** (**WSL**), but there would be more effort involved and WSL
    is pretty limited in how it can be used compared to making individual VMs for
    each project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant是一个程序，当与本地虚拟机管理程序（如VMware Workstation、Oracle VirtualBox或Microsoft的Hyper-V）结合使用时，允许你创建一个脚本，该脚本可以生成一个本地虚拟机，称为*box*，它可以匹配你的生产环境。本质上，你正在以与使用Terraform为服务器的方式相同的方式自动化你在本地计算机上创建和维护虚拟机。Vagrant做一些很酷的事情，比如自动将你的项目文件夹映射到虚拟机，这样你就不需要不断手动将代码复制到虚拟机中。你的PyCharm终端会自动通过SSH连接到虚拟机，所以当你执行命令时，你实际上是在IDE中使用本地终端，但虚拟机正在处理执行。你可以使用**Windows
    Subsystem for Linux**（**WSL**）来做这件事，但会涉及更多的努力，而且与为每个项目创建单独的虚拟机相比，WSL的使用非常有限。
- en: While Vagrant is very useful, most developers are shifting to Docker for these
    kinds of workflows, but I still see developers, especially in the cybersecurity
    fields and in educational settings, still working with virtual machines. Vagrant
    has an advantage in that Docker containers are immutable, meaning they can’t be
    changed once they are created. While this is operationally superior, since immutability
    of a deployed application provides a very stable system, it might be less desirable
    for daily development since it is useful for a developer to be able to fiddle
    with the environment without restrictions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Vagrant 非常有用，但大多数开发者正在转向 Docker 来处理这类工作流程，但我仍然看到开发者，尤其是在网络安全领域和教育环境中，仍在使用虚拟机。Vagrant
    的优势在于 Docker 容器是不可变的，这意味着一旦创建就无法更改。虽然这在操作上更优越，因为部署应用的不可变性提供了一个非常稳定的系统，但对于日常开发来说可能不太理想，因为开发者需要能够不受限制地调整环境。
- en: Vagrant creates a box, which is just a virtual machine, and represents a full
    server experience with a complete operating system. You can do anything you want
    to it, and since it’s on your laptop, if your machinations break the system you
    can just kill the box and make another reset to its original state in minutes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 创建一个盒子，它只是一个虚拟机，代表了一个完整的带有完整操作系统的服务器体验。你可以对它做任何你想做的事情，而且因为它在你的笔记本电脑上，如果你的操作破坏了系统，你只需杀死盒子，然后在几分钟内将其重置到原始状态。
- en: Vagrant gives you the ability to build web applications using a real IP address
    instead of using the loopback address, also known as localhost. This provides
    local testing advantages since applications working on localhost often behave
    differently than applications bound to a real IP address. Furthermore, you can
    choose to make your Vagrant box’s IP address shareable not only on the local network
    but also on the public internet. When you’re ready to show off your progress,
    you can invite others to your shared Vagrant box, elicit feedback, and then turn
    sharing off.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 允许你使用真实 IP 地址而不是使用回环地址（也称为 localhost）来构建 Web 应用程序。这提供了本地测试的优势，因为通常在
    localhost 上运行的应用程序的行为与应用程序绑定到真实 IP 地址时的行为不同。此外，你可以选择使你的 Vagrant 盒子的 IP 地址不仅可在本地网络中共享，也可在公共互联网上共享。当你准备好展示你的进展时，你可以邀请他人访问你的共享
    Vagrant 盒子，获取反馈，然后关闭共享。
- en: You’ll find the tooling for Vagrant in the **Tools** menu shown in *Figure 16**.2*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在显示在 *图 16.2* 中的 *工具* 菜单中找到 Vagrant 的工具。
- en: '![Figure 16.2: PyCharm supports all the Vagrant commands directly via menu
    options](img/B19644_16_002.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.2：PyCharm 可以直接通过菜单选项支持所有 Vagrant 命令](img/B19644_16_002.jpg)'
- en: 'Figure 16.2: PyCharm supports all the Vagrant commands directly via menu options'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2：PyCharm 可以直接通过菜单选项支持所有 Vagrant 命令
- en: In order to use Vagrant, you need to install it along with a supported hypervisor.
    You can find the installation instructions at [https://developer.hashicorp.com/vagrant/tutorials/getting-started/getting-started-install](https://developer.hashicorp.com/vagrant/tutorials/getting-started/getting-started-install).
    As for the hypervisor, the default is Oracle VirtualBox. You can find more about
    VirtualBox at [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Vagrant，你需要安装它以及一个受支持的虚拟机管理程序。你可以在 [https://developer.hashicorp.com/vagrant/tutorials/getting-started/getting-started-install](https://developer.hashicorp.com/vagrant/tutorials/getting-started/getting-started-install)
    找到安装说明。至于虚拟机管理程序，默认是 Oracle VirtualBox。你可以在 [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)
    找到更多关于 VirtualBox 的信息。
- en: Once you have these programs installed you can use the **Init in Project Root**
    option shown in *Figure 16**.2*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了这些程序，你就可以使用显示在 *图 16.2* 中的 *在项目根目录中初始化* 选项。
- en: This will prompt you to create a file called `Vagrantfile` at the root of your
    project by selecting a name for your Vagrant box and providing the image URL.
    The dialog is shown in *Figure 16**.3*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示你通过选择你的 Vagrant 盒子的名称并提供镜像 URL，在项目的根目录下创建一个名为 `Vagrantfile` 的文件。对话框显示在 *图
    16.3* 中。
- en: '![Figure 16.3: You are prompted to create a Vagrant box with a very old default](img/B19644_16_003.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.3：你被提示创建一个带有非常旧默认设置的 Vagrant 盒子](img/B19644_16_003.jpg)'
- en: 'Figure 16.3: You are prompted to create a Vagrant box with a very old default'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3：你被提示创建一个带有非常旧默认设置的 Vagrant 盒子
- en: It is clear that this is a very old default since `lucid32` refers to Ubuntu
    10\. At the time of writing, the current version of Ubuntu is 23 while the long-term
    support edition is 22.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这是一个非常旧的默认设置，因为 `lucid32` 指的是 Ubuntu 10。在撰写本文时，Ubuntu 的当前版本是 23，而长期支持版本是
    22。
- en: You should probably find a newer box definition if you’re serious about using
    a more current virtual machine. You can find box definitions at [https://app.vagrantup.com](https://app.vagrantup.com).
    I’ve done this in *Figure 16**.4* where I’ve searched for `Jammy Jellyfish`, the
    project codename for **Ubuntu 22**, which is what I use for all my current production
    projects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认真想要使用更先进的虚拟机，你可能需要找到一个更新的box定义。你可以在[https://app.vagrantup.com](https://app.vagrantup.com)找到box定义。我在*图16.4*中这样做，我搜索了“Jammy
    Jellyfish”，这是**Ubuntu 22**的项目代号，我目前所有生产项目都在使用它。
- en: '![Figure 16.4: You can find a wide variety of predefined boxes on the Vagrant
    Cloud registry](img/B19644_16_004.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4：你可以在Vagrant Cloud注册表中找到各种预定义的box](img/B19644_16_004.jpg)'
- en: 'Figure 16.4: You can find a wide variety of predefined boxes on the Vagrant
    Cloud registry'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：你可以在Vagrant Cloud注册表中找到各种预定义的box
- en: Once you find one you want to use, click on it. In *Figure 16**.5*, I’m clicking
    on the second entry in the list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到你想要使用的，点击它。在*图16.5*中，我正在点击列表中的第二个条目。
- en: '![Figure 16.5: This is the box definition for Ubuntu Jammy 64](img/B19644_16_005.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5：这是Ubuntu Jammy 64的box定义](img/B19644_16_005.jpg)'
- en: 'Figure 16.5: This is the box definition for Ubuntu Jammy 64'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：这是Ubuntu Jammy 64的box定义
- en: Now that we have a box definition, refer back to *Figure 16**.3*. In the first
    field, you need to type the box name indicated by the dark arrow in *Figure 16**.5*,
    which is `ubuntu/jammy64`. Next, copy the name of the box definition’s URL, indicated
    by the light arrow in *Figure 16**.5*, which in our case is [https://app.vagrantup.com/ubuntu/boxes/jammy64](https://app.vagrantup.com/ubuntu/boxes/jammy64).
    Clicking **OK** will download the box image and create the VM. Once it is ready,
    you’ll find the rest of the Vagrant tools are no longer grayed out in the menu
    as shown in *Figure 16**.6*. The generated Vagrantfile is open (not automatically,
    I did that), and you can even see that PyCharm is prompting me to add the new
    file to the Git repository.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了box定义，请参考*图16.3*。在第一个字段中，你需要输入*图16.5*中由深色箭头指示的box名称，即`ubuntu/jammy64`。接下来，复制box定义URL的名称，由*图16.5*中的浅色箭头指示，在我们的例子中是[https://app.vagrantup.com/ubuntu/boxes/jammy64](https://app.vagrantup.com/ubuntu/boxes/jammy64)。点击**确定**将下载box镜像并创建虚拟机。一旦准备好，你会在菜单中看到Vagrant的其他工具选项不再被灰色显示，如*图16.6*所示。生成的Vagrantfile是打开的（不是自动的，是我手动做的），你甚至可以看到PyCharm在提示我添加新文件到Git仓库。
- en: '![Figure 16.6: The Vagrant tool options are now available](img/B19644_16_006.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6：Vagrant工具选项现在可用](img/B19644_16_006.jpg)'
- en: 'Figure 16.6: The Vagrant tool options are now available'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：Vagrant工具选项现在可用
- en: If you dive more deeply into using Vagrant, you’ll find that like many of PyCharm’s
    integrations, the IDE gives you a graphical way to perform what would otherwise
    be a command-line workflow. You can run the commands using the menu in *Figure
    16**.6*, or you can type the commands in your terminal to achieve the same result.
    Packt has some good books on developing with Vagrant. I’ll be sure to leave a
    few suggestions in the *Further reading* section of this chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更深入地使用Vagrant，你会发现，就像PyCharm的许多集成一样，IDE提供了一个图形界面来执行原本可能需要命令行工作流程的操作。你可以使用*图16.6*中的菜单运行命令，或者你可以在终端中输入命令以实现相同的结果。Packt有一些关于使用Vagrant开发的优秀书籍。我会在本章的*进一步阅读*部分留下一些建议。
- en: There are some big benefits to using Vagrant. You can have your whole development
    team use identical environments for developing and testing your application using
    the same environment you’ll use in production. No more “*It works on my machine*”,
    which implies the code is fine and a configuration issue is to blame. Since the
    environment configuration is standardized, and maintained as part of the code
    base, the project should work the same everywhere assuming the code and any external
    configuration files (such as `.ini` or `.env` files) or environment variables
    are also identical.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vagrant有一些显著的优点。你可以让整个开发团队使用相同的开发环境来开发和测试你的应用程序，这个环境就是你将在生产中使用的环境。不再有“*在我的机器上它运行正常*”的情况，这暗示代码是好的，配置问题是罪魁祸首。由于环境配置是标准化的，并且作为代码库的一部分进行维护，只要代码和任何外部配置文件（如`.ini`或`.env`文件）或环境变量也是相同的，项目应该在任何地方都能正常工作。
- en: Using IaC in Vagrant shields less experienced developers who don’t know how
    to set up virtual machines, and it also standardizes the build so everybody’s
    VM is the same. The configuration is tracked in your revision control system and
    so it tracks and updates just like application code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vagrant中使用IaC可以保护那些不知道如何设置虚拟机的经验不足的开发者，并且它还标准化了构建，使得每个人的虚拟机都是相同的。配置在版本控制系统中跟踪，因此它就像应用程序代码一样跟踪和更新。
- en: Tracking your time
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪你的时间
- en: Over the course of my long career, I’ve worked for the United States Government
    on several occasions, and I’ve run my own freelancing practice. In each case,
    I’ve needed a way to track my time. In the case of government contracts, I have
    to track a set of billing codes down to 7-minute intervals. Time tracking can
    be used in more reasonable environments as well. I try to keep time-tracking data
    to correlate the ever-elusive story point used in agile development methodologies
    such as Scrum with how much time it will take to complete a task. According to
    most agile methodologies, people are really bad at estimating time. But they are
    pretty good at estimating relative size. In *Figure 16**.3*, you would have a
    hard time telling exactly how tall, in inches or centimeters, the soy milk carton
    is next to the cup of latte.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我漫长的职业生涯中，我多次为美国政府工作，并且我经营着自己的自由职业实践。在每种情况下，我都需要一种跟踪时间的方法。在政府合同的情况下，我必须将一组计费代码跟踪到7分钟间隔。时间跟踪也可以在更合理的环境中应用。我试图将时间跟踪数据与敏捷开发方法（如Scrum）中使用的难以捉摸的故事点与完成任务所需的时间相关联。根据大多数敏捷方法，人们真的很擅长估计相对大小。但在*图16**.3*中，你很难准确地告诉豆浆盒相对于咖啡杯的高度，是英寸还是厘米。
- en: '![Figure 16.7: How tall is the soy milk carton?](img/B19644_16_007.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图16.7：豆浆盒有多高？](img/B19644_16_007.jpg)'
- en: 'Figure 16.7: How tall is the soy milk carton?'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：豆浆盒有多高？
- en: Is it 8 inches tall or 20? But if you try estimating the size using the coffee
    cup as your unit of measure, you can be more precise. The carton is about two
    and a half coffee cups tall. So it is with story points, but at the end of the
    day, the boss really wants to know how long something will take. You can’t tell
    her you’ll have her feature done in two coffee cups and expect her to be happy
    about it. This could invite the obvious reply, “Great, so it will be done after
    my second cup of coffee!”
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它是8英寸高还是20英寸？但如果尝试使用咖啡杯作为你的度量单位来估计大小，你可以更加精确。纸箱大约有二又四分之一咖啡杯高。故事点也是如此，但最终，老板真正想知道某件事需要多长时间。你不能告诉她你将在两杯咖啡后完成她的功能，并期望她对此感到高兴。这可能会引起明显的回应，“太好了，那么它将在我的第二杯咖啡之后完成！”
- en: I do my normal story point estimate, then I track my time to see how long it
    really took so I can both give the boss her answer and be better at estimating
    next time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我先进行正常的故事点估计，然后跟踪我的时间，看看实际花了多长时间，这样我既可以给老板一个答复，也可以在下次估计时做得更好。
- en: To use the time tracking features in PyCharm, you need to connect to a server.
    By server, in this case, I mean one of the project tracking services supported
    by PyCharm, as shown in *Figure 16**.4*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用PyCharm中的时间跟踪功能，你需要连接到服务器。在这里，服务器指的是PyCharm支持的项目跟踪服务之一，如*图16**.4*所示。
- en: '![Figure 16.8: Click the Configure Servers menu item to configure your project
    tracker](img/B19644_16_008.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8：点击“配置服务器”菜单项来配置你的项目跟踪器](img/B19644_16_008.jpg)'
- en: 'Figure 16.8: Click the Configure Servers menu item to configure your project
    tracker'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：点击“配置服务器”菜单项来配置你的项目跟踪器
- en: When you click this menu item, you should see the screen shown in *Figure 16**.5*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击这个菜单项时，你应该会看到*图16**.5*所示的屏幕。
- en: '![Figure 16.9: Pick whichever project tracking service you use from the list](img/B19644_16_009.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图16.9：从列表中选择你使用的任何项目跟踪服务](img/B19644_16_009.jpg)'
- en: 'Figure 16.9: Pick whichever project tracking service you use from the list'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：从列表中选择你使用的任何项目跟踪服务
- en: 'Once your server is registered, you’ll be able to pick a backlog item or issue
    that is assigned to you. *Figure 16**.6* shows my YouTrack server integration
    with the issue number **DEMO-20: Finish** [*Chapter 16*](B19644_16.xhtml#_idTextAnchor401)
    **in** **PyCharm Book**.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦你的服务器注册成功，你将能够选择分配给你的待办事项或问题。*图16**.6*展示了我的YouTrack服务器与**PyCharm Book**中的问题编号**DEMO-20:
    完成**[*第16章*](B19644_16.xhtml#_idTextAnchor401)的集成。'
- en: '![Figure 16.10: The time I’ve spent on this issue is automatically tracked](img/B19644_16_010.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10：我在这项问题上的时间自动跟踪](img/B19644_16_010.jpg)'
- en: 'Figure 16.10: The time I’ve spent on this issue is automatically tracked'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：我在这件事上花费的时间会自动跟踪
- en: As you switch between tasks throughout the day, you can switch from right in
    your IDE, which will track how much time you spend on each task. You can then
    synchronize your work times up to the server to keep an accurate tally of how
    you are spending your time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在你一天中切换任务时，你可以在IDE中切换，它会跟踪你在每个任务上花费的时间。然后你可以将你的工作时间同步到服务器，以保持你时间花费的准确统计。
- en: TODO list
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TODO列表
- en: This may sound like it is related to the time tracking feature, but it really
    isn’t. The TODO list panel shows you all those TODO comments in your code as a
    list. You can see an example in *Figure 16**.7*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能和时间跟踪功能有关，但实际上并没有。TODO列表面板以列表形式显示你代码中的所有TODO注释。你可以在图16.7中看到一个示例。
- en: '![Figure 16.11: The TODO panel in PyCharm lists all the to-do comments in your
    code and takes you right to the given line when you double-click](img/B19644_16_011.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图16.11：PyCharm中的TODO面板列出了你代码中的所有待办事项，并在你双击时直接跳转到指定行](img/B19644_16_011.jpg)'
- en: 'Figure 16.11: The TODO panel in PyCharm lists all the to-do comments in your
    code and takes you right to the given line when you double-click'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：PyCharm中的TODO面板列出了你代码中的所有待办事项，并在你双击时直接跳转到指定行
- en: You can double-click the TODO item to go right to that line in the code, allowing
    you to quickly find your way back to whatever you had to temporarily abandon.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以双击TODO项直接跳转到代码中的该行，这样你可以快速找到你之前暂时放弃的地方。
- en: Macros
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏
- en: A macro is a script of recorded keystrokes that can be played back in order
    to create useful automation. In my opinion, learning to use these is a necessary
    survival skill in the jungles of software development.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是一系列记录的按键脚本，可以按顺序回放以创建有用的自动化。在我看来，学会使用这些是软件开发丛林中的必要生存技能。
- en: Let’s say we need a list of things that don’t change to populate a drop-down
    list box in HTML. For this example, I’m going to create a `SELECT` tag with all
    50 states of the US. This is something that hasn’t changed since 1959, although
    if I’m ever elected Emperor, Canada and Mexico are first on my list. They’ll never
    see it coming.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要一个不改变的物品列表来填充HTML中的下拉列表框。在这个例子中，我将创建一个包含美国所有50个州的`SELECT`标签。自1959年以来，这并没有改变，尽管如果我当选皇帝，加拿大和墨西哥将是我名单上的第一个，他们永远不会想到这一点。
- en: Back in reality, I need to get this done and I darn sure don’t want to type
    all this out. I asked my best friend ChatGPT to give me a list of the 50 states
    in alphabetical order. The result is in the `us-states.txt` file in the chapter
    source.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，我需要完成这项工作，而且我绝对不想手动输入所有这些。我向我的好朋友ChatGPT请求给我一个按字母顺序排列的50个州的列表。结果在章节源代码的`us-states.txt`文件中。
- en: 'You’ll also find an HTML file called `states.html` in the source. I’ve included
    the code as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会在源代码中找到一个名为`states.html`的HTML文件。我已经包含了以下代码：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, there is nothing in the `<select>` tag, which is meant to render
    a drop-down selection list in the HTML page defined by the rest of the code in
    that file. I need to add the states so they look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`<select>`标签中没有内容，它旨在在由该文件中其余代码定义的HTML页面中渲染下拉选择列表。我需要添加州名，使它们看起来像这样：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And so on for all 50\. I can do this with a macro. Sure, I could also just have
    ChatGPT generate it for me, but that would be anti-climactic since this is a book
    on PyCharm and not a book on ChatGPT.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这50个州，我可以使用宏来完成。当然，我也可以让ChatGPT为我生成它，但那样就没有悬念了，因为这是一本关于PyCharm的书，而不是关于ChatGPT的书。
- en: Open the project called `feature_demo` in the chapter source code, then open
    the `united-states.txt file`. Start by placing your cursor in front of `Alabama`
    in the `united-states.txt` file, as shown in *Figure 16**.9*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 打开章节源代码中的`feature_demo`项目，然后打开`united-states.txt`文件。首先，将光标放在`united-states.txt`文件中的`Alabama`前面，如图16.9所示。
- en: '![Figure 16.12: Put your cursor in front of Alabama](img/B19644_16_012.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图16.12：将光标放在阿拉巴马州前面](img/B19644_16_012.jpg)'
- en: 'Figure 16.12: Put your cursor in front of Alabama'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12：将光标放在阿拉巴马州前面
- en: Next, click **Edit | Macro | Start Macro Recording** as seen in *Figure 16**.10*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击**编辑 | 宏 | 开始宏录制**，如图16.10所示。
- en: '![Figure 16.13: Start recording your macro](img/B19644_16_013.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图16.13：开始录制你的宏](img/B19644_16_013.jpg)'
- en: 'Figure 16.13: Start recording your macro'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13：开始录制宏
- en: With the macro recording, type `<option>`. Then hit the *End* (*Cmd + Right
    Arrow* on a Mac) key on your keyboard to go to the end of the line, then type
    `</option>`. Press the *down arrow* key on your keyboard, followed by the *Home*
    key (*Cmd + Left Arrow* on Mac). The cursor should now be at the beginning of
    the second line, `Arkansas`. Go back to the same menu item shown in *Figure 16**.10*,
    but note `option-list`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏录制时，输入 `<option>`。然后按键盘上的 *End* 键（在 Mac 上为 *Cmd + 右箭头*）到达行尾，然后输入 `</option>`。按键盘上的
    *下箭头* 键，接着按 *Home* 键（在 Mac 上为 *Cmd + 左箭头*）。此时光标应位于第二行开头，`Arkansas`。回到 *图 16**.10*
    中显示的相同菜单项，但请注意 `option-list`。
- en: Return to the menu shown in *Figure 16**.10* again and you’ll see either your
    saved macro name listed or just `Arkansas` to an `option` tag.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到 *图 16**.10* 中显示的菜单，您将看到保存的宏名称列表，或者只是一个 `Arkansas` 到 `option` 标签的 `Arkansas`。
- en: You can map your macro to a key combination and repeat your actions with a keyboard
    shortcut, making it easy to do over and over.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将宏映射到键盘快捷键组合，并通过键盘快捷键重复执行操作，这使得重复执行变得非常容易。
- en: If I’m being honest, the macro feature in PyCharm is okay, but it isn’t as good
    as in some other tools. Ultraedit and Notepad++, while not IDEs, both have very
    sophisticated macro features such as the ability to replay a macro until it reaches
    the end of the file, or to run the macro a specific number of times. PyCharm’s
    macros are fine for small jobs, but for bigger ones you might look to other tools.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我坦白的话，PyCharm 中的宏功能还不错，但并不像某些其他工具那样出色。虽然 Ultraedit 和 Notepad++ 都不是 IDE，但它们都拥有非常复杂的宏功能，例如能够回放宏直到文件末尾，或者运行特定次数的宏。PyCharm
    的宏对于小任务来说足够好了，但对于更大的任务，您可能需要考虑其他工具。
- en: Notifications
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知
- en: Sometimes PyCharm will present notifications as toast windows in the lower-right
    corner of the screen. These messages will usually disappear within a few seconds,
    but you can see them in the notifications panel. You’ll find this panel on the
    right-hand toolbar, as seen in *Figure 16**.11*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 PyCharm 会在屏幕右下角以托盘的形式显示通知。这些消息通常会在几秒钟内消失，但您可以在通知面板中看到它们。您可以在右侧工具栏中找到这个面板，如图
    *图 16**.11* 所示。
- en: '![Figure 16.14: The notifications panel](img/B19644_16_014.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.14：通知面板](img/B19644_16_014.jpg)'
- en: 'Figure 16.14: The notifications panel'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.14：通知面板
- en: You can toggle the panel by clicking the *bell* icon on the right-hand toolbar.
    The panel has a **Timeline** option that allows you to list notifications by recency.
    You can choose to dismiss any notifications you no longer need, or clear them
    all.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击右侧工具栏上的 *铃铛* 图标来切换面板。面板有一个 **时间线** 选项，允许您按时间顺序列出通知。您可以选择删除不再需要的任何通知，或者清除所有通知。
- en: New features in 2023.2
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2023.2 的新功能
- en: 'During the course of writing this book, a lot has changed, especially in the
    UI. I used build #PY-231.8109.197, or as I like to call it, *the fightin’ 197th*.
    I kept the same release in play for the entire time, neglecting to install any
    updates because I wanted things to be consistent. Right about the time I started
    working on [*Chapter 13*](B19644_13.xhtml#_idTextAnchor318), JetBrains held an
    online event revealing a new point release, 2023.2\. The new release is packed
    with new features, but today as I write [*Chapter 16*](B19644_16.xhtml#_idTextAnchor401)
    (this chapter), two more point releases have come out. This pace is probably due
    in large part to JetBrain’s re-vamp of the UI. If you remember at the beginning
    of the book, we had to turn the “new UI” on in the settings. By the time you read
    this, the new UI will be the default. JetBrains didn’t stop there. The UI has
    always been highly configurable, and we covered that thoroughly in the early chapters
    of this book.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '在撰写本书的过程中，许多事情都发生了变化，尤其是在 UI 方面。我使用了构建号 #PY-231.8109.197，或者像我喜欢叫的，*战斗的 197
    号*。我整个过程中都保持了相同的版本，没有安装任何更新，因为我希望保持一致性。大约在我开始编写 [*第 13 章*](B19644_13.xhtml#_idTextAnchor318)
    的时候，JetBrains 举办了一场在线活动，公布了新的点版本，2023.2。这个新版本包含了大量新功能，但今天当我写 [*第 16 章*](B19644_16.xhtml#_idTextAnchor401)（本章）时，又推出了两个点版本。这种速度可能很大程度上归因于
    JetBrain 对 UI 的重新设计。如果你记得本书开头，我们不得不在设置中打开“新 UI”。等你读到这本书的时候，新 UI 将成为默认设置。JetBrains
    没有止步于此。UI 一直都可以高度自定义，我们在本书的前几章中对此进行了详细阐述。'
- en: One of the main pushes in the new UI effort has been to streamline the development
    process. Most IDEs go through a cycle of growth where they start with a simple
    and focused UI that integrates the minimal features needed to be considered an
    IDE versus an enhanced text editor. Over time, more and more features are added
    with the aim of giving you a tool that does everything you might need. It occurred
    to me just the other day that on days when I am 100% focused on Python development,
    or even JavaScript, web, or database development, all I’d really need is a lightweight
    OS and PyCharm. I wouldn’t even need a window manager beyond what is needed to
    run PyCharm!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 新用户界面努力的主要推动之一是简化开发过程。大多数IDE都会经历一个增长周期，它们从一个简单且专注的UI开始，集成了被视为IDE而非增强型文本编辑器所需的最小功能。就在前几天，我突然想到，在我100%专注于Python开发，或者甚至是JavaScript、Web或数据库开发的日子里，我真正需要的可能只是一个轻量级的操作系统和PyCharm。甚至不需要比运行PyCharm所需的更多的窗口管理器！
- en: The problem caused by the richness of such a tool is it becomes daunting for
    new users, and disorganized for veteran users. We learned in [*Chapter 15*](B19644_15.xhtml#_idTextAnchor379)
    that most new features of any JetBrains IDE are implemented as plugins. This can
    lead to a disorganized UI and it can make the IDE feel like it is a bunch of unrelated
    pieces cobbled together in a sub-optimal overall user experience.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个工具的丰富性带来的问题是，它对于新用户来说可能令人望而生畏，对于老用户来说则显得杂乱无章。我们在[*第15章*](B19644_15.xhtml#_idTextAnchor379)中学到，任何JetBrains
    IDE的新功能都是作为插件实现的。这可能导致UI杂乱无章，并使IDE感觉像是一堆无关的碎片拼凑在一起，用户体验不佳。
- en: The new UI aims to take care of this by compacting the UI, exposing the most
    commonly used tools and hiding (but not removing) the more complicated options.
    The build I used for the book did this very well. As newer point releases come
    out, I’m noticing further efforts to hide complexitity. Take look at *Figure 16**.13*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 新的UI旨在通过压缩UI，展示最常用的工具，并隐藏（但不是删除）更复杂的选项来解决这个问题。我用于书籍的构建版本做得非常好。随着新的点版本发布，我注意到进一步的努力来隐藏复杂性。看看*图16.13*。
- en: '![Figure 16.15: JetBrains has moved a lot of settings into tags instead of
    having dozens of checkboxes](img/B19644_16_015.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图16.15：JetBrains已经将许多设置移动到标签中，而不是有几十个复选框](img/B19644_16_015.jpg)'
- en: 'Figure 16.15: JetBrains has moved a lot of settings into tags instead of having
    dozens of checkboxes'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15：JetBrains已经将许多设置移动到标签中，而不是有几十个复选框
- en: 'This is a run configuration from the latest update released only days ago,
    labeled as Build #PY-232.9559.58 built August 22, 2023\. There are two visible
    differences. There is a set of tags at the bottom and a **Modify Options** dropdown
    both indicated by arrows in *Figure 16**.13*. Compare this to *Figure 16**.14*.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从最近几天发布的最新更新中提取的运行配置，标记为构建号#PY-232.9559.58，构建于2023年8月22日。有两个明显的不同之处。底部有一组标签，以及一个**修改选项**下拉菜单，两者都在*图16.13*中用箭头指示。与*图16.14*进行比较。
- en: '![Figure 16.16: This is the old dialog from Chapter 3](img/B19644_16_016.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图16.16：这是第3章的旧对话框](img/B19644_16_016.jpg)'
- en: 'Figure 16.16: This is the old dialog from [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16：这是[*第3章*](B19644_03.xhtml#_idTextAnchor052)的旧对话框
- en: All those options are still there, but they’ve been rolled up into the **Modify
    Options** dropdown. The settings you’ve actually used appear as tags at the bottom
    of *Figure 16**.13*. The amount of change over only a few months is staggering!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有那些选项仍然存在，但它们已经被整合到**修改选项**下拉菜单中。你实际使用的设置作为标签出现在*图16.13*的底部。仅仅几个月的变化量是惊人的！
- en: In addition to product changes, there are some interesting new feature additions
    and improvements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了产品变化之外，还有一些有趣的新功能添加和改进。
- en: Black integration
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Black集成
- en: First presented at PyCon 2019, Black is an uncompromising code formatter. It
    has gained a great deal of attention and popularity since its release, and JetBrains
    has added support to PyCharm. Black needs to be installed in order for this feature
    to work. You can find details on installation and more at [https://github.com/psf/black](https://github.com/psf/black).
    If you are using Linux, check your package manager. I use Pop_OS, which is based
    on Ubuntu. *Figure 16**.15* shows I’ve found Black as a package and I prefer to
    install it that way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Black首次在PyCon 2019上推出，是一个不妥协的代码格式化器。自从发布以来，它已经获得了极大的关注和人气，JetBrains也为PyCharm添加了支持。为了使此功能正常工作，需要安装Black。你可以在[https://github.com/psf/black](https://github.com/psf/black)上找到有关安装的详细信息。如果你使用Linux，检查你的包管理器。我使用基于Ubuntu的Pop_OS。*图16.15*显示我已经找到了Black作为包，并且我更喜欢以这种方式安装它。
- en: '![Figure 16.17: In Linux, you can probably install Black using your package
    manager](img/B19644_16_017.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图16.17：在Linux中，你很可能会使用你的包管理器来安装Black](img/B19644_16_017.jpg)'
- en: 'Figure 16.17: In Linux, you can probably install Black using your package manager'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17：在Linux中，你很可能会使用你的包管理器来安装Black
- en: Once Black is installed, you need to turn it on on a per-project basis. You’ll
    find this option when you search for Black in the **Settings** dialog shown in
    *Figure 16**.16*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Black，你需要根据每个项目来开启它。当你搜索图16.16中显示的**设置**对话框中的Black时，你会找到这个选项。
- en: '![Figure 16.18: Search for Black in the Settings dialog and you’ll find it
    under Tools](img/B19644_16_018.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图16.18：在设置对话框中搜索Black，你会在工具下找到它](img/B19644_16_018.jpg)'
- en: 'Figure 16.18: Search for Black in the Settings dialog and you’ll find it under
    Tools'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18：在设置对话框中搜索Black，你会在工具下找到它
- en: Your options for formatting are `development`. On my team, we individually branch
    off development into feature branches. If I’m working on some new feature, I’ll
    branch off `development` and make a new branch called `feature/amazing-thing`.
    Next, I’ll create my amazing thing, but I’ll need to touch some other files written
    by other developers along the way. Naturally, before I commit, muscle memory automatically
    uses the *Ctrl* + *Alt* + *L* (reformat code) command to reformat. Black will
    reformat the whole file. When you go to merge, you may find other developers have
    changed some of the same files you re-formatted, but they were less conscientious
    about reformatting. You are presented with the challenge of an ugly merge even
    if there were only a few lines actually changed between the two developers, and
    they might not have otherwise collided.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你的格式化选项是`开发`。在我的团队中，我们每个人都会从`开发`分支创建特性分支。如果我正在开发一些新功能，我会从`开发`分支分出一个新分支，命名为`feature/amazing-thing`。接下来，我将创建我的神奇事物，但在这个过程中，我需要修改其他开发者编写的一些文件。自然地，在我提交之前，肌肉记忆会自动使用*Ctrl*
    + *Alt* + *L*（重新格式化代码）命令来重新格式化。Black会重新格式化整个文件。当你去合并时，你可能会发现其他开发者已经更改了你重新格式化的某些文件，但他们不太注意重新格式化。即使两个开发者之间实际上只更改了几行，你仍然可能会面临一个丑陋的合并挑战。
- en: This is no fault of the Black formatter! The same thing will happen if you use
    PyCharm’s default code formatter. The Black formatter, though, is a better solution
    since it aims for determinism, which is a fancy coder word that means the results
    of an operation always produce the same output. A non-compromising deterministic
    formatter should yield very consistent results every time it is used.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是Black格式化器的错！如果你使用PyCharm的默认代码格式化器，同样的事情也会发生。然而，Black格式化器是一个更好的解决方案，因为它旨在实现确定性，这是一个复杂的程序员术语，意味着操作的结果总是产生相同的输出。一个不妥协的确定性格式化器应该每次使用时都产生非常一致的结果。
- en: My advice, then, if you want to start using Black is to get together as a team.
    Have everyone push their work, merge it into a branch, and then apply Black to
    the whole project. In my example, I would resolve my conflicts, and then merge
    back into the development branch. Then I would have all my colleagues do the same.
    Once development has everyone’s changes, freeze the code and use Black on all
    your source files. During the freeze, nobody is allowed to work on any individual
    file until the formatting has been applied and pushed. If you have a very large
    code base, you might have to organize your efforts over time. The results will
    be worth it! Your code will be PEP-8 compliant, and you should see fewer merge
    conflicts, especially those caused by formatting.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想要开始使用 Black，我的建议是作为一个团队一起行动。让每个人都推送他们的工作，将其合并到一个分支中，然后对整个项目应用 Black。在我的例子中，我会解决我的冲突，然后合并回开发分支。然后我会让所有同事都这样做。一旦开发阶段包含了每个人的更改，冻结代码，并在所有源文件上应用
    Black。在冻结期间，不允许任何人单独工作，直到格式化被应用并推送。如果你有一个非常大的代码库，你可能需要分阶段组织你的工作。结果将是值得的！你的代码将符合
    PEP-8 标准，你应该会看到更少的合并冲突，尤其是那些由格式化引起的。
- en: Black can be configured to run on save, and beyond the scope of PyCharm, Black
    can be used as a hook in your revision control, as well as in your CI/CD process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Black 可以配置在保存时运行，并且超出 PyCharm 的范围，Black 可以作为你的版本控制或 CI/CD 流程中的一个钩子。
- en: GitLab integration
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab 集成
- en: GitHub is easily the most popular and widely used cloud-based solution for managing
    code. Its Achilles heel is the fact that it is cloud-based. Organizations that
    are serious about security, such as those whose trading partners require a certification
    such as the **Service Organization Control 2** (**SOC2**) certification are often
    not satisfied with their intellectual property being hosted on a publicly available
    platform. While it’s true you can host private repositories on GitHub, the mere
    fact that the files are not on a server controlled by the certified organization
    can be a problem.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 是管理代码最流行和最广泛使用的基于云的解决方案。它的阿喀琉斯之踵在于它是基于云的。对于像那些要求其贸易伙伴获得认证（如 **服务组织控制
    2**（**SOC2**）认证）的严肃组织来说，他们的知识产权托管在公开可用的平台上通常是不满意的。虽然你可以在 GitHub 上托管私有仓库，但仅仅因为文件不在由认证组织控制的服务器上，就可能成为一个问题。
- en: Thankfully, it is possible to host your own private GitHub server using GitLab.
    You can run GitLab on-premises behind your firewall and exercise total control
    over your security and infrastructure while still using what is in every other
    sense, the GitHub experience. You’ll find GitLab integration in the **Version
    Control** settings as shown in *Figure 16**.17*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用 GitLab 来托管自己的私有 GitHub 服务器。你可以在防火墙后面运行 GitLab，同时对你的安全和基础设施拥有完全的控制权，同时仍然享受到在所有其他方面都相同的
    GitHub 体验。你将在 *图 16.17* 中的 **版本控制** 设置中找到 GitLab 集成。
- en: '![Figure 16.19: GitLab settings can be found alongside the other VCS settings](img/B19644_16_019.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.19：GitLab 设置可以与其他 VCS 设置一起找到](img/B19644_16_019.jpg)'
- en: 'Figure 16.19: GitLab settings can be found alongside the other VCS settings'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.19：GitLab 设置可以与其他 VCS 设置一起找到
- en: The integration is fairly deep. Beyond the basics we covered in [*Chapter 5*](B19644_05.xhtml#_idTextAnchor112),
    you can handle all your pull requests, approvals, and more right from the IDE.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 集成相当深入。除了我们在 [*第 5 章*](B19644_05.xhtml#_idTextAnchor112) 中介绍的基本内容之外，你还可以直接从
    IDE 中处理所有你的拉取请求、审批等。
- en: Run anywhere
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行任何地方
- en: We’ve had **Search everywhere** for quite a while. In case you missed it, you
    can double-tap the **Shift** key and get a dialog that allows you to find anything
    anywhere in your project. This works even if what you’re looking for isn’t in
    code. It could be in documentation, settings, or elsewhere.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一段时间的 **全局搜索** 功能了。如果你错过了它，你可以双击 **Shift** 键，打开一个对话框，让你在项目中找到任何地方的内容。即使你要找的东西不在代码中，这也同样适用。它可能是在文档、设置或其他地方。
- en: New to PyCharm, though not necessarily new to IntelliJ is `?`) in the dialog.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 PyCharm 对于新手来说可能不是新手，但在对话框中按 `?`) 是一个新功能。
- en: '![Figure 16.20: Double-tap the Ctrl key to bring up the Run Anything dialog](img/B19644_16_020.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.20：双击 Ctrl 键以打开“运行任何内容”对话框](img/B19644_16_020.jpg)'
- en: 'Figure 16.20: Double-tap the Ctrl key to bring up the Run Anything dialog'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.20：双击 Ctrl 键以打开“运行任何内容”对话框
- en: It’s nice enough to say, “*You can run ANYTHING!”* But all you critical thinkers
    out there will immediately follow up with, *“What do you mean by ANYTHING?”* Here,
    the answer to my question mark tells me what can be run. I can see I can run any
    Python script in my project by simply typing its name. I can see I can run `pip`
    and `conda` commands as well. Web developers can run the HTTP request test code
    we covered in [*Chapter 9*](B19644_09.xhtml#_idTextAnchor223). They can also run
    all the popular package managers such as `package.json` file via npm, which is
    visibly supported. Naturally, we can also run any **Node** process as easily as
    we can run Python.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 说出“*你可以运行任何东西！”*已经足够好了。但所有那些批判性思考者会立即追问，“你说的‘任何东西’是什么意思？”在这里，我对问号的回答告诉我可以运行什么。我可以看到，我可以通过简单地输入其名称来运行项目中的任何Python脚本。我可以看到，我也可以运行`pip`和`conda`命令。Web开发者可以运行我们在[*第9章*](B19644_09.xhtml#_idTextAnchor223)中介绍的HTTP请求测试代码。他们还可以通过npm运行所有流行的包管理器，例如`package.json`文件，这是明显支持的。当然，我们也可以像运行Python一样轻松地运行任何**Node**进程。
- en: AI Assistant
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AI助手
- en: The show stealer at most of the recent events featuring PyCharm is the AI Assistant.
    As I write this, the feature is in closed beta, meaning you have to sign up and
    be approved in order to try out the feature. Bear in mind that anything I show
    here will probably change.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近许多PyCharm相关活动中，抢尽风头的无疑是AI助手。当我写这篇文章时，该功能处于封闭测试阶段，这意味着您必须注册并获得批准才能尝试该功能。请记住，这里展示的任何内容都可能发生变化。
- en: The easiest thing to implement, and there are numerous plugins that do this,
    is to just provide an integrated frontend experience for some online AI API.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易实现的事情，而且有众多插件可以做到这一点，就是为某些在线AI API提供一个集成的前端体验。
- en: In contrast, you’ll find the AI Assistant integrated throughout PyCharm. To
    use the AI Assistant, use the right-hand menu shown in *Figure 16**.19*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，您会发现AI助手已集成到PyCharm中。要使用AI助手，请使用*图16.19*中显示的右侧菜单。
- en: '![Figure 16.21: The AI Assistant can be activated using the button on the right-hand
    menu](img/B19644_16_021.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图16.21：可以通过右侧菜单上的按钮激活AI助手](img/B19644_16_021.jpg)'
- en: 'Figure 16.21: The AI Assistant can be activated using the button on the right-hand
    menu'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21：可以通过右侧菜单上的按钮激活AI助手
- en: The preceding dialog summarizes the features available. Let’s take a look.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的对话框总结了可用的功能。让我们看看。
- en: This feature is not local
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能不是本地的
- en: If your company or environment has a restriction on sending code out to an API
    such as ChatGPT, you need to know that this feature does exactly that. The functionality
    is not self-contained within PyCharm and **any code or information you enter will
    be sent out to various external third-party APIs**. This is documented in the
    agreement you blindly scrolled through and ignored so you could get to use PyCharm
    and the cool new AI features.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的公司或环境对将代码发送到API（如ChatGPT）有限制，您需要知道这个功能正是这样做的。该功能不是在PyCharm内部自包含的，**您输入的任何代码或信息都将发送到各种外部第三方API**。这一点在您盲目滚动并忽略的协议中有记录，以便您可以使用PyCharm和酷炫的新AI功能。
- en: Explain code
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释代码
- en: 'There are many circumstances where you might encounter code you don’t understand.
    My normal mode of describing these circumstances is pretty colorful, especially
    at 2 A.M. the day before a deadline. I’ll endeavor to keep it professional:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您可能会遇到不理解代码。我通常用相当生动的语言来描述这些情况，尤其是在截止日期前一天凌晨2点。我将努力保持专业：
- en: It was written by someone else who clearly has no idea what they are doing.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是由其他人编写的，显然他们不知道自己在做什么。
- en: It was written by someone else who is clearly better at this than you are. Sometimes
    this might be the same person depending on the time of day.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是由其他人编写的，显然他们比您更擅长。有时这可能是同一个人，具体取决于时间。
- en: It was written by someone who loves terse code despite it being an anti-pattern
    in Python.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是由一个喜欢简洁代码的人编写的，尽管这在Python中是一种反模式。
- en: The code contains a regular expression you have not committed to memory, since
    no normal human understands regular expressions even though they pretend otherwise.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中包含一个您没有记住的正则表达式，因为即使人们假装了解，也没有正常人类能理解正则表达式。
- en: In circumstances such as these, help is a mouse-click away. Highlight the code
    in question, right-click, and select **AI Assistant Action | Explain code**. Seconds
    later, the AI will give you a breakdown of the selected code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，帮助就在鼠标点击之间。突出显示有问题的代码，右键点击，并选择**AI助手操作 | 解释代码**。几秒钟后，AI将为您提供所选代码的分解。
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bear in mind that the AI Assistant is not always correct, and doesn’t always
    give completely sound advice.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，AI 助手并不总是正确的，也不总是给出完全合理的建议。
- en: Answer programming questions
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回答编程问题
- en: In truth, the AI Assistant will answer any question you ask. I’ve asked it questions
    about nginx configuration, Docker, and general networking questions. Of course,
    it also answers programming questions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，AI 助手可以回答你提出的任何问题。我曾就 nginx 配置、Docker 和一般网络问题向它提问。当然，它也能回答编程问题。
- en: Create commit messages
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建提交信息
- en: 'This one is really neat! I’m a huge fan of the XKCD online comic and their
    treatment of Git in many comics is spot-on. This one comes to mind right now:
    [https://xkcd.com/1296/](https://xkcd.com/1296/).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能真的很棒！我是 XKCD 在线漫画的超级粉丝，他们在许多漫画中对 Git 的处理非常到位。现在我想起了一个：[https://xkcd.com/1296/](https://xkcd.com/1296/)。
- en: Since the IDE can see your change list, it can generate a commit message for
    you as shown in *Figure 16**.20*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 IDE 可以看到你的更改列表，它可以为你生成提交信息，如图 *图 16.20* 所示。
- en: '![Figure 16.22: Commit messages are generated that are more deep and meaningful
    than “I changed a bunch of stuff”](img/B19644_16_022.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.22：生成的提交信息比“我改了一堆东西”更深入和有意义](img/B19644_16_022.jpg)'
- en: 'Figure 16.22: Commit messages are generated that are more deep and meaningful
    than “I changed a bunch of stuff”'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.22：生成的提交信息比“我改了一堆东西”更深入和有意义
- en: Maybe you don’t put much stock in your commit messages. I’ve worked on US Government
    projects where the commit messages were audited. This wasn’t generally known by
    the development team who, upon learning of this, opted to rebase and re-create
    every commit to remove their more colorful language within the commit messages.
    The audit wasn’t really looking for that; it was being used to validate the change
    control process. My team is currently going through SOC2 certification, and I
    can tell you firsthand that complete and descriptive commit messages are seriously
    helpful. As cybersecurity continues to invade developer workflows, you can bet
    this feature will prove its value to you sooner or later.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你对提交信息并不太重视。我曾参与过美国政府项目，那里的提交信息需要接受审计。开发团队并不普遍知道这一点，当他们得知后，选择重置并重新创建每个提交，以移除提交信息中的更生动的语言。审计并不是真的在寻找那个；它被用来验证变更控制流程。我的团队目前正在通过
    SOC2 认证，我可以亲身体验到完整且描述性的提交信息非常有帮助。随着网络安全继续侵入开发工作流程，你可以确信这个功能迟早会证明它的价值。
- en: Generate documentation
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成文档
- en: Do you hate writing docstrings? That’s a trick question. If you’re a software
    developer, you probably think that the code itself is all the documentation anyone
    could ever need. But you’ve also seen the power of well-documented code when using
    the documentation features both in the main UI and in SciView. Wouldn’t it be
    nice if your own functions were as well documented without the need for you to
    write that documentation yourself? *Figure 16**.21* shows me generating a docstring
    for a function in one of my projects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你讨厌编写文档字符串吗？这是一个陷阱问题。如果你是软件开发人员，你可能认为代码本身就是任何人可能需要的所有文档。但你也曾见过在使用主界面和 SciView
    中的文档功能时，良好文档的代码的力量。如果你的函数也能得到良好的文档，而不需要你自己编写这些文档，那岂不是很好？*图 16.21* 显示了我正在为我项目中的一个函数生成文档字符串。
- en: '![Figure 16.23: Don’t write documentation, generate it](img/B19644_16_023.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.23：不要编写文档，生成它](img/B19644_16_023.jpg)'
- en: 'Figure 16.23: Don’t write documentation, generate it'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.23：不要编写文档，生成它
- en: Documentation in this case is really just another form of boilerplate. You should
    let the IDE generate that for you, then maybe improve on what it creates if needed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，文档实际上只是另一种形式的模板。你应该让 IDE 为你生成这些文档，然后如果需要的话，再对其进行改进。
- en: Jupyter Notebook support for Polars
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Polars 对 Jupyter Notebook 的支持
- en: While pandas is great, for big data, it is too slow. Spark and other big data
    frameworks can help but only by scaling horizontally, which involves setting up
    multiple compute nodes on your network. **Polars** is a data science library designed
    to allow you to work with large data without resorting to using multiple computers
    and has long been a requested feature in PyCharm. If your DataFrame fits in your
    computer’s memory, you can use it in Polars and view it in PyCharm just as you
    would any other DataFrame.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 pandas 很强大，但对于大数据来说，它太慢了。Spark 和其他大数据框架可以提供帮助，但只能通过横向扩展来实现，这涉及到在你的网络上设置多个计算节点。**Polars**
    是一个数据科学库，旨在允许你无需使用多台计算机即可处理大量数据，并且长期以来一直是 PyCharm 中的一个请求功能。如果你的 DataFrame 可以适应你的计算机内存，你就可以在
    Polars 中使用它，并在 PyCharm 中查看，就像使用任何其他 DataFrame 一样。
- en: Furthermore, PyCharm supports the **Plotly** library for visualization, which
    uniquely works with Polars DataFrames. When you combine PyCharm’s support for
    these advanced libraries, you can overcome many of the obstacles that are normally
    cited as detractors for using Polars.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，PyCharm 支持 **Plotly** 库进行可视化，该库独特地与 Polars 数据帧一起工作。当你结合 PyCharm 对这些高级库的支持时，你可以克服许多通常被列为使用
    Polars 的障碍。
- en: Summary and closing remarks
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和结束语
- en: We have covered a great deal in a short time! At least it feels this way for
    me since in many of these chapters it was extremely tempting to jump into a tutorial
    on the subject we were covering. For example, in the Flask and Django chapters,
    I felt “wrong” about not giving you a tutorial on Flask and Django. I didn’t do
    so because those are quite literally books unto themselves both within and outside
    of the Packt library.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在短时间内覆盖了大量的内容！至少对我来说是这样的，因为在许多这些章节中，我非常想跳入我们正在讨论的主题的教程。例如，在 Flask 和 Django
    章节中，我觉得没有给你 Flask 和 Django 的教程是“错误的”。我没有这样做，因为那些书实际上本身就是一本，无论是在 Packt 图书馆内部还是外部。
- en: We learned that the point of an IDE is to offer you a full suite of tools for
    every development task you might perform on a daily basis. When viewed through
    that lens, PyCharm is an amazing IDE that really has very few competitors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到 IDE 的目的是为你提供一套完整的工具，以应对你每天可能执行的所有开发任务。从这个角度来看，PyCharm 是一个惊人的 IDE，它实际上几乎没有竞争对手。
- en: We saw how the basics around setting up a simple Python project are made easy
    by automating processes such as creating a virtual environment. The Professional
    edition of PyCharm has many additional features for project creation, mostly centered
    around project templates for the most popular types of projects in the areas of
    general software development, full stack web development, and data science. There
    is even a special edition for educational use, which allows you to create interactive
    lessons that play out directly in the IDE. We didn’t talk about that one, but
    if you’re interested, I’ll leave a link in the *Further* *reading* section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何通过自动化创建虚拟环境等过程来简化设置简单 Python 项目的基礎。PyCharm 专业版具有许多用于项目创建的附加功能，主要围绕通用软件开发、全栈
    Web 开发和数据科学领域中最流行的项目类型的项目模板。甚至还有一个专门用于教育用途的版本，它允许你创建直接在 IDE 中播放的交互式课程。我们没有讨论这一点，但如果你对它感兴趣，我将在
    *进一步阅读* 部分留下一个链接。
- en: Full stack web developers have a huge chunk of PyCharm’s tooling dedicated just
    to their work. We saw all the major frameworks supported, and the support isn’t
    even limited to Python. PyCharm can do anything WebStorm can do with respect the
    JavaScript development and working with modern JavaScript UI frameworks such as
    Angular, Vue, Vite, and React.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈 Web 开发者拥有 PyCharm 工具集中很大一部分是专门针对他们的工作。我们看到了所有主要框架的支持，而且支持并不局限于 Python。PyCharm
    可以做到 WebStorm 可以做到的任何关于 JavaScript 开发的事情，以及与现代 JavaScript UI 框架（如 Angular、Vue、Vite
    和 React）一起工作。
- en: PyCharm has truly complete tooling for interacting with relational and non-relational
    databases. This feature set is mainly from DataGrip, a different IDE from JetBrains
    focused completely on databases, in particular on creating and development relational
    structures. It has full support for MongoDB and Redis, which are two that I use
    daily. Where I would normally need to flip to tools such as Studio 3T or Redis
    Insights, I can instead just stay in PyCharm. The diversity of platforms supported
    is staggering! There are dozens of supported databases, and sometimes it can be
    fun to just look at the list and go look up the ones you’ve never heard of.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm确实为与关系型和非关系型数据库交互提供了完整的工具集。这个功能集主要来自DataGrip，这是JetBrains的一个专注于数据库的IDE，它完全专注于创建和开发关系结构。它对MongoDB和Redis提供了全面的支持，这两个都是我每天都会使用的。在我通常需要切换到Studio
    3T或Redis Insights等工具的地方，我可以在PyCharm中停留。支持的平台多样性令人印象深刻！有数十种支持的数据库，有时只是看看列表，然后查找你从未听说过的那些数据库，也是一种乐趣。
- en: After covering databases, we learned about the boon that PyCharm brings to the
    field of data science. You can use what I’ll call a light version of Jupyter Notebooks
    by leveraging code cells in IPython. I’m not a daily data science guy at work,
    but sometimes I like to pretend that I am. The code cell features covered in *Chapters
    12* and *13* are useful for tasks such as integrating multiple APIs or microservices
    together. I can create a prototype script using cells that draw data from different
    APIs or microservices, toss them into a pandas DataFrame, and I can use SciView
    to see the results even if I don’t need to keep the DataFrame calls in my real
    program. Just being able to visualize the data in several easy tables rendered
    next to each other can be a big help.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了数据库之后，我们学习了PyCharm为数据科学领域带来的好处。你可以通过利用IPython中的代码单元格来使用我所说的Jupyter Notebooks的轻量级版本。我在工作中并不是每天都会做数据科学，但有时我喜欢假装自己是。在第12章和第13章中涵盖的代码单元格功能对于集成多个API或微服务之类的任务非常有用。我可以创建一个原型脚本，使用从不同API或微服务中提取数据的单元格，将它们扔进pandas
    DataFrame中，即使我不需要在我的实际程序中保留DataFrame调用，我也可以使用SciView来查看结果。仅仅能够将数据以几个并排的简单表格可视化，就可以有很大的帮助。
- en: If you are a data science practitioner, your support grows with tools such as
    Jupyter Notebooks integration making PyCharm a one-stop tool for your whole workflow.
    That’s the point of the tool for its three different audiences.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名数据科学从业者，随着Jupyter Notebooks集成等工具的支持增长，PyCharm成为你整个工作流程的一站式工具。这就是这个工具针对其三个不同受众的目的。
- en: When Packt asked me to write this book, I was excited and daunted. I was excited
    because I had just learned that LinkedIn Learning had taken down my PyCharm course,
    and that was one of my personal favorites. This book offered me the opportunity
    to do a deeper dive than you can do in a 2-hour video course. If 2-hour video
    courses are your thing I have one left on LinkedIn covering developing APIs with
    Flask. I doubt they’ll keep it up much longer, so if you’re interested, be sure
    to check it out before they take it down. I’ll put a link in the *Further reading*
    section. My newer video courses can be found on my course website, [https://maddevskilz.com](https://maddevskilz.com).
    Naturally, anything about Python will feature PyCharm as the IDE.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当Packt出版社邀请我写这本书时，我既兴奋又感到畏惧。我之所以兴奋，是因为我刚刚得知LinkedIn Learning已经下架了我的PyCharm课程，而这正是我个人的最爱之一。这本书给了我一个机会，可以比在2小时的视频课程中做得更深入。如果你喜欢2小时的视频课程，我还在LinkedIn上留有一门关于使用Flask开发API的课程。我怀疑他们不会保持太久，所以如果你感兴趣，请确保在他们下架之前查看。我会在*进一步阅读*部分放一个链接。我的新视频课程可以在我的课程网站上找到，[https://maddevskilz.com](https://maddevskilz.com)。自然地，关于Python的任何内容都会以PyCharm作为IDE。
- en: The idea (.idea?) of writing this book was daunting because there is so much
    packed (Packt?) into this IDE and I actually do know what I don’t know. I don’t
    know everything. I definitely found features I didn’t know were there when I started.
    I probably got some things wrong. That’s OK (I hope). Ending this book is a single
    point in time on a journey that, for me, started seven years ago when I got fed
    up with Visual Studio and web development in C# in general. When I saw how easy
    it was to create applications in Flask, and then again how easy PyCharm made it
    for a total n00b like me to actually get real work done, I was hooked. Writing
    a book like this is a huge responsibility with potentially a huge impact. Coding
    is a legitimate superpower. Unlike most superpowers in the movies, it is a superpower
    that can be taught. There is no need to come from a far-away planet, get bitten
    by a radioactive spider, or get injected with an experimental serum. While some
    of that might help, all you really need is grit, curiosity, and to put in the
    hard work. If you master this craft even a little bit, you can do great things.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 写这本书的想法令人畏惧，因为在这个IDE中包含的内容如此之多（Packt？），实际上我也知道自己不知道什么。我并不全知。当我开始时，我确实发现了一些我不知道的功能。我可能做了一些错误的事情。没关系（我希望）。结束这本书只是我在一条旅程上的一个时间点，对我来说，这条旅程始于七年前的某个时刻，当时我对Visual
    Studio和C#的Web开发感到厌倦。当我看到在Flask中创建应用程序有多容易，然后又看到PyCharm如何让像我这样的初学者也能真正完成工作，我就上瘾了。写这样一本书是一项巨大的责任，可能产生巨大的影响。编码是一种真正的超级力量。与电影中的大多数超级力量不同，这是一种可以教授的超级力量。没有必要来自遥远的星球，被放射性蜘蛛咬伤，或者被注射实验血清。虽然这些可能有所帮助，但你真正需要的是毅力、好奇心和付出努力。如果你在这方面哪怕只有一点点的掌握，你也能做大事。
- en: I’ve had the opportunity to create software that helps choose treatment modalities
    for prostate cancer patients. The project didn’t wind up going anywhere, but a
    year after I had shelved the project my father called and told me he had just
    gotten a diagnosis for prostate cancer. The extra moral of this story is to never
    delete your old repos! My father was a pathologist himself, and with the help
    of the doctor who created the algorithm, we ran my dad’s numbers through the program
    and the resulting treatment gave me another 8 years with him.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾有机会开发一款帮助选择前列腺癌患者治疗方案软件。这个项目最终没有取得进展，但在我搁置项目一年后，我的父亲打电话告诉我，他刚刚被诊断出患有前列腺癌。这个故事的一个额外寓意是永远不要删除你的旧代码库！我的父亲本身也是一位病理学家，在算法创建者的帮助下，我们用程序运行了我父亲的检查数据，最终的治疗方案让我又多陪了他8年。
- en: I’ve also been part of projects designed to help keep my country safe, train
    pilots in the US Marine Corps, and to manage IT assets. When I was working on
    these projects, they were just projects. They were deadlines I had to meet, and
    they were sources of stress. But every piece of software published, indeed every
    line of code we write has the potential to help make the world around us a better
    place! Sometimes the benefits are obvious, as with the cancer treatment software.
    Even software with a mundane purpose, such as enterprise storage capacity planning,
    can have far-reaching benefits since this too is a tool for enabling others to
    do what they do and build what they build.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我还参与过旨在帮助保护我的国家、在美国海军陆战队训练飞行员以及管理IT资产的项目。当我参与这些项目时，它们只是项目。它们是我必须完成的截止日期，也是压力的来源。但每一款发布的软件，实际上我们写的每一行代码，都有潜力让周围的世界变得更好！有时好处是显而易见的，就像癌症治疗软件那样。即使是具有平凡目的的软件，比如企业存储容量规划，也能产生深远的影响，因为这也是一个让他人能够做他们想做的事情、建造他们想建造的东西的工具。
- en: Consider too, our superpower works at scale. Superman can only be in one place
    at one time; a fact too frequently exploited by various supervillains. We are
    not limited in this way. There are apps in multiple app stores that can help dyslexic
    children learn to read. That one app downloaded tens of thousands of times can
    educate generations that would be marginalized or ignored by the public education
    systems of most countries, which value test scores and funding over outcomes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑到，我们的超级力量可以大规模运作。超人只能在一个地方出现一次；这是一个被各种超级恶棍频繁利用的事实。我们在这方面没有限制。有多个应用商店中的应用程序可以帮助阅读障碍儿童学习阅读。那个下载了数万次的单一应用程序可以教育那些在大多数国家的公共教育体系中可能会被边缘化或忽视的几代人，这些国家更重视考试成绩和资金而非结果。
- en: You have a superpower! Use it! These tools make it easier! If I’ve hooked even
    one person and they get the benefit from this tool and this language that I have
    gotten since I started, then for me, this book is a wild success.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你拥有超能力！利用它！这些工具使它变得更容易！如果我已经吸引到哪怕一个人，并且他们从我所得到的这个工具和这种语言中受益，那么对我来说，这本书就是一个巨大的成功。
- en: Further reading
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com),
    along with the following useful resources:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看本书的配套网站 [https://www.pycharm-book.com](https://www.pycharm-book.com)，以及以下有用的资源：
- en: Braunton, A. (2018) *Hands-On DevOps with* *Vagrant*. Packt.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布朗顿，A. (2018) 《使用 Vagrant 的实践 DevOps》。Packt。
- en: 'RESTful APIs with Python 3 and Flask (linkedin.com): [https://www.linkedin.com/learning/building-restful-apis-with-flask/restful-apis-with-python-3-and-flask-4](https://www.linkedin.com/learning/building-restful-apis-with-flask/restful-apis-with-python-3-and-flask-4
    )'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 3 和 Flask 构建 RESTful API（linkedin.com）：[https://www.linkedin.com/learning/building-restful-apis-with-flask/restful-apis-with-python-3-and-flask-4](https://www.linkedin.com/learning/building-restful-apis-with-flask/restful-apis-with-python-3-and-flask-4
    )
- en: 'Polars library: [https://www.pola.rs/](https://www.pola.rs/ )'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Polars 库：[https://www.pola.rs/](https://www.pola.rs/ )
- en: 'The Plotly Library for Python: [https://plotly.com/python/](https://plotly.com/python/
    )'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 Plotly 库：[https://plotly.com/python/](https://plotly.com/python/ )
- en: 'Educational edition of PyCharm: [https://www.jetbrains.com/pycharm-edu/](https://www.jetbrains.com/pycharm-edu/)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm 教育版：[https://www.jetbrains.com/pycharm-edu/](https://www.jetbrains.com/pycharm-edu/)
- en: 'HashiCorp Vagrant: [https://www.vagrantup.com/](https://www.vagrantup.com/
    )'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Vagrant：[https://www.vagrantup.com/](https://www.vagrantup.com/ )
- en: 'HashiCorp Terraform: [https://www.terraform.io/](https://www.terraform.io/)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Terraform：[https://www.terraform.io/](https://www.terraform.io/)
- en: 'Docker Desktop: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/
    )'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 桌面：[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/
    )
- en: 'Oracle VirtualBox: [https://www.virtualbox.org/](https://www.virtualbox.org/
    )'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle VirtualBox：[https://www.virtualbox.org/](https://www.virtualbox.org/
    )
- en: 'JetBrains AI Assistant: [https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/](https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains 人工智能助手：[https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/](https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/)
