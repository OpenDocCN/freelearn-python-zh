- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Dynamic Web Application with Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am fortunate enough to have been around the field of web development since
    its inception. I was a software engineer before there was a World Wide Web, at
    least one used by the general public. I remember the first time someone asked
    me to build a web application. I had to ask what it was. The guy told me, and
    I remember thinking “Well that’s dumb! Why wouldn’t people just use CompuServe
    or **America Online** (**AOL**) for that?” I thought the internet was going to
    be, at best, a fad. It was complicated, loaded with jargon, the UI was terrible
    compared with online services of the day, and it all just seemed kind of janky.
    I guess I was wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Once I figured that out, I learned HTML and JavaScript. CSS wasn’t even a thing
    yet. It wasn’t long before I hit a wall with HTML’s capabilities. As you well
    know, HTML isn’t a programming language. It is a content markup language that
    controls the presentation of static content. The earliest version of JavaScript
    wasn’t very useful. You could validate forms. That’s about it. Dynamic content
    generation with JavaScript wasn’t a feature until HTML 3 came out.
  prefs: []
  type: TYPE_NORMAL
- en: Like I said, I hit a wall. I needed to take user interaction data from the browser
    and use it to interact with a database, generate files, and more. With HTML and
    JavaScript, this simply wasn’t possible. I needed a backend language. Initially,
    that was the C language. Even that was limited. You had to write modules in C
    that could interoperate with the Apache web server using an interface called the
    **common gateway** **interface** (**CGI**).
  prefs: []
  type: TYPE_NORMAL
- en: So that was it for the first few years. Writing dynamic web applications was
    hard, and nothing like the capabilities of today. New languages and paradigms
    emerged to make the practice of web development more accessible. My first good
    experience was with a product called `.cfml` extension and process those files
    differently than normal HTML files. I was able to access an Oracle database very
    easily and, coupled with a lot of long nights and the creativity of my youth,
    I created some graphics pipeline software that garnered my employer a software
    patent.
  prefs: []
  type: TYPE_NORMAL
- en: 'CFML was part of a growing trend. The same technology was employed by lots
    of other nascent companies and stacks, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft created **Active Server Pages** (**ASP Classic**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sun Microsystems introduced **Java Server** **Pages** (**JSP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypertext** **Preprocessor** (**PHP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **National Center for Supercomputing Applications** (**NCSA)** created **Server
    -side Includes** (**SSIs**), which were not as feature-rich as the others in this
    list, but nevertheless existed as a way to generate dynamic content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to take a quantum leap forward and look at a more
    modern framework for creating dynamic content, which is generated on the server
    side rather than the client side within the browser. Specifically, we’ll be looking
    at a framework called **Flask**, a popular, unopinionated solution for creating
    web applications in Python. By the end of this chapter, you will understand the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of web development such as **client-server architecture**, and the
    stateless **request-response model** employed by the web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Flask is, and how it compares to other Python frameworks for web development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a Flask application in PyCharm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with **Jinja2** templates in PyCharm, which are used to serve dynamic
    content mixed with regular HTML markup, CSS styling, and JavaScript interactivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a RESTful API endpoint that returns data in JSON format rather
    than content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use PyCharm’s HTTP Requests feature to test your API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bear in mind, this chapter isn’t meant to be a tutorial on Flask. It is a tutorial
    on how to use PyCharm to work with Flask. If you’re looking for a full tutorial
    on Flask, visit my website at [https://www.maddevskilz.com](https://www.maddevskilz.com).
    There are several expanded tutorials on Flask that go into a deep dive and entail
    building entire projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to proceed through this chapter, and indeed the rest of the book,
    you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and macOS has them included on every system. If
    you are using Linux, you need to install the package managers, such as `pip`,
    and virtual environment tools, such as `virtualenv`, separately. Our examples
    will use `pip` and `virtualenv`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028)*, Installation and Configuration*, in case
    you are jumping into the middle of the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book’s sample source code is from GitHub. We covered cloning the code in
    [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028)*, Installation and Configuration*.
    You’ll find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-08](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-08).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web basics – client-server architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I began my career in IT back in 1991, I worked for a company called **Electronic
    Data Systems** (**EDS**). It was a different era. Back then, any serious computing
    was performed by monolithic systems called **mainframes**. Imagine a mainframe
    computer as an incredibly powerful and large-scale computer that existed before
    the era of personal computers and smartphones. It was like a supercomputer, capable
    of handling massive amounts of data and performing complex computations.
  prefs: []
  type: TYPE_NORMAL
- en: Mainframe computers were typically housed in specially designed rooms or data
    centers because they required a lot of space and specialized power and cooling
    systems to function properly. The typical mainframe was usually about the size
    of a minivan while its separate **Power Distribution Unit** (**PDU**) was roughly
    twice the size of a typical clothes dryer. The **Direct Access Storage Device**
    (**DASD**) was in yet another similarly large rectangular metal box. Connecting
    these various components were heavy cables about the diameter of a spent paper
    towel roll. Models from IBM’s Z14 series weighed between 2,500 and 4,000 kg (5,500
    and 8,800 lbs).
  prefs: []
  type: TYPE_NORMAL
- en: In the past, mainframe computers were commonly used by large organizations,
    such as banks, government agencies, universities, and large corporations. They
    were responsible for processing and managing huge volumes of data, running critical
    business applications, and supporting the operations of entire enterprises. In
    my case, I worked with the IBM mainframe systems responsible for running the automotive
    assembly line operations for **General Motors** (**GM**), among others.
  prefs: []
  type: TYPE_NORMAL
- en: Mainframes were known for their reliability, security, and high-performance
    capabilities. They could handle multiple tasks simultaneously and provide fast
    response times, even when dealing with extensive workloads. People would access
    mainframes through terminals or other connected devices to perform tasks or retrieve
    information.
  prefs: []
  type: TYPE_NORMAL
- en: With the advancement of technology and the emergence of personal computers,
    the role of mainframes has evolved. While they still play a vital role in certain
    industries, many of the computing tasks that were once exclusive to mainframes
    are now handled by distributed systems, relatively cheap rack-mounted Intel and
    IBM Power-based systems, cloud computing, and smaller devices such as laptops
    and smartphones.
  prefs: []
  type: TYPE_NORMAL
- en: Mainframes were, and I suppose still are, very expensive to own and operate.
    Not only was the hardware expensive but it also generally took a team of expert
    computer operators and maintainers to keep the system running. The cost was out
    of reach for all but the largest corporations and universities. Smaller companies
    and even smaller nations had to buy time on other people’s mainframes to gain
    access to computing at scale. This, in fact, was the service rendered by EDS.
    We had acres of space in several very large data centers located throughout the
    world, and we sold time and provided services to nearly all of the Fortune 500
    companies. The cost eventually, along with the implications of Moore’s Law, led
    to the downfall of the mainframe.
  prefs: []
  type: TYPE_NORMAL
- en: '**Moore’s Law** is an observation and projection made by Gordon Moore, the
    co-founder of Intel Corporation, in 1965\. It states that the number of transistors
    on a microchip doubles approximately every two years, leading to a significant
    increase in computing power and performance while reducing the cost of electronic
    devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Moore originally noted that this exponential growth in transistor density had
    been occurring since the invention of the integrated circuit, and he predicted
    that it would continue for the foreseeable future. Over the years, Moore’s Law
    has held remarkably true, with advancements in semiconductor manufacturing technology
    allowing for increasingly smaller transistors and more complex integrated circuits.
  prefs: []
  type: TYPE_NORMAL
- en: The doubling of transistor density every two years has had profound implications
    for the field of computing. It has enabled the development of more powerful and
    efficient computers, with increased processing speed, memory capacity, and storage
    capabilities. As more transistors can be packed onto a chip, the overall performance
    of electronic devices has improved while their physical size has decreased.
  prefs: []
  type: TYPE_NORMAL
- en: 'As computers became smaller, and chip architectures such as **Reduced Instruction
    Set Computing** (**RISC**) and eventually Intel’s x86 architecture appeared, a
    new model of computing emerged: **client-server**.'
  prefs: []
  type: TYPE_NORMAL
- en: Mainframes were centralized and accessed using “dumb” terminals. These terminals
    had no compute capability, no storage, and only enough memory to maintain a communications
    buffer to send whatever you typed on the keyboard to the mainframe for processing.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server architecture shifted some of the compute, storage, and memory
    to a local client, which was usually a PC. The client was connected via a **local
    area network** (**LAN**) to a server, which was generally more powerful than a
    PC and capable of running enterprise-grade computing loads. You typically had
    client software, which was composed of a desktop user interface running on the
    PC’s operating system. The client software interfaced with centralized software
    running on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides client and server hardware, one final piece came into existence around
    the same time: a standardized network protocol known as **Transmission Control
    Protocol/Internet Protocol** (**TCP/IP**). I was in college before TCP/IP and
    in order to interact with the University of Oklahoma’s mainframe, I had to keep
    a stack of floppy disks on hand that held an odd, mismatched collection of communication
    protocols. Some systems used a protocol called **Kernel for Efficient, Remote,
    and Multiple Computer Interactions** (**KERMIT**). I also had disks for *XMODEM*,
    *YMODEM*, and *ZMODEM*. Depending on which type of computer I wanted to access,
    I had to employ a different protocol. TCP/IP changed all that with a standard
    set of protocols supported by everything from mainframes and PCs to modern smartphones
    and internet-connected toasters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If this sounds like the internet to you, you’d be right – but with a few caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: The client server was very slow, and often not even full duplex, meaning data
    could only flow in one direction at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most client programs did not have a real GUI and didn’t support mouse interactions.
    They were known as “green screen” interfaces because they were rendered using
    textual menus on monochrome screens that were often green. Later thick-client
    applications had real GUIs usually written in Java, Visual Basic, C++, or Delphi.
    They were called thick because the size of the program was large enough that downloading
    the GUI could take many hours over a typical connection. This sits in stark contrast
    to a typical web application running on the modern internet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client software was always designed around a specialized set of use cases.
    In contrast, web browsers today, which comprise the client, can be used to run
    any kind of software from general word processing applications to specific lines
    of business applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web is the natural evolution in client server architecture. Lightweight
    client software, the web browser, connects to a centralized server where the bulk
    of the real work is handled using universally accepted networking protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the request-response mechanism in HTTP – how clients and servers communicate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great accomplishments of the 1980s, besides CFC-laden hairspray,
    was the development of a universal set of networking protocols known as TCP/IP.
    In case you are new to this, the correct way to pronounce this is as letters:
    *tea sea pea eye pea*. The slash is silent, just like it is with ninjas.'
  prefs: []
  type: TYPE_NORMAL
- en: It took a while for it to be universally adopted, but ultimately it was, and
    the protocols of TCP/IP form the basis of the modern web. While there are many
    useful protocols serving a myriad of functions, I want to focus your attention
    on the **Hypertext Transfer Protocol** (**HTTP**). You can go ahead and include
    the secure counterpart, *HTTPS*, where the *S* stands for *secure*. They effectively
    work the same way, except that HTTPS is encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: The request-response mechanism entails a chain of events that describes a conversation
    that happens between the web browser or client, and the web server. You can watch
    this conversation unfold in *Figure 8**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: The request-response mechanism in HTTP conveys a request from
    a browser to the server, which computes a response and sends it back to the browser](img/B19644_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The request-response mechanism in HTTP conveys a request from a
    browser to the server, which computes a response and sends it back to the browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'The request-response mechanism used by HTTP is the fundamental communication
    pattern between clients, such as web browsers or mobile applications, and servers
    on the World Wide Web. It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`, `POST`, `PUT`, or `DELETE`, which indicates the desired action to be
    performed on the server’s resources, along with additional headers and, in some
    cases, a request body that carries data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The request is received by the server**: Upon receiving the request, the
    server processes the information provided in the request. This may involve accessing
    databases, performing calculations, or executing other server-side operations
    based on the nature of the request. The simplest request is one for an HTML document,
    or other file that is simply returned.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The server generates a response and sends it back to the user**: After processing
    the request, the server generates an HTTP response. The response contains an appropriate
    status code indicating the outcome of the request. For example, a request that
    is successful bears a status code in the response header of 200\. If you request
    a resource on the server that isn’t there, you’ll get a 404 code signaling the
    resource was not found. The response header also includes additional fields providing
    more information and a response body that contains the requested data or any relevant
    information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The browser receives the response data**: The client receives the HTTP response
    from the server and processes the information contained within it. This could
    involve rendering HTML content, processing data, or performing other actions based
    on the response.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Request-response cycle is complete**: With the response received, the request-response
    cycle is complete. The client may choose to send additional requests to the server
    to perform further interactions, or the process may end.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This request-response mechanism forms the basis of how information is exchanged
    between clients and servers over HTTP. It allows clients to request resources
    or perform actions on the server, and the server responds with the corresponding
    results or necessary information. This cycle enables the dynamic and interactive
    nature of web applications and services.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to remember is that HTTP is stateless. This means that every request-response
    cycle is discrete. There is no native way in HTTP to share or retain data between
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: What is Flask?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask is an unopinionated framework for working with the request-response mechanism
    found in HTTP. It does one thing and only one thing: it helps you receive requests
    into a simple Python object structure, then craft responses using Python code.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go back to the word *unopinionated*. By this, I mean Flask by design only
    handles the request-response cycle. I realize I said that already, but it bears
    repeating. When you compare Flask to its virtual antithesis, which is Django,
    the difference is stark.
  prefs: []
  type: TYPE_NORMAL
- en: Django is extremely opinionated about how you create your web application. Django
    dictates the file structure, the application patterns, and the database to be
    used. It features its own object relational mapper, its own request response mechanism,
    and its own set of coding conventions. In short, Django will dictate your stack
    and most of the architectural details for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Flask proffers some suggestions, but they are not set in stone, and you don’t
    have to use them if you don’t want to. A few years ago, I re-wrote my company’s
    flagship software product, Visual Storage Intelligence (see [https://www.visualstorageintelligence.com](https://www.visualstorageintelligence.com))
    as a Flask application strictly because it is unopinionated. I consider myself
    an expert at selecting the best stack given my knowledge, experience, and understanding
    of my company’s business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, I pretty much never use an ORM. I have deep expertise in SQL and
    relational database systems. I can write and tune queries, stored procedures,
    and views to build a fast, responsive web application in a variety of commercial
    and open source databases. An ORM is designed to take all that out of your hands
    and give you a layer of abstraction above the database so a developer need only
    deal with objects.
  prefs: []
  type: TYPE_NORMAL
- en: An ORM is effectively a black box. Most developers don’t know how it works or
    how to improve the performance of the queries the ORM generates. To me, it’s just
    overhead. Personally, I would rather build and tweak those guts myself. Incidentally,
    if any of these database-related terms are mystifying to you, stay tuned. I’ll
    talk a lot more about databases in *Chapter 11**, Understanding Database Management*
    *with PyCharm*.
  prefs: []
  type: TYPE_NORMAL
- en: The point is, Flask doesn’t care how I interact with my database. It doesn’t
    care about how I structure my application, and it doesn’t care what my stack looks
    like. It only does two things, and one of them is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Request-response handling and routing with Werkzeug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing Flask does for us is to make dealing with the request-response
    mechanism in HTTP very easy. Strictly speaking, an inbound request is binary in
    nature. As developers, we would really rather deal with text-like object abstractions
    of binary structures. Dealing with binary anything directly is soooo 1939\. Thankfully,
    there is a Python library that handles this called Werkzeug.
  prefs: []
  type: TYPE_NORMAL
- en: The library’s name, “Werkzeug," is derived from the German language, where it
    translates to “tool” or “instrument.” The Flask framework, including its underlying
    utility library, Werkzeug, was originally developed by Armin Ronacher, a German
    software developer.
  prefs: []
  type: TYPE_NORMAL
- en: The name “Werkzeug” was chosen to reflect the nature of the library as a versatile
    and powerful toolset for building web applications. Just as a craftsperson relies
    on a set of tools to create and shape their work, developers can leverage Werkzeug
    to handle various aspects of web development, such as routing, request handling,
    and HTTP utilities. Flask builds on top of Werkzeug; it adds additional abstractions
    and features to provide a lightweight and user-friendly web framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask uses Werkzeug’s functionalities to handle the low-level details of HTTP
    requests and responses, allowing developers to focus on building web applications
    quickly and efficiently. The effect is the ability to create web applications
    as simple as you would create any other Python application: you create functions
    to handle an incoming HTTP request, which returns a properly formatted HTTP response.
    If you can write a function in Python, you can create a web application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation in Flask looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is a simple Python function that takes no arguments and
    returns a string. The only thing odd about it is the decoration above the function
    definition. We’ll learn a lot more about this later. For now, understand that
    this decoration matches a route on your application’s URL. You are used to typing
    in a URL with the usual syntax of [https://www.maddevskilz.com/](https://www.maddevskilz.com/),
    which would take you to the root document of the website at that address. In the
    preceding code block, our function would answer any web request made to [https://www.maddevskilz.com/hello](https://www.maddevskilz.com/hello)
    with the string `''Hello, World!''`. Naturally, you’ll learn to do more than deal
    with a simple request like this, but my point remains: if you can create a function
    in Python, you can write a web application!'
  prefs: []
  type: TYPE_NORMAL
- en: Using this feature of Flask is non-negotiable. If you don’t want to use this
    abstraction of Werkzeug, then you don’t want to use Flask. Flask is, again, unopinionated,
    meaning this is really the only thing it “cares” about. We’ll see a contrast in
    [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298)*, Building a Web Application
    in Django*. Django is highly opinionated. It wants you to use its pre-defined
    stack. Flask doesn’t care. It does, however, make one strong suggestion that you
    can safely ignore if you’d like.
  prefs: []
  type: TYPE_NORMAL
- en: Templating with Jinja2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flask does come with a default suggestion regarding a templating library called
    Jinja2\. When you install Flask, you get Jinja2 as a dependency. Templating systems
    are designed to allow you to inject content into a markup document. Here is an
    example of a Jinja2 script that generates some items in an unordered list on an
    HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The template is just a string that contains some special characters indicating
    where Python-like code is to be executed. This is how all templating languages
    work, from classic ASP to JSP to PHP. The Flask process gets the request from
    the web server. It parses the request, and here we’re rendering the response with
    our template. The template itself is a markup fragment. A variable called `template_str`
    is created and set to an empty string. Remember, this isn’t Python code, it’s
    Python-like code because it exists within the context of markup. The single quotes
    are escaped by single quotes, meaning [PRE2] is interpreted as a single quote
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have a `for` loop iterating over some list called `items`,
    which will be passed into the template as data. The code in the template is delineated
    with `{%` and `%}`. Each `<li>` has an expression bound in double curly braces.
    In this case, the expression is just the iterating variable item defined with
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my example, the template string is defined in the code, but in real life,
    the template is usually in a file since that is much easier to maintain. Next,
    we create the `template` object and pass the `template` string into the template
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’re back to being in plain Python code. We’ll make a list called `items`
    and populate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we render `template`, which produces a new string set to a variable called
    `output`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are printing the output, but in the context of a Flask application,
    the output would be returned as the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Jijna2 has a robust set of language features common to most good templating
    systems. Remember though that Flask bills itself as *unopinionated*. You don’t
    have to use Jinja2\. There are other templating libraries out there, or you can
    forgo the use of a template system entirely. In my company’s product, *Visual
    Storage Intelligence*, I used Jinja2 for version 4 of the product. At the time,
    I didn’t know Python very well and was used to Microsoft’s MVC template for C#
    web applications. I limited my learning curve to meet my deadline. Jinja2 is not
    difficult to learn at all. It is mostly HTML with some extra syntax. In version
    5 of the product, I went back and replaced the UI layer of the application with
    a React frontend. This didn’t require any changes to the Flask application beyond
    deleting the templates that I no longer used.
  prefs: []
  type: TYPE_NORMAL
- en: Reminder – this isn’t a book on Flask
  prefs: []
  type: TYPE_NORMAL
- en: I’ve spent some time going over the high-level basics of Flask in case you are
    encountering this as a web development novice. While it may appear that I’m about
    to teach you Flask, I only intend to cover the features of Flask development as
    they relate to PyCharm. While we will be building a project, I won’t be doing
    any really deep dives on how and why the code is what it is.
  prefs: []
  type: TYPE_NORMAL
- en: As such, if you are indeed a novice and you are intrigued by the intentionally
    tacit coverage of Flask I’m providing here and you’d like a proper tutorial, I
    will include more in-depth resources in the *Further reading* section at the end
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A note on naming files and folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get further into creating the next project, I want to give you some
    advice based on a principle I always point out to my students. `%20` to be considered
    valid. Web servers automatically handle this encoding, but manually encoding spaces
    can lead to readability issues in URLs, and it can cause issues when trying to
    run your projects on your local computer.
  prefs: []
  type: TYPE_NORMAL
- en: In a web project, most of your project paths will become URLs at some point.
    This can happen even when your project isn’t even intended for the web. To add
    to the problem, different operating systems treat characters differently in their
    filesystems. Windows filenames are case insensitive. If you name your file or
    folder `MyProject`, and then try to create a folder called `myproject`, you’ll
    get a collision since the folder already exists, despite the difference in upper
    and lowercase letters in the name. On Linux and macOS, file and folder names are
    case sensitive. It is totally fine to have `MyProject` and `myproject` together
    in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: My suggestion in all of this is to pick a standard you like and use it. For
    Python projects, the most common convention is to name your files with `MyProject`.
    Instead, you would call it `my_project`.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, most of my projects in this book are named with the PyCharm
    defaults, which are often rendered in camel or Pascal case. In these case standards,
    typically employed by Java and C# developers, spaces are omitted and the boundary
    between words is emphasized using capital letters. `myProject` and `MyProject`
    would be an example of camel and Pascal case respectively. I suspect the use of
    camel case in the project name defaults probably comes from the fact that PyCharm’s
    ancestry is a Java IDE. Other strategies exist for eliminating spaces in code
    files. Kebab case is common in JavaScript development and uses dashes instead
    of underscores. `MyProject` becomes `my-project`.
  prefs: []
  type: TYPE_NORMAL
- en: I heartily recommend breaking any habit of using spaces in any of your folder
    or file names in your coding practice. This includes any upstream folders such
    as your operating system’s home folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Flask application in PyCharm Professional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tooling for Flask is a feature found only in the Professional edition of
    PyCharm. Naturally, you can make a Flask app in the free version of PyCharm, but
    you’ll be on your own in terms of creating the files and setting up run profiles,
    special debugging, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To create a Flask App in PyCharm, just select **File** | **New Project** and
    select the **Flask** template, as shown in *Figure 8**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: To create a new Flask project in PyCharm Professional, choose
    the template from the New Project dialog](img/B19644_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: To create a new Flask project in PyCharm Professional, choose the
    template from the New Project dialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve numbered the most important parts in *Figure 8**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **New Project** dialog of PyCharm Professional, you’ll find a template
    for **Flask** projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This part is no different than any project we’ve done so far. Fill in the location
    for the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your virtual environment. Once everything is filled in, PyCharm creates
    and activates the virtual environment and installs Flask and its dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This section is unique to Flask projects. I mentioned that Flask encourages
    the use of the Jinja2 templating engine. You can choose to leave it out and PyCharm
    will take care of that for you. There is also a setting for the folder you want
    to use for your Jinja2 templates. We’re going to keep the defaults and I recommend
    if you are going to use Jinja2 templates that you leave the settings as they are
    because that is where most developers will expect them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have everything filled in, click the **Create** button at the bottom
    of the dialog and PyCharm will set up your project for you, including the creation
    of some starter code, as seen in *Figure 8**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: PyCharm generates your Flask project automatically](img/B19644_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: PyCharm generates your Flask project automatically'
  prefs: []
  type: TYPE_NORMAL
- en: At position `Hello World` idiom from earlier, except this one is responding
    to the root route of your web application. At the top, we import Flask, then we
    instantiate Flask as the `app` variable. Now that you know that, the decoration
    for the route on *line 6* makes more sense; `app.route` is simply coming from
    the `app` instance of Flask.
  prefs: []
  type: TYPE_NORMAL
- en: All this code is contained in `app.py` at position **(2)** of *Figure 8**.3*.
    The name isn’t a requirement, and you can change it if you’d like. You can also
    see, at position **(3)**, that PyCharm has generated two folders for Jinja2 templates
    and static files such as your images, CSS, and JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Hello World` program generated by PyCharm is a good starting point for
    new applications. It provides you with some nice cognitive prompting in case it’s
    been a while since you created the Flask application from scratch. Naturally,
    we’ll be wanting to replace `Hello World` with something a tad more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a very simple application for cataloging new Python libraries!
    This kind of project is usually done with a database, but it doesn’t have to be.
    Our app is going to hold a list of Python libraries along with their description
    and a rating from 1-5 on how useful we think they are. To accomplish the database
    part, we’re going to simply use an in-memory array of lists. Using this approach
    prevents the need to do a deep dive on the database features of PyCharm, which
    isn’t coming until [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266)*, Understanding
    Database Management with PyCharm*. We’ll also exercise every excuse to cover some
    features we’ve covered earlier in a practical setting, such as using the HTML
    features from the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the static parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest place to start when building a web application is to get the static
    parts working. I’m talking about the non-dynamic parts of the application such
    as the `index.html` page with its basic structure, any CSS, images, and JavaScript
    we might need.
  prefs: []
  type: TYPE_NORMAL
- en: Start off by right-clicking in the `Templates` folder and creating a new file
    called `index.html`. This is going to be a Jinja2 template, so it belongs in the
    `Templates` folder rather than the `static` folder.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.4: Right-click\uFEFFing the Templates folder and creat\uFEFFing\
    \ a new HTML file](img/B19644_08_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Right-clicking the Templates folder and creating a new HTML file'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we created a plain HTML file. There is no special file type for a
    Jinja2 file. The file is created using the Emmet templating system we covered
    in [*Chapter 7*](B19644_07.xhtml#_idTextAnchor172)*, Web Development with JavaScript*,
    *HTML, and CSS*. As you hopefully remember, `title` attribute in the HTML file,
    allowing you to fill in that blank spot in the HTML template. You can see mine
    in *Figure 8**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: The HTML creation template puts your cursor in the title tag
    so you can fill in that part of the page](img/B19644_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: The HTML creation template puts your cursor in the title tag so
    you can fill in that part of the page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s modify the contents of the `<head>` tag like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This brings in the bootstrap CSS and JavaScript libraries from a **content delivery
    network** (**CDN**). If you don’t want to type all that in, you can copy the code
    from the book’s repository code, or you can go to [https://getbootstrap.com](https://getbootstrap.com)
    and find the latest in the **Getting Started** section of their site, which usually
    includes copyable links to their CDN.
  prefs: []
  type: TYPE_NORMAL
- en: We’re using the CDN so we don’t need to keep these common files in our project.
    Besides, CDNs usually serve these kinds of files faster than will your own web
    server once you move your amazing app into production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, change the contents of the `<body>` tag to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’re going to use the Emmet feature we learned about in [*Chapter 7*](B19644_07.xhtml#_idTextAnchor172)*,
    Web Development with JavaScript, HTML, and CSS,* to generate an HTML table header.
    Type this Emmet code into the editor on a new line just below the `<``h2>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This abbreviation will generate a table, followed by a `thead` tag, with one
    table row (`tr`) and four table head fields (`th*4`). Press *Tab* to expand the
    abbreviation. PyCharm’s Emmet plugin will generate your code and take you straight
    to the contents of the `th` tags, as shown in *Figure 8**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: Emmet expands the code into all the code you need for the table
    header](img/B19644_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Emmet expands the code into all the code you need for the table
    header'
  prefs: []
  type: TYPE_NORMAL
- en: Once Emmet has expanded your code, you’ll see the prompts inside the `th` tags
    allowing you to edit the content, as shown in *Figure 8**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: Emmet expands the shorthand in line 15 in Figure 8.6 to what
    we see here](img/B19644_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Emmet expands the shorthand in line 15 in Figure 8.6 to what we
    see here'
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, you’d use **Tab** to move between the fields, but in PyCharm,
    the *Tab* key is bound to the action that expands Emmet, as we just saw. You can’t
    use *Tab* to navigate as you’d expect if you’re coming from a different Emmet-enabled
    editor. Instead, you’ll need to find out what the shortcut is on your system since
    this will depend on which keyboard shortcut layout you configured when you installed
    PyCharm. I chose the Windows layout, so for me, moving between the fields is done
    using *Alt + Shift + ]*.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the first `th` tag, type `Library Name`. Then use *Alt + Shift + ]* to
    move to the next field and change it to `Description`. The third field will be
    called `Rating` and the fourth is titled `URL`.
  prefs: []
  type: TYPE_NORMAL
- en: If *Alt + Shift + ]* doesn’t do it for you, let’s find out what will. Go into
    PyCharm’s settings and find the **Keymap** settings as shown in *Figure 8**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve typed `Emmet` into the search box and I can see that my **Navigate > Next
    / Previous Emmet Edit Point** settings are **Alt + Shift + ]** and **Alt + Shift
    + [,** respectively. If yours are different, you’ll see what they are here, and
    as we’ve learned, you can change them to anything you’d like so long as the change
    doesn’t conflict with something else.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Your Emmet navigation settings are found and set here in Settings](img/B19644_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Your Emmet navigation settings are found and set here in Settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, your HTML `table` code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add one more thing to the `table` code. Put this below the `</thead>`
    closure but before the `</``table>` closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If your code got messy, use PyCharm’s reformat code feature to clean things
    up. This is usually *Ctrl + Alt + L*, or *Cmd + Opt + L* on a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: We have a basic web page laid out. Before we make it dynamic, let’s create a
    run configuration for the app so we can preview our handiwork.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Flask app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we created our project, PyCharm created a Flask run configuration for us.
    Let’s take a look at it so we can understand how the app will be run by PyCharm.
    Click the **Run configuration** dropdown and click **Edit Configurations…**, as
    seen in *Figure 8**.9*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.9: Edit\uFEFFing the run configurations so we can see what they’re\
    \ made of](img/B19644_08_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Editing the run configurations so we can see what they’re made
    of'
  prefs: []
  type: TYPE_NORMAL
- en: The settings look like those shown in *Figure 8**.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: Flask run configuration generated by PyCharm](img/B19644_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Flask run configuration generated by PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: Most of these settings will be familiar now, so only a few are marked.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to run a Flask app. The easiest is to just run the
    `app.py` file, which is the `dunder-main` line that runs the app, this works just
    fine. Recall the code at the bottom of `app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can also run it using the module name, but let’s stick with what PyCharm
    generated for now.
  prefs: []
  type: TYPE_NORMAL
- en: At position `FLASK_DEBUG` environment variable gets its own checkbox. When you
    check this box, it puts the dedicated Flask development server into debug mode,
    which yields several benefits. The greatest of these is that the app server will
    restart whenever you change the code. This saves you from having to remember to
    stop and restart the server every time you make a change. Generally speaking,
    you want this box checked. Above the check is a commonly used `FLASK_ENV` environment
    variable that is also passed to the running app. It defaults to `development`.
    You can use this environment variable to turn on and off certain behaviors in
    your app, including setting log detail levels.
  prefs: []
  type: TYPE_NORMAL
- en: The two `PYTHONPATH` checkboxes at position `PYTHONPATH` folder, which prevents
    you from getting an error stating Python can’t find your application. You want
    these checked.
  prefs: []
  type: TYPE_NORMAL
- en: Note that with all these checkboxes, PyCharm gives you the ability to set common
    environment variables that are passed into the running app. This is nice, because
    setting them at the OS level is extra work that we often forget, and changing
    environment variables often doesn’t work as well as it should depending on your
    operating system. When you use environment variables at the OS level, you generally
    need to either reboot or log out and log back in to make sure the new values are
    active. PyCharm injects variables directly into the running development server,
    which saves a lot of time and frustration.
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK** to close the run configuration dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we fire it up, we need to make a code change to `app.py`. We need to
    alter our `Hello World` code to load and display our template. The altered code
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, I’ve added an import for the `render_template` method from Flask. We’ll
    use this to, you guessed it, render our Jinja2 HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I’ve added some code to the route decorator. Previously, we had `@app.route(''/'')`,
    which defines the `root` route for our site that will be handed by our `root`
    function. I’ve added a second argument, `methods=["GET"]`. Flask allows you to
    lock a route to one or more of the HTTP request methods I described earlier in
    the chapter. Locking Flask application endpoints to a particular HTTP method,
    such as `GET` or `POST`, is a fundamental practice in web development for several
    important reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: Different HTTP methods have different purposes and security implications.
    For example, GET requests are typically used for retrieving data, and they should
    not have any side effects on the server. In contrast, POST requests are used for
    submitting data to the server, and they can have side effects, such as creating,
    updating, or deleting resources. By restricting endpoints to specific HTTP methods,
    you can prevent unintended or malicious actions. This is known as “method-based
    access control.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predictability**: Locking endpoints to specific HTTP methods makes your API
    or web application more predictable and self-documenting. Other developers (or
    even your future self) will have a clearer understanding of how to interact with
    your application. For example, if an endpoint is designed for GET requests, it’s
    clear that it’s meant for data retrieval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: Consistency in your API design can improve the user experience
    and reduce confusion. When users or clients know that a specific HTTP method is
    expected for an endpoint, they are less likely to make incorrect requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preventing accidents**: Accidental misuse of an endpoint can lead to unintended
    consequences. By restricting the allowed HTTP methods, you reduce the chances
    of UI developers making mistakes, such as trying to delete data with a GET request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Framework support**: Flask, along with many other web frameworks, provides
    built-in support for routing requests based on HTTP methods. This makes it easier
    to implement method-based access control, as you can define separate routes and
    handlers for each HTTP method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look closely, the argument we’re passing is an array. You can pass one
    or more methods allowing one route to handle one or several methods differently.
    Here, we’re locking the `root` route function to the HTTP GET method, which is
    what your browser issues when you visit a site.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ve added Flask’s `render_template` method to our import. I changed
    the name of the function from `hello_world` to `root`, then I changed the return
    from the `'Hello World'` string to the result of the `render_template` function
    that takes the filename of a template. Flask knows to find `index.html` in the
    `Templates` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to try it out. Make sure your Flask app is selected in the run
    configuration dropdown and click the green **Run** button. The **Run** tab will
    appear at the bottom of the PyCharm screen. Mine appears as shown in *Figure 8**.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: The Run window for our Flask app](img/B19644_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: The Run window for our Flask app'
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of remarkable elements to point out. The first is the big
    red warning message. I know, it’s gray for you, but you’ll see it the first time
    you try this out. We’re running our app using Flask’s built-in development web
    server. Please don’t use this in production. Instead, you need to use a production-quality
    app server such as Green Unicorn. This falls outside the scope of developing with
    PyCharm, but it is such a huge mistake to deploy your app using the built-in server
    that I felt it needed to point out and justify this warning being in big red letters.
  prefs: []
  type: TYPE_NORMAL
- en: Second, it tells you the app is running at `http://127.0.0.1:5000`. The address
    is listed as a hyperlink, which you can click to open your browser. I have mine
    open in *Figure 8**.12*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: It worked, but 1991 just called on the phone and they want their
    web design back](img/B19644_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: It worked, but 1991 just called on the phone and they want their
    web design back'
  prefs: []
  type: TYPE_NORMAL
- en: It is awfully ugly, isn’t it? We went to the trouble of adding Bootstrap, the
    least we can do is use it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make it look a little better
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The page doesn’t have much happening in terms of design, and while we won’t
    be building some amazing user experience that might land you a design job at Apple,
    we can at least make this a little more presentable by adding some Bootstrap classes.
    We’ll be doing this within the `body` tag inside our Jinja2 template, `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s set up Bootstrap’s layout grid. This allows us to create apps that
    gracefully adjust to any size screen from the tiniest phone browser to the largest
    8K display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code just inside the `body` tag. When you’re done, it should bump
    up against the `table` code we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve added a `div` marked with the `container-fluid` class. This is going
    to give us some much-needed layout and padding so our content doesn’t slam up
    against the edges of the browser window. I’ve also set this to take up the full
    height available in the browser window in anticipation of there being many useful
    libraries in our table. I did this with Bootstrap’s `h-100` class.
  prefs: []
  type: TYPE_NORMAL
- en: After that, I added a `div` to act as a row followed by one acting as a column.
    I’ve set the class on the column to `col-12`, which in Bootstrap means it should
    take up the full width of the browser window with appropriate margins and padding
    defined by the `container-fluid` class in the ancestral `div` tag we added earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The next three tags are just content additions – some labeling that explains
    what the user is seeing using `H1` and `H2` tags followed by a horizontal rule.
    I added a CSS class to flip the letter R so it is reminiscent of a popular, yet
    presently bankrupt toy shop in the US. One more icon from my childhood has bitten
    the dust. Bear in mind, we haven’t created this CSS class yet. We’ll do that in
    just a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the Bootstrap `.table` class to the table. Change your `table` code
    by adding `class="table"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will fix up the spacing in and around the table so everything isn’t squished
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'To close all this out, we need to add all the necessary closing tags after
    our table is closed. That’s just three nested `div` closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first closes the column, the second closes the row, and the third closes
    the container. The last step is to add some CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right-click the `static` folder and create a new CSS file called `index.css`.
    Add the following code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this CSS file, we’re adding some extra margin around the page and setting
    the height to 100% so we don’t wind up with a stubby little page that is fully
    dependent on how much content is in our table.
  prefs: []
  type: TYPE_NORMAL
- en: I added a `flipped-letter` class in `index.css` to flip the letter R in our
    imaginary site’s title. We’re going to be displaying a rating for each library.
    I thought, instead of just a boring old number, we’d put some stars in there.
    Not just any stars – gold stars! So, there’s a class for that, which I called
    `.gold-star`. If you’re new to CSS, the leading dot is significant. It flags the
    rest, `gold-star` as a custom class. In CSS, a class has nothing to do with object-oriented
    development, so if you’ve learned some Java or other class based language, the
    word *class* is not related to the concepts from those languages. You’ll see in
    a minute when the class is used within the HTML, the dot will be absent. This
    is not an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a CSS file in the `static` folder, we need to reference it
    in the HTML file. Since it is in the static folder, which has special meaning
    in a Flask app, our code is a little different than a straight CSS reference like
    those we saw earlier with plain HTML. Add this line of code inside your `head`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note the Jinja2 expression that resolves the location of the static folder.
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned a moment ago that I want to use stars to show my ratings. I don’t
    really want to use graphics for this. Instead, I’d rather use a font, specifically
    **Font Awesome**. Font Awesome is essentially agigantic web font that, instead
    of containing alphabetical characters, contains hundreds of useful graphical icons
    useful for making modern UI and website designs. For more information on Font
    Awesome, see [https://www.fontawesome.com](https://www.fontawesome.com).
  prefs: []
  type: TYPE_NORMAL
- en: Rather than include Font Awesome in our project, which of course is an option,
    I’m going to link to a version of it hosted on a **content delivery network**
    (**CDN**). CDNs are a desirable way to host content because they are designed
    to serve static content with great speed. They do this not only through normal
    server optimizations but also by strategically positioning servers all over the
    world. When your page loads static content from a CDN, the request for that content
    is routed to the closest server. Your users in India will reach a CDN server in
    India, while users in Kansas (the middle of the United States) will be served
    the content from a server much closer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Font Awesome lists its CDN links on its website. I’m going to use a link I
    have copied from the Font Awesome website and add this to the `head` tag of our
    page. Since this is coming from a CDN instead of the static folder, I don’t need
    any Jinja2 voodoo magic to resolve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Things should be looking much better! I’ll hold off on the revealing screenshot
    until we’ve added the dynamic content. I don’t want to spoil the big reveal! Don’t
    forget, you can check the final code in the chapter’s repository folder cloned
    from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Making the page dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve created a Flask app and gotten a template working. Let’s add dynamism
    to the page using Flask and Jinja2\. We’re going to simulate a database using
    a list of `dicts` with fields that correspond to the fields we’ve put in our table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the `app.py` file and find this line, which should be near line number
    3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This line, which was generated by PyCharm when we created the project, creates
    an instance of Flask and assigns that instance to a variable called `app`. We’ll
    begin adding new code below this line. Let’s start by creating a global variable
    to hold our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In general, global variables, especially in a large program, are to be avoided.
    In this case, we’re using the global variable to simulate a database connection,
    which is generally an exception to the rule.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’re adding a few records to our fake database. If you’re a fan of Jinja2,
    please don’t hate me. I rated it a 3 in the content just to have some visual difference
    between the two sample records.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s just one more change. Add a second parameter to the `render_template`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `render_template` method is a **variadic function**. You can pass as many
    parameters into it as you’d like. Jinja2 will be able to render the passed data
    in the template. Here, we’re just adding one data variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re done with `app.py`! The final code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’re passing some data into the template, we need to go back and
    modify the `index.html` template to render the data. You need to change the contents
    of the `tbody` tag to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `{%` and `{{` markers in the template are marking out places where logic
    and content take place. Here, we are checking the length of the array. If it is
    greater than zero, we’re rendering table rows using the contents of the array.
    Further down, there’s an `else` that will render what we have now, which is a
    single row stating there is no data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are looping through the `library_data` list and generating
    a table row (`tr`). The table row is then supplied with columns. The `{{ }}` placeholders
    denote where contents from the `dict` from the current list iteration should be
    placed. The first column shows the contents of `data.python_library`. The second
    shows the description.
  prefs: []
  type: TYPE_NORMAL
- en: The third is where we add some razzle-dazzle! We add a code block that loops
    using a range to generate stars in that column. If the rating is 3, the loop runs
    3 times and we get 3 stars!
  prefs: []
  type: TYPE_NORMAL
- en: For the URL, I used the value of `data.url` as the `href` attribute on a hyperlink.
  prefs: []
  type: TYPE_NORMAL
- en: 'That just leaves the `else` statement I told you about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, if we pass in an array with zero elements, Jinja2 will render
    the row we had before, which states there is no data. If there’s data in the array,
    Jinja2 loops over the array and generates a table row for each row in the data.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project and direct your browser to `http://localhost:5000`. You’ll see
    a table rendered with two records, as seen in *Figure 8**.13*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.13: The big reveal! Our page is now dynamic\uFEFF](img/B19644_08_13.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: The big reveal! Our page is now dynamic'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pause for a moment and take stock of how PyCharm has helped us.
  prefs: []
  type: TYPE_NORMAL
- en: Editor enhancements for working with Flask and Jinja2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve been getting a lot of help during this exercise. If you don’t believe
    me, try repeating this exercise with Vim or Notepad! By now, you’re becoming accustomed
    to how much PyCharm takes off your plate in terms of lightening your cognitive
    load, and physically handling a lot of typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might not have even noticed the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML editing features, such as syntax highlighting, automatic tag closures,
    and color-coded indicators for your nested opening and closing tags in the markup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used Emmet to generate some of our markups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyCharm understands Jinja2 syntax and the inspection doesn’t freak out when
    you start putting curly braces everywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, it auto-closes the curly braces for both `{{ expressions }}` and `{%
    code` `blocks %}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you made any mistakes along the way, you might have noticed that PyCharm’s
    inspections and suggestions clearly understand how to use Flask. It’s not simple
    introspective auto-completion. PyCharm will give you specific assistance tailored
    to Flask development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at a few features that are not so obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch to `app.py`, put your cursor inside the template filename (`index.html`),
    then press *Ctrl* / *Cmd* + *B*. This activates the `library_data` variable in
    the template and press *Ctrl* / *Cmd* + *B*, it will take you to the render template
    call, which passes that variable into Jinja2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It shouldn’t surprise you that the debugger works in `app.py`. It also works
    in the Jinja2 template within the code blocks. Place a breakpoint in the `for`
    loop in the Jinja2 template, `index.html`. Start your app with `debug`, and the
    debugger will stop on the loop. You can use the same step-through capabilities
    as with anything else you are debugging. You can inspect template variables just
    as you would variables in a normal Python script. Considering Jinja2 is effectively
    a meta-language, completely distinct from Python, and specialized in what it can
    do, this is quite remarkable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you made any mistakes, Werkzeug has a nifty error page with links to your
    stack trace, which includes a trace of your template. PyCharm captures this information
    and displays it, complete with hyperlinks in the **Run** window. The hyperlinks
    take you to the code in PyCharm rather than just displaying it as Werkzeug does
    in the browser window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll see the same level of support for popular Flask plugins as you do for
    Jinja2\. Flask is designed to be extensible. There is a plethora of plugins to
    make your life easier in many areas of web development, from REST API development
    to database ORMs to session handling and authentication. You’ll find PyCharm guiding
    you through development in any Flask development scenario in which you find yourself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve pointed out a few times now that this chapter is a poor tutorial on Flask.
    We just barely scratched the surface of what Flask can do, but we covered all
    the ways PyCharm can help you with Flask development and it is one of the few
    IDEs that provides the level of help and tooling we’ve seen as we developed this
    simple project.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, Flask provides an easy way to generate a project structure and
    starter code for a Flask project. Like any other project, PyCharm sets up your
    virtual environment and gives you some starter code. When we use the Flask template
    in PyCharm Professional, PyCharm also installs your project dependencies for you
    and sets up a specialized run configuration for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get into editing your project, you find all the features we’ve covered
    in earlier chapters coming together. The HTML, CSS, and JavaScript-related features
    work not only with normal HTML projects but also with the Jinja2 templating language
    native to Flask. We get Flask-specific inspections, code hints, and documentation
    not just for Flask but also for the extended Flask ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: We even found we can debug Jinja2 templates as if they were actually Python
    code! Combine that with some very nice navigational enhancements to help you move
    between presentation logic and backend logic and you’ve got an unbeatable combination
    of power and functionality at your fingertips as a Flask developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask isn’t the only game in town. Newer development models have become popular
    over the last few years: specifically **single-page apps** (**SPAs**) combined
    with pure RESTful APIs on the backend. The next chapter focuses on a fast, modern
    approach to building RESTful APIs using a framework called FastAPI.'
  prefs: []
  type: TYPE_NORMAL
- en: As you will see, FastAPI bears some resemblence to Flask but with some important
    differences. Flask uses a worker model to serve content or data while FastAPI
    works a little more like NodeJS, which uses an asychronous programming model.
    FastAPI tends to focus solely on creating RESTful APIs and lacks the templating
    utilities found in Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
    The site allows me to list newer resources as they become available. The following
    resources will also be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gaspar, D., & Stouffer, J. (2018). *Mastering Flask Web Development: Build
    Enterprise-grade, Scalable Python Web Applications*. Packt Publishing Ltd.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Van Horn II, B. (2019). *Building RESTful APIs with Flask*. LinkedIn Learning:
    [https://www.linkedin.com/learning/building-restful-apis-with-flask/restful-apis-with-python-3-and-flask-4](https://www.linkedin.com/learning/building-restful-apis-with-flask/restful-apis-with-python-3-and-fl).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Van Horn II, B. (2021). MongoDB for Python Developers. MadDevSkilz.com. [https://www.maddevskilz.com/courses/mongodb-for-python-developers](https://www.maddevskilz.com/courses/mongodb-for-python-developers).
    Note: Despite the title, this is a short tutorial on creating a Flask application
    that uses MongoDB. It is very similar to, and newer than, my LinkedIn course.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
