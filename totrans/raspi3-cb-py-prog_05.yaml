- en: Creating Games and Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏和图形
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using IDLE3 to debug your programs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IDLE3 调试您的程序
- en: Drawing lines using a mouse on a Tkinter Canvas
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标在 Tkinter Canvas 上绘制线条
- en: Creating a bat and ball game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个棒球游戏
- en: Creating an overhead scrolling game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个滚屏游戏
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Games are often a great way to explore and extend your programming skills, as
    they present an inherent motivating force to modify and improve your creation,
    add new features, and create new challenges. They are also great for sharing your
    ideas with others, even if they aren't interested in programming.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通常是一个探索和扩展编程技能的绝佳方式，因为它们本身就具有内在的激励力量，促使你修改和改进你的创作，添加新功能，并创造新的挑战。它们也非常适合与他人分享你的想法，即使他们不感兴趣编程。
- en: This chapter focuses on using the Tkinter Canvas widget to create and display
    objects on a screen for the user to interact with. Using these techniques, a wide
    variety of games and applications can be created, limited only by your own creativity.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍如何使用Tkinter Canvas小部件在屏幕上创建和显示用户可以与之交互的对象。利用这些技术，可以创建各种游戏和应用，其局限性仅取决于您的创造力。
- en: We will also take a quick look at using the debugger built into IDLE3, a valuable
    tool for testing and developing your programs without the need to write extensive
    test code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将快速浏览一下如何在 IDLE3 中使用内置的调试器，这是一个在无需编写大量测试代码的情况下测试和开发程序的有用工具。
- en: The first example demonstrates how we can monitor and make use of the mouse
    to create objects and draw directly on the Canvas widget. Then, we create a bat
    and ball game, which shows how the positions of objects can be controlled and
    how interactions between them can be detected and responded to. Finally, we take
    things a little further and use Tkinter to place our own graphics onto the Canvas
    widget to create an overhead view treasure hunt game.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例演示了我们可以如何监控并利用鼠标来创建对象并在画布小部件上直接绘制。然后，我们创建了一个蝙蝠与球游戏，展示了如何控制对象的位置以及如何检测和响应它们之间的交互。最后，我们更进一步，使用Tkinter将我们自己的图形放置到画布小部件上，以创建一个俯视图寻宝游戏。
- en: Using IDLE3 to debug your programs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IDLE3 调试您的程序
- en: A key aspect of programming is being able to test and debug your code, and a
    useful tool to achieve this is a debugger. The IDLE editor (make sure you use
    IDLE3 to support the Python 3 code we use in this book) includes a basic debugger.
    It allows you to step through your code, observe the values of local and global
    variables, and set breakpoints.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一个关键方面是能够测试和调试你的代码，而实现这一目标的一个有用工具是调试器。IDLE编辑器（确保你使用IDLE3以支持本书中使用的Python 3代码）包含一个基本的调试器。它允许你逐步执行你的代码，观察局部和全局变量的值，并设置断点。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To enable the debugger, start IDLE3 and select Debugger from the Debug menu;
    it will open up the following window (if you are currently running some code,
    you will need to stop it first):'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用调试器，请启动 IDLE3 并从调试菜单中选择调试器；它将打开以下窗口（如果你当前正在运行某些代码，你需要先停止它）：
- en: '![](img/2cb1160c-a6c5-41da-a129-ffc1d43a430d.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2cb1160c-a6c5-41da-a129-ffc1d43a430d.png)'
- en: The IDLE3 debugger window
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE3 调试器窗口
- en: 'Open up the code you want to test (via File | Open...) and try running it (*F5*).
    You will find that the code will not start since the debugger has automatically
    stopped at the first line. The following screenshot shows that the debugger has
    stopped on the first line of code in `filehandler.py`, which is `line 3: import
    os`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开你想要测试的代码（通过文件 | 打开...），然后尝试运行它（*F5*）。你会发现代码无法启动，因为调试器已经自动停止在第一行。以下截图显示了调试器已经停止在`filehandler.py`代码的第一行，即`line
    3: import os`：'
- en: '![](img/fd9ccc69-4360-437d-8a60-bd62796a177d.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd9ccc69-4360-437d-8a60-bd62796a177d.png)'
- en: The IDLE3 debugger at the start of the code
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码开始处的 IDLE3 调试器
- en: How it works...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The control buttons shown in the following screenshot allow you to run and/or
    jump through the code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示的控制按钮允许您运行和/或跳过代码：
- en: '![](img/fcb83ee8-3292-4740-90dc-c868f52e19da.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fcb83ee8-3292-4740-90dc-c868f52e19da.png)'
- en: Debugger controls
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器控制
- en: 'The functions of the control buttons are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 控制按钮的功能如下：
- en: 'Go: This button will execute the code as normal.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Go: 此按钮将正常执行代码。'
- en: 'Step: This button will execute the block of code one line at a time, and then
    stop again. If a function is called, it will enter that function and allow you
    to step through that, too.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步骤：此按钮将逐行执行代码块，然后再次停止。如果调用了一个函数，它将进入该函数，并允许你逐行执行该函数。
- en: 'Over: This button is like the Step command, but if there is a function call,
    it will execute the whole function and stop at the following line.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Over：此按钮类似于Step命令，但如果存在函数调用，它将执行整个函数并在下一行停止。
- en: 'Out: This button will keep executing the code until it has completed the function
    it is currently in, continuing until you come out of the function.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出：此按钮将一直执行代码，直到它完成当前函数，继续执行直到你退出该函数。
- en: 'Quit: This button ends the program immediately.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出：此按钮立即结束程序。
- en: 'In addition to the previously mentioned controls, you can Set Breakpoint and
    Clear Breakpoint directly within the code. A breakpoint is a marker that you can
    insert in the code (by right-clicking on the editor window), which the debugger
    will always break on (stop at) when reached, as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的控制之外，你可以在代码中直接设置断点和清除断点。断点是一个可以在代码中插入的标记（通过在编辑器窗口上右键单击），当调试器到达该标记时，它将始终中断（停止），如下面的截图所示：
- en: '![](img/0556a804-3c2f-43d5-b2b2-28921732b6e6.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0556a804-3c2f-43d5-b2b2-28921732b6e6.png)'
- en: Set and clear breakpoints directly in your code
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在您的代码中设置和清除断点
- en: The checkboxes (on the right-hand side of the control buttons) allow you to
    choose what information to display when you step through the code or when the
    debugger stops somewhere due to a breakpoint. Stack is shown in the main window,
    which is similar to what you would see if the program hit an unhandled exception.
    The Stack option shows all of the function calls made to get to the current position
    in the code, right up to the line it has stopped at. The Source option highlights
    the line of code currently being executed and, in some cases, the code inside
    the imported modules, too (if they are non-compiled libraries).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框（位于控制按钮的右侧）允许您选择在遍历代码或当调试器由于断点而停止时显示哪些信息。堆栈显示在主窗口中，类似于程序遇到未处理的异常时您会看到的情况。堆栈选项显示了为到达代码当前位置所调用的所有函数调用，直至它停止的行。源选项突出显示当前正在执行的代码行，在某些情况下，还包括导入模块中的代码（如果它们是非编译库）。
- en: You can also select whether to display Locals and/or Globals. By default, the
    Source and Globals options are usually disabled, as they can make the process
    quite slow if there is a lot of data to display.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择是否显示局部变量和/或全局变量。默认情况下，源代码和全局变量选项通常被禁用，因为如果需要显示大量数据，这可能会使过程变得相当缓慢。
- en: Python uses the concept of local and global variables to define the scope (where
    and when the variables are visible and valid). Global variables are defined at
    the top level of the file and are visible from any point in the code, after it
    has been defined. However, in order to alter its value from anywhere other than
    the top level, Python requires you to use the global keyword first. Without the
    global keyword, you will create a local copy with the same name (the value of
    which will be lost when you exit the block). Local variables are defined when
    you create a variable within a function; once outside of the function, the variable
    is destroyed and is not visible anymore.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Following Stack data are the Locals – in this case, `aPhoto`, `filename`, and
    `self`. Then (if enabled), we have all of the global values that are currently
    valid, providing useful details about the status of the program (`DATE = 1`, `DEBUG
    = True`, `FOLDERSONLY = True`, and so on):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈数据之后是局部变量 – 在这种情况下，`aPhoto`、`filename` 和 `self`。然后（如果启用），我们拥有所有当前有效的全局值，提供了关于程序状态的详细信息（例如
    `DATE = 1`、`DEBUG = True`、`FOLDERSONLY = True` 等）：
- en: '![](img/dbc36fcb-4ffe-4ee0-8cd5-6f264e81f267.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dbc36fcb-4ffe-4ee0-8cd5-6f264e81f267.png)'
- en: The Stack, Locals, and Globals options within the debugger
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器中的 Stack（栈）、Locals（局部变量）和 Globals（全局变量）选项
- en: The debugger isn't particularly advanced, as it does not allow you to expand
    complex objects, such as the `photohandler.Photo` object, to see what data it
    contains. However, if required, you can adjust your code and assign the data you
    want to observe to some temporary variables during testing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器并不特别先进，因为它不允许你展开复杂对象，例如`photohandler.Photo`对象，以查看它包含的数据。然而，如果需要，你可以在测试期间调整你的代码，并将你想要观察的数据分配给一些临时变量。
- en: It is worth learning how to use the debugger, as it is a much easier way to
    track down particular problems and check whether or not things are functioning
    as you expect them to.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Drawing lines using a mouse on Tkinter Canvas
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用鼠标在 Tkinter Canvas 上绘制线条
- en: 'The Tkinter Canvas widget provides an area to create and draw objects on. The
    following script demonstrates how to use mouse events to interact with Tkinter.
    By detecting the mouse clicks, we can use Tkinter to draw a line that follows
    the movement of the mouse:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72dfae6f-9ceb-4b53-946d-f9567b5b81b9.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: A simple drawing application using Tkinter
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As before, we need to have Tkinter installed, and either the Raspbian desktop
    running (`startx` from the command line) or an SSH session with X11 forwarding
    and an X server running (see [Chapter 1](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml),
    *Getting Started with a Raspberry Pi 3 Computer*). We will also need a mouse connected.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following script, `painting.py`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python code creates a Tkinter window that contains a `Canvas` object called
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`the_canvas`. We use the `bind` function here, which will bind a specific event
    that occurs on this widget (`the_canvas`) to a specific action or key press. In
    this case, we bind the `<Motion>` function of the mouse, plus the click and release
    of the first mouse button (`<ButtonPress-1>` and `<ButtonRelease-1>`). Each of
    these events are then used to call the `mouse1press()`, `mouse1release()`, and
    `mousemove()` functions.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The logic here is to track the status of the mouse button using the `mouse1press()`
    and `mouse1release()` functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: If the mouse button has been clicked, the `mousemove()` function will check
    to see whether we are drawing a new line (we set new coordinates for this) or
    continuing an old one (we draw a line from the previous coordinates to the coordinates
    of the current event that has triggered `mousemove()`). We just need to ensure
    that we reset to the `newline` command whenever the mouse button is released to
    reset the start position of the line.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bat and ball game
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A classic bat and ball game can be created using the drawing tools of `canvas`
    and detecting the collisions of the objects. The user will be able to control
    the green paddle, using the left and right cursor keys to aim the ball at the
    bricks and hit them until they have all been destroyed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6fe6c2b-966c-413b-9975-01727c500869.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: A game in progress
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example requires graphical output, so you must have a screen and keyboard
    attached to the Raspberry Pi, or use X11 forwarding and X server if connected
    remotely from another computer.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following script, `bouncingball.py`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: First, import the `tkinter` and `time` modules, and define constants for the
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'game graphics:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, create functions for closing the program, moving the paddle right and
    left, and for calculating the direction of the ball:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set up the `tkinter` window and define the `canvas`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the borders, `ball`, and `paddle` objects to the `canvas`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Draw all of the bricks and set up the ball and paddle positions:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the main loop for the game to check for collisions and handle the movement
    of the paddle and ball:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create a Tkinter application that is 640 x 480 pixels and bind the `<Right>`
    and `<Left>` cursor keys to the `move_right()` and `move_left()` functions. We
    use `root.protocol('WM_DELETE_WINDOW', close)` to detect when the window is closed,
    so that we can cleanly exit the program (via `close()`, which sets `RUNNING` to
    `False`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add a Canvas widget that will hold all our objects to the application.
    We create the following objects: `top`, `left`, `right`, and `bottom`. These make
    up our bounding sides for our game area. The `canvas` coordinates are `0,0` in
    the top-left corner and `640,480` in the bottom-right corner, so the start and
    end coordinates can be determined for each side (using `canv.create_line(xStart,
    yStart, xEnd, yEnd)`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a75623a9-6ddd-4bce-9143-3ff9aeb61f3e.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: The coordinates of the Canvas widget
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: You can also add multiple `tags` to the objects; `tags` are often useful for
    defining specific actions or behaviors of objects. For instance, they allow for
    different types of events to occur when specific objects or bricks are hit. We
    will see more uses of `tags` in the next example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the ball and paddle objects, which are added using `canv.create_rectangle()`.
    This requires two sets of coordinates that define the opposite corners of the
    image (in this case, the top-left and bottom-right corners).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'A Tkinter rectangle is defined by the coordinates of the two corners:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0ddc64f-8bf6-41e4-9806-464cae5ef0fb.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Example of Tkinter rectangle
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can create the bricks!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our bricks to be 40 x 20 pixels wide so that we can fit 16 bricks across
    our game area of 640 pixels (in four rows). We can create a list of brick objects
    with their positions defined automatically, as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A brick-like effect is provided by making the bricks slightly smaller (`-2`)
    to create a small gap:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ad77ba6-9a6a-40fd-b80d-ad33a1609431.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 4 x 16 block of rows
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: We will now set the default settings before starting the main control loop.
    The movement of the ball will be governed by `delta_x` and `delta_y`, which are
    added to or subtracted from the ball's previous position in each cycle.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the starting position of the ball and use the `canv.move()` function
    to move the ball by that amount. The `move()` function will add `100` to the `x`
    and `y` coordinates of the ball object, which was originally created at position
    `0,0`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything is set up, the main loop can run; this will check that the
    ball has not hit anything (using the `canv.find_overlapping()` function), make
    any adjustments to the `delta_x` or `delta_y` values, and then apply them to move
    the ball to the next location.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The sign of `delta_x` and `delta_y` determines the direction of the ball. Positive
    values will make the ball travel diagonally downwards and towards the right, while
    `-delta_x` will make it travel towards the left – either downwards or upwards,
    depending on whether `delta_y` is positive or negative.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: After the ball has been moved, we use `canv.update()` to redraw any changes
    made to the display, and `time.sleep()` allows a small delay before checking and
    moving the ball again.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Object collisions are detected using the `canv.find_overlapping()` function.
    This returns a list of `canvas` objects that are found to be overlapping the bounds
    of a rectangle defined by the supplied coordinates. For example, in the case of
    the square ball, are any of the coordinates of the `canvas` objects within the
    space the ball is occupying? See the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38695a4d-8844-48c2-89db-de31d2651269.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: The objects are checked to detect if they overlap each other
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: If the ball is found to be overlapping another object, such as the walls, the
    paddle, or one or more of the bricks, we need to determine which direction the
    ball should travel in next. Since we are using the coordinates of the ball as
    the area within which to check, the ball will always be listed, so that we ignore
    them when we check the list of objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: We use the `dir_changed` flag to ensure that if we hit two bricks at the same
    time, we do not change direction twice before we move the ball. Otherwise, it
    would cause the ball to continue moving in the same direction, even though it
    has collided with the bricks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: So, if the ball is overlapping something else, we can call `determineDir()`
    with the coordinates of the ball and the object to work out what the new direction
    should be.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'When the ball collides with something, we want the ball to bounce off of it;
    fortunately, this is easy to simulate, as we just need to change the sign of either
    `delta_x` or `delta_y`, depending on whether we have hit something on the sides
    or the top/bottom. If the ball hits the bottom of another object, it means that
    we were traveling upwards and should now travel downwards. However, we will continue
    to travel in the same direction on the `x` axis (be it left or right, or just
    up). This can be seen from the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `determineDir()` function looks at the coordinates of the ball and the
    object, and looks for a match between either the left and right `x` coordinates
    or the top and bottom `y` coordinates. This is enough to say whether the collision
    is on the sides or top/bottom, and we can set the `delta_x` or `delta_y` signs
    accordingly, as can be seen in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we can determine whether we have hit a brick by checking whether the overlapping
    object ID is between the first and last ID bricks. If it was a brick, we can remove
    it using `canv.delete()`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Python allows the index values to wrap around, rather than access, the invalid
    memory, so an index value of `-1` will provide us with the last item in the list.
    We use this to reference the last brick as `brick [-1]`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We also check to see whether the object being overlapped is the bottom line
    (in which case, the player has missed the ball with the paddle), so a short message
    is briefly displayed. We reset the position of the `ball` and `delta_x`/`delta_y`
    values. The `canv.update()` function ensures that the display is refreshed with
    the message before it is deleted (three seconds later).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the ball is moved by the `delta_x`/`delta_y` distance, and the display
    is updated. A small delay is added here to reduce the rate of updates and the
    CPU time used. Otherwise, you will find that your Raspberry Pi will become unresponsive
    if it is spending 100 percent of its effort running the program.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: When the user presses the cursor keys, the `move_right()` and `move_left()`
    functions are called. They check the position of the paddle object, and if the
    paddle is not at the edge, the paddle will be moved accordingly. If the ball hits
    the paddle, the collision detection will ensure that the ball bounces off, just
    as if it has hit one of the bricks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: You can extend this game further by adding a score for each block destroyed,
    allowing the player a finite number of lives that are lost when they miss the
    ball, and even writing some code to read in new brick layouts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Creating an overhead scrolling game
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using objects and images in our programs, we can create many types of 2D
    graphical games.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a treasure hunt game where the player is trying
    to find buried treasure (by pressing *Enter* to dig for it). Each time the treasure
    has not been found, the player is given a clue to how far away the treasure is;
    the player can then use the cursor keys to move around and search until they find
    it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a03175d-c108-4242-a127-2c8626a9e273.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Dig for treasure in your own overhead scrolling game
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Although this is a basic concept for a game, it could easily be extended to
    include multiple layouts, traps, and enemies to avoid, and perhaps even additional
    tools or puzzles to solve. With a few adjustments to the graphics, the character
    could be exploring a dungeon, a spaceship, or hopping through the clouds, collecting
    rainbows!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following example uses a number of images; these are available as part of
    the book's resources. You will need to place the nine images in the same directory
    as the Python script.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The required image files can be seen in the code bundle of this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following script, `scroller.py`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by importing the required libraries and parameters:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Provide functions to handle the movements of the player:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add functions to check how far the player is from the hidden gold:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add functions to help find a location to hide the gold in:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the Tkinter application window and bind the keyboard events:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Initialize all of the game objects (the background tiles, the player, the walls,
    and
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'the gold):'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, start the `mainloop()` command to allow Tkinter to monitor for events:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As before, we create a new Tkinter application that contains a `Canvas` widget,
    so that we can add all of the game objects. We ensure that we bind the right,
    left, up, down and *Enter* keys, which will be our controls in the game.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: First, we place our background image (`bg.gif`) onto the `Canvas` widget. We
    calculate the number of images we can fit along the length and width to tile the
    whole canvas space, and locate them using suitable coordinates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the player image (by creating `playImg`, a list of Tkinter image
    objects for each direction the player can turn in) and place it on the canvas.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We now create the walls, the positions of which are defined by the `wallPosH`
    and `wallPosV` lists. These could be defined using the exact coordinates, and
    perhaps even read from a file to provide an easy method to load different layouts
    for levels, if required. By iterating through the lists, the horizontal and vertical
    wall images are put in position on the canvas.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: To complete the layout, we just need to hide the gold somewhere. Using the `hideGold()`
    function, we can randomly determine a suitable place to locate the gold. Within
    `findLocationForGold()`, we use `randint(0,value)` to create a pseudo-random number
    (it is not totally random, but good enough for this use) between `0` and `value`.
    In our case, the value we want is between `0` and the edge of our canvas space,
    minus the size of the gold image and any `bg_offset` that has been applied to
    the canvas. This ensures that it is not beyond the edge of the screen. We then
    check the potential location, using the `find_overlapping()` function to see whether
    any objects with `wall` or `player` tags are in the way. If so, we pick a new
    location. Otherwise, we place the gold on the canvas, but with the `state="hidden"`
    value, which will hide it from view.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: We then create `checkImg` (a Tkinter image), and use it while checking for gold
    to mark the area we have checked. Finally, we just wait for the user to press
    one of the keys.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The character will move around the screen whenever one of the cursor keys is
    pressed. The player's movement is determined by the `movePlayer()` function; it
    will first check whether the player is trying to move into a wall, then determine
    (within the `makeMove()` function) if the player is at the edge of the display
    or canvas space.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time a cursor key is pressed, we use the logic shown in the diagram to
    determine what to do:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fa4ac91-6983-4b12-8a55-922d6cad0783.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Cursor key press action logic
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The `foundWall()` function works out whether the player will hit a wall by
    checking for any objects with `wall` tags within the area being covered by the
    player image, plus a little extra for the area that the player will be moving
    to next. The following diagram shows how the `olCoords` coordinates are determined:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0aebc920-9a89-468c-94f3-34590750a19b.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: olCoords coordinate determination
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The `makeMove()` function checks if the player will be moving to the edge of
    the display (as defined by `DIS_LIMITS`) and whether they are at the edge of the
    canvas space (as defined by `SPACE_LIMITS`). Within the display, the player can
    be moved in the direction of the cursor, or all of the objects tagged with `bg`
    within the canvas space are moved in the opposite direction, simulating scrolling
    behind the player. This is done with the `moveBackground()` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'When the player presses *Enter*, we''ll want to check for gold in the current
    location. Using the `measureTo()` function, the position of the player and the
    gold are compared (the distance between the `x` and `y` coordinates of each is
    calculated, as shown in the following figure):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c36f28ad-060a-4445-ab10-aa38dbfbb51f.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Player and gold distance calculation
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The result is scaled to provide a rough indication of how far away the player
    is from the gold. If the distance is greater than zero, we display how far away
    the player is from the gold and leave a cross to show where we have checked. If
    the player has found the gold, we display a message saying so and set `newGame`
    to `True`. The next time the player presses *Enter*, the places marked with a
    cross are removed, and the gold is relocated to somewhere new.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: With the gold hidden again, the player is ready to start over!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
