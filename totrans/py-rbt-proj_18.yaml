- en: Making a Robotic Arm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作机械臂
- en: Finally, we are where most of us have wanted to be since the start of this book.
    Making a robotic arm! In this chapter, we will learn the concepts behind the working
    of a robotic arm. Undoubtedly, we will also be making a robotic arm for our personal
    use as well that can do limitless things for us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了大多数人在这本书开始时就希望达到的地方。制作一个机械臂！在本章中，我们将学习机械臂工作原理背后的概念。毫无疑问，我们也将制作一个供个人使用的机械臂，它可以为我们做无数的事情。
- en: Basics of a robotic arm
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机械臂的基本原理
- en: If you see a human body, then one of the most distinctive parts that makes us
    able to be different than most other species is the arm. It is the part of the
    body that we use to do most of the work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到人体，那么使我们能够与其他大多数物种不同的最显著部分之一就是手臂。它是我们用来做大部分工作的身体部位。
- en: The human arm is a very complex mechanism of joints and muscles that work in
    tandem to give it the dexterity that we know it for. Take an example of our shoulder
    joint. If you pay attention, then you will notice that it has the ability to move
    up and down, right and left, and even rotate on its own axis, and all this while
    it just has one single joint, which we know as a ball joint.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 人类手臂是一个非常复杂的关节和肌肉机制，这些关节和肌肉协同工作，赋予了我们所熟知的灵活性。以我们的肩关节为例。如果你仔细观察，你会发现它能够上下移动，左右移动，甚至可以绕着自己的轴线旋转，而这一切都只靠一个单一的关节，我们称之为球关节。
- en: When we talk about a robotic arm on a robot, we are undoubtedly talking about
    a complex arrangement of actuators with the body, otherwise known as a chassis,
    to get the desired motion in a three-dimensional space.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论机器人上的机械臂时，我们无疑是在谈论一个复杂的执行器排列，与身体（即底盘）一起，以在三维空间中获得所需的运动。
- en: Now, let's understand some of the basic parts of any robotic arm. The first
    parts are the actuators. We can use motors to control the robotic arm; however,
    as we have studied earlier, using the motors we have used before will not be the
    ideal solution for it as it cannot hold its position neither does it have a feedback
    mechanism. So we are left with only one option, that is, to use servo motors.
    As we know, they have a handful of torque and have the ability to know where it
    is and to hold its position for as long as we want.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解任何机械臂的基本组成部分。首先是执行器。我们可以使用电机来控制机械臂；然而，正如我们之前所研究的，使用我们之前使用的电机并不是理想的选择，因为它无法保持其位置，也没有反馈机制。因此，我们只剩下一个选择，那就是使用伺服电机。正如我们所知，它们具有相当大的扭矩，并且能够知道自己的位置，并且可以保持我们想要的任何位置。
- en: The second part of the robot is the chassis, that is, the part that holds all
    the motors together and provides structural support to the robot. This has to
    be made in such a way that it provides motion in all the desirable axis to any
    given joint. This is important as a single servo can only provide motion in one
    single axis. However, there are multiple places in which complex arrangement can
    be used to make the robot traverse in multiple axes. Also, the chassis should
    be rigid, which is extremely important. As we all know, all the material on this
    planet have certain level of flexibility. Also, the construction of the material
    depends on how noncompliant the material would be. This serves a very important
    purpose of repeatability.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人的第二部分是底盘，即那个将所有电机连接在一起并提供机器人结构支撑的部分。它必须以这种方式制作，以便为任何给定的关节提供所有期望的轴运动。这一点很重要，因为单个伺服电机只能在一个轴上提供运动。然而，有多个地方可以使用复杂的排列来使机器人在多个轴上移动。此外，底盘应该是刚性的，这一点非常重要。众所周知，地球上所有的材料都有一定的柔韧性。此外，材料的构造取决于材料的非顺应性。这服务于一个非常重要的重复性目的。
- en: Now, what is repeatability? As you might have seen in industries or any manufacturing
    units, the robots are installed and they do the same task over and over again.
    This is possible as the robots are programmed to perform a specific set of functions
    under specific circumstances. Now, let's say that the chassis of the robot is
    not rigid. In such a case, even if the servos are 100% precise and get to the
    exact same position over and over again, still the robot may actually differ from
    its actual goal position. This happens as there may be some flexibility in the
    chassis, which is why the final position may differ. Hence, a right chassis is
    a must. It becomes even more important when we are talking about large robots,
    as even the slightest of deformation can lead to a very large change in the final
    position of the arm.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是重复性？正如你可能已经在工业或任何制造单位中看到的那样，机器人被安装并重复执行相同的任务。这是可能的，因为机器人被编程在特定情况下执行一组特定的功能。现在，让我们假设机器人的底盘不是刚性的。在这种情况下，即使伺服系统100%精确并且每次都能到达完全相同的位置，机器人实际上可能与其目标位置有所不同。这是因为底盘可能存在一些灵活性，这就是为什么最终位置可能不同。因此，一个合适的底盘是必不可少的。当我们谈论大型机器人时，这一点变得更加重要，因为即使是微小的变形也可能导致手臂最终位置发生很大的变化。
- en: One very common terminology which we use while talking about the robot arm is
    the end effector. This is basically the end of the robot arm, which will be doing
    all the final work for us. End effector in the case of a real human arm can be
    considered the hand. This is at the top of the arm and all the movement of the
    arm is basically to articulate the position of the hand in a three-dimensional
    space. Also, it is the hand that picks up the objects or does the necessary physical
    action. Hence, the term end effector.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论机械臂时，我们经常使用的一个术语是末端执行器。这基本上是机械臂的末端，它将为我们完成所有最终工作。在真实的人臂的情况下，末端执行器可以被认为是手。这是手臂的顶部，手臂的所有运动基本上是为了在三维空间中定位手的位置。此外，正是手拿起物体或执行必要的物理动作。因此，我们称之为末端执行器。
- en: Now, as the robotic arm is moving in a three dimensional space, it becomes a
    real big problem to define the axis in which the motion is happening. Hence, instead
    of using the axis to define the motion, we generally use the type of motion being
    performed, which gives us a realistic idea of what the motion is and in which
    axis it may be on. To analyze the motion, we use the concept of **Yaw Pitch and
    Roll** (**YPR**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着机械臂在三维空间中移动，确定运动发生的轴线成为一个真正的大问题。因此，我们通常不是使用轴线来定义运动，而是使用正在执行的运动类型，这给我们一个关于运动是什么以及它可能在哪个轴上的现实概念。为了分析运动，我们使用**偏航、俯仰和滚转**（**YPR**）的概念。
- en: '![](img/020cfeaf-75d1-4fc0-94a3-559df1142150.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/020cfeaf-75d1-4fc0-94a3-559df1142150.png)'
- en: The preceding diagram will clear most of the doubts about YPR. This concept
    is generally used in aircrafts; however, it is an essential part of a robotic
    hand as well. So, as you can see from the preceding figure, when the nose of the
    plane goes up or down, it will be considered as pitch movement. Similarly, if
    the aircraft changes the heading, then the **Yaw** can be considered to change
    accordingly—the **Yaw** is nothing but the movement of aircraft in the *y* axis.
    Finally, we have something called **Roll**. It is used to understand the angel
    of rotation. As you can see, all these three entities are independent to each
    other and chasing any of it will not have any effect on the other. This concept
    is also useful as no matter what the orientation of the aircraft is, the YPR would
    still be unchanged and very much understandable. Hence, we take this concept straight
    from the aircraft directly to our robots.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示将消除关于YPR的大部分疑问。这个概念通常用于飞机；然而，它也是机械手的一个基本组成部分。所以，正如你从上述图中可以看到的，当飞机的鼻部向上或向下移动时，这将被认为是俯仰运动。同样，如果飞机改变航向，那么**偏航**可以被认为是相应地改变——**偏航**就是飞机在*y*轴上的运动。最后，我们还有被称为**滚转**的东西。它用于理解旋转角度。正如你所看到的，这三个实体彼此独立，追逐任何一个都不会对其他产生影响。这个概念也很有用，因为无论飞机的朝向如何，YPR都会保持不变，并且非常容易理解。因此，我们将这个概念直接从飞机应用到我们的机器人上。
- en: Finally, how can we forget about the processing unit? It is the unit that commands
    all the actuators and does the coordination and the decision making. This processing
    unit in our case is Raspberry Pi, which will command all the actuators. All of
    these preceding components make up a robotic arm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们怎能忘记处理单元呢？它是控制所有执行器并进行协调和决策的单元。在我们的案例中，这个处理单元是树莓派，它将指挥所有执行器。所有这些先前的组件共同构成了一个机械臂。
- en: Degrees of freedom
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自由度
- en: Not every robotic arm is the same. They have different load ratings, that is,
    the maximum load that the end effector can take, the speed and reach, that is,
    how far the end effector can reach. However, one very important part of a robotic
    arm is the number of motors it has. So, for every axis, you need at least one
    motor to make the robot traverse in that axis. For example, a human arm has three-dimensional
    freedom in the shoulder joint. Hence, to mimic that joint, you will need a motor
    for every axis, that is, a minimum of three motors are required for the arm to
    move in all the three axis, independently. Similarly, when we talk about the elbow
    joint of our hand, it can only traverse in two dimensions. That is the closing
    and opening of the arm and the finally the rotation of the arm—the elbow does
    not move in the third dimension. Hence, to replicate its motion, we need at least
    two motors, so that we an move the robot in the *w* axis.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个机械臂都是相同的。它们有不同的负载能力，即末端执行器可以承受的最大负载，速度和范围，即末端执行器可以达到多远。然而，机械臂的一个非常重要的部分是它拥有的电机数量。因此，对于每个轴，你需要至少一个电机来使机器人沿该轴移动。例如，人类的肩关节具有三维自由度。因此，为了模仿该关节，你需要每个轴上的一个电机，也就是说，手臂要在所有三个轴上独立移动，至少需要三个电机。同样，当我们谈论我们手部的肘关节时，它只能在两个维度上移动。那就是手臂的闭合和打开，以及最后手臂的旋转——肘关节在第三维度上不移动。因此，为了复制其运动，我们需要至少两个电机，这样我们才能在*w*轴上移动机器人。
- en: From what we have understood so far, we can safely assume that the more the
    number of motors, the more dexterous the robot would also be. This is mostly the
    case; however, you may use multiple motors to make the robot turn in a single
    axis itself. In such a scenario, the basic concept of counting the number of actuators
    to determine the dexterity of the robot will not work. So how do we determine
    how dexterous the robot is?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们目前所理解的来看，我们可以安全地假设，电机数量越多，机器人也会越灵活。这通常是这种情况；然而，你可能使用多个电机使机器人本身在一个轴上转动。在这种情况下，通过计算执行器的数量来确定机器人灵活性的基本概念将不再适用。那么，我们如何确定机器人的灵活性呢？
- en: We have a concept called **degrees of freedom** (**DOF**). If I go by the standard
    definition, then I can be very sure that you will be left confused as to what
    it actually means. If you are not convinced, then try finding out on Google yourself.
    A DOF, in very simple and plain English, is a joint that can independently move
    on any given axis. So, for example, if we are talking about a shoulder joint,
    then we have movement in all the three axis. Hence, the degrees of freedom would
    be three. Now, let's take into consideration the elbow joint of our arm. As it
    can only move in pitch and roll, hence there are two DOFs that we end up with.
    If we connect the shoulder joint with the elbow joint, then the DOF will be added
    up and the whole system would be called to have six DOFs. Keep in mind that this
    definition is a very simplified one. There are multiple complexities that you
    will encounter should you choose to dig deeper.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个称为**自由度**（**DOF**）的概念。如果按照标准定义来说，那么我可以非常确信你会对它实际意味着什么感到困惑。如果你还不信服，那么你自己尝试在谷歌上查找。用非常简单和直白的话来说，一个自由度是一个可以在任何给定轴上独立移动的关节。例如，如果我们谈论肩关节，那么它在三个轴上都有运动。因此，自由度是三个。现在，让我们考虑我们手臂的肘关节。因为它只能在俯仰和滚转方向上移动，所以我们最终得到两个自由度。如果我们把肩关节和肘关节连接起来，那么自由度将相加，整个系统将被称为具有六个自由度。请记住，这个定义是一个非常简化的定义。如果你选择深入研究，你会遇到多个复杂性。
- en: Now, most of the robotic arms that you will encounter would be having close
    to six DOFs. Though you may say that it is less than what human arms have, in
    practicality, it does most of the work and obviously having less DOFs means less
    number of motors leading to lower cost and obviously lower complexity in programming.
    Hence, we try to use as few DOFs as possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将遇到的大多数机械臂都会有接近六个自由度。尽管你可能认为这比人类的臂少，但实际上，它完成了大部分工作。显然，自由度越少，意味着需要的电机数量越少，从而成本更低，编程的复杂性也显然更低。因此，我们尽量使用尽可能少的自由度。
- en: '![](img/669abc29-fff7-42bb-891e-f2696ae96e1e.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/669abc29-fff7-42bb-891e-f2696ae96e1e.png)'
- en: Now, in the preceding diagram, you can see a typical robotic arm which has six
    DOFs. The base actuator marked by number **1** gives the freedom of rolling and
    altering the pitch. The elbow actuators marked by number **2** add only one DOF
    of the pitch to the robot. Furthermore, joint number **3** is has the ability
    to travel in **Pitch & Roll**. Finally, we have the end actuator as the gripper
    here; the gripper in itself has one DOF. So, cumulatively, we can say that the
    robot is a six-DOF robot.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在先前的图中，你可以看到一个典型的六自由度（DOFs）机械臂。标记为数字**1**的底座执行器提供了滚动和改变俯仰的自由度。标记为数字**2**的肘部执行器只为机器人增加了一个俯仰的自由度。此外，编号为**3**的关节具有在**俯仰和滚动**中移动的能力。最后，我们这里有一个末端执行器作为夹爪；夹爪本身有一个自由度。因此，总的来说，我们可以称这个机器人为一个六自由度机器人。
- en: Power house
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电池组
- en: There is one unit that we have been using in all our projects, but I want to
    emphasize on it in this chapter. This unit is the power unit. The reason we are
    talking about it is because in this chapter we will be controlling multiple servos.
    When we are talking about multiple servos, naturally we will be talking about
    a lot of power consumption. In the robot arm, we have six servo motors. Now, depending
    upon the make and model of the motor, the power consumption will vary. But keeping
    yourself on a safer side and assuming every servo's power consumption to be around
    1 amp would be a good idea. Most of the power supply you would be using might
    not be able to give you this much of burst current. So what should we do?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在所有项目中都使用了一个单位，但我想在本章中强调它。这个单位是功率单位。我们之所以谈论它，是因为在本章中我们将控制多个伺服电机。当我们谈论多个伺服电机时，自然会谈到大量的功耗。在机械臂中，我们有六个伺服电机。现在，根据电机的品牌和型号，功耗会有所不同。但为了安全起见，假设每个伺服电机的功耗约为1安培是个不错的想法。你使用的多数电源可能无法提供这么大的瞬时电流。那么我们应该怎么办？
- en: We can take the easy approach of taking a higher power output. But, instead,
    we can take the unconventional route. We can have a battery that can deliver this
    much of power when needed. But, the question is, will any battery solve our purpose?
    Obviously, the answer would be no.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取简单的方法，选择更高的功率输出。但相反，我们可以走一条非传统的路线。我们可以有一个在需要时可以提供这么多功率的电池。但问题是，任何电池都能满足我们的需求吗？显然，答案是否定的。
- en: 'There are multiple types of batteries that exist. These batteries can be distinguished
    based on the following parameters:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种类型的电池。这些电池可以根据以下参数进行区分：
- en: Voltage
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电压
- en: Capacity
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容量
- en: Power to weight ratio
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功率重量比
- en: Maximum charge and discharge rate
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大充放电速率
- en: Chemical composition
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 化学成分
- en: These are covered in detail in the upcoming subsections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容将在接下来的小节中详细说明。
- en: Voltage
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电压
- en: Voltage is the overall potential difference that the battery can create. Every
    battery has a specific voltage that it delivers. One thing to remember is that
    this voltage will vary slightly based on the charge condition of the battery.
    That is, when a 12V battery is fully charged, it may be giving an output of 12.6V.
    However, when it gets fully discharged, it may reach up to 11.4V. So, what battery
    voltage means is the nominal voltage that the battery would be providing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 电压是电池可以产生的整体电位差。每个电池都有其特定的电压输出。有一点需要记住的是，这个电压会根据电池的充电状态略有变化。也就是说，当12V电池完全充电时，它可能输出12.6V。然而，当它完全放电时，它可能达到11.4V。因此，电池电压的含义是电池将提供的标称电压。
- en: Capacity
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容量
- en: Now, the second parameter is the capacity. Generally, when you buy a battery,
    you will see its capacity in **milliampere hour** (**mAh**) or in **ampere hours**
    (**Ah**). This is a very simple term. Let me explain this term to you using an
    example. Let's say you have a battery with a capacity of 5 Ah. Now, if I draw
    5 amperes continuously for 1 hour, then the battery will be completely discharged.
    On the contrary, if I draw 10 amperes continuously, then the battery will be discharged
    in half an hour. With this, we can also derive the overall power that the battery
    has using the following simple formula: *Overall Power in Watts* = *Nominal Voltage
    of Battery x Overall battery capacity of battery in amperes*
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的第二个参数是容量。通常，当你购买一个电池时，你会看到它的容量以毫安时（mAh）或安培时（Ah）表示。这是一个非常简单的术语。让我用一个例子来解释这个术语。假设你有一个5
    Ah容量的电池。现在，如果我连续1小时抽取5安培的电流，那么电池将完全放电。相反，如果我连续抽取10安培的电流，那么电池将在半小时内放电。通过这个，我们也可以使用以下简单的公式推导出电池的总功率：*总功率（瓦）=
    电池标称电压 x 电池总容量（安培）*。
- en: Hence, if you have a battery of 12V, which has a capacity of 10 Ah, then the
    overall capacity in watts will be 120 watts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你有一个12V、容量为10 Ah的电池，那么总容量将是120瓦。
- en: Power-to-weight ratio
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功率与重量比
- en: In the previous chapter, we have understood that weight plays a very crucial
    role in robotics and if we increase the weight of the robot, then the force required
    to move it can exponentially go up. Hence, the concept of power to weight ratio
    comes into play. We always prefer a battery, which is extremely lightweight and
    delivers a large sum of power in respect to the weight. The equation for the power-to-weight
    ratio can be defined as follows: *Power to weight ratio in watt hour/kg* = *Maximum
    Power in watts / Overall weight of battery in kg.*
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经了解到重量在机器人技术中起着非常重要的作用，如果我们增加机器人的重量，那么移动它所需的力可以指数级增加。因此，功率与重量比的概念就应运而生。我们总是偏好那种极轻且相对于重量能提供大量功率的电池。功率与重量比的方程可以定义为以下：*功率与重量比（瓦时/公斤）=
    最大功率（瓦）/ 电池总重量（公斤）*。
- en: Now, let's say a battery is providing a power of 500 watts and the weight is
    5 kg, then the power to weight ratio will be 100 Wh/kg. The higher the power to
    weight ratio, the better the battery is.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设一个电池提供500瓦的功率，重量为5公斤，那么功率与重量比将是100 Wh/kg。功率与重量比越高，电池越好。
- en: Maximum charge and discharge rate
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大充放电速率
- en: This is perhaps one of the most crucial parts of the battery. Often the batteries
    are capable of running the robot for a span of 1 hour. However, the power consumption
    of robots is not constant. Let's say for 90% of the time, our robotic arm is consuming
    2 amperes of power, so the battery capacity is of 2 Ah. However, at some points
    of time during the operation, the robot needs all the motors to work on peak power.
    The peak power consumption of the robot is around 6 amperes. Now, the question
    is, will the battery of 2 Ah be able to provide 6 amperes power to the robot?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是电池最重要的部分之一。通常，电池能够使机器人运行1小时。然而，机器人的功耗并不恒定。假设90%的时间里，我们的机械臂消耗2安培的功率，那么电池容量是2
    Ah。然而，在操作过程中的一些时刻，机器人需要所有电机以最大功率工作。机器人的峰值功耗约为6安培。现在的问题是，2 Ah的电池能否为机器人提供6安培的功率？
- en: This is a very practical challenge. You may say, it is better to go with a battery
    that is much bigger than a 2 Ah battery. But, as you know, it will increase the
    weight phenomenally. So what's the solution?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常实际的挑战。你可能会说，使用比2 Ah电池更大的电池会更好。但是，正如你所知，这将极大地增加重量。那么解决方案是什么呢？
- en: There is something called peak discharge current. This is denoted by *C* rating.
    So, if our battery is of 1 C rating then a 2 Ah battery will only be able to give
    us a maximum of 2 Ah of power supply at any given time. However, if the battery
    is of 10 C rating, then it should be able to provide a burst power supply of up
    to 20 amperes. These days, you can find batteries that can give a burst power
    supply of up to 100 C or even more. The reason we have this is because the peak
    power consumption of robots can be exponentially higher than their constant power
    consumption. If, at any point, the battery is not able to pull ample amount of
    power, then the robot would behave erroneously and can even shut down.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种叫做峰值放电电流的东西。这用*C*值表示。所以，如果我们的电池是1C的充电率，那么2Ah的电池在任何时候只能提供最大2Ah的电源。然而，如果电池是10C的充电率，那么它应该能够提供高达20安培的瞬间电源。如今，您可以找到能够提供高达100C甚至更多瞬间电源的电池。我们之所以有这个，是因为机器人的峰值功率消耗可能比它们的恒定功率消耗指数级更高。如果在任何时候电池无法提供足够的电力，那么机器人可能会出现错误行为，甚至可能关闭。
- en: The second part of this story is the charge rating. This is the maximum charge
    current that you can provide to the battery. It is also denoted by the same C
    rating. So, if the C rating is 0.5, then you can provide a max of 1 ampere of
    charge to a 2 Ah battery.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的第二部分是充电率。这是您可以提供给电池的最大充电电流。它也用相同的C值表示。所以，如果C值是0.5，那么您可以向2Ah的电池提供最大1安培的充电电流。
- en: In other words, the fastest you can charge a battery would be in 2 hours.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，您最快可以在2小时内给电池充电。
- en: Chemical composition
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 化学成分
- en: 'There are different types of batteries that you can find on the market these
    are broadly segregated by their chemical composition. All of these batteries have
    their own pros and cons. Hence, we cannot say that one is better than the other.
    It is always a trade-off between various factors. The following is a list of batteries
    you can find on the market along with their pros and cons:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上可以找到不同类型的电池，这些电池主要根据它们的化学成分进行分类。所有这些电池都有它们自己的优缺点。因此，我们不能说哪一个比另一个更好。这总是在各种因素之间的权衡。以下是在市场上可以找到的电池列表，以及它们的优缺点：
- en: '| **Battery** | **Peak power output** | **Power-to-weight ratio** | **Price**
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **电池** | **峰值功率输出** | **功率重量比** | **价格** |'
- en: '| Wet cell | Low | Extremely low | Cheapest |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 湿电池 | 低 | 极低 | 最低 |'
- en: '| Nickel metal hydride | Medium | Low | Cheap |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 镍氢 | 中等 | 低 | 便宜 |'
- en: '| Lithium ion | High | Good | High |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 锂离子 | 高 | 好 | 高 |'
- en: '| Lithium polymer | Extremely high | Extremely good | Extremely high |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 锂聚合物 | 极高 | 极好 | 极高 |'
- en: As you can see from this table, the peak power output is something which we
    highly want and so is the good power-to-weight ratio; hence, spending a good amount
    of money on a lithium polymer battery makes sense.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这张表中可以看到，峰值功率输出是我们非常想要的，同样好的功率重量比也是；因此，在锂聚合物电池上投入大量资金是有意义的。
- en: These batteries, at a minimum, have a 20 C rating with a power-to-weight ratio
    around five times higher than the normal wet cell batteries. However, they can
    be up to 10 times more expensive than the normal wet cell batteries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些电池至少有20C的充电率，功率重量比比普通湿电池高约五倍。然而，它们的成本可能是普通湿电池的10倍以上。
- en: Now we know which batteries to choose for those higher current requirements.
    A lithium polymer battery of 11.1V and 2200 mAh will not cost you more than $20
    and will provide you with immense power that you may never need. So, we have the
    power supply issue sorted. Now it's time to go ahead and make the robotic hand
    operational.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了哪些电池适合那些更高的电流需求。一款11.1V、2200mAh的锂聚合物电池不会让您花费超过20美元，并且会为您提供您可能永远不需要的巨大功率。因此，我们已经解决了电源问题。现在是时候继续前进，使机器人手变得可用。
- en: Finding the limits
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找极限
- en: The robotic arm kit is a fairly easy one to procure from eBay or Amazon. This
    is not very difficult to assemble and will require a few hours to prepare. Some
    of the robotic arm kits might not ship with servo motors, in which case, you may
    have to order it separately. I would say go for the kit that comes bundled with
    the servos, as there can be compatibility issues if you choose to order servos
    separately.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人手臂套件在eBay或Amazon上购买相当容易。组装起来并不困难，需要几个小时来准备。有些机器人手臂套件可能不包含伺服电机，在这种情况下，您可能需要单独订购。我会建议选择包含伺服电机的套件，因为如果您选择单独订购伺服电机，可能会出现兼容性问题。
- en: 'As you know, these servos will work using PWM and it''s not hard to control
    them either. So, let''s go straight onto it and see what we can do. Once you have
    assembled the robotic arm kit, connect the wires of the servos as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，这些伺服将使用PWM工作，控制它们也不难。所以，让我们直接进入它，看看我们能做什么。一旦你组装好机器人手臂套件，按照以下方式连接伺服的电线：
- en: '![](img/1e6e7e16-abbc-4a09-8c34-617e30707833.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e6e7e16-abbc-4a09-8c34-617e30707833.png)'
- en: 'Now, firstly, we need to know what are the maximum physical limits of every
    single servo connected on our robot. There are various techniques to do that.
    The very basic one is to measure it physically. This method can be good but you
    won''t be able to ever utilize the full potential of the servo motor as you would
    be having some degree of error in measuring. Hence, the value you put in the servo
    will be slightly less than what you think it can go to. The second method is by
    manually feeding the data and finding out the exact angle. So, let''s go ahead
    with the second way of doing things and upload the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先，我们需要知道我们机器人上连接的每个伺服的最大物理限制是什么。有各种技术可以做到这一点。最基本的方法是进行物理测量。这种方法可能很好，但你将无法充分利用伺服电机的全部潜力，因为你会有一定程度的测量误差。因此，你放入伺服的值将略小于你认为它可以达到的值。第二种方法是手动输入数据并找出确切的角度。所以，让我们继续使用第二种方法，并上传以下代码：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's see what this code is doing. This code may look pretty elaborate,
    but what it is doing is extremely simple.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这段代码在做什么。这段代码看起来可能相当复杂，但它所做的是极其简单的。
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the preceding line of code, we are printing the statement for the user
    `select servo from 1-6`. When the user enters a value of the servo, this value
    gets stored in a variable `j`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码行，我们向用户打印了`从1-6选择伺服`的语句。当用户输入伺服的值时，这个值将被存储在变量`j`中：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `if` condition here checks for the value of `j`. If in this line, `j=1`,
    then it will run the code corresponding to the servo number `1`. Inside this code,
    the first line will print `select value to rotate`. Once this is done, the program
    will then wait for user input. Once the user inputs any value, then it will be
    stored in a variable called `I`. Thereafter, using the `cvt_angle(i)` function, the
    value which the user has input into the system will be converted to its corresponding
    duty cycle value. This duty cycle value will be fetched to the `pwm1.ChangeDutyCycle()` argument
    thereby giving the robot that very certain angle in the particular joint that
    you want. Due to the `time.sleep(2)` function, the servo will wait to go over
    to the next line. Thereafter, we are using the line `pwm1.ChangeDutyCycle(cvt_angle(90))`,
    which will bring it back to 90 degrees.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`if`条件用于检查`j`的值。如果在这一行中`j=1`，那么它将运行对应伺服编号`1`的代码。在这个代码内部，第一行将打印`选择旋转的值`。一旦完成，程序将等待用户输入。一旦用户输入任何值，它将被存储在一个名为`I`的变量中。之后，使用`cvt_angle(i)`函数，用户输入到系统中的值将被转换为相应的占空比值。这个占空比值将被用于`pwm1.ChangeDutyCycle()`参数，从而给机器人提供你想要特定关节的非常确定的角度。由于`time.sleep(2)`函数，伺服将等待执行下一行。之后，我们使用`pwm1.ChangeDutyCycle(cvt_angle(90))`这一行，这将将其恢复到90度。
- en: You may ask, why are we doing this? This is for a very important reason. Let's
    say you have given it a command to go beyond its physical limit. If that's the
    case, then the servo will keep on trying to move in that direction no matter what. However,
    due to the physical constrain, it will not be able to go ahead. Once this happens,
    then, within a few seconds, you will see blue smoke coming out of your servo indicating
    its death. The problem is that making such type of errors is very easy and the
    loss is quite noticeable. Hence, to prevent this, we quickly bring it back to
    the central position where it does not have any possibility of burning up.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，我们为什么要这样做？这是出于一个非常重要的原因。假设你给它一个超出其物理限制的命令。如果是这样，那么伺服将不断尝试朝那个方向移动，不管发生什么。然而，由于物理限制，它将无法继续前进。一旦发生这种情况，然后，在几秒钟内，你将看到从伺服中冒出蓝色烟雾，这表明它已经死亡。问题是，犯这种错误很容易，损失也很明显。因此，为了防止这种情况，我们迅速将其恢复到中央位置，这样它就没有燃烧的可能性了。
- en: Now, as per the preceding code, the same is done for servos 1-6 through the
    robot. Now that you know what is happening, it's time to take a pen and a paper
    and start giving servos the angular values. Do remember that the final goal of
    this code is to find out the maximum limits. So, let's start doing it starting
    from 90 degrees onwards. Give it a value on either side and not down until which
    value you can take it. Make a list on a paper as we will require it for our next
    code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据前面的代码，通过机器人对伺服1-6进行了相同的操作。既然你已经知道了发生了什么，是时候拿起笔和纸，开始为伺服器提供角度值了。请记住，这个代码的最终目标是找出最大限制。所以，让我们从90度开始做起来。在两侧给出一个值，直到你能够取到的值。在纸上列一个清单，因为我们需要它来编写下一部分的代码。
- en: Making the robot safe
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使机器人安全
- en: In the previous part of the chapter, with our multiple attempts, we have been
    able to find the maximum positions for each of the servos. Now it's time to use
    these values. In this chapter, we will be programming the servos for what its
    absolute maximums are. In this program, we will make sure that servos will never
    need to travel even a degree beyond the defined parameters on both the sides.
    If the user gives a value beyond it, then it will simply choose to ignore the
    user inputs instead of causing self damage.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前一部分，通过我们的多次尝试，我们已经能够找到每个伺服器的最大位置。现在是我们使用这些值的时候了。在这一章中，我们将为伺服器的绝对最大值编程。在这个程序中，我们将确保伺服器不会超出定义参数的任何一侧，甚至一度。如果用户给出的值超出这个范围，它将简单地选择忽略用户输入，而不是造成自我损害。
- en: 'So, let''s see how to get it done. There are some parts of this program, where
    the numeric values have been bold. These are the values that you need to replace
    with the values which we have noted in the previous section of this chapter. For
    example, for servo 1, the values noted down are `23` and `170` as the maximum
    values for either side. Hence, the change in the code will be from `if a[0] <
    160 and a[0] > 30` to `ifa[0] < 170 and a[0] > 23`. Similarly, for every servo,
    the same procedure has to be followed:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看如何完成它。在这个程序的一些部分，数值被加粗了。这些是需要用我们在本章前一部分记录的值来替换的值。例如，对于伺服器1，记录的值是`23`和`170`作为两侧的最大值。因此，代码的变化将从`if
    a[0] < 160 and a[0] > 30`变为`if a[0] < 170 and a[0] > 23`。同样，对于每个伺服器，都必须遵循相同的程序：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, in this code, we have done something very rudimentary. You can safely say
    that all we have done is put the `ChangeDutyCycle()` function inside an `if` statement.
    This `if` statement will govern whether the servo will move or stay still in its
    own position. To some, it may seem very naive to have this program in a special
    section. But, trust me, it is not. This statement will now be used as a part of
    every program from here on. All the code written for the movement of the servos
    will have to check the final values going to the servos through this `if` statement;
    hence, a basic visualization of code is extremely necessary.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这段代码中，我们做了一些非常基础的工作。你可以安全地说，我们所做的只是将`ChangeDutyCycle()`函数放入一个`if`语句中。这个`if`语句将决定伺服器是移动还是保持在它自己的位置。对一些人来说，这个程序在特殊部分中可能看起来非常天真。但是，相信我，它不是。这个语句现在将被用作从现在开始每个程序的一部分。所有为伺服器运动编写的代码都必须通过这个`if`语句检查要发送到伺服器的最终值；因此，代码的基本可视化是极其必要的。
- en: Now that the explanation is done, it's time for you to give different commands
    and see whether they are working within the safe working limits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在解释已经完成，是时候给你不同的命令，看看它们是否在安全工作范围内工作。
- en: Programming multiple frames
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程多个框架
- en: In the previous chapter, we have learned the basics of how to make sure that
    the robot is working under safe limits. In this chapter, we will be looking at
    how a robot can be made to do different activities at a click of a button, instead
    of typing the values one by one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何确保机器人在安全限制下工作的基础知识。在这一章中，我们将探讨如何通过点击按钮让机器人执行不同的活动，而不是逐个输入值。
- en: To do this, we will need to understand some advanced concepts of motion. Whenever
    you watch any video or play any video games, then you must have come across the
    term **frames per second** (**FPS**). If you haven't heard this term, then let
    me explain it for you. Every video made right now is actually made by still images.
    These still images are captured by cameras that click 25-30 times in a second.
    When these images are played back on the screen at the same rate at which they
    are captured, it forms a smooth video.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in robots, we do have the concept of frames. These frames, however,
    are not images but instead multiple steps that the robot has to follow to achieve
    a specific motion. In a simple robotic program, there could be simply two frames,
    that is, the initial frame and the final frame. These two frames will correspond
    to the initial position or the final position.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: However, in the real world, this is not always possible, as whenever the robot
    goes directly from the initial position to the final position, it tends a specific
    path with a specific curvature. However, there can be obstacles in that path or
    this path would not be desired as the path that needs to be followed could be
    a different one. Hence, we need frames. These frames not only define the robot's
    motion from the initial position to the final position, but also break down the
    transition from these two positions into multiple steps making the robot follow
    the desired path.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: This can be referred as frame programming, which we will cover in this chapter.
    One thing to keep in mind is that more the number of frames, smoother will be
    the functioning of the robot. Do you remember the CCTV footage we saw? We could
    say it's not smooth and has a lot of jerkiness. This is due to the low frame rate
    of the CCTV camera. Instead of working on 30 FPS, they work on 15 FPS. This is
    done to reduce the storage space of the video. However, if you see the latest
    videos, there are some games and videos with much higher frame rate than normal.
    Some of our latest camera works on 60 FPS, making the video even smoother and
    enjoyable to watch. The same will be the case with the robot. The more the number
    of frames, the smoother and controlled the motion would be. However, make sure
    you don't go into overkill.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to move from one position to another, we will have to put the values of
    the angles of every single servos in the very beginning. Once fetched, it will
    automatically start to execute these values one by one. To do this, go ahead and
    write the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this program, you can see that we have replicated the previous program with
    some very minor changes. So, let''s see what these changes are:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we are taking the input values for each servo and storing it in a different
    list. For servo 1, the list `a` will be used; similarly, `b` will be used for
    servo 2, and so on until `f`. In the preceding lines of code, the robot will prompt
    the user to fill in the six frame values for `motor 1`. Then, it will ask six
    values for `motor 2` and similarly until `motor 6`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The entire program for giving PWM to the servo is concentrated in this for loop.
    This loop will check the value of `i` and increment it every time. The value of
    `i` will start from `1` and the loop will run and increment the value of `i` until
    it reaches `6`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this line of the program, the value contained in the list is headed based
    on the value of `1`. So, for the first time it will read the value of `a[1]`,
    which will correspond to the first value of the list `a[]`. This value should
    be between the safe working limits, hence the `if` loop. If it is within safe
    working limits, then the program in the `if` condition will work, else it won''t.
    Inside the `if` loop, we have a simple statement: `pwm1.ChangeDutyCycle(cvt_angle(a[I]))`.
    This will simply take the value of `a[1]` and convert it into the corresponding
    PWM value and fetch it to the `ChangeDutyCycle()` function, which will change
    the PWM for servo 1.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: A similar program is made for the rest of the servos as well going on from servo
    1 to servo 6\. Hence, all of these will read the values of their corresponding
    list one by one and change the angle of the servo the way the user has programmed
    it. Furthermore, as the loop gets executed, the value of `i` will increase, hence
    making the program read the different values fetched in the list. Every value
    of the servo in the list will correspond to a different frame, hence parsing the
    robot through it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: So go ahead and have some fun making your robot do some awesome moves. Just
    take care that you be gentle to it!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Speed control
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's amazing to have made a robotic arm so easily, and with just a bit of code,
    we are now able to control it the way we want. However, there is one problem you
    might have noticed, that is, the robot is moving the way we want but not at the
    speed at which we want it to move. This is a very common problem while using the
    digital PWM-based servos.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: These servos do not have a built-in speed control. Their control system is programmed
    to move the servo as fast as they can to reach the goal position. Hence, to control
    the speed, we will have to play with the program itself and give it a smooth linear
    progression.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The speed control can be done through a few different techniques. So, without
    much talking, let''s go and see the code. Before you write it, read it and go
    through the code once and then see the following explanation to it. Thereafter,
    you will have a better idea of what we are doing. This will make writing the code
    faster and easier. So, let''s take a look at it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this program, there are quite a few things. We should go through them one
    by one to have an understanding of it. So, let''s see what we are doing:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we have defined six new variables with the name `prev0` to `prev5` and
    all of them have been allowed a value of `90`. The term `prev` here stands for
    previous, so this will be there to indicate the previous value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After the code line `for i in range 6`, we have the preceding line of code,
    which is basically checking the value of `a[i]` with `prev0`. Similarly, it is
    checking the values of `b[i]` with `prev1` and so on. Until the time all of these
    are not true the `while` loop will be true and will loop the program inside it
    until the condition is not false. That is, all the `prev` values are exactly equal
    to the values of the corresponding values of the list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, this may seem a little odd to you, but, trust me, it will be quite useful,
    which we will see in a while:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, here comes the real deal. This is the main program that will control the
    speed of the servo. In this, the first line is simple; it will check whether the
    value given to it is valid, that is, between the safe limits. Once that is done,
    it will then check whether the value of `a[Ii]` is less than or greater than the
    previous value. If it is greater than `a[i]`, then it will take in the previous
    value and decrement it with the speed specified by the user. If it is less than
    the value of `a[i]`, then it will increment the previous value with the speed
    specified.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: So, if you look at it, the code is simply incrementing or decrementing the previous
    value every time the `while` loop is running. Now, the `while` loop will run until
    the value of `prev` is equal to the corresponding list value. That is, the loop
    will keep incrementing the value until it reaches the specified position.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Hence, lower the value of the speed, lower will be the increments every single
    time, thereby slowing down the speed all together.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: This is the same process which will happen for all other servos as well. It
    may sound very complicated, but it is not! Programming is easy and will continue
    to remain easy each time you break it down into small pieces and understand them
    one by one!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have understood the basics of robotic arm, its power source,
    and its programming. With a very simple program, we were able to find out the
    limits of the servos and then apply these limits to make sure the servo did not
    damage itself. We got a basic idea of what frames are and did some programming
    based on frames. Finally, we also went ahead and controlled the speed of the servo
    using our very own program on a basic level.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
