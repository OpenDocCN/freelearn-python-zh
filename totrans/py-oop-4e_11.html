<html><head></head><body>
  <div><h1 class="chapterNumber">11</h1>
    <h1 id="_idParaDest-237" class="chapterTitle">Common Design Patterns</h1>
    <p class="normal">In the previous chapter, we were briefly introduced to design patterns, and covered the iterator pattern, a pattern so useful and common that it has been abstracted into the core of the programming language itself. In this chapter, we'll be reviewing other common patterns and how they are implemented in Python. As with iteration, Python often provides an alternative syntax to make working with such problems simpler. We will cover both the <em class="italic">traditional</em> design, and the Python version for these patterns.</p>
    <p class="normal">In this chapter, we'll see:</p>
    <ul>
      <li class="bullet">The Decorator pattern</li>
      <li class="bullet">The Observer pattern</li>
      <li class="bullet">The Strategy pattern</li>
      <li class="bullet">The Command pattern</li>
      <li class="bullet">The State pattern</li>
      <li class="bullet">The Singleton pattern</li>
    </ul>
    <p class="normal">This chapter's case study will emphasize how the distance calculation is an example of the Strategy design pattern, and how we can leverage abstract base classes to design a variety of distance computations that can be compared to see which produces the most useful results. </p>
    <p class="normal">Consistent with the practice in <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em>, we'll capitalize the pattern names. This can help them stand out from ordinary English usage.</p>
    <p class="normal">We'll start with the Decorator pattern. This is used to combine different kinds of functionality into a single resulting object.</p>
    <h1 id="_idParaDest-238" class="title">The Decorator pattern</h1>
    <p class="normal">The Decorator <a id="_idIndexMarker761"/>pattern allows us to <em class="italic">wrap</em> an object that provides core <a id="_idIndexMarker762"/>functionality with other objects that alter this functionality. Any object that uses the decorated object will interact with it in exactly the same way as if it were undecorated (that is, the interface of the decorated object is identical to that of the core object).</p>
    <p class="normal">There are two <a id="_idIndexMarker763"/>primary uses of the Decorator pattern:</p>
    <ul>
      <li class="bullet">Enhancing the response of a component as it sends data to a second component</li>
      <li class="bullet">Supporting multiple optional behaviors</li>
    </ul>
    <p class="normal">The second option is often a suitable alternative to multiple inheritance. We can construct a core object, and then create a decorator wrapping that core. Since the decorator object has the same interface as the core object, we can even wrap the new object in other decorators. Here's how it looks in a UML diagram:</p>
    <figure class="mediaobject"><img src="img/B17070_11_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 11.1: Decorator pattern in UML</p>
    <p class="normal">Here, <strong class="keyword">Core</strong> and all <a id="_idIndexMarker764"/>the decorators implement a specific <strong class="keyword">Interface</strong>. The <a id="_idIndexMarker765"/>dashed lines show "implements" or "realizes." The decorators maintain a reference to the core instance of that <strong class="keyword">Interface</strong> via composition. When called, the decorator does some added processing before or after calling its wrapped interface. The wrapped object may be another decorator, or the core functionality. While multiple decorators may wrap each other, the object at the end of the chain of all those decorators provides the core functionality.</p>
    <p class="normal">It's essential that each of these is providing an implementation of a common feature. The intent is to provide a composition of processing steps from the various decorators, applied to the core. Often decorators are small, typically a function definition without any state.</p>
    <p class="normal">In Python, because of duck typing, we don't need to formalize these relationships with an official abstract interface definition. It's sufficient to make sure the classes have matching methods. In some cases, we may define a <code class="Code-In-Text--PACKT-">typing.Protocol</code> as a type hint to help <strong class="" style="font-style: italic;">mypy</strong> reason about the relationships.</p>
    <h2 id="_idParaDest-239" class="title">A Decorator example</h2>
    <p class="normal">Let's look at an <a id="_idIndexMarker766"/>example from network programming. We want to build a small server that provides some data and a client that interacts with that server. The server will be simulating rolling complex handfuls of dice. The client will request a handful and wait for an answer that contains some random numbers.</p>
    <p class="normal">This example has two processes interacting via a TCP socket, a way to transmit bytes among computer systems. Sockets are created by a server that listens for connections. When a client attempts to connect to the socket, the server must accept the new connection, and the two processes can then pass bytes back and forth; for this example, there will be a request from client to server and a response from server to client. The TCP socket is part of the foundation for HTTP, around which the world wide web is built.</p>
    <p class="normal">The client and server processes will use the <code class="Code-In-Text--PACKT-">socket.send()</code> method to transmit a string of bytes through the socket. They'll also use <code class="Code-In-Text--PACKT-">socket.recv()</code> to receive bytes. We'll start with an interactive server that waits for a connection from a client and then responds to the request. We'll call this module <code class="Code-In-Text--PACKT-">socket_server.py</code>. Here's the general outline:</p>
    <pre class="programlisting code"><code class="hljs-code">import contextlib
import socket
def main_1() -&gt; None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("localhost", 2401))
    server.listen(1)
    with contextlib.closing(server):
        while True:
            client, addr = server.accept()
            dice_response(client)
            client.close()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">server</code> is bound to the "public" socket, using a more or less arbitrary port number of <code class="Code-In-Text--PACKT-">2401</code>. This is where the server is listening for connection requests. When a client tries to connect to this socket, a child socket is created so the client and server can talk, leaving the public socket ready for more connections. A web server will often use multiple threads to allow a large number of concurrent sessions. We're not using threads, and a second client has to wait until the server is done with the first client. It's a coffee shop queue with exactly one barista making espressos.</p>
    <p class="normal">(Note that TCP/IP sockets have both a host address and a port number. The port number must be above <code class="Code-In-Text--PACKT-">1023</code>. Port numbers <code class="Code-In-Text--PACKT-">1023</code> and below are reserved and require special OS privileges. We chose port <code class="Code-In-Text--PACKT-">2401</code> because it doesn't seem to be used for anything else.)</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">dice_response()</code> function does all the real work of our service. It accepts a <code class="Code-In-Text--PACKT-">socket</code> parameter so it can respond to the client. It reads bytes with a client request, creates a response, then<a id="_idIndexMarker767"/> sends it. In order to handle exceptions gracefully, the <code class="Code-In-Text--PACKT-">dice_response()</code> function looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">def dice_response(client: socket.socket) -&gt; None:
    request = client.recv(1024)
    try:
        response = dice.dice_roller(request)
    except (ValueError, KeyError) as ex:
        response = repr(ex).encode("utf-8")
    client.send(response)
</code></pre>
    <p class="normal">We've wrapped another function, <code class="Code-In-Text--PACKT-">dice_roller()</code>, in an exception handler. This is a common pattern to separate error-handling and other overheads from the real work of computing a dice roll and responding to the client with useful numbers for their role-playing game:</p>
    <pre class="programlisting code"><code class="hljs-code">import random
def dice_roller(request: bytes) -&gt; bytes:
    request_text = request.decode("utf-8")
    numbers = [random.randint(1, 6) for _ in range(6)]
    response = f"{request_text} = {numbers}"
    return response.encode("utf-8")
</code></pre>
    <p class="normal">This isn't too sophisticated. We'll expand on this in the section on <em class="italic">The Command pattern</em> later in this chapter. For now, however, it will provide a sequence of random numbers.</p>
    <p class="normal">Note that we're not really doing anything with the <code class="Code-In-Text--PACKT-">request</code> object that came from the client. For the first few examples, we'll be reading these bytes and ignoring them. The <code class="Code-In-Text--PACKT-">request</code> is a placeholder for a more complex request describing how many dice to roll and how many times to roll them.</p>
    <p class="normal">We can leverage the Decorator design pattern to add features. The decorator will be wrapping the core <code class="Code-In-Text--PACKT-">dice_response()</code> function, which is given a <code class="Code-In-Text--PACKT-">socket</code> object that it can read and write. To make use of the design pattern, it's important to exploit the way this function relies on the <code class="Code-In-Text--PACKT-">socket.send()</code> and <code class="Code-In-Text--PACKT-">socket.recv()</code> methods when we add features. We need to preserve the interface definition as we add decorations.</p>
    <p class="normal">To test the <a id="_idIndexMarker768"/>server, we can write a very simple client that connects to the same port and outputs the response before exiting:</p>
    <pre class="programlisting code"><code class="hljs-code">import socket
def main() -&gt; None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.connect(("localhost", 2401))
    count = input("How many rolls: ") or "1"
    pattern = input("Dice pattern nd6[dk+-]a: ") or "d6"
    command = f"Dice {count} {pattern}"
    server.send(command.encode("utf8"))
    response = server.recv(1024)
    print(response.decode("utf-8"))
    server.close()
if __name__ == "__main__":
    main()
</code></pre>
    <p class="normal">This client asks two questions and creates a fairly complex-looking string, <code class="Code-In-Text--PACKT-">command</code>, that contains a count and dice-rolling pattern. Right now, the server doesn't use this command. This is a teaser for a more sophisticated dice roller.</p>
    <p class="normal">To use these two separate applications, follow these steps:</p>
    <ol>
      <li class="numbered">Open two terminal windows, side by side. (It can help to change the window titles to "client" and "server". Users of macOS Terminal can use the <strong class="screenText">change title</strong> item in the <strong class="screenText">shell</strong> menu. Windows users can use the <code class="Code-In-Text--PACKT-">title</code> command.)</li>
      <li class="numbered">In the server window, start the server application:
        <pre class="programlisting con"><code class="hljs-con">python src/socket_server.py
</code></pre>
      </li>
      <li class="numbered">In the client window, start the client application:
        <pre class="programlisting con"><code class="hljs-con">python src/socket_client.py
</code></pre>
      </li>
      <li class="numbered">Enter your responses to the prompts in the client window. For example:
        <pre class="programlisting con"><code class="hljs-con">How many rolls: 2
Dice pattern nd6[dk+-]a: d6 
</code></pre>
      </li>
      <li class="numbered">The client will send the command, read the response, print it to the console, and exit. Run the client as many times as you want to get a sequence of dice rolls.</li>
    </ol>
    <p class="normal">The result will<a id="_idIndexMarker769"/> look something like this:</p>
    <figure class="mediaobject"><img src="img/B17070_11_02.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 11.2: Server and client</p>
    <p class="normal">On the left side is the server. We started the application, and it started listening on port <code class="Code-In-Text--PACKT-">2401</code> for clients. On the right side is the client. Each time we run the client, it connects to the public socket; the connection operation creates a child socket that can be used for the rest of the interaction. The client sends a command the server responds to that command, and the client prints it.</p>
    <p class="normal">Now, looking back at our server code, we see two sections. The <code class="Code-In-Text--PACKT-">dice_response()</code> function reads data and sends data back to the client via a <code class="Code-In-Text--PACKT-">socket</code> object. The remaining script is responsible for creating that <code class="Code-In-Text--PACKT-">socket</code> object. We'll create a pair of decorators that customize the socket behavior without having to extend or modify the socket itself.</p>
    <p class="normal">Let's start with a <em class="italic">logging</em> decorator. This object outputs any data being sent to the server's console before it sends it to the client:</p>
    <pre class="programlisting code"><code class="hljs-code">class LogSocket:
    def __init__(self, socket: socket.socket) -&gt; None:
        self.socket = socket
    def recv(self, count: int = 0) -&gt; bytes:
        data = self.socket.recv(count)
        print(
            f"Receiving {data!r} from {self.socket.getpeername()[0]}"
        )
        return data
    def send(self, data: bytes) -&gt; None:
        print(f"Sending {data!r} to {self.socket.getpeername()[0]}")
        self.socket.send(data)
    def close(self) -&gt; None:
        self.socket.close()
</code></pre>
    <p class="normal">This class <a id="_idIndexMarker770"/>decorates a <code class="Code-In-Text--PACKT-">socket</code> object and presents the <code class="Code-In-Text--PACKT-">send()</code>, <code class="Code-In-Text--PACKT-">recv()</code>, and <code class="Code-In-Text--PACKT-">close()</code> interface to clients using it. A better decorator could properly implement all of the arguments to <code class="Code-In-Text--PACKT-">send</code>, (which actually accepts an optional flags argument), but let's keep our example simple. Whenever <code class="Code-In-Text--PACKT-">send()</code> is called on an instance of the <code class="Code-In-Text--PACKT-">LogSocket</code> class, it logs the output to the screen before sending data to the client using the original socket. Similarly, for <code class="Code-In-Text--PACKT-">recv()</code>, it reads and logs the data it received.</p>
    <p class="normal">We only have to change one line in our original code to use this decorator. Instead of calling the <code class="Code-In-Text--PACKT-">dice_response()</code> function with the original client socket, we call it with a decorated socket:</p>
    <pre class="programlisting code"><code class="hljs-code">def main_2() -&gt; None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("localhost", 2401))
    server.listen(1)
    with contextlib.closing(server):
        while True:
            client, addr = server.accept()
            logging_socket = cast(socket.socket, LogSocket(client))
            dice_response(logging_socket)
            client.close()
</code></pre>
    <p class="normal">We've decorated the core <code class="Code-In-Text--PACKT-">socket</code> with a <code class="Code-In-Text--PACKT-">LogSocket</code>. The <code class="Code-In-Text--PACKT-">LogSocket</code> will print to the console as well as invoking methods of the socket it decorates. The essential processing in the <code class="Code-In-Text--PACKT-">dice_response()</code> function doesn't change, because the <code class="Code-In-Text--PACKT-">LogSocket</code> instance behaves like the underlying <code class="Code-In-Text--PACKT-">socket</code> object.</p>
    <p class="normal">Note that we needed to use an explicit <code class="Code-In-Text--PACKT-">cast()</code> to tell <strong class="" style="font-style: italic;">mypy</strong> the <code class="Code-In-Text--PACKT-">LogSocket</code> instance would provide a similar interface to an ordinary <code class="Code-In-Text--PACKT-">socket</code>. For a simple case like this, we have to ask ourselves why we didn't just extend the <code class="Code-In-Text--PACKT-">socket</code> class and override the <code class="Code-In-Text--PACKT-">send</code> method. A subclass could call <code class="Code-In-Text--PACKT-">super().send()</code> and <code class="Code-In-Text--PACKT-">super().recv()</code> to do the actual sending, after we logged it. Decoration offers an advantage over inheritance: a decoration can be reused among various classes in various class hierarchies. In this specific little example, there aren't too many socket-like objects, so the possibilities of reuse are<a id="_idIndexMarker771"/> limited.</p>
    <p class="normal">If we switch our focus to something more generic than a <code class="Code-In-Text--PACKT-">socket</code>, we can create potentially reusable decorators. Processing strings or bytes seems more common than processing a <code class="Code-In-Text--PACKT-">socket</code>. Changing the structure can give us some desirable flexibility in addition to reuse potential. Originally, we broke the processing into a <code class="Code-In-Text--PACKT-">dice_response()</code> function that handled the socket reading and writing, separate from a <code class="Code-In-Text--PACKT-">dice_roller()</code> function that works with bytes. Because the <code class="Code-In-Text--PACKT-">dice_roller()</code> function consumes the request bytes and produces response bytes, it can be a little simpler to expand and add features to it.</p>
    <p class="normal">We can have a family of related decorators. We can decorate already decorated objects. The idea is to give ourselves flexibility through composition. Let's rework the logging decorator to focus on the bytes request and response instead of the <code class="Code-In-Text--PACKT-">socket</code> object. The following should look similar to the earlier example but with some code shifted around to reside in a single <code class="Code-In-Text--PACKT-">__call__()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">Address = Tuple[str, int]
class LogRoller:
    def __init__(
            self, 
            dice: Callable[[bytes], bytes], 
            remote_addr: Address
    ) -&gt; None:
        self.dice_roller = dice
        self.remote_addr = remote_addr
    def __call__(self, request: bytes) -&gt; bytes:
        print(f"Receiving {request!r} from {self.remote_addr}")
        dice_roller = self.dice_roller
        response = dice_roller(request)
        print(f"Sending {response!r} to {self.remote_addr}")
        return response
</code></pre>
    <p class="normal">Here's a second<a id="_idIndexMarker772"/> decorator that compresses data using <code class="Code-In-Text--PACKT-">gzip</code> compression on the resulting bytes:</p>
    <pre class="programlisting code"><code class="hljs-code">import gzip
import io
class ZipRoller:
    def __init__(self, dice: Callable[[bytes], bytes]) -&gt; None:
        self.dice_roller = dice
    def __call__(self, request: bytes) -&gt; bytes:
        dice_roller = self.dice_roller
        response = dice_roller(request)
        buffer = io.BytesIO()
        with gzip.GzipFile(fileobj=buffer, mode="w") as zipfile:
            zipfile.write(response)
        return buffer.getvalue()
</code></pre>
    <p class="normal">This decorator compresses the incoming data before sending it on to the client. It decorates an underlying <code class="Code-In-Text--PACKT-">dice_roller</code> object that computes a response to a request.</p>
    <p class="normal">Now that we have these two decorators, we can write code that piles one decoration on top of another:</p>
    <pre class="programlisting code"><code class="hljs-code">def dice_response(client: socket.socket) -&gt; None:
    request = client.recv(1024)
    try:
        remote_addr = client.getpeername()
        roller_1 = ZipRoller(dice.dice_roller)
        roller_2 = LogRoller(roller_1, remote_addr=remote_addr)
        response = roller_2(request)
    except (ValueError, KeyError) as ex:
        response = repr(ex).encode("utf-8")
    client.send(response)
</code></pre>
    <p class="normal">The intent here is to separate three aspects of this application:</p>
    <ul>
      <li class="bullet">Zipping the resulting document</li>
      <li class="bullet">Writing a log</li>
      <li class="bullet">Doing the underlying computation</li>
    </ul>
    <p class="normal">We can apply the zip or logging to any similar application that works with receiving and sending bytes. We can, if we want, make the zipping operation a dynamic choice, also. We might have a separate configuration file to enable or disable the GZip feature. This means something<a id="_idIndexMarker773"/> like the following:</p>
    <pre class="programlisting code"><code class="hljs-code">if config.zip_feature:
    roller_1 = ZipRoller(dice.dice_roller)
else:
    roller_1 = dice.dice_roller
</code></pre>
    <p class="normal">We have a dynamic set of decorations. Try writing this using a multiple inheritance mixin and see how confused it becomes!</p>
    <h2 id="_idParaDest-240" class="title">Decorators in Python</h2>
    <p class="normal">The Decorator <a id="_idIndexMarker774"/>pattern is useful in Python, but there are additional <a id="_idIndexMarker775"/>options. For example, we can use monkey-patching – changing the class definition at runtime – to get a similar effect. For example, <code class="Code-In-Text--PACKT-">socket.socket.send = log_send</code> will change the way the built-in socket works. There are sometimes surprising implementation details that can make this unpleasantly complex. Single inheritance, where the <em class="italic">optional</em> calculations are done in one large method with a bunch of <code class="Code-In-Text--PACKT-">if</code> statements, could be an option. Multiple inheritance should not be written off just because it's not suitable for the specific example seen previously.</p>
    <p class="normal">In Python, it is very common to use this pattern on functions. As we saw in a previous chapter, functions are objects too. In fact, function decoration is so common that Python provides a special syntax to make it easy to apply such decorators to functions.</p>
    <p class="normal">For example, we can look at the logging example in a more general way. Instead of logging only send calls on sockets, we may find it helpful to log all calls to certain functions or methods. The following example implements a decorator that does just this:</p>
    <pre class="programlisting code"><code class="hljs-code">from functools import wraps
def log_args(function: Callable[..., Any]) -&gt; Callable[..., Any]:
    @wraps(function)
    def wrapped_function(*args: Any, **kwargs: Any) -&gt; Any:
        print(f"Calling {function.__name__}(*{args}, **{kwargs})")
        result = function(*args, **kwargs)
        return result
    return wrapped_function
</code></pre>
    <p class="normal">This decorator function is very similar to the example we explored earlier; in the earlier examples, the decorator took a socket-like object and created a socket-like object. This time, our decorator<a id="_idIndexMarker776"/> takes a function object and returns a new <a id="_idIndexMarker777"/>function object. We've provided a type hint of <code class="Code-In-Text--PACKT-">Callable[..., Any]</code> to state that any function will work here. This code comprises three separate tasks:</p>
    <ul>
      <li class="bullet">A function, <code class="Code-In-Text--PACKT-">log_args()</code>, that accepts another function, <code class="Code-In-Text--PACKT-">function</code>, as a parameter value.</li>
      <li class="bullet">This function defines (internally) a new function, named <code class="Code-In-Text--PACKT-">wrapped_function</code>, that does some extra work before calling the original function and returning the results from the original function.</li>
      <li class="bullet">The new inner function, <code class="Code-In-Text--PACKT-">wrapped_function()</code>, is returned from the decorator function.</li>
    </ul>
    <p class="normal">Because we're using <code class="Code-In-Text--PACKT-">@wraps(function)</code>, the new function will have a copy of the original function's name and the original function's docstring. This avoids having all of the functions we decorate wind up named <code class="Code-In-Text--PACKT-">wrapped_function</code>.</p>
    <p class="normal">Here's a sample function to demonstrate the decorator in use:</p>
    <pre class="programlisting code"><code class="hljs-code">def test1(a: int, b: int, c: int) -&gt; float:
    return sum(range(a, b + 1)) / c
test1 = log_args(test1)
</code></pre>
    <p class="normal">This function can be decorated and used like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; test1(1, 9, 2)
Calling test1(*(1, 9, 2), **{})
22.5
</code></pre>
    <p class="normal">This syntax allows us to build decorated function objects dynamically, just as we did with the socket example. If we don't use assignment to assign the new object to the old name, we can even keep the decorated and the non-decorated versions for different situations. We could use a statement like <code class="Code-In-Text--PACKT-">test1_log = log_args(test1)</code> to create a second, decorated version of the <code class="Code-In-Text--PACKT-">test1()</code> function, named <code class="Code-In-Text--PACKT-">test1_log()</code>.</p>
    <p class="normal">Typically, these decorators are general modifications that are applied permanently to different functions. In this situation, Python supports a special syntax to apply the decorator at the time the function is defined. We've already seen this syntax in a few places; now, let's understand how it works.</p>
    <p class="normal">Instead of applying the decorator function after the method definition, we can use the <code class="Code-In-Text--PACKT-">@decorator</code> syntax to do it all at once:</p>
    <pre class="programlisting code"><code class="hljs-code">@log_args
def test1(a: int, b: int, c: int) -&gt; float:
    return sum(range(a, b + 1)) / c
</code></pre>
    <p class="normal">The<a id="_idIndexMarker778"/> primary <a id="_idIndexMarker779"/>benefit of this syntax is that we can easily see that the function has been decorated whenever we read the function definition. If the decorator is applied later, someone reading the code may miss that the function has been altered at all. Answering a question like <em class="italic">Why is my program logging function calls to the console?</em> can become much more difficult! However, the syntax can only be applied to functions we define, since we don't have access to the source code of other modules. If we need to decorate functions that are part of somebody else's third-party library, we have to use the earlier syntax.</p>
    <p class="normal">Python's decorators permit parameters, also. One of the most useful decorators in the standard library is <code class="Code-In-Text--PACKT-">functools.lru_cache</code>. The idea of a cache is to save computed results of a function to avoid recomputing them. Rather than save all of the parameters and results, we can keep the cache small by discarding the <strong class="keyword">least recently used</strong> (<strong class="keyword">LRU</strong>) values. For example, here's a function that involves a potentially expensive computation:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from math import factorial
&gt;&gt;&gt; def binom(n: int, k: int) -&gt; int:
...     return factorial(n) // (factorial(k) * factorial(n-k))
&gt;&gt;&gt; f"6-card deals: {binom(52, 6):,d}"
'6-card deals: 20,358,520'
</code></pre>
    <p class="normal">We can use the <code class="Code-In-Text--PACKT-">lru_cache</code> decorator to avoid doing this computation once the answer is known. Here's the small change required:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from math import factorial
&gt;&gt;&gt; from functools import lru_cache
&gt;&gt;&gt; @lru_cache(64)
... def binom(n: int, k: int) -&gt; int:
...     return factorial(n) // (factorial(k) * factorial(n-k))
</code></pre>
    <p class="normal">The parameterized decorator, <code class="Code-In-Text--PACKT-">@lru_cache(64)</code>, used to create this second version of the <code class="Code-In-Text--PACKT-">binom()</code> function <a id="_idIndexMarker780"/>means it will save the most recent 64 results to <a id="_idIndexMarker781"/>avoid recomputing values when they've already been computed once. No change is needed elsewhere in the application. Sometimes, the speedup from this small change can be dramatic. We can, of course, fine-tune the size of the cache based on the data and the number of computations that are being performed.</p>
    <p class="normal">Parameterized decorators like this involve a two-step dance. First, we customize the decorator with the parameter, then we apply that customized decorator to a function definition. These two separate steps parallel the way callable objects are initialized with the <code class="Code-In-Text--PACKT-">__init__()</code> method, and can be called, like a function, via their <code class="Code-In-Text--PACKT-">__call__()</code> method.</p>
    <p class="normal">Here's an example of a configurable logging decorator, <code class="Code-In-Text--PACKT-">NamedLogger</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">class NamedLogger:
    def __init__(self, logger_name: str) -&gt; None:
        self.logger = logging.getLogger(logger_name)
    def __call__(
           self, 
           function: Callable[..., Any]
    ) -&gt; Callable[..., Any]:
        @wraps(function)
        def wrapped_function(*args: Any, **kwargs: Any) -&gt; Any:
            start = time.perf_counter()
            try:
                result = function(*args, **kwargs)
                μs = (time.perf_counter() - start) * 1_000_000
                self.logger.info(
                    f"{function.__name__}, { μs:.1f}μs")
                return result
            except Exception as ex:
                μs = (time.perf_counter() - start) * 1_000_000
                self.logger.error(
                    f"{ex}, {function.__name__}, { μs:.1f}μs")
                raise
        return wrapped_function
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__init__()</code> method makes sure we can use code like <code class="Code-In-Text--PACKT-">NamedLogger("log4")</code> to create a decorator; this decorator will make sure the function that follows uses a specific logger.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__call__()</code> method follows the pattern shown above. We define a new function, <code class="Code-In-Text--PACKT-">wrapped_function()</code>, that does the work, and return that newly minted function. We can use it like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; @NamedLogger("log4")
... def test4(median: float, sample: float) -&gt; float:
...     return abs(sample-median)
</code></pre>
    <p class="normal">We've <a id="_idIndexMarker782"/>created <a id="_idIndexMarker783"/>an instance of the <code class="Code-In-Text--PACKT-">NamedLogger</code> class. Then we applied this instance to the <code class="Code-In-Text--PACKT-">test4()</code> function definition. The <code class="Code-In-Text--PACKT-">__call__()</code> method is invoked, and will create a new function, the decorated version of the <code class="Code-In-Text--PACKT-">test4()</code> function.</p>
    <p class="normal">There are a few more use cases for the decorator syntax. For example, when a decorator is a method of a class, it can also save information about the decorated function, creating a registry of decorated functions. Further, classes can also be decorated; in that case, the decorator returns a new class instead of a new function. In all of these more advanced cases, we're using ordinary object-oriented design with the simpler-looking syntax of <code class="Code-In-Text--PACKT-">@decorator</code>.</p>
    <h1 id="_idParaDest-241" class="title">The Observer pattern</h1>
    <p class="normal">The Observer<a id="_idIndexMarker784"/> pattern is <a id="_idIndexMarker785"/>useful for state monitoring and event handling situations. This pattern allows a given object to be monitored by an unknown and dynamic group of <em class="italic">observer</em> objects. The core object being observed needs to implement an interface that makes it <em class="italic">observable</em>.</p>
    <p class="normal">Whenever a value on the core object changes, it lets all the observer objects know that a change has occurred, by calling a method announcing there's been a change of state. This is used widely in GUIs to make sure that any state change in the underlying model is reflected in the views of the model. It's common to have detail and summary views; a change to the details must also update the widgets that display the details and update any summaries that are displayed, also. Sometimes a large change in mode may lead to a number of items being changed. For instance, clicking a "lock" icon may alter a number of displayed items to reflect their status as locked. This can be implemented as a number of observers attached to the observable display widget.</p>
    <p class="normal">In Python, the observer can be notified via the <code class="Code-In-Text--PACKT-">__call__()</code> method, making each observer behave like a function or other callable object. Each observer may be responsible for different tasks whenever the core object changes; the core object doesn't know or care what those tasks are, and the observers don't typically know or care what other observers are doing. </p>
    <p class="normal">This allows tremendous flexibility by decoupling the response to a <a id="_idIndexMarker786"/>state <a id="_idIndexMarker787"/>change from the change itself.</p>
    <p class="normal">Here is a depiction of the<a id="_idIndexMarker788"/> Observer design pattern in UML:</p>
    <figure class="mediaobject"><img src="img/B17070_11_03.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 11.3: Observer pattern in UML</p>
    <p class="normal">We've shown the <code class="Code-In-Text--PACKT-">Core</code> object as containing a list of observer objects. To be observable, the <code class="Code-In-Text--PACKT-">Core</code> class must adhere to a common understanding of observability; specifically, it must provide a list of observers and a way to attach new observers.</p>
    <p class="normal">We've shown the <code class="Code-In-Text--PACKT-">Observer</code> subclasses as having a <code class="Code-In-Text--PACKT-">__call__()</code> method. This will be used by the observable to notify each observer of a state change. As with the Decorator pattern, we don't need to formalize the relationships with formally defined abstract superclasses. In most cases, we can rely on duck typing rules; as long as the observers have the right interface, they can be used in the defined role in this pattern. If they lack the proper <a id="_idIndexMarker789"/>interface, <strong class="" style="font-style: italic;">mypy</strong> may catch the conflict, and a unit test should catch the problem.</p>
    <h2 id="_idParaDest-242" class="title">An Observer example</h2>
    <p class="normal">Outside a GUI, the<a id="_idIndexMarker790"/> Observer pattern is useful for saving intermediate states of objects. Using observer objects can be handy in systems where a rigorous audit of changes is required. It's also handy in a system where chaos reigns and components are unreliable. </p>
    <p class="normal">Complex, cloud-based applications can suffer from chaos issues due to unreliable connections. We can use observers to record state changes, making recovery and restart easier. </p>
    <p class="normal">For this example, we'll define a core object to maintain a collection of important values, and then have one or more observers create serialized copies of that object. These copies might be stored in a database, on a remote host, or in a local file, for example. Because we can have a number of observers, it's easy to modify the design to use different data caches. For this example, we're thinking of a dice game called Zonk or Zilch or Ten Thousand, where a player will roll six dice, score some points for triples and runs, and possibly roll again, leading to a sequence of dice. (The rules are a bit more complex than this glib summary.)</p>
    <p class="normal">We'll start with a few overheads to help make our intention clear:</p>
    <pre class="programlisting code"><code class="hljs-code">from __future__ import annotations
from typing import Protocol
class Observer(Protocol):
    def __call__(self) -&gt; None:
        ...
class Observable:
    def __init__(self) -&gt; None:
        self._observers: list[Observer] = []
    def attach(self, observer: Observer) -&gt; None:
        self._observers.append(observer)
    def detach(self, observer: Observer) -&gt; None:
        self._observers.remove(observer)
    def _notify_observers(self) -&gt; None:
        for observer in self._observers:
            observer()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Observer</code> class is a protocol, an abstract superclass for our observers. We didn't formalize it as an <code class="Code-In-Text--PACKT-">abc.ABC</code> abstract class; we're not relying on the runtime error offered by the <code class="Code-In-Text--PACKT-">abc</code> module. When defining a <code class="Code-In-Text--PACKT-">Protocol</code>, we're relying on <strong class="" style="font-style: italic;">mypy</strong> to confirm that all observers actually implement the required method.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Observable</code> class defines the <code class="Code-In-Text--PACKT-">_observers</code> instance variable and three methods that are purely part of this protocol definition. An observable object can append an observer, remove an observer, and – most important – notify all the observers of a state change. The only thing the core class needs to do that's special or different is to make calls to the <code class="Code-In-Text--PACKT-">_notify_observers()</code> method when there's a state change. Appropriate notification is an important piece of the design for an observable object.</p>
    <p class="normal">Here's part of the<a id="_idIndexMarker791"/> Zonk game we care about. This class keeps a player's hands:</p>
    <pre class="programlisting code"><code class="hljs-code">from typing import List
Hand = List[int]
class ZonkHandHistory(Observable):
    def __init__(self, player: str, dice_set: Dice) -&gt; None:
        super().__init__()
        self.player = player
        self.dice_set = dice_set
        self.rolls: list[Hand]
    def start(self) -&gt; Hand:
        self.dice_set.roll()
        self.rolls = [self.dice_set.dice]
        self._notify_observers()  # State change
        return self.dice_set.dice
    def roll(self) -&gt; Hand:
        self.dice_set.roll()
        self.rolls.append(self.dice_set.dice)
        self._notify_observers()  # State change
        return self.dice_set.dice
</code></pre>
    <p class="normal">This class makes calls to <code class="Code-In-Text--PACKT-">self._notify_observers()</code> on important state changes. This will notify all the observer instances. The observers might cache copies of the hand, send details over a network, update widgets on a GUI – any number of things. The <code class="Code-In-Text--PACKT-">_notify_observers()</code> method inherited from <code class="Code-In-Text--PACKT-">Observable</code> iterates over any registered observers and lets each know that the state of the hand has changed.</p>
    <p class="normal">Now let's implement a simple observer object; this one will print out some state to the console:</p>
    <pre class="programlisting code"><code class="hljs-code">class SaveZonkHand(Observer):
    def __init__(self, hand: ZonkHandHistory) -&gt; None:
        self.hand = hand
        self.count = 0
    def __call__(self) -&gt; None:
        self.count += 1
        message = {
            "player": self.hand.player,
            "sequence": self.count,
            "hands": json.dumps(self.hand.rolls),
            "time": time.time(),
        }
        print(f"SaveZonkHand {message}")
</code></pre>
    <p class="normal">There's nothing terribly <a id="_idIndexMarker792"/>exciting here; the observed object is set up in the initializer, and when the observer is called, we do <em class="italic">something</em>, in this example, printing a line. Note that the superclass, <code class="Code-In-Text--PACKT-">Observer</code>, isn't actually needed here. The context in which this class is used is sufficient for <strong class="" style="font-style: italic;">mypy</strong> to confirm this class matches the required <code class="Code-In-Text--PACKT-">Observer</code> protocol. While we don't need to state that it's an <code class="Code-In-Text--PACKT-">Observer</code>, it can help readers to see that this class implements the <code class="Code-In-Text--PACKT-">Observer</code> protocol.</p>
    <p class="normal">We can test the <code class="Code-In-Text--PACKT-">SaveZonkHand</code> observer in an interactive console:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; d = Dice.from_text("6d6")
&gt;&gt;&gt; player = ZonkHandHistory("Bo", d)
&gt;&gt;&gt; save_history = SaveZonkHand(player)
&gt;&gt;&gt; player.attach(save_history)
&gt;&gt;&gt; r1 = player.start()
SaveZonkHand {'player': 'Bo', 'sequence': 1, 'hands': '[[1, 1, 2, 3, 6, 6]]', 'time': 1609619907.52109}
&gt;&gt;&gt; r1
[1, 1, 2, 3, 6, 6]
&gt;&gt;&gt; r2 = player.roll()
SaveZonkHand {'player': 'Bo', 'sequence': 2, 'hands': '[[1, 1, 2, 3, 6, 6], [1, 2, 2, 6, 6, 6]]', 'time': ...}
</code></pre>
    <p class="normal">After attaching the observer to the <code class="Code-In-Text--PACKT-">Inventory</code> object, whenever we change one of the two observed properties, the observer is called and its action is invoked. Note that our observer tracks a sequence number and includes a timestamp. These are outside the game definition, and are kept separate from the essential game processing by being part of the <code class="Code-In-Text--PACKT-">SaveZonkHand</code> observer class.</p>
    <p class="normal">We can add multiple observers of a variety of classes. Let's add a second observer that has a limited job <a id="_idIndexMarker793"/>to check for three pairs and announce it:</p>
    <pre class="programlisting code"><code class="hljs-code">class ThreePairZonkHand:
    """Observer of ZonkHandHistory"""
    def __init__(self, hand: ZonkHandHistory) -&gt; None:
        self.hand = hand
        self.zonked = False
    def __call__(self) -&gt; None:
        last_roll = self.hand.rolls[-1]
        distinct_values = set(last_roll)
        self.zonked = len(distinct_values) == 3 and all(
            last_roll.count(v) == 2 for v in distinct_values
        )
        if self.zonked:
            print("3 Pair Zonk!")
</code></pre>
    <p class="normal">For this example, we omitted naming <code class="Code-In-Text--PACKT-">Observer</code> as a superclass. We can trust the <strong class="" style="font-style: italic;">mypy</strong> tool to note how this class is used and what protocols it must implement. Introducing this new <code class="Code-In-Text--PACKT-">ThreePairZonkHand</code> observer means that when we change the state of the hand, there may be two sets of output, one for each observer. The key idea here is that we can easily add totally different types of observers to do different kinds of things, in this case, copying the data as well as checking for a special case in the data.</p>
    <p class="normal">The Observer pattern detaches the code being observed from the code doing the observing. If we were not using this pattern, we would have had to put code in the <code class="Code-In-Text--PACKT-">ZonkHandHistory</code> class to handle the different cases that might come up: logging to the console, updating a <a id="_idIndexMarker794"/>database or file, checking for special cases, and so on. The code for each of these tasks would all be mixed in with the core class definition. Maintaining it would be a nightmare and adding new monitoring functionality at a later date would be painful.</p>
    <h1 id="_idParaDest-243" class="title">The Strategy pattern</h1>
    <p class="normal">The Strategy pattern<a id="_idIndexMarker795"/> is a common demonstration of abstraction in object-oriented<a id="_idIndexMarker796"/> programming. The pattern implements different solutions to a single problem, each in a different object. The core class can then choose the most appropriate implementation dynamically at runtime.</p>
    <p class="normal">Typically, different algorithms have different trade-offs; one might be faster than another, but uses a lot more memory, while a third algorithm may be most suitable when multiple CPUs are present or a distributed system is provided. </p>
    <p class="normal">Here is the Strategy pattern in UML:</p>
    <figure class="mediaobject"><img src="img/B17070_11_04.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 11.4: Strategy pattern in UML</p>
    <p class="normal">The <strong class="keyword">Core</strong> code connecting<a id="_idIndexMarker797"/> to the <strong class="keyword">Strategy</strong> abstraction simply needs to know that it is dealing with some kind of class that fits the Strategy interface for this particular action. Each of the implementations should perform the same task, but in different ways. The implementation interfaces need to be identical, and it's often helpful to leverage an abstract base<a id="_idIndexMarker798"/> class to make sure the implementations match.</p>
    <div><p class="Tip--PACKT-">This idea of a plug-in strategy is also an aspect of the Observer pattern. Indeed, the idea of strategy objects is an important aspect of many of the patterns covered in this chapter. The common idea is to use a separate object to isolate conditional or replaceable processing and delegate the work to the separate object. This works for observables, decorations, and – as we'll see – commands and states, also.</p>
    </div>
    <h2 id="_idParaDest-244" class="title">A Strategy example</h2>
    <p class="normal">One common<a id="_idIndexMarker799"/> example of the Strategy pattern is sort routines; over the years, numerous algorithms have been invented for sorting a collection of objects. Quick sort, merge sort, and heap sort are all algorithms with different features, each useful in its own right, depending on the size and type of inputs, how out of order they are, and the requirements of the system.</p>
    <p class="normal">If we have client code that needs to sort a collection, we could pass it to an object with a <code class="Code-In-Text--PACKT-">sort()</code> method. This object may be a <code class="Code-In-Text--PACKT-">QuickSorter</code> or <code class="Code-In-Text--PACKT-">MergeSorter</code> object, but the result will be the same in either case: a sorted list. The strategy used to do the sorting is abstracted from the calling code, making it modular and replaceable.</p>
    <p class="normal">Of course, in Python, we typically just call the <code class="Code-In-Text--PACKT-">sorted()</code> function or <code class="Code-In-Text--PACKT-">list.sort()</code> method and trust that it will do the sorting quickly enough that the details of the TimSort algorithm don't really matter. For details on how amazingly fast TimSort is, see <a href="https://bugs.python.org/file4451/timsort.txt">https://bugs.python.org/file4451/timsort.txt</a>. While sorting is a helpful concept, it's not the most practical example, so let's look at something different.</p>
    <p class="normal">As a simpler example of the Strategy design pattern, consider a desktop wallpaper manager. When an image is displayed on a desktop background, it can be adjusted to the screen size in different ways. For example, assuming the image is smaller than the screen, it can be tiled across the screen, centered on it, or scaled to fit. There are other, more complicated strategies that can be used as well, such as scaling to the maximum height or width, combining it with a solid, semi-transparent, or gradient background color, or other manipulations. While we may want to add these strategies later, let's start with a few basic ones.</p>
    <p class="normal">You'll need to install the <code class="Code-In-Text--PACKT-">pillow</code> module. If you're using <strong class="keyword">conda</strong> to manage your virtual environments, use <code class="Code-In-Text--PACKT-">conda install pillow</code> to install<a id="_idIndexMarker800"/> the Pillow project's <code class="Code-In-Text--PACKT-">PIL</code> implementation. If you're not using <strong class="keyword">conda</strong>, use <code class="Code-In-Text--PACKT-">python -m pip install pillow</code>.</p>
    <p class="normal">Our Strategy objects need to take two inputs: the image to be displayed, and a tuple of the width and height of the screen. They each return a new image the size of the screen, with the image manipulated to fit according to the given strategy. </p>
    <p class="normal">Here are some preliminary <a id="_idIndexMarker801"/>definitions, including an abstract superclass for all of the strategy variants:</p>
    <pre class="programlisting code"><code class="hljs-code">import abc
from pathlib import Path
from PIL import Image  # type: ignore [import]
from typing import Tuple
Size = Tuple[int, int]
class FillAlgorithm(abc.ABC):
    @abc.abstractmethod
    def make_background(
            self, 
            img_file: Path, 
            desktop_size: Size
    ) -&gt; Image:
        pass
</code></pre>
    <p class="normal">Is this abstraction necessary? This sits right on the fence between too simple to require an abstraction and complex enough that the superclass helps. The function signature is kind of complex, with a special type hint to describe the size tuple. For this reason, the abstraction can help check each implementation to be sure all the types match. </p>
    <p class="normal">Note that we need to include the special <code class="Code-In-Text--PACKT-"># type: ignore [import]</code> comment to make sure <strong class="" style="font-style: italic;">mypy</strong> isn't confused by the lack of annotations in the PIL modules. </p>
    <p class="normal">Here's our first concrete strategy; this is a fill algorithm that tiles the images:</p>
    <pre class="programlisting code"><code class="hljs-code">class TiledStrategy(FillAlgorithm):
    def make_background(
            self, 
            img_file: Path, 
            desktop_size: Size
    ) -&gt; Image:
        in_img = Image.open(img_file)
        out_img = Image.new("RGB", desktop_size)
        num_tiles = [
            o // i + 1 for o, i in zip(out_img.size, in_img.size)]
        for x in range(num_tiles[0]):
            for y in range(num_tiles[1]):
                out_img.paste(
                    in_img,
                    (
                        in_img.size[0] * x,
                        in_img.size[1] * y,
                        in_img.size[0] * (x + 1),
                        in_img.size[1] * (y + 1),
                    ),
                )
        return out_img
</code></pre>
    <p class="normal">This works by dividing the output height and width by the input image height and width. The <code class="Code-In-Text--PACKT-">num_tiles</code> sequence<a id="_idIndexMarker802"/> is a way of doing the same computation to widths and heights. It's a two-tuple computed via a list comprehension to be sure both width and height are processed the same way. </p>
    <p class="normal">Here's a fill algorithm that centers the image without re-scaling it:</p>
    <pre class="programlisting code"><code class="hljs-code">class CenteredStrategy(FillAlgorithm):
    def make_background(
            self, 
            img_file: Path, 
            desktop_size: Size
    ) -&gt; Image:
        in_img = Image.open(img_file)
        out_img = Image.new("RGB", desktop_size)
        left = (out_img.size[0] - in_img.size[0]) // 2
        top = (out_img.size[1] - in_img.size[1]) // 2
        out_img.paste(
            in_img,
            (left, top, left + in_img.size[0], top + in_img.size[1]),
        )
        return out_img
</code></pre>
    <p class="normal">Finally, here's a fill algorithm that scales the image up to fill the entire screen:</p>
    <pre class="programlisting code"><code class="hljs-code">class ScaledStrategy(FillAlgorithm):
    def make_background(
            self, 
            img_file: Path, 
            desktop_size: Size
    ) -&gt; Image:
        in_img = Image.open(img_file)
        out_img = in_img.resize(desktop_size)
        return out_img
</code></pre>
    <p class="normal">Here we have three strategy subclasses, each using <code class="Code-In-Text--PACKT-">PIL.Image</code> to perform their task. All the strategy implementations have a <code class="Code-In-Text--PACKT-">make_background()</code> method that accepts the same set of parameters. Once selected, the appropriate Strategy object can be called to create a correctly sized version of the desktop image. <code class="Code-In-Text--PACKT-">TiledStrategy</code> computes the number of input image tiles that would fit in the width and height of the display screen and copies the image into each tile location, repeatedly, without rescaling, so it may not fill the entire space. <code class="Code-In-Text--PACKT-">CenteredStrategy</code> figures out how much space needs to be left on the four edges of the image to center it. <code class="Code-In-Text--PACKT-">ScaledStrategy</code> forces the image to the output size, without preserving the original aspect ratio.</p>
    <p class="normal">Here's an overall object that does resizing, using one of these Strategy classes. The <code class="Code-In-Text--PACKT-">algorithm</code> instance variable<a id="_idIndexMarker803"/> is filled in when a <code class="Code-In-Text--PACKT-">Resizer</code> instance is created: </p>
    <pre class="programlisting code"><code class="hljs-code">class Resizer:
    def __init__(self, algorithm: FillAlgorithm) -&gt; None:
        self.algorithm = algorithm
    def resize(self, image_file: Path, size: Size) -&gt; Image:
        result = self.algorithm.make_background(image_file, size)
        return result
</code></pre>
    <p class="normal">And here's a <code class="Code-In-Text--PACKT-">main</code> function that builds an instance of the <code class="Code-In-Text--PACKT-">Resizer</code> class and applies one of the available Strategy classes:</p>
    <pre class="programlisting code"><code class="hljs-code">def main() -&gt; None:
    image_file = Path.cwd() / "boat.png"
    tiled_desktop = Resizer(TiledStrategy())
    tiled_image = tiled_desktop.resize(image_file, (1920, 1080))
    tiled_image.show()
</code></pre>
    <p class="normal">What's important is the binding of the Strategy instance happens as late as possible in the processing. The decision can be made (and unmade) at any point in the processing because any of the available strategy objects can be plugged into a <code class="Code-In-Text--PACKT-">Resizer</code> object at any time.</p>
    <p class="normal">Consider how switching between these options would be implemented without the Strategy pattern. We'd need to put all the code inside one great big method and use an awkward <code class="Code-In-Text--PACKT-">if</code> statement to select the expected one. Every time we wanted to add a new strategy, we'd have to make the method even more ungainly.</p>
    <h2 id="_idParaDest-245" class="title">Strategy in Python</h2>
    <p class="normal">The<a id="_idIndexMarker804"/> preceding <a id="_idIndexMarker805"/>canonical implementation of the Strategy pattern, while very common in most object-oriented libraries, isn't ideal in Python. It involves some overheads that aren't really necessary.</p>
    <p class="normal">These strategy classes each define objects that do nothing but provide a single method. We could just as easily call that function <code class="Code-In-Text--PACKT-">__call__</code> and make the object callable directly. Since there is no other data associated with the object, we need do no more than create a set of top-level functions and pass them around as our strategies instead.</p>
    <p class="normal">Instead of the overheads of an abstract class, we could summarize these strategies with a type hint of:</p>
    <pre class="programlisting code"><code class="hljs-code">FillAlgorithm = Callable[[Image, Size], Image]
</code></pre>
    <p class="normal">When we do this, we can eliminate all of the references to <code class="Code-In-Text--PACKT-">FillAlgorithm</code> in class definitions; we'd change <code class="Code-In-Text--PACKT-">class CenteredStrategy(FillAlgorithm):</code> to <code class="Code-In-Text--PACKT-">class CenteredStrategy</code><code class="Code-In-Text--PACKT-">:</code>.</p>
    <p class="normal">Because we <a id="_idIndexMarker806"/>have a choice between an abstract class and a type hint, the Strategy design pattern seems superfluous. This leads to an odd conversation, starting with <em class="italic">"Because Python has first-class functions, the Strategy pattern is unnecessary."</em> In truth, Python's first-class functions allow us to implement the Strategy pattern in a more straightforward way, without the overhead of class definitions. The pattern is more than the implementation details. Knowing the pattern can help us choose a good design for our program, and implement it using the most readable syntax. The Strategy pattern, whether a class or a top-level function, should be used when we need to allow client code or the end user to select from multiple implementations of the <a id="_idIndexMarker807"/>same interface at runtime.</p>
    <p class="normal">There's a bright line separating mixin class definitions from plug-in strategy objects. As we saw in <em class="chapterRef">Chapter 6</em>, <em class="italic">Abstract Base Classes and Operator Overloading</em>, mixin class definitions are created in the source code, and cannot easily be tweaked at runtime. A plug-in strategy object, however, is filled in at runtime, allowing late binding of the strategy. The code tends to be very similar between them, and it helps to have clear docstrings on each class to explain how the various classes fit together.</p>
    <h1 id="_idParaDest-246" class="title">The Command pattern</h1>
    <p class="normal">When we think<a id="_idIndexMarker808"/> about class <a id="_idIndexMarker809"/>responsibilities, we can sometimes distinguish "passive" classes that hold objects and maintain an internal state, but don't initiate very much, and "active" classes that reach out into other objects to take action and do things. This is not a very crisp distinction, but it can help separate the relatively passive Observer and the more active Command design patterns. An Observer is notified that something changed. A Commander, on the other hand, will be active, making state changes in other objects. We can combine the two aspects, and that's one of the beauties of talking about a software architecture by describing the various patterns that apply to a class or a relationship among classes.</p>
    <p class="normal">The Command pattern generally involves a hierarchy of classes that each do something. A Core class can create a command (or a sequence of commands) to carry out actions. </p>
    <p class="normal">In a way, it's a kind of meta-programming: by creating Command objects that contain a bunch of statements, the design has a higher-level "language" of Command objects.</p>
    <p class="normal">Here's a UML<a id="_idIndexMarker810"/> diagram <a id="_idIndexMarker811"/>showing a <strong class="keyword">Core</strong> object and a collection of <strong class="keyword">Commands</strong>:</p>
    <figure class="mediaobject"><img src="img/B17070_11_05.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 11.5: Command pattern in UML</p>
    <p class="normal">This looks similar to the diagrams for the Strategy and Observer patterns because all these patterns rely on delegating work from a <strong class="keyword">Core</strong> object to a plug-in object. In this case, a sequence of <a id="_idIndexMarker812"/>individual plug-in objects that represent a sequence of commands to perform.</p>
    <h2 id="_idParaDest-247" class="title">A Command example</h2>
    <p class="normal">As an <a id="_idIndexMarker813"/>example, we'll look at the fancy dice rolling that was omitted from the Decorator pattern example earlier in this chapter. In the earlier example, we had a function, <code class="Code-In-Text--PACKT-">dice_roller()</code>, that computed a sequence of random numbers:</p>
    <pre class="programlisting code"><code class="hljs-code">def dice_roller(request: bytes) -&gt; bytes:
    request_text = request.decode("utf-8")
    numbers = [random.randint(1, 6) for _ in range(6)]
    response = f"{request_text} = {numbers}"
    return response.encode("utf-8")
</code></pre>
    <p class="normal">This isn't very clever; we'd rather handle something a little more sophisticated. We want to be able to write strings like <code class="Code-In-Text--PACKT-">3d6</code> to mean three six-sided dice, <code class="Code-In-Text--PACKT-">3d6+2</code> to mean three six-sided dice plus a bonus of two more, and something a little more obscure like <code class="Code-In-Text--PACKT-">4d6d1</code> to mean "roll four six-sided dice and drop one of the lowest dice." We might want to combine things and write <code class="Code-In-Text--PACKT-">4d6d1+2</code>, also, to combine dropping the lowest and adding two to the result.</p>
    <p class="normal">These <code class="Code-In-Text--PACKT-">d1</code> and <code class="Code-In-Text--PACKT-">+2</code> options at the end can be viewed as a series of commands. There are four common varieties: "drop," "keep," "add," and "subtract." There can be a lot more, of course, to reflect a wide variety of game mechanics and desired statistical distributions, but we'll look at four commands that modify a batch of dice.</p>
    <p class="normal">Here's the regular expression we're going to implement:</p>
    <pre class="programlisting code"><code class="hljs-code">dice_pattern = re.compile(r"(?P&lt;n&gt;\d*)d(?P&lt;d&gt;\d+)(?P&lt;a&gt;[dk+-]\d+)*")
</code></pre>
    <p class="normal">This regular expression can be a little daunting. Some people find the railroad diagrams at <a href="https://www.debuggex.com">https://www.debuggex.com</a> to be helpful. Here's a depiction as a UML state diagram:</p>
    <figure class="mediaobject"><img src="img/B17070_11_06.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 11.6: Dice-parsing regular expression</p>
    <p class="normal">This pattern has four parts: </p>
    <ol>
      <li class="numbered" value="1">The first<a id="_idIndexMarker814"/> grouping, <code class="Code-In-Text--PACKT-">(?P&lt;n&gt;\d*)</code>, captures a batch of digits for the number of dice, saving this as a group named <code class="Code-In-Text--PACKT-">n</code>. This is optional, allowing us to write <code class="Code-In-Text--PACKT-">d6</code> instead of <code class="Code-In-Text--PACKT-">1d6</code>.</li>
      <li class="numbered">The letter "d", which must be present, but isn't captured.</li>
      <li class="numbered">The next grouping, <code class="Code-In-Text--PACKT-">(?P&lt;d&gt;\d+)</code>, captures the digits for the number of faces on each die, saving this as a group named <code class="Code-In-Text--PACKT-">d</code>. If we were very fussy, we might try to limit this to <code class="Code-In-Text--PACKT-">(4|6|8|10|12|20|100)</code> to define an acceptable list of regular polyhedral dice (and two common irregular polyhedrons). We didn't provide this short list; instead, we'll accept any sequence of digits.</li>
      <li class="numbered">The final grouping, <code class="Code-In-Text--PACKT-">(?P&lt;a&gt;[dk+-]\d+)*</code>, defines a repeating series of adjustments. Each one has a prefix and a sequence of digits, for example, <code class="Code-In-Text--PACKT-">d1</code> or <code class="Code-In-Text--PACKT-">k3</code> or <code class="Code-In-Text--PACKT-">+1</code> or <code class="Code-In-Text--PACKT-">-2</code>. We'll capture the whole sequence of adjustments as group <code class="Code-In-Text--PACKT-">a</code>, and decompose the parts separately. Each of these parts will become a command, following the Command design pattern.</li>
    </ol>
    <p class="normal">We can think of each part of dice rolling as a distinct command. One command rolls the dice, and then subsequent commands adjust the value of the dice. For example, <code class="Code-In-Text--PACKT-">3d6+2</code> means roll three dice (for example, <img src="img/1.png" alt=""/>, <img src="img/1.png" alt=""/>, <img src="img/3.png" alt=""/>) and add 2 to get 13 in total. The class, overall, looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">class Dice:
    def __init__(self, n: int, d: int, *adj: Adjustment) -&gt; None:
        self.adjustments = [cast(Adjustment, Roll(n, d))] + list(adj)
        self.dice: list[int]
        self.modifier: int
    def roll(self) -&gt; int:
        for a in self.adjustments:
            a.apply(self)
        return sum(self.dice) + self.modifier
</code></pre>
    <p class="normal">When we want a new roll of the dice, a <code class="Code-In-Text--PACKT-">Dice</code> object applies the individual <code class="Code-In-Text--PACKT-">Adjustment</code> objects to create a new roll. We can see one of the kinds of <code class="Code-In-Text--PACKT-">Adjustment</code> objects in the <code class="Code-In-Text--PACKT-">__init__()</code> method: a <code class="Code-In-Text--PACKT-">Roll</code> object. This is put first into a sequence of adjustments; after that any additional adjustments are processed in order. Each adjustment is another kind of command.</p>
    <p class="normal">Here are the <a id="_idIndexMarker815"/>various kinds of adjustment commands that change the state of a <code class="Code-In-Text--PACKT-">Dice</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code">class Adjustment(abc.ABC):
    def __init__(self, amount: int) -&gt; None:
        self.amount = amount
    @abc.abstractmethod
    def apply(self, dice: "Dice") -&gt; None:
        ...
class Roll(Adjustment):
    def __init__(self, n: int, d: int) -&gt; None:
        self.n = n
        self.d = d
    def apply(self, dice: "Dice") -&gt; None:
        dice.dice = sorted(
            random.randint(1, self.d) for _ in range(self.n))
        dice.modifier = 0
class Drop(Adjustment):
    def apply(self, dice: "Dice") -&gt; None:
        dice.dice = dice.dice[self.amount :]
class Keep(Adjustment):
    def apply(self, dice: "Dice") -&gt; None:
        dice.dice = dice.dice[: self.amount]
class Plus(Adjustment):
    def apply(self, dice: "Dice") -&gt; None:
        dice.modifier += self.amount
class Minus(Adjustment):
    def apply(self, dice: "Dice") -&gt; None:
        dice.modifier -= self.amount
</code></pre>
    <p class="normal">An instance of the <code class="Code-In-Text--PACKT-">Roll()</code> class sets the values of the dice and the modifier attribute of a <code class="Code-In-Text--PACKT-">Dice</code> instance. The other <code class="Code-In-Text--PACKT-">Adjustment</code> objects either remove some dice or change the modifier. The <a id="_idIndexMarker816"/>operations depend on the dice being sorted. That makes it easy to drop the worst or keep the best via slice operations. Because each adjustment is a kind of command, they make adjustments to the overall state of the dice that were rolled.</p>
    <p class="normal">The missing piece is translating the string dice expression into a sequence of <code class="Code-In-Text--PACKT-">Adjustment</code> objects. We've made this a <code class="Code-In-Text--PACKT-">@classmethod</code> of the <code class="Code-In-Text--PACKT-">Dice</code> class. This lets us use <code class="Code-In-Text--PACKT-">Dice.from_text()</code> to create a new <code class="Code-In-Text--PACKT-">Dice</code> instance. It also provides the subclass as the first parameter value, <code class="Code-In-Text--PACKT-">cls</code>, making sure that each subclass creates proper instances of itself, not this parent class. Here's the definition of this method:</p>
    <pre class="programlisting code"><code class="hljs-code">@classmethod
def from_text(cls, dice_text: str) -&gt; "Dice":
    dice_pattern = re.compile(
        r"(?P&lt;n&gt;\d*)d(?P&lt;d&gt;\d+)(?P&lt;a&gt;[dk+-]\d+)*")
    adjustment_pattern = re.compile(r"([dk+-])(\d+)")
    adj_class: dict[str, Type[Adjustment]] = {
        "d": Drop,
        "k": Keep,
        "+": Plus,
        "-": Minus,
    }
    if (dice_match := dice_pattern.match(dice_text)) is None:
        raise ValueError(f"Error in {dice_text!r}")
    n = int(dice_match.group("n")) if dice_match.group("n") else 1
    d = int(dice_match.group("d"))
    adjustment_matches = adjustment_pattern.finditer(
        dice_match.group("a") or "")
    adjustments = [
        adj_class[a.group(1)](int(a.group(2))) 
        for a in adjustment_matches
    ]
    return cls(n, d, *adjustments)
</code></pre>
    <p class="normal">The overall <code class="Code-In-Text--PACKT-">dice_pattern</code> is applied first and the result is assigned to the <code class="Code-In-Text--PACKT-">dice_match</code> variable. If the result is a <code class="Code-In-Text--PACKT-">None</code> object, the pattern didn't match, and we can't do much more than raise a <code class="Code-In-Text--PACKT-">ValueError</code> exception and give up. The <code class="Code-In-Text--PACKT-">adjustment_pattern</code> is used to decompose the string of adjustments in the suffix of the dice expression. A list comprehension is used to create a list of objects from the <code class="Code-In-Text--PACKT-">Adjustment</code> class definitions.</p>
    <p class="normal">Each adjustment class is a separate command. The <code class="Code-In-Text--PACKT-">Dice</code> class will inject a special command, <code class="Code-In-Text--PACKT-">Roll</code>, that starts the processing by simulating a roll of the dice. Then the adjust commands<a id="_idIndexMarker817"/> can apply their individual changes to the initial roll. </p>
    <p class="normal">This design allows us to manually create an instance like this:</p>
    <pre class="programlisting code"><code class="hljs-code"> dice.Dice(4, dice.D6, dice.Keep(3))
</code></pre>
    <p class="normal">The first two parameters define the special <code class="Code-In-Text--PACKT-">Roll</code> command. The remaining parameters can include any number of further adjustments. In this case, there's only one, a <code class="Code-In-Text--PACKT-">Keep(3)</code> command. The alternative is to parse text, like this: <code class="Code-In-Text--PACKT-">dice.Dice.from_text("4d6k3")</code>. This will build the <code class="Code-In-Text--PACKT-">Roll</code> command and the other <code class="Code-In-Text--PACKT-">Adjustment</code> commands. Each time we want a new roll of the dice, the sequence of commands is executed, rolling the dice and then adjusting that roll to give a final outcome.</p>
    <h1 id="_idParaDest-248" class="title">The State pattern</h1>
    <p class="normal">The State pattern <a id="_idIndexMarker818"/>is structurally similar to the Strategy pattern, but its intent and purpose <a id="_idIndexMarker819"/>are very different. The goal of the State pattern is to represent state transition systems: systems where an object's behavior is constrained by the state it's in, and there are narrowly defined transitions to other states.</p>
    <p class="normal">To make this work, we need a manager or context class that provides an interface for switching states. Internally, this class contains a pointer to the current state. Each state knows what other states it is allowed to be in and will transition to those states depending on the actions invoked upon it.</p>
    <p class="normal">Here's how it looks in UML:</p>
    <figure class="mediaobject"><img src="img/B17070_11_07.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 11.7: State pattern in UML</p>
    <p class="normal">The State pattern decomposes the <a id="_idIndexMarker820"/>problem into two types of classes: the <strong class="keyword">Core</strong> class and multiple <strong class="keyword">State</strong> classes. The <strong class="keyword">Core</strong> class maintains the current state, and forwards actions to a current state <a id="_idIndexMarker821"/>object. The <strong class="keyword">State</strong> objects are typically hidden from any other objects that are calling the <strong class="keyword">Core</strong> object; it acts like a black box that happens to perform state management internally.</p>
    <h2 id="_idParaDest-249" class="title">A State example</h2>
    <p class="normal">One of the most <a id="_idIndexMarker822"/>compelling state-specific processing examples is parsing text. When we write a regular expression, we're detailing a series of alternative state changes used to match a pattern against a sample piece of text. At a higher level, parsing the text of a programming language or a markup language is also highly stateful work. Markup languages like XML, HTML, YAML, TOML, or even reStructuredText and Markdown all have stateful rules for what is allowed next and what is not allowed next.</p>
    <p class="normal">We'll look at a relatively simple language that crops up when solving <strong class="keyword">Internet of Things</strong> (<strong class="keyword">IoT</strong>) problems. The<a id="_idIndexMarker823"/> data stream from a GPS receiver is an interesting problem. Parsing statements in this language is an example of the State design pattern. The language is the NMEA 0183 language from the National Marine Electronics Association. </p>
    <p class="normal">The output from a GPS antenna is a stream of bytes that form a sequence of "sentences." Each sentence starts with <code class="Code-In-Text--PACKT-">$</code>, includes printable characters in the ASCII encoding, and ends with a carriage return and a newline character. A GPS device's output includes a number of different kinds of sentences, including the following:</p>
    <ul>
      <li class="bullet">GPRMC – recommended minimum data</li>
      <li class="bullet">GPGGA – global position</li>
      <li class="bullet">GPGLL – latitude and longitude</li>
      <li class="bullet">GPGSV – satellites in view</li>
      <li class="bullet">GPGSA – active satellites</li>
    </ul>
    <p class="normal">There are many, many more messages available, and they come out of the antenna device at a pace<a id="_idIndexMarker824"/> that can be bewildering. They all have a common format, however, making them easy to validate and filter so we can use the good ones, and ignore the ones that aren't providing useful information for our specific application.</p>
    <p class="normal">A typical message looks like this:</p>
    <pre class="programlisting gen"><code class="hljs">$GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A*41
</code></pre>
    <p class="normal">This sentence has the following structure:</p>
    <table id="table001-5" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">$</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Starts the sentence</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">GPGLL</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The "talker," GP, and the type of message, GLL</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">3723.2475</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Latitude, 37°23.2475</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">N</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">North of the equator</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">12158.3416</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Longitude, 121°58.3416</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">W</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">West of the 0° meridian</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">161229.487</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The timestamp in UTC: 16:12:29.487</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">A</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Status, <code class="Code-In-Text--PACKT-">A</code>=valid, <code class="Code-In-Text--PACKT-">V</code>=not valid</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">A</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Mode, <code class="Code-In-Text--PACKT-">A</code>=Autonomous, <code class="Code-In-Text--PACKT-">D</code>=DGPS, <code class="Code-In-Text--PACKT-">E</code>=DR</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">*</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Ends the sentence, starts the checksum</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="normal"><code class="Code-In-Text--PACKT-">41</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Hexadecimal checksum of the text (excluding the <code class="Code-In-Text--PACKT-">$</code> and <code class="Code-In-Text--PACKT-">*</code> characters)</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">With a few exceptions, all <a id="_idIndexMarker825"/>the messages from a GPS will have a similar pattern. The exceptional messages will start with <code class="Code-In-Text--PACKT-">!</code>, and our design will safely ignore them.</p>
    <p class="normal">When building IoT devices, we need to be aware of two complicating factors:</p>
    <ol>
      <li class="numbered" value="1">Things aren't very reliable, meaning our software must be prepared for broken or incomplete messages.</li>
      <li class="numbered">The devices are tiny and some common Python techniques that work on a large, general-purpose laptop computer won't work well in a tiny Circuit Playground Express chip with only 32K of memory.</li>
    </ol>
    <p class="normal">What we need to do, then, is to read and validate the message as the bytes arrive. This saves time (and memory) when ingesting data. Because there's a defined upper bound of 82 bytes for these GPS messages, we can use Python <code class="Code-In-Text--PACKT-">bytearray</code> structures as a place to process the bytes of a message. </p>
    <p class="normal">The process for reading a message has a number of distinct states. The following state transition diagram <a id="_idIndexMarker826"/>shows the available state changes:</p>
    <figure class="mediaobject"><img src="img/B17070_11_08.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 11.8: State transitions to parse NMEA sentences</p>
    <p class="normal">We start in a state of waiting for the next <code class="Code-In-Text--PACKT-">$</code>. We'll assume that IoT devices have loose wires and power problems. (Some people can solder really well, so unreliability may not be as common for them as it is for the authors.)</p>
    <p class="normal">Once we've received the <code class="Code-In-Text--PACKT-">$</code>, we'll transition to a state of reading the five-character header. If, at any time, we get another <code class="Code-In-Text--PACKT-">$</code>, it means we lost some bytes somewhere, and we need to start over again. Once we have all five characters with the message name, we can transition to reading the message body. This will have up to 73 more bytes. When we receive a <code class="Code-In-Text--PACKT-">*</code>, it tells us we're at the end of the body. Again, if we see a <code class="Code-In-Text--PACKT-">$</code> along the way, it means something's wrong and we should restart.</p>
    <p class="normal">The final two bytes (after the <code class="Code-In-Text--PACKT-">*</code>) represent a hexadecimal value that should equal the computed <a id="_idIndexMarker827"/>checksum of the preceding message (header and body). If the checksum is good, the message can be used by the application. There will be one or more "whitespace" characters – usually carriage return and newline characters – at the end of the message.</p>
    <p class="normal">We can imagine each of these states as an extension of the following class:</p>
    <pre class="programlisting code"><code class="hljs-code">class NMEA_State:
    def __init__(self, message: "Message") -&gt; None:
        self.message = message
    def feed_byte(self, input: int) -&gt; "NMEA_State":
        return self
    def valid(self) -&gt; bool:
        return False
    def __repr__(self) -&gt; str:
        return f"{self.__class__.__name__}({self.message})"
</code></pre>
    <p class="normal">We've defined each state to work with a <code class="Code-In-Text--PACKT-">Message</code> object. Some reader object will feed a byte to the current state, which will do something with the byte (usually save it) and return the next state. The exact behavior depends on the byte received; for example, most states will reset the message buffer to empty and transition to the <code class="Code-In-Text--PACKT-">Header</code> state when they receive a <code class="Code-In-Text--PACKT-">$</code>. Most states will return <code class="Code-In-Text--PACKT-">False</code> for the <code class="Code-In-Text--PACKT-">valid()</code> function. One state, however, will validate a complete message, and possibly return <code class="Code-In-Text--PACKT-">True</code> for the <code class="Code-In-Text--PACKT-">valid()</code> function, if the checksum is correct.</p>
    <div><p class="Tip--PACKT-">For the purists, the class name doesn't strictly follow PEP-8. It's challenging to include abbreviations or acronyms and keep a properly camel-cased name. It seems like <code class="Code-In-Text--PACKT-">NmeaState</code> isn't as clear. While a compromise class name might be <code class="Code-In-Text--PACKT-">NMEAState</code>, the clash between abbreviations and class name seems confusing. We prefer to cite "<em class="italic">A foolish consistency is the hobgoblin of little minds…</em>" in this specific case. Keeping the class hierarchy internally consistent is more important than the full PEP-8 level of consistency.</p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Message</code> object is a wrapper around two <code class="Code-In-Text--PACKT-">bytearray</code> structures where we accumulate the <a id="_idIndexMarker828"/>content of the message:</p>
    <pre class="programlisting code"><code class="hljs-code">class Message:
    def __init__(self) -&gt; None:
        self.body = bytearray(80)
        self.checksum_source = bytearray(2)
        self.body_len = 0
        self.checksum_len = 0
        self.checksum_computed = 0
    def reset(self) -&gt; None:
        self.body_len = 0
        self.checksum_len = 0
        self.checksum_computed = 0
    def body_append(self, input: int) -&gt; int:
        self.body[self.body_len] = input
        self.body_len += 1
        self.checksum_computed ^= input
        return self.body_len
    def checksum_append(self, input: int) -&gt; int:
        self.checksum_source[self.checksum_len] = input
        self.checksum_len += 1
        return self.checksum_len
    @property
    def valid(self) -&gt; bool:
        return (
            self.checksum_len == 2
            and int(self.checksum_source, 16) == self.checksum_computed
        )
</code></pre>
    <p class="normal">This definition of the <code class="Code-In-Text--PACKT-">Message</code> class encapsulates much of what's important about each sentence that comes from the GPS device. We defined a method, <code class="Code-In-Text--PACKT-">body_append()</code>, for accumulating bytes in the body, and accumulating a checksum of those bytes. In this case, the <code class="Code-In-Text--PACKT-">^</code> operator is used to compute the checksum. This is a real Python operator; it's the bit-wise exclusive OR. An exclusive OR means "one or the other but not both." You can see it in action with an expression like <code class="Code-In-Text--PACKT-">bin(ord(b'a') ^ ord(b'z'))</code>. The bits in <code class="Code-In-Text--PACKT-">b'a'</code> are <code class="Code-In-Text--PACKT-">0b1100001</code>. The bits in <code class="Code-In-Text--PACKT-">b'z'</code> are <code class="Code-In-Text--PACKT-">0b1111010</code>. Applying "one or the other but not both" to the bits, the exclusive OR is <code class="Code-In-Text--PACKT-">0b0011011</code>.</p>
    <p class="normal">Here's the<a id="_idIndexMarker829"/> reader that builds valid <code class="Code-In-Text--PACKT-">Message</code> objects by undergoing a number of state changes as bytes are received:</p>
    <pre class="programlisting code"><code class="hljs-code">class Reader:
    def __init__(self) -&gt; None:
        self.buffer = Message()
        self.state: NMEA_State = Waiting(self.buffer)
    def read(self, source: Iterable[bytes]) -&gt; Iterator[Message]:
        for byte in source:
            self.state = self.state.feed_byte(cast(int, byte))
            if self.buffer.valid:
                yield self.buffer
                self.buffer = Message()
                self.state = Waiting(self.buffer)
</code></pre>
    <p class="normal">The initial state is an instance of the <code class="Code-In-Text--PACKT-">Waiting</code> class, a subclass of <code class="Code-In-Text--PACKT-">NMEA_State</code>. The <code class="Code-In-Text--PACKT-">read()</code> method consumes one byte from the input, and then hands it to the current <code class="Code-In-Text--PACKT-">NMEA_State</code> object for processing. The state object may save the byte or may discard it, the state object may transition to another state, or it may return the current state. If the state's <code class="Code-In-Text--PACKT-">valid()</code> method is <code class="Code-In-Text--PACKT-">True</code>, the message is complete, and we can yield it for further processing by our application.</p>
    <p class="normal">Note that we're reusing a <code class="Code-In-Text--PACKT-">Message</code> object's byte arrays until it's complete and valid. This avoids allocating and freeing a lot of objects while ignoring incomplete messages on a noisy line. This is not typical for Python programs on large computers. In some applications, we don't need to save the original message, but only need to save the values of a few fields, further reducing the amount of memory used.</p>
    <p class="normal">To reuse the buffers in the <code class="Code-In-Text--PACKT-">Message</code> object, we need to make sure it's not part of any specific <code class="Code-In-Text--PACKT-">State</code> object. We've made the current <code class="Code-In-Text--PACKT-">Message</code> object part of the overall <code class="Code-In-Text--PACKT-">Reader</code>, and provided the working <code class="Code-In-Text--PACKT-">Message</code> object to each <code class="Code-In-Text--PACKT-">State</code> as an argument value.</p>
    <p class="normal">Now that we've seen the context, here are the classes to implement the various states for an incomplete message. We'll start with the state of waiting for the initial <code class="Code-In-Text--PACKT-">$</code> to begin a message. When a <code class="Code-In-Text--PACKT-">$</code> is seen, the parser transitions to a new state, <code class="Code-In-Text--PACKT-">Header</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">class Waiting(NMEA_State):
    def feed_byte(self, input: int) -&gt; NMEA_State:
        if input == ord(b"$"):
            return Header(self.message)
        return self
</code></pre>
    <p class="normal">When we're in the <code class="Code-In-Text--PACKT-">Header</code> state, we've seen the <code class="Code-In-Text--PACKT-">$</code>, and we're waiting for the five characters that <a id="_idIndexMarker830"/>identify the talker ("GP") and the sentence type (for example, "GLL"). We'll accumulate bytes until we get five of them, and then transition to the <code class="Code-In-Text--PACKT-">Body</code> state:</p>
    <pre class="programlisting code"><code class="hljs-code">class Header(NMEA_State):
    def __init__(self, message: "Message") -&gt; None:
        self.message = message
        self.message.reset()
    def feed_byte(self, input: int) -&gt; NMEA_State:
        if input == ord(b"$"):
            return Header(self.message)
        size = self.message.body_append(input)
        if size == 5:
            return Body(self.message)
        return self
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Body</code> state is where we accumulate the bulk of the message. For some applications, we may want to apply additional processing on the header and transition back to waiting for headers when we receive a message type we don't want. This can shave off a little bit of processing time when dealing with devices that produce a lot of data.</p>
    <p class="normal">When the <code class="Code-In-Text--PACKT-">*</code> arrives, the body is complete, and the next two bytes must be part of the checksum. This means transitioning to a <code class="Code-In-Text--PACKT-">Checksum</code> state:</p>
    <pre class="programlisting code"><code class="hljs-code">class Body(NMEA_State):
    def feed_byte(self, input: int) -&gt; NMEA_State:
        if input == ord(b"$"):
            return Header(self.message)
        if input == ord(b"*"):
            return Checksum(self.message)
        self.message.body_append(input)
        return self
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Checksum</code> state is similar to accumulating bytes in the <code class="Code-In-Text--PACKT-">Header</code> state: we're waiting for a specific number of input bytes. After the checksum, most messages are followed by ASCII <code class="Code-In-Text--PACKT-">\r</code> and <code class="Code-In-Text--PACKT-">\n</code> characters. If we receive either of these, we transition to an <code class="Code-In-Text--PACKT-">End</code> state where we can gracefully ignore these excess characters: </p>
    <pre class="programlisting code"><code class="hljs-code">class Checksum(NMEA_State):
    def feed_byte(self, input: int) -&gt; NMEA_State:
        if input == ord(b"$"):
            return Header(self.message)
        if input in {ord(b"\n"), ord(b"\r")}:
            # Incomplete checksum... Will be invalid.
            return End(self.message)
        size = self.message.checksum_append(input)
        if size == 2:
            return End(self.message)
        return self
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">End</code> state has <a id="_idIndexMarker831"/>an additional feature: it overrides the default <code class="Code-In-Text--PACKT-">valid()</code> method. For all other states, the <code class="Code-In-Text--PACKT-">valid()</code> method is <code class="Code-In-Text--PACKT-">False</code>. Once we've received a complete message, this state's class definition changes the validity rule: we now depend on the <code class="Code-In-Text--PACKT-">Message</code> class to compare the computed checksum with the final checksum bytes to tell us if the message is valid:</p>
    <pre class="programlisting code"><code class="hljs-code">class End(NMEA_State):
    def feed_byte(self, input: int) -&gt; NMEA_State:
        if input == ord(b"$"):
            return Header(self.message)
        elif input not in {ord(b"\n"), ord(b"\r")}:
            return Waiting(self.message)
        return self
    def valid(self) -&gt; bool:
        return self.message.valid
</code></pre>
    <p class="normal">This state-oriented change in behavior is one of the best reasons for using this design pattern. Instead of a complex set of <code class="Code-In-Text--PACKT-">if</code> conditions to decide if we have a complete message and it has all the right parts and punctuation marks, we've refactored the complexity into a number of individual states and the rules for transition from state to state. This leads us to only checking validity when we've received <code class="Code-In-Text--PACKT-">$</code>, five characters, a body, <code class="Code-In-Text--PACKT-">*</code>, two more characters, and confirmed the checksum is correct.</p>
    <p class="normal">Here's a test case to show how this works:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; message = b'''
... $GPGGA,161229.487,3723.2475,N,12158.3416,W,1,07,1.0,9.0,M,,,,0000*18
... $GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A*41
... '''
&gt;&gt;&gt; rdr = Reader()
&gt;&gt;&gt; result = list(rdr.read(message))
[Message(bytearray(b'GPGGA,161229.487,3723.2475,N,12158.3416,W,1,07,1.0,9.0,M,,,,0000'), bytearray(b'18'), computed=18), Message(bytearray(b'GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A'), bytearray(b'41'), computed=41)]
</code></pre>
    <p class="normal">We've copied<a id="_idIndexMarker832"/> two example messages from the SiRF NMEA Reference Manual, revision 1.3, to be sure our parsing was correct. See <a href="https://www.sparkfun.com/products/13750">https://www.sparkfun.com/products/13750</a> for more information on GPS IoT devices. See <a href="http://aprs.gids.nl/nmea/">http://aprs.gids.nl/nmea/</a> for additional examples and details.</p>
    <p class="normal">It's often helpful to use state transitions when parsing complex messages because we can refactor the validation into individual state definitions and state transition rules.</p>
    <h2 id="_idParaDest-250" class="title">State versus Strategy</h2>
    <p class="normal">The State <a id="_idIndexMarker833"/>pattern looks very similar to the Strategy pattern; indeed, the UML diagrams for the two are identical. The implementation, too, is identical. We could even have written our states as first-class functions instead of wrapping them in objects, as was suggested in the section on the Strategy pattern earlier in this chapter.</p>
    <p class="normal">These two patterns are similar because they both delegate work to other objects. This decomposes a complex problem into several closely related but simpler problems. </p>
    <p class="normal">The Strategy pattern is used to choose an algorithm at runtime; generally, only one of those algorithms is going to be chosen for a particular use case. The idea here is to provide an implementation choice at runtime, as late in the design process as possible. Strategy class definitions are rarely aware of other implementations; each Strategy generally stands alone.</p>
    <p class="normal">The State pattern, on the other hand, is designed to allow switching between different states dynamically, as some process evolves. In our example, the state changed as bytes were consumed and an evolving set of validity conditions satisfied. State definitions are generally defined as a group with an ability to switch among the various state objects.</p>
    <p class="normal">To an extent, the <code class="Code-In-Text--PACKT-">End</code> state used to parse an NMEA message has both State pattern features<a id="_idIndexMarker834"/> and Strategy pattern features. Because the implementation of the <code class="Code-In-Text--PACKT-">valid()</code> method is different from other states, this reflects a different strategy for determining the validity of a sentence.</p>
    <h1 id="_idParaDest-251" class="title">The Singleton pattern</h1>
    <p class="normal">The Singleton pattern <a id="_idIndexMarker835"/>is a source of some controversy; many have accused it of <a id="_idIndexMarker836"/>being an <em class="italic">anti-pattern</em>, a pattern that should be avoided, not promoted. In Python, if someone is using the Singleton pattern, they're almost certainly doing something wrong, probably because they're coming from a more restrictive programming language.</p>
    <p class="normal">So, why discuss it at all? Singleton is useful in overly object-oriented languages and is a vital part of traditional object-oriented programming. More relevantly, the idea behind singleton is useful, even if we implement the concept in a totally different way in Python.</p>
    <p class="normal">The basic idea behind the<a id="_idIndexMarker837"/> Singleton pattern is to allow exactly one instance of a certain object to exist. Typically, this object is a sort of manager class like those we discussed in <em class="chapterRef">Chapter 5</em>, <em class="italic">When to Use Object-Oriented Programming</em>. Such manager objects often need to be referenced by a wide variety of other objects; passing references to the manager object around to the methods and constructors that need them can make code hard to read.</p>
    <p class="normal">Instead, when a singleton is used, the separate objects request the single instance of the manager object from the class. The UML diagram doesn't fully describe it, but here it is for completeness:</p>
    <figure class="mediaobject"><img src="img/B17070_11_09.png" alt="Table  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 11.9: Singleton pattern in UML</p>
    <p class="normal">In most <a id="_idIndexMarker838"/>programming environments, singletons are enforced by making the constructor private (so no one can create additional instances of it), and then providing a static method to retrieve <a id="_idIndexMarker839"/>the single instance. This method creates a new instance the first time it is called, and then returns that same instance for all subsequent calls.</p>
    <h2 id="_idParaDest-252" class="title">Singleton implementation</h2>
    <p class="normal">Python doesn't have <a id="_idIndexMarker840"/>private constructors, but for this purpose, we can use the <code class="Code-In-Text--PACKT-">__new__()</code> class method to ensure that only one instance is ever created:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; class OneOnly: 
...     _singleton = None 
...     def __new__(cls, *args, **kwargs): 
...         if not cls._singleton: 
...             cls._singleton = super().__new__(cls, *args, **kwargs) 
...         return cls._singleton 
</code></pre>
    <p class="normal">When <code class="Code-In-Text--PACKT-">__new__()</code> is called, it normally constructs a new instance of the requested class. When we override it, we first check whether our singleton instance has been created; if not, we create it using a <code class="Code-In-Text--PACKT-">super</code> call. Thus, whenever we call the constructor on <code class="Code-In-Text--PACKT-">OneOnly</code>, we always get the exact same instance:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; o1 = OneOnly()
&gt;&gt;&gt; o2 = OneOnly()
&gt;&gt;&gt; o1 == o2
True
&gt;&gt;&gt; id(o1) == id(o2)
True
&gt;&gt;&gt; o1
&lt;__main__.OneOnly object at 0x7fd9c49ef2b0&gt;
&gt;&gt;&gt; o2
&lt;__main__.OneOnly object at 0x7fd9c49ef2b0&gt;
</code></pre>
    <p class="normal">The two objects are equal and located at the same address; thus, they are the same object. This particular implementation isn't very transparent, since it's not obvious that the special method is being used to create a singleton object. </p>
    <p class="normal">We don't actually need this. Python provides two built-in Singleton patterns we can leverage. Rather than invent something hard to read, there are two choices:</p>
    <ul>
      <li class="bullet">A Python module <em class="italic">is</em> a singleton. One <code class="Code-In-Text--PACKT-">import</code> will create a module. All subsequent attempts to import the module return the one-and-only singleton instance of the module. In places where an application-wide configuration file or cache is required, make this part of a distinct module. Library modules like <code class="Code-In-Text--PACKT-">logging</code>, <code class="Code-In-Text--PACKT-">random</code>, and even <code class="Code-In-Text--PACKT-">re</code> have module-level singleton caches. We'll look at using module-level variables below.</li>
      <li class="bullet">A Python class definition can also be pressed into service as a singleton. A class can only be created once in a given namespace. Consider using a class with class-level attributes as a singleton object. This means defining methods with the <code class="Code-In-Text--PACKT-">@staticmethod</code> decorator because there will never be an instance created, and there's no <code class="Code-In-Text--PACKT-">self</code> variable. </li>
    </ul>
    <p class="normal">To use module-level<a id="_idIndexMarker841"/> variables instead of a complex Singleton pattern, we instantiate the class after we've defined it. We can improve our State pattern implementation from earlier on to use singleton objects for each of the states. Instead of creating a new object every time we change states, we can create a collection of module-level variables that are always accessible. </p>
    <p class="normal">We'll make a small but very important design change, also. In the examples above, each state has a reference to the <code class="Code-In-Text--PACKT-">Message</code> object that is being accumulated. This required us to provide the <code class="Code-In-Text--PACKT-">Message</code> object as part of constructing a new <code class="Code-In-Text--PACKT-">NMEA_State</code> object; we used code like <code class="Code-In-Text--PACKT-">return Body(self.message)</code> to switch to a new state, <code class="Code-In-Text--PACKT-">Body</code>, while working on the same <code class="Code-In-Text--PACKT-">Message</code> instance. </p>
    <p class="normal">If we don't want to create (and recreate) state objects, we need to provide the <code class="Code-In-Text--PACKT-">Message</code> as an argument to the relevant methods. </p>
    <p class="normal">Here's the revised <code class="Code-In-Text--PACKT-">NMEA_State</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">class NMEA_State:
    def enter(self, message: "Message") -&gt; "NMEA_State":
        return self
    def feed_byte(
            self, 
            message: "Message", 
            input: int
    ) -&gt; "NMEA_State":
        return self
    def valid(self, message: "Message") -&gt; bool:
        return False
    def __repr__(self) -&gt; str:
        return f"{self.__class__.__name__}()"
</code></pre>
    <p class="normal">This variant on the <code class="Code-In-Text--PACKT-">NMEA_State</code> class doesn't have any instance variables. All the methods work<a id="_idIndexMarker842"/> with argument values passed in by a client. Here are the individual state definitions:</p>
    <pre class="programlisting code"><code class="hljs-code">class Waiting(NMEA_State):
    def feed_byte(
            self, 
            message: "Message", 
            input: int
    ) -&gt; "NMEA_State":
        return self
        if input == ord(b"$"):
            return HEADER
        return self
class Header(NMEA_State):
    def enter(self, message: "Message") -&gt; "NMEA_State":
        message.reset()
        return self
    def feed_byte(
            self, 
            message: "Message", 
            input: int
    ) -&gt; "NMEA_State":
        return self
        if input == ord(b"$"):
            return HEADER
        size = message.body_append(input)
        if size == 5:
            return BODY
        return self
class Body(NMEA_State):
    def feed_byte(
            self, 
            message: "Message", 
            input: int
    ) -&gt; "NMEA_State":
        return self
        if input == ord(b"$"):
            return HEADER
        if input == ord(b"*"):
            return CHECKSUM
        size = message.body_append(input)
        return self
class Checksum(NMEA_State):
    def feed_byte(
            self, 
            message: "Message", 
            input: int
    ) -&gt; "NMEA_State":
        return self
        if input == ord(b"$"):
            return HEADER
        if input in {ord(b"\n"), ord(b"\r")}:
            # Incomplete checksum... Will be invalid.
            return END
        size = message.checksum_append(input)
        if size == 2:
            return END
        return self
class End(NMEA_State):
    def feed_byte(
            self, 
            message: "Message", 
            input: int
    ) -&gt; "NMEA_State":
        return self
        if input == ord(b"$"):
            return HEADER
        elif input not in {ord(b"\n"), ord(b"\r")}:
            return WAITING
        return self
    def valid(self, message: "Message") -&gt; bool:
        return message.valid
</code></pre>
    <p class="normal">Here are the <a id="_idIndexMarker843"/>module-level variables created from instances of each of these <code class="Code-In-Text--PACKT-">NMEA_State</code> classes.</p>
    <pre class="programlisting code"><code class="hljs-code">WAITING = Waiting()
HEADER = Header()
BODY = Body()
CHECKSUM = Checksum()
END = End()
</code></pre>
    <p class="normal">Within each of these <a id="_idIndexMarker844"/>classes, we can refer to these five global variables to change parsing state. The ability to refer to a global that's defined <em class="italic">after</em> the class can seem a little mysterious at first. It works out beautifully because Python variable names are not resolved to objects until runtime. When each class is being built, a name like <code class="Code-In-Text--PACKT-">CHECKSUM</code> is little more than a string of letters. When evaluating the <code class="Code-In-Text--PACKT-">Body.feed_byte()</code> method and it's time to return the value of <code class="Code-In-Text--PACKT-">CHECKSUM</code>, then the name is resolved to the singleton instance of the <code class="Code-In-Text--PACKT-">Checksum()</code> class:</p>
    <p class="normal">Note how the <code class="Code-In-Text--PACKT-">Header</code> class was refactored. In the version where each state has an <code class="Code-In-Text--PACKT-">__init__()</code>, we could explicitly evaluate <code class="Code-In-Text--PACKT-">Message.reset()</code> when entering the <code class="Code-In-Text--PACKT-">Header</code> state. Since we're not creating new state objects in this design, we need a way to handle the special case of entering a new state, and performing an <code class="Code-In-Text--PACKT-">enter()</code> method one time only to do initialization or setup. This requirement leads to a small change in the <code class="Code-In-Text--PACKT-">Reader</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">class Reader:
    def __init__(self) -&gt; None:
        self.buffer = Message()
        self.state: NMEA_State = WAITING
    def read(self, source: Iterable[bytes]) -&gt; Iterator[Message]:
        for byte in source:
            new_state = self.state.feed_byte(
            self.buffer, cast(int, byte)
            )
            if self.buffer.valid:
                yield self.buffer
                self.buffer = Message()
                new_state = WAITING
            if new_state != self.state:
                new_state.enter(self.buffer)
                self.state = new_state
</code></pre>
    <p class="normal">We don't trivially<a id="_idIndexMarker845"/> replace the value of the <code class="Code-In-Text--PACKT-">self.state</code> instance variable with the result of the <code class="Code-In-Text--PACKT-">self.state.feed_byte()</code> evaluation. Instead, we compare the previous value of <code class="Code-In-Text--PACKT-">self.state</code> with the next value, <code class="Code-In-Text--PACKT-">new_state</code>, to see if there was a state change. If there was a change, then we need to evaluate <code class="Code-In-Text--PACKT-">enter()</code> on the new state, to allow the state change to do any required one-time initialization.</p>
    <p class="normal">In this example we aren't wasting memory creating a bunch of new instances of each state object that must later be garbage collected. Instead, we are reusing a single state object for each piece of the incoming data stream. Even if multiple parsers are running at once, only these state objects need to be used. The stateful message data is kept separate from the state processing rules in each state object.</p>
    <div><p class="Tip--PACKT-">We've combined two patterns, each with different purposes. The State pattern covers how processing is completed. The Singleton pattern covers how object instances are managed. Many software designs involve numbers of overlapping and complementary patterns.</p>
    </div>
    <h1 id="_idParaDest-253" class="title">Case study</h1>
    <p class="normal">We'll review a piece of <a id="_idIndexMarker846"/>the case study we set aside in <em class="chapterRef">Chapter 3</em>, <em class="italic">When Objects Are Alike</em>. We talked about the various ways to compute distances, but left part of the design to be filled in later. Now that we've seen some of the basic design patterns, we can apply some of them to our evolving case study.</p>
    <p class="normal">Specifically, we need to put the various kinds of distance computations into the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class definition. In <em class="chapterRef">Chapter 3</em>, we introduced the idea that the distance computation is not a single definition. There are over 50 commonly used distance computation alternatives, some simple, some rather complex. In <em class="chapterRef">Chapter 3</em>, we showed a few common ones, including Euclidean distance, Manhattan distance, Chebyshev distance, and even a complex-looking Sorensen distance. Each weights the "nearness" of the neighbors slightly differently.</p>
    <p class="normal">This leads us to look at the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class as containing three important components:</p>
    <ul>
      <li class="bullet">A reference to the base <code class="Code-In-Text--PACKT-">TrainingData</code>. This is used to find all of the neighbors, from which the nearest are selected.</li>
      <li class="bullet">The <em class="italic">k</em> value used to determine how many neighbors will be checked.</li>
      <li class="bullet">The distance algorithm. We'd like to be able to plug in any algorithm here. Our research revealed a large number of competing choices. This suggests that implementing one or two won't be very adaptable to real-world demands.</li>
    </ul>
    <p class="normal">Plugging in the distance algorithm is a good application of the <strong class="keyword">Strategy</strong> design pattern. For a given <code class="Code-In-Text--PACKT-">Hyperparameter</code> object, <code class="Code-In-Text--PACKT-">h</code>, the <code class="Code-In-Text--PACKT-">h.distance</code> object has a <code class="Code-In-Text--PACKT-">distance()</code> method that does the work of computing a distance. We can plug in any of the subclasses of <code class="Code-In-Text--PACKT-">Distance</code> to do this work.</p>
    <p class="normal">This means the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class' <code class="Code-In-Text--PACKT-">classify()</code> method will use the strategy's <code class="Code-In-Text--PACKT-">self.distance.distance()</code> to compute the distances. We can use this to provide alternative <code class="Code-In-Text--PACKT-">distance</code> objects as well as alternative <em class="italic">k</em> values to find a combination that provides the best-quality classification of unknown samples.</p>
    <p class="normal">We can summarize the relationships using a UML diagram like the following:</p>
    <figure class="mediaobject"><img src="img/B17070_11_10.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 11.10: UML diagram with Hyperparameter and Distance classes</p>
    <p class="normal">This diagram focuses<a id="_idIndexMarker847"/> on a few of the classes:</p>
    <ul>
      <li class="bullet">An instance of the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class will have a reference to a <code class="Code-In-Text--PACKT-">Distance</code> class. This use of the Strategy design pattern lets us create any number of subclasses of <code class="Code-In-Text--PACKT-">Distance</code> with any of the algorithms found in the literature.</li>
      <li class="bullet">An instance of the <code class="Code-In-Text--PACKT-">Distance</code> class will compute a distance between two samples. Researchers have designed 54 implementations. We'll stick with a few simple ones shown in <em class="chapterRef">Chapter 3</em>:<ul>
          <li class="bullet-l2">Chebyshev uses <code class="Code-In-Text--PACKT-">max()</code> to reduce four distances along each dimension to the single largest value.</li>
          <li class="bullet-l2">Euclidean uses the <code class="Code-In-Text--PACKT-">math.hypot()</code> function.</li>
          <li class="bullet-l2">Manhattan is the sum of each distance along the four dimensions.</li>
        </ul>
      </li>
      <li class="bullet">An instance of the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class will also have a reference to a <em class="italic">k</em>-nearest neighbors <code class="Code-In-Text--PACKT-">Classifier</code> function. This use of the Strategy design pattern lets us use any <a id="_idIndexMarker848"/>number of optimized classifier algorithms.</li>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">TrainingData</code> object contains the original <code class="Code-In-Text--PACKT-">Sample</code> objects, shared by the <code class="Code-In-Text--PACKT-">Hyperparameter</code> objects.</li>
    </ul>
    <p class="normal">Here's an example of the <code class="Code-In-Text--PACKT-">Distance</code> class definitions, defining the overall protocol for distance computations and the <code class="Code-In-Text--PACKT-">Euclidean</code> implementation:</p>
    <pre class="programlisting code"><code class="hljs-code">from typing import Protocol
from math import hypot
class Distance(Protocol):
    def distance(
            self, 
            s1: TrainingKnownSample, 
            s2: AnySample
    ) -&gt; float:
        ...
class Euclidean(Distance):
    def distance(self, s1: TrainingKnownSample, s2: AnySample) -&gt; float:
      return hypot(
        (s1.sample.sample.sepal_length - s2.sample.sepal_length)**2,
        (s1.sample.sample.sepal_width - s2.sample.sepal_width)**2,
        (s1.sample.sample.petal_length - s2.sample.petal_length)**2,
        (s1.sample.sample.petal_width - s2.sample.petal_width)**2,
      )
</code></pre>
    <p class="normal">We've defined a <code class="Code-In-Text--PACKT-">Distance</code> protocol so tools like <strong class="" style="font-style: italic;">mypy</strong> can recognize a class that performs a distance computation. The body of the <code class="Code-In-Text--PACKT-">distance()</code> function is the Python token <code class="Code-In-Text--PACKT-">...</code>. It really is three dots; this is not a placeholder here in the book, it's the token used for abstract method bodies, as we learned in <em class="chapterRef">Chapter 6</em>.</p>
    <p class="normal">The Manhattan and Chebyshev distances are similar to each other. The Manhattan distance is the sum of changes among the features, and the Chebyshev is the largest change among the<a id="_idIndexMarker849"/> features:</p>
    <pre class="programlisting code"><code class="hljs-code">class Manhattan(Distance):
    def distance(self, s1: TrainingKnownSample, s2: AnySample) -&gt; float:
        return sum(
            [
                abs(s1.sample.sample.sepal_length - s2.sample.sepal_length),
                abs(s1.sample.sample.sepal_width - s2.sample.sepal_width),
                abs(s1.sample.sample.petal_length - s2.sample.petal_length),
                abs(s1.sample.sample.petal_width - s2.sample.petal_width),
            ]
        )
class Chebyshev(Distance):
    def distance(self, s1: TrainingKnownSample, s2: AnySample) -&gt; float:
        return max(
            [
                abs(s1.sample.sample.sepal_length - s2.sample.sepal_length),
                abs(s1.sample.sample.sepal_width - s2.sample.sepal_width),
                abs(s1.sample.sample.petal_length - s2.sample.petal_length),
                abs(s1.sample.sample.petal_width - s2.sample.petal_width),
            ]
        )
</code></pre>
    <p class="normal">Similarly, the <em class="italic">k</em>-nearest neighbors classification can also be defined as a hierarchy with alternative implementation strategies. As we saw in <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>, there are a number of ways of performing this algorithm, also. We can use a simple approach with a sorted list, or a more sophisticated approach where we use a heap queue, or the <code class="Code-In-Text--PACKT-">bisect</code> module as a way to cut down on the overheads of a large collection of neighbors. We won't repeat all of the <em class="chapterRef">Chapter 10</em> definitions, here. These are all defined as functions, and this is the simplest version that accumulates and sorts all of the distance computations, looking for the nearest <em class="italic">k</em> samples:</p>
    <pre class="programlisting code"><code class="hljs-code">From collections import Counter
def k_nn_1(
        k: int, 
        dist: DistanceFunc, 
        training_data: TrainingList, 
        unknown: AnySample
) -&gt; str:
    distances = sorted(
        map(lambda t: Measured(dist(t, unknown), t), training_data))
    k_nearest = distances[:k]
    k_frequencies: Counter[str] = Counter(
        s.sample.sample.species for s in k_nearest
    )
    mode, fq = k_frequencies.most_common(1)[0]
    return mode
</code></pre>
    <p class="normal">Given these two<a id="_idIndexMarker850"/> families of the distance functions, and the overall classifier algorithms, we can define the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class in a way that relies on two plug-in Strategy objects. The class definition becomes rather small because the details have been factored into separate class hierarchies that we can extend as needed:</p>
    <pre class="programlisting code"><code class="hljs-code">class Hyperparameter(NamedTuple):
    k: int
    distance: Distance
    training_data: TrainingList
    classifier: Classifier
    def classify(self, unknown: AnySample) -&gt; str:
        classifier = self.classifier
        distance = self.distance
        return classifier(
            self.k, distance.distance, self.training_data, unknown)
</code></pre>
    <p class="normal">Here's how we can create and use a <code class="Code-In-Text--PACKT-">Hyperparameter</code> instance. This shows how the strategy objects are provided to a <code class="Code-In-Text--PACKT-">Hyperparameter</code> object:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; data = [
...     KnownSample(sample=Sample(1, 2, 3, 4), species="a"),
...     KnownSample(sample=Sample(2, 3, 4, 5), species="b"),
...     KnownSample(sample=Sample(3, 4, 5, 6), species="c"),
...     KnownSample(sample=Sample(4, 5, 6, 7), species="d"),
... ]
&gt;&gt;&gt; manhattan = Manhattan().distance
&gt;&gt;&gt; training_data = [TrainingKnownSample(s) for s in data]
&gt;&gt;&gt; h = Hyperparameter(1, manhattan, training_data, k_nn_1)
&gt;&gt;&gt; h.classify(UnknownSample(Sample(2, 3, 4, 5)))
'b'
</code></pre>
    <p class="normal">We created an instance of the <code class="Code-In-Text--PACKT-">Manhattan</code> class, and provided this object's <code class="Code-In-Text--PACKT-">distance()</code> method (the method <a id="_idIndexMarker851"/>object, not a computed distance value) to the <code class="Code-In-Text--PACKT-">Hyperparameter</code> instance. We provided the <code class="Code-In-Text--PACKT-">k_nn_1()</code> function for the nearest neighbor classification. The training data is a sequence of four <code class="Code-In-Text--PACKT-">KnownSample</code> objects.</p>
    <p class="normal">We have a subtle distinction between the distance function, which has a direct impact on how well classification works, and the classifier algorithm, which is a minor performance optimization. We can argue that these are not really peers, and perhaps we have piled too many features into one class. We don't really need to test the quality of the classifier algorithm; instead, we only need to test the performance.</p>
    <p class="normal">This tiny example does, correctly, locate the nearest neighbor to the given unknown sample. As a practical matter, we need a more sophisticated testing capability to examine all samples of a test dataset. </p>
    <p class="normal">We can add the following method to the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class defined above:</p>
    <pre class="programlisting code"><code class="hljs-code">def test(self, testing: TestingList) -&gt; float:
    classifier = self.classifier
    distance = self.distance
    test_results = (
        ClassifiedKnownSample(
            t.sample,
            classifier(
                self.k, distance.distance, 
                self.training_data, t.sample),
        )
        for t in testing
    )
    pass_fail = map(
        lambda t: (1 if t.sample.species == t.classification else 0), 
        test_results
    )
    return sum(pass_fail) / len(testing)
</code></pre>
    <p class="normal">This <code class="Code-In-Text--PACKT-">test()</code> method for a given <code class="Code-In-Text--PACKT-">Hyperparameter</code> can apply the <code class="Code-In-Text--PACKT-">classify()</code> method to all of the given samples in the test set. The ratio of correctly classified test samples to the total number of tests is one way to measure the overall quality of this specific combination of parameters.</p>
    <p class="normal">There are a number of combinations of hyperparameters, and the Command design pattern can be used to create a number of test commands. Each of these command instances would<a id="_idIndexMarker852"/> contain the values required to create and test a unique <code class="Code-In-Text--PACKT-">Hyperparameter</code> object. We can create a large collection of these Commands to perform a comprehensive hyperparameter tuning.</p>
    <p class="normal">The essential command creates a <code class="Code-In-Text--PACKT-">Timing</code> object when it is executed. The <code class="Code-In-Text--PACKT-">Timing</code> object is a summary of the results of a test, and looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">class Timing(NamedTuple):
    k: int
    distance_name: str
    classifier_name: str
    quality: float
    time: float  # Milliseconds
</code></pre>
    <p class="normal">The test command is given a <code class="Code-In-Text--PACKT-">Hyperparameter</code> and a reference to the test data. This can be used, later, to actually gather the tuning results. The use of the Command design pattern makes it possible to separate creating the commands from executing the commands. This separation can be helpful for understanding what's going on. It may also be necessary when there is one-time setup processing that we don›t want to measure when comparing the performance of various algorithms. </p>
    <p class="normal">Here's our <code class="Code-In-Text--PACKT-">TestCommand</code> class definition:</p>
    <pre class="programlisting code"><code class="hljs-code">import time
class TestCommand:
    def __init__(
        self,
        hyper_param: Hyperparameter,
        testing: TestingList,
    ) -&gt; None:
        self.hyperparameter = hyper_param
        self.testing_samples = testing
    def test(self) -&gt; Timing:
        start = time.perf_counter()
        recall_score = self.hyperparameter.test(self.testing_samples)
        end = time.perf_counter()
        timing = Timing(
            k=self.hyperparameter.k,
            distance_name=
                self.hyperparameter.distance.__class__.__name__,
            classifier_name=
                self.hyperparameter.classifier.__name__,
            quality=recall_score,
            time=round((end - start) * 1000.0, 3),
        )
        return timing
</code></pre>
    <p class="normal">The constructor <a id="_idIndexMarker853"/>saves the <code class="Code-In-Text--PACKT-">Hyperparameter</code> and testing samples list. When the <code class="Code-In-Text--PACKT-">test()</code> method is evaluated, the test is run, and a <code class="Code-In-Text--PACKT-">Timing</code> object is created. For this very small dataset, the tests run very quickly. For larger and more complex datasets, the hyperparameter tuning can run for hours.</p>
    <p class="normal">Here's a function to build and then execute a suite of <code class="Code-In-Text--PACKT-">TestCommand</code> instances.</p>
    <pre class="programlisting code"><code class="hljs-code">def tuning(source: Path) -&gt; None:
    train, test = load(source)
    scenarios = [
        TestCommand(Hyperparameter(k, df, train, cl), test)
        for k in range(3, 33, 2)
        for df in (euclidean, manhattan, chebyshev)
        for cl in (k_nn_1, k_nn_b, k_nn_q)
    ]
    timings = [s.test() for s in scenarios]
    for t in timings:
        if t.quality &gt;= 1.0:
            print(t)
</code></pre>
    <p class="normal">This function loads the raw data and will partition the data as well. This code is essentially the subject of <em class="chapterRef">Chapter 9</em>, <em class="italic">Strings, Serialization, and File Paths</em>. It creates a number of <code class="Code-In-Text--PACKT-">TestCommand</code> objects for many combinations of <em class="italic">k</em>, distance, and classifier functions, saving these in the <code class="Code-In-Text--PACKT-">scenarios</code> list.</p>
    <p class="normal">After all the command instances have been created, it executes all of the objects, saving the results in the <code class="Code-In-Text--PACKT-">timings</code> list. The results are displayed, to help us locate the optimal hyperparameter set.</p>
    <p class="normal">We've used the Strategy and the Command design patterns as part of building the tuning function. The three distance computation classes are good candidates for a Singleton-like<a id="_idIndexMarker854"/> class design: we only need one instance of each of these objects. Having a language for describing a design, via design patterns, can make it easier to describe a design to other developers.</p>
    <h1 id="_idParaDest-254" class="title">Recall</h1>
    <p class="normal">The world of software design is full of good ideas. The really good ideas get repeated and form repeatable patterns. Knowing – and using – these patterns of software design can save the developer from burning a lot of brain calories trying to reinvent something that's been developed already. In this chapter, we looked at a few of the most common patterns:</p>
    <ul>
      <li class="bullet">The Decorator pattern is used in the Python language to add features to functions or classes. We can define decorator functions and apply them directly, or use the <code class="Code-In-Text--PACKT-">@</code> syntax to apply a decorator to another function.</li>
      <li class="bullet">The Observer pattern can simplify writing GUI applications. It can also be used in non-GUI applications to formalize relationships between objects that change state, and objects that display or summarize or otherwise use the state information.</li>
      <li class="bullet">The Strategy pattern is central to a lot of object-oriented programming. We can decompose large problems into containers with the data and strategy objects that help with processing the data. The Strategy object is a kind of "plug-in" to another object. This gives us ways to adapt, extend, and improve processing without breaking all the code we wrote when we make a change.</li>
      <li class="bullet">The Command pattern is a handy way to summarize a collection of changes that are applied to other objects. It's really helpful in a web services context where external commands arrive from web clients.</li>
      <li class="bullet">The State pattern is a way to define processing where there's a change in state and a change in behavior. We can often push unique or special-case processing into state-specific objects, leveraging the Strategy pattern to plug in state-specific behavior. </li>
      <li class="bullet">The Singleton pattern is used in the rare cases where we need to be sure there is one and only one of a specific kind of object. It's common, for example, to limit an application to exactly one connection to a central database.</li>
    </ul>
    <p class="normal">These design patterns help us organize complex collections of objects. Knowing a number of patterns can help the developer visualize a collection of cooperating classes, and allocate their responsibilities. It can also help developers talk about a design: when they've both read the same books on design patterns, they can refer to the patterns by name and skip over long descriptions.</p>
    <h1 id="_idParaDest-255" class="title">Exercises</h1>
    <p class="normal">While writing the examples for this chapter, the authors discovered that it can be very difficult, and extremely educational, to come up with good examples where specific design patterns <em class="italic">should</em> be used. Instead of going over current or old projects to see where you can apply these patterns, as we've suggested in previous chapters, think about the patterns and different situations where they might come up. Try to think outside your own experiences. If your current projects are in the banking business, consider how you'd apply these design patterns in a retail or point-of-sale application. If you normally write web applications, think about using design patterns while writing a compiler.</p>
    <p class="normal">Look at the Decorator pattern and come up with some good examples of when to apply it. Focus on the pattern itself, not the Python syntax we discussed. It's a bit more general than the actual pattern. The special syntax for decorators is, however, something you may want to look for places to apply in existing projects too.</p>
    <p class="normal">What are some good areas to use the Observer pattern? Why? Think about not only how you'd apply the pattern, but how you would implement the same task without using Observer. What do you gain, or lose, by choosing to use it?</p>
    <p class="normal">Consider the difference between the Stategy and State patterns. Implementation-wise, they look very similar, yet they have different purposes. Can you think of cases where the patterns could be interchanged? Would it be reasonable to redesign a State-based system to use Strategy instead, or vice versa? How different would the design actually be?</p>
    <p class="normal">In the dice-rolling example, we parsed a simple expression to create a few commands. There are more options possible. See <a href="https://help.roll20.net/hc/en-us/articles/360037773133-Dice-Reference#DiceReference-Roll20DiceSpecif">https://help.roll20.net/hc/en-us/articles/360037773133-Dice-Reference#DiceReference-Roll20DiceSpecification</a> for some really sophisticated syntax for describing dice and dice games. To implement this, there are two changes that need to be made. First, design the command hierarchy for all of these options. After that, write a regular expression to parse a more complex dice-rolling expression and execute all of the commands present.</p>
    <p class="normal">We've noted that Singleton objects can be built using Python module variables. It's sometimes helpful to compare the performance of the two different NMEA message processors. If you don't have a GPS chip with a USB interface laying around, you can search the internet for NMEA example messages to parse. <a href="http://aprs.gids.nl/nmea/">http://aprs.gids.nl/nmea/</a> is a good source of examples. There's a trade-off question between the potential confusion of module variables and the performance of the application. It's helpful to have data to support the lessons you've learned.</p>
    <h1 id="_idParaDest-256" class="title">Summary</h1>
    <p class="normal">This chapter discussed several common design patterns in detail, with examples, UML diagrams, and a discussion of the differences between Python and statically typed object-oriented languages. The Decorator pattern is often implemented using Python's more generic decorator syntax. The Observer pattern is a useful way to decouple events from actions taken on those events. The Strategy pattern allows different algorithms to be chosen to accomplish the same task. The Command pattern helps us design active classes that share a common interface but carry out distinct actions. The State pattern looks similar to the Strategy pattern but is used instead to represent systems that can move between different states using well-defined actions. The Singleton pattern, popular in some statically typed languages, is almost always an anti-pattern in Python.</p>
    <p class="normal">In the next chapter, we'll wrap up our discussion of design patterns.</p>
  </div>
</body></html>