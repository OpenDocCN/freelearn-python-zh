<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Qt Quick Library</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will continue with our implementation of the QML GUI and we will describe the more detailed Qt Quick library <span>– </span>the main tool for working with QML in Qt. By using the Qt Quick module, designers and developers can easily build fluid animated UIs in QML, and have the option of connecting these UIs to any backend C++ libraries. Qt Quick allows developers to create highly performant, fluidly animated, and visually appealing applications.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>Introduction to the Qt Quick module</li>
<li>The window submodule</li>
<li>Controls</li>
<li>Layouts</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to the Qt Quick module</h1>
                </header>
            
            <article>
                
<p>In the Qt framework, the Qt Quick module allows us to work with and implement QML with user-created applications. <span>Qt Quick is the main module in the Qt framework for working with UIs and infrastructures with QML. </span>This module expands Qt's functionality and makes some additions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic types</h1>
                </header>
            
            <article>
                
<p>In addition to the default QML <span>types</span>, the Qt Quick module provides the following types:</p>
<ul>
<li><kbd>date</kbd>: Date values</li>
<li><kbd>point</kbd>: Values with <kbd>x</kbd> and <kbd>y</kbd> attributes</li>
<li><kbd>rect</kbd>: Values with <kbd>x</kbd>, <kbd>y</kbd>, <kbd>width</kbd>, and <kbd>height</kbd> attributes</li>
<li><kbd>size</kbd>: Values with <kbd>width</kbd> and <kbd>height</kbd> attributes</li>
<li><kbd>color</kbd>: ARGB color values</li>
<li><kbd>font</kbd>: Font values with the properties of <kbd>QFont</kbd></li>
<li><kbd>matrix4x4</kbd>: A 4-row and 4-column matrix</li>
<li><kbd>quaternion</kbd>: A scalar with <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd> attributes</li>
<li><kbd>vector2d</kbd>: A 2D vector with <kbd>x</kbd> and <kbd>y</kbd> attributes</li>
<li><kbd>vector3d</kbd>: A 3D vector with <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd> attributes</li>
<li><kbd>vector4d</kbd>: A 4D vector with <kbd>x</kbd>, <kbd>y</kbd>, <kbd>z</kbd>, and <kbd>w</kbd> attributes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qt Quick types</h1>
                </header>
            
            <article>
                
<p>In <a href="e8aa0a88-3426-4280-86f9-8d39cf7f6391.xhtml">Chapter 2</a>, <em>An Overview of QML</em>, we described the most popular Qt Quick types for creating a GUI. A full list of these types is available in the official documentation: <a href="https://doc.qt.io/qt-5.9/qtquick-qmlmodule.html">https://doc.qt.io/qt-5.9/qtquick-qmlmodule.html</a>. Let's look at some of the most useful types that we haven't covered yet:</p>
<ul>
<li><kbd>Canvas</kbd>: <span>This</span> provides a 2D canvas item that enables drawing using JavaScript to create figures and other visual objects.</li>
<li><kbd>Context2D</kbd>: This provides a 2D context for shapes on a <kbd>Canvas</kbd> item</li>
<li><kbd>AnimatedImage</kbd>: This plays animations stored as series of images containing a series of frames.</li>
<li><kbd>Drag</kbd>: This specifies drag and drop events for items.</li>
<li><kbd>DropArea</kbd>: This<span> specifies d</span>rag and drop handling in an area.</li>
<li><kbd>KeyEvent</kbd>: This provides information about key events.</li>
<li><kbd>MouseEvent</kbd>: This allows you to handle mouse events.</li>
<li><kbd>WheelEvent</kbd>: Mouse wheel events.</li>
<li><kbd>Flickable</kbd>: Flicked surfaces.</li>
<li><kbd>Flipable</kbd>: Flipped surfaces.</li>
<li><kbd>FocusScope</kbd>: Explicitly creates a focus scope.</li>
<li><kbd>GridView</kbd>: Model grid view of the items.</li>
<li><kbd>Image</kbd>: Displays an image.</li>
<li><kbd>ListView</kbd>: Model list view.</li>
<li><kbd>Loader</kbd>: Dynamic loading of a subtree from a URL.</li>
<li><kbd>MultiPointTouchArea</kbd>: Used to handle multiple touch points.</li>
<li><kbd>Column</kbd>: Used to position items in columns.</li>
</ul>
<ul>
<li><kbd>Flow</kbd>: Used to position items such as words on a page.</li>
<li><kbd>Positioner</kbd>: Attached properties that show where an item exists.</li>
<li><kbd>Row</kbd>: Used to position items in row form.</li>
<li><kbd>Repeater</kbd>: Used to create a number of item-based components.</li>
<li><kbd>ShaderEffect</kbd>: Used to add shaders to a rectangle.</li>
<li><kbd>GridMesh</kbd>: A mesh with vertices arranged in a grid.</li>
<li><kbd>TextEdit</kbd>: A multiline text field.</li>
<li><kbd>Matrix4x4</kbd>: A 4 x 4 transformation matrix for an item.</li>
<li><kbd>Rotation</kbd>: Used to rotate an item.</li>
<li><kbd>Scale</kbd>: An item will scale.</li>
<li><kbd>Translate</kbd>: Used to move an item without changing its <kbd>x</kbd> or <kbd>y</kbd> properties.</li>
<li><kbd>FontLoader</kbd>: Used to load fonts by name or URL.</li>
<li><kbd>FontMetrics</kbd>: Metrics for a font.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qt Quick submodules</h1>
                </header>
            
            <article>
                
<p>The Qt Quick library includes additional modules with types. Some of them will be described in detail in this chapter. This is a list of the sub-modules:</p>
<ul>
<li><kbd>XmlListModel</kbd>: Provides types for creating models from XML data.</li>
<li><kbd>LocalStorage</kbd>: A JavaScript interface for a SQLite database.</li>
<li><kbd>Particles</kbd>: A particle system for QML applications.</li>
<li><kbd>Window</kbd>: Types for creating top-level windows and accessing screen information.</li>
<li><kbd>Dialogs</kbd>: Used to create and interact with system dialogs.</li>
<li><kbd>Controls</kbd>: Reusable UI components (such as buttons, checkboxes, labels, and more).</li>
<li><kbd>Layouts</kbd>: Used to arrange items.</li>
<li><kbd>Tests</kbd>: Used to test QML applications.</li>
</ul>
<p>In this chapter, we'll focus on the important types and submodules that are used in GUI development. For complete information, it is recommended that you visit the <span>Qt Quick </span>documentation (<a href="https://doc.qt.io/qt-5/qtquick-index.html">https://doc.qt.io/qt-5/qtquick-index.html</a>). In <a href="e8aa0a88-3426-4280-86f9-8d39cf7f6391.xhtml">Chapter 2</a>, <em>An Overview of QML</em>, some of the types and modules were implemented with examples, and were described in detail. Let's do the same here.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The window module</h1>
                </header>
            
            <article>
                
<p>This module provides types that you can use when you're creating top-level windows, screen information, and window events, such as when a window closes. To use this module, use the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick.Window 2.2</pre>
<p><span>We'll go through these types in the following sections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Screen</h1>
                </header>
            
            <article>
                
<p>This type provides information about the displayed screen, item, or window. The properties are as follows:</p>
<p><kbd>desktopAvailableHeight</kbd><strong>:</strong> This integer is the available height of the desktop resolution in pixels.</p>
<p><kbd>desktopAvailableWidth</kbd><strong>:</strong><span> This integer is the available width of the desktop resolution in pixels</span>.</p>
<p><kbd>devicePixelRatio</kbd><strong>:</strong><span> This</span> <kbd>real</kbd> <span>number is the ratio of physical pixels and device-independent pixels. The value is</span> <kbd>1.0</kbd> <span>with normal displays and</span> <kbd>2.0</kbd> <span>on Apple's retina displays.</span></p>
<p><kbd>width</kbd><strong>:</strong><span> This integer is the width of the screen in pixels.</span></p>
<p><kbd>height</kbd><strong>:</strong><span> This integer is the height of the screen in pixels.</span></p>
<p><kbd>name</kbd><strong>:</strong><span> This</span> string <span>is the name of the screen.</span></p>
<p><kbd>orientation</kbd><strong>:</strong><span> This is the orientation of the screen (using the accelerometer).</span></p>
<p><kbd>orientationUpdateMask</kbd><strong>:</strong><span> This contains the update mask for the orientation.</span></p>
<p><kbd>primaryOrientation</kbd><strong>:</strong><span> The primary orientation of the screen can be</span> <kbd>Qt.PortraitOrientation</kbd> <span>or</span> <kbd>Qt.LandscapeOrientation</kbd><span>, depending on the height and width of the screen.</span></p>
<p><kbd>pixelDensity</kbd><strong>:</strong><span> This</span> <kbd>real</kbd> <span>number is the number of physical pixels per millimeter.</span></p>
<p><kbd>virtualX</kbd><strong>:</strong><span> This integer is the</span> <em>x</em> <span>coordinate of the screen related to the virtual desktop.</span></p>
<p><kbd>virtualY</kbd><strong>:</strong><span> This integer is the</span> <em>y</em> <span>coordinate of the screen related to the virtual desktop.</span></p>
<p>The following method is available:</p>
<p><kbd>angleBetween(a, b)</kbd>: This returns the rotation angle between the <kbd>a</kbd> (the first parameter) and <kbd>b</kbd> (the second parameter) <span>angles</span> in degrees.</p>
<p>Let's make our QML app with a size that depends on the screen resolution of the device. To do this, open the <kbd>u_qml.qml</kbd> file and change the <kbd>UQml.Window</kbd> width and height properties with the following lines as screen type values:</p>
<pre>...<br/>UQml.Window {<br/>    ... <br/>    width: UQml.Screen.desktopAvailableWidth<br/>    height: UQml.Screen.desktopAvailableHeight<br/>    ...<br/>...</pre>
<p>The application's window will have the <kbd>width</kbd> and <kbd>height</kbd> properties that are available for the device that's being used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CloseEvent</h1>
                </header>
            
            <article>
                
<p>This type notifies you that a window is about to be closed by the windowing system. It has the following property:</p>
<p><kbd>accepted</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>, and allows the user to close the window (the default is <kbd>true</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Window</h1>
                </header>
            
            <article>
                
<p>This creates a new top-level window for the GUI application, which can consist of elements and items. The available properties of this type are as follows:</p>
<p><kbd>width</kbd>: This integer sets the width of the window in pixels.</p>
<p><kbd>height</kbd><span>: T</span><span>his integer </span><span>sets the height of the window in pixels.</span></p>
<p><kbd>maximumWidth</kbd><strong>:</strong><span> T</span><span>his integer </span><span>sets the maximum width of the window that will be available.</span></p>
<p><kbd>maximumHeight</kbd><strong>:</strong><span> T</span><span>his integer </span><span>sets the maximum height of the window that will be available.</span></p>
<p><kbd>minimumWidth</kbd><strong>:</strong><span> T</span><span>his integer </span><span>sets the minimum width of the window that will be available.</span></p>
<p><kbd>minimumHeight</kbd><strong>:</strong><span> T</span><span>his integer </span><span>sets the minimum height of the window that will be available.</span></p>
<p><kbd>x</kbd><strong>:</strong><span> T</span><span>his integer is the</span> <span>position of the window on the</span> <em>x</em> <span>axis.</span></p>
<p><kbd>y</kbd><strong>:</strong><span> T</span><span>his integer is the</span> <span>position of the window on the</span> <em>y</em> <span>axis.</span></p>
<p><kbd>opacity</kbd><strong>:</strong><span> This</span> <kbd>real</kbd> <span>number sets the opacity of the window. The value ranges from</span> <kbd>0.0</kbd> <span>to</span> <kbd>1.0</kbd><span>, where </span> <kbd>0.0</kbd> <span>is fully transparent and</span> <kbd>1.0</kbd> <span>is fully opaque.</span></p>
<p><kbd>title</kbd><strong>:</strong><span> This</span> <kbd>string</kbd> <span>sets the title of the window.</span></p>
<p><kbd>visible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd><span>, the window will be visible, and if it's</span> <kbd>false</kbd><span>, the window will be invisible (the default is</span> <kbd>true</kbd><span>).</span></p>
<p><kbd>visibility</kbd><strong>: </strong><span>This </span><span>sets the screen-occupation state of the window as</span> <kbd>normal</kbd><span>,</span> <kbd>minimized</kbd><span>,</span> <kbd>maximized</kbd><span>, or</span> <kbd>fullscreen</kbd><span>.</span></p>
<p><kbd>color</kbd><strong>:</strong><span> This sets the background color of the window.</span></p>
<p><kbd>modality</kbd><strong>:</strong><span> This sets the window as modal (the default is</span> <kbd>QtCore.Qt.NonModal</kbd><span>).</span></p>
<p><kbd>screen</kbd><strong>:</strong><span> </span>This sets the associated window for this window.</p>
<p><kbd>active</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and sets the status of the window.</span></p>
<p><kbd>activeFocusItem</kbd><strong>:</strong><span> This is the</span> item <span>that currently has active focus; it's null if there is no item with active focus.</span></p>
<p><kbd>contentItem</kbd><strong>:</strong><span> This is the invisible root</span> <kbd>Item</kbd> <span>of the</span> scene<span>.</span></p>
<p><kbd>contentOrientation</kbd><strong>:</strong><span> </span>The hint to the window manager for additional content.</p>
<p><kbd>data</kbd><strong>:</strong><span> This is a list, and allows us to mix visual objects, resources, and other windows.</span></p>
<p><kbd>flags</kbd><strong>:</strong> <span>These are the available flags for this window.</span></p>
<p>The window type provides the following properties:</p>
<p><kbd>Window.window</kbd><strong>:</strong> The <kbd>Window</kbd> type <span>– </span>the item's window that's used.</p>
<p><kbd>Window.width</kbd><span>: This integer is the width of the item's window.</span></p>
<p><kbd>Window.height</kbd><strong>:</strong><span> This integer is the height of the item's window.</span></p>
<p><kbd>Window.visibility</kbd><strong>:</strong><span> </span>This window will be shown in the windowing system, such as <kbd>normal</kbd>, <kbd>fullscreen</kbd>, and more.</p>
<p><kbd>Window.active</kbd>:<span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and shows whether the window is active.</span></p>
<p><kbd>Window.activeFocusItem</kbd>:<span> This shows which item currently has active focus.</span></p>
<p><kbd>Window.contentItem</kbd>:<span> This is the invisible root item of the </span>scene.</p>
<p>This type has one signal:</p>
<p><kbd>closing(CloseEvent close)</kbd>: This is emitted when the window tries to close.</p>
<p>The type also has the following methods:</p>
<p><kbd>alert(int)</kbd>: Causes an alert.</p>
<p><kbd>close()</kbd><span>: Closes the window.</span></p>
<p><kbd>hide()</kbd><span>: Hides the window.</span></p>
<p><kbd>lower()</kbd><span>: Lowers the window.</span></p>
<p><kbd>raise()</kbd><span>: Raises the window.</span></p>
<p><kbd>requestActivate()</kbd><span>: Requests the window to be activated.</span></p>
<p><kbd>show()</kbd><span>: Shows the window.</span></p>
<p><kbd>showFullScreen()</kbd><span>: Shows the window in fullscreen mode.</span></p>
<p><kbd>showMaximized()</kbd><span>: Shows the window in maximized mode.</span></p>
<p><kbd>showMinimized()</kbd><span>: Shows the window in minimized mode.</span></p>
<p><kbd>showNormal()</kbd><span>: Shows the window in normal mode.</span></p>
<p>We can try to change/add properties in the <kbd>u_qml.qml</kbd> file in the <kbd>UQml.Window</kbd> section and look at the results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controls</h1>
                </header>
            
            <article>
                
<p>The <kbd>QtQuick.Controls</kbd> module allows us to use a wide set of reusable UI elements to construct the functionality of the application. The <kbd>import</kbd> statement that you need to be able to use types from this module is as follows:</p>
<pre>import QtQuick.Controls 1.4</pre>
<p>In the next section, we'll go through the types this module provides.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ApplicationWindow</h1>
                </header>
            
            <article>
                
<p>This type implements a simple top-level application window with the following properties:</p>
<p><kbd>contentItem</kbd>: This is the area between <kbd>ToolBar</kbd> and <kbd>StatusBar</kbd>.</p>
<p><kbd>menuBar</kbd><strong>:</strong><span> This sets the menu bar of the application window.</span></p>
<p><kbd>toolBar</kbd><strong>:</strong><span> This sets the toolbar of the app.</span></p>
<p><kbd>statusBar</kbd><strong>:</strong><span> This item sets the status bar.</span></p>
<p><kbd>style</kbd><strong>:</strong><span> This component is used to style the app.</span></p>
<p>Let's take a look at the following example:</p>
<ol>
<li>Create a file called <kbd>UAppwin.qml</kbd> in the <kbd>qmls/</kbd> directory and add the following lines:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Controls 1.4<br/>import QtQuick.Controls.Styles 1.4<br/>import QtQuick.Window 2.2 as SZ<br/>import QtQuick.Layouts 1.3<br/>import "bars" as Bars<br/>import "." as Qmls<br/>import "gradients" as SApp<br/><br/>ApplicationWindow {<br/>    width: SZ.Screen.desktopAvailableWidth / 2<br/>    height: SZ.Screen.desktopAvailableHeight / 2<br/>    title: "QML Application"<br/>    menuBar: Bars.MBar {}<br/>    toolBar: Bars.TBar {}<br/>...</pre>
<p style="padding-left: 60px">The width and height of the application window will be dependent on the resolution of the device. Also, the created <kbd>bars/</kbd> directory inside the <kbd>qmls/</kbd> folder will be used to import this application's menus and status bars. </p>
<ol start="2">
<li>Add the bar to the bottom of the application window:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Bars.TaBar {<br/>        id: tabar1<br/>        width: parent.width<br/>    }<br/>...</pre>
<p style="padding-left: 60px">The <kbd>id</kbd> of the tab bar and the <kbd>width</kbd> of the application window are specified.</p>
<ol start="3">
<li><span>Then, add the <kbd>StackLayout</kbd> class with <kbd>UAppItems</kbd>:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    StackLayout {<br/>        id: sl1<br/>        width: tabar1.width<br/>        height: tabar1.height<br/>        currentIndex: tabar1.currentIndex<br/>        Qmls.UAppItems {<br/>            width: tabar1.width<br/>            height: tabar1.height<br/>        }<br/>    }</pre>
<p style="padding-left: 60px">This will add the application items that will be used with the stacked layout representation. </p>
<ol start="4">
<li>Add the status bar for the application window at the bottom of the <kbd>UAppwin.qml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    statusBar: StatusBar {<br/>        anchors.fill: parent<br/>        Label { text: "Reading..."; color: "red" }<br/>        style: StatusBarStyle {<br/>            background: Rectangle {<br/>                anchors.fill: parent<br/>                SApp.UGradientWin {}<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The <kbd>StatusBar</kbd> class uses <kbd>Label</kbd> for the text and <kbd>style</kbd> for the gradient colors. </p>
<p>Now, we need to create a directory called <kbd>bars/</kbd><strong> </strong>inside <kbd>qmls/</kbd>, which will be used for elements of the application window, such as the tab bar, the menu, and the status bar. Let's implement the following steps:</p>
<ol start="1">
<li>Create the <kbd>MBar.qml</kbd> <span>file in the</span> <kbd>bars/</kbd> <span>folder with the following lines:</span></li>
</ol>
<pre style="padding-left: 60px">import QtQuick.Controls 1.4<br/><br/>MenuBar {<br/>    Menu {<br/>        title: "File"<br/>        MenuItem { text: "New" }<br/>        MenuItem { text: "Open" }<br/>        MenuItem { text: "Save" }<br/>        MenuItem { text: "Save as" }<br/>    }<br/>    Menu {<br/>        title: "Edit"<br/>        MenuItem { text: "Cut" }<br/>        MenuItem { text: "Copy" }<br/>        MenuItem { text: "Paste" }<br/>    }<br/>    Menu {<br/>        title: "Tools"<br/>        MenuItem { text: "Tool # 1" }<br/>        MenuItem { text: "Tool # 2" }<br/>        MenuItem { text: "Tool # 3" }<br/>    }<br/>}</pre>
<p class="mce-root" style="padding-left: 60px">For each menu section, we need to add the <kbd>MenuItem</kbd> with text.</p>
<ol start="2">
<li>Create a file called <kbd>TBar.qml</kbd> for the toolbar of the application inside the <kbd>bars/</kbd> directory:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Controls 1.4<br/>import QtQuick.Layouts 1.2<br/><br/>ToolBar {<br/>    RowLayout {<br/>        anchors.fill: parent<br/>        ToolButton {<br/>            iconSource: "Icons/python1.png"<br/>        }<br/>        ToolButton {<br/>            iconSource: "Icons/python2.png"<br/>        }<br/>        ToolButton {<br/>            iconSource: "Icons/Aiconda.png"<br/>        }<br/>        Item { Layout.fillWidth: true }<br/>    }<br/>}</pre>
<p class="mce-root" style="padding-left: 60px">For each toolbar item, a tool button <span>is used </span>with an icon that is available in the <kbd>Icons/</kbd> folder, which is in the <kbd>bars/</kbd> directory. The tool buttons are arranged with a row layout.</p>
<ol start="3">
<li>Create <span>the central element, or <kbd>TabBar</kbd>, inside the</span> <kbd>TaBar.qml</kbd><strong> </strong><span>file</span><strong><span> </span></strong>in the <kbd>bars/</kbd> directory:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Controls 2.2<br/><br/>TabBar {<br/>    anchors.fill: parent<br/>    Repeater {<br/>        model: ["Actions", "Views", "Models"]<br/>        TabButton {<br/>            text: modelData<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">This <kbd>TabBar</kbd> will use several tabs in the application. These tabs are added in the <kbd>model</kbd> property. Each tab uses a tab button with model data text. The <kbd>Repeater</kbd> type is used to repeat the <kbd>TabButton</kbd> type for each element of the model. To use this tab bar with our application, we need to add some objects, such as items, images, videos, and animations.</p>
<ol start="4">
<li>Create a file inside the <kbd>qmls/</kbd> directory called <kbd>UAppItems.qml</kbd> (similar to <kbd>UItems.qml</kbd>) to implement the animated objects with the application window:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Layouts 1.3<br/>import "." as Qmls<br/><br/>GridLayout {<br/>    anchors.centerIn: parent<br/>    columns: 3<br/>...</pre>
<p style="padding-left: 60px">The <kbd>GridLayout</kbd> positions the items.</p>
<ol start="5">
<li><span>Add the first glow rectangle to the bottom of this<span> </span><kbd>GridLayout</kbd></span><span>:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Qmls.URectGlow {<br/>        id: rg1<br/>        Layout.leftMargin: parent.width / 100<br/>        Layout.rightMargin: parent.width / 100<br/>        Layout.topMargin: parent.height / 4<br/>        Layout.bottomMargin: parent.height / 12<br/>        Layout.fillWidth: true<br/>        Layout.fillHeight: true<br/>        color: Qt.rgba(0, 0.07, 0.14, 1);<br/>        glowcolor: Qt.rgba(0.95, 0, 0, 1);<br/>        txglow: Qt.rgba(0.77, 0, 0, 1);<br/>        txtext: "PUSH"<br/>        txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>        signal acolored(color ucolor)<br/>    ...<br/>...</pre>
<p class="mce-root"/>
<p style="padding-left: 60px">In this rectangle, <span>the layout properties for each side margin are </span>specified. This will be used for the space between the elements.</p>
<ol start="6">
<li><span>Add the <kbd>function</kbd> to the first rectangle:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        function onAcolor(ucolor) {<br/>            if (ucolor==Qt.rgba(0.95, 0, 0, 1)) {<br/>                return [Qt.rgba(0.2, 0.2, 0.2, 1), 0.5,<br/>                        Qt.rgba(0, 0.07, 0.14, 1), 0.5,<br/>                        Qt.rgba(0, 0.07, 0.14, 1)];<br/>                } else {<br/>                return [Qt.rgba(0.95, 0, 0, 1), 10,<br/>                        Qt.rgba(0, 0.07, 0.14, 1), 0.1,<br/>                        Qt.rgba(0.77, 0, 0, 1)];<br/>            };<br/>        }<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function returns a list of colors, depending on the colors that are passed as parameters.</p>
<ol start="7">
<li>Add the handlers and <kbd>MouseArea</kbd> to the first grid layout's element:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        onAcolored: {<br/>            var acol = onAcolor(rg1.glowcolor)<br/>            rg1.glowcolor = acol[0];<br/>            rg1.glowr = acol[1];<br/>            rg1.color = acol[2];<br/>            rg1.spr = acol[3];<br/>            rg1.txglow = acol[4];<br/>        }<br/>        MouseArea {<br/>            anchors.fill: parent<br/>            onClicked: rg1.acolored(Qt.rgba(0.2, 0.2, 0.2, 1))<br/>        }<br/>    }<br/>...</pre>
<p style="padding-left: 60px">The <kbd>onAcolored</kbd> handler calls the <kbd>onAcolor</kbd> function and changes the properties of the first rectangle correspondingly.</p>
<p class="mce-root"/>
<ol start="8">
<li><span>Add the second glow rectangle to the bottom of the<span> </span><kbd>GridLayout</kbd></span><span>:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Qmls.URectGlow {<br/>        id: rg2<br/>        Layout.leftMargin: parent.width / 100<br/>        Layout.rightMargin: parent.width / 100<br/>        Layout.topMargin: parent.height / 4<br/>        Layout.bottomMargin: parent.height / 12<br/>        Layout.fillWidth: true<br/>        Layout.fillHeight: true<br/>        color: Qt.rgba(0, 0.07, 0.14, 1);<br/>        glowcolor: Qt.rgba(0.95, 0, 0, 1);<br/>        txglow: Qt.rgba(0.77, 0, 0, 1);<br/>        txtext: "PUSH"<br/>        txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The second rectangle uses similar properties to the first.</p>
<ol start="9">
<li>Then, add the sequential animations to the second rectangle:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        SequentialAnimation {<br/>            id: sa2; running: false<br/>            loops: Animation.Infinite<br/>            PropertyAnimation {<br/>                target: rg2<br/>                properties: "glowcolor,txglow"<br/>                from: Qt.rgba(0.95, 0, 0, 1);<br/>                to: Qt.rgba(0.007, 1, 1, 1);<br/>                duration: 7000<br/>                easing.type: Easing.OutInElastic<br/>            }<br/>            PropertyAnimation { <br/>                target: rg2<br/>                properties: "glowcolor,txglow"<br/>                from: Qt.rgba(0.007, 1, 1, 1);<br/>                to: Qt.rgba(0.95, 0, 0, 1);<br/>                duration: 7000<br/>                easing.type: Easing.OutInElastic<br/>            }<br/>        }<br/>        MouseArea {<br/>            anchors.fill: parent; onClicked: sa2.running = true;<br/>        }<br/>    }<br/>...</pre>
<p style="padding-left: 60px">These animations are used to animate the color changes of the rectangle's glow and text glow colors.</p>
<ol start="10">
<li>Add the third element to the tab of the application window:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Qmls.URectGlow {<br/>        id: rg3<br/>        Layout.leftMargin: parent.width / 100<br/>        Layout.rightMargin: parent.width / 100<br/>        Layout.topMargin: parent.height / 4<br/>        Layout.bottomMargin: parent.height / 12<br/>        Layout.fillWidth: true<br/>        Layout.fillHeight: true<br/>        color: Qt.rgba(0, 0.07, 0.14, 1);<br/>        glowcolor: Qt.rgba(0.95, 0, 0, 1);<br/>        txglow: Qt.rgba(0.77, 0, 0, 1);<br/>        txtext: "PUSH"<br/>        txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This tab element is similar to the other element in this tab.</p>
<ol start="11">
<li>Add parallel animations to the third element (the glow rectangle) of the tab:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        ParallelAnimation {<br/>            id: pa3; running: false<br/>            loops: Animation.Infinite<br/>            PropertyAnimation {<br/>                target: rg3<br/>                properties: "glowcolor,txglow"<br/>                to: Qt.rgba(0, 0.07, 0.14, 1);<br/>                duration: 7000<br/>                easing.type: Easing.OutInElastic<br/>            }<br/>            PropertyAnimation {<br/>                target: rg3<br/>                properties: "glowr,spr"<br/>                to: 1<br/>                duration: 7000<br/>            }<br/>        }<br/>        MouseArea {<br/>            anchors.fill: parent; onClicked: pa3.running = true<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">This type uses the <kbd>PropertyAnimation</kbd> type to make changes to different properties in parallel.</p>
<p><span>Now we need to make some changes in the </span><kbd>URectGlow.qml</kbd><span> file:</span></p>
<ol start="1">
<li>Add new properties to the <kbd>URectGlow.qml</kbd><span> file</span>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>Rectangle {<br/>    property color glowcolor<br/>    property color txglow<br/>    property string txtext<br/>    property color txcolor<br/>    property real glowr: 10<br/>    property real spr: 0.1<br/>    property real whr: 1.5<br/>    property real rdx: 14<br/>...</pre>
<p style="padding-left: 60px">Here, we've added <span>custom properties </span>to the glow rectangle, which can be changed in any place, and that will reimplement this object in the application.</p>
<ol start="2">
<li>Now we need to change all the related properties of <kbd>URectGlow.qml</kbd> so that they're the custom properties:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    RectangularGlow {<br/>        ...<br/>        glowRadius: parent.glowr<br/>        spread: parent.spr<br/>        ...<br/>    }<br/>    Rectangle {<br/>        ...<br/>        width: parent.width / parent.whr<br/>        height: parent.height / parent.whr<br/>        ...<br/>        radius: rdx<br/>        Text {<br/>            ...<br/>            text: txtext<br/>            ...<br/>            color: txcolor<br/>        }<br/>        Glow {<br/>            ...<br/>            radius: parent.radius / 2<br/>            ...<br/>        }<br/>    }<br/>...</pre>
<p style="padding-left: 60px">Change the properties to the values of the custom properties to reimplement them in the application.</p>
<p class="mce-root"/>
<ol start="3">
<li>For <span>the application to </span>work properly, it is recommended that you add <span>the following lines </span>to each rectangular glow element of the app:</li>
</ol>
<pre style="padding-left: 60px">...<br/>GridLayout {<br/>    ...<br/>    Uqmls.URectGlow {<br/>        ... <br/>        txtext: "PUSH"<br/>        txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We have changed the properties of the rectangles to the new, custom-created ones.</p>
<ol start="4">
<li>To show this result, we can run this app by adding <span>the following lines </span>to the <kbd>u_qml.qml</kbd> file, somewhere before the rectangle, with <kbd>id: rect1</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.UAppwin { id: appwin1; visible: true }<br/>    ...<br/>...</pre>
<p class="mce-root"/>
<p style="padding-left: 60px">The preceding line will add the demonstration of the application window to the main window application. Run the <kbd>u_qml.qml</kbd> file with the <kbd>u_app.py</kbd> P<span>ython </span>file. You will see the application window with bars, a menu, and animated items:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/47d7a8e6-f9ff-4b7d-8364-6069d23cd368.png" style="width:53.83em;height:22.17em;"/></p>
<p>The application window has a top panel, tool bar, central widget, and status bar. The buttons of the central widget provide animation effects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Button</h1>
                </header>
            
            <article>
                
<p>The most popular type in GUIs is the button. This is a push button with a text label. You will need the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick.Controls 1.4</pre>
<p>It has the following properties:</p>
<p><kbd>action</kbd>: This is an associated button action, such as text or a tooltip.</p>
<p><kbd>checkable</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd><span>, the button will be checkable, that is, it remains pushed when the user pushes this button (the default is</span> <kbd>false</kbd><span>).</span></p>
<p><kbd>checked</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd><span>, the button will be checked (the default is</span> <kbd>false</kbd><span>). It's available only if</span> <kbd>checkable</kbd> <span>is set to</span> <kbd>true</kbd><span>.</span></p>
<p><kbd>exclusiveGroup</kbd><strong>:</strong><span> This determines whether the button belongs to a group.</span></p>
<p><kbd>hovered</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and states whether</span> the button is being hovered<span>.</span></p>
<p><kbd>iconName</kbd><strong>:</strong><span> This</span> <kbd>string</kbd> <span>is the theme name of the image source.</span></p>
<p><kbd>iconSource</kbd><strong>:</strong><span> This is a URL. The button will have an icon image from the provided URL.</span></p>
<p><kbd>isDefault</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. T</span>his button will be the default, or will be clicked on when the <em>Enter</em> key is pressed.</p>
<p><kbd>menu</kbd><strong>:</strong><span> This provides a d</span><span>rop-</span><span>down menu for this button.</span></p>
<p><kbd>pressed</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd><span>, the button has been pressed.</span></p>
<p><kbd>style</kbd><strong>:</strong><span> This component is for the style of the button, such as</span> <kbd>ButtonStyle</kbd><span>.</span></p>
<p><kbd>text</kbd><strong>:</strong><span> This <kbd>string</kbd> sets the text to the button.</span></p>
<p><kbd>tooltip</kbd>: <span>This <kbd>string</kbd> sets a tooltip to the button.</span></p>
<p>It also has the following signal:</p>
<p><kbd>clicked()</kbd>: This is emitted when the button is clicked on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ButtonStyle</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>ButtonStyle</kbd> type can be used to</span> style the button. You will need the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick.Controls.Styles 1.4</pre>
<p>It has the following properties:</p>
<p><kbd>background</kbd><strong>:</strong> This component is used for the background styling of the button.</p>
<p><kbd>control</kbd><strong>:</strong> This is the button of the <kbd>Button</kbd> QML type with the style that will be attached to this button.</p>
<p><kbd>label</kbd><strong>:</strong><span> T</span>his component is used to style the label of this button.</p>
<p>Let's have a look at the following example:</p>
<ol>
<li>Modify the <kbd>UButton.qml</kbd> <span>file:</span></li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Controls 1.4<br/>import QtQuick.Controls.Styles 1.4<br/>import "." as Qmls<br/><br/>Button {<br/>    property color bcolor: Qt.rgba(0, 0.07, 0.14, 1);<br/>    property color gcolor: Qt.rgba(0.95, 0, 0, 1);<br/>    property color tgcolor: Qt.rgba(0.77, 0, 0, 1);<br/>    property color tcolor: Qt.rgba(0.2, 0.2, 0.2, 1);<br/>    property real glrd: 3<br/>    property real sprd: 0.5<br/>    property string btext<br/>...</pre>
<p style="padding-left: 60px">This is a standard push button, with specified custom properties for colors, glow radius, spread, and text. </p>
<ol start="2">
<li>Add the <kbd>style</kbd> property to the button using the <kbd>ButtonStyle</kbd> type:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    style: ButtonStyle {<br/>        background: Qmls.URectGlow {<br/>            id: but1<br/>            txtext: btext<br/>            txcolor: tcolor<br/>            color: bcolor<br/>            glowcolor: gcolor<br/>            txglow: tgcolor<br/>            glowr: glrd<br/>            spr: sprd<br/>            whr: 1.2<br/>            rdx: 7<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Here, we've styled the button with the <kbd>ButtonStyle</kbd> type and the property background, which will use the button's custom properties. Now we need to add some <span>lines </span>to the <kbd>u_qml.qml</kbd> file.</p>
<ol start="3">
<li>In the importing section, add the controls and the styles of the controls that can be used with buttons and other related elements:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import QtQuick.Controls 1.4<br/>import QtQuick.Controls.Styles 1.4<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root" style="padding-left: 60px">The versions of the imported elements can vary, depending on the Qt library version you are using.</p>
<ol start="4">
<li><span>Add the first button </span>inside the rectangle with <kbd>id: rect2</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        Uqmls.URect {<br/>            ...<br/>            Uqmls.UButton {<br/>                id: ubut1<br/>                width: rect2.width<br/>                height: rect2.height / 10<br/>                btext: "HIDE"<br/>                tooltip: "Hide the panel with buttons"<br/>                MouseArea {<br/>                    anchors.fill: parent; hoverEnabled: true<br/>                    onEntered: {<br/>                        parent.tcolor = Qt.rgba(1, 0, 0, 1); <br/>                    }<br/>                    onExited: {<br/>                        parent.tcolor = Qt.rgba(0.2, 0.2, 0.2, 1);<br/>                    }<br/>                    onClicked: {<br/>                        rect2.visible = false; <br/>                        rect1.width = UQml.Window.width;} <br/>                    }<br/>                }<br/>            }<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Here, we are using different types of signal handlers in the mouse area of the button.</p>
<ol start="5">
<li>Add the second button after the first:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ... <br/>        Uqmls.UButton {<br/>            id: ubut2<br/>            width: rect2.width<br/>            height: rect2.height / 10<br/>            y: rect2.height / 10 <br/>            btext: "APPS"<br/>            tooltip: "Run example of the Application Window"<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The <kbd>tooltip</kbd> property, as specified in this button, will provide the tooltip with the used action. </p>
<ol start="6">
<li>Add the sequential animations to the second button, at the bottom:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>            ...<br/>            SequentialAnimation {<br/>                id: sa1; running: false; loops: 1<br/>                PropertyAnimation {<br/>                    target: ubut2; property: "glrd"; to: 7;<br/>                    duration: 100;<br/>                }<br/>                PropertyAnimation {<br/>                    target: ubut2; property: "glrd"; to: 3;<br/>                    duration: 100<br/>                }<br/>            }<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This is used to realize the hover and blinking effects with animations.</p>
<ol start="7">
<li>Add the <kbd>MouseArea</kbd> type to the second button:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>            ...<br/>             MouseArea {<br/>                anchors.fill: parent; hoverEnabled: true<br/>                onEntered: {<br/>                    parent.tcolor = Qt.rgba(1, 0, 0, 1);<br/>                }<br/>                onExited: {<br/>                    parent.tcolor = Qt.rgba(0.2, 0.2, 0.2, 1);<br/>                }<br/>                onClicked: {<br/>                    sa1.running = true; appwin1.visible = true;<br/>                }<br/>            }<br/>        }</pre>
<p class="mce-root" style="padding-left: 60px">These signal handlers are used to handle events such as enter cursor in the area, exit cursor from the area, and clicks.</p>
<ol start="8">
<li>Now add the third button after the second button:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        Uqmls.UButton {<br/>            id: ubut3<br/>            width: rect2.width<br/>            height: rect2.height / 10<br/>            y: (rect2.height / 10) * 2<br/>            btext: "TOOL"<br/>            tooltip: "Show animated rectangles as item elements"<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Clicking on this button will show animated rectangles in the application window.</p>
<ol start="9">
<li>Add the <kbd>MouseArea</kbd> type and the <kbd>onClicked</kbd> handler to the third button:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>            ...<br/>            MouseArea {<br/>                anchors.fill: parent; hoverEnabled: true<br/>                onEntered: {<br/>                    ubut3.tcolor = Qt.rgba(1, 0, 0, 1);<br/>                }<br/>                onExited: {<br/>                    ubut3.tcolor = Qt.rgba(0.2, 0.2, 0.2, 1);<br/>                }<br/>                onClicked: {ubut3.clicked()}<br/>            }<br/>            onClicked: {<br/>                ubut3.glrd == 3 ? ubut3.glrd = 7 : ubut3.glrd = 3;<br/>                if (ubut3.glrd==7) {<br/>                    main_item.visible = true;<br/>                    grid1.visible = false;<br/>                } else {<br/>                    main_item.visible = false;<br/>                    grid1.visible = true;<br/>                };<br/>            }<br/>        }<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The <kbd>onClicked</kbd> handler uses JavaScript instructions to make  <kbd>main_item</kbd> and <kbd>grid1</kbd> <span>visible/invisible </span>in the first rectangle of the application window.</p>
<p>Now we need to cut the <kbd>Grid</kbd> from the <kbd>u_qml.qml</kbd> file, create a file called <kbd>UGrid.qml</kbd> in the <kbd>qmls/</kbd> directory, paste the <kbd>Grid</kbd> to this file, and rebuild the lines of code with the <kbd>GridLayout</kbd>:</p>
<ol start="1">
<li>Change the <kbd>Grid</kbd> elements positioning to the <kbd>GridLayout</kbd> construction:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Layouts 1.3<br/>import "." as Uqmls<br/><br/>GridLayout {<br/>    Uqmls.UCircle {id: g1;Layout.margins: 20<br/>    Layout.fillWidth: true;Layout.fillHeight: true}<br/>    Uqmls.URectLG {id: g2;Layout.margins: 20<br/>    Layout.fillWidth: true;Layout.fillHeight: true}<br/>    Uqmls.URectRG {id: g3;Layout.margins: 20<br/>    Layout.fillWidth: true;Layout.fillHeight: true}<br/>    Uqmls.URectCG {id: g4;Layout.margins: 20<br/>    Layout.fillWidth: true;Layout.fillHeight: true}<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This is the construction of the items that was used before we used <kbd>GridLayout</kbd> positioning.</p>
<ol start="2">
<li>Add the first rectangle with a glow effect to the <kbd>UGrid.qml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.URectGlow {<br/>        id: g5; Layout.fillWidth: true; Layout.fillHeight: true<br/>        Layout.margins: 20<br/>        color: Qt.rgba(0, 0.07, 0.14, 1);<br/>        glowcolor: Qt.rgba(0.007, 1, 1, 1);<br/>        txglow: Qt.rgba(0.007, 0.7, 0.7, 1);<br/>        txtext: "PUSH"<br/>        txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The custom and layout properties are added to this rectangle.</p>
<ol start="3">
<li>Add the <kbd>MouseArea</kbd> and <kbd>RotationAnimator</kbd> QML types to the first rectangle:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>         MouseArea {<br/>            anchors.fill: parent<br/>            onClicked: {<br/>                g5.glowcolor == Qt.rgba(0.007, 1, 1, 1) ?<br/>                g5.glowcolor = Qt.rgba(0, 0.07, 0.14, 1) :<br/>                g5.glowcolor = Qt.rgba(0.007, 1, 1, 1);<br/>                g5.txglow == Qt.rgba(0, 0.07, 0.14, 1) ?<br/>                g5.txglow = Qt.rgba(0.007, 1, 1, 1) :<br/>                g5.txglow = Qt.rgba(0, 0.07, 0.14, 1);<br/>                g5a.running == true ? <br/>                g5a.running = false : g5a.running = true;<br/>            }<br/>        }<br/>        RotationAnimator {<br/>            id: g5a; running: false; loops: Animation.Infinite<br/>            target: g1<br/>            to: 360<br/>            duration: 1000<br/>            easing.type: Easing.Linear<br/>        }<br/>    }<br/>...</pre>
<p style="padding-left: 60px">This animator will rotate the item with the specified <kbd>id</kbd> property clockwise by <kbd>360</kbd> degrees, with a speed dependent on the <kbd>duration</kbd> property. The animation will be infinite.</p>
<ol start="4">
<li>Add the second rectangle to the <kbd>UGrid.qml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>     Uqmls.URectGlow {<br/>        id: g6; Layout.fillWidth: true; Layout.fillHeight: true<br/>        Layout.margins: 20<br/>        color: Qt.rgba(0, 0.07, 0.14, 1);<br/>        glowcolor: Qt.rgba(0.95, 0, 0, 1);<br/>        txglow: Qt.rgba(0.77, 0, 0, 1);<br/>        txtext: "PUSH"<br/>        txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This is the second rectangle with <kbd>id</kbd> and <kbd>Layout</kbd> properties.</p>
<ol start="5">
<li>Add the <kbd>MouseArea</kbd> and <kbd>RotationAnimator</kbd> types to the bottom of the second rectangle:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        MouseArea {<br/>            anchors.fill: parent<br/>            onClicked: {<br/>                g6.glowcolor == Qt.rgba(0.95, 0, 0, 1) ?<br/>                g6.glowcolor = Qt.rgba(0, 0.07, 0.14, 1) :<br/>                g6.glowcolor = Qt.rgba(0.95, 0, 0, 1);<br/>                g6.txglow == Qt.rgba(0, 0.07, 0.14, 1) ?<br/>                g6.txglow = Qt.rgba(0.77, 0, 0, 1) :<br/>                g6.txglow = Qt.rgba(0, 0.07, 0.14, 1);<br/>                g6a.running == true ? <br/>                g6a.running = false : g6a.running = true;<br/>            }<br/>        }<br/>        RotationAnimator {<br/>            id: g6a; running: false; loops: Animation.Infinite<br/>            target: g2<br/>            to: 360<br/>            duration: 300<br/>            easing.type: Easing.InQuad<br/>        }<br/>    }<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">The <kbd>duration</kbd> property of this <kbd>RotationAnimator</kbd> is less than it was in the first rectangle, and so this circle will be rotated faster.</p>
<ol start="6">
<li>Add the third rectangle to the <kbd>UGrid.qml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.URectGlow {             <br/>        id: g7; Layout.fillWidth: true; Layout.fillHeight: true<br/>        Layout.margins: 20    <br/>        color: Qt.rgba(0, 0.07, 0.14, 1);  <br/>        glowcolor: Qt.rgba(0,0.95,0.37,1); <br/>        txglow: Qt.rgba(0,0.47,0.37,1);    <br/>        txtext: "PUSH"                     <br/>        txcolor: Qt.rgba(0.2, 0.2, 0.2, 1) <br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This is the third rectangle with a glow effect, an <kbd>id: g7</kbd> property, and <kbd>Layout</kbd> properties that fill the width and height.</p>
<ol start="7">
<li>Add the <kbd>MouseArea</kbd> and <kbd>RotationAnimator</kbd> to the third rectangle:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        MouseArea {<br/>            anchors.fill: parent<br/>            onClicked: {<br/>                g7.glowcolor == Qt.rgba(0, 0.95, 0.37, 1) ?<br/>                g7.glowcolor = Qt.rgba(0, 0.07, 0.14, 1) :<br/>                g7.glowcolor = Qt.rgba(0, 0.95, 0.37, 1);<br/>                g7.txglow == Qt.rgba(0, 0.07, 0.14, 1) ?<br/>                g7.txglow = Qt.rgba(0, 0.47, 0.37, 1) :<br/>                g7.txglow = Qt.rgba(0, 0.07, 0.14, 1);<br/>                g7a.running == true ?<br/>                g7a.running = false : g7a.running = true;<br/>            }<br/>        }<br/>        RotationAnimator {<br/>            id: g7a; running: false; loops: Animation.Infinite<br/>            target: g3<br/>            to: 360<br/>            duration: 200<br/>            easing.type: Easing.InCubic<br/>        }<br/>    }<br/>...</pre>
<p style="padding-left: 60px">This <kbd>RotationAnimator</kbd> will rotate the target circle faster than the previous <span>two</span>.</p>
<ol start="8">
<li>Finally, add the fourth rectangle to the application:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.URectGlow {<br/>        id: g8; Layout.fillWidth: true; Layout.fillHeight: true<br/>        Layout.margins: 20<br/>        color: Qt.rgba(0, 0.07, 0.14, 1);<br/>        glowcolor: Qt.rgba(1, 1, 1, 1);<br/>        txglow: "grey";<br/>        txtext: "PUSH"<br/>        txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>    ...<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">This rectangle uses a named color, <kbd>grey</kbd>, for the <kbd>txtglow</kbd> property of the rectangle.</p>
<ol start="9">
<li>Finally, for the last rectangle, add the <kbd>MouseArea</kbd> and <kbd>RotationAnimator</kbd> types:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        MouseArea {<br/>            anchors.fill: parent<br/>            onClicked: {<br/>                g8.glowcolor == Qt.rgba(1, 1, 1, 1) ?<br/>                g8.glowcolor = Qt.rgba(0, 0.07, 0.14, 1) :<br/>                g8.glowcolor = Qt.rgba(1, 1, 1, 1);<br/>                g8.txglow == Qt.rgba(0, 0.07, 0.14, 1) ?<br/>                g8.txglow = "grey" :<br/>                g8.txglow = Qt.rgba(0, 0.07, 0.14, 1);<br/>                g8a.running == true ?<br/>                g8a.running = false : g8a.running = true;<br/>            }<br/>        }<br/>        RotationAnimator {<br/>            id: g8a; running: false; loops: Animation.Infinite<br/>            target: g4<br/>            to: 360<br/>            duration: 100<br/>            easing.type: Easing.InQuart<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">This animator will rotate the target circle at a faster speed than the previous circles. <span><span>These </span></span>examples demonstrate the principles of creating and styling buttons with the <kbd>Button</kbd>, <kbd>Rectangle</kbd>, and <kbd>MouseArea</kbd> QML types.</p>
<p>Practicing with this code may help you to understand these basics. Finally, to implement the button in the application, let's change the <kbd>u_qml.qml</kbd> file:</p>
<ol start="1">
<li>Add/change the <kbd>UAppwin</kbd>, <kbd>UItem</kbd>, and <kbd>UGrid</kbd> properties to/in the application:</li>
</ol>
<pre style="padding-left: 60px">... <br/>    ...<br/>        ...<br/>            ...<br/>            Uqmls.UAppwin {<br/>                id: appwin1<br/>                visible: false<br/>            }<br/>            Uqmls.UItem {<br/>                id: main_item<br/>                visible: false<br/>                width: rect1.width<br/>                height: parent.height - rect1.height<br/>                y: rect1.height<br/>            }<br/>            Uqmls.UGrid {<br/>                id: grid1<br/>                anchors.fill: parent<br/>                visible: true<br/>                function wsize() {<br/>                    if (parent.width &gt; 590) {<br/>                        return 4;<br/>                    } <br/>                    else {return 2;};<br/>                }<br/>                columns: wsize();<br/>            }<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The visible properties of <kbd>UItem</kbd> and <kbd>UAppwin</kbd> are set to false. By default, <kbd>UGrid</kbd><span> </span>will be visible with circles and glow rectangles. Now we can run the application, and we'll see the following result:   </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/be574969-e353-48ec-9131-e7dc738b98a7.png"/></p>
<p>If we push these buttons, the related circle will rotate, and if we push them again, the related circle will stop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CheckBox</h1>
                </header>
            
            <article>
                
<p>The <kbd>CheckBox</kbd> button allows the user to select <span>one or more options</span>. A <kbd>CheckBox</kbd> button can be toggled to check an option, or it can be unchecked, and it consists of a checkbox and a text label. You need the following <kbd>import</kbd> statement for this type:</p>
<pre>import QtQuick.Controls 1.4</pre>
<p class="mce-root"/>
<p>It has the following properties:</p>
<p><kbd>checked</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. It is <kbd>true</kbd> if the checkbox is checked.</p>
<p><kbd>pressed</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. It is</span> <kbd>true</kbd> <span>if the checkbox is</span> <span>checked</span><span>.</span></p>
<p><kbd>hovered</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. It is</span> <kbd>true</kbd> <span>if the checkbox is hovered over by the mouse pointer.</span></p>
<p><kbd>partiallyCheckedEnabled</kbd> <strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. It makes the</span> <kbd>Qt.PartiallyChecked</kbd> <span>state available.</span></p>
<p><kbd>text</kbd><strong>:</strong><span> This is a <kbd>string</kbd> that sets the text that will be displayed near the checkbox.</span></p>
<p><kbd>tooltip</kbd><strong>:</strong><span> This is a <kbd>string</kbd> that sets a tooltip to this button.</span></p>
<p><kbd>checkedState</kbd><strong>:</strong><span> This is an integer that sets the current state for the button.</span> <kbd>1</kbd> <span>means checked,</span> <kbd>0</kbd> <span>means unchecked, and</span> <kbd>2</kbd> <span>means partially checked.</span></p>
<p><kbd>activeFocusOnPress</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. The checkbox will be focused when pressed.</span></p>
<p><kbd>exclusiveGroup</kbd><strong>:</strong><span> This sets the group that the checkbox will belong to.</span></p>
<p><kbd>style</kbd><strong>:</strong><span> This component provides styling for this button, such as the</span> <kbd>CheckBoxStyle</kbd> <span>type. The</span> <kbd>CheckBoxStyle</kbd> <span>type includes</span> <kbd>background</kbd><span>,</span> <kbd>control</kbd><span>,</span> <kbd>indicator</kbd><span>,</span> <kbd>label</kbd><span>, and</span> <kbd>spacing</kbd> <span>properties.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ComboBox</h1>
                </header>
            
            <article>
                
<p>This type allows users to choose from multiple options of a drop-down list or implement the model in order to represent a <kbd>ComboBox</kbd>. Use the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick.Controls 1.4</pre>
<p>It has the following properties:</p>
<p><kbd>count</kbd><strong>:</strong> This is an integer, and is the number of items in the combo box.</p>
<p><kbd>currentIndex</kbd><strong>:</strong> This is an integer, and is the index of the selected item in the combo box.</p>
<p><kbd>currentText</kbd><strong>:</strong> This is a <kbd>string</kbd> that sets the text of the selected item.</p>
<p><kbd>pressed</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. It will be <kbd>true</kbd> if the <kbd>ComboBox</kbd> is pressed.</p>
<p><kbd>hovered</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. It will be <kbd>true</kbd> if the box is hovered over by the mouse pointer.</p>
<p><kbd>editable</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. It will make <span>the text inside </span>the combo box editable.</p>
<p><kbd>editText</kbd><strong>:</strong> This is a <kbd>string</kbd> that represents <span>the text </span>in the editable <kbd>ComboBox</kbd>, which can be edited.</p>
<p><kbd>selectByMouse</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>, and provides you with the ability to select the text in the editable <kbd>ComboBox</kbd> using the mouse.</p>
<p><kbd>menu</kbd><strong>:</strong> This component sets a menu so that you can work with text selections, such as the <kbd>menu</kbd> type component.</p>
<p><kbd>model</kbd><strong>:</strong> This will be used to implement the <kbd>ComboBox</kbd>.</p>
<p><kbd>inputMethodComposing</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. If it's <kbd>true</kbd>, the editable <kbd>ComboBox</kbd> has partial text input from an input method.</p>
<p><kbd>inputMethodHints</kbd><strong>:</strong> This <kbd>enumeration</kbd> sets hints for the input about the expected content, such as <kbd>Qt.ImhHiddenText</kbd>, which will be a password field, or <kbd>Qt.ImhDate</kbd>, which will be a date field.</p>
<p><kbd>acceptableInput</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. If <kbd>true</kbd>, the editable text field contains acceptable text.</p>
<p><kbd>activeFocusOnPress</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. The <kbd>ComboBox</kbd> will be focused when pressed.</p>
<p><kbd>textRole</kbd><strong>:</strong> This is a <kbd>string</kbd> that can be put as a model role for the <kbd>ComboBox</kbd>.</p>
<p><kbd>validator</kbd><strong>:</strong> This sets a text validator for the editable <kbd>ComboBox</kbd>.</p>
<p><kbd>style</kbd><strong>:</strong> This component is used of the styling for the <kbd>ComboBox</kbd>, such as the <kbd>ComboBoxStyle</kbd> type. <kbd>ComboBoxStyle</kbd> has the <kbd>background</kbd>, <kbd>control</kbd>, <kbd>dropDownButtonWidth</kbd>, <kbd>font</kbd>, <kbd>label</kbd>, <kbd>renderType</kbd>, <kbd>selectedTextColor</kbd>, <kbd>selectionColor</kbd>, and <kbd>textColor</kbd> properties.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RadioButton</h1>
                </header>
            
            <article>
                
<p>This type of button provides a choice between different options, and only one can be checked at a time. This button consists of the radio button control and the text label. You need the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick.Controls 1.4</pre>
<p>It has the following properties:</p>
<p><kbd>checked</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. It's <kbd>true</kbd> if the radio button is checked.</p>
<p><kbd>pressed</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. It's</span> <kbd>true</kbd> <span>if the button is pressed.</span></p>
<p><kbd>hovered</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. It's </span><kbd>true</kbd> <span>if the button is hovered over by the mouse pointer.</span></p>
<p><kbd>text</kbd><strong>:</strong><span> This is a <kbd>string</kbd> that sets the text that will be displayed near the radio button.</span></p>
<p><kbd>tooltip</kbd><strong>:</strong><span> This is a <kbd>string</kbd> that sets the tooltip for this button.</span></p>
<p><kbd>activeFocusOnPress</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. The radio button will be focused when pressed.</span></p>
<p><kbd>exclusiveGroup</kbd><strong>:</strong><span> This is the group that the button will belong to.</span></p>
<p><kbd>style</kbd><strong>:</strong><span> This component provides styling for the button, such as the</span> <kbd>RadioButtonStyle</kbd> <span>type. The</span> <kbd>background</kbd><span>, <kbd>control</kbd>, <kbd>indicator</kbd>, <kbd>label</kbd>, and <kbd>spacing</kbd> properties are available in</span><span> the</span> <kbd>RadioButtonStyle</kbd> <span>type.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TextField</h1>
                </header>
            
            <article>
                
<p>These elements provide the functionality to work with and visualize text data. The user can paste, copy, edit, and insert text from a file or <span>input </span>text manually, or use another operation related to the text in the text field. In the <kbd>QtQuick</kbd> module, the <span><kbd>TextArea</kbd> and <kbd>TextField</kbd> types are available </span>for these tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TextArea</h1>
                </header>
            
            <article>
                
<p>This type allows lines of editable formatted text. We need to use the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick.Controls 1.4</pre>
<p>It has the following properties:</p>
<p><kbd>text</kbd><strong>:</strong> This is a <kbd>string</kbd> that will be displayed in the text area.</p>
<p><kbd>textFormat</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>is the type of text field that will be provided with this</span> <kbd>TextArea</kbd><span>. It can be</span> <kbd>TextEdit.AutoText</kbd><span>, which will automatically determine whether the text will be either plain or rich text;</span> <kbd>TextEdit.PlainText</kbd><span>, where the text will be plain; and</span> <kbd>TextEdit.RichText</kbd><span>, which will make rich text.</span></p>
<p><kbd>textDocument</kbd><strong>:</strong><span> The </span><kbd>textDocument</kbd> property exposes the <kbd>QQuickTextDocument</kbd><span> class.</span></p>
<p><strong><kbd>baseUrl</kbd>:</strong><span> This specifies a base URL that will be used to resolve relative URLs within the text.</span></p>
<p><strong><kbd>hoveredLink</kbd>:</strong><span> This is a</span> link <kbd>string</kbd>. When hovered over by a mouse, you can see that a link has been embedded in the text.</p>
<p><strong><kbd>wrapMode</kbd>:</strong><span> This</span> <kbd>enumeration</kbd> <span>provides a wrapping of the text related to the width of the text area. The available flags are as follows:</span></p>
<ul>
<li><kbd>TextEdit.NoWrap</kbd>: Wrapping will not be available.</li>
<li><kbd>TextEdit.WordWrap</kbd>: Text wrapping by the words (the default).</li>
<li><kbd>TextEdit.WrapAnywhere</kbd>: Text will be wrapped anywhere.</li>
<li><kbd>TextEdit.Wrap</kbd>: If possible, the text will be wrapped by words, or if the line of the text is long and has no spaces, it will be wrapped at an appropriate point on the line.</li>
</ul>
<p><kbd>length</kbd><strong>:</strong><span> This is an integer that returns the number of plain text characters in the text area.</span></p>
<p><kbd>lineCount</kbd><strong>:</strong><span> This is an integer that returns the number of lines in the text.</span></p>
<p><kbd>inputMethodComposing</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the text area will have partial text input from an input method.</span></p>
<p><kbd>inputMethodHints</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>provides the types of the input methods that can be implemented with text area flags such as</span> <kbd>Qt.ImhHiddenText</kbd> <span>for the passwords.</span></p>
<p><kbd>readOnly</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the text area will be read-only.</span></p>
<p><kbd>selectByKeyboard</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and if</span> <kbd>true</kbd><span>, it allows users to select text with the keyboard (the default is</span> <kbd>true</kbd><span>).</span></p>
<p><kbd>selectByMouse</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and if</span> <kbd>true</kbd><span>, it allows users to select text with the mouse (the default is</span> <kbd>true</kbd><span>).</span></p>
<p><kbd>selectedText</kbd><strong>:</strong><span> This is a</span> <kbd>string</kbd> <span>of the currently selected text.</span></p>
<p><kbd>selectionStart</kbd><strong>:</strong><span> This is an integer for the position of the cursor before the first character in the selection.</span></p>
<p><kbd>selectionEnd</kbd><strong>:</strong><span> This is an integer for the position of the cursor after the last character in the selection.</span></p>
<p><kbd>canPaste</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and returns</span> <kbd>true</kbd> <span>if the content in the clipboard can be pasted into the text area.</span></p>
<p><kbd>canRedo</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and returns</span> <kbd>true</kbd> <span>if the text was edited and can be redone.</span></p>
<p><kbd>canUndo</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and returns</span> <kbd>true</kbd> <span>if the text was edited and can be undone.</span></p>
<p><kbd>cursorPosition</kbd><strong>:</strong><span> This is an integer for the position of the cursor in the text area.</span></p>
<p><kbd>cursorRectangle</kbd><strong>:</strong><span> This is the rectangle where the text cursor is rendered within this </span>text area<span>.</span></p>
<p><kbd>activeFocusOnPress</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the text area will be focused when pressed.</span></p>
<p><kbd>backgroundVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and if</span> <kbd>true</kbd><span>, the background is filled (the default is</span> <kbd>true</kbd><span>).</span></p>
<p><kbd>tabChangesFocus</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. This property determines whether</span> tab <span>changes focus, or is accepted as input (the default is</span> <kbd>false</kbd><span>).</span></p>
<p class="mce-root"/>
<p><kbd>effectiveHorizontalAlignment</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>is for the effective horizontal alignment of the text.</span></p>
<p><kbd>horizontalAlignment</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>sets the alignment of the text, such as</span> <kbd>TextEdit.AlignHCenter</kbd><span>.</span></p>
<p><kbd>verticalAlignment</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>sets the alignment of the text, such as</span> <kbd>TextEdit.AlignTop</kbd><span>,</span> <kbd>TextEdit.AlignVCenter</kbd> <span>(the default), or</span> <kbd>TextEdit.AlignBottom</kbd><span>.</span></p>
<p><kbd>textMargin</kbd><strong>:</strong><span> This defines the margins (in pixels) around the text in the text area.</span></p>
<p><kbd>textColor</kbd><strong>:</strong><span> This is the color of the text in the area.</span></p>
<p><kbd>font</kbd><strong>:</strong><span> This is the font of the text.</span></p>
<p><kbd>menu</kbd><strong>:</strong><span> This component is the edit menu for working with text selection.</span></p>
<p><kbd>style</kbd><strong>:</strong><span> This component provides styling for the text area, such as the</span> <kbd>TextAreaStyle</kbd> <span>type. The</span> <span>properties i</span><span>n</span> <kbd>TextAreaStyle</kbd> <span>are</span> <kbd>backgroundColor</kbd><span>,</span> <kbd>control</kbd><span>,</span> <kbd>renderType</kbd><span>,</span> <kbd>font</kbd><span>,</span> <kbd>selectedTextColor</kbd><span>,</span> <kbd>selectionColor</kbd><span>,</span> <kbd>textColor</kbd><span>, and</span> <kbd>textMargin</kbd><span>.</span></p>
<p>The following signals are <span>available</span>:</p>
<p><kbd>editingFinished()</kbd>: This will be emitted when the area loses focus. The handler is <kbd>onEditingFinished</kbd>.</p>
<p><kbd>linkActivated(string link)</kbd><span>: This will be emitted when the user clicks on a link in the text. The handler is</span> <kbd>onLinkActivated</kbd><span>.</span></p>
<p><kbd>linkHovered(string link)</kbd><span>: This will be emitted when a link is hovered over in the text. The handler is</span> <kbd>onLinkHovered</kbd><span>.</span></p>
<p>The following are its methods:</p>
<p><kbd>append(string text)</kbd>: This adds the <kbd>string</kbd> as a new line at the end of the text.</p>
<p><kbd>copy()</kbd><span>: This copies the selected text to the clipboard.</span></p>
<p><kbd>cut()</kbd><span>: This cuts the selected text to the clipboard.</span></p>
<p><kbd>paste()</kbd><span>: This inserts the selected text from the clipboard to the text area.</span></p>
<p><kbd>deselect()</kbd><span>: This removes the text selection.</span></p>
<p><kbd>getFormattedText(int start, int end)</kbd><span>: This returns the text with formatting between the start and end positions.</span></p>
<p><kbd>getText(int start, int end)</kbd><span>: This returns the text without formatting between the start and end positions.</span></p>
<p><kbd>insert(int position, string text)</kbd><span>: This inserts the text to the position in the text area.</span></p>
<p><kbd>isRightToLeft(int start, int end)</kbd><span>: This is</span> <kbd>true</kbd> <span>if the direction of the text between the start/end positions is right to left.</span></p>
<p><kbd>moveCursorSelection(int position, mode=TextEdit.SelectCharacters)</kbd><span>: This moves the cursor to the specified position and updates the mode parameter.</span></p>
<p><kbd>positionToRectangle(position)</kbd><span>: This returns the rectangle at the position in the text.</span></p>
<p><kbd>undo()</kbd><span>: If available, this undoes the last edit action of the text.</span></p>
<p><kbd>redo()</kbd><span>: If available, this redoes the last edit action of the text.</span></p>
<p><kbd>remove(int start, int end)</kbd><span>: This removes the text between the start/end positions.</span></p>
<p><kbd>select(int start, int end)</kbd><span>: This selects the text between the start/end positions.</span></p>
<p><kbd>selectAll()</kbd><span>: This selects all the text of the text area.</span></p>
<p><kbd>selectWord()</kbd><span>: This selects the word that is closest to the current cursor position.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TextField</h1>
                </header>
            
            <article>
                
<p>This type provides a single line of editable plain text. The <kbd>TextField</kbd> type requires the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick.Controls 1.4</pre>
<p>It has the following properties:</p>
<p><kbd>text</kbd><strong>:</strong> This is a <kbd>string</kbd> that will be displayed in the text field.</p>
<p><kbd>displayText</kbd><strong>:</strong><span> T</span>his is a <kbd>string</kbd> of text that's displayed in the text field.</p>
<p class="mce-root"/>
<p><kbd>echoMode</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>sets how text will be displayed. The available modes are as follows:</span></p>
<ul>
<li><kbd>TextInput.Normal</kbd>: This is for normal text.</li>
<li><kbd>TextInput.Password</kbd>: This is for <span>password </span>text.</li>
<li><kbd>TextInput.NoEcho</kbd>: This is for text that is not displayed.</li>
</ul>
<ul>
<li><kbd>TextInput.PasswordEchoOnEdit</kbd>: This is for text that will be displayed as normal while editing, otherwise, the characters will be shown as asterisks.</li>
</ul>
<p><kbd>placeholderText</kbd><strong>:</strong><span> This <kbd>string</kbd> is the text that will be displayed when text field is empty.</span></p>
<p><kbd>length</kbd><strong>:</strong><span> This is an integer that returns the number of plain text characters in the text field.</span></p>
<p><kbd>maximumLength</kbd><strong>:</strong><span> This is an integer that is the maximum length of the text in the text field.</span></p>
<p><kbd>inputMask</kbd><strong>:</strong><span> This is a <kbd>string</kbd> of an input mask on the</span> <kbd>TextField</kbd><span>, and restricts the allowable text inputs.</span></p>
<p><kbd>inputMethodComposing</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. The text field will have partial text input from an input method.</span></p>
<p><kbd>inputMethodHints</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>provides the types of input methods that can be implemented with the text field, with flags such as</span> <kbd>Qt.ImhHiddenText</kbd> for the passwords.</p>
<p><kbd>readOnly</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the text field will be read-only.</span></p>
<p><kbd>selectByMouse</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and if</span> <kbd>true</kbd><span>, it allows us to select text with the mouse (the default is</span> <kbd>true</kbd><span>).</span></p>
<p><kbd>selectedText</kbd><strong>:</strong><span> This is a <kbd>string</kbd> of the currently selected text.</span></p>
<p><kbd>selectionStart</kbd><strong>:</strong><span> This is the integer for the position of the cursor before the first character in the selection.</span></p>
<p><kbd>selectionEnd</kbd><strong>:</strong><span> This is the integer for the position of the cursor after the last character in the selection.</span></p>
<p class="mce-root"/>
<p><kbd>canPaste</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and returns</span> <kbd>true</kbd> <span>if the content on the clipboard can be pasted into the text field.</span></p>
<p><kbd>canRedo</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and returns</span> <kbd>true</kbd> <span>if the text was edited and can be redone.</span></p>
<p><kbd>canUndo</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and returns</span> <kbd>true</kbd> <span>if the text was edited and can be undone.</span></p>
<p><kbd>cursorPosition</kbd><strong>:</strong><span> This is an integer of the position of the cursor in the text field.</span></p>
<p><kbd>cursorRectangle</kbd><strong>:</strong><span> This is the rectangle where the text cursor is rendered within the text field.</span></p>
<p><kbd>activeFocusOnPress</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and if</span> <kbd>true</kbd><span>, the text field will be focused when pressed.</span></p>
<p><kbd>acceptableInput</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and returns</span> <kbd>true</kbd> <span>if the text is acceptable.</span></p>
<p><kbd>hovered</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, depending on whether the text field is hovered over or not.</span></p>
<p><kbd>effectiveHorizontalAlignment</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>is the effective horizontal alignment of the text.</span></p>
<p><kbd>horizontalAlignment</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>sets the alignment of the text, such as</span> <kbd>TextInput.AlignHCenter</kbd><span>.</span></p>
<p><kbd>verticalAlignment</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>sets the alignment of the text, such as</span> <kbd>TextInput.AlignTop</kbd><span>,</span> <kbd>TextInput.AlignVCenter</kbd> <span>(the default), and</span> <kbd>TextInput.AlignBottom</kbd><span>.</span></p>
<p><kbd>textColor</kbd><strong>:</strong><span> This is the color of the text in the area.</span></p>
<p><kbd>font</kbd><strong>:</strong><span> This is the font of the text.</span></p>
<p><kbd>menu</kbd><strong>:</strong><span> This component is the edit menu for working with the text selection.</span></p>
<p><kbd>validator</kbd><strong>:</strong><span> This sets a validator on the</span> <kbd>TextField</kbd><span>. The </span>supported validators are <kbd>IntValidator</kbd>, <kbd>DoubleValidator</kbd>, and <kbd>RegExpValidator</kbd>.</p>
<p class="mce-root"/>
<p><kbd>style</kbd><strong>:</strong><span> This component provides styling for the text field, such as the</span> <kbd>TextFieldStyle</kbd> <span>type. In this type, the</span> <kbd>background</kbd><span>,</span> <kbd>control</kbd><span>,</span> <kbd>passwordCharacter</kbd><span>,</span> <kbd>placeholderTextColor</kbd><span>,</span> <kbd>renderType</kbd><span>,</span> <kbd>font</kbd><span>,</span> <kbd>selectedTextColor</kbd><span>,</span> <kbd>selectionColor</kbd><span>, and</span> <kbd>textColor</kbd> <span>properties are available.</span></p>
<p>These signals are <span>available</span>:</p>
<p><kbd>editingFinished()</kbd>: This is emitted when the field loses focus. The handler is <kbd>onEditingFinished</kbd>.</p>
<p><kbd>accepted()</kbd><span>: This is emitted when the</span> <em>return</em> <span>or</span> <em>Enter</em> <span>key is pressed.</span></p>
<p>The following methods are available:</p>
<p><kbd>copy()</kbd>: This copies the selected text to the clipboard.</p>
<p><kbd>cut()</kbd><span>: This cuts the selected text to the clipboard.</span></p>
<p><kbd>paste()</kbd><span>: This inserts the selected text from the clipboard to the text field.</span></p>
<p><kbd>deselect()</kbd><span>: This removes the text selection.</span></p>
<p><kbd>getText(int start, int end)</kbd><span>: This returns the text without formatting between the start and end positions.</span></p>
<p><kbd>insert(int position, string text)</kbd><span>: This inserts the text in the specified position in the text field.</span></p>
<p><kbd>isRightToLeft(int start, int end)</kbd><span>: This is</span> <kbd>true</kbd> <span>if the direction of the text between the start/end positions is right to left.</span></p>
<p><kbd>undo()</kbd><span>: If this is available, it undoes the last edit action of the text.</span></p>
<p><kbd>redo()</kbd><span>: If this is available, it redoes the last edit action of the text.</span></p>
<p><kbd>remove(int start, int end)</kbd><span>: This removes the text between the start/end positions.</span></p>
<p><kbd>select(int start, int end)</kbd><span>: This selects the text between the start/end positions.</span></p>
<p><kbd>selectAll()</kbd><span>: This selects all the text in the text field.</span></p>
<p><kbd>selectWord()</kbd><span>: This selects the word that is closest to the current cursor position.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigation</h1>
                </header>
            
            <article>
                
<p>The <kbd>QtQuick.Controls</kbd> module has an instrument for constructing navigation tools inside GUI applications. The <kbd>import</kbd> statement for these types is as follows:</p>
<pre>import QtQuick.Controls 1.4</pre>
<p>It can be implemented with the types that are mentioned in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ScrollView</h1>
                </header>
            
            <article>
                
<p>This type provides scrolling within another item. It allows us to scroll the item if its height and width are more than the main window, and it adds scroll bars. The <kbd>ScrollView</kbd> type has the following properties:</p>
<p><kbd>contentItem</kbd><strong>:</strong> This is the content item for this scroll.</p>
<p><kbd>flickableItem</kbd><strong>:</strong> <span>This is</span> the flickable item for this scroll.</p>
<p><kbd>frameVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. When</span> <kbd>true</kbd><span>, the scroll view will render the frame around its content.</span></p>
<p><kbd>highlightOnFocus</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, it will highlight around the frame when it has input focus.</span></p>
<p><kbd>horizontalScrollBarPolicy</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>is the policy for the horizontal scroll bar, such as</span> <kbd>Qt.ScrollBarAsNeeded</kbd><span>,</span> <kbd>Qt.ScrollBarAlwaysOff</kbd><span>, and</span> <kbd>Qt.ScrollBarAlwaysOn</kbd><span>.</span></p>
<p><kbd>verticalScrollBarPolicy</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>is the policy for the vertical scroll bar with the</span> <span>same </span><span>modes as horizontal.</span></p>
<p><kbd>viewport</kbd><strong>:</strong><span> This is the</span> size <span>of the viewport, and tells us how much of the content area is visible relative to the window.</span></p>
<p><kbd>style</kbd><strong>:</strong><span> This component provides styling for the scroll, such as the</span> <kbd>ScrollViewStyle</kbd> <span>type. In the type, the</span> <kbd>control</kbd><span>,</span> <kbd>corner</kbd><span>,</span> <kbd>decrementControl</kbd><span>,</span> <kbd>frame</kbd><span>,</span> <kbd>handle</kbd><span>,</span> <kbd>handleOverlap</kbd><span>,</span> <kbd>incrementControl</kbd><span>,</span> <kbd>minimumHandleLength</kbd><span>,</span> <kbd>scrollBarBackground</kbd><span>,</span> <kbd>scrollToClickedPosition</kbd><span>, and</span> <kbd>transientScrollBars</kbd> <span>properties are available</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SplitView</h1>
                </header>
            
            <article>
                
<p>This is a QML type for a draggable splitter for horizontal or vertical layouts. This type has the following properties:</p>
<p><kbd>handleDelegate</kbd><strong>:</strong> This component is the delegate between each child item. It has properties such as <kbd>styleData.index</kbd>, <kbd>styleData.hovered</kbd>, <kbd>styleData.pressed</kbd>, and <kbd>styleData.resizing</kbd>.</p>
<p><kbd>orientation</kbd><strong>:</strong><span> This is an integer that can have a </span><kbd>Qt.Horizontal</kbd> <span>(the default) or</span> <kbd>Qt.Vertical</kbd> <span>orientation of the scroll view.</span></p>
<p><kbd>resizing</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. It will return</span> <kbd>true</kbd> <span>if an item of the scroll view is resized by dragging the splitter handles onto it.</span></p>
<p>It has the following methods:</p>
<p><kbd>addItem(Item item)</kbd>: This adds items to the end of the scroll view.</p>
<p><kbd>removeItem(Item item)</kbd><span>: This removes items from the scroll view.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">StackView</h1>
                </header>
            
            <article>
                
<p>This type constructs a stack-based navigation model. It has the following properties:</p>
<p><kbd>busy</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. It will return <kbd>true</kbd> if the transition is running.</p>
<p><kbd>currentItem</kbd><strong>:</strong><span> This gets the top-most item in the stack.</span></p>
<p><kbd>delegate</kbd><strong>:</strong><span> T</span>he <kbd>StackViewDelegate</kbd> is a transition that will be used for pushing and popping items with this stack view.</p>
<p><kbd>depth</kbd><strong>:</strong><span> This is an integer of the number of items in the stack.</span></p>
<p><kbd>initialItem</kbd><strong>:</strong><span> This is the first item that will be shown in the stack.</span></p>
<p>It has the following methods:</p>
<p><kbd>clear()</kbd>: This removes all the items from the stack.</p>
<p><kbd>completeTransition()</kbd><span>: This immediately completes the running transition.</span></p>
<p><kbd>find(function, bool onlySearchLoadedItems=false)</kbd><span>: This finds the item inside this stack.</span></p>
<p class="mce-root"/>
<p><kbd>get(int index, bool dontLoad=false)</kbd><span>: This returns the item of the stack that has the specified index.</span></p>
<p><kbd>pop(Item item=undefined)</kbd><span>: This pops items off the stack.</span></p>
<p><kbd>push(Item item)</kbd><span>: This pushes items to the stack.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TabView</h1>
                </header>
            
            <article>
                
<p>This type allows you to select one of the multiple stacked items and imply the tab-based navigation model. It has the following properties:</p>
<p><kbd>contentItem</kbd><strong>:</strong> This is the content item of the tab view.</p>
<p><kbd>count</kbd><strong>:</strong><span> This integer is the count of the current tab.</span></p>
<p><kbd>currentIndex</kbd><strong>:</strong><span> This integer is the index of the current tab.</span></p>
<p><kbd>frameVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd><span>, the tab frame around the content will be visible.</span></p>
<p><kbd>tabPosition</kbd><strong>:</strong><span> This integer is the position of the tab controls, such as</span> <kbd>Qt.TopEdge</kbd> (the default) <span>or</span> <kbd>Qt.BottomEdge</kbd><span>.</span></p>
<p><kbd>tabsVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd><span>, the tab bar will be visible.</span></p>
<p><kbd>style</kbd><strong>:</strong><span> This component provides styling for the tab view, such as the</span> <kbd>TabViewStyle</kbd> <span>type. This type provides the </span><kbd>control</kbd><span>,</span> <kbd>frame</kbd><span>,</span> <kbd>frameOverlap</kbd><span>,</span> <kbd>leftCorner</kbd><span>,</span> <kbd>rightCorner</kbd><span>,</span> <kbd>tab</kbd><span>,</span> <kbd>tabBar</kbd><span>,</span> <kbd>tabOverlap</kbd><span>,</span> <kbd>tabsAlignment</kbd>, <span>and</span> <kbd>tabsMovable</kbd> <span>properties.</span></p>
<p>It has the following methods:</p>
<p><kbd>addTab(string title, Component component)</kbd>: This adds a new tab.</p>
<p><kbd>getTab(int index)</kbd><span>: This returns the tab by its index.</span></p>
<p><kbd>insertTab(int index, string title, Component component)</kbd><span>: This inserts a new tab at the given</span> <span>index.</span></p>
<p><kbd>moveTab(int from, int to)</kbd><span>: This moves the tab from one index to another.</span></p>
<p><kbd>removeTab(int index)</kbd><span>: This removes and destroys the tab at the index provided.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TableView</h1>
                </header>
            
            <article>
                
<p>This type implements a table in the GUI application. In addition to the <kbd>ListView</kbd>, scroll bars, header sections, and styling <span>are available</span>. This type has the following properties:</p>
<p><kbd>columnCount</kbd><strong>:</strong> This integer is the number of columns in the table.</p>
<p><kbd>rowCount</kbd><span>: This integer is the number of rows in the table.</span></p>
<p><kbd>contentFooter</kbd><strong>:</strong><span> This component is the content of the footer of the table.</span></p>
<p><kbd>contentHeader</kbd><strong>:</strong><span> This component is the content of the header of the table.</span></p>
<p><kbd>currentRow</kbd><strong>:</strong><span> This integer is the current index of the row in the table.</span></p>
<p><kbd>alternatingRowColors</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd> <span>(the default), the colors of the rows will alternate.</span></p>
<p><kbd>backgroundVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd> <span>(the default), the background will be filled.</span></p>
<p><kbd>frameVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd> <span>(the default), it will render a frame around its content.</span></p>
<p><kbd>headerVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd> <span>(the default), the header will be visible.</span></p>
<p><kbd>headerDelegate</kbd><strong>:</strong><span> This component defines a delegate to draw a header.</span></p>
<p><kbd>itemDelegate</kbd><strong>:</strong><span> This component defines a delegate to draw a cell.</span></p>
<p><kbd>rowDelegate</kbd><strong>:</strong><span> This component defines a delegate to draw a row.</span></p>
<p><kbd>model</kbd><strong>:</strong><span> This is the model for the table.</span></p>
<p><kbd>section.property</kbd><strong>:</strong><span> This is a</span> <kbd>string</kbd> <span>for the name of the property and is the basis of each section.</span></p>
<p><kbd>section.criteria</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>is the criteria for forming each section, such as</span> <kbd>ViewSection.FullString</kbd> <span>(the default) or</span> <kbd>ViewSection.FirstCharacter</kbd><span>.</span></p>
<p><kbd>section.delegate</kbd><strong>:</strong><span> This component is the delegate component for each section.</span></p>
<p class="mce-root"/>
<p><kbd>section.labelPositioning</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>is the positioning of the labels for the sections, such as</span> <kbd>ViewSection.InlineLabels</kbd> <span>(the default),</span> <kbd>ViewSection.CurrentLabelAtStart</kbd><span>, and</span> <kbd>ViewSection.NextLabelAtEnd</kbd><span>.</span></p>
<p><kbd>sortIndicatorColumn</kbd><strong>:</strong><span> This integer is the index of the current sort column.</span></p>
<p><kbd>sortIndicatorOrder</kbd><strong>:</strong><span> This integer sets the sorting order of the indicator, such as</span> <kbd>Qt.AscendingOrder</kbd> <span>(the default) and</span> <kbd>Qt.DescendingOrder</kbd><span>.</span></p>
<p><kbd>sortIndicatorVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the sort indicator will be visible.</span></p>
<p><strong><kbd>selection</kbd>:</strong><span> This is the current row selection of the table.</span></p>
<p><kbd>selectionMode</kbd><strong>:</strong><span> This integer is the mode of the user selection, such as</span> <kbd>SelectionMode.NoSelection</kbd><span>,</span> <kbd>SelectionMode.SingleSelection</kbd> <span>(the default),</span> <kbd>SelectionMode.MultiSelection</kbd><span>,</span> <kbd>SelectionMode.ExtendedSelection</kbd><span>, and</span> <kbd>SelectionMode.ContiguousSelection</kbd><span>.</span></p>
<p><strong><kbd>style</kbd>:</strong><span> This component provides styling for the table, such as the </span><kbd>TableViewStyle</kbd> <span>type. This type provides the </span><kbd>activateItemOnSingleClick</kbd><span>,</span> <kbd>alternateBackgroundColor</kbd><span>,</span> <kbd>backgroundColor</kbd><span>,</span> <kbd>highlightedTextColor</kbd>, <span>and</span> <kbd>textColor</kbd> <span>properties.</span></p>
<p>It has the following signals:</p>
<p><kbd>activated(int row)</kbd>: This is emitted when an item is activated by the mouse or keyboard. The handler is <kbd>onActivated</kbd>.</p>
<p><kbd>clicked(int row)</kbd><span>: This is emitted when a row is clicked on. The handler is</span> <kbd>onClicked</kbd><span>.</span></p>
<p><kbd>doubleClicked(int row)</kbd><span>: This is emitted when a row is double-clicked. The handler is</span> <kbd>onDoubleClicked</kbd><span>.</span></p>
<p><kbd>pressAndHold(int row)</kbd><span>: This is emitted when a row is pressed and held. The handler is</span> <kbd>onPressAndHold</kbd><span>.</span></p>
<p>It has the following methods:</p>
<p><kbd>addColumn(object column)</kbd>: The column will be added.</p>
<p><kbd>getColumn(int index)</kbd><strong>:</strong><span> This returns the column at the specified index.</span></p>
<p class="mce-root"/>
<p><kbd>insertColumn(int index, object column)</kbd><span>: This inserts a column into the table.</span></p>
<p><kbd>moveColumn(int from, int to)</kbd><span>: This moves the column from the specified index to another index.</span></p>
<p><kbd>positionViewAtRow(int row, PositionMode mode)</kbd><span>: This is the position of the view in the specified row defined by the mode, such as</span> <kbd>ListView.Beginning</kbd><span>,</span> <kbd>ListView.Center</kbd><span>,</span> <kbd>ListView.End</kbd><span>,</span> <kbd>ListView.Visible</kbd><span>, or </span><kbd>ListView.Contain</kbd>.</p>
<p><kbd>removeColumn(int index)</kbd><span>: This removes and destroys the column in the table by the index.</span></p>
<p><kbd>resizeColumnsToContents()</kbd><span>: This resizes the column according to the content.</span></p>
<p><kbd>rowAt(int x, int y)</kbd><span>: This returns the index of the row by its</span> <kbd>x</kbd><span> and </span><kbd>y</kbd> <span>coordinates.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional tools</h1>
                </header>
            
            <article>
                
<p>In the <kbd>QtQuick.Controls</kbd> module, useful types are available that can be implemented in GUI applications. All of these types require the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick.Controls 1.4</pre>
<p>Let's go through all of these types in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calendar</h1>
                </header>
            
            <article>
                
<p>This type provides the calendar widget, and has the following properties:</p>
<p><kbd>dayOfWeekFormat</kbd><strong>:</strong> This integer is the format for when the days of the week are displayed.</p>
<p><kbd>frameVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the frame surrounding the calendar will be visible.</span></p>
<p><kbd>minimumDate</kbd><strong>:</strong><span> This is the earliest date that the calendar will accept.</span></p>
<p><kbd>maximumDate</kbd><strong>:</strong><span> This is the latest date that the calendar will accept.</span></p>
<p><kbd>navigationBarVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the navigation bar will be visible.</span></p>
<p class="mce-root"/>
<p><kbd>selectedDate</kbd><strong>:</strong><span> This is</span> the date that was selected by the user.</p>
<p><kbd>visibleMonth</kbd><strong>:</strong><span> This integer is the month from</span> <kbd>0</kbd> <span>to</span> <kbd>11</kbd> <span>that will be shown on the calendar.</span></p>
<p><kbd>visibleYear</kbd><strong>:</strong><span> This integer is the year that will be shown.</span></p>
<p><kbd>weekNumbersVisible</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the</span> <span>week </span><span>numbers will be visible (the default is</span> <kbd>false</kbd><span>).</span></p>
<p><strong><kbd>style</kbd>:</strong><span> This component provides styling of the calendar with the</span> <kbd>CalendarStyle</kbd> <span>type. With the </span><kbd>CalendarStyle</kbd> <span>type, the</span> <kbd>background</kbd><span>,</span> <kbd>control</kbd><span>,</span> <kbd>dayDelegate</kbd><span>,</span> <kbd>dayOfWeekDelegate</kbd><span>,</span> <kbd>gridColor</kbd><span>,</span> <kbd>gridVisible</kbd><span>,</span> <kbd>navigationBar</kbd>, <span>and</span> <kbd>weekNumberDelegate</kbd> <span>properties are available.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ProgressBar</h1>
                </header>
            
            <article>
                
<p>This provides a visualized element showing the progress of an operation in the GUI. It has the following properties:</p>
<p><kbd>value</kbd><strong>:</strong> This is the current value of the progress bar.</p>
<p><kbd>minimumValue</kbd><strong>:</strong><span> This is the minimum value of the progress.</span></p>
<p><kbd>maximumValue</kbd><strong>:</strong><span> This is the maximum value of the progress.</span></p>
<p><kbd>indeterminate</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the progress will be animated as busy (the default is</span> <kbd>false</kbd><span>).</span></p>
<p><kbd>orientation</kbd><strong>:</strong><span> This integer is the horizontal or vertical orientation of the progress bar (the default is</span> <kbd>Qt.Horizontal</kbd><span>).</span></p>
<p><kbd>hovered</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, this </span>progress bar is being hovered over.</p>
<p><kbd>style</kbd><strong>:</strong><span> This component provides styles for the progress bar with the</span> <kbd>ProgressBarStyle</kbd> <span>type. This type has the </span><kbd>background</kbd><span>,</span> <kbd>control</kbd><span>,</span> <kbd>currentProgress</kbd><span>,</span> <kbd>panel</kbd><span>, and</span> <kbd>progress</kbd> <span>properties.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Switch</h1>
                </header>
            
            <article>
                
<p>This type implements a toggle button, which can be switched or have a checked or unchecked state. Its properties are as follows:</p>
<p><kbd>checked</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. It is <kbd>true</kbd> if the toggle button is checked.</p>
<p><kbd>pressed</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. It is</span> <kbd>true</kbd> <span>if the toggle button is pressed.</span></p>
<p><kbd>activeFocusOnPress</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the switch will be focused when pressed.</span></p>
<p><kbd>exclusiveGroup</kbd><strong>:</strong><span> This is the group that the toggle button will belong to.</span></p>
<p><kbd>style</kbd><strong>:</strong><span> This component provides styling for this button with the </span><kbd>SwitchStyle</kbd> <span>type. In this type, the </span><kbd>groove</kbd> <span>and</span> <kbd>handle</kbd> <span>properties</span> <span>are available. <kbd>groove</kbd></span><span> can implement an item, such as a rectangle.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Slider</h1>
                </header>
            
            <article>
                
<p>This is used to provide a sliding handle that can be moved horizontally or vertically. The properties are as follows:</p>
<p><kbd>value</kbd><strong>:</strong> This is the current value of the slider (the default is <kbd>0.0</kbd>).</p>
<p><kbd>minimumValue</kbd><strong>:</strong><span> This is the minimum value of the slider (the default is</span> <kbd>0.0</kbd><span>).</span></p>
<p><kbd>maximumValue</kbd><strong>:</strong><span> This is the maximum value of the slider (the default is</span> <kbd>1.0</kbd><span>).</span></p>
<p><kbd>stepSize</kbd><strong>:</strong><span> This is the slider step size. The default value,</span> <kbd>0.0</kbd><span>, indicates a continuous range.</span></p>
<p><kbd>tickmarksEnabled</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd><span>, the slider will display tickmarks.</span></p>
<p><kbd>updateValueWhileDragging</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If it's</span> <kbd>true</kbd><span>, the current value will be updated by moving the slider handle. Otherwise, it will be updated when it has been released.</span></p>
<p><kbd>orientation</kbd><strong>:</strong><span> This integer is the horizontal or vertical orientation of the slider (the default is</span> <kbd>Qt.Horizontal</kbd><span>)</span></p>
<p><kbd>hovered</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, this slider handle is being hovered over.</span></p>
<p class="mce-root"/>
<p><kbd>pressed</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. It returns</span> <kbd>true</kbd> <span>if the slider handle is pressed.</span></p>
<p><kbd>activeFocusOnPress</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the slider will be focused when pressed.</span></p>
<p><kbd>style</kbd><strong>:</strong><span> This component styles the slider with the</span> <kbd>SliderStyle</kbd> <span>type. In this type, the</span> <kbd>control</kbd><span>,</span> <kbd>groove</kbd><span>,</span> <kbd>handle</kbd><span>,</span> <kbd>panel</kbd><span>, and</span> <kbd>tickmarks</kbd> <span>properties are available.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SpinBox</h1>
                </header>
            
            <article>
                
<p>This type allows the user to choose a value by clicking the up and down buttons or by typing in a value. The properties of this type are as follows:</p>
<p><kbd>value</kbd><strong>:</strong> This is the current value of the spin box (the default is <kbd>0.0</kbd>).</p>
<p><kbd>minimumValue</kbd><strong>:</strong><span> This is the minimum value of the range in the spin box (the default is</span> <kbd>0.0</kbd><span>).</span></p>
<p><kbd>maximumValue</kbd><strong>:</strong><span> This is the maximum value of the range in the spin box (the default is</span> <kbd>1.0</kbd><span>).</span></p>
<p><kbd>stepSize</kbd><strong>:</strong><span> This is the step that will be incremented or decremented when the up/down button is pressed.</span></p>
<p><kbd>prefix</kbd><strong>:</strong><span> This is a <kbd>string</kbd> that adds a prefix for this value, such as</span> <kbd>$</kbd><span>.</span></p>
<p><kbd>suffix</kbd><strong>:</strong><span> This is a <kbd>string</kbd> that adds a suffix for this value, such as</span> <kbd>ms</kbd><span>.</span></p>
<p><kbd>decimals</kbd><strong>:</strong><span> This integer is the number of decimals of the spin box (the default is</span> <kbd>0</kbd><span>).</span></p>
<p><kbd>inputMethodComposing</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. The spin box has partial text input from an input method.</span></p>
<p><kbd>cursorPosition</kbd><strong>:</strong><span> This is the integer position of the cursor in the spin box.</span></p>
<p><kbd>selectByMouse</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. The values of the spin box can be selected by the mouse (the default is</span> <kbd>true</kbd><span>).</span></p>
<p><kbd>hovered</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and is</span> <kbd>true</kbd> <span>if the spin box is being hovered over.</span></p>
<p><kbd>horizontalAlignment</kbd><strong>:</strong><span> This integer value will align the box with a</span> <kbd>Qt.AlignLeft</kbd><span>,</span> <kbd>Qt.AlignHCenter</kbd><span>, or</span> <kbd>Qt.AlignRight</kbd> <span>alignment.</span></p>
<p><kbd>font</kbd><strong>:</strong><span> This sets the font for the spin box values.</span></p>
<p><kbd>activeFocusOnPress</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>, and if</span> <kbd>true</kbd><span>, the spin box will be focused when pressed.</span></p>
<p><kbd>menu</kbd><strong>:</strong><span> This component sets the menu for working with text selection with the menu type.</span></p>
<p><strong><kbd>style</kbd>:</strong><span> This component provides spin box styling with the</span> <kbd>SpinBoxStyle</kbd> <span>type. This type has the </span><kbd>background,</kbd> <kbd>control</kbd><span>,</span> <kbd>decrementControl</kbd><span>,</span> <kbd>incrementControl</kbd><span>,</span> <kbd>horizontalAlignment</kbd><span>,</span> <kbd>font</kbd><span>,</span> <kbd>renderType</kbd><span>,</span> <kbd>selectedTextColor</kbd><span>,</span> <kbd>selectionColor</kbd><span>, and</span> <kbd>textColor</kbd> <span>properties.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BusyIndicator</h1>
                </header>
            
            <article>
                
<p>This type provides an indication of the progress of an operation, such as loading, downloading, and installing. It's used to inform the user about operation progress with a graphical element. This type has two properties:</p>
<p><kbd>running</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd>. The element will indicate that an activity is taking place (the default is <kbd>true</kbd>).</p>
<p><kbd>style</kbd><strong>:</strong><span> This component provides styling for this indicator with the</span> <kbd>BusyIndicatorStyle</kbd> <span>type by using the </span><kbd>control</kbd> <span>and</span> <kbd>indicator</kbd> <span>properties.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controls implementation</h1>
                </header>
            
            <article>
                
<p>Let's implement some of the controls we described in this chapter in our application. Create a file called <kbd>USplit.qml</kbd><strong> </strong>in the <kbd>qmls/</kbd> directory and write the following lines:</p>
<ol>
<li>Add <kbd>SplitView</kbd> to the parent <kbd>Item</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Layouts 1.3<br/>import QtQuick.Controls 1.4<br/><br/>Item {<br/>    SplitView {<br/>        anchors.fill: parent;<br/>        orientation: Qt.Vertical;<br/>        resizing: true<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This realizes the split view of the buttons for the text and table windows.</p>
<ol start="2">
<li>Add the first rectangle as a <kbd>SplitView</kbd> element:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        Rectangle {<br/>            id: scr1; color: "#111F1F"<br/>            Layout.minimumHeight: parent.height / 2 <br/>            Text {<br/>                id: tx1; anchors.centerIn: parent<br/>                text: "Texts"; color: "grey"<br/>                font: {<br/>                    font.pixelSize=scr1.width / 8;<br/>                    font.letterSpacing=5;<br/>                    font.weight=Font.ExtraBold;<br/>                }<br/>            }<br/>            MouseArea {<br/>                id: ma1; anchors.fill: parent;<br/>                hoverEnabled: true<br/>                onEntered: scr1.color = "lightgrey";<br/>                onExited: scr1.color = "#111F1F";<br/>                onClicked: {<br/>                    txs1.visible = true;<br/>                    grid1.visible = false;<br/>                    main_item = false;<br/>                    tb1.visible = true;<br/>                }<br/>            }<br/>        }<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">If this rectangle is clicked on, a window with various text fields will be displayed.</p>
<ol start="3">
<li>Add the second rectangle to the <kbd>USplit.qml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        Rectangle {<br/>            id: scr2; color: "#111F1F"<br/>            Layout.fillHeight: true<br/>            Text {<br/>                id: tx2; anchors.centerIn: parent<br/>                text: "Table"; color: "grey"<br/>                font: {<br/>                    font.pixelSize=scr1.width / 8;<br/>                    font.letterSpacing=5;<br/>                    font.weight=Font.ExtraBold;<br/>                }<br/>            }<br/>            MouseArea {<br/>                id: ma2; anchors.fill: parent<br/>                hoverEnabled: true<br/>                onEntered: scr2.color = "lightgrey";<br/>                onExited: scr2.color = "#111F1F";<br/>                onClicked: {<br/>                    tb1.visible = true;<br/>                    grid1.visible = false;<br/>                    main_item = false;<br/>                    txs1.visible = false;<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px"><span>If the second rectangle is clicked on, the window with a table will be displayed in the application. We can see a similar result by running the application. The s</span>plit view <span>with the </span><kbd>Texts</kbd> <span>and</span> <kbd>Table</kbd> <span>options is displayed in the bottom-right corner of the application window:</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/db3fda66-66fe-4525-b89d-8081ce497737.png" style="width:40.25em;height:20.42em;"/></p>
<p>Now, let's create a <kbd>UTexts.qml</kbd> file in the <kbd>qmls/</kbd> directory to demonstrate the text fields and additional components:</p>
<ol start="1">
<li>Add the <kbd>GridLayout</kbd> to the <kbd>UTexts.qml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Layouts 1.3<br/>import QtQuick.Controls 1.4<br/>import QtQuick.Controls.Styles 1.4<br/>import QtQuick.Dialogs 1.2<br/><br/>GridLayout {<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Dialogs are used to implement the font and color dialog windows in the application. The elements will be arranged with the grid layout positioning mechanism.</p>
<ol start="2">
<li>Add the <kbd>TextArea</kbd> to the <kbd>GridLayout</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ... <br/>    TextArea {<br/>        id: ta1; Layout.column: 0<br/>        Layout.rowSpan: 5; Layout.columnSpan: 3<br/>        Layout.fillWidth: true; Layout.fillHeight: true<br/>        Layout.minimumWidth: parent.width / 2<br/>        font.pixelSize: sl1.value<br/>        textColor: "lightgrey"; textMargin: 10<br/>    }<br/>...</pre>
<p style="padding-left: 60px">This sets the properties for the text area, such as <kbd>font.pixelSize</kbd>, <kbd>textColor</kbd>, and <kbd>textMargin</kbd>. </p>
<ol start="3">
<li>Add the <kbd>Calendar</kbd> after the <kbd>TextArea</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Calendar {<br/>        id: cd1; Layout.row: 0<br/>        Layout.column: 3<br/>        Layout.columnSpan: 2<br/>        Layout.fillWidth: true<br/>        Layout.fillHeight: true<br/>    }<br/>...</pre>
<p style="padding-left: 60px">The calendar will be displayed in the top-right corner of the application window.</p>
<ol start="4">
<li>Then, add the <kbd>Slider</kbd> component:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Slider {<br/>        id: sl1<br/>        Layout.row: 1<br/>        Layout.column: 3<br/>        Layout.fillWidth: true<br/>        Layout.fillHeight: true<br/>        Layout.maximumHeight: parent.height / 24<br/>        updateValueWhileDragging: true<br/>        minimumValue: 0<br/>        maximumValue: 100<br/>        value: 19<br/>    }<br/>...</pre>
<p style="padding-left: 60px">The <kbd>Slider</kbd> will increase or decrease the size of the text area.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li>Add the <span><kbd>ComboBox</kbd> after the</span> <kbd>Slider</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    ComboBox {<br/>        id: cb1<br/>        Layout.row: 1<br/>        Layout.column: 4 <br/>        Layout.fillWidth: true<br/>        Layout.fillHeight: true<br/>        Layout.maximumHeight: parent.height / 24<br/>        model: ["Dialogs", "Change Font", "Change Color"]<br/>        currentIndex: 0<br/>        onCurrentIndexChanged: {<br/>            if (currentText=="Change Font") {<br/>                fontd1.open(); cb1.currentIndex = 0;};<br/>            if (currentText=="Change Color") {<br/>                colord1.open(); cb1.currentIndex = 0;};<br/>            }<br/>        FontDialog {<br/>            id: fontd1<br/>            onAccepted: {<br/>                ta1.font = fontd1.currentFont;<br/>                fontd1.visible = false;<br/>            }<br/>            onRejected: fontd1.visible = false;<br/>        }<br/>        ColorDialog {<br/>            id: colord1<br/>            onAccepted: {<br/>                ta1.textColor = colord1.currentColor<br/>                colord1.visible = false<br/>            }<br/>            onRejected: colord1.visible = false;<br/>        }<br/>    }<br/>...</pre>
<p style="padding-left: 60px">This combobox allows the static dialog windows to change the color and font in the text area.</p>
<ol start="6">
<li>Then, add the radio buttons:</li>
</ol>
<pre>...<br/>    ...<br/>    ExclusiveGroup { id: exgr }<br/>    GridLayout {<br/>        columns: 1<br/>        Layout.row: 2<br/>        Layout.column: 3<br/>        Layout.rowSpan: 2<br/>        Repeater {<br/>            id: rbrep1; model: ["1 line of the text",<br/>                                "1000 lines of the text"]<br/>            RadioButton { <br/>                exclusiveGroup: exgr<br/>                Layout.fillWidth: true<br/>                Layout.fillHeight: true<br/>                style: RadioButtonStyle {<br/>                    background: Rectangle {<br/>                        color: "#000F1F"<br/>                    }<br/>                    label: Text {<br/>                        text: modelData<br/>                        color: "lightgray"<br/>                        font.pixelSize: 14<br/>                        font.letterSpacing: 2 <br/>                    }<br/>                }<br/>            }<br/>            Component.onCompleted: {<br/>                rbrep1.itemAt(0).checked = true;<br/>            }<br/>        }<br/>    }<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">The <kbd>ExclusiveGroup</kbd> type groups these radio buttons with the possibility to make only one choice.</p>
<ol start="7">
<li>Add the check boxes to the application, arranged with the <kbd>GridLayout</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    GridLayout {<br/>        columns: 1<br/>        Layout.row: 2<br/>        Layout.column: 4<br/>        Layout.rowSpan: 2<br/>        Repeater {<br/>            id: rbrep2; model: ["Month number",<br/>                                "Milliseconds",<br/>                                    "Scidate"]<br/>            CheckBox {<br/>                Layout.fillWidth: true<br/>                Layout.fillHeight: true<br/>                style: CheckBoxStyle {<br/>                    background: Rectangle {<br/>                        color: "#000F1F"<br/>                    }<br/>                    label: Text {<br/>                        text: modelData<br/>                        color: "lightgray"<br/>                        font.pixelSize: 14<br/>                        font.letterSpacing: 2<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>...</pre>
<p style="padding-left: 60px">These checkboxes allow the selection of various date implementations in the text area field. <span>One option, or all options together, can be selected</span>.</p>
<ol start="8">
<li>Then, add the single-line <kbd>TextField</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    TextField {<br/>        id: tf1<br/>        Layout.row: 4<br/>        Layout.column: 3<br/>        Layout.fillWidth: true<br/>        Layout.fillHeight: true<br/>        Layout.maximumHeight: rx1.height<br/>        horizontalAlignment: TextInput.AlignHCenter<br/>        font.pixelSize: rx1.height / 2<br/>        style: TextFieldStyle {<br/>            background: Rectangle {radius: 7}<br/>        }<br/>    }<br/>...</pre>
<p style="padding-left: 60px">In this text field, <span>the total number of characters in the text area </span>will be displayed.</p>
<ol start="9">
<li>Add the <kbd>Rectangle</kbd> item that will represent the main button in this window:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Rectangle {<br/>        id: rx1; Layout.row: 4<br/>        Layout.column: 4<br/>        Layout.fillWidth: true<br/>        Layout.fillHeight: true<br/>        Layout.maximumHeight: cb1.height * 2<br/>        radius: 14; color: Qt.rgba(0.2, 0.2, 0.2, 1);<br/>        Text {<br/>            id: rtxt1<br/>            anchors.centerIn: parent<br/>            visible: true<br/>            text: "Ok"; color: "green"<br/>            font.pixelSize: parent.width / 8<br/>        }<br/>        BusyIndicator {<br/>            id: bi1<br/>            anchors.centerIn: parent<br/>            running: false<br/>        }<br/>        Timer {<br/>            id: t1; interval: 300<br/>            running: false<br/>            repeat: false<br/>            onTriggered: rx1.txdate();<br/>        }<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This custom rectangle uses the <kbd>Text</kbd> type for the text on this button; the <kbd>BusyIndicator</kbd>, which will indicate that a process is in progress; and <kbd>Timer</kbd>, which sets the <kbd>interval</kbd>.</p>
<ol start="10">
<li>Now we need to add <span>a JavaScript function </span>to this <kbd>Rectangle</kbd> item:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        function txdate() {<br/>            var sd = cd1.selectedDate;<br/>            var dateform = sd;<br/>            if (rbrep2.itemAt(0).checked==true) {<br/>                dateform = dateform + ",<br/>                        month-" + (cd1.visibleMonth + 1);<br/>            } else {dateform = dateform};<br/>            if (rbrep2.itemAt(1).checked==true) {<br/>                dateform = dateform + ",<br/>                        milliseconds: " + Date.parse(sd)<br/>            } else {dateform = dateform};<br/>            if (rbrep2.itemAt(2).checked==true) {<br/>                var sdy = sd.getFullYear().toString();<br/>                var sdmi = sd.getMonth() + 1;<br/>                var sdm = sdmi.toString();<br/>                var sdd = sd.getDate().toString();<br/>                var sdh = sd.getHours().toString();<br/>                var sdmt = sd.getMinutes().toString();<br/>                var sds = sd.getSeconds().toString();<br/>                var scid = sdy + sdm + sdd + sdh + sdmt + sds;<br/>                dateform = dateform + ", scidate: " + scid;<br/>            } else {dateform = dateform};<br/>            if (rbrep1.itemAt(0).checked==true) {<br/>                ta1.text = dateform; tf1.text = ta1.length;<br/>                bi1.running = false; rtxt1.text = "Ok"<br/>            };<br/>            if (rbrep1.itemAt(1).checked==true) {<br/>                for (var i = 0; i&lt;1000; i++) { <br/>                    ta1.append(dateform);<br/>                    if (i==999) {<br/>                        tf1.text = ta1.length; bi1.running = false; <br/>                        rtxt1.text = "Ok";<br/>                    };<br/>                }<br/>            };<br/>        }<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This JavaScript function will manipulate the data and set the result to the text area.</p>
<ol start="11">
<li>Finally, add the <kbd>MouseArea</kbd> type to this rectangle:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        MouseArea {<br/>            anchors.fill: parent;<br/>            hoverEnabled: true<br/>            onEntered: {<br/>                rx1.color = Qt.rgba(0.25, 0.25, 0.25, 1);<br/>                rtxt1.color = "lightgreen";<br/>            }<br/>            onExited: {rx1.color = Qt.rgba(0.2, 0.2, 0.2, 1);<br/>                rtxt1.color = "green";}<br/>            onClicked: {<br/>                rtxt1.text = "";<br/>                bi1.running = true;<br/>                t1.running = true;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root" style="padding-left: 60px">This mouse area will be used with the rectangle to realize the click and hover effects. Now we can start the application. To do this, choose the <kbd>Texts</kbd> option in the bottom-<span>right</span> corner, and see a result similar to this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2a6026a3-2779-4a34-b97c-d5d982320ed8.png"/></p>
<p>Now we can create a <kbd>UTable.qml</kbd> file in the same directory so that we can implement a simple table in the GUI application:</p>
<ol>
<li>Add a table view to the <kbd>UTable.qml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Controls 1.4<br/>import QtQuick.Controls.Styles 1.4<br/>import QtQuick.Layouts 1.3<br/><br/>GridLayout {<br/>    TableView {<br/>        Layout.fillWidth: true<br/>        Layout.fillHeight: true<br/>        Layout.margins: 50<br/>        TableViewColumn {<br/>            horizontalAlignment: Text.AlignHCenter <br/>            role: "num1"; title: "Title 1"<br/>        }<br/>        TableViewColumn {<br/>            horizontalAlignment: Text.AlignHCenter<br/>            role: "num2"; title: "Title 2" <br/>        }<br/>        TableViewColumn {<br/>            horizontalAlignment: Text.AlignHCenter<br/>            role: "num3"; title: "Title 3"<br/>        }<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The <kbd>TableView</kbd> QML type creates a table in the application. The <kbd>TableViewColumn</kbd> types are used for columns in this table and have title and role properties.</p>
<ol start="2">
<li>Add the <span><kbd>style</kbd> and <kbd>model</kbd> properties </span>to the table:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        style: TableViewStyle {<br/>            textColor: "red"<br/>        }<br/>        model: ListModel {<br/>            id: lm1<br/>            ListElement {<br/>                num1: "1_1"; num2: "1_2"; num3: "1_3"<br/>            }<br/>            ListElement {<br/>                num1: "2_1"; num2: "2_2"; num3: "2_3"<br/>            }<br/>            ListElement {<br/>                num1: "3_1"; num2: "3_2"; num3: "3_3"<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root" style="padding-left: 60px">The data in this table is realized with the <kbd>model</kbd> property of the <kbd>TableView</kbd> type. The <kbd>ListModel</kbd> type contains the <kbd>ListElement</kbd> types with specified data for titles related to each cell. The table looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cf808d1a-1fda-4961-bbba-ced50c8fca07.png" style="width:40.92em;height:6.00em;"/></p>
<p class="mce-root"><span>We have three columns with</span> data <span>for each cell of the table. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Layouts</h1>
                </header>
            
            <article>
                
<p>If we run the application and try to resize the window with controls such as a fullscreen button or with the mouse, we will get some unresizable views. This may be because of unresizable items, or because the positions of some of the items will not fit the application. One of the causes of this is that <span>the items and elements have </span>a fixed position and size. The <kbd>Layouts</kbd> submodule of <kbd>QtQuick</kbd> tries to solve these problems. This submodule is used to arrange items in a UI. Also, <kbd>Layouts</kbd> QML types resize their items, which makes them well-suited to application views. With the help of the <kbd>Layouts</kbd> submodule, all the items will be rearranged in relation to window resizing. At the end of this chapter, we will describe how to arrange GUI items with the layouts representation. The Qt Quick <kbd>Layouts</kbd> submodule has the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick.Layouts 1.3</pre>
<p>Let's go through the types that can be used to provide layout arrangement for items.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>The basic QML type for the grid/row/column layouts has the following properties that can be used in layout construction:</p>
<p><kbd>column</kbd><strong>:</strong> This is an integer that specifies the column position of the item in the layout.</p>
<p><kbd>row</kbd><strong>:</strong><span> This is an integer that specifies the row position of the item in the layout.</span></p>
<p class="mce-root"/>
<p><kbd>columnSpan</kbd><strong>:</strong><span> This integer is the number of columns occupied by the item.</span></p>
<p><kbd>rowSpan</kbd><strong>:</strong><span> This integer is the number of rows occupied by the item.</span></p>
<p><kbd>fillWidth</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the item will have the full width of the occupied cell in the layout.</span></p>
<p><kbd>fillHeight</kbd><strong>:</strong><span> This can be</span> <kbd>true</kbd> <span>or</span> <kbd>false</kbd><span>. If</span> <kbd>true</kbd><span>, the item will have the full available height of the cell in the layout.</span></p>
<p><kbd>maximumWidth</kbd><strong>:</strong><span> This sets the maximum available width for an item in the cell of the layout.</span></p>
<p><kbd>maximumHeight</kbd><strong>:</strong><span> This sets the maximum available height for an item.</span></p>
<p><kbd>minimumWidth</kbd><strong>:</strong><span> This sets the minimum available width for an item in the cell of the layout.</span></p>
<p><kbd>minimumHeight</kbd><strong>:</strong><span> This sets the minimum available height for an item.</span></p>
<p><kbd>preferredWidth</kbd><strong>:</strong><span> This is the preferred width of an item in a layout. By default, it is set to</span> <kbd>-1</kbd> <span>or to the</span> <kbd>implicitWidth</kbd> <span>of an item. It is related to some items that have a natural size, such as images and text.</span></p>
<p><kbd>preferredHeight</kbd><strong>:</strong><span> This is the preferred width of an item in a layout (the default is</span> <kbd>-1</kbd><span>).</span></p>
<p><kbd>margins</kbd><strong>:</strong><span> This sets the</span> <span>margins on </span><span>all sides outside the item in the layout.</span></p>
<p><kbd>topMargin</kbd><strong>:</strong><span> This sets the top margin outside of the item.</span></p>
<p><kbd>leftMargin</kbd><strong>:</strong><span> This sets the left margin outside of the item.</span></p>
<p><kbd>bottomMargin</kbd><strong>:</strong><span> This is the bottom margin outside of the item in the layout.</span></p>
<p><kbd>rightMargin</kbd><strong>:</strong><span> This is the right margin outside of the item.</span></p>
<p><kbd>alignment</kbd><strong>:</strong><span> The alignment of the item inside the layout cell.</span></p>
<p>These properties are used inside the item declaration with the following example syntax: <kbd>Layout.fillWidth: true</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ColumnLayout</h1>
                </header>
            
            <article>
                
<p>This type arranges items by columns. It has two properties:</p>
<p><kbd>layoutDirection</kbd><strong>:</strong> This <kbd>enumeration</kbd> is the direction of the items in the layout (the default is <kbd>Qt.LeftToRight</kbd>). <kbd>Qt.RightToLeft</kbd> can be used as well.</p>
<p><kbd>spacing</kbd><strong>:</strong><span> This is the spacing between each cell in the column (the default is</span> <kbd>5</kbd><span>).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RowLayout</h1>
                </header>
            
            <article>
                
<p>This QML type will arrange the items in the layout by rows. It has two properties:</p>
<p><kbd>layoutDirection</kbd><strong>:</strong> This <kbd>enumeration</kbd> is the direction of the items in the layout (the default is <kbd>Qt.LeftToRight</kbd>). <kbd>Qt.RightToLeft</kbd> can be used as well.</p>
<p><kbd>spacing</kbd><strong>:</strong><span> This is the spacing between each cell in the row (the default is</span> <kbd>5</kbd><span>).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GridLayout</h1>
                </header>
            
            <article>
                
<p>This is the most highly recommended type of layout implementation. It arranges items in the grid by the row/column position of the element. This type has the following properties. Note that these properties are not attached, and can be used just inside the <kbd>GridLayout</kbd> declaration (not inside the item of the layout):</p>
<p><kbd>columns</kbd><strong>:</strong> This integer is the column limit. It specifies the number of columns that will be used for the item's position in the layout.</p>
<p><kbd>rows</kbd><strong>:</strong><span> This integer is the row limit for positioned items.</span></p>
<p><kbd>columnSpacing</kbd><strong>:</strong><span> This is the spacing between each column in the layout.</span></p>
<p><kbd>rowSpacing</kbd><strong>:</strong><span> This is the spacing between each row.</span></p>
<p><kbd>flow</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>is the flow direction of items that do not have an explicit position in the layout. The default is</span> <kbd>GridLayout.LeftToRight</kbd><span>.</span> <kbd>GridLayout.TopToBottom</kbd> <span>can also be used.</span></p>
<p><kbd>layoutDirection</kbd><strong>:</strong><span> This</span> <kbd>enumeration</kbd> <span>is the direction of the items in the layout. The default is</span> <kbd>Qt.LeftToRight</kbd><span>.</span> <kbd>Qt.RightToLeft</kbd> <span>can also be used.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Completing layouts</h1>
                </header>
            
            <article>
                
<p>In order to demonstrate the layout construction advantages as opposed to using fixed positioning, let's rebuild the <kbd>u_qml.qml</kbd> file, which consists of the fixed size of elements, with an implementation of the <kbd>GridLayout</kbd>:</p>
<ol>
<li>Add the <kbd>GridLayout</kbd> to the <kbd>u_qml.qml</kbd><strong> </strong>file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import QtQuick.Layouts 1.3<br/>...<br/><br/>UQml.Window {<br/>    ...<br/>    GridLayout {<br/>        id: main_grid1<br/>        columns: 1<br/>        rows: 1<br/>        anchors.fill: parent<br/>        Uqmls.URect {<br/>            Layout.column: 0; Layout.row: 0<br/>            Layout.fillWidth: true<br/>            Layout.fillHeight: true<br/>            Layout.minimumHeight: w1.height<br/>            id: rect1<br/>            ...<br/>        }<br/>    }<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">This is the <kbd>GridLayout</kbd> for the arrangement of <kbd>rect1</kbd> in the application.</p>
<ol start="2">
<li>After the first <kbd>GridLayout</kbd>, add the second <kbd>GridLayout</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    GridLayout {<br/>        id: main_grid2<br/>        columns: 1<br/>        rows: 1<br/>        anchors.fill: parent<br/>        Uqmls.URect {<br/>            Layout.column: 0; Layout.row: 0<br/>            Layout.fillWidth: true<br/>            Layout.fillHeight: true<br/>            Layout.alignment: Qt.AlignRight<br/>            Layout.maximumWidth: w1.width / 5<br/>            id: rect2<br/>            visible: false<br/>            color: "#000F1D"<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px"><span>This is the <kbd>GridLayout</kbd> for the arrangement of <kbd>rect2</kbd> in the application.</span></p>
<ol start="3">
<li>Add the <kbd>GridLayout</kbd> for the buttons of the second rectangle:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>            ...<br/>            GridLayout {<br/>                id: but_grid<br/>                columns: 1<br/>                rows: 4<br/>                anchors.fill: parent                       <br/>                Uqmls.UButton {<br/>                    id: ubut1<br/>                    Layout.column: 0<br/>                    Layout.row: 0<br/>                    Layout.maximumHeight: w1.height / 5<br/>                    Layout.fillWidth: true<br/>                    Layout.fillHeight: true<br/>                    ...<br/>                }<br/>                Uqmls.UButton {<br/>                    id: ubut2<br/>                    Layout.column: 0<br/>                    Layout.row: 1<br/>                    Layout.maximumHeight: w1.height / 5<br/>                    Layout.fillWidth: true<br/>                    Layout.fillHeight: true<br/>                    ...<br/>                }<br/>                Uqmls.UButton {<br/>                    id: ubut3<br/>                    Layout.column: 0<br/>                    Layout.row: 2<br/>                    Layout.fillWidth: true<br/>                    Layout.fillHeight: true<br/>                    Layout.maximumHeight: w1.height / 5<br/>                    ...<br/>                }<br/>                ...<br/>            ...<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The buttons of the right panel will be arranged with <kbd>GridLayout</kbd> positioning.</p>
<ol start="4">
<li>Complete this file by adding some properties to the <kbd>SplitView</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>            ...<br/>                ...<br/>                Uqmls.USplit {<br/>                    id: spl1<br/>                    visible: true<br/>                    Layout.column: 0<br/>                    Layout.row: 3<br/>                    Layout.maximumHeight: w1.height / 5<br/>                    Layout.fillWidth: true<br/>                    Layout.fillHeight: true<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">This <kbd>SplitView</kbd> will be arranged in the button's grid layout of the second rectangle. Now we can run the <kbd>u_app.py</kbd> file and check that it is right. The full examples are available in the GitHub repository of this book.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the <kbd>QtQuick</kbd> module—the basic library for working with QML in the Qt framework. We learned about important concepts, such as layouts, controls, and some additional fields. For detailed information, you must go through the official documentation.</p>
<p>Now we will interrupt the exploration of QML and move on to the next stage and use the graphical Qt library with Python bindings, which is the main target of this book.</p>
<p>In the next chapter, we will learn about Python-related libraries, such as PyQt and PySide. This will give us practical experience with Python, and we will use all of the best things from Qt.</p>


            </article>

            
        </section>
    </body></html>