- en: Chapter 3.  Improving and Adding Authentication to an API With Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will improve the RESTful API that we started in the previous
    chapter and also add authentication related security to it. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Add unique constraints to the models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update a single field for a resource with the `PATCH` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take advantage of pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize pagination classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand authentication, permissions and throttling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add security-related data to the models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a customized permission class for object-level permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persist the user that makes a request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure permission policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a default value for a new required field in migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compose requests with the necessary authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browse the API with authentication credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding unique constraints to the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our API has a few issues that we need to solve. Right now, it is possible to
    create many game categories with the same name. We shouldn't be able to do so,
    and therefore, we will make the necessary changes to the `GameCategory` model
    to add a unique constraint on the `name` field. We will also add a unique constraint
    on the `name` field for the `Game` and `Player` models. This way, we will learn
    the necessary steps to make changes to the constraints for many models and reflect
    the changes in the underlying database through migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you quit Django''s development server. Remember that you just
    need to press ***Ctrl* + *C*** in the terminal or Command Prompt window in which
    it is running. Now, we will make changes to introduce unique constraints to the
    name field for the models that we use to represent and persist the game categories,
    games, and players. Open the `games/models.py`, file and replace the code that
    declares the `GameCategory`, `Game` and `Player` classes with the following code.
    The three lines that change are highlighted in the code listing. The code for
    the `PlayerScore` class remains the same. The code file for the sample is included
    in the `restful_python_chapter_03_01` folder, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We just needed to add `unique=True` as one of the named arguments for `models.CharField`.
    This way, we indicate that the field must be unique and Django will create the
    necessary unique constraints for the fields in the underlying database tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following Python script to generate the migrations that will allow
    us to synchronize the database with the unique constraints we added for the fields
    in the models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that the `gamesapi/games/migrations/0002_auto_20160623_2131.py`
    file includes the code to alter the field named `name` on `game`, `gamecategory`,
    and `player`. Note that the generated file name will be different in your configuration
    because it includes an encoded date and time. The following lines show the code
    for this file, which was automatically generated by Django. The code file for
    the sample is included in the `restful_python_chapter_03_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code defines a subclass of the `django.db.migrations.Migration` class named
    `Migration` that defines an `operations` list with many `migrations.AlterField`.
    Each `migrations.AlterField` will alter the field in the the table for each of
    the related models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following Python script to apply all the generated migrations
    and execute the changes in the database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the output generated after running the previous command.
    Note that the ordering for the migrations might be different in your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After we run the preceding command, we will have unique indexes on the name
    field for the `games_game`, `games_gamecategory`, and `games_player` tables in
    the PostgreSQL database. We can use the PostgreSQL command line or any other application
    that allows us to easily check the contents of the PostreSQL database to check
    the tables that Django updated. In case you decide to continue working with SQLite,
    use the commands or tools related to this database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can launch Django's development server to compose and send HTTP requests.
    Execute any of the following two commands based on your needs to access the API
    in other devices or computers connected to your LAN. Remember that we analyzed
    the difference between them in [Chapter 1](ch01.html "Chapter 1. Developing RESTful
    APIs with Django"), *Developing RESTful APIs with Django:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to create a game category with
    a name that already exists: `''3D RPG''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Django won''t be able to persist a `GameCategory` instance whose `name` is
    equal to the specified value because it would violate the unique constraint added
    to the `name` field. Thus, we will receive a `400 Bad Request` status code in
    the response header and a message related to the value specified for `name` in
    the JSON body. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After we have made the changes, we won't be able to add duplicate values for
    the `name` field in game categories, games, or players. This way, we can be sure
    that whenever we specify the name of any of these resources, we are going to reference
    the same unique resource.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a single field for a resource with the PATCH method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained in [Chapter 2](ch02.html "Chapter 2.  Working with Class-Based
    Views and Hyperlinked APIs in Django"), *Working with Class-Based Views and Hyperlinked *
    *APIs in Django*, our API can update a single field for an existing resource,
    and therefore, we provide an implementation for the `PATCH` method. For example,
    we can use the `PATCH` method to update an existing game and set the value for
    its `played` field to `true`. We don't want to use the `PUT` method because this
    method is meant to replace an entire game. The `PATCH` method is meant to apply
    a delta to an existing game, and therefore, it is the appropriate method to just
    change the value of the `played` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to update an existing game, specifically,
    to update the value of the `played` field and set it to `true` because we just
    want to update a single field, we will use the `PATCH` method instead of `PUT`.
    Make sure you replace `2` with the id or primary key of an existing game in your
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will compose and send a `PATCH` HTTP request with the
    specified JSON key-value pair. The request has a number after `/games/`, and therefore,
    it will match `''^games/(?P<pk>[0-9]+)/$''` and run the `patch` method for the
    `views.GameDetail` class-based view. Remember that the method is defined in the
    `RetrieveUpdateDestroyAPIView` superclass and it ends up calling the `update`
    method defined in `mixins.UpdateModelMixin`. If the `Game` instances with the
    updated value for the `played` field are valid and were successfully persisted
    in the database, the call to the method will return a `200 OK` status code and
    the recently updated `Game` serialized to JSON in the response body. The following
    lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Taking advantage of pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our database has a few rows in each of the tables that persist the models we
    have defined. However, after we start working with our API in a real-life production
    environment, we will have thousands of player scores, players, games, and game
    categories, and therefore, we will have to deal with large result sets. We can
    take advantage of the pagination features available in Django REST Framework to
    make it easy to specify how we want large results sets to be split into individual
    pages of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will compose and send HTTP requests to create 10 games that belong
    to one of the categories we have created: `2D mobile arcade`. This way, we will
    have a total of 12 games that persist in the database. We had 2 games and we will
    add 10 more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent `curl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands will compose and send ten `POST` HTTP requests with the
    specified JSON key-value pairs. The request specifies `/games/`, and therefore,
    it will match `'^games/$'` and run the `post` method for the `views.GameList`
    class-based view.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have 12 games in our database. However, we don't want to retrieve the
    12 games when we compose and send a `GET` HTTP request to `/games/`. We will configure
    one of the customizable pagination styles included in Django REST Framework to
    include a maximum of five resources in each individual page of data.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our API uses the generic views that work with the mixin classes that can handle
    paginated responses, and therefore, they will automatically take into account
    the pagination settings we configure in Django REST Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `gamesapi/settings.py` file and add the following lines that declare
    a dictionary named `REST_FRAMEWORK` with key-value pairs that configure the global
    pagination settings. The code file for the sample is included in the `restful_python_chapter_03_02`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The value for the `DEFAULT_PAGINATION_CLASS` settings key specifies a global
    setting with the default pagination class that the generic views will use to provide
    paginated responses. In this case, we will use the `rest_framework.pagination.LimitOffsetPagination`
    class, that provides a limit/offset-based style. This pagination style works with
    `limit` that indicates the maximum number of items to return and an `offset` that
    specifies the starting position of the query. The value for the `PAGE_SIZE` settings
    key specifies a global setting with the default value for the `limit`, also known
    as page size. We can specify a different limit when we perform the HTTP request
    by specifying the desired value in the `limit` query parameter. We can configure
    the class to have the maximum `limit` value in order to avoid the undesired huge
    result sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to retrieve all the games, specifically
    the following HTTP `GET` method to `/games/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic views will use the new settings that we added to enable the offset/limit
    pagination and the result will provide us the first 5 game resources (`results`
    key), the total number of games for the query (`count` key), and a link to the
    next (`next` key) and previous (`previous` key) pages. In this case, the resultset
    is the first page, and therefore, the link to the previous page (previous `key`)
    is `null`. We will receive a `200 OK` status code in the response header and the
    5 games in the `results` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding HTTP request, we didn''t specify any value for either the
    limit or offset parameters. However, as we specified the default value of limit
    as 5 items in the global settings, the generic views use this configuration value
    and provide us with the first page. If we compose and send the following HTTP
    request to retrieve the first page of all the games by specifying `1` for the
    offset value, the API will provide the same results shown before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compose and send the following HTTP request to retrieve the first page
    of all the games by specifying 0 for the offset value and 5 for the limit, the
    API will also provide the same results as shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send an HTTP request to retrieve the next page, that
    is, the second page for the games, specifically an HTTP `GET` method to `/games/`
    with the `offset` value set to `5`. Remember that the value for the next key returned
    in the JSON body of the previous result provides us with the URL to the next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will provide us the second set of the 5 game resource (`results`
    key), the total number of games for the query (`count` key), and a link to the
    next (`next` key) and previous (`previous` key) pages. In this case, the resultset
    is the second page, and therefore, the link to the previous page (previous `key`)
    is `http://localhost:8000/games/?limit=5`. We will receive a `200 OK` status code
    in the response header and the 5 games in the `results` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding HTTP request, we specified values for both the `limit` and
    `offset` parameters. However, as we specified the default value of `limit` in
    `5` items in the global settings, the following request will produce the same
    results than the previous request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will compose and send an HTTP request to retrieve the last page,
    that is, the third page for the games, specifically an HTTP `GET` method to `/games/`
    with the `offset` value set to `10`. Remember that the value for the next key
    returned in the JSON body of the previous result provides us with the URL to the
    next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will provide us the last set with 2 game resources (`results` key),
    the total number of games for the query (`count` key), and a link to the next
    (`next` key) and previous (`previous` key) pages. In this case, the resultset
    is the last page, and therefore, the link to the next page (`next` key) is `null`.
    We will receive a `200 OK` status code in the response header and the 2 games
    in the `results` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Customizing pagination classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `rest_framework.pagination.LimitOffsetPagination` class that we are using
    to provide paginated responses declares a `max_limit` class attribute that defaults
    to `None`. This attribute allows us to indicate the maximum allowable limit that
    can be specified using the `limit` query parameter. With the default setting,
    there is no limit and we will be able to process requests that specify a value
    for `1000000` for the limit query parameter. We definitely don't want our API
    to be able to generate a response with a million player scores or players with
    a single request. Unluckily, there is no setting that allows us to change the
    value that the class assigns to the `max_limit` class attribute. Thus, we will
    create our customized version of the limit/offset pagination style provided by
    Django REST Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Python file named `pagination.py` within the `games` folder and
    enter the following code which declares the new `LimitOffsetPaginationWithMaxLimit`
    class. The code file for the sample is included in the `restful_python_chapter_03_03`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lines declare the `LimitOffsetPaginationWithMaxLimit` class as
    a subclass of the `rest_framework.pagination.LimitOffsetPagination` class and
    overrides the value specified for the `max_limit` class attribute with `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `gamesapi/settings.py` file and replace the line that specified the
    value for the `DEFAULT_PAGINATION_CLASS` key in the dictionary named `REST_FRAMEWORK`
    with the highlighted line. The following lines show the new declaration of the
    dictionary named `REST_FRAMEWORK`. The code file for the sample is included in
    the `restful_python_chapter_03_03` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, the generic views will use the recently declared `games.pagination.LimitOffsetPaginationWithMaxLimit`
    class, that provides a limit/offset based style with a maximum `limit` value equal
    to `10`. If a request specifies a value for limit higher than `10`, the class
    will use the maximum limit value, that is, 10, and we will never return more than
    `10` items in a paginated response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to retrieve the first page for
    the games, specifically an HTTP `GET` method to `/games/` with the `limit` value
    set to `10000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will use a limit value equal to `10` instead of the indicated `10000`
    because we are using our customized pagination class. The result will provide
    us the first set with 10 game resources (`results` key), the total number of games
    for the query (`count` key), and a link to the next (`next` key) and previous
    (`previous` key) pages. In this case, the resultset is the first page, and therefore,
    the link to the next page (`next` key) is `http://localhost:8000/games/?limit=10&offset=10`.
    We will receive a `200 OK` status code in the response header and the first `10`
    games in the `results` array. The following lines show the header and the first
    lines of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to configure a maximum limit to avoid generating huge
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: Open a web browser and enter `http://localhost:8000/games/`. Replace localhost
    with the IP of the computer that is running the Django development server in case
    you use another computer or device to run the browser. The browsable API will
    compose and send a `GET` request to `/games/` and will display the results of
    its execution, that is, the headers and the JSON games list; since we have configured
    pagination, the rendered web page will include the default pagination template
    associated with the base pagination class we are using and will display the available
    page numbers at the upper-right corner of the web page. The following screenshot
    shows the rendered web page after entering the URL in a web browser with the resource
    description, **Game List**, and the three pages.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding authentication, permissions and throttling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current version of the API processes all the incoming requests without requiring
    any kind of authentication. Django REST Framework allows us to easily use different
    authentication schemes to identify the user that originated the request or the
    token that signed the request. Then, we can use these credentials to apply the
    permission and throttling policies that will determine whether the request must
    be permitted or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to other configurations, we can set the authentication schemes globally
    and then override them if necessary in a class-based view or a function view.
    A list of classes specifies the authentication schemes. Django REST framework
    will use all the specified classes in the list to authenticate a request before
    running the code for the view. The first class in the list that generates a successful
    authentication, in case we specify more than one class, will be responsible for setting
    the values for the following two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request.user`: The user model instance. We will use an instance of the `django.contrib.auth.User`
    class, that is, a Django `User` instance, in our examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request.auth`: Additional authentication information, such as an authentication
    token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a successful authentication, we can use the `request.user` property in
    our class-based view methods that receive the `request` parameter to retrieve
    additional information about the user that generated the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django REST Framework provides the following three authentication classes in
    the `rest_framework.authentication` module. All of them are subclasses of the
    `BaseAuthentication` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BasicAuthentication`: Provides an HTTP Basic authentication against username
    and password. If we use in production, we must make sure that the API is only
    available over HTTPS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SessionAuthentication`: Works with Django''s session framework for authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TokenAuthentication`: Provides a simple token based authentication. The request
    must include the token generated for a user in the `Authorization` HTTP header
    with `"Token "` as a prefix for the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will use a combination of `BasicAuthentication` and `SessionAuthentication`.
    We could also take advantage of the `TokenAuthentication` class later. Make sure
    you quit the Django's development server. Remember that you just need to press
    ***Ctrl*** + ***C*** in the terminal or command-prompt window in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `gamesapi/settings.py` file and add the highlighted lines to the dictionary
    named `REST_FRAMEWORK` with a key-value pair that configures the global default
    authentication classes. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The value for the `DEFAULT_AUTHENTICATION_CLASSES` settings key specifies a
    global setting with a tuple of string whose values indicate the classes that we
    want to use for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions use the authentication information included in the `request.user`
    and `request.auth` properties to determine whether the request should be granted
    or denied access. Permissions allow us to control which classes of users will
    be granted or denied access to the different features or parts of our API.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we will use the permissions features in Django REST framework to
    allow the authenticated users to create games. Unauthenticated users will only
    be allowed read-only access to games. Only the user that created the game will
    be able to make changes to this game, and therefore, we will make the necessary
    changes in our API to make a game have an owner user. We will use predefined permission
    classes and a customized permission class to define the explained permission policies.
  prefs: []
  type: TYPE_NORMAL
- en: Throttling also determines whether the request must be authorized. Throttles
    control the rate of requests that users can make to our API. For example, we want
    to limit unauthenticated users to a maximum of 5 requests per hour. We want to
    restrict authenticated users to a maximum of 20 requests to the games related
    views per day.
  prefs: []
  type: TYPE_NORMAL
- en: Adding security-related data to the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will associate a game with a creator or owner. Only the authenticated users
    will be able to create new games. Only the creator of a game will be able to update
    it or delete it. All the requests that aren't authenticated will only have read-only
    access to games.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `games/models.py` file and replace the code that declares the `Game`
    class with the following code. The line that changes is highlighted in the code
    listing. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `Game` model declares a new `owner` field that uses the `django.db.models.ForeignKey`
    class to provide a many-to-one relationship to the `auth.User` model, specifically,
    to the `django.contrib.auth.User` model. This `User` model represents the users
    within the Django authentication system. The `'games'` value specified for the
    `related_name` argument creates a backwards relation from the `User` model to
    the `Game` model. This value indicates the name to be used for the relation from
    the related `User` object back to a `Game` object. This way, we will be able to
    access all the games owned by a specific user. Whenever we delete a user, we want
    all the games owned by this user to be deleted too, and therefore, we specified
    the `models.CASCADE` value for the `on_delete` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will run the `createsuperuser` subcommand for `manage.py` to create
    the `superuser` for Django that we will use to easily authenticate our requests.
    We will create more users later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will ask you for the `username` you want to use for the `superuser`.
    Enter the desired user name and press **Enter**. We will use `superuser` as the
    user name for this example. You will see a line similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the command will ask you for the e-mail address. Enter an e-mail address
    and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the command will ask you for the password for the new superuser. Enter
    your desired password and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will ask you to enter the password again. Enter it and press *Enter*.
    If both entered passwords match, the superuser will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the `gamesapi/games` folder and open the `serializers.py` file.
    Add the following code after the last line that declares the imports, before the
    declaration of the `GameCategorySerializer` class. The code file for the sample
    is included in the `restful_python_chapter_03_04` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserGameSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. We use this new serializer class to serialize the games related to a user.
    This class declares a `Meta` inner class that declares two attributes: `model`
    and `fields`. The `model` attribute specifies the model related to the serializer,
    that is, the `Game` class. The `fields` attribute specifies a tuple of string
    whose values indicate the field names that we want to include in the serialization
    from the related model. We just want to include the URL and the game''s name,
    and therefore, the code specified `''url''` and `''name''` as members of the tuple.
    We don''t want to use the `GameSerializer` serializer class for the games related
    to a user because we want to serialize fewer fields, and therefore, we created
    the `UserGameSerializer` class.'
  prefs: []
  type: TYPE_NORMAL
- en: The `UserSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. This class declares a `Meta` inner class that declares two attributes-`model`
    and `fields`. The `model` attribute specifies the model related to the serializer,
    that is, the `django.contrib.auth.models.User` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `UserSerializer` class declares a `games` attribute as an instance of the
    previously explained `UserGameSerializer` with `many` and `read_only` equal to
    `True` because it is a one-to-many relationship and it is read-only. We use the
    `games` name that we specified as the `related_name` string value when we added
    the `owner` field as a `models.ForeignKey` instance in the `Game` model. This
    way, the `games` field will provide us with an array of URLs and names for each
    game that belongs to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make more changes to the `serializers.py` file in the `gamesapi/games`
    folder. We will add an `owner` field to the existing `GameSerializer` class. The
    following lines show the new code for the `GameSerializer` class. The new lines
    are highlighted. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `GameSerializer` class declares an `owner` attribute as an instance
    of `serializers.ReadOnlyField` with `source` equal to `'owner.username'`. This
    way, we will serialize the value for the `username` field of the related `django.contrib.auth.User`
    hold in the `owner` field. We use the `ReadOnlyField` because the owner is automatically
    populated when an authenticated user creates a game, and therefore, it won't be
    possible to change the owner after a game has been created. This way, the `owner`
    field will provide us with the user name that created the game. In addition, we
    added `'owner'` to the field's string tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a customized permission class for object-level permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Python file named `permissions.py` within the `games` folder and
    enter the following code that, declares the new `IsOwnerOrReadOnly` class. The
    code file for the sample is included in the `restful_python_chapter_03_04` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `rest_framework.permissions.BasePermission` class is the base class from
    which all permission classes should inherit. The previous lines declare the `IsOwnerOrReadOnly`
    class as a subclass of the `BasePermission` class and overrides the `has_object_permission`
    method defined in the superclass that returns a `bool` value indicating whether
    the permission should be granted or not. If the HTTP verb specified in the request
    (`request.method`) is any of the three safe methods specified in `permission.SAFE_METHODS`
    (`GET`, `HEAD` , or `OPTIONS`), the `has_object_permission` method returns `True`
    and grants permission to the request. These HTTP verbs do not make changes to
    the related resources, and therefore, they are included in the `permissions.SAFE_METHODS`
    tuple of string.
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb specified in the request (`request.method`) is not any of the
    three safe methods, the code returns `True` and grants permission only when the
    `owner` attribute of the received `obj` (`obj.owner`) matches the user that created
    the request (`request.user`). This way, only the owner of the related resource
    will be granted permission to requests that include HTTP verbs that aren't safe.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the new `IsOwnerOrReadOnly` permission class to make sure that only
    the game owners can make changes to an existing game. We will combine this permission
    class with the `rest_framework.permissions.IsAuthenticatedOrReadOnly` permission
    class that only allows read-only access to resources when the request is not authenticated
    as a user.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting the user that makes a request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to be able to list all the users and retrieve the details for a single
    user. We will create subclasses of the two following generic class views declared
    in `rest_framework.generics`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListAPIView`: Implements the `get` method that retrieves a listing of a queryset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RetrieveAPIView`: Implements the `get` method to retrieve a model instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go to the `gamesapi/games` folder and open the `views.py` file. Add the following
    code after the last line that declares the imports, before the declaration of
    the `GameCategoryList` class. The code file for the sample is included in the
    `restful_python_chapter_03_04` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Add the following highlighted lines to the ApiRoot class declared in the `views.py`
    file. Now, we will be able to navigate to the user-related views throughout the
    browsable API. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the `gamesapi/games` folder and open the `urls.py` file. Add the following
    elements to the `urlpatterns` string list. The new strings define the URL patterns
    that specify the regular expressions that have to be matched in the request to
    run a specific method for the previously created class based-views in the `views.py`
    file: `UserList` and `UserDetail`. The code file for the sample is included in
    the `restful_python_chapter_03_04` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to add a line in the `urls.py` file in the `gamesapi` folder, specifically,
    the `gamesapi/urls.py` file. The file defines the root URL configurations and
    we want to include the URL patterns to allow the browsable API to display the
    login and logout views. The following lines show the new code for the `gamesapi/urls.py`
    file. The new line is highlighted. The code file for the sample is included in
    the `restful_python_chapter_03_04` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to make changes to the `GameList` class-based view. We will override
    the `perform_create` method to populate the `owner` before a new `Game` instance
    is persisted in the database. The following lines show the new code for the `GameList`
    class in the `views.py` file. The new lines are highlighted. The code file for
    the sample is included in the `restful_python_chapter_03_04` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `GameList` class inherits the `perform_create` method from the `rest_framework.mixins.CreateModelMixin`
    class. Remember that the `generics.ListCreateAPIView` class inherits from `CreateModelMixin`
    class and other classes. The code for the overridden `perform_create` method passes
    an additional `owner` field to the create method by setting a value for the `owner`
    argument for the call to the `serializer.save` method. The code sets the owner
    attribute to the value of `self.request.user`, that is, to the user associated
    to the request. This way, whenever a new game is persisted, it will save the user
    associated to the request as its owner.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring permission policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will configure permission policies for the class-based views related
    to games. We will override the value for the `permission_classes` class attribute
    for the `GameList` and `GameDetail` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the new code for the `GameList` class in the `views.py`
    file. The new lines are highlighted. Don''t remove the code we added for the `perform_create`
    method for this class. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the new code for the `GameDetail` class in the `views.py`
    file. The new lines are highlighted. Don''t remove the code we added for the `perform_create`
    method for this class. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We added the same lines in the two classes. We have included the `IsAuthenticatedOrReadOnly`
    class and our previously created `IsOwnerOrReadOnly` permission class in the `permission_classes`
    tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a default value for a new required field in migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have persisted many games in our database and added a new `owner` field for
    the games that is a required field. We don't want to delete all the existing games,
    and therefore, we will take advantage of some features in Django that make it
    easy for us to make the changes in the underlying database without losing the
    existing data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to retrieve the `id` for the `superuser` we have created to use
    it as the default owner for the existing games. Django will allow us to easily
    update the existing games to set the owner user for them.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following commands to retrieve the `id` from the `auth_user` table for
    the row that whose username is equal to `'superuser'`. Replace `superuser` with
    the user name you selected for the previously created superuser. In addition,
    replace `user_name` in the command with the user name you used to create the PostgreSQL
    database and `password` with your chosen password for this database user. The
    command assumes that you are running PostgreSQL on the same computer in which
    you are running the command. In case you are working with a SQLite database, you
    can run the equivalent command in the PostgreSQL command line or a GUI-based tool
    to execute the same query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output with the value for `id`: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following Python script to generate the migrations that will allow
    us to synchronize the database with the new field we added to the Game model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Django will display the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We want to provide the one-off default that will be set on all existing rows,
    and therefore, enter `1` to select the first option and press ***Enter*** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Django will display the following text asking us to enter the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the value for the previously retrieved id, `1` in our example, and press
    Enter. The following lines show the output generated after running the preceding
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that the `gamesapi/games/migrations/0003_game_owner.py`
    file includes the code to add the field named `owner` to `game`. The following
    lines show the code for this file that was automatically generated by Django.
    The code file for the sample is included in the `restful_python_chapter_03_04`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The code declares a subclass of the `django.db.migrations.Migration` class named
    `Migration` that defines an `operations` list with a `migrations.AddField` that
    will add the the owner field to the table related to the `game` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following python script to apply all the generated migrations
    and execute the changes in the database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command.
    Note that the ordering for the migrations might be different in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: After we run the previous command, we will have a new `owner_id` field added
    to the `games_game` table in the PostgreSQL database. The existing rows in the
    `games_game` table will use the default value we indicated Django to use for the
    new `owner_id` field. We can use the PostgreSQL command line or any other application
    that allows us to easily check the contents of the PostreSQL database to check
    the `games_game` table that Django updated. In case you decide to continue working
    with SQLite, use the commands or tools related to this database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to launch the interactive shell. Make sure you are
    within the `gamesapi` folder in the Terminal or Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that a line that says (**InteractiveConsole**) is displayed
    after the usual lines that introduce your default Python interactive shell. Enter
    the following code in the Python interactive to create another user that is not
    a superuser. We will use this user and the superuser to test our changes in the
    permissions policies. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder, in the `users_test_01.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can replace `kevin` with your desired user name, `kevin@eaxmple.com` with
    the e-mail and `kevinpassword` with the password you want to use for this user.
    However, take into account that we will be using these credentials in the following
    sections. Make sure you always replace the credentials with your own credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, quit the interactive console by entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can launch Django''s development server to compose and send HTTP requests.
    Execute any of the following two commands based on your needs to access the API
    in other devices or computers connected to your LAN. Remember that we analyzed
    the difference between them in [Chapter 1](ch01.html "Chapter 1. Developing RESTful
    APIs with Django"), *Developing RESTful APIs with Django*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the preceding commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: Composing requests with the necessary authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to create a new game without
    authentication credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive a `401 Unauthorized` status code in the response header and
    a detail message indicating that we didn''t provide authentication credentials
    in the JSON body. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to create a new game, that is, to make a `POST` request to `/games/`,
    we need to provide authentication credentials using HTTP authentication. Now,
    we will compose and send an HTTP request to create a new game with authentication
    credentials, that is, with the `superuser` name and his password. Remember to
    replace `superuser` with the name you used for the `superuser` and `password`
    with the password you configured for this user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If the new `Game` with the superuser user as its owner was successfully persisted
    in the database, the function returns an `HTTP 201 Created` status code and the
    recently persisted `Game` serialized to JSON in the response body. The following
    lines show an example response for the HTTP request, with the new `Game` object
    in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will compose and send an HTTP request to update the `played` field value
    for the previously created game with authentication credentials. However, in this
    case, we will use the other user we created in Django to authenticate the request.
    Remember to replace `kevin` with the name you used for the user and `kevinpassword`
    with the password you configured for this user. In addition, replace `16` with
    the id generated for the previously created game in your configuration. We will
    use the `PATCH` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive a `403 Forbidden` status code in the response header and a
    detail message indicating that we do not have permission to perform the action
    in the JSON body. The owner for the game we want to update is `superuser` and
    the authentication credentials for this request use a different user. Thus, the
    operation is rejected by the `has_object_permission` method in the `IsOwnerOrReadOnly`
    class. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compose and send an HTTP request with the same authentication credentials
    for the same resource with the `GET` method, we will be able to retrieve the game
    that the specified user doesn''t own. It will work because `GET` is one of the
    safe methods and a user that is not the owner is allowed to read the resource.
    Remember to replace `kevin` with the name you used for the user and `kevinpassword`
    with the password you configured for this user. In addition, replace `16` with
    the id generated for the previously created game in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Browsing the API with authentication credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a web browser and enter `http://localhost:8000/`. Replace localhost by
    the IP of the computer that is running the Django development server in case you
    use another computer or device to run the browser. The browsable API will compose
    and send a `GET` request to `/` and will display the results of its execution,
    that is, the Api Root. You will notice that there is a **Log in** hyperlink in
    the upper-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: Click Log in and the browser will display the Django REST Framework login page.
    Enter `kevin` in username, `kevinpassword` in password, and click **Log In**.
    Remember to replace `kevin` with the name you used for the user and `kevinpassword`
    with the password you configured for this user. Now, you will be logged in as
    `kevin` and all the requests you compose and send through the browsable API will
    use this user. You will be redirected again to the **Api Root** and you will notice
    the **Log In** hyperlink is replaced with the username (**kevin**) and a drop-down
    menu that allows you to Log Out. The following screenshot shows the Api Root after
    we are logged in as `kevin`.
  prefs: []
  type: TYPE_NORMAL
- en: Click or tap on the URL on the right-hand side of **users**. In case you are
    browsing in localhost, the URL will be `http://localhost:8000/users/`. The Browsable
    API will render the web page for the **Users List**. The following lines show
    the JSON body with the first lines and the last lines with the results for the
    `GET` request to `localhost:8000/users/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `games` array includes the URL and the name for each game that the user
    owns because the `UserGameSerializer` class is serializing the content for each
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Click or tap on one of the URLs for the games listed as owned by the `superuser`
    user. The Browsable API will render the web page for the **Game Detail**. Click
    or tap on **OPTIONS** and the **DELETE** button will appear. Click or tap on **DELETE**.
    The web browser will display a confirmation dialog box. Click or tap on **DELETE**.
    We will receive a `403 Forbidden` status code in the response header and a detail
    message indicating that we do not have permission to perform the action in the
    JSON body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The owner for the game we want to delete is `superuser` and the authentication
    credentials for this request use a different user, specifically, `kevin`. Thus,
    the operation is rejected by the `has_object_permission` method in the `IsOwnerOrReadOnly`
    class. The following screenshot shows a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Browsing the API with authentication credentials](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also take advantage of other authentication plugins that Django REST
    Framework provides us. You can read more about all the possibilities that the
    framework provides us for authentication at [http://www.django-rest-framework.org/api-guide/authentication/](http://www.django-rest-framework.org/api-guide/authentication/)
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Which is the most appropriate HTTP method to update a single field for an existing
    resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`POST  `'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following pagination classes provides a limit/offset based style
    in Django REST Framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.pagination.LimitOffsetPagination`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.pagination.LimitOffsetPaging`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.styles.LimitOffsetPagination`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `rest_framework.authentication.BasicAuthentication` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Works with Django's session framework for authentication.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides an HTTP Basic authentication against username and password.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides a simple token based authentication.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `rest_framework.authentication.SessionAuthentication` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Works with Django's session framework for authentication.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides an HTTP Basic authentication against username and password.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides a simple token based authentication.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The value of which of the following settings keys specify a global setting
    with a tuple of string whose values indicate the classes that we want to use for
    authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DEFAULT_AUTH_CLASSES`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AUTHENTICATION_CLASSES`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DEFAULT_AUTHENTICATION_CLASSES`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we improved the REST API in many ways. We added unique constraints
    to the model and updated the database, we made it easy to update single fields
    with the `PATCH` method and we took advantage of pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we started working with authentication, permissions, and throttling. We
    added security-related data to the models and we updated the database. We made
    numerous changes in the different pieces of code to achieve a specific security
    goal and we took advantage of Django REST Framework authentication and permissions
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built an improved and complex API that takes into account authentication
    and uses permission policies, we will use additional abstractions included in
    the framework, we will add throttling and tests, which is what we are going to
    discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
