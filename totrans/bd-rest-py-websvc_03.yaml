- en: Chapter 3.  Improving and Adding Authentication to an API With Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. 使用 Django 改进和添加身份验证到 API
- en: 'In this chapter, we will improve the RESTful API that we started in the previous
    chapter and also add authentication related security to it. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将改进上一章开始构建的 RESTful API，并为其添加与身份验证相关的安全功能。我们将：
- en: Add unique constraints to the models
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为模型添加唯一约束
- en: Update a single field for a resource with the `PATCH` method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `PATCH` 方法更新资源的单个字段
- en: Take advantage of pagination
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用分页功能
- en: Customize pagination classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义分页类
- en: Understand authentication, permissions and throttling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解身份验证、权限和节流
- en: Add security-related data to the models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将安全相关数据添加到模型中
- en: Create a customized permission class for object-level permissions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为对象级权限创建自定义权限类
- en: Persist the user that makes a request
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化发起请求的用户
- en: Configure permission policies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置权限策略
- en: Set a default value for a new required field in migrations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在迁移中为新的必填字段设置默认值
- en: Compose requests with the necessary authentication
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用必要的身份验证来组合请求
- en: Browse the API with authentication credentials
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用身份验证凭据浏览 API
- en: Adding unique constraints to the models
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为模型添加唯一约束
- en: Our API has a few issues that we need to solve. Right now, it is possible to
    create many game categories with the same name. We shouldn't be able to do so,
    and therefore, we will make the necessary changes to the `GameCategory` model
    to add a unique constraint on the `name` field. We will also add a unique constraint
    on the `name` field for the `Game` and `Player` models. This way, we will learn
    the necessary steps to make changes to the constraints for many models and reflect
    the changes in the underlying database through migrations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 API 存在一些需要解决的问题。目前，可以创建许多具有相同名称的游戏类别。我们不应该能够这样做，因此，我们将对 `GameCategory` 模型进行必要的更改，以在
    `name` 字段上添加唯一约束。我们还将为 `Game` 和 `Player` 模型的 `name` 字段添加唯一约束。这样，我们将学习必要的步骤来更改多个模型的约束，并通过迁移在底层数据库中反映这些更改。
- en: 'Make sure that you quit Django''s development server. Remember that you just
    need to press ***Ctrl* + *C*** in the terminal or Command Prompt window in which
    it is running. Now, we will make changes to introduce unique constraints to the
    name field for the models that we use to represent and persist the game categories,
    games, and players. Open the `games/models.py`, file and replace the code that
    declares the `GameCategory`, `Game` and `Player` classes with the following code.
    The three lines that change are highlighted in the code listing. The code for
    the `PlayerScore` class remains the same. The code file for the sample is included
    in the `restful_python_chapter_03_01` folder, as shown:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已退出 Django 的开发服务器。请记住，您只需在运行它的终端或命令提示符窗口中按 ***Ctrl* + *C*** 即可。现在，我们将进行更改，为用于表示和持久化游戏类别、游戏和玩家的模型引入对名称字段的唯一约束。打开
    `games/models.py` 文件，将声明 `GameCategory`、`Game` 和 `Player` 类的代码替换为以下代码。代码列表中突出显示的三个行发生了变化。`PlayerScore`
    类的代码保持不变。示例代码文件包含在 `restful_python_chapter_03_01` 文件夹中，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We just needed to add `unique=True` as one of the named arguments for `models.CharField`.
    This way, we indicate that the field must be unique and Django will create the
    necessary unique constraints for the fields in the underlying database tables.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将 `unique=True` 作为 `models.CharField` 的命名参数之一添加。这样，我们表明该字段必须是唯一的，Django
    将为底层数据库表中的字段创建必要的唯一约束。
- en: 'Now, run the following Python script to generate the migrations that will allow
    us to synchronize the database with the unique constraints we added for the fields
    in the models:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下 Python 脚本来生成迁移，这将允许我们同步数据库，以与我们在模型字段中添加的唯一约束保持一致：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following lines show the output generated after running the previous command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一条命令后生成的输出：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output indicates that the `gamesapi/games/migrations/0002_auto_20160623_2131.py`
    file includes the code to alter the field named `name` on `game`, `gamecategory`,
    and `player`. Note that the generated file name will be different in your configuration
    because it includes an encoded date and time. The following lines show the code
    for this file, which was automatically generated by Django. The code file for
    the sample is included in the `restful_python_chapter_03_01` folder:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明`gamesapi/games/migrations/0002_auto_20160623_2131.py`文件包含了更改`game`、`gamecategory`和`player`上名为`name`的字段的代码。请注意，由于它包含编码的日期和时间，生成的文件名在您的配置中可能会有所不同。以下行显示了此文件的代码，该代码由Django自动生成。示例的代码文件包含在`restful_python_chapter_03_01`文件夹中：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code defines a subclass of the `django.db.migrations.Migration` class named
    `Migration` that defines an `operations` list with many `migrations.AlterField`.
    Each `migrations.AlterField` will alter the field in the the table for each of
    the related models.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个名为`Migration`的`django.db.migrations.Migration`类的子类，该类定义了一个包含许多`migrations.AlterField`的`operations`列表。每个`migrations.AlterField`将更改相关模型中每个相关表的字段。
- en: 'Now, run the following Python script to apply all the generated migrations
    and execute the changes in the database tables:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下Python脚本来应用所有生成的迁移并在数据库表中执行更改：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following lines show the output generated after running the previous command.
    Note that the ordering for the migrations might be different in your configuration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上述命令后生成的输出。请注意，迁移的顺序在您的配置中可能会有所不同。
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After we run the preceding command, we will have unique indexes on the name
    field for the `games_game`, `games_gamecategory`, and `games_player` tables in
    the PostgreSQL database. We can use the PostgreSQL command line or any other application
    that allows us to easily check the contents of the PostreSQL database to check
    the tables that Django updated. In case you decide to continue working with SQLite,
    use the commands or tools related to this database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行前面的命令之后，我们将在PostgreSQL数据库的`games_game`、`games_gamecategory`和`games_player`表上的`name`字段上拥有唯一的索引。我们可以使用PostgreSQL命令行或任何允许我们轻松检查PostreSQL数据库内容的其他应用程序来检查Django更新的表。如果您决定继续使用SQLite，请使用与此数据库相关的命令或工具。
- en: Now, we can launch Django's development server to compose and send HTTP requests.
    Execute any of the following two commands based on your needs to access the API
    in other devices or computers connected to your LAN. Remember that we analyzed
    the difference between them in [Chapter 1](ch01.html "Chapter 1. Developing RESTful
    APIs with Django"), *Developing RESTful APIs with Django:*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动Django的开发服务器来编写和发送HTTP请求。根据您的需求执行以下两个命令之一，以在其他连接到您的局域网的其他设备或计算机上访问API。请记住，我们在[第1章](ch01.html
    "第1章。使用Django开发RESTful API")中分析了它们之间的区别：*使用Django开发RESTful API：*
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行上述任何命令之后，开发服务器将开始监听端口`8000`。
- en: 'Now, we will compose and send an HTTP request to create a game category with
    a name that already exists: `''3D RPG''`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求来创建一个名为`'3D RPG'`的游戏类别：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Django won''t be able to persist a `GameCategory` instance whose `name` is
    equal to the specified value because it would violate the unique constraint added
    to the `name` field. Thus, we will receive a `400 Bad Request` status code in
    the response header and a message related to the value specified for `name` in
    the JSON body. The following lines show a sample response:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Django无法持久化`GameCategory`实例，其实例的`name`等于指定的值，因为这会违反添加到`name`字段的唯一约束。因此，我们将在响应头中收到`400
    Bad Request`状态码，并在JSON正文中收到与`name`指定的值相关的消息。以下行显示了示例响应：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After we have made the changes, we won't be able to add duplicate values for
    the `name` field in game categories, games, or players. This way, we can be sure
    that whenever we specify the name of any of these resources, we are going to reference
    the same unique resource.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行了更改之后，我们无法在游戏类别、游戏或玩家中为`name`字段添加重复的值。这样，我们可以确保每次我们指定这些资源的名称时，我们都会引用相同的唯一资源。
- en: Updating a single field for a resource with the PATCH method
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PATCH方法更新资源的单个字段
- en: As we explained in [Chapter 2](ch02.html "Chapter 2.  Working with Class-Based
    Views and Hyperlinked APIs in Django"), *Working with Class-Based Views and Hyperlinked *
    *APIs in Django*, our API can update a single field for an existing resource,
    and therefore, we provide an implementation for the `PATCH` method. For example,
    we can use the `PATCH` method to update an existing game and set the value for
    its `played` field to `true`. We don't want to use the `PUT` method because this
    method is meant to replace an entire game. The `PATCH` method is meant to apply
    a delta to an existing game, and therefore, it is the appropriate method to just
    change the value of the `played` field.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第二章](ch02.html "第二章。在Django中使用基于类的视图和超链接API")中解释的那样，*在Django中使用基于类的视图和超链接API*，我们的API可以更新现有资源的单个字段，因此，我们提供了一个`PATCH`方法的实现。例如，我们可以使用`PATCH`方法来更新一个现有的游戏，并将它的`played`字段的值设置为`true`。我们不希望使用`PUT`方法，因为这个方法旨在替换整个游戏。`PATCH`方法旨在将增量应用到现有游戏上，因此，它是仅更改`played`字段值的适当方法。
- en: 'Now, we will compose and send an HTTP request to update an existing game, specifically,
    to update the value of the `played` field and set it to `true` because we just
    want to update a single field, we will use the `PATCH` method instead of `PUT`.
    Make sure you replace `2` with the id or primary key of an existing game in your
    configuration:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个HTTP请求来更新一个现有的游戏，具体来说，是更新`played`字段的值并将其设置为`true`，因为我们只想更新单个字段，所以我们将使用`PATCH`方法而不是`PUT`。确保将`2`替换为您配置中现有游戏的id或主键：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the equivalent curl command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding command will compose and send a `PATCH` HTTP request with the
    specified JSON key-value pair. The request has a number after `/games/`, and therefore,
    it will match `''^games/(?P<pk>[0-9]+)/$''` and run the `patch` method for the
    `views.GameDetail` class-based view. Remember that the method is defined in the
    `RetrieveUpdateDestroyAPIView` superclass and it ends up calling the `update`
    method defined in `mixins.UpdateModelMixin`. If the `Game` instances with the
    updated value for the `played` field are valid and were successfully persisted
    in the database, the call to the method will return a `200 OK` status code and
    the recently updated `Game` serialized to JSON in the response body. The following
    lines show a sample response:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将组合并发送一个带有指定JSON键值对的`PATCH` HTTP请求。请求在`/games/`之后有一个数字，因此，它将匹配`'^games/(?P<pk>[0-9]+)/$'`并运行`views.GameDetail`基于类的视图的`patch`方法。请记住，该方法是在`RetrieveUpdateDestroyAPIView`超类中定义的，并且最终会调用在`mixins.UpdateModelMixin`中定义的`update`方法。如果具有更新`played`字段值的`Game`实例有效并且已成功持久化到数据库中，对该方法的调用将返回`200
    OK`状态码，并将最近更新的`Game`序列化为JSON格式放在响应体中。以下行显示了示例响应：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Taking advantage of pagination
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用分页功能
- en: Our database has a few rows in each of the tables that persist the models we
    have defined. However, after we start working with our API in a real-life production
    environment, we will have thousands of player scores, players, games, and game
    categories, and therefore, we will have to deal with large result sets. We can
    take advantage of the pagination features available in Django REST Framework to
    make it easy to specify how we want large results sets to be split into individual
    pages of data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库在每个表中都有几行，用于持久化我们定义的模型。然而，在我们开始在现实生活中的生产环境中使用我们的API之后，我们将有数千个玩家得分、玩家、游戏和游戏类别，因此，我们将不得不处理大量结果集。我们可以利用Django
    REST Framework中可用的分页功能，使其容易指定我们希望如何将大量结果集拆分为单个数据页。
- en: 'First, we will compose and send HTTP requests to create 10 games that belong
    to one of the categories we have created: `2D mobile arcade`. This way, we will
    have a total of 12 games that persist in the database. We had 2 games and we will
    add 10 more:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将组合并发送HTTP请求来创建属于我们创建的某个类别（例如`2D mobile arcade`）的10个游戏。这样，我们将有总共12个游戏持久保存在数据库中。我们原本有2个游戏，并将再添加10个：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following are the equivalent `curl` commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding commands will compose and send ten `POST` HTTP requests with the
    specified JSON key-value pairs. The request specifies `/games/`, and therefore,
    it will match `'^games/$'` and run the `post` method for the `views.GameList`
    class-based view.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将组合并发送十个带有指定JSON键值对的`POST` HTTP请求。请求指定`/games/`，因此，它将匹配`'^games/$'`并运行`views.GameList`基于类的视图的`post`方法。
- en: Now, we have 12 games in our database. However, we don't want to retrieve the
    12 games when we compose and send a `GET` HTTP request to `/games/`. We will configure
    one of the customizable pagination styles included in Django REST Framework to
    include a maximum of five resources in each individual page of data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的数据库中有12场比赛。然而，当我们向`/games/`发送一个`GET` HTTP请求来组合和发送时，我们不想检索这12场比赛。我们将配置Django
    REST Framework中包含的可定制的分页样式之一，以在每个数据页面上包含最多五个资源。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Our API uses the generic views that work with the mixin classes that can handle
    paginated responses, and therefore, they will automatically take into account
    the pagination settings we configure in Django REST Framework.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API使用与可以处理分页响应的混合类一起工作的通用视图，因此，它们将自动考虑我们在Django REST Framework中配置的分页设置。
- en: 'Open the `gamesapi/settings.py` file and add the following lines that declare
    a dictionary named `REST_FRAMEWORK` with key-value pairs that configure the global
    pagination settings. The code file for the sample is included in the `restful_python_chapter_03_02`
    folder:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`gamesapi/settings.py`文件，并添加以下行，声明一个名为`REST_FRAMEWORK`的字典，其中包含配置全局分页设置的键值对。示例代码文件包含在`restful_python_chapter_03_02`文件夹中：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The value for the `DEFAULT_PAGINATION_CLASS` settings key specifies a global
    setting with the default pagination class that the generic views will use to provide
    paginated responses. In this case, we will use the `rest_framework.pagination.LimitOffsetPagination`
    class, that provides a limit/offset-based style. This pagination style works with
    `limit` that indicates the maximum number of items to return and an `offset` that
    specifies the starting position of the query. The value for the `PAGE_SIZE` settings
    key specifies a global setting with the default value for the `limit`, also known
    as page size. We can specify a different limit when we perform the HTTP request
    by specifying the desired value in the `limit` query parameter. We can configure
    the class to have the maximum `limit` value in order to avoid the undesired huge
    result sets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_PAGINATION_CLASS`设置键的值指定了一个全局设置，即通用视图将使用的默认分页类，以提供分页响应。在这种情况下，我们将使用`rest_framework.pagination.LimitOffsetPagination`类，它提供基于限制/偏移的分页样式。这种分页样式与`limit`一起工作，表示要返回的最大项目数，以及指定查询起始位置的`offset`。`PAGE_SIZE`设置键的值指定了一个全局设置，即`limit`的默认值，也称为页面大小。我们可以在执行HTTP请求时指定不同的限制值，通过在`limit`查询参数中指定所需的值。我们可以配置类以具有最大的`limit`值，以避免不希望的大结果集。'
- en: 'Now, we will compose and send an HTTP request to retrieve all the games, specifically
    the following HTTP `GET` method to `/games/`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个HTTP请求来检索所有比赛，具体来说，是以下HTTP `GET`方法到`/games/`：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The generic views will use the new settings that we added to enable the offset/limit
    pagination and the result will provide us the first 5 game resources (`results`
    key), the total number of games for the query (`count` key), and a link to the
    next (`next` key) and previous (`previous` key) pages. In this case, the resultset
    is the first page, and therefore, the link to the previous page (previous `key`)
    is `null`. We will receive a `200 OK` status code in the response header and the
    5 games in the `results` array:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通用视图将使用我们添加的新设置来启用偏移/限制分页，并且结果将为我们提供前5个游戏资源（`results`键），查询的游戏总数（`count`键），以及指向下一页（`next`键）和上一页（`previous`键）的链接。在这种情况下，结果集是第一页，因此，上一页的链接（previous
    `key`）是`null`。我们将在响应头中收到`200 OK`状态码，以及`results`数组中的5场比赛：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding HTTP request, we didn''t specify any value for either the
    limit or offset parameters. However, as we specified the default value of limit
    as 5 items in the global settings, the generic views use this configuration value
    and provide us with the first page. If we compose and send the following HTTP
    request to retrieve the first page of all the games by specifying `1` for the
    offset value, the API will provide the same results shown before:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的HTTP请求中，我们没有指定限制或偏移参数的任何值。然而，由于我们在全局设置中指定了默认的限制值为5项，通用视图使用此配置值并为我们提供第一页。如果我们通过指定偏移值为`1`来组合并发送以下HTTP请求以检索所有游戏的首页，API将提供之前显示的相同结果：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we compose and send the following HTTP request to retrieve the first page
    of all the games by specifying 0 for the offset value and 5 for the limit, the
    API will also provide the same results as shown earlier:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写并发送以下 HTTP 请求以通过将偏移量值指定为 0 和限制值指定为 5 来检索所有游戏的首页，API 也将提供与前面所示相同的相同结果：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the equivalent curl command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 curl 命令：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we will compose and send an HTTP request to retrieve the next page, that
    is, the second page for the games, specifically an HTTP `GET` method to `/games/`
    with the `offset` value set to `5`. Remember that the value for the next key returned
    in the JSON body of the previous result provides us with the URL to the next page:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个 HTTP 请求以检索下一页，即游戏的第二页，具体是一个到 `/games/` 的 HTTP `GET` 方法，并将 `offset`
    值设置为 `5`。请记住，前一个结果 JSON 体的 `next` 键返回的值为我们提供了下一页的 URL：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result will provide us the second set of the 5 game resource (`results`
    key), the total number of games for the query (`count` key), and a link to the
    next (`next` key) and previous (`previous` key) pages. In this case, the resultset
    is the second page, and therefore, the link to the previous page (previous `key`)
    is `http://localhost:8000/games/?limit=5`. We will receive a `200 OK` status code
    in the response header and the 5 games in the `results` array:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将为我们提供第 5 个游戏资源集（`results` 键），查询到的游戏总数（`count` 键），以及指向下一页（`next` 键）和上一页（`previous`
    键）的链接。在这种情况下，结果集是第二页，因此，指向上一页的链接（`previous` 键）是 `http://localhost:8000/games/?limit=5`。我们将在响应头中收到
    `200 OK` 状态码，并在 `results` 数组中收到 5 个游戏：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding HTTP request, we specified values for both the `limit` and
    `offset` parameters. However, as we specified the default value of `limit` in
    `5` items in the global settings, the following request will produce the same
    results than the previous request:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 HTTP 请求中，我们为 `limit` 和 `offset` 参数指定了值。然而，由于我们在全局设置中将 `limit` 的默认值指定为 `5`
    项，因此以下请求将产生与先前请求相同的结果：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the equivalent curl command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 curl 命令：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we will compose and send an HTTP request to retrieve the last page,
    that is, the third page for the games, specifically an HTTP `GET` method to `/games/`
    with the `offset` value set to `10`. Remember that the value for the next key
    returned in the JSON body of the previous result provides us with the URL to the
    next page:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编写并发送一个 HTTP 请求以检索最后一页，即游戏的第三页，具体是一个到 `/games/` 的 HTTP `GET` 方法，并将 `offset`
    值设置为 `10`。请记住，前一个结果 JSON 体的 `next` 键返回的值为我们提供了下一页的 URL：
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result will provide us the last set with 2 game resources (`results` key),
    the total number of games for the query (`count` key), and a link to the next
    (`next` key) and previous (`previous` key) pages. In this case, the resultset
    is the last page, and therefore, the link to the next page (`next` key) is `null`.
    We will receive a `200 OK` status code in the response header and the 2 games
    in the `results` array:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将为我们提供最后一个包含 2 个游戏资源（`results` 键），查询到的游戏总数（`count` 键），以及指向下一页（`next` 键）和上一页（`previous`
    键）的链接。在这种情况下，结果集是最后一页，因此，指向下一页的链接（`next` 键）是 `null`。我们将在响应头中收到 `200 OK` 状态码，并在
    `results` 数组中收到 2 个游戏：
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Customizing pagination classes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义分页类
- en: The `rest_framework.pagination.LimitOffsetPagination` class that we are using
    to provide paginated responses declares a `max_limit` class attribute that defaults
    to `None`. This attribute allows us to indicate the maximum allowable limit that
    can be specified using the `limit` query parameter. With the default setting,
    there is no limit and we will be able to process requests that specify a value
    for `1000000` for the limit query parameter. We definitely don't want our API
    to be able to generate a response with a million player scores or players with
    a single request. Unluckily, there is no setting that allows us to change the
    value that the class assigns to the `max_limit` class attribute. Thus, we will
    create our customized version of the limit/offset pagination style provided by
    Django REST Framework.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的`rest_framework.pagination.LimitOffsetPagination`类，用于提供分页响应，声明了一个`max_limit`类属性，默认值为`None`。此属性允许我们指定可以使用`limit`查询参数指定的最大允许限制。使用默认设置，没有限制，我们将能够处理指定`1000000`作为限制查询参数值的请求。我们绝对不希望我们的API能够通过单个请求生成包含一百万个玩家分数或玩家的响应。不幸的是，没有设置可以更改类分配给`max_limit`类属性的值。因此，我们将创建Django
    REST Framework提供的限制/偏移分页样式的自定义版本。
- en: 'Create a new Python file named `pagination.py` within the `games` folder and
    enter the following code which declares the new `LimitOffsetPaginationWithMaxLimit`
    class. The code file for the sample is included in the `restful_python_chapter_03_03`
    folder:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`games`文件夹中创建一个名为`pagination.py`的新Python文件，并输入以下代码，该代码声明了新的`LimitOffsetPaginationWithMaxLimit`类。示例代码文件包含在`restful_python_chapter_03_03`文件夹中：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding lines declare the `LimitOffsetPaginationWithMaxLimit` class as
    a subclass of the `rest_framework.pagination.LimitOffsetPagination` class and
    overrides the value specified for the `max_limit` class attribute with `10`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行声明了`LimitOffsetPaginationWithMaxLimit`类作为`rest_framework.pagination.LimitOffsetPagination`类的子类，并覆盖了为`max_limit`类属性指定的值，将其设置为`10`。
- en: 'Open the `gamesapi/settings.py` file and replace the line that specified the
    value for the `DEFAULT_PAGINATION_CLASS` key in the dictionary named `REST_FRAMEWORK`
    with the highlighted line. The following lines show the new declaration of the
    dictionary named `REST_FRAMEWORK`. The code file for the sample is included in
    the `restful_python_chapter_03_03` folder:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`gamesapi/settings.py`文件，将指定`REST_FRAMEWORK`字典中`DEFAULT_PAGINATION_CLASS`键值的行替换为高亮显示的行。以下行显示了名为`REST_FRAMEWORK`的新字典声明。示例代码文件包含在`restful_python_chapter_03_03`文件夹中：
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, the generic views will use the recently declared `games.pagination.LimitOffsetPaginationWithMaxLimit`
    class, that provides a limit/offset based style with a maximum `limit` value equal
    to `10`. If a request specifies a value for limit higher than `10`, the class
    will use the maximum limit value, that is, 10, and we will never return more than
    `10` items in a paginated response.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通用视图将使用最近声明的`games.pagination.LimitOffsetPaginationWithMaxLimit`类，该类提供了一个最大`limit`值为`10`的限制/偏移分页样式。如果请求指定了大于`10`的限制值，该类将使用最大限制值，即10，并且我们永远不会在分页响应中返回超过`10`个条目。
- en: 'Now, we will compose and send an HTTP request to retrieve the first page for
    the games, specifically an HTTP `GET` method to `/games/` with the `limit` value
    set to `10000`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求来检索游戏的第一个页面，具体是一个设置`limit`值为`10000`的`/games/`的HTTP `GET`方法：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following is the equivalent curl command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result will use a limit value equal to `10` instead of the indicated `10000`
    because we are using our customized pagination class. The result will provide
    us the first set with 10 game resources (`results` key), the total number of games
    for the query (`count` key), and a link to the next (`next` key) and previous
    (`previous` key) pages. In this case, the resultset is the first page, and therefore,
    the link to the next page (`next` key) is `http://localhost:8000/games/?limit=10&offset=10`.
    We will receive a `200 OK` status code in the response header and the first `10`
    games in the `results` array. The following lines show the header and the first
    lines of the output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将使用`10`作为限制值，而不是指示的`10000`，因为我们正在使用我们自定义的分页类。结果将提供包含10个游戏资源的第一个集合（`results`键），查询的游戏总数（`count`键），以及指向下一页（`next`键）和上一页（`previous`键）的链接。在这种情况下，结果集是第一页，因此，指向下一页的链接（`next`键）是`http://localhost:8000/games/?limit=10&offset=10`。我们将在响应头中收到`200
    OK`状态码，并在`results`数组中收到前`10`个游戏。以下行显示了头信息和输出内容的第一行：
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a good practice to configure a maximum limit to avoid generating huge
    responses.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 配置最大限制是一个良好的实践，以避免生成巨大的响应。
- en: Open a web browser and enter `http://localhost:8000/games/`. Replace localhost
    with the IP of the computer that is running the Django development server in case
    you use another computer or device to run the browser. The browsable API will
    compose and send a `GET` request to `/games/` and will display the results of
    its execution, that is, the headers and the JSON games list; since we have configured
    pagination, the rendered web page will include the default pagination template
    associated with the base pagination class we are using and will display the available
    page numbers at the upper-right corner of the web page. The following screenshot
    shows the rendered web page after entering the URL in a web browser with the resource
    description, **Game List**, and the three pages.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 打开网页浏览器并输入 `http://localhost:8000/games/`。如果您使用另一台计算机或设备运行浏览器，请将 localhost 替换为运行
    Django 开发服务器的计算机的 IP 地址。可浏览的 API 将会组成并发送一个 `GET` 请求到 `/games/`，并显示其执行结果，即头部信息和
    JSON 游戏列表；由于我们已配置分页，渲染的网页将包括与我们所使用的基分页类关联的默认分页模板，并在网页右上角显示可用的页码。以下截图显示了在网页浏览器中输入
    URL 后渲染的网页，其中包含资源描述、**游戏列表**和三个页面。
- en: Understanding authentication, permissions and throttling
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解认证、权限和限制
- en: Our current version of the API processes all the incoming requests without requiring
    any kind of authentication. Django REST Framework allows us to easily use different
    authentication schemes to identify the user that originated the request or the
    token that signed the request. Then, we can use these credentials to apply the
    permission and throttling policies that will determine whether the request must
    be permitted or not.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前版本的 API 处理所有传入的请求，而不需要任何类型的认证。Django REST 框架允许我们轻松地使用不同的认证方案来识别发起请求的用户或签名请求的令牌。然后，我们可以使用这些凭证来应用权限和限制策略，这将决定请求是否必须被允许。
- en: 'Similar to other configurations, we can set the authentication schemes globally
    and then override them if necessary in a class-based view or a function view.
    A list of classes specifies the authentication schemes. Django REST framework
    will use all the specified classes in the list to authenticate a request before
    running the code for the view. The first class in the list that generates a successful
    authentication, in case we specify more than one class, will be responsible for setting
    the values for the following two properties:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他配置类似，我们可以全局设置认证方案，并在必要时在基于类的视图或函数视图中覆盖它们。一个类列表指定了认证方案。Django REST 框架将在运行视图代码之前使用列表中指定的所有类来认证请求。如果指定了多个类，则列表中第一个成功认证的类将负责设置以下两个属性的值：
- en: '`request.user`: The user model instance. We will use an instance of the `django.contrib.auth.User`
    class, that is, a Django `User` instance, in our examples.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request.user`: 用户模型实例。在我们的示例中，我们将使用 `django.contrib.auth.User` 类的实例，即 Django
    的 `User` 实例。'
- en: '`request.auth`: Additional authentication information, such as an authentication
    token.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request.auth`: 额外的认证信息，例如认证令牌。'
- en: After a successful authentication, we can use the `request.user` property in
    our class-based view methods that receive the `request` parameter to retrieve
    additional information about the user that generated the request.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功认证后，我们可以在接收 `request` 参数的类视图方法中使用 `request.user` 属性来检索关于发起请求的用户的额外信息。
- en: 'Django REST Framework provides the following three authentication classes in
    the `rest_framework.authentication` module. All of them are subclasses of the
    `BaseAuthentication` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST 框架在 `rest_framework.authentication` 模块中提供了以下三个认证类。它们都是 `BaseAuthentication`
    类的子类：
- en: '`BasicAuthentication`: Provides an HTTP Basic authentication against username
    and password. If we use in production, we must make sure that the API is only
    available over HTTPS.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BasicAuthentication`: 提供基于用户名和密码的 HTTP Basic 认证。如果我们用于生产，我们必须确保 API 只通过 HTTPS
    提供访问。'
- en: '`SessionAuthentication`: Works with Django''s session framework for authentication.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SessionAuthentication`: 与 Django 的会话框架一起用于认证。'
- en: '`TokenAuthentication`: Provides a simple token based authentication. The request
    must include the token generated for a user in the `Authorization` HTTP header
    with `"Token "` as a prefix for the token.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TokenAuthentication`：提供基于简单令牌的身份验证。请求必须包含在 `Authorization` HTTP 头中为用户生成的令牌，令牌前缀为
    `"Token "`。'
- en: First, we will use a combination of `BasicAuthentication` and `SessionAuthentication`.
    We could also take advantage of the `TokenAuthentication` class later. Make sure
    you quit the Django's development server. Remember that you just need to press
    ***Ctrl*** + ***C*** in the terminal or command-prompt window in which it is running.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 `BasicAuthentication` 和 `SessionAuthentication` 的组合。我们还可以稍后利用 `TokenAuthentication`
    类。确保您已退出 Django 的开发服务器。请记住，您只需在终端或命令提示符窗口中按 ***Ctrl*** + ***C*** 即可。
- en: 'Open the `gamesapi/settings.py` file and add the highlighted lines to the dictionary
    named `REST_FRAMEWORK` with a key-value pair that configures the global default
    authentication classes. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder, as shown:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `gamesapi/settings.py` 文件，并将高亮显示的行添加到名为 `REST_FRAMEWORK` 的字典中，以键值对的形式配置全局默认身份验证类。示例代码文件包含在
    `restful_python_chapter_03_04` 文件夹中，如下所示：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The value for the `DEFAULT_AUTHENTICATION_CLASSES` settings key specifies a
    global setting with a tuple of string whose values indicate the classes that we
    want to use for authentication.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_AUTHENTICATION_CLASSES` 设置键的值指定了一个全局设置，它是一个字符串元组，其值指示我们想要用于身份验证的类。'
- en: Permissions use the authentication information included in the `request.user`
    and `request.auth` properties to determine whether the request should be granted
    or denied access. Permissions allow us to control which classes of users will
    be granted or denied access to the different features or parts of our API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 权限使用 `request.user` 和 `request.auth` 属性中包含的认证信息来确定是否应授予或拒绝请求访问。权限允许我们控制哪些用户类别将被授予或拒绝访问我们
    API 的不同功能或部分。
- en: For example, we will use the permissions features in Django REST framework to
    allow the authenticated users to create games. Unauthenticated users will only
    be allowed read-only access to games. Only the user that created the game will
    be able to make changes to this game, and therefore, we will make the necessary
    changes in our API to make a game have an owner user. We will use predefined permission
    classes and a customized permission class to define the explained permission policies.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将使用 Django REST framework 中的权限功能，允许经过身份验证的用户创建游戏。未经身份验证的用户将仅被允许对游戏进行只读访问。只有创建游戏的用户才能对其进行更改，因此，我们将在我们的
    API 中进行必要的更改，使游戏具有所有者用户。我们将使用预定义的权限类和自定义权限类来定义所解释的权限策略。
- en: Throttling also determines whether the request must be authorized. Throttles
    control the rate of requests that users can make to our API. For example, we want
    to limit unauthenticated users to a maximum of 5 requests per hour. We want to
    restrict authenticated users to a maximum of 20 requests to the games related
    views per day.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 限制也决定了请求是否必须被授权。限制控制用户对我们 API 发出请求的速率。例如，我们希望限制未经身份验证的用户每小时最多请求 5 次。我们希望限制经过身份验证的用户每天对游戏相关视图的请求最多为
    20 次。
- en: Adding security-related data to the models
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将安全相关数据添加到模型中
- en: We will associate a game with a creator or owner. Only the authenticated users
    will be able to create new games. Only the creator of a game will be able to update
    it or delete it. All the requests that aren't authenticated will only have read-only
    access to games.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把一个游戏与创建者或所有者关联起来。只有经过身份验证的用户才能创建新游戏。只有游戏的创建者才能更新或删除它。所有未经身份验证的请求都只能对游戏进行只读访问。
- en: Open the `games/models.py` file and replace the code that declares the `Game`
    class with the following code. The line that changes is highlighted in the code
    listing. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `games/models.py` 文件，并用以下代码替换声明 `Game` 类的代码。代码列表中更改的行被高亮显示。示例代码文件包含在 `restful_python_chapter_03_04`
    文件夹中。
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Game` model declares a new `owner` field that uses the `django.db.models.ForeignKey`
    class to provide a many-to-one relationship to the `auth.User` model, specifically,
    to the `django.contrib.auth.User` model. This `User` model represents the users
    within the Django authentication system. The `'games'` value specified for the
    `related_name` argument creates a backwards relation from the `User` model to
    the `Game` model. This value indicates the name to be used for the relation from
    the related `User` object back to a `Game` object. This way, we will be able to
    access all the games owned by a specific user. Whenever we delete a user, we want
    all the games owned by this user to be deleted too, and therefore, we specified
    the `models.CASCADE` value for the `on_delete` argument.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game` 模型声明了一个新的 `owner` 字段，该字段使用 `django.db.models.ForeignKey` 类来提供与 `auth.User`
    模型的多对一关系，具体来说，是与 `django.contrib.auth.User` 模型。这个 `User` 模型代表 Django 认证系统中的用户。为
    `related_name` 参数指定的 `''games''` 值创建了一个从 `User` 模型到 `Game` 模型的反向关系。这个值表示从相关的 `User`
    对象回指到 `Game` 对象时要使用的名称。这样，我们将能够访问特定用户拥有的所有游戏。每当我们要删除一个用户时，我们希望删除该用户拥有的所有游戏，因此，我们为
    `on_delete` 参数指定了 `models.CASCADE` 值。'
- en: 'Now, we will run the `createsuperuser` subcommand for `manage.py` to create
    the `superuser` for Django that we will use to easily authenticate our requests.
    We will create more users later:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行 `manage.py` 的 `createsuperuser` 子命令来创建 Django 的 `superuser`，我们将使用它来轻松地验证我们的请求。我们将在稍后创建更多用户：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The command will ask you for the `username` you want to use for the `superuser`.
    Enter the desired user name and press **Enter**. We will use `superuser` as the
    user name for this example. You will see a line similar to the following one:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将要求你输入用于 `superuser` 的 `username`。输入你想要的用户名并按 **Enter**。在这个例子中，我们将使用 `superuser`
    作为用户名。你将看到类似以下的一行：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, the command will ask you for the e-mail address. Enter an e-mail address
    and press *Enter*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，命令将要求你输入电子邮件地址。输入一个电子邮件地址并按 *Enter*：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, the command will ask you for the password for the new superuser. Enter
    your desired password and press *Enter*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，命令将要求你输入新超级用户的密码。输入你想要的密码并按 *Enter*。
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The command will ask you to enter the password again. Enter it and press *Enter*.
    If both entered passwords match, the superuser will be created:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将要求你再次输入密码。输入它并按 *Enter*。如果输入的两个密码匹配，超级用户将被创建：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, go to the `gamesapi/games` folder and open the `serializers.py` file.
    Add the following code after the last line that declares the imports, before the
    declaration of the `GameCategorySerializer` class. The code file for the sample
    is included in the `restful_python_chapter_03_04` folder:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `gamesapi/games` 文件夹并打开 `serializers.py` 文件。在声明导入的最后一行之后，在 `GameCategorySerializer`
    类声明之前添加以下代码。示例代码文件包含在 `restful_python_chapter_03_04` 文件夹中：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `UserGameSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. We use this new serializer class to serialize the games related to a user.
    This class declares a `Meta` inner class that declares two attributes: `model`
    and `fields`. The `model` attribute specifies the model related to the serializer,
    that is, the `Game` class. The `fields` attribute specifies a tuple of string
    whose values indicate the field names that we want to include in the serialization
    from the related model. We just want to include the URL and the game''s name,
    and therefore, the code specified `''url''` and `''name''` as members of the tuple.
    We don''t want to use the `GameSerializer` serializer class for the games related
    to a user because we want to serialize fewer fields, and therefore, we created
    the `UserGameSerializer` class.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserGameSerializer` 类是 `HyperlinkedModelSerializer` 类的子类。我们使用这个新的序列化器类来序列化与用户相关的游戏。这个类声明了一个
    `Meta` 内部类，该类声明了两个属性：`model` 和 `fields`。`model` 属性指定了与序列化器相关的模型，即 `Game` 类。`fields`
    属性指定了一个字符串值的元组，其值表示我们想要在序列化中包含的相关模型的字段名称。我们只想包含 URL 和游戏名称，因此，代码将 `''url''` 和 `''name''`
    作为元组的成员。我们不想使用 `GameSerializer` 序列化器类来序列化与用户相关的游戏，因为我们想序列化更少的字段，因此，我们创建了 `UserGameSerializer`
    类。'
- en: The `UserSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. This class declares a `Meta` inner class that declares two attributes-`model`
    and `fields`. The `model` attribute specifies the model related to the serializer,
    that is, the `django.contrib.auth.models.User` class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserSerializer`类是`HyperlinkedModelSerializer`类的子类。这个类声明了一个`Meta`内部类，该类声明了两个属性-`model`和`fields`。`model`属性指定了与序列化器相关的模型，即`django.contrib.auth.models.User`类。'
- en: The `UserSerializer` class declares a `games` attribute as an instance of the
    previously explained `UserGameSerializer` with `many` and `read_only` equal to
    `True` because it is a one-to-many relationship and it is read-only. We use the
    `games` name that we specified as the `related_name` string value when we added
    the `owner` field as a `models.ForeignKey` instance in the `Game` model. This
    way, the `games` field will provide us with an array of URLs and names for each
    game that belongs to the user.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserSerializer`类声明了一个`games`属性，它是一个之前解释过的`UserGameSerializer`的实例，其中`many`和`read_only`等于`True`，因为这是一个一对多关系，并且是只读的。我们使用`games`名称，我们在将`owner`字段作为`models.ForeignKey`实例添加到`Game`模型时指定的`related_name`字符串值。这样，`games`字段将为我们提供属于用户的每个游戏的URL和名称数组。'
- en: 'We will make more changes to the `serializers.py` file in the `gamesapi/games`
    folder. We will add an `owner` field to the existing `GameSerializer` class. The
    following lines show the new code for the `GameSerializer` class. The new lines
    are highlighted. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对`gamesapi/games`文件夹中的`serializers.py`文件进行更多修改。我们将在现有的`GameSerializer`类中添加一个`owner`字段。以下行显示了`GameSerializer`类的新代码。新行被突出显示。示例的代码文件包含在`restful_python_chapter_03_04`文件夹中：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, the `GameSerializer` class declares an `owner` attribute as an instance
    of `serializers.ReadOnlyField` with `source` equal to `'owner.username'`. This
    way, we will serialize the value for the `username` field of the related `django.contrib.auth.User`
    hold in the `owner` field. We use the `ReadOnlyField` because the owner is automatically
    populated when an authenticated user creates a game, and therefore, it won't be
    possible to change the owner after a game has been created. This way, the `owner`
    field will provide us with the user name that created the game. In addition, we
    added `'owner'` to the field's string tuple.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`GameSerializer`类声明了一个`owner`属性，它是一个`serializers.ReadOnlyField`的实例，其`source`等于`'owner.username'`。这样，我们将序列化相关`django.contrib.auth.User`类中`owner`字段持有的`username`字段的值。我们使用`ReadOnlyField`是因为当认证用户创建游戏时，所有者会自动填充，因此，在创建游戏后不可能更改所有者。这样，`owner`字段将为我们提供创建游戏的用户名。此外，我们还向字段字符串元组中添加了`'owner'`。
- en: Creating a customized permission class for object-level permissions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为对象级权限创建自定义权限类
- en: 'Create a new Python file named `permissions.py` within the `games` folder and
    enter the following code that, declares the new `IsOwnerOrReadOnly` class. The
    code file for the sample is included in the `restful_python_chapter_03_04` folder:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`games`文件夹中创建一个名为`permissions.py`的新Python文件，并输入以下代码，该代码声明了新的`IsOwnerOrReadOnly`类。示例的代码文件包含在`restful_python_chapter_03_04`文件夹中：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `rest_framework.permissions.BasePermission` class is the base class from
    which all permission classes should inherit. The previous lines declare the `IsOwnerOrReadOnly`
    class as a subclass of the `BasePermission` class and overrides the `has_object_permission`
    method defined in the superclass that returns a `bool` value indicating whether
    the permission should be granted or not. If the HTTP verb specified in the request
    (`request.method`) is any of the three safe methods specified in `permission.SAFE_METHODS`
    (`GET`, `HEAD` , or `OPTIONS`), the `has_object_permission` method returns `True`
    and grants permission to the request. These HTTP verbs do not make changes to
    the related resources, and therefore, they are included in the `permissions.SAFE_METHODS`
    tuple of string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`rest_framework.permissions.BasePermission`类是所有权限类应该继承的基础类。前面的行声明了`IsOwnerOrReadOnly`类作为`BasePermission`类的子类，并覆盖了在超类中定义的`has_object_permission`方法，该方法返回一个`bool`值，指示是否应该授予权限。如果请求中指定的HTTP动词（`request.method`）是`permission.SAFE_METHODS`（`GET`、`HEAD`或`OPTIONS`）中指定的三个安全方法之一，则`has_object_permission`方法返回`True`并授予请求权限。这些HTTP动词不会更改相关资源，因此它们包含在字符串元组`permissions.SAFE_METHODS`中。'
- en: If the HTTP verb specified in the request (`request.method`) is not any of the
    three safe methods, the code returns `True` and grants permission only when the
    `owner` attribute of the received `obj` (`obj.owner`) matches the user that created
    the request (`request.user`). This way, only the owner of the related resource
    will be granted permission to requests that include HTTP verbs that aren't safe.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: We will use the new `IsOwnerOrReadOnly` permission class to make sure that only
    the game owners can make changes to an existing game. We will combine this permission
    class with the `rest_framework.permissions.IsAuthenticatedOrReadOnly` permission
    class that only allows read-only access to resources when the request is not authenticated
    as a user.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Persisting the user that makes a request
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to be able to list all the users and retrieve the details for a single
    user. We will create subclasses of the two following generic class views declared
    in `rest_framework.generics`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '`ListAPIView`: Implements the `get` method that retrieves a listing of a queryset'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RetrieveAPIView`: Implements the `get` method to retrieve a model instance'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go to the `gamesapi/games` folder and open the `views.py` file. Add the following
    code after the last line that declares the imports, before the declaration of
    the `GameCategoryList` class. The code file for the sample is included in the
    `restful_python_chapter_03_04` folder:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Add the following highlighted lines to the ApiRoot class declared in the `views.py`
    file. Now, we will be able to navigate to the user-related views throughout the
    browsable API. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Go to the `gamesapi/games` folder and open the `urls.py` file. Add the following
    elements to the `urlpatterns` string list. The new strings define the URL patterns
    that specify the regular expressions that have to be matched in the request to
    run a specific method for the previously created class based-views in the `views.py`
    file: `UserList` and `UserDetail`. The code file for the sample is included in
    the `restful_python_chapter_03_04` folder:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We have to add a line in the `urls.py` file in the `gamesapi` folder, specifically,
    the `gamesapi/urls.py` file. The file defines the root URL configurations and
    we want to include the URL patterns to allow the browsable API to display the
    login and logout views. The following lines show the new code for the `gamesapi/urls.py`
    file. The new line is highlighted. The code file for the sample is included in
    the `restful_python_chapter_03_04` folder:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We have to make changes to the `GameList` class-based view. We will override
    the `perform_create` method to populate the `owner` before a new `Game` instance
    is persisted in the database. The following lines show the new code for the `GameList`
    class in the `views.py` file. The new lines are highlighted. The code file for
    the sample is included in the `restful_python_chapter_03_04` folder:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `GameList` class inherits the `perform_create` method from the `rest_framework.mixins.CreateModelMixin`
    class. Remember that the `generics.ListCreateAPIView` class inherits from `CreateModelMixin`
    class and other classes. The code for the overridden `perform_create` method passes
    an additional `owner` field to the create method by setting a value for the `owner`
    argument for the call to the `serializer.save` method. The code sets the owner
    attribute to the value of `self.request.user`, that is, to the user associated
    to the request. This way, whenever a new game is persisted, it will save the user
    associated to the request as its owner.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Configuring permission policies
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will configure permission policies for the class-based views related
    to games. We will override the value for the `permission_classes` class attribute
    for the `GameList` and `GameDetail` classes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the new code for the `GameList` class in the `views.py`
    file. The new lines are highlighted. Don''t remove the code we added for the `perform_create`
    method for this class. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following lines show the new code for the `GameDetail` class in the `views.py`
    file. The new lines are highlighted. Don''t remove the code we added for the `perform_create`
    method for this class. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We added the same lines in the two classes. We have included the `IsAuthenticatedOrReadOnly`
    class and our previously created `IsOwnerOrReadOnly` permission class in the `permission_classes`
    tuple.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Setting a default value for a new required field in migrations
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have persisted many games in our database and added a new `owner` field for
    the games that is a required field. We don't want to delete all the existing games,
    and therefore, we will take advantage of some features in Django that make it
    easy for us to make the changes in the underlying database without losing the
    existing data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to retrieve the `id` for the `superuser` we have created to use
    it as the default owner for the existing games. Django will allow us to easily
    update the existing games to set the owner user for them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Run the following commands to retrieve the `id` from the `auth_user` table for
    the row that whose username is equal to `'superuser'`. Replace `superuser` with
    the user name you selected for the previously created superuser. In addition,
    replace `user_name` in the command with the user name you used to create the PostgreSQL
    database and `password` with your chosen password for this database user. The
    command assumes that you are running PostgreSQL on the same computer in which
    you are running the command. In case you are working with a SQLite database, you
    can run the equivalent command in the PostgreSQL command line or a GUI-based tool
    to execute the same query.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following lines show the output with the value for `id`: 1'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, run the following Python script to generate the migrations that will allow
    us to synchronize the database with the new field we added to the Game model:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Django will display the following question:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We want to provide the one-off default that will be set on all existing rows,
    and therefore, enter `1` to select the first option and press ***Enter*** .
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Django will display the following text asking us to enter the default value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Enter the value for the previously retrieved id, `1` in our example, and press
    Enter. The following lines show the output generated after running the preceding
    command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output indicates that the `gamesapi/games/migrations/0003_game_owner.py`
    file includes the code to add the field named `owner` to `game`. The following
    lines show the code for this file that was automatically generated by Django.
    The code file for the sample is included in the `restful_python_chapter_03_04`
    folder:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The code declares a subclass of the `django.db.migrations.Migration` class named
    `Migration` that defines an `operations` list with a `migrations.AddField` that
    will add the the owner field to the table related to the `game` model.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following python script to apply all the generated migrations
    and execute the changes in the database tables:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following lines show the output generated after running the previous command.
    Note that the ordering for the migrations might be different in your configuration:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: After we run the previous command, we will have a new `owner_id` field added
    to the `games_game` table in the PostgreSQL database. The existing rows in the
    `games_game` table will use the default value we indicated Django to use for the
    new `owner_id` field. We can use the PostgreSQL command line or any other application
    that allows us to easily check the contents of the PostreSQL database to check
    the `games_game` table that Django updated. In case you decide to continue working
    with SQLite, use the commands or tools related to this database.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to launch the interactive shell. Make sure you are
    within the `gamesapi` folder in the Terminal or Command Prompt:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You will notice that a line that says (**InteractiveConsole**) is displayed
    after the usual lines that introduce your default Python interactive shell. Enter
    the following code in the Python interactive to create another user that is not
    a superuser. We will use this user and the superuser to test our changes in the
    permissions policies. The code file for the sample is included in the `restful_python_chapter_03_04`
    folder, in the `users_test_01.py` file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'You can replace `kevin` with your desired user name, `kevin@eaxmple.com` with
    the e-mail and `kevinpassword` with the password you want to use for this user.
    However, take into account that we will be using these credentials in the following
    sections. Make sure you always replace the credentials with your own credentials:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, quit the interactive console by entering the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we can launch Django''s development server to compose and send HTTP requests.
    Execute any of the following two commands based on your needs to access the API
    in other devices or computers connected to your LAN. Remember that we analyzed
    the difference between them in [Chapter 1](ch01.html "Chapter 1. Developing RESTful
    APIs with Django"), *Developing RESTful APIs with Django*:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After we run any of the preceding commands, the development server will start
    listening at port `8000`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Composing requests with the necessary authentication
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to create a new game without
    authentication credentials:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following is the equivalent curl command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We will receive a `401 Unauthorized` status code in the response header and
    a detail message indicating that we didn''t provide authentication credentials
    in the JSON body. The following lines show a sample response:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If we want to create a new game, that is, to make a `POST` request to `/games/`,
    we need to provide authentication credentials using HTTP authentication. Now,
    we will compose and send an HTTP request to create a new game with authentication
    credentials, that is, with the `superuser` name and his password. Remember to
    replace `superuser` with the name you used for the `superuser` and `password`
    with the password you configured for this user:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If the new `Game` with the superuser user as its owner was successfully persisted
    in the database, the function returns an `HTTP 201 Created` status code and the
    recently persisted `Game` serialized to JSON in the response body. The following
    lines show an example response for the HTTP request, with the new `Game` object
    in the JSON response:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now, we will compose and send an HTTP request to update the `played` field value
    for the previously created game with authentication credentials. However, in this
    case, we will use the other user we created in Django to authenticate the request.
    Remember to replace `kevin` with the name you used for the user and `kevinpassword`
    with the password you configured for this user. In addition, replace `16` with
    the id generated for the previously created game in your configuration. We will
    use the `PATCH` method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We will receive a `403 Forbidden` status code in the response header and a
    detail message indicating that we do not have permission to perform the action
    in the JSON body. The owner for the game we want to update is `superuser` and
    the authentication credentials for this request use a different user. Thus, the
    operation is rejected by the `has_object_permission` method in the `IsOwnerOrReadOnly`
    class. The following lines show a sample response:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If we compose and send an HTTP request with the same authentication credentials
    for the same resource with the `GET` method, we will be able to retrieve the game
    that the specified user doesn''t own. It will work because `GET` is one of the
    safe methods and a user that is not the owner is allowed to read the resource.
    Remember to replace `kevin` with the name you used for the user and `kevinpassword`
    with the password you configured for this user. In addition, replace `16` with
    the id generated for the previously created game in your configuration:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Browsing the API with authentication credentials
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a web browser and enter `http://localhost:8000/`. Replace localhost by
    the IP of the computer that is running the Django development server in case you
    use another computer or device to run the browser. The browsable API will compose
    and send a `GET` request to `/` and will display the results of its execution,
    that is, the Api Root. You will notice that there is a **Log in** hyperlink in
    the upper-right corner.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Click Log in and the browser will display the Django REST Framework login page.
    Enter `kevin` in username, `kevinpassword` in password, and click **Log In**.
    Remember to replace `kevin` with the name you used for the user and `kevinpassword`
    with the password you configured for this user. Now, you will be logged in as
    `kevin` and all the requests you compose and send through the browsable API will
    use this user. You will be redirected again to the **Api Root** and you will notice
    the **Log In** hyperlink is replaced with the username (**kevin**) and a drop-down
    menu that allows you to Log Out. The following screenshot shows the Api Root after
    we are logged in as `kevin`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Click or tap on the URL on the right-hand side of **users**. In case you are
    browsing in localhost, the URL will be `http://localhost:8000/users/`. The Browsable
    API will render the web page for the **Users List**. The following lines show
    the JSON body with the first lines and the last lines with the results for the
    `GET` request to `localhost:8000/users/`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The `games` array includes the URL and the name for each game that the user
    owns because the `UserGameSerializer` class is serializing the content for each
    game:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Click or tap on one of the URLs for the games listed as owned by the `superuser`
    user. The Browsable API will render the web page for the **Game Detail**. Click
    or tap on **OPTIONS** and the **DELETE** button will appear. Click or tap on **DELETE**.
    The web browser will display a confirmation dialog box. Click or tap on **DELETE**.
    We will receive a `403 Forbidden` status code in the response header and a detail
    message indicating that we do not have permission to perform the action in the
    JSON body.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The owner for the game we want to delete is `superuser` and the authentication
    credentials for this request use a different user, specifically, `kevin`. Thus,
    the operation is rejected by the `has_object_permission` method in the `IsOwnerOrReadOnly`
    class. The following screenshot shows a sample response:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Browsing the API with authentication credentials](img/image_03_001.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also take advantage of other authentication plugins that Django REST
    Framework provides us. You can read more about all the possibilities that the
    framework provides us for authentication at [http://www.django-rest-framework.org/api-guide/authentication/](http://www.django-rest-framework.org/api-guide/authentication/)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Which is the most appropriate HTTP method to update a single field for an existing
    resource:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PUT`'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`POST  `'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PATCH`'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following pagination classes provides a limit/offset based style
    in Django REST Framework:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.pagination.LimitOffsetPagination`'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.pagination.LimitOffsetPaging`'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.styles.LimitOffsetPagination`'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `rest_framework.authentication.BasicAuthentication` class:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Works with Django's session framework for authentication.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides an HTTP Basic authentication against username and password.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides a simple token based authentication.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `rest_framework.authentication.SessionAuthentication` class:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Works with Django's session framework for authentication.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides an HTTP Basic authentication against username and password.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides a simple token based authentication.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The value of which of the following settings keys specify a global setting
    with a tuple of string whose values indicate the classes that we want to use for
    authentication:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DEFAULT_AUTH_CLASSES`'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AUTHENTICATION_CLASSES`'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DEFAULT_AUTHENTICATION_CLASSES`'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we improved the REST API in many ways. We added unique constraints
    to the model and updated the database, we made it easy to update single fields
    with the `PATCH` method and we took advantage of pagination.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Then, we started working with authentication, permissions, and throttling. We
    added security-related data to the models and we updated the database. We made
    numerous changes in the different pieces of code to achieve a specific security
    goal and we took advantage of Django REST Framework authentication and permissions
    features.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built an improved and complex API that takes into account authentication
    and uses permission policies, we will use additional abstractions included in
    the framework, we will add throttling and tests, which is what we are going to
    discuss in the next chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
