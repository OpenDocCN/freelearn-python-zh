["```py\nimport pyupm_adxl335 as upmAdxl335\nimport time\n\nclass Accelerometer:\n    def __init__(self, pinX, pinY, pinZ):\n        self.accelerometer = upmAdxl335.ADXL335(\n            pinX, pinY, pinZ)\n        self.accelerometer.calibrate()\n        self.x_acceleration_fp = upmAdxl335.new_floatPointer()\n        self.y_acceleration_fp = upmAdxl335.new_floatPointer()\n        self.z_acceleration_fp = upmAdxl335.new_floatPointer()\n        self.x_acceleration = 0.0\n        self.y_acceleration = 0.0\n        self.z_acceleration = 0.0\n\n    def calibrate(self):\n        self.accelerometer.calibrate()\n\n    def measure_acceleration(self):\n        # Retrieve the acceleration values for the three axis\n        self.accelerometer.acceleration(\n            self.x_acceleration_fp,\n            self.y_acceleration_fp,\n            self.z_acceleration_fp)\n        self.x_acceleration = upmAdxl335.floatPointer_value(\n            self.x_acceleration_fp)\n        self.y_acceleration = upmAdxl335.floatPointer_value(\n            self.y_acceleration_fp)\n        self.z_acceleration = upmAdxl335.floatPointer_value(\n            self.z_acceleration_fp)\n```", "```py\nif __name__ == \"__main__\":\n    # The accelerometer is connected to analog pins A0, A1 and A2\n    # A0 -> x\n    # A1 -> y\n    # A2 -> z\n    accelerometer = Accelerometer(0, 1, 2)\n    # Calibrate the accelerometer\n    accelerometer.calibrate()\n\n    while True:\n        accelerometer.measure_acceleration()\n        print(\"Acceleration for x: {0}g\".format(accelerometer.x_acceleration))\n        print(\"Acceleration for y: {0}g\".format(accelerometer.y_acceleration))\n        print(\"Acceleration for z: {0}g\".format(accelerometer.z_acceleration))\n        # Sleep 0.5 seconds (500 milliseconds)\n        time.sleep(0.5)\n```", "```py\npython iot_python_chapter_07_01.py\n```", "```py\nAcceleration for x: 0.0g\nAcceleration for y: 0.4296875g\nAcceleration for z: 0.0g\nAcceleration for x: 0.0g\nAcceleration for y: 0.52734375g\nAcceleration for z: 0.0g\nAcceleration for x: 0.0g\nAcceleration for y: 0.60546875g\nAcceleration for z: 0.0g\nAcceleration for x: 0.01953125g\nAcceleration for y: 0.68359375g\nAcceleration for z: 0.0g\n```", "```py\nimport pyupm_adxl345 as upmAdxl345\nimport time\n\nclass Accelerometer:\n    def __init__(self, bus):\n        self.accelerometer = upmAdxl345.Adxl345(bus)\n        self.x_acceleration = 0.0\n        self.y_acceleration = 0.0\n        self.z_acceleration = 0.0\n\n    def measure_acceleration(self):\n        # Update the acceleration values for the three axis\n        self.accelerometer.update()\n        # Retrieve the acceleration values for the three axis\n        acceleration_array = \\\n            self.accelerometer.getAcceleration()\n        self.x_acceleration = acceleration_array[0]\n        self.y_acceleration = acceleration_array[1]\n        self.z_acceleration = acceleration_array[2]\n```", "```py\nif __name__ == \"__main__\":\n    accelerometer = Accelerometer(0)\n    while True:\n        accelerometer.measure_acceleration()\n        print(\"Acceleration for x: {:5.2f}g\".\n              format(accelerometer.x_acceleration))\n        print(\"Acceleration for y: {:5.2f}g\".\n              format(accelerometer.y_acceleration))\n        print(\"Acceleration for z: {:5.2f}g\".\n              format(accelerometer.z_acceleration))\n        # Sleep 0.5 seconds (500 milliseconds)\n        time.sleep(0.5)\n```", "```py\npython iot_python_chapter_07_02.py\n```", "```py\nAcceleration for x: 0.000g\nAcceleration for y: 0.056g\nAcceleration for z: 0.000g\nAcceleration for x: 0.000g\nAcceleration for y: 0.088g\nAcceleration for z: 0.000g\nAcceleration for x: 0.000g\nAcceleration for y: 0.872g\nAcceleration for z: 0.056g\n```", "```py\nclass Adxl345:\n    # Read buffer length\n    READ_BUFFER_LENGTH = 6\n    # I2C address for the ADXL345 accelerometer\n    ADXL345_I2C_ADDR = 0x53\n    ADXL345_ID = 0x00\n    # Control registers\n    ADXL345_OFSX = 0x1E\n    ADXL345_OFSY = 0x1F\n    ADXL345_OFSZ = 0x20\n    ADXL345_TAP_THRESH = 0x1D\n    ADXL345_TAP_DUR = 0x21\n    ADXL345_TAP_LATENCY = 0x22\n    ADXL345_ACT_THRESH = 0x24\n    ADXL345_INACT_THRESH = 0x25\n    ADXL345_INACT_TIME = 0x26\n    ADXL345_INACT_ACT_CTL = 0x27\n    ADXL345_FALL_THRESH = 0x28\n    ADXL345_FALL_TIME = 0x29\n    ADXL345_TAP_AXES = 0x2A\n    ADXL345_ACT_TAP_STATUS = 0x2B\n    # Interrupt registers\n    ADXL345_INT_ENABLE = 0x2E\n    ADXL345_INT_MAP = 0x2F\n    ADXL345_INT_SOURCE = 0x30\n    # Data registers (read only)\n    ADXL345_XOUT_L = 0x32\n    ADXL345_XOUT_H = 0x33\n    ADXL345_YOUT_L = 0x34\n    ADXL345_YOUT_H = 0x35\n    ADXL345_ZOUT_L = 0x36\n    ADXL345_ZOUT_H = 0x37\n    DATA_REG_SIZE = 6\n    # Data and power management\n    ADXL345_BW_RATE = 0x2C\n    ADXL345_POWER_CTL = 0x2D\n    ADXL345_DATA_FORMAT = 0x31\n    ADXL345_FIFO_CTL = 0x38\n    ADXL345_FIFO_STATUS = 0x39\n    # Useful values\n    ADXL345_POWER_ON = 0x08\n    ADXL345_AUTO_SLP = 0x30\n    ADXL345_STANDBY = 0x00\n    # Scales and resolution\n    ADXL345_FULL_RES = 0x08\n    ADXL345_10BIT = 0x00\n    ADXL345_2G = 0x00\n    ADXL345_4G = 0x01\n    ADXL345_8G = 0x02\n    ADXL345_16G = 0x03\n\n    def __init__(self, bus):\n        # Init bus and reset chip\n        self.i2c = mraa.I2c(bus)\n        # Set the slave to talk to\n        if self.i2c.address(self.__class__.ADXL345_I2C_ADDR) != mraa.SUCCESS:\n            raise Exception(\"i2c.address() failed\")\n        message = bytearray(\n            [self.__class__.ADXL345_POWER_CTL,\n             self.__class__.ADXL345_POWER_ON])\n        if self.i2c.write(message) != mraa.SUCCESS:\n            raise Exception(\"i2c.write() control register failed\")\n        if self.i2c.address(self.__class__.ADXL345_I2C_ADDR) != mraa.SUCCESS:\n            raise Exception(\"i2c.address() failed\")\n        message = bytearray(\n            [self.__class__.ADXL345_DATA_FORMAT,\n             self.__class__.ADXL345_16G | self.__class__.ADXL345_FULL_RES])\n        if self.i2c.write(message) != mraa.SUCCESS:\n            raise Exception(\"i2c.write() mode register failed\")\n        # 2.5V sensitivity is 256 LSB/g = 0.00390625 g/bit\n        # 3.3V x and y sensitivity is 265 LSB/g = 0.003773584 g/bit, z is the same\n        self.x_offset = 0.003773584\n        self.y_offset = 0.003773584\n        self.z_offset = 0.00390625\n        self.x_acceleration = 0.0\n        self.y_acceleration = 0.0\n        self.z_acceleration = 0.0\n        self.update()\n\n    def update(self):\n        # Set the slave to talk to\n        self.i2c.address(self.__class__.ADXL345_I2C_ADDR)\n        self.i2c.writeByte(self.__class__.ADXL345_XOUT_L)\n        self.i2c.address(self.__class__.ADXL345_I2C_ADDR)\n        xyz_raw_acceleration = self.i2c.read(self.__class__.DATA_REG_SIZE)\n        x_raw_acceleration = (xyz_raw_acceleration[1] << 8) | xyz_raw_acceleration[0]\n        y_raw_acceleration = (xyz_raw_acceleration[3] << 8) | xyz_raw_acceleration[2]\n        z_raw_acceleration = (xyz_raw_acceleration[5] << 8) | xyz_raw_acceleration[4]\n        self.x_acceleration = x_raw_acceleration * self.x_offset\n        self.y_acceleration = y_raw_acceleration * self.y_offset\n        self.z_acceleration = z_raw_acceleration * self.z_offset\n```", "```py\nself.i2c = mraa.I2c(bus)\n```", "```py\nif self.i2c.address(self.__class__.ADXL345_I2C_ADDR) != mraa.SUCCESS:\n    raise Exception(\"i2c.address() failed\")\n```", "```py\nmessage = bytearray(\n    [self.__class__.ADXL345_POWER_CTL,\n     self.__class__.ADXL345_POWER_ON])\nif self.i2c.write(message) != mraa.SUCCESS:\n    raise Exception(\"i2c.write() control register failed\")\n```", "```py\nif self.i2c.address(self.__class__.ADXL345_I2C_ADDR) != mraa.SUCCESS:\n    raise Exception(\"i2c.address() failed\")\nmessage = bytearray(\n    [self.__class__.ADXL345_DATA_FORMAT,\n     self.__class__.ADXL345_16G | self.__class__.ADXL345_FULL_RES])\nif self.i2c.write(message) != mraa.SUCCESS:\n    raise Exception(\"i2c.write() mode register failed\")\n```", "```py\nmessage = bytearray(\n    [self.__class__.ADXL345_DATA_FORMAT,\n     self.__class__.ADXL345_4G | self.__class__.ADXL345_FULL_RES])\n```", "```py\nself.i2c.address(self.__class__.ADXL345_I2C_ADDR)\nself.i2c.writeByte(self.__class__.ADXL345_XOUT_L)\n```", "```py\nself.i2c.address(self.__class__.ADXL345_I2C_ADDR)\nxyz_raw_acceleration = self.i2c.read(self.__class__.DATA_REG_SIZE)\n```", "```py\nx_raw_acceleration = (xyz_raw_acceleration[1] << 8) | xyz_raw_acceleration[0]\ny_raw_acceleration = (xyz_raw_acceleration[3] << 8) | xyz_raw_acceleration[2]\nz_raw_acceleration = (xyz_raw_acceleration[5] << 8) | xyz_raw_acceleration[4]\n```", "```py\nself.x_acceleration = x_raw_acceleration * self.x_offset\nself.y_acceleration = y_raw_acceleration * self.y_offset\nself.z_acceleration = z_raw_acceleration * self.z_offset\n```", "```py\nclass Accelerometer:\n    def __init__(self, bus):\n        self.accelerometer = Adxl345(bus)\n        self.x_acceleration = 0.0\n        self.y_acceleration = 0.0\n        self.z_acceleration = 0.0\n\n    def measure_acceleration(self):\n        # Update the acceleration values for the three axis\n        self.accelerometer.update()\n        self.x_acceleration = self.accelerometer.x_acceleration\n        self.y_acceleration = self.accelerometer.y_acceleration\n        self.z_acceleration = self.accelerometer.z_acceleration\n```", "```py\nimport pyupm_grove as upmGrove\nimport time\n\nclass TemperatureSensor:\n    def __init__(self, analog_pin):\n        self.temperature_sensor = upmGrove.GroveTemp(analog_pin)\n        self.temperature_celsius = 0.0\n        self.temperature_fahrenheit = 0.0\n\n    def measure_temperature(self):\n        # Retrieve the temperature expressed in Celsius degrees\n        temperature_celsius = self.temperature_sensor.value()\n        self.temperature_celsius = temperature_celsius\n        self.temperature_fahrenheit = \\\n            (temperature_celsius * 9.0 / 5.0) + 32.0\n```", "```py\nif __name__ == \"__main__\":\n    # The temperature sensor is connected to analog pin A0\n    temperature_sensor = TemperatureSensor(0)\n\n    while True:\n        temperature_sensor.measure_temperature()\n        print(\"Ambient temperature in degrees Celsius: {0}\".\n              format(temperature_sensor.temperature_celsius))\n        print(\"Ambient temperature in degrees Fahrenheit: {0}\".\n              format(temperature_sensor.temperature_fahrenheit))\n        # Sleep 10 seconds (10000 milliseconds)\n        time.sleep(10)\n```", "```py\npython iot_python_chapter_07_04.py\n```", "```py\nAmbient temperature in degrees Celsius: 13\nAmbient temperature in degrees Fahrenheit: 55.4\nAmbient temperature in degrees Celsius: 14\nAmbient temperature in degrees Fahrenheit: 57.2\nAmbient temperature in degrees Celsius: 15\nAmbient temperature in degrees Fahrenheit: 59\nAmbient temperature in degrees Celsius: 16\nAmbient temperature in degrees Fahrenheit: 60.8\n```", "```py\nimport pyupm_th02 as upmTh02\nimport time\n\nclass TemperatureAndHumiditySensor:\n    def __init__(self, bus):\n        self.th02_sensor = upmTh02.TH02(bus)\n        self.temperature_celsius = 0.0\n        self.temperature_fahrenheit = 0.0\n        self.humidity = 0.0\n\n    def measure_temperature_and_humidity(self):\n        # Retrieve the temperature expressed in Celsius degrees\n        temperature_celsius = self.th02_sensor.getTemperature()\n        self.temperature_celsius = temperature_celsius\n        self.temperature_fahrenheit = \\\n            (temperature_celsius * 9.0 / 5.0) + 32.0\n        # Retrieve the humidity\n        self.humidity = self.th02_sensor.getHumidity()\n```", "```py\nif __name__ == \"__main__\":\n    temperature_and_humidity_sensor = \\\n        TemperatureAndHumiditySensor(0)\n\n    while True:\n        temperature_and_humidity_sensor.\\\n            measure_temperature_and_humidity()\n        print(\"Ambient temperature in degrees Celsius: {0}\".\n              format(temperature_and_humidity_sensor.temperature_celsius))\n        print(\"Ambient temperature in degrees Fahrenheit: {0}\".\n              format(temperature_and_humidity_sensor.temperature_fahrenheit))\n        print(\"Ambient humidity: {0}%\".\n              format(temperature_and_humidity_sensor.humidity))\n        # Sleep 10 seconds (10000 milliseconds)\n        time.sleep(10)\n```", "```py\npython iot_python_chapter_07_05.py\n```", "```py\nAmbient temperature in degrees Celsius: 24\nAmbient temperature in degrees Fahrenheit: 73.4\nAmbient humidity: 48%\n```"]