- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: RESTful API Building
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API构建
- en: An **Application Programming Interface** (**API**) can be summarized as a developer’s
    interface with an application. Just as end users have a visible frontend user
    interface with which they can work on and talk to the application, developers
    also need an interface to it. **Representational State Transfer** (**REST**) is
    not a protocol or a standard. It is just a software architectural style or a set
    of suggestions defined for writing applications, the aim of which is to simplify
    the interfaces within and without the application. When web service APIs are written
    in a way that adheres to the REST definitions, then they are known as RESTful
    APIs. Being RESTful keeps the API decoupled from the internal application details.
    This results in ease of scalability and keeps things simple. The uniform interface
    ensures that each and every request is documented.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）可以概括为开发者与应用程序的接口。正如最终用户有一个可见的前端用户界面，他们可以通过它与应用程序交互和交流一样，开发者也需要一个与之交互的接口。**表示状态转换**（**REST**）不是一个协议或标准。它只是一个软件架构风格或一系列为编写应用程序而定义的建议，其目的是简化应用程序内部和外部的接口。当以符合REST定义的方式编写网络服务API时，它们被称为RESTful
    API。保持RESTful可以使API与内部应用程序细节解耦。这导致易于扩展并保持简单。统一的接口确保每个请求都有文档记录。'
- en: Information
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: It is a topic of debate as to whether REST or simple object access protocol
    (SOAP) is better. This is actually a subjective question, as it depends on what
    needs to be done. Each has its own benefits and should be chosen based on the
    requirements of the application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关于REST或简单的对象访问协议(SOAP)哪个更好，这是一个有争议的话题。这实际上是一个主观问题，因为它取决于需要做什么。每种方法都有自己的优点，应根据应用程序的需求进行选择。
- en: REST calls for segregating your API into logical resources, which can be accessed
    and manipulated using HTTP requests, where each request consists of one of the
    following methods – `GET`, `POST`, `PUT`, `PATCH`, and `DELETE` (there can be
    more, but these are the ones used most frequently). Each of these methods has
    a specific meaning. One of the key implied principles of REST is that the logical
    grouping of resources should be easily understandable and, hence, provide simplicity
    along with portability.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: REST调用用于将API分割成逻辑资源，这些资源可以通过HTTP请求访问和操作，其中每个请求都包含以下方法之一——`GET`、`POST`、`PUT`、`PATCH`和`DELETE`（可能有更多，但这些都是最常用的）。这些方法中的每一个都有其特定的含义。REST的一个关键隐含原则是资源的逻辑分组应该是易于理解的，因此可以提供简单性和可移植性。
- en: 'We have a resource called `product`, as used in our book hitherto. Now, let’s
    see how we can logically map our API calls to the resource segregation:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`product`的资源，正如我们在本书中迄今为止所使用的。现在，让我们看看我们如何逻辑地将我们的API调用映射到资源分割：
- en: '`GET /products/1`: This gets the product with an ID of `1`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /products/1`: 这将获取ID为`1`的产品'
- en: '`GET /products`: This gets the list of products'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /products`: 这将获取产品列表'
- en: '`POST /products`: This creates a new product'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /products`: 这将创建一个新的产品'
- en: '`PUT /products/1`: This replaces or recreates the product with an ID of `1`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /products/1`: 这将替换或重新创建ID为`1`的产品'
- en: '`PATCH /products/1`: This partially updates the product with an ID of `1`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH /products/1`: 这将部分更新ID为`1`的产品'
- en: '`DELETE /products/1`: This deletes the product with an ID of `1`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /products/1`: 这将删除ID为`1`的产品'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Creating a class-based REST interface
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于类的REST接口
- en: Creating an extension-based REST interface
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于扩展的REST接口
- en: Creating a complete RESTful API
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建完整的RESTful API
- en: Creating a class-based REST interface
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于类的REST接口
- en: We saw how class-based views work in Flask, using the concept of pluggable views,
    in the *Writing class-based views* recipe in [*Chapter 4*](B19111_04.xhtml#_idTextAnchor184),
    *Working with Views*. In this recipe, we will now see how we can use the same
    to create views, which will provide a REST interface to our application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B19111_04.xhtml#_idTextAnchor184)的*编写基于类的视图*菜谱中看到了如何在Flask中使用可插拔视图的概念，*与视图一起工作*。在这个菜谱中，我们现在将看到如何使用相同的方法来创建视图，这些视图将为我们的应用程序提供REST接口。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Let’s take a simple view that will handle the REST-style calls to our `Product`
    model.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的视图，它将处理对`Product`模型的REST风格调用。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We simply have to modify our views for product handling to extend the `MethodView`
    class in `views.py`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需修改`views.py`中的产品处理视图，以扩展`MethodView`类：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding `get()` method searches for the product and sends back a JSON
    result. Similarly, we can write the `post()`, `put()`, and `delete()` methods
    too:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着的 `get()` 方法会查找产品并发送回 JSON 结果。同样，我们也可以编写 `post()`、`put()` 和 `delete()` 方法：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Many of us would question why we have no routing here. To include routing,
    we have to do the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人会质疑为什么这里没有路由。要包含路由，我们必须做以下事情：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first statement here converts the class to an actual view function internally
    that can be used with the routing system. The next two statements are the URL
    rules corresponding to the calls that can be made.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里第一条语句将类内部转换为实际的可用于路由系统的视图函数。接下来的两个语句是与可以进行的调用相对应的 URL 规则。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MethodView` class identified the type of HTTP method in the sent request
    and converted the name to lowercase. Then, it matched this to the methods defined
    in the class and called the matched method. So, if we make a `GET` call to `ProductView`,
    it will automatically be mapped to the `get()` method and processed accordingly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`MethodView` 类识别了发送请求中使用的 HTTP 方法类型，并将名称转换为小写。然后，它将此与类中定义的方法进行匹配，并调用匹配的方法。因此，如果我们向
    `ProductView` 发起 `GET` 调用，它将自动映射到 `get()` 方法并相应处理。'
- en: Creating an extension-based REST interface
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于扩展的 REST 接口
- en: In the previous recipe, *Creating a class-based REST interface*, we saw how
    to create a REST interface using pluggable views. In this recipe, we will use
    an extension called **Flask- RESTful**, which is written over the same pluggable
    views we used in the previous recipe, but which handles a lot of nuances by itself
    to allow us developers to focus on actual API development. It is also independent
    of **object-relational mapping** (**ORM**), so there are no strings attached to
    the ORM we may want to use.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱 *创建基于类的 REST 接口* 中，我们看到了如何使用可插拔视图创建 REST 接口。在这个菜谱中，我们将使用一个名为 **Flask-RESTful**
    的扩展，它是基于我们在上一个菜谱中使用的相同可插拔视图编写的，但它通过自己处理许多细微差别，使我们开发者能够专注于实际的 API 开发。它也独立于 **对象关系映射**（**ORM**），因此我们想要使用的
    ORM 上没有附加条件。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we will begin with the installation of the extension:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从安装扩展开始：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will modify the catalog application from the last recipe to add a REST interface
    using this extension.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改上一个菜谱中的目录应用程序，使用此扩展添加 REST 接口。
- en: How to do it…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As always, start with changes to the application’s configuration in `my_app/__init__.py`,
    which will look something like the following lines of code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，从 `my_app/__init__.py` 中应用程序配置的更改开始，它看起来像以下几行代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `app` is our Flask application object/instance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`app` 是我们的 Flask 应用程序对象/实例。
- en: 'Next, create the API inside the `views.py` file. Here, we will just try to
    understand how to lay out the skeleton of the API. Actual methods and handlers
    will be covered in the *Creating a complete RESTful* *API* recipe:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `views.py` 文件中创建 API。在这里，我们只是尝试了解如何安排 API 的框架。实际的方法和处理器将在 *创建完整的 RESTful
    API* 菜谱中介绍：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding API structure is self-explanatory. Consider the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 API 结构是自我解释的。考虑以下代码：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we created the routing for `ProductApi`, and we can specify multiple routes
    as necessary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 `ProductApi` 创建了路由，并且可以根据需要指定多个路由。
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will see how this REST interface works on the Python shell using the `requests`
    library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `requests` 库在 Python shell 中查看这个 REST 接口是如何工作的。
- en: Information
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: '`requests` is a very popular Python library that makes the rendering of HTTP
    requests very easy. It can simply be installed by running the `$ pip install`
    `requests` command.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests` 是一个非常流行的 Python 库，它使得 HTTP 请求的渲染变得非常简单。只需运行 `$ pip install` `requests`
    命令即可安装。'
- en: 'The command will show the following information:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将显示以下信息：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding snippet, we saw that all our requests are properly routed to
    the respective methods; this is evident from the response received.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们看到所有我们的请求都正确地路由到了相应的方法；这从收到的响应中可以明显看出。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the following recipe, *Creating a complete RESTful API*, to see the
    API skeleton from this recipe come to life.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下菜谱，*创建完整的 RESTful API*，以查看本菜谱中的 API 框架如何变得生动。
- en: Creating a complete RESTful API
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建完整的 RESTful API
- en: In this recipe, we will convert the API structure created in the last recipe,
    *Creating an extension-based REST interface*, into a full-fledged RESTful API.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将把在最后一个菜谱 *创建基于扩展的 REST 接口* 中创建的 API 结构转换为完整的 RESTful API。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will take the API skeleton from the last recipe as a basis to create a completely
    functional SQLAlchemy-independent RESTful API. Although we will use SQLAlchemy
    as the ORM for demonstration purposes, this recipe can be written in a similar
    fashion for any ORM or underlying database.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于最后一个菜谱中的API骨架来创建一个完全独立的SQLAlchemy RESTful API。虽然我们将使用SQLAlchemy作为演示目的的ORM，但这个菜谱可以用类似的方式为任何ORM或底层数据库编写。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The following lines of code are the complete RESTful API for the `Product` model.
    These code snippets will go into the `views.py` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行是`Product`模型的完整RESTful API。这些代码片段将放入`views.py`文件中。
- en: 'Start with imports and add `parser`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从导入开始并添加`parser`：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding snippet, we created `parser` for the arguments that we expected
    to have in our requests for `POST` and `PUT`. The request expects each of the
    arguments to have a value. If a value is missing for any argument, then `None`
    is used as the value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们为`POST`和`PUT`请求中预期的参数创建了`parser`。请求期望每个参数都有一个值。如果任何参数缺少值，则使用`None`作为值。
- en: 'Write the method as shown in the following code block to fetch products:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下代码块所示编写方法来获取产品：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding `get()` method corresponds to `GET` requests and returns a paginated
    list of products if no `id` is passed; otherwise, it returns the corresponding
    product.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`get()`方法对应于`GET`请求，如果没有传递`id`，则返回分页的产品列表；否则，返回相应的产品。
- en: 'Create the following method to add a new product:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下方法来添加一个新的产品：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding `post()` method will lead to the creation of a new product by
    making a `POST` request.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`post()`方法将通过发送`POST`请求来创建一个新的产品。
- en: 'Write the following method to update or essentially replace an existing product
    record:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编写以下方法来更新或本质上替换现有的产品记录：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we updated an existing product using a `PUT` request.
    Here, we should provide all the arguments even if we intend to change a few of
    them. This is because of the conventional way in which `PUT` has been defined
    to work. If we want to have a request where we intend to pass only those arguments
    that we intend to update, then we should use a `PATCH` request. I would urge you
    to try that by yourself.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`PUT`请求更新了一个现有的产品。在这里，即使我们打算更改其中的一些参数，我们也应该提供所有参数。这是因为`PUT`被定义成传统的工作方式。如果我们想要一个只传递我们打算更新的参数的请求，那么我们应该使用`PATCH`请求。我敦促你自己尝试一下。
- en: 'Delete a product using the following method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法删除产品：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Last, but not least, we have the `DELETE` request, which will simply delete
    the product that matches the `id` passed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们有`DELETE`请求，它将简单地删除与传递的`id`匹配的产品。
- en: 'The following is a definition of all the possible routes that our API can accommodate:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们API可以容纳的所有可能路由的定义：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To test and see how this works, we can send a number of requests using the
    Python shell by means of the `requests` library:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试和查看它是如何工作的，我们可以通过Python shell使用`requests`库发送多个请求：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We made a `GET` request to fetch the list of products, but there is no record
    of this. Let’s create a new product now:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送了一个`GET`请求来获取产品列表，但没有任何记录。现在让我们创建一个新的产品：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We sent a `POST` request to create a product with some data. Note the `headers`
    argument in the request. Each `POST` request sent in Flask-RESTful should have
    this header. Now, we should look for the list of products again:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送了一个`POST`请求来创建一个带有一些数据的产品。注意请求中的`headers`参数。在Flask-RESTful中发送的每个`POST`请求都应该有这个头。现在，我们应该再次查找产品列表：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we look for the products again via a `GET` request, we can see that we now
    have a newly created product in the database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次通过`GET`请求查找产品，我们可以看到现在数据库中有一个新创建的产品。
- en: I will leave it to you to try to incorporate other API requests by themselves.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把它留给你去尝试独立地整合其他API请求。
- en: Important
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: An important facet of RESTful APIs is the use of token-based authentication
    to allow only limited and authenticated users to be able to use and make calls
    to the API. I urge you to explore this on your own. We covered the basics of user
    authentication in [*Chapter 6*](B19111_06.xhtml#_idTextAnchor328), *Authenticating
    in Flask*, which will serve as a basis for this concept.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API的一个重要方面是使用基于令牌的认证，以允许只有有限的认证用户能够使用和调用API。我敦促你自己去探索这一点。我们在[*第6章*](B19111_06.xhtml#_idTextAnchor328)中介绍了用户认证的基础，这将为这个概念提供基础。
