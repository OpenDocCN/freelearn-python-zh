- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RESTful API Building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Application Programming Interface** (**API**) can be summarized as a developer’s
    interface with an application. Just as end users have a visible frontend user
    interface with which they can work on and talk to the application, developers
    also need an interface to it. **Representational State Transfer** (**REST**) is
    not a protocol or a standard. It is just a software architectural style or a set
    of suggestions defined for writing applications, the aim of which is to simplify
    the interfaces within and without the application. When web service APIs are written
    in a way that adheres to the REST definitions, then they are known as RESTful
    APIs. Being RESTful keeps the API decoupled from the internal application details.
    This results in ease of scalability and keeps things simple. The uniform interface
    ensures that each and every request is documented.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: It is a topic of debate as to whether REST or simple object access protocol
    (SOAP) is better. This is actually a subjective question, as it depends on what
    needs to be done. Each has its own benefits and should be chosen based on the
    requirements of the application.
  prefs: []
  type: TYPE_NORMAL
- en: REST calls for segregating your API into logical resources, which can be accessed
    and manipulated using HTTP requests, where each request consists of one of the
    following methods – `GET`, `POST`, `PUT`, `PATCH`, and `DELETE` (there can be
    more, but these are the ones used most frequently). Each of these methods has
    a specific meaning. One of the key implied principles of REST is that the logical
    grouping of resources should be easily understandable and, hence, provide simplicity
    along with portability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a resource called `product`, as used in our book hitherto. Now, let’s
    see how we can logically map our API calls to the resource segregation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /products/1`: This gets the product with an ID of `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /products`: This gets the list of products'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /products`: This creates a new product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /products/1`: This replaces or recreates the product with an ID of `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /products/1`: This partially updates the product with an ID of `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /products/1`: This deletes the product with an ID of `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class-based REST interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an extension-based REST interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a complete RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a class-based REST interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how class-based views work in Flask, using the concept of pluggable views,
    in the *Writing class-based views* recipe in [*Chapter 4*](B19111_04.xhtml#_idTextAnchor184),
    *Working with Views*. In this recipe, we will now see how we can use the same
    to create views, which will provide a REST interface to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a simple view that will handle the REST-style calls to our `Product`
    model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We simply have to modify our views for product handling to extend the `MethodView`
    class in `views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `get()` method searches for the product and sends back a JSON
    result. Similarly, we can write the `post()`, `put()`, and `delete()` methods
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Many of us would question why we have no routing here. To include routing,
    we have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first statement here converts the class to an actual view function internally
    that can be used with the routing system. The next two statements are the URL
    rules corresponding to the calls that can be made.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MethodView` class identified the type of HTTP method in the sent request
    and converted the name to lowercase. Then, it matched this to the methods defined
    in the class and called the matched method. So, if we make a `GET` call to `ProductView`,
    it will automatically be mapped to the `get()` method and processed accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an extension-based REST interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *Creating a class-based REST interface*, we saw how
    to create a REST interface using pluggable views. In this recipe, we will use
    an extension called **Flask- RESTful**, which is written over the same pluggable
    views we used in the previous recipe, but which handles a lot of nuances by itself
    to allow us developers to focus on actual API development. It is also independent
    of **object-relational mapping** (**ORM**), so there are no strings attached to
    the ORM we may want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will begin with the installation of the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will modify the catalog application from the last recipe to add a REST interface
    using this extension.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, start with changes to the application’s configuration in `my_app/__init__.py`,
    which will look something like the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `app` is our Flask application object/instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the API inside the `views.py` file. Here, we will just try to
    understand how to lay out the skeleton of the API. Actual methods and handlers
    will be covered in the *Creating a complete RESTful* *API* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding API structure is self-explanatory. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created the routing for `ProductApi`, and we can specify multiple routes
    as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will see how this REST interface works on the Python shell using the `requests`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: '`requests` is a very popular Python library that makes the rendering of HTTP
    requests very easy. It can simply be installed by running the `$ pip install`
    `requests` command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command will show the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we saw that all our requests are properly routed to
    the respective methods; this is evident from the response received.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the following recipe, *Creating a complete RESTful API*, to see the
    API skeleton from this recipe come to life.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a complete RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will convert the API structure created in the last recipe,
    *Creating an extension-based REST interface*, into a full-fledged RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will take the API skeleton from the last recipe as a basis to create a completely
    functional SQLAlchemy-independent RESTful API. Although we will use SQLAlchemy
    as the ORM for demonstration purposes, this recipe can be written in a similar
    fashion for any ORM or underlying database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following lines of code are the complete RESTful API for the `Product` model.
    These code snippets will go into the `views.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with imports and add `parser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we created `parser` for the arguments that we expected
    to have in our requests for `POST` and `PUT`. The request expects each of the
    arguments to have a value. If a value is missing for any argument, then `None`
    is used as the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the method as shown in the following code block to fetch products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `get()` method corresponds to `GET` requests and returns a paginated
    list of products if no `id` is passed; otherwise, it returns the corresponding
    product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following method to add a new product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `post()` method will lead to the creation of a new product by
    making a `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method to update or essentially replace an existing product
    record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we updated an existing product using a `PUT` request.
    Here, we should provide all the arguments even if we intend to change a few of
    them. This is because of the conventional way in which `PUT` has been defined
    to work. If we want to have a request where we intend to pass only those arguments
    that we intend to update, then we should use a `PATCH` request. I would urge you
    to try that by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete a product using the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Last, but not least, we have the `DELETE` request, which will simply delete
    the product that matches the `id` passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a definition of all the possible routes that our API can accommodate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test and see how this works, we can send a number of requests using the
    Python shell by means of the `requests` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We made a `GET` request to fetch the list of products, but there is no record
    of this. Let’s create a new product now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We sent a `POST` request to create a product with some data. Note the `headers`
    argument in the request. Each `POST` request sent in Flask-RESTful should have
    this header. Now, we should look for the list of products again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we look for the products again via a `GET` request, we can see that we now
    have a newly created product in the database.
  prefs: []
  type: TYPE_NORMAL
- en: I will leave it to you to try to incorporate other API requests by themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: An important facet of RESTful APIs is the use of token-based authentication
    to allow only limited and authenticated users to be able to use and make calls
    to the API. I urge you to explore this on your own. We covered the basics of user
    authentication in [*Chapter 6*](B19111_06.xhtml#_idTextAnchor328), *Authenticating
    in Flask*, which will serve as a basis for this concept.
  prefs: []
  type: TYPE_NORMAL
