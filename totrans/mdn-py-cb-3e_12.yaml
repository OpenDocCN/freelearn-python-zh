- en: '12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '12'
- en: Graphics and Visualization with Jupyter Lab
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jupyter Lab 进行图形和可视化
- en: A great many problems are simplified through visualization of the data. The
    human eye is particularly suited to identifying relationships and trends. Given
    a display of a potential relationship (or trend), it makes sense to turn to more
    formal statistical methods to quantify the relationship.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数据可视化，许多问题都得到了简化。人眼特别适合识别关系和趋势。给定一个潜在关系（或趋势）的显示，转向更正式的统计方法来量化关系是有意义的。
- en: Python offers a number of graphical tools. For data analytics purposes, one
    of the most popular is matplotlib. This package offers numerous graphic capablities.
    It integrates well with Jupyter Lab, providing us an interactive environment to
    visualize and analyze data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了许多图形工具。对于数据分析目的，最受欢迎的是 matplotlib。这个包提供了许多图形功能。它与 Jupyter Lab 集成良好，为我们提供了一个交互式环境来可视化和分析数据。
- en: It’s possible to do a great deal of Python development in Jupyter Lab. While
    wonderful, this is not a perfect Integrated Development Environment (IDE). The
    one minor drawback is the interactive notebook relies on global variables, something
    that isn’t ideal for writing modules or applications. The use of global variables
    can lead to confusion when transforming a notebook into a module intended for
    reuse.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jupyter Lab 中可以进行大量的 Python 开发。虽然很棒，但这并不是一个完美的集成开发环境（IDE）。一个小的缺点是交互式笔记本依赖于全局变量，这对于编写模块或应用程序来说并不理想。当将笔记本转换为可重用的模块时，使用全局变量可能会导致混淆。
- en: In addition to running Python code and displaying graphics, a Jupyter Lab notebook
    can also render cells in Markdown notation. This lets us write very good-looking
    documentation around the graphical analysis of data. This includes the ability
    to render mathematical formulae properly. It lets us include a cell with e^(πi)
    + 1 = 0 kinds of mathematics close to the relevant code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行 Python 代码和显示图形外，Jupyter Lab 笔记本还可以渲染 Markdown 语法中的单元格。这使得我们能够围绕数据的图形分析编写非常漂亮的文档。这包括正确渲染数学公式的功能。它允许我们在相关代码附近包含类似
    e^(πi) + 1 = 0 的数学。
- en: The two packages we’ll use aren’t part of the standard Python distribution.
    We’ll need to install them. In some cases, using a tool like Conda can help to
    install these large and complex packages. In many cases, however, a PIP install
    will work when our computer is one of the widely supported varieties.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的两个包不是 Python 标准发行版的一部分。我们需要安装它们。在某些情况下，使用 Conda 等工具可以帮助安装这些大型且复杂的包。然而，在许多情况下，如果我们的计算机是广泛支持的类型之一，那么
    PIP 安装将有效。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the python -m pip command ensures that we will use the pip command that
    is compatible with the currently active virtual environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 python -m pip 命令可以确保我们将使用与当前活动虚拟环境兼容的 pip 命令。
- en: 'This will conclude with a line something like the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以类似以下的一行结束：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This line will be followed by a list of new packages added to the current virtual
    environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行后面将跟一个列表，列出添加到当前虚拟环境中的新包。
- en: Note that Jupyter Lab will make use of the IPython implementation of Python.
    This implementation includes some additional features that are very handy for
    managing the complex client-server connection between a browser and a Jupyter
    Lab server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Jupyter Lab 将会使用 IPython 的 Python 实现。这个实现包括一些非常有用的附加功能，这些功能对于管理浏览器和 Jupyter
    Lab 服务器之间的复杂客户端-服务器连接非常有帮助。
- en: The most visible difference from the standard Python implementation is a distinct
    prompt. IPython uses In [n]:  as a prompt. The number, n, increases during the
    session. It’s possible to recall specific previous commands and outputs using
    the numbering of the prompts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的 Python 实现相比，最明显的区别是一个独特的提示符。IPython 使用 In [n]: 作为提示符。数字 n 在会话期间会增加。可以使用提示符的编号来回忆特定的先前命令和输出。
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下食谱：
- en: '[Starting a Notebook and creating cells with Python code](ch016.xhtml#x1-6760001)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[启动笔记本并使用 Python 代码创建单元格](ch016.xhtml#x1-6760001)'
- en: '[Ingesting data into a notebook](ch016.xhtml#x1-6820002)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将数据导入笔记本](ch016.xhtml#x1-6820002)'
- en: '[Using pyplot to create a scatter plot](ch016.xhtml#x1-6880003)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 pyplot 创建散点图](ch016.xhtml#x1-6880003)'
- en: '[Using axes directly to create a scatter plot](ch016.xhtml#x1-6940004)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[直接使用坐标轴创建散点图](ch016.xhtml#x1-6940004)'
- en: '[Adding details to markdown cells](ch016.xhtml#x1-7000005)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[向 markdown 单元格添加细节](ch016.xhtml#x1-7000005)'
- en: '[Including Unit Test Cases in a Notebook](ch016.xhtml#x1-7060006)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在笔记本中包含单元测试用例](ch016.xhtml#x1-7060006)'
- en: 12.1 Starting a Notebook and creating cells with Python code
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.1 使用 Python 代码启动笔记本并创建单元格
- en: 'We’ll use a terminal window to enter a command to start the lab server. The
    jupyter lab command will do two things:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用终端窗口输入一个命令来启动实验室服务器。jupyter lab 命令将做两件事：
- en: It will start the backend, number-crunching server component of Jupyter Lab.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将启动 Jupyter Lab 的后端，数值计算服务器组件。
- en: It will also try to launch a browser window that’s connected to that server
    component.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还将尝试启动一个连接到该服务器组件的浏览器窗口。
- en: The rest of our interaction with the various notebooks in the lab will be through
    the browser.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与实验室中各种笔记本的其余交互将通过浏览器进行。
- en: In the rare case that a browser isn’t launched, the log will provide links that
    can be used in your browser of choice. The IPython runtime will make use of the
    various installed packages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数浏览器未启动的情况下，日志将提供可以在您选择的浏览器中使用的链接。IPython 运行时会使用各种已安装的包。
- en: For this first recipe, we’ll focus on the administrative aspects of starting
    and stopping the Jupyter Lab server, and creating notebooks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个菜谱，我们将关注启动和停止 Jupyter Lab 服务器以及创建笔记本的管理方面。
- en: 12.1.1 Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1.1 准备工作
- en: We’re going to start a Jupyter Lab session and create a notebook to make sure
    that the environment works and all of the needed components are installed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动一个 Jupyter Lab 会话并创建一个笔记本，以确保环境正常工作并且所有必需的组件都已安装。
- en: The use of a terminal window to start Jupyter Lab is sometimes confusing. Many
    programmers are used to working inside an IDE to create and test code. Starting
    Jupyter Lab is generally done from a terminal window, not a Python editor or interactive
    Python REPL session.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用终端窗口启动 Jupyter Lab 有时可能会令人困惑。许多程序员习惯于在集成开发环境（IDE）中创建和测试代码。启动 Jupyter Lab 通常是在终端窗口中完成的，而不是在
    Python 编辑器或交互式 Python REPL 会话中。
- en: 12.1.2 How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1.2 如何操作...
- en: 'Open a terminal window. Change to a working directory that has access to data
    and a folder for notebooks. Be sure the proper virtual environment is active.
    The Jupyter Lab server is limited to working in the directory in which it was
    started. Enter the following command to start Jupyter Lab:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口。切换到一个可以访问数据和笔记本文件夹的工作目录。确保正确的虚拟环境已激活。Jupyter Lab 服务器限制在启动它的目录中工作。输入以下命令以启动
    Jupyter Lab：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will output a log of actions taken by the server. In the block of lines
    will be URLs to connect to the server securely. Generally, a browser window will
    also open.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将输出服务器执行的操作日志。在行块中将有连接到服务器的安全 URL。通常，也会打开一个浏览器窗口。
- en: In the browser window, the Jupyter Lab window will show the launcher tab. It
    looks like the page shown in Figure [12.1](ch016.xhtml#x1-678006r1).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，Jupyter Lab 窗口将显示启动器选项卡。它看起来像图 [12.1](ch016.xhtml#x1-678006r1) 中显示的页面。
- en: '![PIC](img/file74.png)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![PIC](img/file74.png)'
- en: 'Figure 12.1: Jupyter Lab launcher'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.1：Jupyter Lab 启动器
- en: Click the Python 3 (ipykernel) icon in the Notebook section of the launcher.
    This will open a Jupyter Notebook named Untitled.ipynb.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动器中的笔记本部分单击 Python 3 (ipykernel) 图标。这将打开一个名为 Untitled.ipynb 的 Jupyter Notebook。
- en: '![PIC](img/file75.png)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![PIC](img/file75.png)'
- en: 'Figure 12.2: Jupyter notebook ready for work'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.2：准备工作的 Jupyter 笔记本
- en: The top of this tab has a notebook-level menu bar with a series of icons to
    save the notebook, add a cell, cut a cell, copy a cell, and paste a cell, among
    other things.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此选项卡顶部有一个笔记本级别的菜单栏，其中包含一系列图标，用于保存笔记本、添加单元格、剪切单元格、复制单元格和粘贴单元格等。
- en: The ▸ icon on the notebook’s menu bar will execute the cell’s Python or format
    the cell’s Markup content. This can also often be done with the Shift+Enter keyboard
    combination.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 笔记本菜单栏上的 ▸ 图标将执行单元格的 Python 代码或格式化单元格的 Markup 内容。这也可以经常通过 Shift+Enter 键盘组合来完成。
- en: The remaining icons will stop the running kernel and restart it. The ▸▸ icon
    will restart the notebook, running all the cells. A drop-down menu lets you choose
    between the code, markdown, and raw cells. We’ll spend most of our time creating
    code and markdown cells.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 剩余的图标将停止运行的内核并重新启动它。▸▸ 图标将重新启动笔记本，运行所有单元格。下拉菜单允许您在代码、markdown 和原始单元格之间进行选择。我们将大部分时间用于创建代码和
    markdown 单元格。
- en: The initial content has a label, [ ]:, and a text box into which we can enter
    code. As we add more commands, this area will be filled with cells of code and
    their output.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始内容有一个标签 [ ]，以及一个文本框，我们可以在此输入代码。随着我们添加更多命令，这个区域将被代码单元格及其输出填充。
- en: 'To be sure we have all the required packages, enter the following code into
    the first cell:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们拥有所有必需的包，请将以下代码输入到第一个单元格中：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Use the Shift+Enter keyboard combination or click the ▸ icon on the notebook’s
    menu bar to execute the code in this cell. If it works, that confirms everything
    we need is installed in the current virtual environment.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 Shift+Enter 键盘组合或点击笔记本菜单栏上的▸图标来执行此单元格中的代码。如果它工作正常，这确认了当前虚拟环境中已安装我们所需的一切。
- en: 12.1.3 How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1.3 它是如何工作的...
- en: One of the many features of Jupyter Lab is creating and editing notebooks. We
    can enter code and execute code directly, saving the results for others to review.
    This permits a great deal of flexibility in how to acquire, analyze, and share
    data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter Lab 的许多功能之一是创建和编辑笔记本。我们可以直接输入代码并执行代码，将结果保存供他人审阅。这允许在获取、分析和共享数据的方式上具有很大的灵活性。
- en: Because we can also open a Python console and edit Python modules, we can do
    a tremendous amount of development work using Jupyter Lab as an IDE. It’s possible
    to export a notebook as a script file. This permits a transition from a sequence
    of cells representing a number of good ideas into a module or application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还可以打开 Python 控制台并编辑 Python 模块，我们可以使用 Jupyter Lab 作为 IDE 进行大量的开发工作。可以将笔记本导出为脚本文件。这允许将一系列代表许多好想法的单元格转换为模块或应用程序。
- en: When confronted with a new problem or new data, using a notebook as a way to
    record experiments is often encouraged. Cells that show failures reflect lessons
    learned and are worth preserving. Cells that show success, of course, serve to
    guide colleagues through the learning process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 面对新的问题或新的数据时，通常鼓励使用笔记本作为记录实验的方式。显示失败的单元格反映了学到的经验教训，值得保留。当然，显示成功的单元格有助于引导同事通过学习过程。
- en: 'The Jupyter Lab environment is designed to be used in a variety of container
    configurations. Two common container architectures are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter Lab 环境设计为可以在各种容器配置中使用。两种常见的容器架构是：
- en: A large analytical host separate from an analyst’s laptop.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大型分析主机，与分析师的笔记本电脑分开。
- en: An individual laptop acting as both the host for the Jupyter Lab server process
    and also the host for the browser session. This is the environment created for
    this recipe.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台笔记本电脑既作为 Jupyter Lab 服务器进程的主机，也作为浏览器会话的主机。这是为这个配方创建的环境。
- en: The idea is to be able to scale up and process a very large dataset on a very
    expensive, very large host. This number-crunching host runs the Jupter Lab and
    the kernel for our notebook. Our laptop only runs a browser and a terminal window.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目的是能够扩展并处理一个非常大的数据集，在一个非常昂贵、非常大的主机上。这个数值计算主机运行 Jupyter Lab 和笔记本的内核。我们的笔记本电脑只运行浏览器和终端窗口。
- en: 12.1.4 There’s more...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1.4 更多内容...
- en: The working notebook needs to be saved or the current state will be lost. Save
    early and save often to make sure no precious results are lost. There are two
    ways to stop the Jupyter Lab server when we’re finished using it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 工作笔记本需要保存，否则当前状态将丢失。尽早保存并经常保存，以确保不会丢失任何宝贵的结果。有两种方法可以在使用完毕后停止 Jupyter Lab 服务器。
- en: From the Jupyter Lab browser window.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Jupyter Lab 浏览器窗口。
- en: From the terminal window.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从终端窗口。
- en: To stop processing from the browser window, use the File menu. At the bottom
    of this menu is the Shut Down menu item. This stops the server and disconnects
    the browser session.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要从浏览器窗口停止处理，使用文件菜单。在菜单底部是关闭菜单项。这将停止服务器并断开浏览器会话。
- en: To stop processing from the terminal window, use Control+C (Ĉ) twice to stop
    the processing. Entering Ĉ once will get a Shutdown this Jupyter server (y/[n])?
    prompt. A second Ĉ (or a y answer) is required to stop the process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要从终端窗口停止处理，使用 Control+C (Ĉ) 两次来停止处理。输入 Ĉ 一次将得到提示“关闭此 Jupyter 服务器 (y/[n])？”。需要第二次
    Ĉ（或选择 y）来停止进程。
- en: 12.1.5 See also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1.5 相关内容
- en: In the [Ingesting data into a notebook](ch016.xhtml#x1-6820002) section, we’ll
    move beyond the basics and load a notebook with data.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [将数据导入笔记本](ch016.xhtml#x1-6820002) 部分中，我们将超越基础知识，并加载包含数据的笔记本。
- en: See [Learning Jupyter](https://www.packtpub.com/product/learning-jupyter/9781785884870)
    for an in-depth book on Jupyter Lab.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考关于 Jupyter Lab 的深入书籍 [Learning Jupyter](https://www.packtpub.com/product/learning-jupyter/9781785884870)。
- en: 12.2 Ingesting data into a notebook
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.2 将数据导入笔记本
- en: As a sample data analytics problem, we’ll look at a data collection containing
    four closely related series of samples. The file is named anscombe.json. Each
    series of data is a sequence of (x,y) data pairs and a name for the series, represented
    as a Python dictionary. The series key has the name of the series. The data key
    is the list of data pairs. The four series are sometimes called Anscombe’s Quartet.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为样本数据分析问题，我们将查看包含四个紧密相关的样本系列的数据集合。文件名为anscombe.json。每个数据系列是一个(x,y)数据对的序列和系列名称，表示为Python字典。系列键是系列的名称。数据键是数据对的列表。这四个系列有时被称为安斯康姆四重奏。
- en: We’ll create a notebook to ingest the data. To begin the work, this initial
    recipe will focus on ordinary Python expressions to confirm the data was loaded
    properly. In later recipes, we’ll use visualization and statistical methods to
    see if there are correlations between the two variables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个笔记本来摄取数据。为了开始工作，这个初始配方将专注于普通的Python表达式，以确认数据已正确加载。在后面的配方中，我们将使用可视化和统计方法来查看两个变量之间是否存在相关性。
- en: 12.2.1 Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2.1 准备工作
- en: 'There are a few preliminary steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个初步步骤：
- en: Make sure the Jupyter Lab server is running. If it isn’t, see the [Starting
    a Notebook and creating cells with Python code](ch016.xhtml#x1-6760001) recipe
    to start the server and open a notebook.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Jupyter Lab服务器正在运行。如果它没有运行，请参阅[使用Python代码启动笔记本并创建单元格](ch016.xhtml#x1-6760001)配方以启动服务器并打开笔记本。
- en: Locate the browser window for this server. When starting a server, a browser
    window is often displayed that connects to the server.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位此服务器的浏览器窗口。在启动服务器时，通常会显示一个连接到服务器的浏览器窗口。
- en: Start a new notebook for this recipe.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个配方启动一个新的笔记本。
- en: 'If we close the browser application, or if Python can’t launch our preferred
    browser, then the Jupyter Lab server will run, but there’s no obvious browser
    window to connect to the server. We can locate the server by making an inquiry,
    using this jupyter command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们关闭浏览器应用程序，或者如果Python无法启动我们首选的浏览器，那么Jupyter Lab服务器将运行，但没有任何明显的浏览器窗口可以连接到服务器。我们可以通过使用以下jupyter命令进行查询来定位服务器：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will identify all running servers. It will provide a URL to connect to
    the server. The output might look something like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将识别所有正在运行的服务器。它将提供一个连接到服务器的URL。输出可能看起来像以下这样：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The actual URL shown in the output on your computer can be used to connect to
    the server.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在您计算机上的输出中显示的实际URL可以用来连接到服务器。
- en: 12.2.2 How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2.2 如何操作...
- en: Since we’re going to read a file in the JSON format, the first cell can be a
    code cell with the import statements required.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将以JSON格式读取文件，第一个单元格可以是一个包含所需导入语句的代码单元格。
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the Enter (or Return) key in the cell adds lines of code.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在单元格中使用Enter（或Return）键可以添加代码行。
- en: Using Shift+Enter (or Shift+Return) will execute the cell’s code and open a
    new cell for more code. This also happens when we click the ▸ icon on the menu
    bar to execute the code, followed by the + icon on the menu bar to add a new,
    empty cell.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Shift+Enter（或Shift+Return）将执行单元格的代码并打开一个新的单元格以输入更多代码。点击菜单栏上的▸图标执行代码，然后点击菜单栏上的+图标添加一个新的空单元格也会发生这种情况。
- en: 'After a cell is executed, the number is filled in for the cell label; the first
    cell shows [1]: when the cell has been executed.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行一个单元格后，单元格标签的数字将被填写；第一个单元格显示[1]，表示单元格已被执行。
- en: 'It makes sense to put the whole ”read and extract data” process into a single
    cell:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个“读取和提取数据”过程放入一个单元格中是有意义的：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The path from the current working directory to data assumes the notebook is
    in a src/ch12 folder, and the src folder is a peer of the data folder. If your
    project isn’t structured like this, then the computation of source_path will need
    to change.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从当前工作目录到数据的路径假设笔记本位于src/ch12文件夹中，src文件夹是data文件夹的同级文件夹。如果您的项目结构不是这样，那么source_path的计算需要更改。
- en: 'When we execute this cell, we’ll see the names of the four data series in this
    collection. They look like this:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们执行这个单元格时，我们将看到这个集合中四个数据系列的名称。它们看起来像这样：
- en: '![PIC](img/file76.png)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![PIC](img/file76.png)'
- en: 'Figure 12.3: Jupyter notebook with two cells of code'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.3：包含两个代码单元格的Jupyter笔记本
- en: 'We can look at the (x,y) pairs in this source. A cell with an expression is
    sufficient to show the value of the expression:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以查看这个源中的(x,y)对。一个包含表达式的单元格足以显示表达式的值：
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can define a class to hold these data pairs. Because the data is JSON-formatted,
    and because the pydantic package offers really good JSON parsing, we can consider
    extending the BaseModel class.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以定义一个类来保存这些数据对。由于数据是 JSON 格式，并且 pydantic 包提供了非常好的 JSON 解析功能，我们可以考虑扩展 BaseModel
    类。
- en: 'This requires rewriting cell 1 to extend the sequence of imports to include:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这需要重写单元格 1，以扩展导入序列以包括：
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can click the ▸▸ icon to restart the notebook, running all the cells. This
    is essential when we go back toward the top and make a change.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以点击▸▸图标来重启笔记本，运行所有单元格。当我们回到顶部并做出更改时，这是必不可少的。
- en: At the top of the page, over the tabs for the launcher at the notebooks, there’s
    a higher-level menu bar with items like File, Edit, View, Run, Kernel, Tabs, Settings,
    and Help. The Kernel menu has a Restart Kernel and Run All Cells... item that
    has the same functionality as the ▸▸ icon in the notebook menu bar.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在页面顶部，笔记本启动标签上方，有一个更高层次的菜单栏，包括文件、编辑、查看、运行、内核、标签页、设置和帮助等选项。内核菜单中的“重启内核”和“运行所有单元格...”项与笔记本菜单栏中的▸▸图标具有相同的功能。
- en: 'Define a class for an X-Y pair. Then, define a class for the series of individual
    pairs:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于 X-Y 对的类。然后，定义一个用于单个对序列的类：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we can populate the class instances from the all_data object:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以从 all_data 对象中填充类实例：
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Use an expression like clean_data[0] to see a specific series.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 clean_data[0] 这样的表达式来查看特定的序列。
- en: 'We have an awkward problem where each series has a position in the clean_data
    sequence, and a name. Using a mapping is better than using a sequence:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个尴尬的问题，即每个序列在 clean_data 序列中都有一个位置和一个名称。使用映射比使用序列更好：
- en: '[PRE12]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Use an expression like quartet[’I’] to see a specific series.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 quartet[’I’] 这样的表达式来查看特定的序列。
- en: 12.2.3 How it works...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2.3 它是如何工作的...
- en: The Python in each cell is not dramatically different from the code used in
    the [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006) recipe
    in Chapter [11](ch015_split_000.xhtml#x1-61500011). We’ve used Jupyter Lab to
    start an IPython kernel that evaluates the code in each cell.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元格中的 Python 代码与第 [11](ch015_split_000.xhtml#x1-61500011) 章中 [Reading JSON
    and YAML documents](ch015_split_001.xhtml#x1-6520006) 菜单中使用的代码没有显著差异。我们使用了 Jupyter
    Lab 来启动一个 IPython 内核，以评估每个单元格中的代码。
- en: When a cell’s code ends with an expression, the Jupyter Notebook will display
    any non-None output. This is similar to the command-line REPL. A print() function
    isn’t needed to display the results of the final expression in a cell.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元格的代码以表达式结束，Jupyter Notebook 将显示任何非 None 输出。这类似于命令行 REPL。在单元格中显示最终表达式的结果不需要
    print() 函数。
- en: The Jupyter notebook interface is a distinct way to access Python and provides
    a richly interactive environment. Underneath the clever editing and display features,
    the language and libraries are still Python.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter 笔记本界面是一种独特的访问 Python 的方式，提供了一个丰富的交互式环境。在巧妙的编辑和显示功能之下，语言和库仍然是 Python。
- en: 12.2.4 There’s more...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2.4 更多...
- en: After reviewing the notebook, it’s clear we can optimize some of the processing.
    There’s no real benefit in creating the all_data and clean_data objects. The real
    goal is to work with the quartet object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查笔记本后，很明显我们可以优化一些处理过程。创建 all_data 和 clean_data 对象并没有真正的益处。真正的目标是与 quartet
    对象一起工作。
- en: 'We can use the following cell to parse and load the series:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下单元格来解析和加载序列：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It helps to insert a new cell after the Pydantic class definition with this
    code. We can then execute the code. A cell with an expression like quartet[’IV’]
    can be used to confirm that the data was loaded.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pydantic 类定义之后插入一个新单元格并使用此代码很有帮助。然后我们可以执行代码。可以使用 quartet[’IV’] 这样的表达式来确认数据已被加载。
- en: 'A more complete check would be the following cell:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更完整的检查将是以下单元格：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This shows each series name and the number of points in the data for the series.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了每个序列名称和数据序列中的点数。
- en: Once this works, we can remove prior cells, add Markdown, and rerun the notebook
    to make sure it works properly and neatly displays the data to be analyzed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个工作正常，我们可以删除之前的单元格，添加 Markdown，并重新运行笔记本以确保它正常且整洁地显示要分析的数据。
- en: 12.2.5 See also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2.5 参见
- en: See the [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011) for more on JSON-format
    files.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见第 [11](ch015_split_000.xhtml#x1-61500011) 章的 [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006)
    菜单，了解更多关于 JSON 格式文件的信息。
- en: The [Implementing more strict type checks with Pydantic](ch014.xhtml#x1-6000005)
    recipe in Chapter [10](ch014.xhtml#x1-57300010) covers some features of the Pydantic
    package.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 [10](ch014.xhtml#x1-57300010) 章的[使用 Pydantic 实现更严格的类型检查](ch014.xhtml#x1-6000005)配方涵盖了
    Pydantic 包的一些功能。
- en: 12.3 Using pyplot to create a scatter plot
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.3 使用 `pyplot` 创建散点图
- en: The matplotlib project has an immense variety of graph and plot types that it
    can produce. It is extremely sophisticated, which makes it challenging to use
    for some kinds of analysis.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib 项目可以产生各种图表和绘图类型，它极其复杂，这使得它在某些类型的分析中难以使用。
- en: A particularly useful subset of features is collected in a sub-package called
    pyplot. This group of features reflects some common assumptions and optimizations
    that work out very nicely when working in Jupyter Lab. In other contexts, these
    assumptions are often limiting.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为 `pyplot` 的子包中收集了特别有用的功能集。这个功能组反映了在 Jupyter Lab 中工作时的一些常见假设和优化，这些假设和优化工作得非常好。在其他上下文中，这些假设通常是限制性的。
- en: To make things easier, the pyplot package will automatically manage the figure
    being created. It will track any sub-plots that fill in the picture. It will track
    the various axes and artists that comprise those subplots.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更简单，`pyplot` 包将自动管理创建的图形。它将跟踪填充图片的任何子图。它将跟踪构成这些子图的各个轴和艺术家。
- en: For more information, see [Parts of a Figure](https://matplotlib.org/stable/users/explain/quick_start.html#parts-of-a-figure)
    in the matplotlib tutorial. This diagram identifies the various elements of a
    figure and what parts of matplotlib are used to create or control those elements.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅 matplotlib 教程中的[图形的各个部分](https://matplotlib.org/stable/users/explain/quick_start.html#parts-of-a-figure)。此图确定了图形的各个元素以及用于创建或控制这些元素的
    matplotlib 的各个部分。
- en: In the [Ingesting data into a notebook](ch016.xhtml#x1-6820002) recipe, we looked
    at a collection of data that had four data series. The file that contains this
    data section is named anscombe.json. Each series of data is a sequence of (x,y)
    data pairs, and each series has a name.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在[将数据导入笔记本](ch016.xhtml#x1-6820002)配方中，我们查看了一个包含四个数据序列的数据集。包含此数据部分的文件名为 `anscombe.json`。每个数据序列是一系列
    (x,y) 数据对，每个序列都有一个名称。
- en: The general approach will be to define some useful classes that provide helpful
    definitions of the series and the samples within a series. Given those definitions,
    we can read the anscombe.json file to acquire the data. Once it is loaded, we
    can then create a figure that shows the data pairs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通用方法将是定义一些有用的类，这些类提供了对序列及其内部样本的有用定义。有了这些定义，我们可以读取 `anscombe.json` 文件以获取数据。一旦加载，我们就可以创建一个显示数据对的图形。
- en: 12.3.1 Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3.1 准备工作
- en: 'There are a few preliminary steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个初步步骤：
- en: Start the Jupyter Lab server and locate the browser window for it. If it isn’t
    running, see the [Starting a Notebook and creating cells with Python code](ch016.xhtml#x1-6760001)
    recipe to start a server. See [Ingesting data into a notebook](ch016.xhtml#x1-6820002)
    for advice on locating a server that runs in the background.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Jupyter Lab 服务器并定位其浏览器窗口。如果它没有运行，请参阅[使用 Python 代码启动笔记本并创建单元格](ch016.xhtml#x1-6760001)配方以启动服务器。有关定位在后台运行的服务器的建议，请参阅[将数据导入笔记本](ch016.xhtml#x1-6820002)。
- en: Start a new notebook for this recipe.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此配方创建一个新的笔记本。
- en: 12.3.2 How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3.2 如何操作...
- en: 'Start the notebook with a cell that describes what the notebook will have in
    it. This should be a Markdown cell to record some notes:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用描述笔记本将包含内容的单元格开始笔记本。这应该是一个 Markdown 单元格，用于记录一些笔记：
- en: '[PRE15]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the imports required to use Pydantic to load JSON-formatted data. This
    will be a code cell:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需的导入，以便使用 Pydantic 加载 JSON 格式的数据。这将是一个代码单元格：
- en: '[PRE16]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define two classes that define each series of data. One class has the individual
    (x,y) pair. The other is the series of pairs, along with the series name:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个类，分别定义数据序列。一个类包含单个 (x,y) 对。另一个是包含这些对及其序列名称的序列：
- en: '[PRE17]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write a cell with the code required to read the data, and create a global variable
    with the cleaned data:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个包含读取数据所需代码的单元格，并创建一个包含清洗后数据的全局变量：
- en: '[PRE18]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The value of clean_data contains a list of four individual Series objects. An
    expression like quartet[’I’] will reveal one of the series.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clean_data` 的值包含四个单独的 Series 对象列表。像 `quartet[''I'']` 这样的表达式将揭示其中一个序列。'
- en: 'Add a Markdown cell showing what the next part of this notebook will contain:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 Markdown 单元格，显示本笔记本下一部分将包含的内容：
- en: '[PRE19]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Write the needed import for the pyplot package. This is often renamed plt to
    simplify the code that is written in the Jupyter notebook cells:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写对pyplot包所需的导入。这通常被重命名为plt以简化Jupyter笔记本单元格中编写的代码：
- en: '[PRE20]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For an individual series, we’ll need to extract two parallel sequences of numbers.
    We’ll use list comprehensions on clean_data[0].data to extract the x values for
    one sequence and the y values for a second, parallel sequence:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于单个系列，我们需要提取两个平行的数字序列。我们将使用list comprehensions在clean_data[0].data上提取一个序列的x值和第二个平行序列的y值：
- en: '[PRE21]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The scatter() function creates the essential scatter plot. We provide two parallel
    sequences: one has the x values and one has the y values. The title() function
    will place a label above the plot. We’ve constructed a string from the series
    name. While not always necessary, a plt.show() is sometimes needed to display
    the resulting plot:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: scatter()函数创建基本的散点图。我们提供两个平行序列：一个包含x值，另一个包含y值。title()函数将在图形上方放置一个标签。我们从一个系列名称构造了一个字符串。虽然不总是必要的，但有时需要plt.show()来显示生成的图形：
- en: '[PRE22]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The resulting notebook will include cells like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的笔记本将包括如下单元格：
- en: '![PIC](img/file77.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file77.png)'
- en: 'Figure 12.4: Jupyter notebook with a figure for Series I'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：包含Series I图形的Jupyter笔记本
- en: 12.3.3 How it works...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3.3 它是如何工作的...
- en: The underlying matplotlib package has a tall stack of components to support
    graphics and visualizations of data. One foundation is the idea of a backend component
    to integrate with the wide variety of contexts, frameworks, and platforms in which
    Python is used. This also includes interactive environments like Jupyter Lab.
    It also includes static, non-interactive backends that can produce a variety of
    image file formats.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 基于matplotlib的底层包有一系列组件来支持图形和数据可视化。一个基础是后端组件的概念，以集成Python使用的广泛上下文、框架和平台。这还包括像Jupyter
    Lab这样的交互式环境。它还包括可以生成各种图像文件格式的静态、非交互式后端。
- en: Another foundational element of matplotlib is the API that lets us create a
    Figure object populated with Artist objects. The collection of Artist objects
    will draw the titles, axes, data points, and lines we expect to see in the figure.
    The Artist objects can be interactive, permitting them to refresh a figure when
    the data changes, or when the display shape changes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib的另一个基础元素是API，它允许我们创建一个包含Artist对象的Figure对象。Artist对象的集合将绘制我们希望在图形中看到的标题、坐标轴、数据点和线条。Artist对象可以是交互式的，允许它们在数据变化或显示形状变化时刷新图形。
- en: In this kind of analysis notebook, we’re often more interested in a static figure
    that’s drawn once. Our objective is to save the notebook for other people to view
    and understand the data. The ultimate goal is to communicate relationships or
    trends in the data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种分析笔记本中，我们通常对一次性绘制的静态图形更感兴趣。我们的目标是保存笔记本供其他人查看和理解数据。最终目标是传达数据中的关系或趋势。
- en: The pyplot package contains a number of simplifications for the overall matplotlib
    API. These simplifications save us from some of the tedious details of keeping
    track of the various axes instances that are used to create a plot displayed in
    a figure.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: pyplot包包含对matplotlib整体API的简化。这些简化使我们免于跟踪用于创建图形显示在图形中的各种坐标轴实例的繁琐细节。
- en: 12.3.4 There’s more...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3.4 更多内容...
- en: We’ll often want to see several closely related plots as part of a single figure.
    In this case, where we have four series of data in a single file, it seems particularly
    helpful to put all four plots together.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望将几个紧密相关的图形作为单个图形的一部分来查看。在这种情况下，如果我们有一个文件中的四个数据系列，将所有四个图形放在一起似乎特别有帮助。
- en: 'This is done using plt.figure() to create an overall figure. Within this figure,
    each plt.subplot() function can create a distinct subplot. The layout of the figure
    is provided as part of each subplot request as three numbers: the number of plots
    arranged vertically within the figure, the number plots horizontally in the figure,
    and this particular plot’s location within that layout.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过plt.figure()创建一个整体图形来完成的。在这个图形内部，每个plt.subplot()函数可以创建一个独立的子图。图形的布局作为每个子图请求的一部分提供，作为三个数字：图形内垂直排列的图形数量、图形内水平排列的图形数量以及此特定图形在布局中的位置。
- en: We might use 2, 2, n to state that the figure has a 2 × 2 arrangement, and this
    specific subplot has position n. The positions are counted across the figure from
    top left to bottom right. The position can also span more than one section of
    the figure so that we have one large plot and a number of smaller plots.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用2, 2, n来表示图形具有2 × 2的排列，并且这个特定的子图位置为n。位置是从图形的左上角到右下角进行计算的。位置也可以跨越图形的多个部分，这样我们就可以有一个大图和多个小图。
- en: 'To make it easier to extract the x and y attributes of each plot, we’ll modify
    the definition of the Series class. We’ll add two properties, x and y, that will
    extract all of the series values. This redefines the Series class as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易提取每个图表的x和y属性，我们将修改Series类的定义。我们将添加两个属性，x和y，它们将提取所有序列值。这样重新定义Series类如下：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Adding these properties permits some slight simplifications in the plt.scatter()
    function. The overall figure can be created by a cell with the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些属性允许在plt.scatter()函数中做一些轻微的简化。整个图形可以通过以下代码的单元创建：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After changing the new Series class definition, the notebook’s cells must be
    rerun from the beginning. In the Run menu, the item to Restart the kernel and
    run all cells will incorporate the revised class and reload the data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改新的Series类定义后，笔记本的单元必须从头开始重新运行。在运行菜单中，重启内核并运行所有单元的项将包含修订后的类并重新加载数据。
- en: There are numerous options and parameters for the definition of the figure overall,
    the scatter plot, and the axes for the scatter plot. Additionally, there are numerous
    alternative kinds of plots available. The [Matplotlib Examples Gallery](https://matplotlib.org/stable/gallery/index.html)
    shows dozens of varieties of plots. For example, in a case where we have an Counter
    object, we can create a bar chart using a sequence of x values and a sequence
    of height values, using the bar() function instead of the scatter() function.
    See the [Creating dictionaries – inserting and updating](ch009.xhtml#x1-2900001)
    recipe in Chapter [5](ch009.xhtml#x1-2890005) for examples of creating a Counter
    object to summarize frequencies in source data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图形的整体定义、散点图以及散点图的坐标轴，有许多选项和参数。此外，还有许多其他类型的图表可供选择。[Matplotlib Examples Gallery](https://matplotlib.org/stable/gallery/index.html)展示了多种图表的示例。例如，在有一个Counter对象的情况下，我们可以使用x值的序列和高度值的序列，通过使用bar()函数而不是scatter()函数来创建条形图。查看第[5](ch009.xhtml#x1-2890005)章中的[Creating
    dictionaries – inserting and updating](ch009.xhtml#x1-2900001)配方，了解创建Counter对象以总结源数据频率的示例。
- en: 12.3.5 See also
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3.5 参考信息
- en: See the [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011) for more on JSON-format
    files.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看第[11](ch015_split_000.xhtml#x1-61500011)章中的[Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006)配方，了解更多关于JSON格式文件的信息。
- en: The [Implementing more strict type checks with Pydantic](ch014.xhtml#x1-6000005)
    recipe in Chapter [10](ch014.xhtml#x1-57300010) covers some features of using
    the Pydantic package.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第[10](ch014.xhtml#x1-57300010)章中的[Implementing more strict type checks with
    Pydantic](ch014.xhtml#x1-6000005)配方涵盖了使用Pydantic包的一些功能。
- en: The [Ingesting data into a notebook](ch016.xhtml#x1-6820002) recipe earlier
    in this chapter looks at JSON loading in more depth.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章前面的[Ingesting data into a notebook](ch016.xhtml#x1-6820002)配方深入探讨了JSON的加载。
- en: See the [Matplotlib Examples Gallery](https://matplotlib.org/stable/gallery/index.html)
    for dozens of varieties of plots.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看第[Matplotlib Examples Gallery](https://matplotlib.org/stable/gallery/index.html)以了解多种图表的示例。
- en: 12.4 Using axes directly to create a scatter plot
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.4 直接使用坐标轴创建散点图
- en: Many ordinary graphics visualizations can be done using the functions available
    directly in the pyplot module. In the previous recipes, we used the scatter()
    function to draw a scatter plot showing the relationship between two variables.
    Other functions like bar(), pie(), and hist() will create other kinds of plots
    from our raw data. However, there are times when the readily available functions
    on the pyplot module aren’t completely appropriate, and we’d like to do a few
    more things in our images.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常规的图形可视化可以使用pyplot模块中直接可用的函数来完成。在先前的配方中，我们使用了scatter()函数来绘制显示两个变量之间关系的散点图。其他如bar()、pie()和hist()等函数将根据我们的原始数据创建其他类型的图表。然而，有时pyplot模块上现成的函数并不完全适用，我们希望在图像中做更多的事情。
- en: In this recipe, we’ll add a legend box to each of the sub-plots to show the
    linear regression parameters that fit the scatter-plot data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将为每个子图添加一个图例框，以显示适合散点图数据的线性回归参数。
- en: In the [Ingesting data into a notebook](ch016.xhtml#x1-6820002) recipe, we looked
    at a collection of data that had four series of data. The file that contained
    this data is named anscombe.json. Each series of data is a dictionary with a sequence
    of (x,y) data pairs, and a name for the series.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [将数据导入笔记本](ch016.xhtml#x1-6820002) 菜单中，我们查看了一个包含四个数据序列的数据集。包含这些数据的文件被命名为 anscombe.json。每个数据序列是一个包含一系列
    (x,y) 数据对的字典，以及序列的名称。
- en: The general approach will be to define some classes that provide helpful definitions
    of the series and the samples within a series. Given those definitions, we can
    read the anscombe.json file to acquire the data. Once it is loaded, we can then
    create a figure that shows the data pairs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通用方法将是定义一些类，这些类提供了对序列及其内部样本的有用定义。有了这些定义，我们可以读取 anscombe.json 文件以获取数据。一旦加载，我们就可以创建一个显示数据对的图表。
- en: The statistics module in Python provides two handy functions, correlation()
    and regression(), that help us annotate each plot with some parameters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的统计模块提供了两个方便的函数，correlation() 和 regression()，帮助我们用一些参数注释每个图表。
- en: 12.4.1 Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4.1 准备工作
- en: 'There are a few preliminary steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个初步步骤：
- en: Ensure the Jupyter Lab server is running, and locate the browser window for
    it. The [Starting a Notebook and creating cells with Python code](ch016.xhtml#x1-6760001)
    recipe shows how to start a server. The [Ingesting data into a notebook](ch016.xhtml#x1-6820002)
    has some additional advice on locating a server running in the background.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 Jupyter Lab 服务器正在运行，并找到其浏览器窗口。[使用 Python 代码启动笔记本和创建单元格](ch016.xhtml#x1-6760001)
    菜单展示了如何启动服务器。[将数据导入笔记本](ch016.xhtml#x1-6820002) 提供了一些关于定位后台运行的服务器的额外建议。
- en: Start a new notebook for this recipe.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此菜谱启动一个新的笔记本。
- en: 12.4.2 How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4.2 如何操作...
- en: 'Start the notebook with a cell that describes what the notebook will have in
    it. This should be a cell with Markdown content instead of code content:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个描述笔记本内容的单元格来启动笔记本。这应该是一个包含 Markdown 内容而不是代码内容的单元格：
- en: '[PRE25]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create the imports required to use Pydantic to load JSON-formatted data. This
    will be a code cell:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需的导入，以便使用 Pydantic 加载 JSON 格式的数据。这将是一个代码单元格：
- en: '[PRE26]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define two classes that define each series of data. One class has the individual
    (x,y) pair:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个类，分别定义每个数据序列。一个类包含单个 (x,y) 对：
- en: '[PRE27]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The second class is series of pairs, along with the series name. This includes
    two methods to compute the useful statistical summaries like correlation and regression:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个类是包含序列名称的成对数据，这包括两个方法来计算有用的统计摘要，如相关性和回归：
- en: '[PRE28]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a cell to ingest the data, creating a dictionary that maps a series
    name to the related Series instance:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个单元格来导入数据，创建一个将序列名称映射到相关 Series 实例的字典：
- en: '[PRE29]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Confirm that the previous cells all work. Create a cell to evaluate an expression
    like quartet[’I’].correlation. Rounded, the result will be 0.816\. Interestingly,
    the result is almost the same for all four series.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认之前的单元格都正常工作。创建一个单元格来评估一个表达式，例如 quartet[‘I’].correlation。四舍五入后，结果将是 0.816。有趣的是，所有四个序列的结果几乎相同。
- en: 'Start a cell with an expression to create a figure using the figure() function.
    Providing a value of ’tight’ for the layout produces a good-looking figure. It’s
    essential to assign this to a variable so that the object persists until it can
    be displayed by the plt.show() function:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 figure() 函数创建一个图表的单元格，提供一个值为 ‘tight’ 的布局值可以产生一个看起来很好的图表。将这个值赋给一个变量是必要的，这样对象就可以在
    plt.show() 函数显示之前保持存在：
- en: '[PRE30]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a line to the cell to create a collection of axes for displaying four subplots
    within the overall figure. The subplot_mosaic() function provides a great deal
    of sophisticated layout capabilities. The list-of-lists structure will create
    a grid that’s square. The axes will be assigned to a dictionary, ax_dict with
    four distinct keys. We’ve chosen the keys to match the series names and positioned
    them in rows and columns of the resulting figure, using lists of lists:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在单元格中添加一行来创建一个用于显示整体图表中四个子图的轴集合。subplot_mosaic() 函数提供了大量的复杂布局功能。列表的列表结构将创建一个正方形网格。轴将被分配到具有四个不同键的字典
    ax_dict 中。我们选择了与序列名称匹配的键，并使用列表的列表将它们定位在结果图表的行和列中：
- en: '[PRE31]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Add the scatter plot and the text caption. We can also build a string with the
    correlation coefficient, r. This can be placed near the bottom-right corner of
    the plot using a relative position that is specified as (.95,.05); this is transformed
    by the ax.transAxes transformer into coordinates based on the sizes of axes.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加散点图和文字说明。我们还可以构建一个包含相关系数r的字符串。这个字符串可以放置在图表的右下角，使用相对位置（.95,.05）指定；这将通过ax.transAxes转换器转换为基于坐标轴大小的坐标。
- en: '[PRE32]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The use of $ around the string, rf"$r = {...}$", forces matplotlib to apply
    TeXformatting rules to the text, creating a properly formatted mathematical equation.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在字符串周围使用$，rf"$r = {...}$"，迫使matplotlib将TeX格式化规则应用于文本，创建一个正确格式化的数学方程。
- en: 'When creating an explicit figure, a final call to the show() function is needed
    to display the image:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建显式图表时，需要调用show()函数的最终调用来显示图像：
- en: '[PRE33]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 12.4.3 How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4.3 它是如何工作的...
- en: The graphics technology stack in matplotlib includes an immense variety of Artist
    subclasses. Each of these will create some part of the final image. In this case,
    we’ve used the subplot_mosaic() function to create four subplot objects, each
    with a set of axes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib中的图形技术堆栈包括大量的Artist子类。每个子类都将创建最终图像的一部分。在这种情况下，我们使用了subplot_mosaic()函数来创建四个子图对象，每个对象都有一组坐标轴。
- en: We’ve used the axes object to display the data, specifying that a scatter plot
    organization should be used. The title for the plot and the text block with the
    correlation coefficient also draw details in the plot.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了坐标轴对象来显示数据，指定使用散点图组织。图表的标题和包含相关系数的文字块也在图表中绘制了细节。
- en: At some point, the display can become cluttered with details. A good presentation
    of data needs to have a message. There are many interesting books and articles
    written about good (and bad) ways to present data to an audience. Consider Matplotlib
    for Python Developers from Packt Publishing as a way to learn more about data
    visualization.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，显示可能会因为细节而变得杂乱。一个好的数据展示需要有一个信息点。关于如何向观众展示数据（好的和不好的方式）有许多有趣的书籍和文章。可以考虑Packt
    Publishing出版的《Python开发者Matplotlib指南》作为学习更多关于数据可视化的途径。
- en: 12.4.4 There’s more...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4.4 更多...
- en: The correlation value suggests there’s a relationship between the x and y variables
    in the series. We can use linear regression to compute the parameters for a linear
    model that predicts the y value when given an x value.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系数表明，在序列中的x和y变量之间存在关系。我们可以使用线性回归来计算线性模型的参数，该模型在给定x值时预测y值。
- en: A linear_regression() function is part of the statistics module in the standard
    library. The result of this function is a tuple with slope and intercept values
    that describe a linear relationship, y = mx + b, where m is the slope and b is
    the intercept.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: linear_regression()函数是标准库中的统计模块的一部分。该函数的结果是一个包含斜率和截距值的元组，这些值描述了一个线性关系，y = mx
    + b，其中m是斜率，b是截距。
- en: 'We can update the cells of this notebook to add the linear regression computation.
    There are several changes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新这个笔记本的单元格来添加线性回归计算。这里有几个变化：
- en: 'Change the Series class to add another property that performs the linear regression
    computation:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Series类更改为添加执行线性回归计算的其他属性：
- en: '[PRE34]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Add a cell to confirm that the regression works. The cell can display the expression
    quartet[’I’].regression The result will have a slope of almost 0.5 and an intercept
    of almost 3.0\. Interestingly, this is almost identical for all four series.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个单元格来确认回归是否有效。该单元格可以显示表达式quartet['I'].regression。结果将具有几乎为0.5的斜率和几乎为3.0的截距。有趣的是，这几乎适用于所有四个序列。
- en: 'Change the subplot label to include the regression parameters:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子图标签更改为包括回归参数：
- en: '[PRE35]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After these changes, restarting the kernel and running all cells will show that
    each of the four subplots shows both the correlation coefficient and the equation
    for a line that predicts y values from given x values.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，重新启动内核并运行所有单元格将显示每个子图都显示了相关系数和从给定的x值预测y值的线的方程。
- en: 'The axline() function can be used to add the regression line to each subplot.
    We’ve provided a known point, the (0,b) intercept, and the slope, m. The line
    is automatically constrained to fit within the range of the axes. This may be
    little more than more visual clutter, or it may be helpful for understanding the
    relationship between the variables:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: axline()函数可以用来向每个子图添加回归线。我们提供了一个已知点，即(0,b)截距和斜率m。该线自动约束在轴的范围之内。这可能会稍微增加视觉杂乱，或者可能有助于理解变量之间的关系：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 12.4.5 See also
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4.5 参考内容
- en: The [Ingesting data into a notebook](ch016.xhtml#x1-6820002) recipe earlier
    in this chapter has more details on ingesting data.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章前面的[将数据导入笔记本](ch016.xhtml#x1-6820002)配方中提供了有关导入数据的更多详细信息。
- en: The matplotlib examples pages include dozens of plots suitable for statistical
    analysis. See the [https://matplotlib.org/stable/gallery/statistics/index.html](https://matplotlib.org/stable/gallery/statistics/index.html)
    Statistics Gallery web page for a large number of examples of data visualizations.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: matplotlib的示例页面包括数十个适合统计分析的图表。请参阅[https://matplotlib.org/stable/gallery/statistics/index.html](https://matplotlib.org/stable/gallery/statistics/index.html)
    统计画廊网页，以获取大量数据可视化的示例。
- en: See the matplotlib [https://matplotlib.org/stable/users/resources/index.html#books-chapters-and-articles](https://matplotlib.org/stable/users/resources/index.html#books-chapters-and-articles)
    books, chapters and articles web page for books on data visualization.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅matplotlib [https://matplotlib.org/stable/users/resources/index.html#books-chapters-and-articles](https://matplotlib.org/stable/users/resources/index.html#books-chapters-and-articles)
    书籍、章节和文章网页，了解有关数据可视化的书籍。
- en: 12.5 Adding details to markdown cells
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.5 向Markdown单元格添加细节
- en: The point of data analytics is to offer deeper insights into numeric measures
    to show trends and relationships. The object, in general, is to help someone make
    a decision that’s fact-based. The decision can be as simple as deciding to recharge
    a vehicle before a trip, based on the anticipated distance and time available
    for charging. Alternatively, it can be as profound as responding to a medical
    diagnosis with effective therapies.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析的目的在于提供对数值指标的深入洞察，以展示趋势和关系。一般来说，目标是帮助某人做出基于事实的决定。这个决定可能很简单，比如根据预期的行驶距离和充电时间来决定在旅行前给车辆充电。或者，它可能非常深刻，比如对医疗诊断做出有效的治疗方案。
- en: Visualization is one aspect of presenting data for an audience to help their
    understanding. Adjacent to visualization is organizing the presented material
    into a coherent story. Further, we also need to provide supplemental details beyond
    figures and images. See [The Manager’s Guide to Presentations](https://www.packtpub.com/product/the-managers-guide-to-presentations/9781783000142)
    from Packt Publishing for more on this topic.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是向观众展示数据以帮助他们理解的一个方面。与可视化相邻的是将展示的材料组织成一个连贯的故事。此外，我们还需要提供超出图表和图像的补充细节。请参阅Packt出版社的[《经理的演示指南》](https://www.packtpub.com/product/the-managers-guide-to-presentations/9781783000142)，了解更多关于这个主题的信息。
- en: 12.5.1 Getting ready
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5.1 准备工作
- en: We’ll update a notebook with some cells that contain Markdown formatting. We
    can start with a notebook created in one of the recipes earlier in this chapter.
    An alternative is to create a new, empty notebook that contains formatted text.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新一个包含Markdown格式的单元格的笔记本。我们可以从本章前面的配方中创建的一个笔记本开始。另一种选择是创建一个新的、空的笔记本，其中包含格式化文本。
- en: A notebook can be exported as a PDF file directly from Jupyter Lab. This is
    the quickest and easiest publication route. We may want to hide some code cells
    from these kind of publications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本可以直接从Jupyter Lab导出为PDF文件。这是最快、最简单的发布途径。我们可能希望隐藏一些代码单元格，以避免这类出版物。
- en: For more polished results, it helps to use separate formatting tools. A notebook
    can be exported as a Markdown file (or Restructured Text or LaTeX). Appropriate
    programs like Pandoc, Docutils, or a a TeXtoolset can then create documents from
    the exported notebook.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更精致的结果，使用单独的格式化工具很有帮助。笔记本可以导出为Markdown文件（或重构文本或LaTeX）。然后，像Pandoc、Docutils或TeX工具集这样的适当程序可以从导出的笔记本中创建文档。
- en: Tools like Quarto and Jupyter {Book} can also be used to create polished output.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Quarto和Jupyter {Book}等工具也可以用来创建精致的结果。
- en: The essential basics, however, are a sensible organization, clear writing, and
    Markdown-formatting in the notebook cells. An interesting part of using Markdown
    is that a cell’s content is essentially static. The notebook’s syntax won’t take
    computed values and inject them into a Markdown cell.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基本要素是合理的组织、清晰的写作和笔记本单元格中的Markdown格式化。使用Markdown的一个有趣之处在于，单元格的内容基本上是静态的。笔记本的语法不会将计算值注入Markdown单元格。
- en: 'There are two ways to create dynamic content:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 创建动态内容有两种方式：
- en: Install the [Python Markdown](https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tree/master/src/jupyter_contrib_nbextensions/nbextensions/python-markdown)
    extension. See [Extensions](https://jupyterlab.readthedocs.io/en/stable/user/extensions.html)
    in the Jupyter Lab documentation. After installing this extension, code can be
    included in a Markdown cell by surrounding it with {{ and }}.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装[Python Markdown](https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tree/master/src/jupyter_contrib_nbextensions/nbextensions/python-markdown)扩展。请参阅Jupyter
    Lab文档中的[扩展](https://jupyterlab.readthedocs.io/en/stable/user/extensions.html)。安装此扩展后，可以通过在周围添加{{和}}来在Markdown单元格中包含代码。
- en: Build the Markdown content in a code cell, and then render the results as Markdown.
    We’ll look at this in a little more depth next.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码单元格中构建Markdown内容，然后将结果渲染为Markdown。我们将在下一部分更深入地探讨这一点。
- en: 12.5.2 How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5.2 如何实现...
- en: 'Import the required function and class from the IPython.display module:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从IPython.display模块导入所需的函数和类：
- en: '[PRE37]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a Markdown object with the text to render:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于渲染的Markdown对象：
- en: '[PRE38]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The triple-quoted string has two prefix characters, r and f. This is a ”raw”
    formatted string. The formatted string is essential for injecting Python objects
    into text. See [Building complicated strings with f-strings](ch005_split_000.xhtml#x1-410004)
    in Chapter [1](ch005_split_000.xhtml#x1-170001).
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 三引号字符串有两个前缀字符，r和f。这是一个“原始”格式化字符串。格式化字符串对于将Python对象注入文本至关重要。请参阅第[1](ch005_split_000.xhtml#x1-170001)章中的[使用f-strings构建复杂的字符串](ch005_split_000.xhtml#x1-410004)。
- en: A raw string is required because LaTeX math formatting requires extensive use
    of \ characters. In this context, we emphatically do not want Python to consider
    the \ as an escape character; we need to ensure these characters are left alone,
    untouched, and provided to the Markdown engine without change.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于LaTeX数学格式化需要广泛使用\字符，因此需要一个原始字符串。在这种情况下，我们明确不希望Python将\视为转义字符；我们需要确保这些字符保持原样，不受影响，并且以不变的方式提供给Markdown引擎。
- en: Using raw strings means it’s very difficult to include a newline character.
    Therefore, it’s best to use a triple-quoted string that can span multiple lines.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用原始字符串意味着很难包含换行符。因此，最好使用可以跨越多行的三引号字符串。
- en: 'Use the display() function to render the cell results as Markdown instead of
    unformatted text:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用display()函数将单元格结果渲染为Markdown而不是未格式化的文本：
- en: '[PRE39]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This creates output in Markdown that includes the results of a computation.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在Markdown中创建包含计算结果的输出。
- en: 12.5.3 How it works...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5.3 工作原理...
- en: Given a code cells that computes a result value, a notebook uses an object’s
    __repl__() method to display the object. The object can have additional methods
    defined that are used by IPython to format the object in distinct ways. In this
    case, the use of the Markdown class creates an object that is rendered as nicely
    formatted text.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个计算结果值的代码单元格，笔记本使用对象的__repl__()方法来显示对象。对象可以定义额外的由IPython用于以不同方式格式化对象的函数。在这种情况下，使用Markdown类创建的对象被渲染为格式良好的文本。
- en: The IPython.display package contains a number of helpful functions. The display()
    function allows a Python code cell to interact with the browser-based rendering
    of the notebook.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: IPython.display包包含许多有用的函数。display()函数允许Python代码单元格与基于浏览器的笔记本渲染进行交互。
- en: The creation of the block of text and the Markdown object is part of the back-end
    number-crunching kernel that’s running the notebook’s code. From this, the rendered
    text is sent to the browser. This text can also be send to the other external
    tools for publishing a notebook, giving us nicely formatted cells with content
    computed by the notebook.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 文本块和Markdown对象的创建是笔记本代码运行的后端计算核心的一部分。从这里，渲染的文本被发送到浏览器。这些文本也可以发送到其他外部工具，用于发布笔记本，从而为我们提供格式良好的单元格，这些单元格的内容是由笔记本计算得出的。
- en: 12.5.4 There’s more...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5.4 更多...
- en: 'When we turn to sharing a notebook, we often have two distinct venues:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转向共享笔记本时，我们通常有两个不同的场所：
- en: Presentations, where the notebook has key points to back up a presenter’s remarks
    to stakeholders.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publications, where the notebook – or a document produced from the notebook
    – is distributed to stakeholders.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some instances, we’ll need to create both a slide deck and a report. This
    requires some care to be sure that computed results are consistent among all variants
    of the notebook. One approach is to have two final report notebooks built around
    importing a core notebook that has data ingestion and computation features.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The %run magic command can be put into a cell to run a notebook and collect
    the result variables. This will also display the output from print() and any plots
    that are created. Because the output is displayed separately, the core notebook
    should focus on ingesting and computing results without any display features.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: For presentations, use the Property Inspector on the right side of the Jupyter
    Lab page. This lets us set a cell’s Slide Type for a presentation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: We can create Markdown content with the key points, the visualizations, and
    all the necessary supporting information. Once we have the content, we can mark
    the cells using the Property Inspector. Finally, we need to save the notebook
    as a presentation. In the File menu, the Save and Export Notebook As... menu item
    presents a list of alternatives. The Reveal.js Slides will create an HTML file
    with the slide presentation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The exported HTML document can be opened in a browser to provide the supporting
    visuals for a presentation. It can be emailed to attendees who only want the presentation
    materials.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a final document (often in the PDF format), we have an array of choices:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Export as AsciiDoc, Markdown, or Restructured Text. From these formats, tools
    like Pandodc, Docutils, or Sphinx can be used to create a final output file.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export as LaTeX. From this format, the TeXtools need to be used to create a
    final PDF. These tools can be rather complicated to install and maintain, but
    the results are stellar.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export as a PDF. There may be a webpdf option, which uses Playwright and the
    Chromium library to render a PDF. There may also be a Qtpdf option, which uses
    the Qt library to create a PDF.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools like Quarto and Jupyter {Book} can also be used to create polished output.
    These include their own publication tools to create final, outstanding PDF documents
    from the Markdown in a notebook.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'An important thing to remember about this publication pipeline is this imperative:
    don’t copy and paste from a notebook.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Copying results from a notebook into a word-processing document is a way to
    introduce errors and omissions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Publishing directly from a notebook eliminates the possible errors caused by
    having two – potentially conflicting – copies of the computation results.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.5 See also
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Writing clear documentation strings with RST markup](ch007_split_001.xhtml#x1-2030007)
    in Chapter [3](ch007_split_000.xhtml#x1-1610003) for more on using ReStructured
    Text to document code.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)
    in Chapter [2](ch006_split_000.xhtml#x1-840002) for more on documentation for
    Python modules.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Python 模块的文档，请参阅第 [2](ch006_split_000.xhtml#x1-840002) 章的[包含描述和文档](ch006_split_000.xhtml#x1-1010003)。
- en: See [Using pyplot to create a scatter plot](ch016.xhtml#x1-6880003) in this
    chapter for data analysis examples that require publication.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，有关需要发布的数据分析示例，请参阅[使用 pyplot 创建散点图](ch016.xhtml#x1-6880003)。
- en: 12.6 Including Unit Test Cases in a Notebook
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.6 在笔记本中包含单元测试用例
- en: It’s difficult to be sure that any software is trustworthy without a test suite.
    It can be awkward to unit test code in a Jupyter Notebook. One of the primary
    reasons testing is difficult is that a notebook is often used to ingest a very
    large volume of data. This means that computations in individual cells can take
    a very long time to complete. For a sophisticated machine learning model, this
    kind of time-consuming processing is typical.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试套件，很难确定任何软件是可信的。在 Jupyter Notebook 中对代码进行单元测试可能会很尴尬。测试之所以困难，一个主要原因是笔记本通常用于处理大量数据。这意味着单个单元格中的计算可能需要非常长的时间才能完成。对于复杂的机器学习模型，这种耗时的处理是典型的。
- en: One approach to creating test cases is to create a ”template” notebook used
    for unit testing. The template can be cloned and a source Path value changed to
    read the large data that is of real interest.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 创建测试用例的一种方法是为单元测试创建一个“模板”笔记本。该模板可以被克隆，并将源路径值更改为读取真正感兴趣的大量数据。
- en: Since notebook .ipynb files are in the JSON format, it’s relatively easy to
    write a program to confirm that the cells of a notebook used to produce the desired
    results are (nearly) identical to the template notebook used for testing. Cells
    with specific filenames are expected to change; the rest are expected to remain
    intact.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于笔记本 .ipynb 文件是 JSON 格式，因此编写一个程序来确认用于生成预期结果的笔记本单元格与用于测试的模板笔记本（几乎）相同相对容易。预期特定文件名的单元格会发生变化；其余的预期保持完整。
- en: A good notebook design transforms multi-statement cells into function (and class)
    definitions. This means the important results are computed by functions that have
    test cases. These test cases can be included in the function’s docstring. We’ll
    address doctest in depth in Chapter [15](ch019_split_000.xhtml#x1-79400015).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的笔记本设计将多语句单元格转换为函数（和类）定义。这意味着重要的结果是由具有测试用例的函数计算得出的。这些测试用例可以包含在函数的文档字符串中。我们将在第
    [15](ch019_split_000.xhtml#x1-79400015) 章中深入探讨 doctest。
- en: In addition to doctest examples for functions and classes, we can use the assert
    statement in a cell to confirm that a notebook’s cells work as expected. This
    statement is a shorthand for an if-raise statement pair. If the expression in
    the assert statement is not true, an AssertException is raised. This will stop
    the notebook, revealing a problem.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数和类的 doctest 示例之外，我们还可以在单元格中使用 assert 语句来确认笔记本的单元格按预期工作。这个语句是 if-raise 语句对的简写。如果
    assert 语句中的表达式不为真，则会引发 AssertException。这将停止笔记本，揭示问题。
- en: 12.6.1 Getting ready
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6.1 准备工作
- en: We’ll start with the notebook from [Using axes directly to create a scatter
    plot](ch016.xhtml#x1-6940004), as it has a complicated cell to ingest data that
    can be converted into a function and some class definitions that can be supplemented
    with doctest examples.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从[直接使用坐标轴创建散点图](ch016.xhtml#x1-6940004)的笔记本开始，因为它有一个复杂的数据摄入单元格，可以将其转换为函数，以及一些可以补充
    doctest 示例的类定义。
- en: 12.6.2 How to do it...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6.2 如何做...
- en: 'Refactor the data ingestion cell to be a function with a name like ingest().
    The parameter should be the Path and the return value should be the dictionary
    with the four Anscombe series. The original side-effect of this cell will be created
    in a cell below. Here’s the function definition:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据摄入单元格重构为具有类似 ingest() 的名称的函数。参数应该是路径，返回值应该是包含四个 Anscombe 系列的字典。该单元格的原始副作用将在下面的单元格中创建。以下是函数定义：
- en: '[PRE40]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We haven’t filled in the doctest example; we’ve only left reminder text. These
    kinds of examples are the subject of recipes in Chapter [15](ch019_split_000.xhtml#x1-79400015).
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还没有填写 doctest 示例；我们只留下了提醒文本。这些类型的示例是第 [15](ch019_split_000.xhtml#x1-79400015)
    章中食谱的主题。
- en: 'Add a cell to ingest the test data:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个单元格来摄入测试数据：
- en: '[PRE41]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add some assert statements to show the expected properties of the quartet object.
    These combine an expression and the expected output into a single statement:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些 assert 语句来显示四元对象预期的属性。这些语句将表达式和预期输出组合成单个语句：
- en: '[PRE42]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Often, we’ll replace an informal test cell with a more formal assertion. It’s
    common to have a cell with an expression like quartet.keys(). When developing
    a notebook, we’ll look at the results of this expression to confirm that the data
    ingestion worked. This manual test case can be upgraded with an automated test
    in the form of assert statements.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，我们会用一个更正式的断言替换一个非正式的测试单元格。有一个包含类似 quartet.keys() 的表达式的单元格是很常见的。在开发笔记本时，我们会查看这个表达式的结果以确认数据导入是否成功。这个手动测试案例可以通过断言语句形式的自动化测试来升级。
- en: Be sure to save the notebook. We’ll assume it’s called recipe_06.ipynb.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确保保存笔记本。我们假设它叫做 recipe_06.ipynb。
- en: 'Open a new terminal window and enter the following command:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并输入以下命令：
- en: '[PRE43]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The notebook should execute flawlessly. There are two important lines in the
    output:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 笔记本应该完美执行。输出中有两条重要的信息：
- en: '[PRE44]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These lines confirm the file and the kernel being used. The absence of other
    output tells us no exceptions were raised.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些行确认了正在使用的文件和内核。没有其他输出表明没有抛出异常。
- en: 12.6.3 How it works...
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6.3 它是如何工作的...
- en: The jupyter execute command will start a kernel and run the notebook’s cells
    to completion. This is handy for confirming that it works.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter 执行命令将启动内核并运行笔记本的单元格直到完成。这对于确认其工作情况非常有用。
- en: We have to be sure to reject the false negative of a test procedure that fails
    to uncover a problem. To be sure the testing approach is sound, we can inject
    a failing assertion into the notebook and observe the expected error.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保拒绝测试程序未能发现问题的假阴性。为了确保测试方法合理，我们可以在笔记本中注入一个失败的断言并观察预期的错误。
- en: 'Add a cell like the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个如下所示的单元格：
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will compute a value and then make a demonstrably false assertion about
    it. This will lead to a very visible failure when we use the jupyter execute command.
    The output will result in the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计算一个值，然后对该值做出一个明显错误的断言。当我们使用 jupyter 执行命令时，这将导致一个非常明显的失败。输出将如下所示：
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The OS status code will also be non-zero, indicating a failure to execute properly.
    This provides ample confirmation that an error will produce a noisy, explicit
    failure. Once we’re sure this works, we can remove it from the notebook, confident
    that the other tests really will discover problems.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统状态码也将是非零的，表示未能正确执行。这提供了足够的证据，表明错误将产生嘈杂的、明确的失败。一旦我们确认这可以正常工作，我们就可以从笔记本中移除它，有信心其他测试真的会发现问题。
- en: 12.6.4 There’s more...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6.4 更多...
- en: For the special case of comparing float values, we shouldn’t use simple == comparison.
    As noted in [Choosing between float, decimal, and fraction](ch005_split_000.xhtml#x1-180001),
    float values are an approximation, and small changes to the order of operations
    can influence the right-most digits.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于比较浮点值的特殊情况，我们不应该使用简单的 == 比较。如 [Choosing between float, decimal, and fraction](ch005_split_000.xhtml#x1-180001)
    中所述，浮点值是近似值，操作顺序的微小变化可能会影响最右边的数字。
- en: 'For float values, the math.isclose() function is essential. Look back at the
    notebook for [Using axes directly to create a scatter plot](ch016.xhtml#x1-6940004).
    The Series class definition computed a correlation and a linear regression value.
    We might create a cell like the following to test this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点值，math.isclose() 函数是必不可少的。回顾笔记本中的 [Using axes directly to create a scatter
    plot](ch016.xhtml#x1-6940004)。Series 类定义计算了相关性和线性回归值。我们可能创建一个如下所示的单元格来测试这一点：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This test case creates a sample Series object. It then confirms that the results
    are very close to the target values. The default settings have a relative tolerance
    value of 10^(−9), which will include nine digits.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试案例创建了一个样本 Series 对象。然后确认结果非常接近目标值。默认设置具有 10^(-9) 的相对容差值，这将包括九位数字。
- en: 12.6.5 See also
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6.5 参考信息
- en: Chapter [15](ch019_split_000.xhtml#x1-79400015) covers testing and unit tests
    in some depth.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 [15](ch019_split_000.xhtml#x1-79400015) 章深入探讨了测试和单元测试。
- en: In [Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)
    in Chapter [2](ch006_split_000.xhtml#x1-840002), the idea of doctest examples
    is also mentioned.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [2](ch006_split_000.xhtml#x1-840002) 章 [Writing better docstrings with RST
    markup](ch006_split_000.xhtml#x1-1090004) 中，也提到了 doctest 示例的想法。
- en: See [Ingesting data into a notebook](ch016.xhtml#x1-6820002) for the seed notebook
    to which we want to add assertions.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 [Ingesting data into a notebook](ch016.xhtml#x1-6820002) 以获取我们想要添加断言的种子笔记本。
- en: Join our community Discord space
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
