- en: '12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graphics and Visualization with Jupyter Lab
  prefs: []
  type: TYPE_NORMAL
- en: A great many problems are simplified through visualization of the data. The
    human eye is particularly suited to identifying relationships and trends. Given
    a display of a potential relationship (or trend), it makes sense to turn to more
    formal statistical methods to quantify the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Python offers a number of graphical tools. For data analytics purposes, one
    of the most popular is matplotlib. This package offers numerous graphic capablities.
    It integrates well with Jupyter Lab, providing us an interactive environment to
    visualize and analyze data.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to do a great deal of Python development in Jupyter Lab. While
    wonderful, this is not a perfect Integrated Development Environment (IDE). The
    one minor drawback is the interactive notebook relies on global variables, something
    that isn’t ideal for writing modules or applications. The use of global variables
    can lead to confusion when transforming a notebook into a module intended for
    reuse.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to running Python code and displaying graphics, a Jupyter Lab notebook
    can also render cells in Markdown notation. This lets us write very good-looking
    documentation around the graphical analysis of data. This includes the ability
    to render mathematical formulae properly. It lets us include a cell with e^(πi)
    + 1 = 0 kinds of mathematics close to the relevant code.
  prefs: []
  type: TYPE_NORMAL
- en: The two packages we’ll use aren’t part of the standard Python distribution.
    We’ll need to install them. In some cases, using a tool like Conda can help to
    install these large and complex packages. In many cases, however, a PIP install
    will work when our computer is one of the widely supported varieties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using the python -m pip command ensures that we will use the pip command that
    is compatible with the currently active virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will conclude with a line something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This line will be followed by a list of new packages added to the current virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Jupyter Lab will make use of the IPython implementation of Python.
    This implementation includes some additional features that are very handy for
    managing the complex client-server connection between a browser and a Jupyter
    Lab server.
  prefs: []
  type: TYPE_NORMAL
- en: The most visible difference from the standard Python implementation is a distinct
    prompt. IPython uses In [n]:  as a prompt. The number, n, increases during the
    session. It’s possible to recall specific previous commands and outputs using
    the numbering of the prompts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Starting a Notebook and creating cells with Python code](ch016.xhtml#x1-6760001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ingesting data into a notebook](ch016.xhtml#x1-6820002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using pyplot to create a scatter plot](ch016.xhtml#x1-6880003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using axes directly to create a scatter plot](ch016.xhtml#x1-6940004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Adding details to markdown cells](ch016.xhtml#x1-7000005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Including Unit Test Cases in a Notebook](ch016.xhtml#x1-7060006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1 Starting a Notebook and creating cells with Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll use a terminal window to enter a command to start the lab server. The
    jupyter lab command will do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It will start the backend, number-crunching server component of Jupyter Lab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will also try to launch a browser window that’s connected to that server
    component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of our interaction with the various notebooks in the lab will be through
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the rare case that a browser isn’t launched, the log will provide links that
    can be used in your browser of choice. The IPython runtime will make use of the
    various installed packages.
  prefs: []
  type: TYPE_NORMAL
- en: For this first recipe, we’ll focus on the administrative aspects of starting
    and stopping the Jupyter Lab server, and creating notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to start a Jupyter Lab session and create a notebook to make sure
    that the environment works and all of the needed components are installed.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a terminal window to start Jupyter Lab is sometimes confusing. Many
    programmers are used to working inside an IDE to create and test code. Starting
    Jupyter Lab is generally done from a terminal window, not a Python editor or interactive
    Python REPL session.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open a terminal window. Change to a working directory that has access to data
    and a folder for notebooks. Be sure the proper virtual environment is active.
    The Jupyter Lab server is limited to working in the directory in which it was
    started. Enter the following command to start Jupyter Lab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will output a log of actions taken by the server. In the block of lines
    will be URLs to connect to the server securely. Generally, a browser window will
    also open.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the browser window, the Jupyter Lab window will show the launcher tab. It
    looks like the page shown in Figure [12.1](ch016.xhtml#x1-678006r1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![PIC](img/file74.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.1: Jupyter Lab launcher'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the Python 3 (ipykernel) icon in the Notebook section of the launcher.
    This will open a Jupyter Notebook named Untitled.ipynb.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![PIC](img/file75.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.2: Jupyter notebook ready for work'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The top of this tab has a notebook-level menu bar with a series of icons to
    save the notebook, add a cell, cut a cell, copy a cell, and paste a cell, among
    other things.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The ▸ icon on the notebook’s menu bar will execute the cell’s Python or format
    the cell’s Markup content. This can also often be done with the Shift+Enter keyboard
    combination.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The remaining icons will stop the running kernel and restart it. The ▸▸ icon
    will restart the notebook, running all the cells. A drop-down menu lets you choose
    between the code, markdown, and raw cells. We’ll spend most of our time creating
    code and markdown cells.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The initial content has a label, [ ]:, and a text box into which we can enter
    code. As we add more commands, this area will be filled with cells of code and
    their output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To be sure we have all the required packages, enter the following code into
    the first cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the Shift+Enter keyboard combination or click the ▸ icon on the notebook’s
    menu bar to execute the code in this cell. If it works, that confirms everything
    we need is installed in the current virtual environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 12.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the many features of Jupyter Lab is creating and editing notebooks. We
    can enter code and execute code directly, saving the results for others to review.
    This permits a great deal of flexibility in how to acquire, analyze, and share
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Because we can also open a Python console and edit Python modules, we can do
    a tremendous amount of development work using Jupyter Lab as an IDE. It’s possible
    to export a notebook as a script file. This permits a transition from a sequence
    of cells representing a number of good ideas into a module or application.
  prefs: []
  type: TYPE_NORMAL
- en: When confronted with a new problem or new data, using a notebook as a way to
    record experiments is often encouraged. Cells that show failures reflect lessons
    learned and are worth preserving. Cells that show success, of course, serve to
    guide colleagues through the learning process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Jupyter Lab environment is designed to be used in a variety of container
    configurations. Two common container architectures are:'
  prefs: []
  type: TYPE_NORMAL
- en: A large analytical host separate from an analyst’s laptop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An individual laptop acting as both the host for the Jupyter Lab server process
    and also the host for the browser session. This is the environment created for
    this recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea is to be able to scale up and process a very large dataset on a very
    expensive, very large host. This number-crunching host runs the Jupter Lab and
    the kernel for our notebook. Our laptop only runs a browser and a terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working notebook needs to be saved or the current state will be lost. Save
    early and save often to make sure no precious results are lost. There are two
    ways to stop the Jupyter Lab server when we’re finished using it.
  prefs: []
  type: TYPE_NORMAL
- en: From the Jupyter Lab browser window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the terminal window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To stop processing from the browser window, use the File menu. At the bottom
    of this menu is the Shut Down menu item. This stops the server and disconnects
    the browser session.
  prefs: []
  type: TYPE_NORMAL
- en: To stop processing from the terminal window, use Control+C (Ĉ) twice to stop
    the processing. Entering Ĉ once will get a Shutdown this Jupyter server (y/[n])?
    prompt. A second Ĉ (or a y answer) is required to stop the process.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Ingesting data into a notebook](ch016.xhtml#x1-6820002) section, we’ll
    move beyond the basics and load a notebook with data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Learning Jupyter](https://www.packtpub.com/product/learning-jupyter/9781785884870)
    for an in-depth book on Jupyter Lab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2 Ingesting data into a notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a sample data analytics problem, we’ll look at a data collection containing
    four closely related series of samples. The file is named anscombe.json. Each
    series of data is a sequence of (x,y) data pairs and a name for the series, represented
    as a Python dictionary. The series key has the name of the series. The data key
    is the list of data pairs. The four series are sometimes called Anscombe’s Quartet.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a notebook to ingest the data. To begin the work, this initial
    recipe will focus on ordinary Python expressions to confirm the data was loaded
    properly. In later recipes, we’ll use visualization and statistical methods to
    see if there are correlations between the two variables.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few preliminary steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the Jupyter Lab server is running. If it isn’t, see the [Starting
    a Notebook and creating cells with Python code](ch016.xhtml#x1-6760001) recipe
    to start the server and open a notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the browser window for this server. When starting a server, a browser
    window is often displayed that connects to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a new notebook for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we close the browser application, or if Python can’t launch our preferred
    browser, then the Jupyter Lab server will run, but there’s no obvious browser
    window to connect to the server. We can locate the server by making an inquiry,
    using this jupyter command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will identify all running servers. It will provide a URL to connect to
    the server. The output might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The actual URL shown in the output on your computer can be used to connect to
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we’re going to read a file in the JSON format, the first cell can be a
    code cell with the import statements required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the Enter (or Return) key in the cell adds lines of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Shift+Enter (or Shift+Return) will execute the cell’s code and open a
    new cell for more code. This also happens when we click the ▸ icon on the menu
    bar to execute the code, followed by the + icon on the menu bar to add a new,
    empty cell.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After a cell is executed, the number is filled in for the cell label; the first
    cell shows [1]: when the cell has been executed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It makes sense to put the whole ”read and extract data” process into a single
    cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The path from the current working directory to data assumes the notebook is
    in a src/ch12 folder, and the src folder is a peer of the data folder. If your
    project isn’t structured like this, then the computation of source_path will need
    to change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we execute this cell, we’ll see the names of the four data series in this
    collection. They look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![PIC](img/file76.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.3: Jupyter notebook with two cells of code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can look at the (x,y) pairs in this source. A cell with an expression is
    sufficient to show the value of the expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can define a class to hold these data pairs. Because the data is JSON-formatted,
    and because the pydantic package offers really good JSON parsing, we can consider
    extending the BaseModel class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This requires rewriting cell 1 to extend the sequence of imports to include:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can click the ▸▸ icon to restart the notebook, running all the cells. This
    is essential when we go back toward the top and make a change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top of the page, over the tabs for the launcher at the notebooks, there’s
    a higher-level menu bar with items like File, Edit, View, Run, Kernel, Tabs, Settings,
    and Help. The Kernel menu has a Restart Kernel and Run All Cells... item that
    has the same functionality as the ▸▸ icon in the notebook menu bar.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a class for an X-Y pair. Then, define a class for the series of individual
    pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can populate the class instances from the all_data object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use an expression like clean_data[0] to see a specific series.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have an awkward problem where each series has a position in the clean_data
    sequence, and a name. Using a mapping is better than using a sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use an expression like quartet[’I’] to see a specific series.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 12.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python in each cell is not dramatically different from the code used in
    the [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006) recipe
    in Chapter [11](ch015_split_000.xhtml#x1-61500011). We’ve used Jupyter Lab to
    start an IPython kernel that evaluates the code in each cell.
  prefs: []
  type: TYPE_NORMAL
- en: When a cell’s code ends with an expression, the Jupyter Notebook will display
    any non-None output. This is similar to the command-line REPL. A print() function
    isn’t needed to display the results of the final expression in a cell.
  prefs: []
  type: TYPE_NORMAL
- en: The Jupyter notebook interface is a distinct way to access Python and provides
    a richly interactive environment. Underneath the clever editing and display features,
    the language and libraries are still Python.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After reviewing the notebook, it’s clear we can optimize some of the processing.
    There’s no real benefit in creating the all_data and clean_data objects. The real
    goal is to work with the quartet object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following cell to parse and load the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It helps to insert a new cell after the Pydantic class definition with this
    code. We can then execute the code. A cell with an expression like quartet[’IV’]
    can be used to confirm that the data was loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more complete check would be the following cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This shows each series name and the number of points in the data for the series.
  prefs: []
  type: TYPE_NORMAL
- en: Once this works, we can remove prior cells, add Markdown, and rerun the notebook
    to make sure it works properly and neatly displays the data to be analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011) for more on JSON-format
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Implementing more strict type checks with Pydantic](ch014.xhtml#x1-6000005)
    recipe in Chapter [10](ch014.xhtml#x1-57300010) covers some features of the Pydantic
    package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3 Using pyplot to create a scatter plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The matplotlib project has an immense variety of graph and plot types that it
    can produce. It is extremely sophisticated, which makes it challenging to use
    for some kinds of analysis.
  prefs: []
  type: TYPE_NORMAL
- en: A particularly useful subset of features is collected in a sub-package called
    pyplot. This group of features reflects some common assumptions and optimizations
    that work out very nicely when working in Jupyter Lab. In other contexts, these
    assumptions are often limiting.
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier, the pyplot package will automatically manage the figure
    being created. It will track any sub-plots that fill in the picture. It will track
    the various axes and artists that comprise those subplots.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, see [Parts of a Figure](https://matplotlib.org/stable/users/explain/quick_start.html#parts-of-a-figure)
    in the matplotlib tutorial. This diagram identifies the various elements of a
    figure and what parts of matplotlib are used to create or control those elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Ingesting data into a notebook](ch016.xhtml#x1-6820002) recipe, we looked
    at a collection of data that had four data series. The file that contains this
    data section is named anscombe.json. Each series of data is a sequence of (x,y)
    data pairs, and each series has a name.
  prefs: []
  type: TYPE_NORMAL
- en: The general approach will be to define some useful classes that provide helpful
    definitions of the series and the samples within a series. Given those definitions,
    we can read the anscombe.json file to acquire the data. Once it is loaded, we
    can then create a figure that shows the data pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few preliminary steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the Jupyter Lab server and locate the browser window for it. If it isn’t
    running, see the [Starting a Notebook and creating cells with Python code](ch016.xhtml#x1-6760001)
    recipe to start a server. See [Ingesting data into a notebook](ch016.xhtml#x1-6820002)
    for advice on locating a server that runs in the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a new notebook for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 12.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the notebook with a cell that describes what the notebook will have in
    it. This should be a Markdown cell to record some notes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the imports required to use Pydantic to load JSON-formatted data. This
    will be a code cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define two classes that define each series of data. One class has the individual
    (x,y) pair. The other is the series of pairs, along with the series name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a cell with the code required to read the data, and create a global variable
    with the cleaned data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value of clean_data contains a list of four individual Series objects. An
    expression like quartet[’I’] will reveal one of the series.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a Markdown cell showing what the next part of this notebook will contain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the needed import for the pyplot package. This is often renamed plt to
    simplify the code that is written in the Jupyter notebook cells:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For an individual series, we’ll need to extract two parallel sequences of numbers.
    We’ll use list comprehensions on clean_data[0].data to extract the x values for
    one sequence and the y values for a second, parallel sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The scatter() function creates the essential scatter plot. We provide two parallel
    sequences: one has the x values and one has the y values. The title() function
    will place a label above the plot. We’ve constructed a string from the series
    name. While not always necessary, a plt.show() is sometimes needed to display
    the resulting plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting notebook will include cells like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Jupyter notebook with a figure for Series I'
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The underlying matplotlib package has a tall stack of components to support
    graphics and visualizations of data. One foundation is the idea of a backend component
    to integrate with the wide variety of contexts, frameworks, and platforms in which
    Python is used. This also includes interactive environments like Jupyter Lab.
    It also includes static, non-interactive backends that can produce a variety of
    image file formats.
  prefs: []
  type: TYPE_NORMAL
- en: Another foundational element of matplotlib is the API that lets us create a
    Figure object populated with Artist objects. The collection of Artist objects
    will draw the titles, axes, data points, and lines we expect to see in the figure.
    The Artist objects can be interactive, permitting them to refresh a figure when
    the data changes, or when the display shape changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this kind of analysis notebook, we’re often more interested in a static figure
    that’s drawn once. Our objective is to save the notebook for other people to view
    and understand the data. The ultimate goal is to communicate relationships or
    trends in the data.
  prefs: []
  type: TYPE_NORMAL
- en: The pyplot package contains a number of simplifications for the overall matplotlib
    API. These simplifications save us from some of the tedious details of keeping
    track of the various axes instances that are used to create a plot displayed in
    a figure.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll often want to see several closely related plots as part of a single figure.
    In this case, where we have four series of data in a single file, it seems particularly
    helpful to put all four plots together.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done using plt.figure() to create an overall figure. Within this figure,
    each plt.subplot() function can create a distinct subplot. The layout of the figure
    is provided as part of each subplot request as three numbers: the number of plots
    arranged vertically within the figure, the number plots horizontally in the figure,
    and this particular plot’s location within that layout.'
  prefs: []
  type: TYPE_NORMAL
- en: We might use 2, 2, n to state that the figure has a 2 × 2 arrangement, and this
    specific subplot has position n. The positions are counted across the figure from
    top left to bottom right. The position can also span more than one section of
    the figure so that we have one large plot and a number of smaller plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier to extract the x and y attributes of each plot, we’ll modify
    the definition of the Series class. We’ll add two properties, x and y, that will
    extract all of the series values. This redefines the Series class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding these properties permits some slight simplifications in the plt.scatter()
    function. The overall figure can be created by a cell with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After changing the new Series class definition, the notebook’s cells must be
    rerun from the beginning. In the Run menu, the item to Restart the kernel and
    run all cells will incorporate the revised class and reload the data.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous options and parameters for the definition of the figure overall,
    the scatter plot, and the axes for the scatter plot. Additionally, there are numerous
    alternative kinds of plots available. The [Matplotlib Examples Gallery](https://matplotlib.org/stable/gallery/index.html)
    shows dozens of varieties of plots. For example, in a case where we have an Counter
    object, we can create a bar chart using a sequence of x values and a sequence
    of height values, using the bar() function instead of the scatter() function.
    See the [Creating dictionaries – inserting and updating](ch009.xhtml#x1-2900001)
    recipe in Chapter [5](ch009.xhtml#x1-2890005) for examples of creating a Counter
    object to summarize frequencies in source data.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011) for more on JSON-format
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Implementing more strict type checks with Pydantic](ch014.xhtml#x1-6000005)
    recipe in Chapter [10](ch014.xhtml#x1-57300010) covers some features of using
    the Pydantic package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Ingesting data into a notebook](ch016.xhtml#x1-6820002) recipe earlier
    in this chapter looks at JSON loading in more depth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the [Matplotlib Examples Gallery](https://matplotlib.org/stable/gallery/index.html)
    for dozens of varieties of plots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.4 Using axes directly to create a scatter plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many ordinary graphics visualizations can be done using the functions available
    directly in the pyplot module. In the previous recipes, we used the scatter()
    function to draw a scatter plot showing the relationship between two variables.
    Other functions like bar(), pie(), and hist() will create other kinds of plots
    from our raw data. However, there are times when the readily available functions
    on the pyplot module aren’t completely appropriate, and we’d like to do a few
    more things in our images.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll add a legend box to each of the sub-plots to show the
    linear regression parameters that fit the scatter-plot data.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Ingesting data into a notebook](ch016.xhtml#x1-6820002) recipe, we looked
    at a collection of data that had four series of data. The file that contained
    this data is named anscombe.json. Each series of data is a dictionary with a sequence
    of (x,y) data pairs, and a name for the series.
  prefs: []
  type: TYPE_NORMAL
- en: The general approach will be to define some classes that provide helpful definitions
    of the series and the samples within a series. Given those definitions, we can
    read the anscombe.json file to acquire the data. Once it is loaded, we can then
    create a figure that shows the data pairs.
  prefs: []
  type: TYPE_NORMAL
- en: The statistics module in Python provides two handy functions, correlation()
    and regression(), that help us annotate each plot with some parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few preliminary steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the Jupyter Lab server is running, and locate the browser window for
    it. The [Starting a Notebook and creating cells with Python code](ch016.xhtml#x1-6760001)
    recipe shows how to start a server. The [Ingesting data into a notebook](ch016.xhtml#x1-6820002)
    has some additional advice on locating a server running in the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a new notebook for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 12.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the notebook with a cell that describes what the notebook will have in
    it. This should be a cell with Markdown content instead of code content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the imports required to use Pydantic to load JSON-formatted data. This
    will be a code cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define two classes that define each series of data. One class has the individual
    (x,y) pair:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second class is series of pairs, along with the series name. This includes
    two methods to compute the useful statistical summaries like correlation and regression:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a cell to ingest the data, creating a dictionary that maps a series
    name to the related Series instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Confirm that the previous cells all work. Create a cell to evaluate an expression
    like quartet[’I’].correlation. Rounded, the result will be 0.816\. Interestingly,
    the result is almost the same for all four series.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a cell with an expression to create a figure using the figure() function.
    Providing a value of ’tight’ for the layout produces a good-looking figure. It’s
    essential to assign this to a variable so that the object persists until it can
    be displayed by the plt.show() function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a line to the cell to create a collection of axes for displaying four subplots
    within the overall figure. The subplot_mosaic() function provides a great deal
    of sophisticated layout capabilities. The list-of-lists structure will create
    a grid that’s square. The axes will be assigned to a dictionary, ax_dict with
    four distinct keys. We’ve chosen the keys to match the series names and positioned
    them in rows and columns of the resulting figure, using lists of lists:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the scatter plot and the text caption. We can also build a string with the
    correlation coefficient, r. This can be placed near the bottom-right corner of
    the plot using a relative position that is specified as (.95,.05); this is transformed
    by the ax.transAxes transformer into coordinates based on the sizes of axes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The use of $ around the string, rf"$r = {...}$", forces matplotlib to apply
    TeXformatting rules to the text, creating a properly formatted mathematical equation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When creating an explicit figure, a final call to the show() function is needed
    to display the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 12.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The graphics technology stack in matplotlib includes an immense variety of Artist
    subclasses. Each of these will create some part of the final image. In this case,
    we’ve used the subplot_mosaic() function to create four subplot objects, each
    with a set of axes.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve used the axes object to display the data, specifying that a scatter plot
    organization should be used. The title for the plot and the text block with the
    correlation coefficient also draw details in the plot.
  prefs: []
  type: TYPE_NORMAL
- en: At some point, the display can become cluttered with details. A good presentation
    of data needs to have a message. There are many interesting books and articles
    written about good (and bad) ways to present data to an audience. Consider Matplotlib
    for Python Developers from Packt Publishing as a way to learn more about data
    visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The correlation value suggests there’s a relationship between the x and y variables
    in the series. We can use linear regression to compute the parameters for a linear
    model that predicts the y value when given an x value.
  prefs: []
  type: TYPE_NORMAL
- en: A linear_regression() function is part of the statistics module in the standard
    library. The result of this function is a tuple with slope and intercept values
    that describe a linear relationship, y = mx + b, where m is the slope and b is
    the intercept.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update the cells of this notebook to add the linear regression computation.
    There are several changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the Series class to add another property that performs the linear regression
    computation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a cell to confirm that the regression works. The cell can display the expression
    quartet[’I’].regression The result will have a slope of almost 0.5 and an intercept
    of almost 3.0\. Interestingly, this is almost identical for all four series.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the subplot label to include the regression parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After these changes, restarting the kernel and running all cells will show that
    each of the four subplots shows both the correlation coefficient and the equation
    for a line that predicts y values from given x values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The axline() function can be used to add the regression line to each subplot.
    We’ve provided a known point, the (0,b) intercept, and the slope, m. The line
    is automatically constrained to fit within the range of the axes. This may be
    little more than more visual clutter, or it may be helpful for understanding the
    relationship between the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 12.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Ingesting data into a notebook](ch016.xhtml#x1-6820002) recipe earlier
    in this chapter has more details on ingesting data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The matplotlib examples pages include dozens of plots suitable for statistical
    analysis. See the [https://matplotlib.org/stable/gallery/statistics/index.html](https://matplotlib.org/stable/gallery/statistics/index.html)
    Statistics Gallery web page for a large number of examples of data visualizations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the matplotlib [https://matplotlib.org/stable/users/resources/index.html#books-chapters-and-articles](https://matplotlib.org/stable/users/resources/index.html#books-chapters-and-articles)
    books, chapters and articles web page for books on data visualization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5 Adding details to markdown cells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The point of data analytics is to offer deeper insights into numeric measures
    to show trends and relationships. The object, in general, is to help someone make
    a decision that’s fact-based. The decision can be as simple as deciding to recharge
    a vehicle before a trip, based on the anticipated distance and time available
    for charging. Alternatively, it can be as profound as responding to a medical
    diagnosis with effective therapies.
  prefs: []
  type: TYPE_NORMAL
- en: Visualization is one aspect of presenting data for an audience to help their
    understanding. Adjacent to visualization is organizing the presented material
    into a coherent story. Further, we also need to provide supplemental details beyond
    figures and images. See [The Manager’s Guide to Presentations](https://www.packtpub.com/product/the-managers-guide-to-presentations/9781783000142)
    from Packt Publishing for more on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll update a notebook with some cells that contain Markdown formatting. We
    can start with a notebook created in one of the recipes earlier in this chapter.
    An alternative is to create a new, empty notebook that contains formatted text.
  prefs: []
  type: TYPE_NORMAL
- en: A notebook can be exported as a PDF file directly from Jupyter Lab. This is
    the quickest and easiest publication route. We may want to hide some code cells
    from these kind of publications.
  prefs: []
  type: TYPE_NORMAL
- en: For more polished results, it helps to use separate formatting tools. A notebook
    can be exported as a Markdown file (or Restructured Text or LaTeX). Appropriate
    programs like Pandoc, Docutils, or a a TeXtoolset can then create documents from
    the exported notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Tools like Quarto and Jupyter {Book} can also be used to create polished output.
  prefs: []
  type: TYPE_NORMAL
- en: The essential basics, however, are a sensible organization, clear writing, and
    Markdown-formatting in the notebook cells. An interesting part of using Markdown
    is that a cell’s content is essentially static. The notebook’s syntax won’t take
    computed values and inject them into a Markdown cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to create dynamic content:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the [Python Markdown](https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tree/master/src/jupyter_contrib_nbextensions/nbextensions/python-markdown)
    extension. See [Extensions](https://jupyterlab.readthedocs.io/en/stable/user/extensions.html)
    in the Jupyter Lab documentation. After installing this extension, code can be
    included in a Markdown cell by surrounding it with {{ and }}.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the Markdown content in a code cell, and then render the results as Markdown.
    We’ll look at this in a little more depth next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the required function and class from the IPython.display module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a Markdown object with the text to render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The triple-quoted string has two prefix characters, r and f. This is a ”raw”
    formatted string. The formatted string is essential for injecting Python objects
    into text. See [Building complicated strings with f-strings](ch005_split_000.xhtml#x1-410004)
    in Chapter [1](ch005_split_000.xhtml#x1-170001).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A raw string is required because LaTeX math formatting requires extensive use
    of \ characters. In this context, we emphatically do not want Python to consider
    the \ as an escape character; we need to ensure these characters are left alone,
    untouched, and provided to the Markdown engine without change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using raw strings means it’s very difficult to include a newline character.
    Therefore, it’s best to use a triple-quoted string that can span multiple lines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the display() function to render the cell results as Markdown instead of
    unformatted text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates output in Markdown that includes the results of a computation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 12.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a code cells that computes a result value, a notebook uses an object’s
    __repl__() method to display the object. The object can have additional methods
    defined that are used by IPython to format the object in distinct ways. In this
    case, the use of the Markdown class creates an object that is rendered as nicely
    formatted text.
  prefs: []
  type: TYPE_NORMAL
- en: The IPython.display package contains a number of helpful functions. The display()
    function allows a Python code cell to interact with the browser-based rendering
    of the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of the block of text and the Markdown object is part of the back-end
    number-crunching kernel that’s running the notebook’s code. From this, the rendered
    text is sent to the browser. This text can also be send to the other external
    tools for publishing a notebook, giving us nicely formatted cells with content
    computed by the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we turn to sharing a notebook, we often have two distinct venues:'
  prefs: []
  type: TYPE_NORMAL
- en: Presentations, where the notebook has key points to back up a presenter’s remarks
    to stakeholders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publications, where the notebook – or a document produced from the notebook
    – is distributed to stakeholders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some instances, we’ll need to create both a slide deck and a report. This
    requires some care to be sure that computed results are consistent among all variants
    of the notebook. One approach is to have two final report notebooks built around
    importing a core notebook that has data ingestion and computation features.
  prefs: []
  type: TYPE_NORMAL
- en: The %run magic command can be put into a cell to run a notebook and collect
    the result variables. This will also display the output from print() and any plots
    that are created. Because the output is displayed separately, the core notebook
    should focus on ingesting and computing results without any display features.
  prefs: []
  type: TYPE_NORMAL
- en: For presentations, use the Property Inspector on the right side of the Jupyter
    Lab page. This lets us set a cell’s Slide Type for a presentation.
  prefs: []
  type: TYPE_NORMAL
- en: We can create Markdown content with the key points, the visualizations, and
    all the necessary supporting information. Once we have the content, we can mark
    the cells using the Property Inspector. Finally, we need to save the notebook
    as a presentation. In the File menu, the Save and Export Notebook As... menu item
    presents a list of alternatives. The Reveal.js Slides will create an HTML file
    with the slide presentation.
  prefs: []
  type: TYPE_NORMAL
- en: The exported HTML document can be opened in a browser to provide the supporting
    visuals for a presentation. It can be emailed to attendees who only want the presentation
    materials.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a final document (often in the PDF format), we have an array of choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Export as AsciiDoc, Markdown, or Restructured Text. From these formats, tools
    like Pandodc, Docutils, or Sphinx can be used to create a final output file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export as LaTeX. From this format, the TeXtools need to be used to create a
    final PDF. These tools can be rather complicated to install and maintain, but
    the results are stellar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export as a PDF. There may be a webpdf option, which uses Playwright and the
    Chromium library to render a PDF. There may also be a Qtpdf option, which uses
    the Qt library to create a PDF.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools like Quarto and Jupyter {Book} can also be used to create polished output.
    These include their own publication tools to create final, outstanding PDF documents
    from the Markdown in a notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important thing to remember about this publication pipeline is this imperative:
    don’t copy and paste from a notebook.'
  prefs: []
  type: TYPE_NORMAL
- en: Copying results from a notebook into a word-processing document is a way to
    introduce errors and omissions.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing directly from a notebook eliminates the possible errors caused by
    having two – potentially conflicting – copies of the computation results.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Writing clear documentation strings with RST markup](ch007_split_001.xhtml#x1-2030007)
    in Chapter [3](ch007_split_000.xhtml#x1-1610003) for more on using ReStructured
    Text to document code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)
    in Chapter [2](ch006_split_000.xhtml#x1-840002) for more on documentation for
    Python modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Using pyplot to create a scatter plot](ch016.xhtml#x1-6880003) in this
    chapter for data analysis examples that require publication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6 Including Unit Test Cases in a Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s difficult to be sure that any software is trustworthy without a test suite.
    It can be awkward to unit test code in a Jupyter Notebook. One of the primary
    reasons testing is difficult is that a notebook is often used to ingest a very
    large volume of data. This means that computations in individual cells can take
    a very long time to complete. For a sophisticated machine learning model, this
    kind of time-consuming processing is typical.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to creating test cases is to create a ”template” notebook used
    for unit testing. The template can be cloned and a source Path value changed to
    read the large data that is of real interest.
  prefs: []
  type: TYPE_NORMAL
- en: Since notebook .ipynb files are in the JSON format, it’s relatively easy to
    write a program to confirm that the cells of a notebook used to produce the desired
    results are (nearly) identical to the template notebook used for testing. Cells
    with specific filenames are expected to change; the rest are expected to remain
    intact.
  prefs: []
  type: TYPE_NORMAL
- en: A good notebook design transforms multi-statement cells into function (and class)
    definitions. This means the important results are computed by functions that have
    test cases. These test cases can be included in the function’s docstring. We’ll
    address doctest in depth in Chapter [15](ch019_split_000.xhtml#x1-79400015).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to doctest examples for functions and classes, we can use the assert
    statement in a cell to confirm that a notebook’s cells work as expected. This
    statement is a shorthand for an if-raise statement pair. If the expression in
    the assert statement is not true, an AssertException is raised. This will stop
    the notebook, revealing a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start with the notebook from [Using axes directly to create a scatter
    plot](ch016.xhtml#x1-6940004), as it has a complicated cell to ingest data that
    can be converted into a function and some class definitions that can be supplemented
    with doctest examples.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refactor the data ingestion cell to be a function with a name like ingest().
    The parameter should be the Path and the return value should be the dictionary
    with the four Anscombe series. The original side-effect of this cell will be created
    in a cell below. Here’s the function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We haven’t filled in the doctest example; we’ve only left reminder text. These
    kinds of examples are the subject of recipes in Chapter [15](ch019_split_000.xhtml#x1-79400015).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a cell to ingest the test data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some assert statements to show the expected properties of the quartet object.
    These combine an expression and the expected output into a single statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Often, we’ll replace an informal test cell with a more formal assertion. It’s
    common to have a cell with an expression like quartet.keys(). When developing
    a notebook, we’ll look at the results of this expression to confirm that the data
    ingestion worked. This manual test case can be upgraded with an automated test
    in the form of assert statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Be sure to save the notebook. We’ll assume it’s called recipe_06.ipynb.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new terminal window and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The notebook should execute flawlessly. There are two important lines in the
    output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These lines confirm the file and the kernel being used. The absence of other
    output tells us no exceptions were raised.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 12.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The jupyter execute command will start a kernel and run the notebook’s cells
    to completion. This is handy for confirming that it works.
  prefs: []
  type: TYPE_NORMAL
- en: We have to be sure to reject the false negative of a test procedure that fails
    to uncover a problem. To be sure the testing approach is sound, we can inject
    a failing assertion into the notebook and observe the expected error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a cell like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will compute a value and then make a demonstrably false assertion about
    it. This will lead to a very visible failure when we use the jupyter execute command.
    The output will result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The OS status code will also be non-zero, indicating a failure to execute properly.
    This provides ample confirmation that an error will produce a noisy, explicit
    failure. Once we’re sure this works, we can remove it from the notebook, confident
    that the other tests really will discover problems.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the special case of comparing float values, we shouldn’t use simple == comparison.
    As noted in [Choosing between float, decimal, and fraction](ch005_split_000.xhtml#x1-180001),
    float values are an approximation, and small changes to the order of operations
    can influence the right-most digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'For float values, the math.isclose() function is essential. Look back at the
    notebook for [Using axes directly to create a scatter plot](ch016.xhtml#x1-6940004).
    The Series class definition computed a correlation and a linear regression value.
    We might create a cell like the following to test this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This test case creates a sample Series object. It then confirms that the results
    are very close to the target values. The default settings have a relative tolerance
    value of 10^(−9), which will include nine digits.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chapter [15](ch019_split_000.xhtml#x1-79400015) covers testing and unit tests
    in some depth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)
    in Chapter [2](ch006_split_000.xhtml#x1-840002), the idea of doctest examples
    is also mentioned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Ingesting data into a notebook](ch016.xhtml#x1-6820002) for the seed notebook
    to which we want to add assertions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
