- en: Web Framework for Automation Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we move on and get better at understanding the coding techniques and Python,
    the next step is to ensure that scripts are executed without the end users actually
    running the code locally, and ensure a platform or OS independent approach in
    code execution. This chapter focuses on putting our scripts on a web platform.
    We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web accessible script with examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the script from HTML/dynamic HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and configuring the environment for the web framework using IIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of APIs and creating a sample API using C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the API in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a task to understand the full end-to-end functionality of a web framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why create web-based scripts/frameworks?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **web framework** is a collection of scripts, hosted on a web platform such
    as **Internet Information Services** (**IIS**) (on Windows) or Apache (on Linux),
    and calling the same script using front-end web-based languages such as HTML.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when people ask why we want to migrate our current scripts or
    create scripts on a web framework. The answer is very simple. A web framework
    ensures that our scripts are used by multiple end users using just the browser.
    This gives the programmer the independence to code the script on their preferred
    platform (such as Windows or Linux), and people can use the scripts on their choice
    of browser. They don't need to understand how you have written the code, or what
    you are calling or using in the back-end, and of course, this ensures that you
    prevent your code from being directly visible to end users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say  you have written a script that calls four or five libraries for specific
    tasks. There are general libraries, but as we have seen in previous chapters,
    some specific libraries need to be installed for the tasks. In this case, if you
    want to ensure that end users can execute your script, they need to install the
    same libraries on their machines. Also, they need to be running a Python environment
    on their machines, without which the scripts would not run. So, to run a small
    script of let's say five lines, users need to customize their environment by installing
    Python, installing libraries, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This might not be feasible for a lot of users because of restrictions on their
    machines (such as installation not being allowed), so even though there is a requirement
    to run the scripts for those users, they would be unable to use the scripts, which
    would effectively lower efficiency. But the same users, if given the option, could
    easily open the browser of their choice and use those scripts like opening any
    other web page, which would ensure that our scripts bring greater efficiency to
    the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and configuring IIS for web framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we are going to focus on what IIS is and how to configure it, to ensure
    our Python scripts are executed by harnessing the power of a web server framework.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IIS is a tool available on Windows that is used to host web services. In other
    words, if we install IIS we ensure that the machine on which it is installed is
    now acting as a web server. IIS is a fully functional program that is available
    from Add or Remove Programs in Windows. It supports the machine becoming a web
    server, an FTP server, and other things as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the first screen that appears after IIS is installed
    and opened using the IIS icon in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/833bb345-30ef-4b22-9066-4bad30036fb0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the screenshot, the left side of the application indicates
    the server name, and the right side shows the properties that we can configure
    for different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to select **Common Gateway Interface** (**CGI**) support when
    installing IIS from the Windows Add or Remove Programs. After selecting IIS, Windows
    gives us the option to select specific sub-items in IIS, from which CGI and CGI
    support is an option. If this option is not selected during installation, the
    Python scripts will fail to run from the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring IIS for Python script support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let us configure IIS to ensure it supports execution of Python scripts
    on the web server itself, and allows end users to directly run Python scripts
    by calling the web URLs from the web server. The following are the steps to do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we expand the properties on the left, we see the Default Web Site option.
    If you right-click on this, there is a section called Add Application. Click on
    it to see the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a632887a-93aa-431a-a134-863091026f53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screen, we have to enter two specific values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias: This is a value that is part of our web URL. For example, `http://<servername>/test`
    will be the URL if our selected Alias is `test`.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Physical Path:This is the the actual physical directory mapping on which our
    scripts will reside. For example, our script, `testscript.py`, has the following
    path. To call it from the URL we will type the following in our browser:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once we have these values, we click on OK and our website reference is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to map our Python scripts to use the Python interpreter while being
    executed. Once we create the website, we see an option called Handler Mappings
    in the right panel. Click on it and open the section as shown in the following
    screenshot. To add the Python reference, click on `Add Script Map...` as shown
    on the right-hand side of the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9732acee-d630-4921-a62b-951693957c23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this section, we fill in three values:'
  prefs: []
  type: TYPE_NORMAL
- en: Request path: This is always `*.py`, because any script we call will have the
    extension `.py`.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Executable: This is an important section where we reference the actual location
    of `python.exe`. The full path of `python.exe` is needed. In addition to the path,
    we need to add `%s`twice after the executable file path, because this is interpreted
    to take arguments passed from IIS. For example, if our path to Python is `C:\Python`,
    then we would add the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Name:This is simple reference name for the current settings that we have configured.
    It can be any name of your choice.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a button called Request Restrictions inside the Add Script Map section.
    We need to click on that button, and under Access, select the Execute option and
    click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d339304-5b45-41b0-a4ec-16f5ca543352.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we click OK, a prompt comes from IIS to allow the extension. We need to
    select Yes for the settings to be effective:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d5069e66-3b7c-40bc-baae-90772fb95514.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the final step, we select the newly created script map (`Python` in our
    case) and click on Edit Feature Permissions... on the right-hand side. In the
    dialog box, select the Execute option and click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1761816f-aec0-48b2-aaa9-716a39051761.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once all of the preceding steps are followed, we have a running environment
    that supports the execution of Python scripts from a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Once the web server is running, you can test to ensure that it is configured
    correctly by invoking the default page on the web server itself. This is done
    using the `http://localhost` URL from the browser, which should show the Welcome
    IIS page. If this does not show up, then we need to go back and validate the web
    server installation because it means that web server is not up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Creating web-specific scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a running environment that''s ready to run our scripts, let''s
    create a very basic script to take a look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On IDLE, we type the preceding code and save it as a Python file (such as `testscript.py`).
    Now, as we discussed earlier, for our web reference we mapped a physical directory
    or location in IIS. The newly created `testscript.py` needs to be in that folder
    to be accessible from the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the web based URL call for Python script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0d4ddad-b535-4b70-b4ba-3cc5f13c3347.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the script is now called from the
    browser using the localhost URL. The output is a simple `Hello, world !` that
    was called to be printed in script code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, the value `Content-Type: text/plain` specifies that the return
    values from Python will be simple text that the browser will interpret as plain
    text rather than HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s look at an example of modifying it to HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the URL with modified values is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91fbb29c-60d4-4b4e-9cfc-5a081ebbd892.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the first line of the code has been modified to `Content-Type:
    text/html`**. **This ensures that the text now being returned from the script
    is HTML, and hence the last print statement, with `font color` as `red` and `world!`
    in bold html tag is being interpreted correctly in the browser. In real-life scenarios,
    if we want to print a pass, fail, or any other specific message or output from
    our scripts, we should return the values in HTML color-coded and bold formats
    so that they are clearly readable in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of printing a table of 5 in a tabular format in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c73f060b-6bab-4460-8286-dcd3f5e65891.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the first line indicates the return type as HTML. In the next
    few lines, we take a variable named `value` with a value of `5`. Using a `for`
    loop, we create the HTML table and its values (for each row and cell) in a `tval` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final statement returns the value of the `tval` variable to the browser
    where we called the script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting deeper into this example, now let''s create the same table, but the
    number needs to be provided by the web user in the URL. In other words, rather
    than sticking to the static value of `5` in our example, the table needs to be
    generated for the value that is entered by the user in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eed90d41-a775-4220-8ea1-287aafa9d825.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the change in the URL, we pass the number using the enhanced
    URL `http://localhost/test/testscript.py?number=8`. The value specified after
    the question mark, which is referenced as the value passed to the parameter number,
    is now taken as an input in the script. The code now imports a specific inbuilt
    library called `cgi` to read the parameters passed to itself from the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are next two lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: They are used to take a reference of the form as returned from the browser,
    and from the form, the specific parameter named `number`**.** The parameter returned
    is always in string format, so we need to ensure it is converted to our specific
    datatype depending on our usage.
  prefs: []
  type: TYPE_NORMAL
- en: The `value` variable now has the number that we passed from the browser, and
    the rest of the script is executed in the same manner given in previous examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see in the preceding examples, the end user is now only calling the
    script with specific values based upon their needs, and is not concerned about
    the back-end logic or program. For the developer, if there is a bug identified
    in the script, the fix can be done on the main web server as soon as the end users
    start getting correct results. This also saves a lot of effort compared to users
    downloading the new fixed script from a specific location on their machines and
    then running it on their own. Sometimes, even calling the script from the browser
    with parameters becomes a bit tough. In this case, we use form tags in HTML to
    pass values to scripts to fetch outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, ask the user for their name, the number for which the table needs
    to be generated, and output the generated table in a friendly manner with the
    caller''s name in the output. Here''s the HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1355169a-d721-4d70-a1db-54967b7c7e42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: HTML Page
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the HTML code, we create a form that takes the input needed for our script.
    In this case, it asks for a name and the number from which the table needs to
    be generated. Once the user enters this information, the Submit button needs to
    be clicked for the values to be passed to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df0bc049-3729-4bde-a55a-e3eb6f13d59b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Script Output
  prefs: []
  type: TYPE_NORMAL
- en: As the user clicks on the Submit button, the values are passed to the script.
    In the code, we get the values using the same `form.getvalue()` method for each
    of the HTML elements. Once the script has the values fetched from the browser,
    the script logic takes care of what needs to be returned. In our case, as we can
    see in the example, the username has been displayed in the browser, along with
    the table that the user wanted to see as the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example in which we type in the IP address of a device and the
    command that we want to see from the device, using the form and browser output.
    Here''s the HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the only difference is that now we are calling the `getweboutput.py` script, into
    which we are sending the parameters of the device IP address (for the device from
    which we want the output), and the actual command. Here''s the Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python code is now taking the input parameter of `ipaddress` for the device
    IP, and `cmd` for the actual command that needs to be sent to the router. It again
    uses Netmiko, as in [Chapter 2](463dbdd3-1fde-4886-b582-f6de051b1440.xhtml), *Python
    for Network Engineers*, to fetch the information and return it using the `getoutput()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sample 1**: **We provide the IP address and the command show clock**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/438a3e32-d3e2-454e-ab2b-841678717512.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Landing page
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cd167fa-51a4-47c1-a7df-532c627e2d9a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Sample 2**: **For the same script with different parameters provided**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/020a64cf-bb7e-438b-8183-c377a31907c7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Landing Page
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the output when the Submit button is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/104c3097-f2db-4f7e-a998-0534eb9b2a04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we saw, we can create a web-based query tool to fetch information from devices
    with specified commands, which can act as a quick reference for device validations.
    Additionally, with this methodology we are also hiding our username and password
    (`cisco`:`cisco` in this case) without exposing the device credentials to end
    users. The end user is only providing inputs on the web page, and is unaware of
    the code that is being executed at the back-end, which has the device credentials.
  prefs: []
  type: TYPE_NORMAL
- en: We can even have additional checks to ensure that users can only run `show`
    commands and display appropriate messages depending on the various commands users
    will try to call on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a script from dynamic HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when we run a Python script to create dynamic HTML pages (which
    are based upon certain triggers that we put in the script). These pages can be
    enhanced to add additional URLs to invoke other scripts when we click on those
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's say we need to find out how many models of devices are
    in our network. For this we create a script, schedule it to run every hour with
    the task scheduler, and after each run a dynamic HTML page is created to show
    the updated stats or inventory. In a BYODscenario, this also plays an important
    role, because each hour we can monitor what devices are on our network, and if
    we click on any of the discovered devices, we can get additional information such
    as a detailed show version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the Python code to create the dynamic HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bfb5a1b-c5c0-4e1b-95b5-d1431e487dc4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding code creates the dynamic HTML shown in the previous screenshot.
    It queries the vendor from SNMP for the given IP addresses, and creates the table
    based upon the values. The blue color in the IP addresses denotes the hyperlink,
    which, when clicked, will result in the output as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdbe3530-7fd8-48e2-807d-dcd480392933.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the Python code for the output of show version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the URL, when the user clicked on the main dynamic HTML page,
    it invoked another script (the one that was listed earlier) that takes the input
    parameter of the IP address from the URL and, using Netmiko, fetches the version
    of the device.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can gather other stats, such as CPU, memory, a routing summary,
    and other tasks for each of the devices quickly using the web framework approach.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the backend API in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we move ahead, there are times when as a developer we not only need to consume
    APIs, but create our own APIs for others to use. Even if we find recurring usage
    of some functions, keeping in mind web framework strategy, we need to ensure that
    instead of simply creating functions for that task, we need to convert them to
    APIs. A big advantage of that is that the usage of our function or task will then
    not be limited only to Python, but it can be used in any scripting language or
    web language.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will see a very basic approach to creating a functional API to say `Hello
    World` in C#. As a prerequisite, we will need IIS to run the web services, and
    Visual Studio (Community edition is free to use) to create our own API. Later
    on, we will see how to consume that API in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will ensure that the return value is in the JSON format, which
    is the industry standard for API communication, replacing XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke the C# Web project in Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7f523e58-f1f1-4bb3-9127-e1fdc1e0a99a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the Web API checkbox in the next screen shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1a0df4e-d93b-4eed-9c24-6cce40f0bca8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the Controller (this is the main component that will ensure the API framework
    is active):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ba348a19-b854-4eca-85bc-50f0607cc120.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Give a meaningful name to the controller. Note, the name must be followed by
    the word `Controller` (example `testController`), otherwise the controller will
    not function and the API framework will be broken:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d249e72-4e1f-4416-bf5d-a8a49cc7b1e2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the controller is added, under the `WebApiConfig.cs` file add the new
    `JsonMediaTypeFormatter()` config, as shown in the next screenshot. This ensures
    that every output returned from the API will be in JSON format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/64018700-c1fb-49d1-8962-a58fc2e0bf12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the main `apitestController.cs` program, return the value `Hello World`
    once the `Get` method is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73d860b4-94a2-4cb8-a07d-0bda4ef3d515.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, click on the `Run` button that is available in the Visual Studio
    application. A screen similar to the following screenshot will be opened, which
    ensures that the local IIS server is being invoked and the application is initialized
    for testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7900d45b-f90a-44ca-8bc5-1546018e295d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the application is loaded, a URL similar to the following will confirm
    our API is working fine. Note that, at this point, the local IIS Express is being
    used and the API is still not published for external use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa52c019-c5c0-452b-b48e-3e5e97060756.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once validated, now we need to publish this to our IIS. Similar to what we
    did earlier, we create a new application in IIS (named `apitest` in our case):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/878f8386-6690-4df3-980d-ed644acd7e21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the IIS mapping has been done, we use Visual Studio to publish our API
    project to this web folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2a5873a4-3849-4176-a523-62b4058a119d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We create a web Publish profile, and publish it to the local folder that we
    mapped to our IIS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e525a06b-13ec-4923-b118-c373b2b13435.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our API is ready to be used. We can validate it by going to `http://localhost`
    on our browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a15ccb68-ce3f-4993-89f2-515685693803.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consuming the API in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, as we have the API created, let us see how to consume the API in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0dfd313-d468-4755-acb2-3f2febe8eba4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For API interaction, we use the `requests` library in Python. When we perform
    a call to the API, the API returns the string in JSON format. The `r.json()`method
    converts the returned JSON to extract the text value and displays the output as
    `Hello World`.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, we can use the requests library to fetch API results from
    various web-based API calls. The result is generally in XML or JSON format, with
    JSON being the preferred return method for the API calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see another example to fetch some more JSON from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e64ff339-7c8f-4d71-b47a-5664b533ab01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we now call the GitHub API, we get the JSON value as shown previously. As
    we can see, the return value is like a dictionary in the JSON return data of the
    API call, so we can explicitly get the text inside the `message` dictionary key.
    In the preceding output, the first output is the raw JSON return value, and the
    next output is the extracted text from the `message` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to calling the standard APIs, there are times when we need to pass
    credentials to the API to fetch information. In other words, there needs to be
    an authentication in place for the APIs to respond with requested data. In our
    API, let us now enable basic authentication from IIS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the IIS, select your website (`apitest` in our case), and under the Authentication
    section, select Basic Authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c4bd726-2d81-4a5d-9d5b-d2d8dea242fc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This ensures that any request that calls this API needs to have basic authentication
    (a username and a password) to access the content. Additionally, we create a simple
    user `testuser` with a password `testpassword` in the Users application on a Windows
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since authentication is now enabled, let us see what we get if no credentials
    are passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/833d1d8d-18fe-4d0a-97f1-ca48b78c6c9c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We get a Response [401], which means *unauthorized* access in a HTTP call. In
    other words, the API call is unauthorized and hence no output will be given back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we see the same call, but this time with authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad4bf86f-8630-4fc8-95ee-d600411f7982.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we call the authentication method `HTTPBasicAuth`, and pass the
    username and password in the `requests.get` call. As we have provided the correct
    credentials, we get back a Response [200], which is OK in HTTP, and in the last
    line we print the output of the returned value, which in our case is `Hello World`.
  prefs: []
  type: TYPE_NORMAL
- en: Sample summary task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are now familiar with the web framework, let us perform a task that covers
    all the aspects that we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: We write a HTML page that asks for the username and password from the user.
    Those values will be passed into a Python script which will call the API that
    we created earlier to authenticate. If the return value is authorized, then we
    display the IP addresses of the devices that we want to view the additional information
    for on another web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, the user can click on any of the IP addresses to view the `show ip int
    brief` output. If the authorization fails, the script returns the message Not
    Authorized and will not display the IP addresses. For reference (valid set of
    username and password):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Username**: `Abhishek`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password**: `password`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTML Code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have used the `POST` method in this case, since the password will be shown
    in clear text on the browser URL if we use the default `GET` method. In the `POST` method,
    there is a separate connection made at the back-end, and the URL does not show
    the values that are being passed on to the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of incorrect credentials (credentials that are not valid, like dummy
    credentials) being provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c6aacd4b-9466-440d-8345-75a2731f76c7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we click on Submit button, it will display the message as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06309a5b-bfac-4185-835b-50727c2161aa.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In case of correct credentials (that are correct and authenticated successfully
    at web server):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2857b776-ace6-4a8f-8aad-e248b6072ecf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we click on Submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9568740-10fc-4180-9561-e7b39b47cfa6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we see the IP addresses, which we can now use to get the output. We select
    the IP address that we want to use and click on Select IPaddress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/52320f4e-56fa-46ea-a102-27fd7471a40f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we click on Submit (or the Select IPaddress button), we get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d96ed8d1-af13-428d-851c-490d4070b36b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, if we look at the preceding output URL, since we used the `POST` method
    for this selection, we only see the script but not the parameters that were passed
    in the URL. This ensures that people need to go from the landing page (in our
    case, `main.html`), and cannot directly call any URL with parameters that could
    have been given if we were using the `GET` method.
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, we are also ensuring that end users executing this follow a step-by-step
    selection, and are not jumping from one URL to the other without performing the
    sequential steps.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, end users can create their own APIs to fetch information
    such as bulk device names and IP addresses, and can use that information in their
    script to create front-end, back-end, or web-enabled scenarios quickly accessible
    from any browser without the need for any end user installations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now understood the web framework and with relevant examples, the usage
    of APIs. This includes how to create an API, access APIs, and even work with authentication
    on APIs. Using this knowledge, we will now be able to develop web based tools
    for end users. The IIS functionality has also been introduced, which helps developers
    to customize various web-based settings such as authentications, authorizations,
    and creating websites.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, with a fully functional example of a given scenario, readers can
    quickly build web-based Python scripts, which remove the need for any end user
    installations of Python and customized libraries. This makes support and bug fixing
    much easier, owing to having a single machine to fix. A fix done on the server
    will ensure that all end users will now be using the fixed or enhanced functions
    of the script, rather than downloading a local copy on their machines to get the
    fixed or enhanced script.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the use of Ansible, which is a popular
    open source automation platform.
  prefs: []
  type: TYPE_NORMAL
