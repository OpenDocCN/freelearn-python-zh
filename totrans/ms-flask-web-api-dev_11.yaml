- en: <st c="0">11</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">11</st>
- en: <st c="3">Deploying Flask Applications</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">部署 Flask 应用程序</st>
- en: <st c="32">When the development of a Flask application is over, you can always
    decide to deploy it somewhere outside Werkzeug’s HTTP server.</st> <st c="163">The
    final application needs a production server that is fast and reliable, with minimal
    or no potential security risks, configurable, and easy to manage.</st> <st c="317">Instead
    of utilizing the built-in Werkzeug server, the product needs a non-development
    server not for development, debugging, or testing but for running the software
    product.</st> <st c="492">Flask deployment requires a stable and independent Python
    server or a</st> <st c="562">hosting platform.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32">当 Flask 应用程序的开发完成时，你总是可以决定将其部署到 Werkzeug 的 HTTP 服务器之外的地方。</st> <st
    c="163">最终的应用程序需要一个快速且可靠的、具有最小或无潜在安全风险的、可配置且易于管理的生产服务器。</st> <st c="317">除了利用内置的
    Werkzeug 服务器外，产品需要一个非开发服务器，该服务器不是用于开发、调试或测试，而是用于运行软件产品。</st> <st c="492">Flask
    部署需要一个稳定且独立的 Python 服务器或</st> <st c="562">托管平台。</st>
- en: <st c="579">This chapter will focus on different approaches, options, and procedures
    for deploying Flask applications to production servers suited for the product’s
    scope, environment,</st> <st c="753">and objectives.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="579">本章将重点介绍将 Flask 应用程序部署到适合产品范围、环境和</st> <st c="753">目标的生产服务器的不同方法、选项和程序。</st>
- en: <st c="768">The following topics will be covered in</st> <st c="809">this chapter:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="768">本章将涵盖以下主题：</st> <st c="809">：</st>
- en: <st c="822">Running the application on Gunicorn</st> <st c="859">and uWSGI</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="822">在 Gunicorn</st> <st c="859">和 uWSGI 上运行应用程序</st>
- en: <st c="868">Running the application</st> <st c="893">on Uvicorn</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="868">在 Uvicorn 上运行应用程序</st> <st c="893">中</st>
- en: <st c="903">Deploying the application to the Apache</st> <st c="944">HTTP Server</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="903">将应用程序部署到 Apache</st> <st c="944">HTTP 服务器</st>
- en: <st c="955">Deploying the application</st> <st c="982">to Docker</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="955">将应用程序部署到 Docker</st> <st c="982">中</st>
- en: <st c="991">Deploying the application</st> <st c="1018">to Kubernetes</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="991">将应用程序部署到 Kubernetes</st> <st c="1018">中</st>
- en: <st c="1031">Creating an API gateway</st> <st c="1056">using NGINX</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1031">使用 NGINX 创建一个 API 网关</st> <st c="1056">中</st>
- en: <st c="1067">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1067">技术要求</st>
- en: <st c="1090">Our application will be using PostgreSQL to manage its data.</st>
    <st c="1152">The projects will also be applying the</st> `<st c="1191">Blueprint</st>`
    <st c="1200">approach of managing Flask components.</st> <st c="1240">The project
    prototype will focus on simple e-commerce, inventory, and stocking transactions
    for a small-scale grocery store, and it will be called an</st> *<st c="1390">Online
    Grocery</st>* <st c="1404">application.</st> <st c="1418">All these applications
    can be found</st> <st c="1454">at</st> [<st c="1457">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch11</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch11)<st
    c="1538">.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1090">我们的应用程序将使用 PostgreSQL 来管理其数据。</st> <st c="1152">项目还将应用</st> `<st
    c="1191">蓝图</st>` <st c="1200">方法来管理 Flask 组件。</st> <st c="1240">项目原型将专注于小型杂货店的简单电子商务、库存和库存交易，并将被称为</st>
    *<st c="1390">在线杂货店</st>* <st c="1404">应用程序。</st> <st c="1418">所有这些应用程序都可以在</st>
    <st c="1454">以下位置找到</st> [<st c="1457">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch11</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch11)<st
    c="1538">。</st>
- en: <st c="1539">Getting ready for deployment</st>
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1539">准备部署</st>
- en: <st c="1568">In this chapter, we’ll create an</st> *<st c="1602">Online Grocery</st>*
    <st c="1616">application that can be deployed to different platforms.</st> <st
    c="1674">The</st> <st c="1678">application is an API-based type with administration,
    login, inventory, stocking, order, and purchase modules designed for small business
    transactions of a small shopping or</st> <st c="1852">grocery store.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1568">在本章中，我们将创建一个</st> *<st c="1602">在线杂货店</st>* <st c="1616">应用程序，该应用程序可以部署到不同的平台。</st>
    <st c="1674">该应用程序是一个基于 API 的类型，具有管理、登录、库存、库存、订单和购买模块，专为小型购物或</st> <st c="1852">杂货店的商业交易设计。</st>
- en: <st c="1866">The Peewee ORM builds the application’s model and repository layer.</st>
    <st c="1935">To utilize the standard</st> `<st c="1959">Peewee</st>` <st c="1965">module,
    install it and the</st> `<st c="1993">psycopg2</st>` <st c="2001">driver using
    the following</st> `<st c="2029">pip</st>` <st c="2032">command:</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1866">Peewee ORM构建应用程序的模型和仓库层。</st> <st c="1935">要利用标准</st> `<st c="1959">Peewee</st>`
    <st c="1965">模块，请使用以下</st> `<st c="1993">pip</st>` <st c="2001">命令安装它和</st> `<st
    c="2029">psycopg2</st>` <st c="2032">驱动程序：</st>
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="2069">The Peewee ORM provides the standard</st> *<st c="2107">INSERT</st>*<st
    c="2113">,</st> *<st c="2115">UPDATE</st>*<st c="2121">,</st> *<st c="2123">DELETE</st>*<st
    c="2129">, and</st> *<st c="2135">SELECT</st>* <st c="2141">transactions, thus
    including the</st> `<st c="2175">psycopg2</st>` <st c="2183">driver as a dependency
    library.</st> <st c="2216">Let’s begin structuring the model layer of the</st>
    <st c="2263">Peewee ORM.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2069">Peewee ORM提供了标准的</st> *<st c="2107">INSERT</st>*<st c="2113">,</st>
    *<st c="2115">UPDATE</st>*<st c="2121">,</st> *<st c="2123">DELETE</st>*<st c="2129">,
    和</st> *<st c="2135">SELECT</st>* <st c="2141">事务，因此包括</st> `<st c="2175">psycopg2</st>`
    <st c="2183">驱动程序作为依赖库。</st> <st c="2216">让我们开始构建Peewee ORM的模型层。</st>
- en: <st c="2274">Classes and methods for the standard Peewee ORM</st>
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="2274">标准Peewee ORM的类和方法</st>
- en: <st c="2322">Our</st> *<st c="2327">Online Grocery</st>* <st c="2341">application</st>
    <st c="2354">is deployed to a</st> **<st c="2371">Gunicorn</st>** <st c="2379">server</st>
    <st c="2387">and uses the standard</st> <st c="2409">Peewee helper classes and
    methods to establish the model layer and the repository classes.</st> <st c="2500">Here
    is a typical Peewee configuration for the PostgreSQL</st> <st c="2558">database
    connection:</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2322">我们的</st> *<st c="2327">在线杂货店</st>* <st c="2341">应用程序</st> <st c="2354">部署到一个</st>
    **<st c="2371">Gunicorn</st>** <st c="2379">服务器</st> <st c="2387">上，并使用标准的</st>
    <st c="2409">Peewee辅助类和方法来建立模型层和仓库类。</st> <st c="2500">以下是针对PostgreSQL数据库连接的典型Peewee配置：</st>
    <st c="2558">数据库连接：</st>
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="3312">(app/models/db.py)</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3312">(app/models/db.py)</st>
- en: <st c="3331">from app.models.config import database</st> from peewee import
    Model, CharField, IntegerField, BigIntegerField, ForeignKeyField, DateField <st
    c="3466">class Product(Model):</st> id = BigIntegerField(<st c="3509">primary_key=True</st>,
    null=False, <st c="3540">sequence="product_id_seq"</st>)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3331">from app.models.config import database</st> from peewee import
    Model, CharField, IntegerField, BigIntegerField, ForeignKeyField, DateField <st
    c="3466">class Product(Model):</st> id = BigIntegerField(<st c="3509">primary_key=True</st>,
    null=False, <st c="3540">sequence="product_id_seq"</st>)
- en: code = CharField(max_length="20", unique="True", null=False)
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: code = CharField(max_length="20", unique="True", null=False)
- en: 'name = CharField(max_length="100", null=False) <st c="3676">btype = ForeignKeyField(model=Brand,
    null=False,</st> <st c="3724">to_field="code", backref="brand")</st><st c="3758">ctype
    = ForeignKeyField(model=Category, null=False,</st> <st c="3810">to_field="code",
    backref="category")</st> … … … … … … <st c="4014">Product</st> model class represents
    the record details of a product sold by the grocery store, while the following
    <st c="4124">Stock</st> model creates stock information about a product:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: name = CharField(max_length="100", null=False) <st c="3676">btype = ForeignKeyField(model=Brand,
    null=False,</st> <st c="3724">to_field="code", backref="brand")</st><st c="3758">ctype
    = ForeignKeyField(model=Category, null=False,</st> <st c="3810">to_field="code",
    backref="category")</st> … … … … … … <st c="4014">Product</st>模型类表示杂货店销售产品的记录详情，而下面的<st
    c="4124">Stock</st>模型创建关于产品的库存信息：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="4667">All model</st> <st c="4678">classes must</st> <st c="4691">subclass
    Peewee’s</st> `<st c="4709">Model</st>` <st c="4714">class to become the logical
    representations of the database tables.</st> <st c="4783">The Peewee model classes,
    like the given</st> `<st c="4824">Product</st>` <st c="4831">and</st> `<st c="4836">Stock</st>`<st
    c="4841">, have the</st> `<st c="4852">Meta</st>` <st c="4856">class, which holds
    the</st> `<st c="4880">database</st>` <st c="4888">and</st> `<st c="4893">db_table</st>`
    <st c="4901">attributes responsible for mapping them to the physical tables of
    our database.</st> <st c="4982">Peewee’s column helper classes build the column
    attributes of the model classes.</st> <st c="5063">Now, the</st> `<st c="5072">main.py</st>`
    <st c="5079">module must enable the</st> `<st c="5103">before_request()</st>`
    <st c="5119">glocal event of Flask to handle the database connection.</st> <st
    c="5177">The following snippet shows the implementation of the</st> `<st c="5231">before_request()</st>`
    <st c="5247">global event:</st>
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="4667">所有模型</st> <st c="4678">类必须</st> <st c="4691">继承 Peewee 的</st> `<st
    c="4709">Model</st>` <st c="4714">类以成为数据库表的逻辑表示。</st> <st c="4783">Peewee 模型类，如给定的</st>
    `<st c="4824">Product</st>` <st c="4831">和</st> `<st c="4836">Stock</st>`<st c="4841">，有</st>
    `<st c="4852">Meta</st>` <st c="4856">类，它包含</st> `<st c="4880">database</st>`
    <st c="4888">和</st> `<st c="4893">db_table</st>` <st c="4901">属性，负责将它们映射到我们数据库的物理表。</st>
    <st c="4982">Peewee 的列辅助类构建模型类的列属性。</st> <st c="5063">现在，</st> `<st c="5072">main.py</st>`
    <st c="5079">模块必须启用 Flask 的</st> `<st c="5103">before_request()</st>` <st c="5119">全局事件来处理数据库连接。</st>
    <st c="5177">以下片段显示了</st> `<st c="5231">before_request()</st>` <st c="5247">全局事件的实现：</st>
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: from app.models.db import Product
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从 app.models.db 导入 Product
- en: from app.models.db import database
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从 app.models.db 导入 database
- en: from typing import Dict, Any
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从 typing 导入 Dict, Any
- en: 'class ProductRepository:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'class ProductRepository:'
- en: 'def insert_product(self, details:Dict[str, Any]) -> bool:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def insert_product(self, details:Dict[str, Any]) -> bool:'
- en: 'try: <st c="6015">with database.atomic() as tx:</st><st c="6044">Product.create(**details)</st><st
    c="6070">tx.commit()</st> return True'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="6015">使用 database.atomic() 作为 tx:</st><st c="6044">Product.create(**details)</st><st
    c="6070">tx.commit()</st> 返回 True'
- en: 'except Exception as e:'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印(e)
- en: return False
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 False
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'def update_product(self, details:Dict[str,Any]) -> bool:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update_product(self, details:Dict[str,Any]) -> bool:'
- en: 'try: <st c="6954">with database.atomic() as tx:</st><st c="6983">prod = Product.get(</st>
    <st c="7003">Product.code==details["code"])</st> prod.rate = details["name"]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="6954">使用 database.atomic() 作为 tx:</st><st c="6983">prod = Product.get(</st>
    <st c="7003">Product.code==details["code"])</st> prod.rate = details["名称"]'
- en: prod.code = details["btype"]
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: prod.code = details["类型"]
- en: prod.rate = details["ctype"]
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: prod.rate = details["类型"]
- en: prod.code = details["unit_type"]
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: prod.code = details["单位类型"]
- en: prod.rate = details["sell_price"]
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: prod.rate = details["售价"]
- en: prod.code = details["purchase_price"]
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: prod.code = details["采购价格"]
- en: prod.rate = details["discount"] <st c="7258">prod.save()</st><st c="7269">tx.commit()</st>
    return True
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: prod.rate = details["折扣"] <st c="7258">prod.save()</st><st c="7269">tx.commit()</st>
    返回 True
- en: 'except Exception as e:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印(e)
- en: return False
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 False
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'def delete_product_code(self, code:str) -> bool:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'def delete_product_code(self, code:str) -> bool:'
- en: 'try: <st c="8086">with database.atomic() as tx:</st><st c="8115">prod = Product.get(Product.code==code)</st><st
    c="8154">prod.delete_instance()</st><st c="8177">tx.commit()</st> return True'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="8086">使用 database.atomic() 作为 tx:</st><st c="8115">prod = Product.get(Product.code==code)</st><st
    c="8154">prod.delete_instance()</st><st c="8177">tx.commit()</st> 返回 True'
- en: 'except Exception as e:'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印(e)
- en: return False
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 False
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'def select_product_code(self, code:str): <st c="8764">prod = Product.select(Product.code==code)</st>
    return <st c="8813">prod.to_json()</st> def select_product_id(self, id:int): <st
    c="8865">prod = Product.select(Product.id==id)</st> return <st c="8910">prod.to_json()</st>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'def select_product_code(self, code:str): <st c="8764">prod = Product.select(Product.code==code)</st>
    返回 <st c="8813">prod.to_json()</st> def select_product_id(self, id:int): <st c="8865">prod
    = Product.select(Product.id==id)</st> 返回 <st c="8910">prod.to_json()</st>'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'def select_all_product(self): <st c="9062">prods = Product.select()</st><st
    c="9086">records = [log.to_json() for log in prods]</st> return records'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'def select_all_product(self): <st c="9062">prods = Product.select()</st><st
    c="9086">records = [log.to_json() for log in prods]</st> 返回 records'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: pip install aiopg peewee-async
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: pip install aiopg peewee-async
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="10455">from peewee_async import PooledPostgresqlDatabase</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10455">从 peewee_async 导入 PooledPostgresqlDatabase</st>
- en: <st c="10505">database = PooledPostgresqlDatabase(</st> 'ogs', user='postgres',
    password='admin2255',
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10505">database = PooledPostgresqlDatabase(</st> 'ogs', user='postgres',
    password='admin2255',
- en: host='localhost', port='5432', <st c="10620">max_connections = 3</st>,
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: host='localhost', port='5432', <st c="10620">最大连接数 = 3</st>,
- en: connect_timeout = 3, <st c="10731">3</st> with <st c="10738">autocommit</st>
    set to <st c="10756">False</st>.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`connect_timeout = 3, <st c="10731">3</st>` `<st c="10738">autocommit</st>`
    `<st c="10756">设置为</st>` `<st c="10756">False</st>.`'
- en: '<st c="10762">The Async Peewee ORM handles database connectivity differently:
    it does not use the</st> `<st c="10847">before_request()</st>` <st c="10863">and</st>
    `<st c="10868">teardown_request()</st>` <st c="10886">events but rather uses configuration
    with the</st> `<st c="10933">create_app()</st>` <st c="10945">factory method.</st>
    <st c="10962">The following snippet shows how to establish a PostgreSQL database
    connection using the</st> `<st c="11050">peewee-async</st>` <st c="11062">module:</st>'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="10762">异步Peewee ORM处理数据库连接的方式不同：它不使用</st>` `<st c="10847">before_request()</st>`
    `<st c="10863">和</st>` `<st c="10868">teardown_request()</st>` `<st c="10886">事件，而是使用与</st>`
    `<st c="10933">create_app()</st>` `<st c="10945">工厂方法</st>` `<st c="10962">的配置。</st>`
    `<st c="10962">以下代码片段展示了如何使用</st>` `<st c="11050">peewee-async</st>` `<st c="11062">模块</st>`
    `<st c="11062">建立PostgreSQL数据库连接：</st>`'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="11325">Here,</st> `<st c="11332">Manager</st>` <st c="11339">establishes
    an</st> `<st c="11355">asyncio</st>` <st c="11362">database connection pattern
    without using</st> `<st c="11405">before_request()</st>` <st c="11421">to connect
    to and</st> `<st c="11440">teardown_request()</st>` <st c="11458">to disconnect
    from the</st> <st c="11482">database.</st> <st c="11492">However, it can emit
    the</st> `<st c="11517">connect()</st>` <st c="11526">and</st> `<st c="11531">close()</st>`
    <st c="11538">methods to manage the database connection</st> <st c="11581">during
    query execution explicitly.</st> <st c="11616">Instantiating the</st> `<st c="11634">Manager</st>`
    <st c="11641">class requires the database connection object and an optional</st>
    `<st c="11704">asyncio</st>` <st c="11711">event loop.</st> <st c="11724">Through
    the</st> `<st c="11736">Manager</st>` <st c="11743">object, you can invoke its</st>
    `<st c="11771">set_allow_sync()</st>` <st c="11787">method and set it to</st>
    `<st c="11809">False</st>` <st c="11814">to restrict the usage of non-async utility</st>
    <st c="11858">Peewee methods.</st>
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`<st c="11325">` `<st c="11332">经理</st>` `<st c="11339">建立了一个</st>` `<st
    c="11355">asyncio</st>` `<st c="11362">数据库连接模式，不使用</st>` `<st c="11405">before_request()</st>`
    `<st c="11421">来连接到</st>` `<st c="11440">teardown_request()</st>` `<st c="11458">来断开与数据库的</st>`
    `<st c="11482">连接。</st>` `<st c="11492">然而，它可以在查询执行期间显式地发出</st>` `<st c="11517">connect()</st>`
    `<st c="11526">和</st>` `<st c="11531">close()</st>` `<st c="11538">方法来管理数据库连接。</st>`
    `<st c="11581">` `<st c="11616">实例化</st>` `<st c="11634">Manager</st>` `<st c="11641">类需要数据库连接对象和一个可选的</st>`
    `<st c="11704">asyncio</st>` `<st c="11711">事件循环。</st>` `<st c="11724">通过</st>`
    `<st c="11736">Manager</st>` `<st c="11743">对象，你可以调用它的</st>` `<st c="11771">set_allow_sync()</st>`
    `<st c="11787">方法并将其设置为</st>` `<st c="11809">False</st>` `<st c="11814">以限制非异步实用程序</st>`
    `<st c="11858">Peewee方法的使用。</st>`
- en: <st c="11873">The</st> `<st c="11878">conn_mgr</st>` <st c="11886">and</st>
    `<st c="11891">database</st>` <st c="11899">objects are equally essential for
    building the repository layer, as depicted in the following</st> `<st c="11994">DiscountRepository</st>`
    <st c="12012">implementation:</st>
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="11873">` `<st c="11878">conn_mgr</st>` `<st c="11886">和</st>` `<st
    c="11891">database</st>` `<st c="11899">对象对于构建仓库层同样至关重要，如下面的</st>` `<st c="11994">DiscountRepository</st>`
    `<st c="12012">实现</st>` `<st c="12012">所示：</st>`'
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="12408">Although the implementation of the model layer is similar to the
    standard Peewee, its repository</st> <st c="12506">layer is not the same</st>
    <st c="12528">because of the</st> `<st c="12543">asyncio</st>` <st c="12550">platform
    used by the ORM to perform the CRUD transactions.</st> <st c="12610">For instance,
    the following</st> `<st c="12638">insert_discount()</st>` <st c="12655">function
    emits</st> `<st c="12671">atomic_async()</st>` <st c="12685">from the</st> `<st
    c="12695">conn_mgr</st>` <st c="12703">instance to generate an async transaction
    layer, which will commit the inserted</st> `<st c="12784">Discount</st>` <st c="12792">record
    performed by the</st> `<st c="12817">create()</st>` <st c="12825">method of</st>
    `<st c="12836">conn_mgr</st>`<st c="12844">, not by</st> `<st c="12853">Discount</st>`<st
    c="12861">. The use of the</st> `<st c="12878">async</st>`<st c="12883">/</st>`<st
    c="12885">await</st>` <st c="12890">keywords is present in</st> <st c="12914">the
    implementations.</st>
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="12408">尽管模型层的实现与标准 Peewee 相似，但由于 ORM 使用的</st>` `<st c="12543">asyncio</st>`
    `<st c="12550">平台执行 CRUD 事务，其存储库</st> `<st c="12506">层并不相同。</st> `<st c="12528">例如，以下</st>`
    `<st c="12638">insert_discount()</st>` `<st c="12655">函数从`<st c="12695">conn_mgr</st>`
    `<st c="12703">实例发出`<st c="12671">atomic_async()</st>` `<st c="12685">，以生成异步事务层，该层将提交由`<st
    c="12836">conn_mgr</st>` `<st c="12844">的`<st c="12817">create()</st>` `<st c="12825">方法执行的插入`<st
    c="12784">Discount</st>` `<st c="12792">记录，而不是由`<st c="12853">Discount</st>` `<st
    c="12861">执行。</st> `<st c="12878">async</st>` `<st c="12883">/</st>` `<st c="12885">await</st>`
    `<st c="12890">关键字在实现中存在。</st>`'
- en: <st c="12934">On the</st> `<st c="12942">UPDATE</st>` <st c="12948">operation,
    the</st> `<st c="12964">get()</st>` <st c="12969">method of</st> `<st c="12980">conn_mgr</st>`
    <st c="12988">retrieves the record object that needs updating, and its</st> `<st
    c="13046">update()</st>` <st c="13054">method flushes the newly updated fields
    to the table.</st> <st c="13109">Again, the async</st> `<st c="13126">Manager</st>`
    <st c="13133">methods operate the transaction, not the model class.</st> <st c="13188">The
    following</st> `<st c="13202">update_discount()</st>` <st c="13219">function showcases
    Peewee’s async approach to updating</st> <st c="13275">table records:</st>
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `<st c="12934">UPDATE</st>` <st c="12948">操作中，`<st c="12964">get()</st>` <st
    c="12969">方法从`<st c="12980">conn_mgr</st>` <st c="12988">中检索需要更新的记录对象，并且其`<st
    c="13046">update()</st>` <st c="13054">方法将新更新的字段刷新到表中。</st> `<st c="13109">再次强调，异步</st>`
    `<st c="13126">Manager</st>` <st c="13133">方法操作的是事务，而不是模型类。</st> `<st c="13188">以下</st>`
    `<st c="13202">update_discount()</st>` <st c="13219">函数展示了 Peewee 更新表记录的异步方法：</st>
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="13594">The local</st> <st c="13605">parameters of the</st> `<st c="13623">update()</st>`
    <st c="13631">method of</st> `<st c="13642">conn_mgr</st>` <st c="13650">include
    the record object with the updated fields</st> <st c="13701">and the</st> `<st
    c="13709">only</st>` <st c="13713">parameter for controlling a tuple of field
    names that need updating in</st> <st c="13785">the table.</st>
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13594">本地</st> <st c="13605">参数包括</st> `<st c="13623">update()</st>`
    <st c="13631">方法中的</st> `<st c="13642">conn_mgr</st>` <st c="13650">记录对象以及需要更新的字段</st>
    <st c="13701">的</st> `<st c="13709">唯一</st>` <st c="13713">参数，这些字段需要在表中进行更新。</st>
- en: <st c="13795">On the other hand, the</st> `<st c="13819">DELETE</st>` <st c="13825">operation
    uses the same async</st> `<st c="13856">get()</st>` <st c="13861">method of</st>
    `<st c="13872">conn_mgr</st>` <st c="13880">in</st> `<st c="13884">update_discount()</st>`
    <st c="13901">to retrieve the record object for deletion.</st> <st c="13946">As
    shown in the following</st> `<st c="13972">delete_discount_code()</st>` <st c="13994">function,
    the async</st> `<st c="14015">delete()</st>` <st c="14023">method of</st> `<st
    c="14034">conn_mgr</st>` <st c="14042">deletes the record from the table using
    the</st> <st c="14087">record object:</st>
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="13795">另一方面，DELETE</st>` `<st c="13819">操作使用与`<st c="13825">update_discount()</st>`
    `<st c="13884">中相同的异步</st>` `<st c="13856">get()</st>` `<st c="13861">方法从`<st
    c="13872">conn_mgr</st>` `<st c="13880">中检索要删除的记录对象。</st> `<st c="13946">以下</st>`
    `<st c="13972">delete_discount_code()</st>` `<st c="13994">函数显示了`<st c="14015">conn_mgr</st>`
    `<st c="14034">的异步`<st c="14023">delete()</st>` `<st c="14042">方法如何使用记录对象从表中删除记录：</st>'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="14338">When implementing async query transactions, the Async Peewee ORM
    uses the</st> `<st c="14413">Manager</st>` <st c="14420">class’s async</st> `<st
    c="14435">get()</st>` <st c="14440">method to retrieve a single record and the</st>
    `<st c="14484">execute()</st>` <st c="14493">method to</st> <st c="14504">wrap
    and run the</st> `<st c="14521">select()</st>` <st c="14529">statement for retrieving
    a single or all the records asynchronously.</st> <st c="14599">The</st> <st c="14603">following
    snippets show the query implementation</st> <st c="14652">for</st> `<st c="14656">DiscountRepository</st>`<st
    c="14674">:</st>
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="14338">在实现异步查询事务时，Async Peewee ORM 使用</st> `<st c="14413">Manager</st>`
    <st c="14420">类的异步</st> `<st c="14435">get()</st>` <st c="14440">方法来检索单个记录，并使用</st>
    `<st c="14484">execute()</st>` <st c="14493">方法来</st> <st c="14504">包装并运行用于检索单个或所有记录的异步</st>
    `<st c="14521">select()</st>` <st c="14529">语句。</st> <st c="14599">以下代码片段显示了针对</st>
    `<st c="14656">DiscountRepository</st>`<st c="14674">的查询实现</st>：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="15072">So, all these bundled methods in the</st> `<st c="15110">Manager</st>`
    <st c="15117">class’s instance provide the operations for implementing the CRUD
    transactions in the asynchronous</st> <st c="15217">transaction layer.</st>
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15072">因此，在</st> `<st c="15110">Manager</st>` <st c="15117">类实例中的所有这些捆绑方法都提供了在异步</st>
    <st c="15217">事务层中实现 CRUD 事务的操作。</st>
- en: <st c="15235">Peewee is a simple and flexible ORM for small to middle-scale
    Flask applications.</st> <st c="15318">Although SQLAlchemy offers more powerful
    utilities, it is not suited for a small application like our</st> *<st c="15420">Online
    Grocery</st>* <st c="15434">application, which has less scope</st> <st c="15469">and
    complexity.</st>
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15235">Peewee 是一个简单且灵活的 ORM，适用于小型到中型 Flask 应用程序。</st> <st c="15318">尽管
    SQLAlchemy 提供了更强大的实用工具，但它不适合像我们的</st> *<st c="15420">在线杂货店</st>* <st c="15434">应用程序这样的小型应用程序，该应用程序的范围</st>
    <st c="15469">和复杂性较低。</st>
- en: <st c="15484">Next, we’ll deploy our applications that utilize both the standard
    and asynchronous Peewee ORM for their</st> <st c="15590">repository layers.</st>
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15484">接下来，我们将部署利用标准异步 Peewee ORM 的</st> <st c="15590">存储层</st> 的应用程序。</st>
- en: <st c="15608">Running the application on Gunicorn and uWSGI</st>
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15608">在 Gunicorn 和 uWSGI 上运行应用程序</st>
- en: <st c="15654">The main</st> <st c="15664">reason why Flask applications start
    by running the</st> `<st c="15715">flask run</st>` <st c="15724">command or by
    calling</st> `<st c="15747">app.run()</st>` <st c="15756">in</st> `<st c="15760">main.py</st>`
    <st c="15767">during</st> <st c="15775">development is because of the built-in
    WSGI server that the</st> `<st c="15835">werkzeug</st>` <st c="15843">module has.</st>
    <st c="15856">However, there are limitations that this server possesses, such
    as its inability to respond to more requests from clients without slowing down</st>
    <st c="15999">and its incapability to maximize</st> <st c="16032">the resources
    of the production server.</st> <st c="16072">Moreover, the built-in server has
    several vulnerabilities, which pose security risks.</st> <st c="16158">For</st>
    <st c="16162">standard Flask applications, it is best to use another WSGI server</st>
    <st c="16229">for production, such as</st> **<st c="16253">Gunicorn</st>** <st
    c="16261">or</st> **<st c="16265">uWSGI</st>**<st c="16270">.</st>
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15654">Flask 应用程序之所以从运行</st> `<st c="15715">flask run</st>` <st c="15724">命令或通过在</st>
    `<st c="15760">main.py</st>` <st c="15767">中调用</st> `<st c="15747">app.run()</st>`
    <st c="15756">开始，主要是由于</st> `<st c="15835">werkzeug</st>` <st c="15843">模块内置的
    WSGI 服务器。</st> <st c="15856">然而，这个服务器存在一些限制，例如它无法在不减慢速度的情况下响应用户的更多请求，以及它无法最大化生产服务器的资源。</st>
    <st c="16072">此外，内置服务器还包含几个漏洞，这些漏洞可能带来安全风险。</st> <st c="16158">对于标准 Flask 应用程序，最好使用另一个
    WSGI 服务器</st> <st c="16229">用于生产，例如</st> **<st c="16253">Gunicorn</st>** <st c="16261">或</st>
    **<st c="16265">uWSGI</st>**<st c="16270">。</st>
- en: <st c="16271">Let’s start by deploying our application to the</st> *<st c="16320">Gunicorn</st>*
    <st c="16328">server.</st>
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="16271">让我们首先将我们的应用程序部署到</st> *<st c="16320">Gunicorn</st>* <st c="16328">服务器。</st>
- en: <st c="16336">Using the Gunicorn server</st>
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="16336">使用 Gunicorn 服务器</st>
- en: '`<st c="16723">ch11-guni</st>` <st c="16732">application.</st> <st c="16746">But
    first, we must install the</st> `<st c="16777">gunicorn</st>` <st c="16785">module
    in the application’s virtual environment using the following</st> `<st c="16854">pip</st>`
    <st c="16857">command:</st>'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="16723">ch11-guni</st>` <st c="16732">应用程序。</st> <st c="16746">但首先，我们必须使用以下</st>
    `<st c="16854">pip</st>` <st c="16857">命令在应用程序的虚拟环境中安装</st> `<st c="16777">gunicorn</st>`
    <st c="16785">模块：</st>'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="16887">Then, run the</st> `<st c="16902">gunicorn</st>` <st c="16910">command
    with the module name and the</st> `<st c="16948">app</st>` <st c="16951">instance</st>
    <st c="16961">in</st> `<st c="16964">{module}</st>` **<st c="16972">:{flask_app}</st>**
    <st c="16985">format, the binding host address, and the port.</st> <st c="17034">The
    following is the complete command to run a standard Flask application on the Gunicorn
    server with a</st> <st c="17138">single worker:</st>
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="16887">然后，使用模块名称和</st> `<st c="16948">app</st>` <st c="16951">实例</st>
    <st c="16961">在</st> `<st c="16964">{module}</st>` **<st c="16972">:{flask_app}</st>**
    <st c="16985">格式，绑定主机地址和端口来运行</st> `<st c="16902">gunicorn</st>` <st c="16910">命令。</st>
    <st c="17034">以下是在Gunicorn服务器上运行标准Flask应用程序的完整命令，使用单个工作进程：</st>
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*<st c="17192">Figure 11</st>**<st c="17202">.1</st>* <st c="17204">shows the
    server log after successfully running the given command with the default</st>
    <st c="17288">single worker:</st>'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="17192">图11</st>**<st c="17202">.1</st>* <st c="17204">显示了使用默认</st>
    <st c="17288">单个工作进程成功运行给定命令后的服务器日志：</st>'
- en: '![Figure 11.1 – Server log after starting the Gunicorn server](img/B19383_11_001.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图11.1 – 启动Gunicorn服务器后的服务器日志](img/B19383_11_001.jpg)'
- en: <st c="17670">Figure 11.1 – Server log after starting the Gunicorn server</st>
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="17670">图11.1 – 启动Gunicorn服务器后的服务器日志</st>
- en: <st c="17729">A</st> *<st c="17732">Gunicorn</st>* <st c="17740">worker is a
    Python process that manages one HTTP request-response transaction at a time.</st>
    <st c="17830">A default Gunicorn server has one worker process running in the
    background.</st> <st c="17906">Logically, the more workers that are spawned to
    manage the requests and responses, the better the application’s performance.</st>
    <st c="18031">However, for Gunicorn, the number of</st> <st c="18068">workers
    depends on the count of CPU processors on the server machine and is derived using
    the</st> `<st c="18162">(2*CPU)+1</st>` <st c="18171">formula.</st> <st c="18181">These
    child processes will manage HTTP requests simultaneously, utilizing the maximum
    level of resources that the hardware can provide.</st> <st c="18317">One of the
    advantages of Gunicorn is its capability to leverage the resources efficiently
    to manage the</st> <st c="18421">runtime performance:</st>
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="17729">一个</st> *<st c="17732">Gunicorn</st> <st c="17740">工作进程是一个Python进程，它一次管理一个HTTP请求-响应事务。</st>
    <st c="17830">默认的Gunicorn服务器在后台运行一个工作进程。</st> <st c="17906">从逻辑上讲，产生更多的工作进程来管理请求和响应，将提高应用程序的性能。</st>
    <st c="18031">然而，对于Gunicorn来说，工作进程的数量取决于服务器机器上的CPU处理器数量，并使用</st> `<st c="18162">(2*CPU)+1</st>`
    <st c="18171">公式计算。</st> <st c="18181">这些子进程将同时管理HTTP请求，利用硬件可以提供的最大资源级别。</st>
    <st c="18317">Gunicorn的一个优点是它能够有效地利用资源来管理</st> <st c="18421">运行时性能：</st>
- en: '![Figure 11.2 – The CPU utilization dashboard of a Windows system](img/B19383_11_002.jpg)'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图11.2 – Windows系统CPU利用率仪表板](img/B19383_11_002.jpg)'
- en: <st c="18863">Figure 11.2 – The CPU utilization dashboard of a Windows system</st>
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18863">图11.2 – Windows系统CPU利用率仪表板</st>
- en: '*<st c="18926">Figure 11</st>**<st c="18936">.2</st>* <st c="18938">shows that
    our production server machine has</st> `<st c="18984">4</st>` <st c="18985">CPU
    cores, which means that the acceptable number of workers that our Gunicorn server
    can utilize is</st> `<st c="19087">9</st>`<st c="19088">. Thus, the following
    command runs a Gunicorn server with</st> `<st c="19146">9</st>` <st c="19147">workers:</st>'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="18926">图11</st>**<st c="18936">.2</st>* <st c="18938">显示我们的生产服务器机器有</st>
    `<st c="18984">4</st>` <st c="18985">个CPU核心，这意味着我们的Gunicorn服务器可以使用的可接受工作进程数量是</st>
    `<st c="19087">9</st>`<st c="19088">。因此，以下命令运行了一个具有</st> `<st c="19146">9</st>`
    <st c="19147">个工作进程的Gunicorn服务器：</st>'
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="19208">Adding the</st> `<st c="19220">--workers</st>` <st c="19229">setting
    in the command statement allows us to include the appropriate worker count in
    the HTTP</st> <st c="19325">request processing.</st>
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19208">在命令语句中添加</st> `<st c="19220">--workers</st>` <st c="19229">设置，允许我们将适当的工人数包含在HTTP</st>
    <st c="19325">请求处理中。</st>
- en: <st c="19344">Adding workers to the Gunicorn server that does not improve the
    total CPU-bound performance of the application is a waste of resources.</st> <st
    c="19481">A remedy is to add more threads to a worker rather than add</st> <st
    c="19541">unhelpful workers.</st>
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19344">向Gunicorn服务器添加工作进程，但不会提高应用程序的总CPU性能，这是一种资源浪费。</st> <st c="19481">一种补救方法是向工作进程添加更多线程，而不是添加</st>
    <st c="19541">无益的工作进程。</st>
- en: <st c="19559">Workers or processes consume more memory space.</st> <st c="19608">Additionally,
    no two workers can share memory space, unlike with threads.</st> <st c="19682">A</st>
    *<st c="19684">thread</st>* <st c="19690">consumes less memory space since it
    is more lightweight than a worker.</st> <st c="19762">To experience the best server
    performance, each worker must spawn at least</st> `<st c="19837">2</st>` <st c="19838">threads
    that will work concurrently on HTTP requests and responses.</st> <st c="19907">So,
    running the following Gunicorn command can start a server with</st> `<st c="19974">1</st>`
    <st c="19975">worker with</st> `<st c="19988">2</st>` <st c="19989">threads:</st>
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="19559">工作进程或进程消耗更多的内存空间。</st>` `<st c="19608">此外，与线程不同，没有两个工作进程可以共享内存空间。</st>`
    `<st c="19682">一个</st>` `<st c="19684">线程</st>` `<st c="19690">消耗的内存空间更少，因为它比工作进程更轻量级。</st>`
    `<st c="19762">为了获得最佳的服务器性能，每个工作进程必须至少启动</st>` `<st c="19837">2</st>` `<st c="19838">个线程，这些线程将并发处理HTTP请求和响应。</st>`
    `<st c="19907">因此，运行以下Gunicorn命令可以启动一个具有</st>` `<st c="19974">1</st>` `<st c="19975">个工作进程和</st>`
    `<st c="19988">2</st>` `<st c="19989">个线程的服务器：</st>`'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="20062">The</st> `<st c="20067">--threads</st>` <st c="20076">setting
    allows us to add at least</st> `<st c="20111">2</st>` <st c="20112">threads</st>
    <st c="20121">per worker.</st>
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="20062">The</st>` `<st c="20067">--threads</st>` `<st c="20076">设置允许我们为每个工作进程至少添加</st>`
    `<st c="20111">2</st>` `<st c="20112">个线程</st>` `<st c="20121">。</st>`'
- en: <st c="20132">Although setting threads in a worker connotes concurrency, the
    threads are still within the bounds</st> <st c="20232">of their workers, which
    run synchronously.</st> <st c="20275">So, the blocking limitation of the workers
    hinders threads from performing their actual concurrent performance.</st> <st
    c="20387">However, having threads can manage the overhead of handling I/O transactions
    compared to the pure worker setup because the concurrency that’s applied to the
    I/O blockings will not consume</st> <st c="20575">more space.</st>
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="20132">尽管在工作进程中设置线程意味着并发，但这些线程仍然在其工作进程的范围内运行，它们是同步的。</st>` `<st c="20232">因此，工作进程的阻塞限制阻碍了线程发挥其真正的并发性能。</st>`
    `<st c="20275">然而，与纯工作进程设置相比，线程可以管理处理I/O事务的开销，因为应用于I/O阻塞的并发不会消耗</st>` `<st c="20575">更多空间。</st>`'
- en: <st c="20586">The server log shown in</st> *<st c="20611">Figure 11</st>**<st
    c="20620">.3</st>* <st c="20622">depicts the change from the</st> `<st c="20651">sync</st>`
    <st c="20655">worker to</st> `<st c="20666">gthread</st>` <st c="20673">since
    all spawned Python threads become gthreads when used in the</st> <st c="20740">Gunicorn
    platform:</st>
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="20586">图11**<st c="20611">.3</st>** 中所示的服务器日志显示了从</st>` `<st c="20651">同步</st>`
    `<st c="20655">工作进程</st>` `<st c="20666">到</st>` `<st c="20673">gthread</st>`
    `<st c="20673">的变化，因为当在</st>` `<st c="20740">Gunicorn平台</st>` `<st c="20740">上使用时，所有生成的Python线程都变成了gthread：</st>`'
- en: '![Figure 11.3 – Server log after running Gunicorn with threads](img/B19383_11_003.jpg)'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图11.3 – 运行Gunicorn后服务器的日志](img/B19383_11_003.jpg)'
- en: <st c="21045">Figure 11.3 – Server log after running Gunicorn with threads</st>
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="21045">图11.3 – 运行Gunicorn后服务器的日志</st>`'
- en: <st c="21105">Now, when the number of features that require I/O transactions
    increases, Gunicorn, along with workers and servers, will not help speed up the
    processing of HTTP requests and responses.</st> <st c="21292">Another solution
    is to add</st> *<st c="21319">pseudo-threads</st>* <st c="21333">or</st> *<st
    c="21337">green-threads</st>*<st c="21350">, through the</st> `<st c="21364">eventlet</st>`
    <st c="21372">and</st> `<st c="21377">gevent</st>` <st c="21383">libraries, to
    the Gunicorn server as worker classes.</st> <st c="21437">Both libraries use asynchronous
    utilities and</st> `<st c="21483">greenlet</st>` <st c="21491">threads to interface
    and execute the standard Flask components, especially I/O transactions, for more
    efficiency.</st> <st c="21606">They use the</st> *<st c="21619">monkey-patching</st>*
    <st c="21634">mechanism to</st> <st c="21648">replace the standard or blocking
    components with their</st> <st c="21703">asynchronous counterparts.</st>
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="21105">现在，当需要I/O事务的特征数量增加时，Gunicorn以及工作进程和服务器都不会帮助加快HTTP请求和响应的处理速度。</st>`
    `<st c="21292">另一个解决方案是通过</st>` `<st c="21319">伪线程</st>` `<st c="21333">或</st>`
    `<st c="21337">绿色线程</st>` `<st c="21350">，通过</st>` `<st c="21364">eventlet</st>`
    `<st c="21372">和</st>` `<st c="21377">gevent</st>` `<st c="21383">库，将伪线程或绿色线程作为工作进程类添加到Gunicorn服务器中。</st>`
    `<st c="21437">这两个库都使用异步工具和</st>` `<st c="21483">greenlet</st>` `<st c="21491">线程来接口和执行标准的Flask组件，特别是I/O事务，以提高效率。</st>`
    `<st c="21606">它们使用</st>` `<st c="21619">monkey-patching</st>` `<st c="21634">机制来</st>`
    `<st c="21648">替换标准或阻塞组件，以它们的异步对应物。</st>`'
- en: <st c="21729">To deploy our application to Gunicorn with the</st> `<st c="21777">eventlet</st>`
    <st c="21785">library, install the</st> `<st c="21807">greenlet</st>` <st c="21815">module
    first using the following</st> `<st c="21849">pip</st>` <st c="21852">command,
    followed</st> <st c="21871">by</st> `<st c="21874">eventlet</st>`<st c="21882">:</st>
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21729">要将我们的应用程序部署到使用</st> `<st c="21777">eventlet</st>` <st c="21785">库的
    Gunicorn，首先使用以下</st> `<st c="21849">pip</st>` <st c="21852">命令安装</st> `<st c="21807">greenlet</st>`
    <st c="21815">模块，然后是</st> `<st c="21874">eventlet</st>`<st c="21882">：</st>
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="21914">For</st> `<st c="21919">psycopg2</st>` <st c="21927">or database-related
    monkey-patching, install the</st> `<st c="21977">psycogreen</st>` <st c="21987">module
    with the following</st> `<st c="22014">pip</st>` <st c="22017">command:</st>
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21914">对于</st> `<st c="21919">psycopg2</st>` <st c="21927">或数据库相关的 monkey-patching，使用以下</st>
    `<st c="22014">pip</st>` <st c="22017">命令安装</st> `<st c="21977">psycogreen</st>`
    <st c="21987">模块：</st>
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="22049">Then, apply</st> <st c="22062">monkey-patching for Peewee and</st>
    `<st c="22093">psycopg2</st>` <st c="22101">transactions by calling the</st> `<st
    c="22130">patch_psycopg()</st>` <st c="22145">function of the</st> `<st c="22162">psycogreen.eventlet</st>`
    <st c="22181">module in the uppermost portion of the</st> `<st c="22221">main.py</st>`
    <st c="22228">file before calling the</st> `<st c="22253">create_app()</st>` <st
    c="22265">method.</st> <st c="22274">The following snippet shows the portion of
    the</st> `<st c="22321">main.py</st>` <st c="22328">file with the</st> `<st c="22343">psycogreen</st>`
    <st c="22353">setup:</st>
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22049">然后，通过在</st> `<st c="22221">main.py</st>` <st c="22228">文件的最上方调用</st>
    `<st c="22162">psycogreen.eventlet</st>` <st c="22181">模块的</st> `<st c="22130">patch_psycopg()</st>`
    <st c="22145">函数，对 Peewee 和</st> `<st c="22093">psycopg2</st>` <st c="22101">事务进行
    monkey-patching，并在调用</st> `<st c="22253">create_app()</st>` <st c="22265">方法之前执行。</st>
    <st c="22274">以下代码片段显示了包含</st> `<st c="22343">psycogreen</st>` <st c="22353">设置的</st>
    `<st c="22321">main.py</st>` <st c="22328">文件的部分：</st>
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="22540">The</st> `<st c="22545">psycogreen</st>` <st c="22555">module
    provides a blocking interface or wrapper for</st> `<st c="22608">psycopg2</st>`
    <st c="22617">transactions to interact with coroutines or asynchronous components
    of the</st> `<st c="22692">eventlet</st>` <st c="22700">worker without altering
    the standard</st> <st c="22738">Peewee codes.</st>
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22540">The</st> `<st c="22545">psycogreen</st>` <st c="22555">module
    provides a blocking interface or wrapper for</st> `<st c="22608">psycopg2</st>`
    <st c="22617">transactions to interact with coroutines or asynchronous components
    of the</st> `<st c="22692">eventlet</st>` <st c="22700">worker without altering
    the standard</st> <st c="22738">Peewee codes.</st>
- en: <st c="22751">To deploy our</st> *<st c="22766">Online Grocery</st>* <st c="22780">application
    (</st>`<st c="22794">ch11-guni-eventlet</st>`<st c="22813">) to the Gunicorn server
    that uses</st> `<st c="22849">1</st>` `<st c="22850">eventlet</st>` <st c="22858">worker
    with</st> `<st c="22871">2</st>` <st c="22872">threads, run the</st> <st c="22890">following
    command:</st>
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22751">要将我们的</st> *<st c="22766">在线杂货</st>* <st c="22780">应用程序（</st>`<st
    c="22794">ch11-guni-eventlet</st>`<st c="22813">）部署到使用</st> `<st c="22849">1</st>`
    `<st c="22850">eventlet</st>` <st c="22858">工作进程和</st> `<st c="22871">2</st>`
    <st c="22872">线程的 Gunicorn 服务器上，请运行以下命令：</st>
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*<st c="22996">Figure 11</st>**<st c="23006">.4</st>* <st c="23008">shows the
    server log after running the</st> <st c="23048">Gunicorn server:</st>'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="22996">图 11</st>**<st c="23006">.4</st>* <st c="23008">显示了运行 Gunicorn
    服务器后的服务器日志：</st>'
- en: '![Figure 11.4 – Server log after starting the Gunicorn server using the eventlet
    worker](img/B19383_11_004.jpg)'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.4 – 使用 eventlet 工作进程启动 Gunicorn 服务器后的服务器日志](img/B19383_11_004.jpg)'
- en: <st c="23522">Figure 11.4 – Server log after starting the Gunicorn server using
    the eventlet worker</st>
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23522">图 11.4 – 使用 eventlet 工作进程启动 Gunicorn 服务器后的服务器日志</st>
- en: <st c="23607">The log depicts</st> <st c="23624">that the worker that was used
    by the server is an</st> `<st c="23674">eventlet</st>` <st c="23682">worker type.</st>
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23607">日志描述了</st> <st c="23624">服务器使用的工作进程是一个</st> `<st c="23674">eventlet</st>`
    <st c="23682">工作进程类型。</st>
- en: <st c="23695">The</st> `<st c="23700">eventlet</st>` <st c="23708">library provides</st>
    <st c="23726">concurrent utilities that run standard or non-async Flask components
    asynchronously using task switching, a shift from sync to async tasks internally
    without explicitly</st> <st c="23895">programming it.</st>
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23695">The</st> `<st c="23700">eventlet</st>` <st c="23708">library provides</st>
    <st c="23726">concurrent utilities that run standard or non-async Flask components
    asynchronously using task switching, a shift from sync to async tasks internally
    without explicitly</st> <st c="23895">programming it.</st>
- en: <st c="23910">Aside from</st> `<st c="23922">eventlet</st>`<st c="23930">,</st>
    `<st c="23932">gevent</st>` <st c="23938">can also manage concurrent requests
    from I/O-bound tasks of the applications.</st> <st c="24017">Like</st> `<st c="24022">eventlet</st>`<st
    c="24030">,</st> `<st c="24032">gevent</st>` <st c="24038">is a coroutine-based
    library but relies more on its stack of</st> `<st c="24100">greenlet</st>` <st
    c="24108">objects and their event loops.</st> <st c="24140">The</st> `<st c="24144">gevent</st>`
    <st c="24150">library’s</st> `<st c="24161">greenlet</st>` <st c="24169">is a
    lightweight and powerful thread that executes in a cooperative scheduling fashion.</st>
    <st c="24258">To operate a</st> `<st c="24271">gevent</st>` <st c="24277">worker
    in the Gunicorn server, install the</st> `<st c="24321">greenlet</st>`<st c="24329">,</st>
    `<st c="24331">eventlet</st>`<st c="24339">, and</st> `<st c="24345">gevent</st>`
    <st c="24351">modules using the following</st> `<st c="24380">pip</st>` <st c="24383">command:</st>
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="24429">Also, install</st> `<st c="24444">psycogreen</st>` <st c="24454">to
    monkey-patch the database-related transactions of the application using its</st>
    `<st c="24534">gevent</st>` `<st c="24540">patch_psycopg()</st>`<st c="24556">.
    The following snippet shows a portion of the</st> `<st c="24603">main.py</st>`
    <st c="24610">file of the</st> `<st c="24623">ch11-guni-gevent</st>` <st c="24639">project,
    a version of our</st> *<st c="24666">Online Grocery</st>* <st c="24680">application
    that needs to run on Gunicorn with</st> `<st c="24728">gevent</st>` <st c="24734">workers:</st>
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="24953">In</st> `<st c="24957">gevent</st>`<st c="24963">, the main module
    must call its</st> `<st c="24995">patch_all()</st>` <st c="25006">method from
    the</st> `<st c="25023">gevent.monkey</st>` <st c="25036">module, above anything
    else, to explicitly interface all the events at runtime to run asynchronously
    like coroutines.</st> <st c="25155">Afterward, it needs to call the</st> `<st
    c="25187">psycogreen</st>` <st c="25197">module’s</st> `<st c="25207">patch_psycopg()</st>`<st
    c="25222">, but this time under the</st> `<st c="25248">gevent</st>` <st c="25254">sub-module.</st>
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="25266">To start the</st> <st c="25280">Gunicorn server using the</st>
    `<st c="25306">2</st>` `<st c="25307">gevent</st>` <st c="25313">workers with</st>
    `<st c="25327">2</st>` <st c="25328">thread utilization each, run the</st> <st
    c="25362">following command:</st>
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*<st c="25466">Figure 11</st>**<st c="25476">.5</st>* <st c="25478">shows the
    server log after starting up the</st> <st c="25522">Gunicorn server:</st>'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Server log after starting the Gunicorn server using the gevent
    workers](img/B19383_11_005.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="26061">Figure 11.5 – Server log after starting the Gunicorn server using
    the gevent workers</st>
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26145">The worker used by the Gunicorn is now a</st> `<st c="26187">gevent</st>`
    <st c="26193">worker, as depicted in the preceding</st> <st c="26231">server log.</st>
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26145">Gunicorn 使用的进程现在是一个</st> `<st c="26187">gevent</st>` <st c="26193">进程，如前述服务器日志所示。</st>
- en: <st c="26242">Now, let’s use uWSGI as our production</st> <st c="26282">application
    server.</st>
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26242">现在，让我们使用 uWSGI 作为我们的生产</st> <st c="26282">应用服务器。</st>
- en: <st c="26301">Using uWSGI</st>
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26301">使用 uWSGI</st>
- en: '`<st c="26534">pyuwsgi</st>` <st c="26541">module using the following</st>
    `<st c="26569">pip</st>` <st c="26572">command:</st>'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="26534">pyuwsgi</st>` <st c="26541">模块使用以下</st> `<st c="26569">pip</st>`
    <st c="26572">命令：</st>'
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="26601">uWSGI has several required and optional setting options.</st>
    <st c="26659">One is the</st> `<st c="26670">-w</st>` <st c="26672">setting, which
    requires the WSGI module that the server needs to run.</st> <st c="26743">The</st>
    `<st c="26747">-p</st>` <st c="26749">setting indicates the number of workers
    or processes that can manage HTTP requests.</st> <st c="26834">The</st> `<st c="26838">--http</st>`
    <st c="26844">setting denotes the address and the port the server will be listening
    to.</st> <st c="26919">The</st> `<st c="26923">--enable-threads</st>` <st c="26939">setting
    allows the server to utilize Python threads for</st> <st c="26996">background
    processes.</st>
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26601">uWSGI 有几个必需和可选的设置选项。</st> <st c="26659">其中一个是</st> `<st c="26670">-w</st>`
    <st c="26672">设置，它需要服务器运行所需的 WSGI 模块。</st> <st c="26743">`<st c="26747">-p</st>`
    <st c="26749">设置表示可以管理 HTTP 请求的工作进程或进程数。</st> <st c="26834">`<st c="26838">--http</st>`
    <st c="26844">设置表示服务器将监听的地址和端口。</st> <st c="26919">`<st c="26923">--enable-threads</st>`
    <st c="26939">设置允许服务器利用 Python 线程进行</st> <st c="26996">后台进程。</st>
- en: <st c="27017">To deploy our</st> *<st c="27032">Online Grocery</st>* <st c="27046">application
    (</st>`<st c="27060">ch11-uwsgi</st>`<st c="27071">) to a uWSGI server with</st>
    `<st c="27097">4</st>` <st c="27098">workers and background Python threads, run
    the</st> <st c="27146">following command:</st>
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27017">要将我们的</st> *<st c="27032">在线杂货</st>* <st c="27046">应用程序（</st>`<st
    c="27060">ch11-uwsgi</st>`<st c="27071">）部署到具有</st> `<st c="27097">4</st>` <st
    c="27098">个工作进程和后台 Python 线程的 uWSGI 服务器上，请运行以下命令：</st>
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="27235">Here,</st> `<st c="27242">--master</st>` <st c="27250">is an optional
    setting that allows the master process and its workers to shut down and</st> <st
    c="27338">restart gracefully.</st>
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27235">在这里，</st> `<st c="27242">--master</st>` <st c="27250">是一个可选设置，允许主进程及其工作进程优雅地关闭和</st>
    <st c="27338">重启。</st>
- en: <st c="27357">Unlike Gunicorn, uWSGI generates a long server log mentioning
    the several manageable configuration</st> <st c="27457">details it consists of
    to improve the application’s performance.</st> *<st c="27522">Figure 11</st>**<st
    c="27531">.6</st>* <st c="27533">shows the server log of uWSGI after</st> <st
    c="27570">its startup:</st>
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 Gunicorn 不同，uWSGI 生成一个长的服务器日志，提到了它包含的几个可管理的配置细节，以提高应用程序的性能。</st> <st c="27457">*<st
    c="27522">图 11</st>**<st c="27531">.6</st>* <st c="27533">显示了 uWSGI 启动后的服务器日志：</st>
- en: '![Figure 11.6 – Server log after starting the uWSGI server with 4 workers](img/B19383_11_006.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.6 – 使用 4 个工作进程启动 uWSGI 服务器后的服务器日志](img/B19383_11_006.jpg)'
- en: <st c="29113">Figure 11.6 – Server log after starting the uWSGI server with
    4 workers</st>
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29113">图 11.6 – 启动 uWSGI 服务器并使用 4 个工作进程后的服务器日志</st>
- en: <st c="29184">Shutting down the uWSGI server with the</st> `<st c="29225">--master</st>`
    <st c="29233">setting allows us to send the master process and its workers the</st>
    `<st c="29299">SIGTERM</st>` <st c="29306">signal to impose graceful shutdown,
    restart, or reload, which is better than the abrupt kill process.</st> *<st c="29409">Figure
    11</st>**<st c="29418">.7</st>* <st c="29420">shows the advantage of having the</st>
    `<st c="29455">--master</st>` <st c="29463">setting in</st> <st c="29475">the
    command:</st>
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29184">使用</st> `<st c="29225">--master</st>` <st c="29233">设置关闭 uWSGI
    服务器，允许我们向主进程及其工作进程发送</st> `<st c="29299">SIGTERM</st>` <st c="29306">信号，以执行优雅的关闭、重启或重新加载，这比突然终止进程要好。</st>
    *<st c="29409">图 11</st>**<st c="29418">.7</st>* <st c="29420">显示了在命令中设置</st>
    `<st c="29455">--master</st>` <st c="29463">设置的优势：</st>
- en: '![Figure 11.7 – Server log after shutting down the uWSGI server with the --master
    setting](img/B19383_11_007.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.7 – 使用 --master 设置关闭 uWSGI 服务器后的服务器日志](img/B19383_11_007.jpg)'
- en: <st c="29792">Figure 11.7 – Server log after shutting down the uWSGI server
    with the --master setting</st>
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29792">图 11.7 – 使用 --master 设置关闭 uWSGI 服务器后的服务器日志</st>
- en: <st c="29879">Managing uWSGI is</st> <st c="29898">complex compared to the easy-to-configure
    Gunicorn.</st> <st c="29950">So far, Gunicorn is still the recommended server
    to use when deploying standard</st> <st c="30030">Flask applications.</st>
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30049">Now, let’s deploy</st> *<st c="30068">Flask[async]</st>* <st c="30080">to
    an ASGI server</st> <st c="30099">called</st> *<st c="30106">Uvicorn</st>*<st
    c="30113">.</st>
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30114">Deploying the application to Uvicorn</st>
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="30419">uvicorn.workers.UvicornWorker</st>` <st c="30448">as its</st>
    <st c="30456">HTTP server.</st>'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30468">Even though Gunicorn is a WSGI-based server, it can support running
    Flask applications in standard and async mode through its</st> `<st c="30595">--worker-class</st>`
    <st c="30609">setting.</st> <st c="30619">For Flask[async] applications, Gunicorn
    can utilize the</st> `<st c="30675">aiohttp</st>` <st c="30682">or</st> `<st c="30686">uvicorn</st>`
    <st c="30693">worker</st> <st c="30701">class types.</st>
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30713">Our async</st> *<st c="30724">Online Grocery</st>* <st c="30738">application
    (</st>`<st c="30752">ch11-async</st>`<st c="30763">) uses Gunicorn with a</st>
    `<st c="30787">uvicorn</st>` <st c="30794">worker as its deployment platform.</st>
    <st c="30830">Before applying the worker type, install the</st> `<st c="30875">uvicorn</st>`
    <st c="30882">module first by running the following</st> `<st c="30921">pip</st>`
    <st c="30924">command:</st>
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="30953">Then, import</st> `<st c="30967">WsgiToAsgi</st>` <st c="30977">from
    the</st> `<st c="30987">uvicorn</st>` <st c="30994">module’s</st> `<st c="31004">asgiref.wsgi</st>`
    <st c="31016">module to wrap the Flask app instance.</st> <st c="31056">The following
    snippet shows how to transform a WSGI application into an</st> <st c="31128">ASGI
    type:</st>
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: gunicorn main:asgi_app --bind 0.0.0.0:8000 --workers 2 --worker-class uvicorn.workers.UvicornWorker
    --threads 2
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: pip install mod_wsgi
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: set "MOD_WSGI_APACHE_ROOTDIR= C:/.../Server/Apache24"
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: import sys
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sys.path.insert(0, 'C:/Alibata/Training/ Source/flask/mastering/ch11-apache')
    <st c="39142">conf.wsgi</st> configuration file provides the Apache HTTP Server
    a channel to access the Flask <st c="39233">app</st> instance for deployment and
    execution through the <st c="39287">mod_wsgi</st> module.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: LoadFile "C:/Alibata/Development/Language/ Python/Python311/python311.dll"
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: LoadModule wsgi_module "C:/Alibata/Training/Source/ flask/mastering/ch11-apache-env/Lib/site-packages/mod_wsgi/server/mod_wsgi.cp311-win_amd64.pyd"
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WSGIPythonHome "C:/Alibata/Training/Source/ flask/mastering/ch11-apache-env"
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Include conf/<st c="40310">VirtualHost</st> configuration file referenced in
    *<st c="40355">Step 10</st>*. The following is a sample configuration setup in
    our <st c="40417">ch11_apache.conf</st> file:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="40689">The</st> `<st c="40694">VirtualHost</st>` <st c="40705">configuration
    defines the host address and port that the server</st> <st c="40770">will listen</st>
    <st c="40782">to so that it can run our application.</st> <st c="40821">Its</st>
    `<st c="40825">WSGIScriptAlias</st>` <st c="40840">directive gives reference to
    the</st> `<st c="40874">mod_wsgi</st>` <st c="40882">configuration file of the
    application.</st> <st c="40922">Moreover, the configuration permits the server
    to access all files in the</st> `<st c="40996">ch11-apache</st>` <st c="41007">project.</st>
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40689">The</st> `<st c="40694">VirtualHost</st>` <st c="40705">配置定义了服务器将监听的主机地址和端口，以便运行我们的应用程序。</st>
    <st c="40770">它的</st> `<st c="40825">WSGIScriptAlias</st>` <st c="40840">指令给出了应用程序的</st>
    `<st c="40874">mod_wsgi</st>` <st c="40882">配置文件的引用。</st> <st c="40922">此外，配置允许服务器访问</st>
    `<st c="40996">ch11-apache</st>` <st c="41007">项目中的所有文件。</st>
- en: '[PRE36]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="43647">FROM python:3.11</st> WORKDIR /usr/src/ch11-asgi
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43647">FROM python:3.11</st> WORKDIR /usr/src/ch11-asgi
- en: RUN pip install --upgrade pip
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `pip install --upgrade pip`
- en: COPY ./requirements.txt /usr/src/ch11-asgi/requirements.txt
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: COPY ./requirements.txt /usr/src/ch11-asgi/requirements.txt
- en: RUN pip install -r requirements.txt
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: RUN pip install -r requirements.txt
- en: COPY . /usr/src/ch11-asgi
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: COPY . /usr/src/ch11-asgi
- en: EXPOSE 8000
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: EXPOSE 8000
- en: CMD ["gunicorn", "main:asgi_app", "--bind", "0.0.0.0:8000", "--worker-class",
    "uvicorn.workers.UvicornWorker", "--threads", "2"]
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: CMD ["gunicorn", "main:asgi_app", "--bind", "0.0.0.0:8000", "--worker-class",
    "uvicorn.workers.UvicornWorker", "--threads", "2"]
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<st c="47286">version: ''3.0''</st>'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="47286">version: ''3.0''</st>'
- en: '<st c="47301">services</st>: <st c="47313">api</st>: <st c="47319">build: ./ch11-asgi</st>
    volumes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="47301">services</st>: <st c="47313">api</st>: <st c="47319">build: ./ch11-asgi</st>
    volumes:'
- en: '- ./ch11-asgi/:/usr/src/ch11-asgi/'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- ./ch11-asgi/:/usr/src/ch11-asgi/'
- en: 'ports:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'ports:'
- en: '- 8000:8000 <st c="47401">depends_on</st>:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 8000:8000 <st c="47401">depends_on</st>:'
- en: '- postgres <st c="47425">postgres</st>: <st c="47436">image: «bitnami/postgresql:latest»</st>
    ports:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- postgres <st c="47425">postgres</st>: <st c="47436">image: «bitnami/postgresql:latest»</st>
    ports:'
- en: '- 5432:5432'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 5432:5432'
- en: 'env_file:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'env_file:'
- en: '- db.env # configure postgres <st c="47530">volumes</st>:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- db.env # 配置 postgres <st c="47530">volumes</st>:'
- en: '- <st c="47542">database-data:/var/lib/postgresql/data/</st>'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- <st c="47542">database-data:/var/lib/postgresql/data/</st>'
- en: '<st c="47581">volumes</st>: <st c="47611">version</st> directive indicates
    the Compose syntax version the configuration will use in the Compose instructions.
    Our Compose configuration file uses version <st c="47766">3.0</st>, which is the
    latest at the time of writing this book. Lower versions mean deprecated keywords
    and commands.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="47581">volumes</st>: <st c="47611">version</st> 指令表示配置将在 Compose 指令中使用
    Compose 语法版本。我们的 Compose 配置文件使用版本 <st c="47766">3.0</st>，这是撰写本书时的最新版本。较低版本意味着已弃用的关键字和命令。'
- en: <st c="47878">Now, the</st> `<st c="47888">services</st>` <st c="47896">directive
    defines all the containers that Compose will create and run.</st> <st c="47968">Ours
    include the</st> *<st c="47985">Online Grocery</st>* <st c="47999">application
    (</st>`<st c="48013">api</st>`<st c="48017">) and the PostgreSQL database platform
    (</st>`<st c="48058">postgres</st>`<st c="48067">).</st> <st c="48071">Here,</st>
    `<st c="48077">api</st>` <st c="48080">is the name of the service for our application.</st>
    <st c="48129">It contains the following</st> <st c="48155">required sub-directives:</st>
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47878">现在，</st> `<st c="47888">services</st>` <st c="47896">指令定义了 Compose
    将创建和运行的容器。</st> <st c="47968">我们的包括</st> *<st c="47985">在线杂货</st>* <st c="47999">应用程序（</st>`<st
    c="48013">api</st>`<st c="48017">）和 PostgreSQL 数据库平台（</st>`<st c="48058">postgres</st>`<st
    c="48067">）。</st> <st c="48071">在这里，</st> `<st c="48077">api</st>` <st c="48080">是我们应用程序服务的名称。</st>
    <st c="48129">它包含以下</st> <st c="48155">必需的子指令：</st>
- en: '`<st c="48179">build</st>`<st c="48185">: Points to the location of the local
    project folder containing</st> <st c="48250">the Dockerfile.</st>'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="48179">build</st>`<st c="48185">: 指向包含 Dockerfile 的本地项目文件夹的位置。</st>'
- en: '`<st c="48265">ports</st>`<st c="48271">: Maps the container’s ports to the
    host’s ports, either TCP</st> <st c="48333">or UDP.</st>'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="48265">ports</st>`<st c="48271">: 将容器的端口映射到主机的端口，可以是 TCP</st> <st c="48333">或
    UDP。</st>'
- en: '`<st c="48340">volumes</st>`<st c="48348">: Attaches the local project files
    to the specified directory of the container, which spares the image from rebuilding
    if there are changes in the</st> <st c="48496">project files.</st>'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="48340">volumes</st>`<st c="48348">: 将本地项目文件附加到容器指定的目录，如果项目文件有更改，则可以节省镜像重建。</st>
    <st c="48496">项目文件。</st>'
- en: '`<st c="48510">depends_on</st>`<st c="48521">: Mentions the service name considered
    as one of the</st> <st c="48575">container’s dependencies.</st>'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="48510">depends_on</st>`<st c="48521">: 指出被视为容器依赖项之一的服务名称。</st>'
- en: <st c="48600">Another service is</st> `<st c="48620">postgres</st>`<st c="48628">,
    which provides the database platform for the</st> `<st c="48675">api</st>` <st
    c="48679">service, thus the</st> <st c="48697">dependency between the two services.</st>
    <st c="48734">Instead of using the</st> `<st c="48755">build</st>` <st c="48760">directive,
    its</st> `<st c="48776">image</st>` <st c="48781">directive will pull the latest</st>
    `<st c="48813">bitnami/postgresql</st>` <st c="48831">image to create a container
    for the PostgreSQL platform with an empty database schema.</st> <st c="48919">Its</st>
    `<st c="48923">ports</st>` <st c="48928">directive indicates that the container
    will use port</st> `<st c="48982">5432</st>` <st c="48986">to listen for database
    connectivity.</st> <st c="49024">The database credentials are in the</st> `<st
    c="49060">db.env</st>` <st c="49066">file indicated by the</st> `<st c="49089">env_file</st>`
    <st c="49097">directive.</st> <st c="49109">The following snippet shows the content
    of the</st> `<st c="49156">db.env</st>` <st c="49162">file:</st>
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48600">另一项服务是</st> `<st c="48620">postgres</st>`<st c="48628">，它为</st>
    `<st c="48675">api</st>` <st c="48679">服务提供数据库平台，因此存在</st> <st c="48697">两个服务之间的依赖关系。</st>
    <st c="48734">而不是使用</st> `<st c="48755">build</st>` <st c="48760">指令，它的</st> `<st
    c="48776">image</st>` <st c="48781">指令将拉取最新的</st> `<st c="48813">bitnami/postgresql</st>`
    <st c="48831">镜像来创建一个具有空数据库模式的 PostgreSQL 平台的容器。</st> <st c="48919">它的</st> `<st
    c="48923">ports</st>` <st c="48928">指令表明容器将使用端口</st> `<st c="48982">5432</st>`
    <st c="48986">来监听数据库连接。</st> <st c="49024">数据库凭据位于由</st> `<st c="49060">db.env</st>`
    <st c="49066">文件指示的</st> `<st c="49089">env_file</st>` <st c="49097">指令。</st>
    <st c="49109">以下代码片段显示了</st> `<st c="49156">db.env</st>` <st c="49162">文件的内容：</st>
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: <st c="49235">The</st> `<st c="49240">volumes</st>` <st c="49247">directive
    for the</st> `<st c="49266">postgres</st>` <st c="49274">service is essential
    for data persistence because its absence in the configuration means data cleanup
    after the</st> <st c="49387">container restarts.</st>
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49235">对于</st> `<st c="49240">volumes</st>` <st c="49247">指令的</st> `<st
    c="49266">postgres</st>` <st c="49274">服务至关重要，因为配置中缺少它意味着容器重启后的数据清理。</st>
- en: <st c="49406">After finalizing the</st> `<st c="49428">docker-compose.yaml</st>`
    <st c="49447">file, run the</st> `<st c="49462">docker-compose --build</st>` <st
    c="49484">command to build or rebuild the services, then once again after the</st>
    `<st c="49553">docker-compose up</st>` <st c="49570">command to create and run
    the containers.</st> *<st c="49613">Figure 11</st>**<st c="49622">.12</st>* <st
    c="49625">shows the command logs after running the</st> `<st c="49667">docker-compose
    up --</st>``<st c="49687">build</st>` <st c="49693">commands:</st>
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49406">在最终确定</st> `<st c="49428">docker-compose.yaml</st>` <st c="49447">文件后，运行</st>
    `<st c="49462">docker-compose --build</st>` <st c="49484">命令来构建或重建服务，然后在</st>
    `<st c="49553">docker-compose up</st>` <st c="49570">命令之后再次运行，以创建和运行容器。</st> *<st
    c="49613">图 11</st>**<st c="49622">.12</st>* <st c="49625">显示了运行</st> `<st c="49667">docker-compose
    up --</st>``<st c="49687">build</st>` <st c="49693">命令后的命令日志：</st>
- en: '![Figure 11.12 – Logs when running the docker-compose up --build command](img/B19383_11_012.jpg)'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.12 – 运行 docker-compose up --build 命令时的日志](img/B19383_11_012.jpg)'
- en: <st c="50912">Figure 11.12 – Logs when running the docker-compose up --build
    command</st>
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="50912">图 11.12 – 运行 docker-compose up --build 命令时的日志</st>
- en: <st c="50982">The Docker</st> <st c="50994">Desktop dashboard, on the other
    hand, will display the following container structure in</st> *<st c="51082">Figure
    11</st>**<st c="51091">.13</st>* <st c="51094">after successfully running the</st>
    <st c="51126">generated containers:</st>
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="50982">另一方面，Docker</st> <st c="50994">桌面仪表板将在成功运行生成的容器后，在</st> *<st c="51082">图
    11</st>**<st c="51091">.13</st>* <st c="51094">中显示以下容器结构：</st>
- en: '![Figure 11.13 – Docker Desktop showing ch11-asgi and the PostgreSQL containers](img/B19383_11_013.jpg)'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.13 – Docker Desktop 显示 ch11-asgi 和 PostgreSQL 容器](img/B19383_11_013.jpg)'
- en: <st c="51293">Figure 11.13 – Docker Desktop showing ch11-asgi and the PostgreSQL
    containers</st>
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="51293">图 11.13 – Docker Desktop 显示 ch11-asgi 和 PostgreSQL 容器</st>
- en: <st c="51370">Here,</st> `<st c="51377">ch11-asgi-deployment</st>` <st c="51397">in
    the given container structure is the name of the deployment folder containing
    the</st> `<st c="51483">db.env</st>` <st c="51489">and</st> `<st c="51494">docker-compose.yaml</st>`
    <st c="51513">files, and the directory where the terminal invocation of the</st>
    `<st c="51576">docker-compose</st>` <st c="51590">commands happened.</st> <st
    c="51610">Inside the Compose container structure are the two containers that were
    generated by the services.</st> <st c="51709">Clicking the</st> `<st c="51722">api-1</st>`
    <st c="51727">container will provide us with the Gunicorn server logs presented
    in</st> *<st c="51797">Figure 11</st>**<st c="51806">.14</st>*<st c="51809">:</st>
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="51370">在这里，</st> `<st c="51377">ch11-asgi-deployment</st>` <st c="51397">在给定的容器结构中是包含</st>
    `<st c="51483">db.env</st>` <st c="51489">和</st> `<st c="51494">docker-compose.yaml</st>`
    <st c="51513">文件的部署文件夹的名称，以及执行</st> `<st c="51576">docker-compose</st>` <st c="51590">命令的终端目录。</st>
    <st c="51610">在 Compose 容器结构内部是服务生成的两个容器。</st> <st c="51709">点击</st> `<st c="51722">api-1</st>`
    <st c="51727">容器将为我们提供如</st> *<st c="51797">图 11.14</st>**<st c="51806">.14</st>*<st
    c="51809">所示的 Gunicorn 服务器日志：</st>
- en: '![Figure 11.14 – The Gunicorn server log from ch11-asgi app in the api-1 container](img/B19383_11_014.jpg)'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.14 – api-1 容器中 ch11-asgi 应用程序的 Gunicorn 服务器日志](img/B19383_11_014.jpg)'
- en: <st c="52764">Figure 11.14 – The Gunicorn server log from ch11-asgi app in the
    api-1 container</st>
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52764">图 11.14 – api-1 容器中 ch11-asgi 应用程序的 Gunicorn 服务器日志</st>
- en: <st c="52844">On the</st> <st c="52852">other hand, clicking the</st> `<st c="52877">postgres-1</st>`
    <st c="52887">container will show the logs shown in</st> *<st c="52926">Figure
    11</st>**<st c="52935">.15</st>*<st c="52938">:</st>
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52844">另一方面，点击</st> `<st c="52877">postgres-1</st>` <st c="52887">容器将显示如</st>
    *<st c="52926">图 11</st>**<st c="52935">.15</st>*<st c="52938">所示的日志：</st>
- en: '![Figure 11.15 – The PostgreSQL server log in the postgres-1 container](img/B19383_11_015.jpg)'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.15 – postgres-1 容器中的 PostgreSQL 服务器日志](img/B19383_11_015.jpg)'
- en: <st c="54308">Figure 11.15 – The PostgreSQL server log in the postgres-1 container</st>
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="54308">图 11.15 – postgres-1 容器中的 PostgreSQL 服务器日志</st>
- en: <st c="54376">Now, the database schema in the</st> `<st c="54409">postgres-1</st>`
    <st c="54419">container is empty.</st> <st c="54440">To populate the database
    with the tables and data from the local PostgreSQL server, run</st> `<st c="54528">pg_dump</st>`
    <st c="54535">to create a</st> `<st c="54548">.sql</st>` <st c="54552">dump file.</st>
    <st c="54564">Then, in the directory location of the</st> `<st c="54603">.sql</st>`
    <st c="54607">backup file, run the following</st> `<st c="54639">docker copy</st>`
    <st c="54650">command to copy the backup file, say</st> `<st c="54688">ogs.sql</st>`<st
    c="54695">, to the</st> `<st c="54704">entrypoint</st>` <st c="54714">directory
    of</st> <st c="54728">the container:</st>
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="54376">现在，postgres-1 容器中的数据库模式是空的。</st> <st c="54409">为了将本地 PostgreSQL
    服务器中的表和数据填充到数据库中，运行</st> `<st c="54528">pg_dump</st>` <st c="54535">来创建一个</st>
    `<st c="54548">.sql</st>` <st c="54552">转储文件。</st> <st c="54564">然后，在</st> `<st
    c="54603">.sql</st>` <st c="54607">备份文件所在的目录位置，运行以下</st> `<st c="54639">docker
    copy</st>` <st c="54650">命令来复制备份文件，例如</st> `<st c="54688">ogs.sql</st>`<st c="54695">，到容器的</st>
    `<st c="54704">entrypoint</st>` <st c="54714">目录：</st>
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <st c="54828">Then, access the container’s server using valid credentials, such
    as</st> `<st c="54898">postgres</st>` <st c="54906">and its password, to spool
    or execute the</st> `<st c="54949">.sql</st>` <st c="54953">file using the</st>
    `<st c="54969">docker</st>` `<st c="54976">exec</st>` <st c="54980">command:</st>
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="54828">然后，使用有效的凭据，例如</st> `<st c="54898">postgres</st>` <st c="54906">及其密码，通过</st>
    `<st c="54969">docker</st>` `<st c="54976">exec</st>` <st c="54980">命令来转储或执行</st>
    `<st c="54949">.sql</st>` <st c="54953">文件：</st>
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="55099">Finally, log in to the</st> `<st c="55123">ch11-asgi-deployment-postgres-1</st>`
    <st c="55154">server using the</st> `<st c="55172">docker exec</st>` <st c="55183">command
    with the database</st> <st c="55210">admin credentials:</st>
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="55099">最后，使用数据库</st> `<st c="55123">ch11-asgi-deployment-postgres-1</st>`
    <st c="55154">的凭据通过</st> `<st c="55172">docker exec</st>` <st c="55183">命令登录到服务器：</st>
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <st c="55293">Also, don’t forget</st> <st c="55313">to replace the</st> `<st
    c="55328">host</st>` <st c="55332">parameter of the</st> `<st c="55350">PooledPostgresqlDatabase</st>`
    <st c="55374">driver class with the container’s name instead of</st> `<st c="55425">localhost</st>`
    <st c="55434">and its</st> `<st c="55443">port</st>` <st c="55447">to</st> `<st
    c="55451">5432</st>`<st c="55455">. The following snippet shows the changes in
    the driver class configuration that can be found in the</st> `<st c="55556">app/models/config</st>`
    <st c="55573">module:</st>
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <st c="55810">Now, problems arise when one or some of the containers fail during
    production.</st> <st c="55890">By default, it does support automatic container
    restart when there are runtime errors in the application or some memory-related
    issues.</st> <st c="56026">Moreover, Compose cannot perform container orchestration
    in a</st> <st c="56088">distributed setup.</st>
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="56106">Another powerful approach to deploying applications to different
    hosts rather than to a single server is through</st> *<st c="56220">Kubernetes</st>*<st
    c="56230">. In the next section, we’ll use Kubernetes to deploy our</st> `<st
    c="56288">ch11-asgi</st>` <st c="56297">application with Gunicorn as</st> <st
    c="56327">the server.</st>
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="56338">Deploying the application on Kubernetes</st>
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="56378">Like Compose,</st> **<st c="56393">Kubernetes</st>** <st c="56403">or</st>
    **<st c="56407">K8</st>** <st c="56409">manages multiple containers with or without
    dependencies</st> <st c="56467">on each other.</st> <st c="56482">Kubernetes can
    utilize volume storage</st> <st c="56520">for data persistence and has CLI</st>
    <st c="56553">commands to manage the life cycle of the containers.</st> <st c="56606">The
    only difference is that Kubernetes can run containers in a distributed setup and
    uses Pods to manage</st> <st c="56711">its containers.</st>
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="56726">Among the many ways to install Kubernetes, this chapter utilizes
    the</st> **<st c="56796">Kubernetes</st>** <st c="56806">feature in Docker Desktop’s</st>
    **<st c="56835">Settings</st>**<st c="56843">, as shown in</st> *<st c="56857">Figure
    11</st>**<st c="56866">.16</st>*<st c="56869">:</st>
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Kubernetes in Desktop Docker](img/B19383_11_016.jpg)'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="57377">Figure 11.16 – Kubernetes in Desktop Docker</st>
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="57420">Check the</st> **<st c="57431">Enable Kubernetes</st>** <st c="57448">checkbox
    from the</st> **<st c="57467">Settings</st>** <st c="57475">area and click the</st>
    **<st c="57495">Apply & restart</st>** <st c="57510">button in the lower right
    portion of the dashboard.</st> <st c="57563">It will take a while for Kubernetes
    to appear running or</st> *<st c="57620">green</st>* <st c="57625">in the lower
    left corner of the dashboard, depending on the number of containers running on</st>
    <st c="57718">Docker Engine.</st>
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="57732">When the Kubernetes engine fails, click the</st> `<st c="57942">C:\Users\alibatasys\AppData\Local\Temp</st>`
    <st c="57980">folder before restarting</st> <st c="58006">Docker Desktop.</st>
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="58021">Kubernetes uses YAML files to define and create Kubernetes objects,
    such as</st> **<st c="58098">Deployment</st>**<st c="58108">,</st> **<st c="58110">Pods</st>**<st
    c="58114">,</st> **<st c="58116">Services</st>**<st c="58124">, and</st> **<st
    c="58130">PersistentVolume</st>**<st c="58146">, all of which are required to
    establish</st> <st c="58187">some container rules, manage the host resources,
    and build</st> <st c="58246">containerized</st> <st c="58260">applications.</st>
    <st c="58274">An object definition in YAML format</st> <st c="58310">always consists
    of the following</st> <st c="58343">manifest fields:</st>
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="58359">apiVersion</st>`<st c="58370">: The field that indicates the
    appropriate and stable Kubernetes API for a Kubernetes object creation.</st> <st
    c="58474">This field must always appear first in the file.</st> <st c="58523">Kubernetes
    has several APIs, such as</st> `<st c="58560">batch/v1</st>`<st c="58568">,</st>
    `<st c="58570">apps/v1</st>`<st c="58577">,</st> `<st c="58579">v1</st>`<st c="58581">,
    and</st> `<st c="58587">rbac.authorization.k8s.io/v1</st>`<st c="58615">, but
    the more common is</st> `<st c="58640">v1</st>` <st c="58642">for</st> `<st c="58647">PersistentVolume</st>`<st
    c="58663">,</st> `<st c="58665">PersistentVolumeClaims</st>`<st c="58687">,</st>
    `<st c="58689">Service</st>`<st c="58696">,</st> `<st c="58698">Secret</st>`<st
    c="58704">, and</st> `<st c="58710">Pod</st>` <st c="58713">object creation and</st>
    `<st c="58734">apps/v1</st>` <st c="58741">for</st> `<st c="58746">Deployment</st>`
    <st c="58756">and</st> `<st c="58761">ReplicaSets</st>` <st c="58772">objects.</st>
    <st c="58782">So far,</st> `<st c="58790">v1</st>` <st c="58792">is the first
    stable release of</st> <st c="58824">Kubernetes API.</st>'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="58839">kind</st>`<st c="58844">: The field that identifies the Kubernetes
    object the file needs to create.</st> <st c="58921">Here,</st> `<st c="58927">kind</st>`
    <st c="58931">can be</st> `<st c="58939">Secret</st>`<st c="58945">,</st> `<st
    c="58947">Service</st>`<st c="58954">,</st> `<st c="58956">Deployment</st>`<st
    c="58966">,</st> `<st c="58968">Role</st>`<st c="58972">,</st> <st c="58974">or</st>
    `<st c="58977">Pod</st>`<st c="58980">.</st>'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="58981">metadata</st>`<st c="58990">: This field specifies the properties
    of the Kubernetes object defined in the file.</st> <st c="59075">The properties
    may include the</st> *<st c="59106">name</st>*<st c="59110">,</st> *<st c="59112">labels</st>*<st
    c="59118">,</st> <st c="59120">and</st> *<st c="59124">namespace</st>*<st c="59133">.</st>'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="59134">spec</st>`<st c="59139">: This field provides the specification
    of the object in key-value format.</st> <st c="59215">The same object type with
    a different</st> `<st c="59253">apiVersion</st>` <st c="59263">can have different</st>
    <st c="59283">specification details.</st>'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="59134">spec</st>` `<st c="59139">`: 此字段以键值格式提供对象的规范。</st> `<st c="59215">具有不同</st>`
    `<st c="59253">apiVersion</st>` `<st c="59263">的同一种对象类型可以有不同的</st>` `<st c="59283">规范细节。</st>'
- en: <st c="59305">In this</st> <st c="59314">chapter, the Kubernetes deployment</st>
    <st c="59349">involves pulling our</st> `<st c="59370">ch11-asgi</st>` <st c="59379">file’s
    Docker image and the latest</st> `<st c="59415">bitnami/postgresql</st>` <st c="59433">image
    from the Docker registry hub.</st> <st c="59470">But before creating the deployment
    file, our first manifest focuses on containing the</st> `<st c="59556">Secret</st>`
    <st c="59562">object definition, which aims to store and secure the database PostgreSQL
    credentials.</st> <st c="59650">The following is our</st> `<st c="59671">kub-secrets.yaml</st>`
    <st c="59687">file, which contains our</st> `<st c="59713">Secret</st>` <st c="59719">object
    definition:</st>
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，Kubernetes部署涉及从Docker仓库中心拉取我们的`<st c="59370">ch11-asgi</st>`文件和最新的`<st
    c="59415">bitnami/postgresql</st>`镜像。<st c="59433">但在创建部署文件之前，我们的第一个清单关注的是包含`<st
    c="59556">Secret</st>`对象定义，其目的是存储和确保数据库PostgreSQL凭据的安全。</st> `<st c="59650">以下是我们</st>`
    `<st c="59671">kub-secrets.yaml</st>` `<st c="59687">文件，其中包含我们的</st>` `<st c="59713">Secret</st>`
    `<st c="59719">对象定义：</st>
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <st c="59947">A</st> `<st c="59950">Secret</st>` <st c="59956">object contains
    protected data such as a password, user token, or access key.</st> <st c="60035">Instead
    of hardcoding these confidential data in the applications, it is safe to store
    them in Pods so that they can be accessed by other Pods in</st> <st c="60181">the
    cluster.</st>
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="59947">一个</st>` `<st c="59950">Secret</st>` `<st c="59956">对象包含受保护的数据，如密码、用户令牌或访问密钥。</st>
    `<st c="60035">而不是将这些机密数据硬编码到应用程序中，将它们存储在Pod中是安全的，这样其他Pod就可以在集群中访问它们。</st>'
- en: <st c="60193">Our second</st> <st c="60205">YAML file,</st> `<st c="60216">kub-postgresql-pv.yaml</st>`<st
    c="60238">, defines the object that will create persistent storage resources</st>
    <st c="60305">for our PostgreSQL, the</st> `<st c="60329">PersistentVolume</st>`
    <st c="60345">object.</st> <st c="60354">Since our Kubernetes runs on a single-node
    server, the default storage class is</st> `<st c="60434">hostpath</st>`<st c="60442">.
    This storage will hold the data of the PostgreSQL permanently, even after the
    removal of our containerized application.</st> <st c="60564">The following</st>
    `<st c="60578">kub-postgresql-pv.yaml</st>` <st c="60600">file defines the</st>
    `<st c="60618">PersistentVolume</st>` <st c="60634">object that will manage our
    application’s</st> <st c="60677">data storage:</st>
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="60193">我们的第二个</st>` `<st c="60205">YAML文件</st>` `<st c="60216">kub-postgresql-pv.yaml</st>`
    `<st c="60238">定义了将为我们PostgreSQL创建持久存储资源的对象，即</st>` `<st c="60329">PersistentVolume</st>`
    `<st c="60345">对象。</st> `<st c="60354">由于我们的Kubernetes运行在单个节点服务器上，默认存储类是</st>`
    `<st c="60434">hostpath</st>` `<st c="60442">。此存储将永久保存PostgreSQL的数据，即使在我们的容器化应用程序被删除后也是如此。</st>
    `<st c="60564">以下</st>` `<st c="60578">kub-postgresql-pv.yaml</st>` `<st c="60600">文件定义了将管理我们应用程序数据存储的</st>`
    `<st c="60618">PersistentVolume</st>` `<st c="60634">对象：</st>'
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <st c="60894">In Kubernetes, utilizing storage from the</st> `<st c="60937">PersistentVolume</st>`
    <st c="60953">object requires a</st> `<st c="60972">PersistentVolumeClaims</st>`
    <st c="60994">object.</st> <st c="61003">This object requests a portion of the
    cluster storage</st> <st c="61057">that Kubernetes</st> *<st c="61073">Pods</st>*
    <st c="61077">will use</st> <st c="61087">for the application’s read and write.</st>
    <st c="61125">The following</st> `<st c="61139">kub-postgresql-pvc.yaml</st>`
    <st c="61162">file creates an</st> `<st c="61179">PersistentVolumeClaims</st>`
    <st c="61201">object for the</st> <st c="61217">deployment’s storage:</st>
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="60894">在Kubernetes中，利用</st>` `<st c="60937">PersistentVolume</st>`
    `<st c="60953">对象需要一个</st>` `<st c="60972">PersistentVolumeClaims</st>` `<st c="60994">对象。</st>
    `<st c="61003">此对象请求集群存储的一部分，Kubernetes</st>` `<st c="61057">Pods</st>` `<st c="61073">将使用这部分存储进行应用程序的读写。</st>
    `<st c="61125">以下</st>` `<st c="61139">kub-postgresql-pvc.yaml</st>` `<st c="61162">文件为部署的存储创建了一个</st>`
    `<st c="61179">PersistentVolumeClaims</st>` `<st c="61201">对象：</st>'
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <st c="61386">The</st> `<st c="61391">PersistentVolumeClaims</st>` <st c="61413">and</st>
    `<st c="61418">PersistentVolume</st>` <st c="61434">objects work together to dynamically
    claim a new volume storage for the</st> `<st c="61507">bitnami/postgresql</st>`
    <st c="61525">container.</st> <st c="61537">The</st> *<st c="61541">manual</st>*
    `<st c="61547">StorageClass</st>` <st c="61560">type indicates that there is a
    binding from</st> `<st c="61605">PersistentVolumeClaims</st>` <st c="61627">to</st>
    `<st c="61631">PersistentVolume</st>` <st c="61647">for the request of</st> <st
    c="61667">the storage.</st>
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="61679">After creating the configuration files for the</st> `<st c="61727">Secret</st>`<st
    c="61733">,</st> `<st c="61735">PersistentVolume</st>`<st c="61751">, and</st>
    `<st c="61757">PersistentVolumeClaims</st>` <st c="61779">objects, the next crucial
    step is to create the deployment configuration files that will connect the</st>
    `<st c="61881">ch11-asgi</st>` <st c="61890">and</st> `<st c="61895">bitnami/postgresql</st>`
    <st c="61913">Docker images with database configuration details from the</st>
    `<st c="61973">Secret</st>` <st c="61979">object, utilize the volume claims for
    PostgreSQL data persistency, and deploy and run them all together with Kubernetes
    Services and Pods.</st> <st c="62119">Here,</st> `<st c="62125">Deployment</st>`
    <st c="62135">manages a set of Pods to run an application workload.</st> <st c="62190">A
    Pod, as Kubernetes’ fundamental building block, represents a single running process
    within the Kubernetes cluster.</st> <st c="62307">The following</st> `<st c="62321">kub-postgresql-deployment.yaml</st>`
    <st c="62351">file tells Kubernetes to manage an instance that will hold the</st>
    <st c="62415">PostgreSQL container:</st>
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<st c="62780">spec:</st> replicas: 1'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'selector:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'matchLabels:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'app: ch11-postgresql'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'template:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'labels:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'app: ch11-postgresql'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'spec:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'terminationGracePeriodSeconds: 180 <st c="62932">containers:</st> - name: ch11-postgresql'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: bitnami/postgresql:latest'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'imagePullPolicy: IfNotPresent'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ports:'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: tcp-5432'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'containerPort: 5432'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'env:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '- name: POSTGRES_USER'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'valueFrom:'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'secretKeyRef: <st c="63570">name: postgres-credentials</st> key: user'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: POSTGRES_PASSWORD'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'valueFrom:'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'secretKeyRef: <st c="63658">name: postgres-credentials</st> key: password'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: POSTGRES_DB'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'value: ogs'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: PGDATA'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'value: /var/lib/postgresql/data/pgdata'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'volumeMounts:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '- name: data-storage-volume'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mountPath: /var/lib/postgresql/data'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'resources:'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'requests:'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'cpu: "50m"'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'memory: "256Mi"'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'limits:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'cpu: "500m"'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'memory: "256Mi"'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'volumes:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: data-storage-volume'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'persistentVolumeClaim:'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'claimName: postgresql-db-claim'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '--- <st c="64972">apiVersion: v1</st>'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="64986">kind: Service</st>'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="65000">metadata:</st><st c="65010">name: ch11-postgresql-service</st>
    labels: <st c="65049">name: ch11-postgresql</st>'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="65070">spec:</st><st c="65076">ports:</st><st c="65083">- port: 5432</st>
    selector:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'app: ch11-postgresql'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<st c="65354">apiVersion: apps/v1</st>'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="65374">kind: Deployment</st>'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="65391">metadata:</st><st c="65401">name: ch11-app</st> labels:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'name: ch11-app'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<st c="65657">spec:</st> replicas: 1'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'selector:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'matchLabels:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'app: ch11-app'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'template:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'labels:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'app: ch11-app'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'spec:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'containers:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- <st c="66156">name: ch11-app</st><st c="66170">image: sjctrags/ch11-app:latest</st>
    env:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: SERVICE_POSTGRES_SERVICE_HOST'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'value: ch11-postgresql-service. default.svc.cluster.local'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: POSTGRES_DB_USER'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'valueFrom:'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'secretKeyRef: <st c="66354">name: postgres-credentials</st> key: user'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: POSTGRES_DB_PSW'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'valueFrom:'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'secretKeyRef: <st c="66440">name: postgres-credentials</st> key: password'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ports:'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- containerPort: 8000'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '--- <st c="66610">apiVersion: v1</st>'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="66624">kind: Service</st>'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="66638">metadata:</st><st c="66648">name: ch11-app-service</st>'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="66671">spec:</st><st c="66677">type: LoadBalancer</st> selector:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'app: ch11-app <st c="66721">ports:</st> - <st c="66730">protocol: TCP</st><st
    c="66743">port: 8000</st> targetPort: 8000'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: kubectl cp ogs.sql ch11-postgresql-b7fc578f4-6g4nc:/tmp/ogs.sql
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: kubectl exec -it ch11-postgresql-b7fc578f4-6g4nc -- psql -U postgres -d ogs
    -f /tmp/ogs.sql
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: from peewee_async import PooledPostgresqlDatabase
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: import os
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: database = PooledPostgresqlDatabase(
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '''ogs'', <st c="70758">user=os.environ.get(''POSTGRES_DB_USER''),</st><st c="70798">password=os.environ.get(''POSTGRES_DB_PSW''),</st><st
    c="70842">host=os.environ.get(</st> <st c="70863">''SERVICE_POSTGRES_SERVICE_HOST''),</st><st
    c="70897">port=''5432'',</st> max_connections = 3,'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: connect_timeout = 3
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: server { <st c="72747">listen 80</st>; <st c="72759">server_name localhost</st>;
    <st c="72783">location /</st> { <st c="72796">proxy_pass</st> http://ch11-asgi-dep-nginx-api-1:8000/;
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: proxy_set_header <st c="72864">X-Forwarded-For</st> $proxy_add_x_forwarded_for;
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: proxy_set_header <st c="72925">X-Forwarded-Proto</st> $scheme;
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: proxy_set_header <st c="72969">X-Forwarded-Host</st> $host;
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: proxy_set_header <st c="73010">X-Forwarded-Prefix</st> /;
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
