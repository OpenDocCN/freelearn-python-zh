- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Visualization in FX Trading with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we learned how to receive and store market data, how to
    process it, and how to calculate various technical indicators. However, working
    with large amounts of time series data frequently leads to errors typically caused
    by sad mistakes – for example, using incorrect data feed or wrong timestamps.
    Besides that, when working with TA indicators, it’s really wise to check the result
    of the calculations visually – for example, you want to use a large period moving
    average to determine long-term price movements, but you make a mistake, enter
    a small period value, and then find yourself lost in debugging because no real
    long-term trend can be found. Making your research visual helps identify various
    mistakes very quickly and saves a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to visualize data using one of the industry
    standard libraries, `matplotlib`, and then go on to plotting bar and candlestick
    charts with the `mplfinance` library, and we will see how it’s possible to create
    charts with live updates and use additional graphics with price charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Charting and plotting basics – how to use graphical libraries with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick plotting using scripts or an interactive console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing historical market data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating bar and candlestick charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing live market data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding other objects to price charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the practical examples in this chapter, you only require Python 3.9 or
    above.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of charting with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many libraries that implement charting with Python but at the time
    of writing, two of them are industry standards – `matplotlib` and `plotly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy` arrays, support numerous types of charts, including financial ones
    (which is what we need!), provides full control over chart objects, features almost
    unlimited chart customizations, and can be used with different backends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matplotlib` so the choice between the two is not obvious. Plotly definitely
    wins when it comes to interactivity and working with chart objects via an API
    but loses the competition in speed and abilities for customization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which one do we choose? Generally speaking, if you do not plan to develop a
    commercial-grade GUI application, then `matplotlib` is the obvious choice because
    it’s easy to use, is very well documented, and has decent community support.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, let’s quickly look at how `matplotlib` (and similar charting
    libraries in general) work and clearly decide what we are going to do, and especially
    what we are *not* going to do. We will learn about different backends, consider
    the peculiarities of plotting real-time and static data, and get familiar with
    the internal organization of graphical engines and their interaction with the
    *outer world* (your code).
  prefs: []
  type: TYPE_NORMAL
- en: Graphical backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any charting package used with Python has various **backends** – the very engines
    that render graphics on screen. Out of the box, we have a choice of four backends:
    Agg, **PS** (**postscript**), PDF (yes, the standard PDF format used for documents),
    and SVG (the standard for vector graphics).'
  prefs: []
  type: TYPE_NORMAL
- en: Backends have **bindings** – in simple terms, wrappers that facilitate calls
    to backends from Python. Some backends offer interactive tools and controls out
    of the box; in this case, you only need to draw a chart and then you can pan and
    zoom in using built-in controls provided by the backend. Using other backends
    requires full implementation of the user interface, which is great if you want
    to customize and polish your app to a commercial-grade level but is pretty annoying
    if you only want to quickly look at some piece of data.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the standard `matplotlib`, so you don’t need to use any
    special commands in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Static versus real-time data and related issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note the key difference between visualizing static data and
    dynamic data. By **static data**, we mean any data that is read only once, received,
    calculated, and so on, and is not modified in real time. Typically, it is used
    during the research phase when you develop, test, and optimize your trading strategy.
    In this case, we work with historical data saved on the disk or retrieved via
    an API from our broker – but in any case, it is not being modified live. This
    means that both charting libraries work just perfectly without any serious efforts
    from the developer’s side; once the dataset is formed, it can be plotted with
    a single command.
  prefs: []
  type: TYPE_NORMAL
- en: However, once we switch to real-time data visualization, we encounter problems
    because we need to update the chart(s) either periodically or upon an event –
    for example, upon receipt of a new tick. And here, we can encounter issues related
    to multithreading. To better understand these issues, let’s do a quick recap.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember the concept of multithreading that we covered in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*? Running several processes in
    parallel and connecting them using queues makes our trading apps universal, in
    the sense that we can develop all logic only once and then switch between data
    sources in order to go from research and development to production.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we add graphics to our applications, we can sometimes encounter
    issues, and these issues are rooted in the fact that graphics are also running
    in a separate thread. This thread is controlled by a separate mechanism, not the
    one that we use to organize data-receiving and processing threads.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, adding charting in yet another thread to keep it completely separate
    from the main thread is tricky, to say the least. So, we will sacrifice the universality
    of our application in favor of keeping the usage of the graphics simple.
  prefs: []
  type: TYPE_NORMAL
- en: Important note about threads, loops, and process termination
  prefs: []
  type: TYPE_NORMAL
- en: The problem with multithreading is the termination of a thread. If you start
    a thread and don’t add any check on whether to keep it running or terminate, then
    it will run virtually forever. To keep your code correct, you may want to always
    add an exit condition to any thread and/or the entire program (which is also a
    thread). However, when using `matplotlib`, you don’t have explicit control over
    the thread that renders graphics, so you may want to use callbacks from the operating
    system. Therefore, despite the risk of being criticized by programming purists,
    I personally use keyboard termination from inside an IDE to stop the graphics
    loop – keeping in mind that, in production, we won’t have to do that, as we never
    include charting in the production code. It’s up to you to choose how you handle
    this issue, but in my opinion, the simpler, the better.
  prefs: []
  type: TYPE_NORMAL
- en: So, what we *are* going to do is to integrate some basic charting as part of
    the main thread of the main module. It will serve the only purpose of quick visualization
    without any intent to be used as a universal charting software, and will be disabled
    or removed before switching from development mode to production.
  prefs: []
  type: TYPE_NORMAL
- en: What we *are not* going to do is to write complex code that would provide our
    app with a sophisticated GUI that would fully imitate commercial applications,
    such as MetaTrader or MultiCharts.
  prefs: []
  type: TYPE_NORMAL
- en: Enough talk – let’s get coding.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unless you use a clean Python installation, chances are that you already have
    `matplotlib` installed, so check before trying to install it. Just type `import
    matplotlib` in the console and watch the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t have `matplotlib` installed, you can use the standard installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use Conda packages, then you can install `matplotlib` using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Generally speaking, all major third-party Python distributions such as Anaconda,
    ActiveState, ActivePython, and WinPython have `matplotlib` as part of them.
  prefs: []
  type: TYPE_NORMAL
- en: Using Matplotlib in your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`matplotlib` is quite a large library and we actually need only a part of it
    – the very module that does the plotting. As always, I strongly recommend using
    `import` rather than `from ... import` – to keep namespaces separate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This imports the `pyplot` module that actually creates and handles plots. Let’s
    create our first plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.1 – A basic \uFEFFMatplotlib plot](img/B19145_8_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – A basic Matplotlib plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what actually happened:'
  prefs: []
  type: TYPE_NORMAL
- en: The graphics library created a figure – the very **canvas** on which all the
    following charting should be made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, **axes** were created in the figure – the rectangle box with scales from
    0 to 10, in our case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, a graph object was added to the axes – in our case, it’s the diagonal
    line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And finally, `plt.show()` was called – the method that actually displays the
    chart on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Multithreading: revisited'
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code, you will now see a separate process. This process is
    created by the `plt.show()` method and its name is `python`. Don’t confuse it
    with the Python interpreter! This new process handles only the figure that is
    currently being displayed on screen. If you kill it, the `matplotlib` main loop
    is terminated and the figure disappears, but other threads will keep running!
    So, a better idea is to stop the execution of your code from the IDE, to kill
    all threads along with this `python` process.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we had 10 elements in the `y` list, and the horizontal axis
    is graduated accordingly, 0 to 10\. It’s clear that the current plot displays
    the `y = x` linear function, where arguments are integer numbers. However, what
    if we wanted to calculate the same function for fractional arguments – say, the
    same 10 points, but taken between 0 and 1, not 0 and 10?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, as always, we import `pyplot`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we import `numpy` – the universal mathematical library for Python that
    adds support for vectors and matrices, along with myriads of math functions. We’re
    going to use `arange`, which is somewhat similar to the native Python range but
    supports fractional steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we form the range to display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rest of the code is unchanged – just creating a plot and displaying it
    on screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you should see a figure similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The plot of the linear function in the range between 0 and 1
    – the incorrect X-axis scale](img/B19145_8_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The plot of the linear function in the range between 0 and 1 –
    the incorrect X-axis scale
  prefs: []
  type: TYPE_NORMAL
- en: But wait! There’s something wrong with our chart. Yes, the *Y* axis has now
    graduated from 0 to 1 with a step of 0.1, but the *X* axis has still graduated
    from 0 to 10\. This happened because we plotted the new array but did nothing
    to tell the `plt.plot()` method about the new scale by the *X* axis – and by default,
    this method assumes that we plot any array versus indices of its elements, which
    is always an array of integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s fix this mistake by adding the correct `X`-axis data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also modify the call of the `plot()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will see the correct plot, shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The plot of the linear function in the range between 0 and 1
    – now the correct X-axis scale](img/B19145_8_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – The plot of the linear function in the range between 0 and 1 –
    now the correct X-axis scale
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know a bit about how the `plot()` method works, let’s plot some
    actual market data.
  prefs: []
  type: TYPE_NORMAL
- en: Simple plots of market data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following examples, we will use historical data only. We will learn how
    to plot live data received from a broker later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to read and handle market data, some of which were considered
    in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086), *Retrieving and Handling Market
    Data with Python*. Now, we are going to learn some alternative approaches so that
    you can best choose what suits your current research and development needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the most straightforward approach, which uses only native
    Python data structures. As we saw in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    the preferred way of storing and manipulating market data is a dictionary because
    of its full compatibility with the JSON standard and the ability to extract the
    necessary data by keywords. We will start with dictionaries as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we still need to do some imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `csv` module contains very convenient methods to read and parse **comma-separated
    value** (**CSV**) files, which is the de facto standard for storing historical
    market data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s open a data file and create a `DictReader()` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `DictReader()` method parses the CSV file into a dictionary or set of dictionaries
    and returns a `DictReader` object. It uses the first line of the file as the source
    for keywords, so make sure you have it in your source data. In the sample file
    I’m using, the header (the first line) looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, these are the very keywords that will appear in the dictionaries when I
    have read the file and parsed it with `DictReader()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to convert this object into a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we now look at the last three elements in the list by entering `print(all_data[-3:])`,
    we will see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So, we indeed now have 1-minute data in the form of OHLC bars, along with some
    information about the volume and the number of ticks per interval (1 minute).
    Each bar is represented by a separate dictionary, and dictionaries are collected
    in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to extract only the data we want to plot – say, closing prices.
    In order to avoid possible issues by plotting too much data, let’s plot just the
    last 100 data points. There are many ways to do this; we will use list comprehensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rest of the code is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you did everything correctly, you should see a chart similar to the one
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – A simple line chart of closing prices](img/B19145_8_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – A simple line chart of closing prices
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, but what about the *X*-axis labels? Oh, it again just counts the data
    points, 0 to 100, but we want to see something more meaningful here. Let’s recall
    that the `plot()` method actually plots one iterable versus another, so we’ll
    create labels from the timestamps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can see that the numbers along the *X* axis were indeed replaced with
    something, but this something is really hard to read and understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Using timestamps as X-axis labels without proper formatting
    gets erratic results](img/B19145_8_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Using timestamps as X-axis labels without proper formatting gets
    erratic results
  prefs: []
  type: TYPE_NORMAL
- en: Unsurprisingly, the labels (the timestamps) are rather long, there are too many
    of them, and they are displayed one over another, making the result unusable.
    So, we want to format them somehow, printing labels only every 10, 20, or 100
    ticks and rotating them to save screen space.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do that, we should recall the sequence of events that is triggered
    by the call to the `plot()` method, which is explained in the *Using matplotlib
    in your code* section in this chapter. First, a *figure* (a blank canvas) is created,
    an *axis* (rectangle box with axes) is added, and then the actual *plot* is drawn.
    All three objects were created automatically by a single call to the `plot()`
    method. However, in order to be able to modify the visual representation of the
    plot, we need to get access to the `axes` object directly. We now want to rewrite
    the entire code responsible for plotting in order to separate the three aforementioned
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after we formed the `time` list and before the `plot()` call, we add the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This creates a new empty figure object and returns a handle to the `fig` variable.
    Then, we add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This one creates a new subplot, or axis – the very rectangle that we want to
    customize. Great – now we can access it using the `ax` variable. So, let’s limit
    the number of tick labels printed along the *X* axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `set_xticks()` method uses only one argument here – an iterable that specifies
    indices of only those elements in the `time` list that we want to plot. In our
    example, we use a `numpy` `arange` that contains integer numbers with a step of
    15 to plot every 15th timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to make our plot even more readable, let’s turn the labels by 45°
    and plot the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you did everything correctly, you should see a chart like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – A slightly better-looking simple price chart](img/B19145_8_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – A slightly better-looking simple price chart
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have plotted charts only for the last 100 data points, but what if
    we want to plot the market data of a certain day in the past?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite the entire code now to keep everything that we’ve learned so
    far together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So far, there’s no difference; we just import the necessary modules and read
    the data file. Now, we want to plot 100 bars, starting from midnight of December
    12, 2019\. So, we find the position of the dictionary with the relevant value
    of the `Date` keyword in the `all_data` list of dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we extract the required data for plotting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we actually plot using some nice formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it! Now, we can enjoy our chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – A simple price chart of data from a specified date and time](img/B19145_8_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – A simple price chart of data from a specified date and time
  prefs: []
  type: TYPE_NORMAL
- en: Here, we omit all the capabilities of `matplotlib`, including the formatting
    of titles, using colors, multiple subplots, and much more – at the end of the
    day, this book is not a `matplotlib` tutorial. If you’re interested in learning
    more about this reliable charting package, I’d recommend starting with its official
    website ([https://matplotlib.org](https://matplotlib.org)), where you’ll find
    a lot of examples, tutorials, and general documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, now we know how to plot basic price charts – simple line charts of
    closing (or any other) prices versus timestamps. However, we all know that the
    most common format for charting in the financial world is a bar chart or candlestick
    chart. How do we plot such a chart with `matplotlib`?
  prefs: []
  type: TYPE_NORMAL
- en: Well, a few years ago, `matplotlib` itself used to have a `finance` module that
    supported the charts in question. However, now it’s deprecated. So, we have only
    two options – either building financial charts bar by bar using matplotlib’s `bar()`
    method or opting for a relatively new but advanced package, `mplfinance`. This
    package offers very simplistic and straightforward methods to plot price charts,
    but it won’t plot data stored in native Python structures, such as lists or dictionaries.
    Instead, it uses **pandas** to handle market data.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is pandas and how can we use it?
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing static market data with pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pandas is *“a fast, powerful, flexible, and easy to use open source data analysis
    and manipulation tool, built on top of the Python programming language”*, as declared
    on its official web page at [https://pandas.pydata.org](https://pandas.pydata.org).
    It was originally developed exactly for the purpose of manipulating time series
    data, especially market prices.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of native Python lists or NumPy arrays, pandas uses **DataFrames** as
    a core data object. You can think of a DataFrame as a table, where columns represent
    various named time series (or any other series) and rows contain actual data,
    with the first row always containing the names of the series. Pretty much the
    same as with the historical market data file that we’ve used so far? Yes, and
    this makes the learning curve with pandas really steep.
  prefs: []
  type: TYPE_NORMAL
- en: pandas offers methods to add, delete, and rearrange columns, create and modify
    indices, slice and create subsets, merge and reshape DataFrames, and even handle
    missing data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: pandas is quite a comprehensive package that offers various methods to handle
    data to suit very different needs. This book is in no way a pandas tutorial; we
    are going to use only those methods that are required to accomplish the task of
    plotting market data. If you are interested in learning more about pandas, I’d
    recommend starting with a simple tutorial at [https://www.w3schools.com/python/pandas/default.asp](https://www.w3schools.com/python/pandas/default.asp).
  prefs: []
  type: TYPE_NORMAL
- en: Installing pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The official pandas website recommends installing Anaconda, which comes with
    pandas on board, and refers to other installation methods as *advanced*. However,
    there’s nothing really advanced about them. You can use the standard PyPI installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use Conda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Reading data from CSV files with pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'pandas offers a straightforward method to read data from a CSV file. Let’s
    try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Of course, as always, you want to replace the value of `file_name` with the
    actual path to the locally stored historical data CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you did everything correctly, you will see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the first row was used to create column names and the rest
    formed the actual data.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in front of the data read from the file, there’s an additional column
    without a name, and it contains just integer numbers from 0 to 2,136,278 (in the
    example with my file). This is the **DataFrame index**. We can retrieve any specific
    records by referring to them using these numbers – again, pretty much as we would
    do if we used lists. Of course, it’s very inconvenient, as we want to be able
    to retrieve any piece of historical data by referring to a particular date or
    time range. Fortunately, pandas offers a way to build a custom index for a DataFrame,
    so let’s continue with our code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting index for a dataframe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s form the timestamps from the `date` and `time` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use built-in methods, `to_datetime()` and `to_timedelta()`, which convert
    string values into a single `Timestamp` object.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing columns in pandas
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, you can see how pandas allows you to reference a certain
    column by its name. This is very similar to finding values by keywords in a dictionary,
    but in pandas, the entire column is returned, not a scalar value.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment to a column with a non-existent name (`Timestamp`, in our case) effectively
    creates a new column with this name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having created the new column, let’s set it as the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now check the contents of `source_data`, we will see that the new index
    was generated and added to the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now we have indexed all our data points (minute bars) by timestamps.
    Let’s now create a simple bar chart for the same 1-minute historical data that
    we used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple bar charts using pandas and mplfinance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, we don’t want to plot all data in one chart. The data file I’m using
    in this chapter contains about 5 years’ worth of 1-minute bars, or more than 2
    million records, so creating a chart with more than 2 million bars in it would
    simply freeze rendering forever. Let’s create a chart for just a piece of history,
    specifying the date, the starting, and the ending time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The data in my file is in the GMT+1 time zone, so 23:00 here equals 17:00 in
    New York time, which is the bank settlement time for the FX market (see the *Trading
    the FX market – what and how* section in [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044),
    *FX Market Overview from a Developer’s Standpoint*). Also, note that the first
    timestamp for the day (the `start_time` variable) is 1 minute past midnight; for
    bars, timestamps mean the time of the last tick or the closing price of the interval
    (see the *Universal data connector* section in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*, for a detailed explanation
    of data compression and timestamps).
  prefs: []
  type: TYPE_NORMAL
- en: Making slices and subsets in pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most heavily used method to extract a subset from a DataFrame is `.loc()`.
    Its usage is again very intuitive, as it’s very similar to making slices of native
    Python lists; you only need to specify the start and end indexes for the new sub-DataFrame,
    as shown in this pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In our actual code, it will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to strip away all unnecessary data and keep only `Open`, `High`,
    `Low`, and `Close`. Again, with pandas, it can be done in the same straightforward
    way by just specifying the columns to retain in a list – and the rest will be
    thrown away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note the double brackets; the outer pair means that we create a sub-DataFrame
    based on the specified set of columns, and the inner pair actually specifies the
    columns in a list. That’s all done – now, it’s time to create our first bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting market charts with mplfinance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All charts created by `mplfinance` are, by default, bar charts, so let’s start
    with the most simplistic one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you did everything correctly, you should see a figure like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – A default bar chart plotted with mplfinance](img/B19145_8_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – A default bar chart plotted with mplfinance
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, it looks like the same line chart, but this is because we
    have a few too many bars on a relatively small canvas. Here, we can benefit from
    the fact that the `TkAgg` backend used by default in `matplotlib` (and `mplfinance`
    is built on top of `matplotlib`) is interactive; you can click the magnifying
    glass icon and zoom in to any part of the chart – say, the spike in the middle
    of the day:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Using the interactivity of the TkAgg backend to zoom in and
    out](img/B19145_8_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Using the interactivity of the TkAgg backend to zoom in and out
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several options to customize the `mplfinance` charts. For example,
    we can plot a candlestick chart instead of a bar chart and even add a number of
    moving averages to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `mav` means **moving averages**, and their periods are specified in a
    tuple. The result is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – A candlestick chart with moving averages plotted with mplfinance](img/B19145_8_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – A candlestick chart with moving averages plotted with mplfinance
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use both Matplotlib’s `pyplot` and `mplfinance` to create price
    charts in the form of simple line charts or nice-looking bar or candlestick charts.
    However, so far, we have worked only with saved data that is static and not updated
    in real time. But what do we do with data being received live from a broker or
    a data vendor? Let’s see how we can solve this problem using the universal data
    connector approach.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing live market data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on, I strongly recommend you reread the *Working with saved and
    live data – keep your app universal* section in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*, and the *Sliding windows* section
    in [*Chapter 7*](B19145_07.xhtml#_idTextAnchor114), *Technical Analysis and Its
    Implementation in Python*. We are going to use the same architecture to create
    live plots of market data.
  prefs: []
  type: TYPE_NORMAL
- en: Important reminder
  prefs: []
  type: TYPE_NORMAL
- en: Whatever data we receive from a live data source should go into a queue. This
    should be done in a separate thread. Then, data is read from the queue into a
    sliding window that controls the actual amount of data – for any processing or
    plotting.
  prefs: []
  type: TYPE_NORMAL
- en: When we worked with static historical data, we used very convenient methods
    that allowed us to read an entire dataset into memory in one line of code and
    then navigate through it. Of course, any convenience is always paid for, and in
    this case, the fee is running the risk of peeking ahead (see the *Trading logic
    – this is where a small mistake may cost a fortune* section in [*Chapter 4*](B19145_04.xhtml#_idTextAnchor073),
    *Trading Application – What’s Inside?*), which was efficiently solved in [*Chapter
    7*](B19145_07.xhtml#_idTextAnchor114) by using sliding windows and threading and
    feeding data points into them one by one, regardless of whether they were saved
    locally or being received from the broker.
  prefs: []
  type: TYPE_NORMAL
- en: So, in other words, what we were doing so far in this chapter is convenient,
    but it contradicts the idea of building a universal trading application suitable
    for both research and live trading.
  prefs: []
  type: TYPE_NORMAL
- en: Why, therefore, did we do all that, you may ask?
  prefs: []
  type: TYPE_NORMAL
- en: There are two reasons.
  prefs: []
  type: TYPE_NORMAL
- en: First, don’t forget that we use charts only to *either* visually confirm an
    idea during the research phase *or* to check the consistency of live ordering
    in production. When we work on the development of a trading idea, it is infinitely
    more convenient to be able to immediately visualize a certain piece of historical
    data, especially if you work in an interactive environment such as IPython. That’s
    where using pandas with `mplfinance` may be the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: Second, visualization is used not only to plot market data but also (and probably
    even more intensively) to plot the results of a backtest, running simulated trades
    over historical data. And since a backtest is by definition something *carved
    in stone* – that is, not updated live – then using the approaches that we considered
    earlier in this chapter will serve our purpose just fine.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, we want to visualize live market data in order to check its correctness,
    see various indicators, and/or track the order execution. Let’s see how it’s done.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting live tick data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, we start with several imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `json` module will help us parse the response from the data server; we are
    already familiar with the other modules
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we import a method to establish WebSocket connections from the `websocket`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a class that implements the sliding window (see the *Sliding
    windows* section in [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101), *Basics of
    Fundamental Analysis and Its Possible Use in* *FX Trading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a function that creates and maintains the WebSocket connection
    with the market data server. This function has three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The URL to connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message we send to the server to subscribe to market data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The queue in which we place incoming ticks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also implement the function as a class method if you plan to build
    a complex application with multiple connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, send the subscription message, which we will specify later, outside the
    function code (if you implement the function as a `class` method, you may want
    to pass the subscription message as a parameter or have it as a `class` attribute):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successful subscription, the function awaits incoming ticks and places
    them into a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print(tick)` statement is added only for debugging purposes. All preparations
    are done, so now, let’s proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specify the server to connect to and the message we will send to subscribe
    to market data. Please refer to [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*, for a detailed description
    of the LMAX data structure and the *Retrieving data – garbage in – garbage out*
    section in [*Chapter 4*](B19145_04.xhtml#_idTextAnchor073), *Trading Application
    – What’s Inside?*, to refresh your memory on important issues regarding receiving
    and processing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll create the queue to store the incoming ticks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also create a thread to retrieve data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If you did everything correctly and ran the code, you will see the order book
    data coming from the WebSocket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to plot only the top of the book – that is, the current best bid and
    best ask – so let’s add another function that will parse incoming ticks and send
    `bid` and `ask` values to the respective sliding windows. We implement this function
    without arguments because it shares data structures (bid and ask sliding windows)
    with the charting part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This function gets ticks from the queue, extracts bids and asks, and sends
    them to the respective sliding windows (`bids` and `asks`). Let’s create them
    – first, we specify the length of the sliding window (let’s set it to 60, which
    will display about 1 minute’s worth of data, given that LMAX sends an update at
    a rate of about 1 tick per second):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add two windows, for `bids` and `asks` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we wrap the processing function into a thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run the code we have developed so far, we will see pairs of bids
    and asks updated about every 1 second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Great job! Now, we want to plot this live data in a chart.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the most natural course of action would be to create the third
    thread and do all the plotting inside it, to keep all three processes (retrieving
    data, processing, and plotting) separate from each other and the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Alas, with `matplotlib` (and many other charting suites), to do this is very
    complex (although not impossible). So, unfortunately, we have to live with the
    fact that charting is (easily) available only in the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s wait till the entire data in the sliding windows is filled with
    meaningful values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the figure and the axes separately (as we did earlier in this
    chapter when we customized the axis labels):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add two lines for our two data series (the bids and asks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we start the main charting loop, which will draw the lines and refresh
    the figure once every second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command adds small margins above and below the plots, just to
    improve the visual perception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we actually plot the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We then wait for 1 second for the graphics to be rendered and appear on screen;
    otherwise, the loop blocks the rendering we don’t let it run during this pause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'So simple! If you did everything correctly, you should see a figure similar
    to the following one updating every second:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It takes time to fill the entire sliding window. In our example, it will be
    about 60 seconds before the figure appears.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – A simple live price tick chart showing both bid and ask](img/B19145_8_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – A simple live price tick chart showing both bid and ask
  prefs: []
  type: TYPE_NORMAL
- en: Well, now we can draw live charts of market prices, and it has turned out to
    be quite simple and straightforward – but only in form of lines for every tick.
    What if we want to aggregate data and then plot a bar or candlestick chart? Let’s
    find the solution in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting live bar or candlestick charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we worked with bar and candlestick charts, and we
    know that the most streamlined way of doing that is by using the `mplfinance`
    library. The idea is to use the `mplfinance.plot()` method in a loop and update,
    similar to how we just did for line plots of tick data. So, what we want to do
    now is add a new function that would split the incoming tick data stream into
    bars according to a certain rule, adds the formed bars to a DataFrame, and sends
    the resulting DataFrame to the charting loop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with imports. Some imported modules are the same as in the previous
    example because we need them to retrieve data from a WebSocket connection again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we import the `datetime` method, as we will convert string timestamps
    into `datetime` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we have some imports to facilitate charting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we will reuse some of the code from the *Plotting live tick data* section
    – the assignment of the `sliding_window` class, `url`, and `subscription_msg`
    variables, and the initialization of `pipe`, `window_size`, `bids`, and `asks`.
    We will also reuse the `LMAX_connect()` function without changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a new queue into which we will send DataFrames for plotting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also create a new function that will do the job of splitting the incoming
    tick data stream into bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve created an empty DataFrame, set the column titles, and assigned `Timestamp`
    as the index. Next, we set the time frame (resolution) to 10 seconds and initialize
    the timestamp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, as always, if we work with infinite processes in threads, we start the
    loop, in which we read a tick, extract its timestamp and last bid price (we assume
    we want to plot bids; if you want to plot any other data from the order book,
    just choose the appropriate key and value in the dictionary), and if this is the
    very first tick we received, initialize the `open`, `high`, `low`, and `close`
    values for the upcoming bar and set `last_sample_ts` to `ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we specify the condition with which we will start a new bar. In this case,
    we do it as soon as the difference between the current time (`ts`) and the time
    of the previous bar (`last_bar_sample`) becomes greater than the value stored
    in the `resolution` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, as soon as a new 10-second interval is started, we create a new DataFrame
    bar using the `Open`, `High`, `Low`, and `Close` values and the current timestamp,
    and add it to the main DataFrame bars. The rest of the function’s code is pretty
    apparent; first, we again initialize all four price variables, update the timestamp
    of the last bar, and put the DataFrame in the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Of course, if the condition is not `true` (the time since the bars opened did
    not exceed the resolution threshold), we just update the price variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The trick is done; now, let’s create two threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the figure and get a handle on the axes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, run the plotting loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The `block = False` optional argument to the `mpf.plot()` method tells the renderer
    to release the chart after drawing and allow adding or modifying objects in it
    (so that we can do live updates). Don’t forget to add a pause (`plt.pause(1)`);
    otherwise, the loop will always be busy and won’t let the system display the chart
    on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this code, the first thing you will see is a single huge candlestick
    because we don’t have enough data yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – The initial view of the live candlestick chart](img/B19145_8_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – The initial view of the live candlestick chart
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the chart will update every 10 seconds, and after 4 minutes, you will
    see something like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – A 10-second candlestick chart made with live price data](img/B19145_8_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – A 10-second candlestick chart made with live price data
  prefs: []
  type: TYPE_NORMAL
- en: 'As we receive more and more data, there will be more and more candles on the
    chart, so at a certain point, it will become unreadable. Therefore, you may want
    to add a limit and throw away the oldest row from the DataFrame as the newest
    one comes in, just before we place the DataFrame in the `data_for_chart` queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Here, I specified 100 bars to display, and as soon as this limit is reached,
    older bars will disappear from the screen – pretty much like in MetaTrader, MultiCharts,
    TradeStation, or any other charting application.
  prefs: []
  type: TYPE_NORMAL
- en: Very frequently, we will need to plot something else along with the price data.
    It can be a technical indicator, a trendline, just a mark denoting an entry or
    exit, or anything else. Let’s see how we can do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding objects to price charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not difficult to add any objects to the chart if we know their coordinates
    because all `matplotlib` methods always plot one array-like object versus another.
    So, basically, all we need to do to add any special objects to a chart is to calculate
    their position in the list, or the array along the *X* axis and the corresponding
    value along the *Y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a simple yet valuable example. In [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044),
    *FX Market Overview from a Developer’s Standpoint*, we saw that price takers can
    only buy at the ask and sell at the bid. We also saw that a large order can move
    the price a few points (pips) up or down because it consumes the liquidity from
    several levels in the order book. So, we can assume with a good degree of confidence
    that if the best bid suddenly became greater than the best ask at the previous
    tick, then it was possibly a trace of a significant buy order. And it works vice
    versa – if we observe a plunge of the best ask below the previous best bid, then
    it may be a footprint of a significant sell order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s visualize these two situations by adding triangle markers, pointing up
    and down on the tick chart for supposed buys and sells respectively. For this
    purpose, we will use the code that we wrote to visualize live tick data (see the
    *Plotting live tick data* section) and just add a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add two new objects that will display the markers. We add
    them just below the lines where we create objects to display bids and asks (`line1`
    and `line2`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Special modifiers here denote the color and the style of the graphics – `'g^'`
    means a green triangle pointing up and `'mv'` means a magenta triangle pointing
    down. You can find a comprehensive list of the optional parameters of the `pyplot.plot()`
    method at [https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to calculate the coordinates (positions) of these markers. We
    will do it at the very beginning of the main charting loop (immediately after
    `while True:`). Let’s add four respective lists to store the coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, fill them at all occurrences of the best bid being greater than the previous
    best ask, or the best ask being lower than the previous best bid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we start counting from 1 and not from 0 because we want to compare
    a value in the list with the `bids.data[0]` to `bids.data[-1]`, which is effectively
    the **last** element in the list, not the **previous** one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add a margin of 1 `pip` to the values along the *Y* axis so that the markers
    will be placed slightly away from the main chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest is the same as what we did for plotting bids and asks; just add calls
    to the `set_xdata()` and `set_ydata()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That’s it! If we run our script now, we will see green and magenta markers
    pointing to the exact places where supposedly big buys or sells happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – A tick chart with spread-crossing marks added](img/B19145_8_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – A tick chart with spread-crossing marks added
  prefs: []
  type: TYPE_NORMAL
- en: Wow! Does the chart show the exact points to buy or sell? Looks like we’ve found
    an excellent trading strategy. Now, is the only thing left to do to automate it
    and look for a bank with reliable safe deposit boxes to store the earned cash?
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course not. Just look at the following screenshot, and you will see that
    sometimes chasing *big money* can be quite a disappointing experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Another illustration of spread-crossing – the price reverses
    and goes in the opposite direction](img/B19145_8_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Another illustration of spread-crossing – the price reverses and
    goes in the opposite direction
  prefs: []
  type: TYPE_NORMAL
- en: So, as I have maintained throughout the book, there is no free lunch and there
    is no Holy Grail in trading, which means that it is impossible to make money consistently
    for a reasonably long period of time by using only one magical trading rule. Instead,
    we need to develop a trading strategy, something that will incorporate trading
    logic (when we enter and exit the market and why, which normally consists of plenty
    of rules), money management (how much we trade), and risk management (what we
    do if things go wrong or, preferably, how to anticipate that and avoid trading).
    And this is what we are going to consider in the remaining part of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the general principles of handling charts
    with Python. Now, we can quickly find the required part of historical data and
    plot it as line or candlestick charts. We also learned how to plot live market
    data and update the charts in real time. Finally, we learned how to add custom
    graphics to a price chart and discovered that crossing the spread can indeed be
    a potentially valuable trading signal. We are prepared to visualize any data,
    be it market prices or the performance of our trading algorithm, so it’s high
    time we step into the domain of trading strategies to understand how and why they
    work, and to make the right choice for further development. This is what we are
    going to consider in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Orders, Trading Strategies, and Their Performance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous parts, we learned about the FX markets, understood how they operate,
    and discovered how to avoid the intrinsic risks. We also considered the essential
    components of most trading algorithms, which aim at addressing the peculiarities
    of the subject domain.
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 3* moves forward by explaining the ideas behind most trading strategies,
    including all-time classics such as trend following, momentum, and mean reversion,
    along with more advanced arbitrage and stat arbitrage, market making, and high-frequency
    trading. We will also learn about the most common types of orders, typical issues
    with their execution, and ways to mitigate the associated risks. Finally, we will
    build our first trading app, test it, and learn about one of the most common mistakes
    among quant traders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19145_09.xhtml#_idTextAnchor152), *Trading Strategies and Their
    Core Elements*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19145_10.xhtml#_idTextAnchor171), *Types of Orders and Their
    Simulation in Python*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19145_11.xhtml#_idTextAnchor186), *Backtesting and Theoretical
    Performance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
