- en: Building Your Own Extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the first chapter of this book, we have been adding Flask extensions to
    our app in order to add new features and to save us from spending lots of time
    reinventing the wheel. Up to this point, it has been unknown how these Flask extensions
    worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create two simple Flask extensions in order to better understand Flask
    internals and allow you to extend Flask with your own functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extend Jinja
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a Python package, ready to be published to PyPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a YouTube Flask extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, the first extension we are going to create is a simple extension
    that allows the embedding of YouTube videos in Jinja templates using the following
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `video_id` object is the code after `v` in any YouTube URL. For example,
    in the URL `https://www.youtube.com/watch?v=_OBlgSz8sSM`, the `video_id` object
    is `_OBlgSz8sSM`.
  prefs: []
  type: TYPE_NORMAL
- en: For now, the code for this extension resides in `__init__.py`. However, this
    is only for development and debugging purposes. When the code is ready to be shared,
    it is moved into its own project directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that any Flask extension needs is the object that will be initialized
    on the app. This object will handle adding its `Blueprint` object to the app and
    registering the `youtube` function on Jinja:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So far, the only thing this code does is initialize an empty blueprint on the
    `app` object.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the code marked with bold. In the `YouTube` class, we have to register
    the function to Jinja in the `init_app` method. We can now use the `youtube` Jinja
    function on our templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next piece of code needed is a representation of a video. The following
    is a class that handles the parameters from the Jinja function and renders HTML
    to display in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This object is created from the `youtube` function in the template, and any
    arguments passed in the template are given to this object to render the HTML.
    There is also a new object in this code, `Markup`, which was not used before.
    The `Markup` class is Flask's way of automatically escaping HTML, or marking it
    as safe to include in the template. If we just returned HTML, Jinja would auto
    escape it because it does not know whether it is safe or not. This is Flask's
    way of protecting your site from **cross-site scripting attacks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the function that will be registered in Jinja:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to create the HTML that will add the video to the page. In
    a new folder named `youtube` in the `templates` directory, create a new HTML file
    named `video.html` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all the code that''s needed to embed YouTube videos in your templates.
    Let''s test this out now. In `__init__.py`, initialize the `Youtube` class below
    the `Youtube` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In `__init__.py`, use the `youtube_ext` variable, which contains the initialized class, and
    use the `init_app` method we created to register it on the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as a simple example, add the `youtube` function to the top of the blog
    home page on `templates/blog/home.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92fe397f-1ed7-4802-b4bd-300759ec0d67.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Python package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make our new Flask extension available to others, we have to create
    an installable Python package from the code we have written so far. To begin,
    we need a new project directory outside of our current application directory.
    We will need two things: a `setup.py` file, which we will fill in later, and a
    folder named `flask_youtube`. In the `flask_youtube` directory, we will have an
    `__init__.py` file, which contains all the code that we wrote for our extension.
    This includes the `Youtube` and the `Video` Python classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, inside the `flask_youtube` directory, we will need a `templates` directory,
    which holds the `youtube` directory that we put in our app's `templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: In order to turn this code into a Python package, we use the library named `setuptools`.
    Now, `setuptools` is a Python package that allows developers to easily create
    installable packages for their code. `setuptools` bundles code so that `pip` and
    `easy_install` can automatically install them, and will even upload your package
    to the **Python Package Index** (**PyPI**).
  prefs: []
  type: TYPE_NORMAL
- en: All the packages that we have been installed from `pip` have come from PyPI.
    To see all the available packages, go to [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need to do to get this functionality is fill out the `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `setup` function from `setuptools` to find your source code
    and make sure that the machine that is installing your code has the required packages.
    Most of the attributes are rather self-explanatory, except the package attribute,
    which uses the `find_packages` function from `setuptools`.
  prefs: []
  type: TYPE_NORMAL
- en: The `package` attribute finds which parts of the source code are part of the
    package to be released. We use the `find_packages` method to automatically find
    which parts of the code to include. This is based on some sane defaults, such
    as looking for directories with `__init__.py` files and excluding common file
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also declare a manifest file that the `setuptools` will use to know
    how to create our package. This includes rules for cleaning up files, and what
    folders that are not Python modules to include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MANIFEST.in`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Although it is not mandatory, this setup also contains metadata about the author
    and the license, which would be included on the PyPI page if we were to upload
    this there. There is a lot more customization available in the `setup` function,
    so I encourage you to read the documentation at [http://pythonhosted.org/setuptools/](http://pythonhosted.org/setuptools/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now install this package on your machine by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This installs your code into your Python `packages` directory, or if you''re
    using `virtualenv`, it installs it to the local `packages` directory. Then, you
    can import your place on package via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating blog posts with videos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to extend our blog so that users can include videos on their
    posts. This is a nice feature and is useful for showing how to create a new feature
    that includes database schema change and migration, as well as giving a review
    on Jinja2 and WTForms.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add a new column named `youtube_id` (on the following highlighted
    code) to our `Post` SQLAlchemy model on the `blog/models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are able to store our user''s YouTube ID to go along with their posts.
    Next we need to include our new field on the `Post` form. So, in the `blog/forms.py`
    file, we add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to change the `edit` and `new_post` controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blog/controllers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are setting the `Post.youtube_id` SQLAlchemy model attribute to the form `youtube_id` field,
    and for the `edit` method, we have the same thing when the forms have been submitted
    (POST HTTP method), and it''s the other way around when the form is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blog/controllers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just have to include this new field on our Jinja2 templates. On
    our `templates/blog/post.html`, we render this field if it exists on the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To finish, we change our new post and edit the post templates. Just look for
    the change in the provided code.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the response with Flask extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we have created an extension that adds new functionality to our templates.
    But how would we create an extension that modifies the behavior of our app at
    the request level? To demonstrate this, let's create an extension that modifies
    all the responses from Flask by compressing the contents of the response. This
    is a common practice in web development in order to speed up page load times,
    as compressing objects with a method such as `gzip` is very fast and relatively
    cheap, CPU-wise. Normally, this would be handled at the server level. So, unless
    you wish to host your app with only Python code, which is possible and will be
    covered in [Chapter 13](380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml), *Deploying
    Flask Apps*, this extension really doesn't have much use in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will use the `gzip` module in the Python standard library
    to compress the contents after each request is processed. We will also have to
    add special HTTP headers into the response in order for the browser to know that
    the content is compressed. We will also need to check in the HTTP request headers
    whether the browser can accept gzipped content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as before, our content will initially reside in the `__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Just as with the previous extension, our initializer for the compressed object
    accommodates both the normal Flask setup and the application factory setup. In
    the `after_request` method, instead of registering a blueprint, we register a
    new function on the `after-request` event so that our extension can compress the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: The `after_request` method is where the real logic of the extension comes into
    play. First, it checks whether the browser accepts gzip encoding by looking at
    the `Accept-Encoding` value in the request header. If the browser does not accept
    gzip, or the browser did not return a successful response, the function just returns
    the content and makes no modifications to the content. However, if the browser
    does except our content and the response was successful, then the content will
    be compressed. We use another standard library class named `BytesIO`, which allows
    file streams to be written and stored in memory, rather than being stored in an
    intermediate file. This is necessary because the `GzipFile` object expects to
    write to a file object.
  prefs: []
  type: TYPE_NORMAL
- en: After the data is compressed, we set the response object data to the results
    of the compression and set the necessary HTTP header values in the response as
    well. Finally, the gzip content is returned to the browser, and the browser then
    decompresses the content, significantly speeding up the page load times.
  prefs: []
  type: TYPE_NORMAL
- en: In order to test the functionality in your browser, you have to disable Flask
    Debug Toolbar because, at the time of writing, there is a bug in its code where
    it expects all responses to be encoded in UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: If you reload the page, nothing should look different. However, if you use the
    developer tools in the browser of your choice and inspect the responses, you will
    see that they are compressed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have looked at two different examples of different types of Flask
    extensions, you should have a very clear understanding of how most of the Flask
    extensions that we used work. Using the knowledge that you have now, you should
    be able to add any extra functionality to Flask that you need for your specific
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at how to add testing to our application
    to take out the guesswork of whether the changes we made to the code have broken
    any of the functionality of our application.
  prefs: []
  type: TYPE_NORMAL
