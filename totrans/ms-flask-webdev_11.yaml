- en: Building Your Own Extension
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the first chapter of this book, we have been adding Flask extensions to
    our app in order to add new features and to save us from spending lots of time
    reinventing the wheel. Up to this point, it has been unknown how these Flask extensions
    worked.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: How to create two simple Flask extensions in order to better understand Flask
    internals and allow you to extend Flask with your own functionality
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extend Jinja
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a Python package, ready to be published to PyPI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a YouTube Flask extension
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, the first extension we are going to create is a simple extension
    that allows the embedding of YouTube videos in Jinja templates using the following
    tag:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `video_id` object is the code after `v` in any YouTube URL. For example,
    in the URL `https://www.youtube.com/watch?v=_OBlgSz8sSM`, the `video_id` object
    is `_OBlgSz8sSM`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: For now, the code for this extension resides in `__init__.py`. However, this
    is only for development and debugging purposes. When the code is ready to be shared,
    it is moved into its own project directory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that any Flask extension needs is the object that will be initialized
    on the app. This object will handle adding its `Blueprint` object to the app and
    registering the `youtube` function on Jinja:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So far, the only thing this code does is initialize an empty blueprint on the
    `app` object.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Notice the code marked with bold. In the `YouTube` class, we have to register
    the function to Jinja in the `init_app` method. We can now use the `youtube` Jinja
    function on our templates.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The next piece of code needed is a representation of a video. The following
    is a class that handles the parameters from the Jinja function and renders HTML
    to display in the template:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This object is created from the `youtube` function in the template, and any
    arguments passed in the template are given to this object to render the HTML.
    There is also a new object in this code, `Markup`, which was not used before.
    The `Markup` class is Flask's way of automatically escaping HTML, or marking it
    as safe to include in the template. If we just returned HTML, Jinja would auto
    escape it because it does not know whether it is safe or not. This is Flask's
    way of protecting your site from **cross-site scripting attacks**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the function that will be registered in Jinja:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we have to create the HTML that will add the video to the page. In
    a new folder named `youtube` in the `templates` directory, create a new HTML file
    named `video.html` and add the following code to it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is all the code that''s needed to embed YouTube videos in your templates.
    Let''s test this out now. In `__init__.py`, initialize the `Youtube` class below
    the `Youtube` class definition:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `__init__.py`, use the `youtube_ext` variable, which contains the initialized class, and
    use the `init_app` method we created to register it on the app:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, as a simple example, add the `youtube` function to the top of the blog
    home page on `templates/blog/home.html`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will have the following result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92fe397f-1ed7-4802-b4bd-300759ec0d67.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Creating a Python package
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make our new Flask extension available to others, we have to create
    an installable Python package from the code we have written so far. To begin,
    we need a new project directory outside of our current application directory.
    We will need two things: a `setup.py` file, which we will fill in later, and a
    folder named `flask_youtube`. In the `flask_youtube` directory, we will have an
    `__init__.py` file, which contains all the code that we wrote for our extension.
    This includes the `Youtube` and the `Video` Python classes.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Also, inside the `flask_youtube` directory, we will need a `templates` directory,
    which holds the `youtube` directory that we put in our app's `templates` directory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In order to turn this code into a Python package, we use the library named `setuptools`.
    Now, `setuptools` is a Python package that allows developers to easily create
    installable packages for their code. `setuptools` bundles code so that `pip` and
    `easy_install` can automatically install them, and will even upload your package
    to the **Python Package Index** (**PyPI**).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: All the packages that we have been installed from `pip` have come from PyPI.
    To see all the available packages, go to [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need to do to get this functionality is fill out the `setup.py` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code uses the `setup` function from `setuptools` to find your source code
    and make sure that the machine that is installing your code has the required packages.
    Most of the attributes are rather self-explanatory, except the package attribute,
    which uses the `find_packages` function from `setuptools`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The `package` attribute finds which parts of the source code are part of the
    package to be released. We use the `find_packages` method to automatically find
    which parts of the code to include. This is based on some sane defaults, such
    as looking for directories with `__init__.py` files and excluding common file
    extensions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also declare a manifest file that the `setuptools` will use to know
    how to create our package. This includes rules for cleaning up files, and what
    folders that are not Python modules to include:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '`MANIFEST.in`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although it is not mandatory, this setup also contains metadata about the author
    and the license, which would be included on the PyPI page if we were to upload
    this there. There is a lot more customization available in the `setup` function,
    so I encourage you to read the documentation at [http://pythonhosted.org/setuptools/](http://pythonhosted.org/setuptools/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now install this package on your machine by running the following commands:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This installs your code into your Python `packages` directory, or if you''re
    using `virtualenv`, it installs it to the local `packages` directory. Then, you
    can import your place on package via the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating blog posts with videos
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to extend our blog so that users can include videos on their
    posts. This is a nice feature and is useful for showing how to create a new feature
    that includes database schema change and migration, as well as giving a review
    on Jinja2 and WTForms.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add a new column named `youtube_id` (on the following highlighted
    code) to our `Post` SQLAlchemy model on the `blog/models.py` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we are able to store our user''s YouTube ID to go along with their posts.
    Next we need to include our new field on the `Post` form. So, in the `blog/forms.py`
    file, we add the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we need to change the `edit` and `new_post` controllers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '`blog/controllers.py`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are setting the `Post.youtube_id` SQLAlchemy model attribute to the form `youtube_id` field,
    and for the `edit` method, we have the same thing when the forms have been submitted
    (POST HTTP method), and it''s the other way around when the form is shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '`blog/controllers.py`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we just have to include this new field on our Jinja2 templates. On
    our `templates/blog/post.html`, we render this field if it exists on the database:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To finish, we change our new post and edit the post templates. Just look for
    the change in the provided code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the response with Flask extensions
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we have created an extension that adds new functionality to our templates.
    But how would we create an extension that modifies the behavior of our app at
    the request level? To demonstrate this, let's create an extension that modifies
    all the responses from Flask by compressing the contents of the response. This
    is a common practice in web development in order to speed up page load times,
    as compressing objects with a method such as `gzip` is very fast and relatively
    cheap, CPU-wise. Normally, this would be handled at the server level. So, unless
    you wish to host your app with only Python code, which is possible and will be
    covered in [Chapter 13](380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml), *Deploying
    Flask Apps*, this extension really doesn't have much use in the real world.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will use the `gzip` module in the Python standard library
    to compress the contents after each request is processed. We will also have to
    add special HTTP headers into the response in order for the browser to know that
    the content is compressed. We will also need to check in the HTTP request headers
    whether the browser can accept gzipped content.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as before, our content will initially reside in the `__init__.py` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Just as with the previous extension, our initializer for the compressed object
    accommodates both the normal Flask setup and the application factory setup. In
    the `after_request` method, instead of registering a blueprint, we register a
    new function on the `after-request` event so that our extension can compress the
    results.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的扩展一样，我们为压缩对象提供的初始化器既适用于正常的 Flask 设置，也适用于应用程序工厂设置。在 `after_request` 方法中，我们不是注册一个蓝图，而是在
    `after-request` 事件上注册一个新的函数，以便我们的扩展可以压缩结果。
- en: The `after_request` method is where the real logic of the extension comes into
    play. First, it checks whether the browser accepts gzip encoding by looking at
    the `Accept-Encoding` value in the request header. If the browser does not accept
    gzip, or the browser did not return a successful response, the function just returns
    the content and makes no modifications to the content. However, if the browser
    does except our content and the response was successful, then the content will
    be compressed. We use another standard library class named `BytesIO`, which allows
    file streams to be written and stored in memory, rather than being stored in an
    intermediate file. This is necessary because the `GzipFile` object expects to
    write to a file object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`after_request` 方法是扩展真正逻辑发挥作用的地方。首先，它通过查看请求头中的 `Accept-Encoding` 值来检查浏览器是否接受
    gzip 编码。如果浏览器不接受 gzip，或者浏览器没有返回成功的响应，函数就直接返回内容，不对内容进行任何修改。然而，如果浏览器接受我们的内容并且响应是成功的，那么内容将被压缩。我们使用另一个名为
    `BytesIO` 的标准库类，它允许文件流在内存中写入和存储，而不是存储在中间文件中。这是必要的，因为 `GzipFile` 对象期望写入文件对象。'
- en: After the data is compressed, we set the response object data to the results
    of the compression and set the necessary HTTP header values in the response as
    well. Finally, the gzip content is returned to the browser, and the browser then
    decompresses the content, significantly speeding up the page load times.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数据压缩后，我们将响应对象的数据设置为压缩的结果，并在响应中设置必要的 HTTP 头部值。最后，gzip 内容被返回给浏览器，然后浏览器对其进行解压缩，显著加快页面加载时间。
- en: In order to test the functionality in your browser, you have to disable Flask
    Debug Toolbar because, at the time of writing, there is a bug in its code where
    it expects all responses to be encoded in UTF-8.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在浏览器中测试功能，你必须禁用 Flask Debug Toolbar，因为在编写本文时，它的代码中存在一个错误，它期望所有响应都编码为 UTF-8。
- en: If you reload the page, nothing should look different. However, if you use the
    developer tools in the browser of your choice and inspect the responses, you will
    see that they are compressed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新加载页面，看起来应该没有不同。然而，如果你使用你选择的浏览器的开发者工具检查响应，你会看到它们已经被压缩。
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that we have looked at two different examples of different types of Flask
    extensions, you should have a very clear understanding of how most of the Flask
    extensions that we used work. Using the knowledge that you have now, you should
    be able to add any extra functionality to Flask that you need for your specific
    application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了不同类型的 Flask 扩展的两个不同示例，你应该对大多数我们使用的 Flask 扩展的工作方式有非常清晰的理解。利用你现在的知识，你应该能够为你的特定应用程序添加任何额外的
    Flask 功能。
- en: In the next chapter, we are going to look at how to add testing to our application
    to take out the guesswork of whether the changes we made to the code have broken
    any of the functionality of our application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将测试添加到我们的应用程序中，以消除我们做出的代码更改是否破坏了应用程序功能的功能性猜测。
