- en: Selection Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择算法
- en: One interesting set of algorithms related to finding elements in an unordered
    list of items is selection algorithms. In doing so, we shall be answering questions
    that have to do with selecting the median of a set of numbers and selecting the
    ith-smallest or -largest element in a list, among other things.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与在无序列表中查找元素相关的一组有趣的算法是选择算法。在这样做的时候，我们将回答有关选择一组数字的中位数以及选择列表中的第i个最小或最大元素等问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Selection by sorting
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序选择
- en: Randomized selection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择
- en: Deterministic selection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性选择
- en: Selection by sorting
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序选择
- en: Items in a list may undergo statistical enquiries such as finding the mean,
    median, and mode values. Finding the mean and mode values do not require the list
    to be ordered. However, to find the median in a list of numbers, the list must
    first be ordered. Finding the median requires one to find the element in the middle
    position of the ordered list. But what if we want to find the last-smallest item
    in the list or the first-smallest item in the list?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的项目可能需要进行统计调查，例如找到平均值、中位数和众数。找到平均值和众数不需要对列表进行排序。然而，要找到数字列表中的中位数，必须首先对列表进行排序。找到中位数需要找到有序列表中间位置的元素。但如果我们想找到列表中的最后一个最小项或第一个最小项呢？
- en: To find the ith-smallest number in an unordered list of items, the index of
    where that item occurs is important to obtain. But because the elements have not
    been sorted, it is difficult to know whether the element at index 0 in a list
    is really the first-smallest number.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要在无序列表中找到第i个最小的数字，该元素出现的位置索引是重要的。但由于元素尚未排序，很难知道列表中索引为0的元素是否真的是第一个最小的数字。
- en: A pragmatic and obvious thing to do when dealing with unordered lists is to
    first sort the list. Once the list is sorted, one is assured that the zeroth element
    in the list will house the first-smallest element in the list. Likewise, the last
    element in the list will house the last-smallest element in the list.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理无序列表时，一个实用且明显的事情是首先对列表进行排序。一旦列表排序，就可以确保列表中的零元素将包含列表中的第一个最小元素。同样，列表中的最后一个元素将包含列表中的最后一个最小元素。
- en: Assume that perhaps the luxury of sorting before performing the search cannot
    be afforded. Is it possible to find the ith-smallest element without having to
    sort the list in the first place?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在进行搜索之前排序的奢侈可能负担不起。是否可以在不首先对列表进行排序的情况下找到第i个最小的元素？
- en: Randomized selection
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机选择
- en: 'In the previous chapter, we examined the quick sort algorithm. The quick sort
    algorithm allows us to sort an unordered list of items but has a way of preserving
    the index of elements as the sorting algorithm runs. Generally speaking, the quick
    sort algorithm does the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了快速排序算法。快速排序算法允许我们对无序列表中的项目进行排序，但有一个方法可以在排序算法运行时保留元素的索引。一般来说，快速排序算法执行以下操作：
- en: Selects a pivot.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个枢轴。
- en: Partitions the unsorted list around the pivot.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在枢轴周围划分未排序的列表。
- en: Recursively sorts the two halves of the partitioned list using *step 1* and
    *step 2*.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归地对划分后的列表的两半使用*步骤1*和*步骤2*进行排序。
- en: One interesting and important fact is that after every partitioning step, the
    index of the pivot will not change even after the list has become sorted. It is
    this property that enables us to be able to work with a not-so-fully sorted list
    to obtain the ith-smallest number. Because randomized selection is based on the
    quick sort algorithm, it is generally referred to as quick select.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣且重要的事实是，在每次划分步骤之后，枢轴的索引即使在列表排序后也不会改变。正是这个特性使我们能够处理一个不是完全排序的列表来获取第i个最小的数字。因为随机选择基于快速排序算法，所以通常被称为快速选择。
- en: Quick select
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速选择
- en: 'The quick select algorithm is used to obtain the ith-smallest element in an
    unordered list of items, in this case, numbers. We declare the main method of
    the algorithm as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 快速选择算法用于在无序列表的项目中获取第i个最小的元素，在这种情况下，是数字。我们声明算法的主要方法如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `quick_select` function takes as parameters the index of the first element
    in the list as well as the last. The ith element is specified by the third parameter
    `k`. Values greater or equal to zero (0) are allowed in such a way that when `k`
    is 0, we know to search for the first-smallest item in the list. Others like to
    treat the `k` parameter so that it maps directly with the index that the user
    is searching for, so that the first-smallest number maps to the 0 index of a sorted
    list. It's all a matter of preference.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick_select`函数接受列表中第一个元素的索引以及最后一个元素的索引作为参数。第i个元素由第三个参数`k`指定。允许值大于或等于零（0），这样当`k`为0时，我们知道要搜索列表中的第一个最小元素。其他人喜欢将`k`参数直接映射到用户正在搜索的索引，这样第一个最小数字就映射到排序列表的0索引。这完全取决于个人喜好。'
- en: A method call to the partition function, `split = partition(array_list, left,
    right),` returns the `split` index. This index of `split` array is the position
    in the unordered list where all elements between `right` to `split-1` are less
    than the element contained in the array `split`, while all elements between `split+1`
    to `left` are greater.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对分区函数的调用`split = partition(array_list, left, right)`返回`split`索引。这个`split`数组的索引是在未排序列表中，所有元素在`right`到`split-1`之间都小于`split`数组中包含的元素，而所有元素在`split+1`到`left`之间都大于。
- en: When the `partition` function returns the `split` value, we compare it with
    `k` to find out if the `split` corresponds to the kth items.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当`partition`函数返回`split`值时，我们将其与`k`进行比较，以确定`split`是否对应于第k个元素。
- en: 'If `split` is less than `k`, then it means that the kth-smallest item should
    exist or be found between `split+1` and `right`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`split`小于`k`，那么这意味着第k个最小元素应该存在于`split+1`和`right`之间：
- en: '![](img/image_11_001.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_11_001.jpg)'
- en: 'In the preceding example, a split within an imaginary unordered list occurs
    at index 5, while we are searching for the second-smallest number. Since 5<2 yields
    `false`, a recursive call to return `quick_select(array_list, left, split-1, k)`
    is made so that the other half of the list is searched:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，在一个假想的未排序列表中的分割发生在索引5处，而我们正在寻找第二个最小的数字。由于5<2的结果是`false`，因此会进行递归调用`quick_select(array_list,
    left, split-1, k)`，以便搜索列表的另一部分：
- en: 'If the `split` index was less than `k`, then we would make a call to `quick_select`
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`split`索引小于`k`，那么我们将调用`quick_select`如下：
- en: '![](img/image_11_003-1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_11_003-1.jpg)'
- en: Partition step
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区步骤
- en: 'The partition step is exactly like we had in the quick sort algorithm. There
    are a couple of things worthy of note:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 分区步骤与我们在快速排序算法中看到的是一样的。有几个值得注意的点：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An if statement has been inserted at the beginning of the function definition
    to cater for situations where `first_index` is equal to `last_index`. In such
    cases, it means there is only one element in our sublist. We therefore simply
    return any of the function parameters, in this case, `first_index`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义的开始处插入了一个if语句，以处理`first_index`等于`last_index`的情况。在这种情况下，这意味着我们的子列表中只有一个元素。因此，我们只需返回任何函数参数即可，在这种情况下，是`first_index`。
- en: The first element is always chosen as the pivot. This choice to make the first
    element the pivot is a random decision. It often does not yield a good split and
    subsequently a good partition. However, the ith element will eventually be found
    even though the pivot is chosen at random.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素总是被选作枢轴。将第一个元素作为枢轴的选择是一个随机决策。这通常不会产生好的分割，从而也不会产生好的分区。然而，即使枢轴是随机选择的，最终也会找到第i个元素。
- en: The `partition` function returns the pivot index pointed to by `less_than_pivot_index`,
    as we saw in the preceding chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition`函数返回由`less_than_pivot_index`指向的枢轴索引，正如我们在前一章中看到的。'
- en: From this point on, you will need to follow the program execution with a pencil
    and paper to get a better feel of how the split variable is being used to determine
    the section of the list to search for the ith-smallest item.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，你需要用铅笔和纸跟随程序执行，以更好地了解如何使用分割变量来确定搜索第i个最小元素的列表部分。
- en: Deterministic selection
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定性选择
- en: The worst-case performance of a randomized selection algorithm is **O**(*n²*).
    It is possible to improve on a section of the randomized selection algorithm to
    obtain a worst-case performance of **O**(*n*). This kind of algorithm is called
    **deterministic selection**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择算法的最坏情况性能是**O**(*n²*)。有可能改进随机选择算法的一部分，以获得最坏情况性能为**O**(*n*)。这种算法被称为**确定性选择**。
- en: 'The general approach to the deterministic algorithm is listed here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性算法的一般方法如下所示：
- en: 'Select a pivot:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个枢轴：
- en: Split a list of unordered items into groups of five elements each.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将无序项目列表分成每组五个元素。
- en: Sort and find the median of all the groups.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有组进行排序并找到中位数。
- en: Repeat *step 1* and *step 2* recursively to obtain the true median of the list.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归重复*步骤1*和*步骤2*以获得列表的真实中位数。
- en: Use the true median to partition the list of unordered items.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用真实中位数对无序项目列表进行分区。
- en: Recurse into the part of the partitioned list that may contain the ith-smallest
    element.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归到可能包含第i个最小元素的分区列表部分。
- en: Pivot selection
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枢轴选择
- en: 'Previously, in the random selection algorithm, we selected the first element
    as the pivot. We shall replace that step with a sequence of steps that enables
    us to obtain the true or approximate median. This will improve the partitioning
    of the list about the pivot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机选择算法中，我们之前选择第一个元素作为枢轴。我们将用一系列步骤来替换这一步，使我们能够获得真实或近似的中位数。这将改善列表关于枢轴的分区：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now study the code for the partition function. The `nearest_median`
    variable stores the true or approximate median of a given list:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来研究分区函数的代码。`nearest_median`变量存储给定列表的真实或近似中位数：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the `unsorted_array` parameter has only one element, `first_index` and `last_index`
    will be equal. `first_index` is therefore returned anyway.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`unsorted_array`参数只有一个元素，`first_index`和`last_index`将相等。因此，无论如何都会返回`first_index`。
- en: However, if the list size is greater than one, we call the `median_of_medians`
    function with the section of the array, demarcated by `first_index` and `last_index`.
    The return value is yet again stored in `nearest_median`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果列表大小大于一个，我们将使用由`first_index`和`last_index`定义的数组部分调用`median_of_medians`函数。返回值再次存储在`nearest_median`中。
- en: Median of medians
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中位数的中位数
- en: 'The `median_of_medians` function is responsible for finding the approximate
    median of any given list of items. The function uses recursion to return the true
    median:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`median_of_medians`函数负责找到任何给定项目列表的近似中位数。该函数使用递归来返回真实中位数：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function begins by splitting the list, `elems`, into groups of five elements
    each. This means that if `elems` contains 100 items, there will be 20 groups created
    by the statement `sublists = [elems[j:j+5] for j in range(0, len(elems), 5)],`
    with each containing exactly five elements or fewer:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先将列表`elems`分成每组五个元素的组。这意味着如果`elems`包含100个元素，那么通过语句`sublists = [elems[j:j+5]
    for j in range(0, len(elems), 5)]`将创建20个组，每个组包含恰好五个元素或更少：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An empty array is created and assigned to `medians,` which stores the medians
    in each of the five element arrays assigned to `sublists`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空数组并将其分配给`medians`，它存储分配给`sublists`的每个五个元素数组中的中位数。
- en: The for loop iterates over the list of lists inside `sublists`. Each sublist
    is sorted, the median found, and stored in the `medians` list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: for循环遍历`sublists`内部的列表列表。每个子列表被排序，找到中位数并存储在`medians`列表中。
- en: The `medians.append(sorted(sublist)[len(sublist)/2])` statement will sort the
    list and obtain the element stored in its middle index. This becomes the median
    of the five-element list. The use of an existing sorting function will not impact
    the performance of the algorithm due to the list's small size.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`medians.append(sorted(sublist)[len(sublist)/2])`语句将排序列表并获取存储在其中间索引的元素。这成为五个元素列表的中位数。由于列表的大小很小，使用现有的排序函数不会影响算法的性能。'
- en: We understood from the outset that we would not sort the list in order to find
    the ith-smallest element, so why employ Python's sorted method? Well, since we
    are sorting a very small list of five elements or fewer, the impact of that operation
    on the overall performance of the algorithm is considered negligible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一开始就明白，我们不会对列表进行排序以找到第i个最小元素，那么为什么还要使用Python的排序方法呢？嗯，由于我们正在对非常小的列表（五个元素或更少）进行排序，该操作对算法整体性能的影响被认为是微不足道的。
- en: 'Thereafter, if the list now contains five or fewer elements, we shall sort
    the `medians` list and return the element located in its middle index:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，如果列表现在包含五个或更少的元素，我们将对`medians`列表进行排序，并返回位于其中间索引的元素：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If, on the other hand, the size of the list is greater than five, we recursively
    call the `median_of_medians` function again, supplying it with the list of the
    medians stored in `medians`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表的大小大于五个，我们将再次递归调用`median_of_medians`函数，并给它提供存储在`medians`中的中位数列表。
- en: 'Take, for instance, the following list of numbers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下数字列表为例：
- en: '*[2, 3, 5, 4, 1, 12, 11, 13, 16, 7, 8, 6, 10, 9, 17, 15, 19, 20, 18, 23, 21,
    22, 25, 24, 14]*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*[2, 3, 5, 4, 1, 12, 11, 13, 16, 7, 8, 6, 10, 9, 17, 15, 19, 20, 18, 23, 21,
    22, 25, 24, 14]*'
- en: 'We can break this list into groups of five elements each with the code statement
    `sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]`, to obtain the following
    list:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用代码语句`sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]`将这个列表分成每组五个元素的组，以获得以下列表：
- en: '*[[2, 3, 5, 4, 1], [12, 11, 13, 16, 7], [8, 6, 10, 9, 17], [15, 19, 20, 18,
    23], [21, 22, 25, 24, 14]]*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*[[2, 3, 5, 4, 1], [12, 11, 13, 16, 7], [8, 6, 10, 9, 17], [15, 19, 20, 18,
    23], [21, 22, 25, 24, 14]]*'
- en: 'Sorting each of the five-element lists and obtaining their medians produces
    the following list:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对五个元素的列表进行排序并获取它们的中位数，得到以下列表：
- en: '*[3, 12, 9, 19, 22]*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*[3, 12, 9, 19, 22]*'
- en: Since the list is five elements in size, we only return the median of the sorted
    list, or we would have made another call to the `median_of_median` function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表大小为五个元素，我们只返回排序列表的中位数，否则我们将对`median_of_median`函数进行另一次调用。
- en: Partitioning step
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区步骤
- en: 'Now that we have obtained the approximate median, the `get_index_of_nearest_median`
    function takes the bounds of the list indicated by the `first` and `last` parameters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了近似中位数，`get_index_of_nearest_median`函数根据`first`和`last`参数指定的列表范围取值：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once again, we only return the first index if there is only one element in
    the list. The `arraylist[first:second]` returns an array with index 0 up to the
    size of the `list -1`. When we find the index of the median, we lose the portion
    in the list where it occurs because of the new range indexing the `[first:second]`
    code returns. Therefore, we must add whatever index is returned by `arraylist[first:second]`
    to `first` to obtain the true index where the median was found:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果列表中只有一个元素，我们只返回第一个索引。`arraylist[first:second]`返回一个从索引0到`list -1`大小的数组。当我们找到中位数的索引时，由于新的范围索引，我们失去了列表中该元素所在的区域，因为`[first:second]`代码返回的范围。因此，我们必须将`arraylist[first:second]`返回的任何索引加到`first`上，以获得中位数实际找到的索引：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We then swap the first element in `unsorted_array` with `index_of_nearest_median`,
    using the swap function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用交换函数将`unsorted_array`中的第一个元素与`index_of_nearest_median`交换。
- en: 'The utility function to swap two array elements is shown here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 交换两个数组元素的实用函数如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our approximate median is now stored at `first_index` of the unsorted list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将近似中位数存储在未排序列表的`first_index`位置。
- en: 'The partition function continues as it would in the code of the quick select
    algorithm. After the partitioning step, the array looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 分区函数继续按照快速选择算法的代码进行。在分区步骤之后，数组看起来是这样的：
- en: '![](img/image_11_004-1.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_11_004-1.jpg)'
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you will have already observed, the main function of the deterministic selection
    algorithm looks exactly the same as its random selection counterpart. After the
    initial `array_list` has been partitioned about the approximate median, a comparison
    with the kth element is made.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经观察到的，确定性选择算法的主要功能与随机选择对应算法完全相同。在`array_list`关于近似中位数分区后，与第k个元素进行比较。
- en: If `split` is less than `k`, then a recursive call to `deterministic_select(array_list,
    split + 1, right, k)` is made. This will look for the kth element in that half
    of the array. Otherwise the function call to `deterministic_select(array_list,
    left, split-1, k)` is made.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`split`小于`k`，则调用`deterministic_select(array_list, split + 1, right, k)`进行递归调用。这将寻找数组那一半的第k个元素。否则，调用`deterministic_select(array_list,
    left, split-1, k)`。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter has examined ways to answer the question of how to find the ith-smallest
    element in a list. The trivial solution of simply sorting a list to perform the
    operation of finding the ith-smallest has been explored.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了如何回答如何在列表中找到第i个最小元素的问题。已经探讨了简单地排序列表以执行查找第i个最小元素操作的平凡解决方案。
- en: There is also the possibility of not necessarily sorting the list before we
    can determine the ith-smallest element. The random selection algorithm allows
    us to modify the quick sort algorithm to determine the ith-smallest element.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定第i个最小元素之前，我们不一定需要对列表进行排序。随机选择算法允许我们修改快速排序算法以确定第i个最小元素。
- en: To further improve upon the random selection algorithm so that we can obtain
    a time complexity of **O**(*n*), we embark on finding the median of medians to
    enable us find a good split during partitioning.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高随机选择算法，以便我们可以获得**O**(*n*)的时间复杂度，我们着手寻找中位数的中位数，以便我们在分区期间找到一个好的分割点。
- en: In the next chapter, we will explore the world of strings. We will learn how
    to efficiently store and manipulate large amounts of text. Data structures and
    common string operations will be covered too.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索字符串的世界。我们将学习如何高效地存储和操作大量文本。同时，我们还将涵盖数据结构和常见的字符串操作。
