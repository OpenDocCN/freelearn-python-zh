- en: Object-Oriented Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In software development, design is often considered as the step done *before*
    programming. This isn''t true; in reality, analysis, programming, and design tend
    to overlap, combine, and interweave. In this chapter, we will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What object-oriented means
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between object-oriented design and object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic principles of object-oriented design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic **Unified Modeling Language** (**UML**) and when it isn't evil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing object-oriented
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everyone knows what an object is: a tangible thing that we can sense, feel,
    and manipulate. The earliest objects we interact with are typically baby toys.
    Wooden blocks, plastic shapes, and over-sized puzzle pieces are common first objects.
    Babies learn quickly that certain objects do certain things: bells ring, buttons
    are pressed, and levers are pulled.'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of an object in software development is not terribly different.
    Software objects may not be tangible things that you can pick up, sense, or feel,
    but they are models of something that can do certain things and have certain things
    done to them. Formally, an object is a collection of **data** and associated **behaviors**.
  prefs: []
  type: TYPE_NORMAL
- en: So, knowing what an object is, what does it mean to be object-oriented? In the
    dictionary, *oriented* means *directed toward*. So object-oriented means functionally
    directed toward modeling objects. This is one of many techniques used for modeling
    complex systems. It is defined by describing a collection of interacting objects
    via their data and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: If you've read any hype, you've probably come across the terms *object-oriented
    analysis*, *object-oriented design*, *object-oriented analysis and design*, and
    *object-oriented programming*. These are all highly related concepts under the
    general *object-oriented* umbrella.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, analysis, design, and programming are all stages of software development.
    Calling them object-oriented simply specifies what level of software development
    is being pursued.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented analysis** (**OOA**) is the process of looking at a problem,
    system, or task (that somebody wants to turn into an application) and identifying
    the objects and interactions between those objects. The analysis stage is all
    about *what* needs to be done.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the analysis stage is a set of requirements. If we were to complete
    the analysis stage in one step, we would have turned a task, such as *I need a
    website*, into a set of requirements.  As an example, here or some requirements
    as to what a website visitor might need to do (*italic* represents actions, **bold**
    represents objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Review* our **history**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apply* for **jobs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Browse*, *compare*, and *order* **products**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some ways, *analysis* is a misnomer. The baby we discussed earlier doesn't
    analyze the blocks and puzzle pieces. Instead, she explores her environment, manipulates
    shapes, and sees where they might fit. A better turn of phrase might be *object-oriented
    exploration*. In software development, the initial stages of analysis include
    interviewing customers, studying their processes, and eliminating possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented design** (**OOD**) is the process of converting such requirements
    into an implementation specification. The designer must name the objects, define
    the behaviors, and formally specify which objects can activate specific behaviors
    on other objects. The design stage is all about *how* things should be done.'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the design stage is an implementation specification. If we were
    to complete the design stage in a single step, we would have turned the requirements
    defined during object-oriented analysis into a set of classes and interfaces that
    could be implemented in (ideally) any object-oriented programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) is the process of converting this
    perfectly-defined design into a working program that does exactly what the CEO
    originally requested.'
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, right! It would be lovely if the world met this ideal and we could follow
    these stages one by one, in perfect order, like all the old textbooks told us
    to. As usual, the real world is much murkier. No matter how hard we try to separate
    these stages, we'll always find things that need further analysis while we're
    designing. When we're programming, we find features that need clarification in
    the design.
  prefs: []
  type: TYPE_NORMAL
- en: Most twenty-first century development happens in an iterative development model.
    In iterative development, a small part of the task is modeled, designed, and programmed,
    and then the program is reviewed and expanded to improve each feature and include
    new features in a series of short development cycles.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this book is about object-oriented programming, but in this chapter,
    we will cover the basic object-oriented principles in the context of design. This
    allows us to understand these (rather simple) concepts without having to argue
    with software syntax or Python tracebacks.
  prefs: []
  type: TYPE_NORMAL
- en: Objects and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, an object is a collection of data with associated behaviors. How do we differentiate
    between types of objects? Apples and oranges are both objects, but it is a common
    adage that they cannot be compared. Apples and oranges aren't modeled very often
    in computer programming, but let's pretend we're doing an inventory application
    for a fruit farm. To facilitate the example, we can assume that apples go in barrels
    and oranges go in baskets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have four kinds of objects: apples, oranges, baskets, and barrels.
    In object-oriented modeling, the term used for a *kind of object* is **class**.
    So, in technical terms, we now have four classes of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to understand the difference between an object and a class.
    Classes describe objects. They are like blueprints for creating an object. You
    might have three oranges sitting on the table in front of you. Each orange is
    a distinct object, but all three have the attributes and behaviors associated
    with one class: the general class of oranges.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship between the four classes of objects in our inventory system
    can be described using a **Unified Modeling Language** (invariably referred to
    as **UML**, because three-letter acronyms never go out of style) class diagram.
    Here is our first class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da5a618a-1873-45d4-9cc1-9f6a3be48278.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram shows that an **Orange** is somehow associated with a **Basket**
    and that an **Apple** is also somehow associated with a **Barrel**. *Association*
    is the most basic way for two classes to be related.
  prefs: []
  type: TYPE_NORMAL
- en: UML is very popular among managers, and occasionally disparaged by programmers.
    The syntax of a UML diagram is generally pretty obvious; you don't have to read
    a tutorial to (mostly) understand what is going on when you see one. UML is also
    fairly easy to draw, and quite intuitive. After all, many people, when describing
    classes and their relationships, will naturally draw boxes with lines between
    them. Having a standard based on these intuitive diagrams makes it easy for programmers
    to communicate with designers, managers, and each other.
  prefs: []
  type: TYPE_NORMAL
- en: However, some programmers think UML is a waste of time. Citing iterative development,
    they will argue that formal specifications done up in fancy UML diagrams are going
    to be redundant before they're implemented, and that maintaining these formal
    diagrams will only waste time and not benefit anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the corporate structure involved, this may or may not be true.
    However, every programming team consisting of more than one person will occasionally
    have to sit down and hash out the details of the subsystem it is currently working
    on. UML is extremely useful in these brainstorming sessions for quick and easy
    communication. Even those organizations that scoff at formal class diagrams tend
    to use some informal version of UML in their design meetings or team discussions.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the most important person you will ever have to communicate with
    is yourself. We all think we can remember the design decisions we've made, but
    there will always be the *Why did I do that?* moments hiding in our future. If
    we keep the scraps of papers we did our initial diagramming on when we started
    a design, we'll eventually find them a useful reference.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter, however, is not meant to be a tutorial on UML. There are many
    of those available on the internet, as well as numerous books on the topic. UML
    covers far more than class and object diagrams; it also has a syntax for use cases,
    deployment, state changes, and activities. We'll be dealing with some common class
    diagram syntax in this discussion of object-oriented design. You can pick up the
    structure by example, and you'll subconsciously choose the UML-inspired syntax
    in your own team or personal design sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Our initial diagram, while correct, does not remind us that apples go in barrels
    or how many barrels a single apple can go in. It only tells us that apples are
    somehow associated with barrels. The association between classes is often obvious
    and needs no further explanation, but we have the option to add further clarification
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of UML is that most things are optional. We only need to specify
    as much information in a diagram as makes sense for the current situation. In
    a quick whiteboard session, we might just quickly draw lines between boxes. In
    a formal document, we might go into more detail. In the case of apples and barrels,
    we can be fairly confident that the association is **many apples go in one barrel**,
    but just to make sure nobody confuses it with **one apple spoils one barrel**,
    we can enhance the diagram as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dd6f137-fafa-4b84-9619-afc7c64c3102.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram tells us that oranges **go in** baskets, with a little arrow showing
    what goes in what. It also tells us the number of that object that can be used
    in the association on both sides of the relationship. One **Basket** can hold
    many (represented by a *****) **Orange** objects. Any one **Orange** can go in
    exactly one **Basket**. This number is referred to as the *multiplicity* of the
    object. You may also hear it described as the *cardinality*. These are actually
    slightly distinct terms. Cardinality refers to the actual number of items in the
    set, whereas multiplicity specifies how small or how large the set could be.
  prefs: []
  type: TYPE_NORMAL
- en: I sometimes forget which end of the relationship line is supposed to have which
    multiplicity number. The multiplicity nearest to a class is the number of objects
    of that class that can be associated with any one object at the other end of the
    association. For the apple goes in barrel association, reading from left to right,
    many instances of the **Apple** class (that is many **Apple** objects) can go
    in any one **Barrel**. Reading from right to left, exactly one **Barrel** can
    be associated with any one **Apple**.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying attributes and behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a grasp of some basic object-oriented terminology. Objects are instances
    of classes that can be associated with each other. An object instance is a specific
    object with its own set of data and behaviors; a specific orange on the table
    in front of us is said to be an instance of the general class of oranges. That's
    simple enough, but let's dive into the meaning of those two words, *data* and
    *behaviors*.
  prefs: []
  type: TYPE_NORMAL
- en: Data describes objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with data. Data represents the individual characteristics of a certain
    object. A class can define specific sets of characteristics that are shared by
    all objects from that class. Any specific object can have different data values
    for the given characteristics. For example, the three oranges on our table (if
    we haven't eaten any) could each weigh a different amount. The orange class could
    have a weight attribute to represent that datum. All instances of the orange class
    have a weight attribute, but each orange has a different value for this attribute.
    Attributes don't have to be unique, though; any two oranges may weigh the same
    amount. As a more realistic example, two objects representing different customers
    might have the same value for a first name attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes are frequently referred to as **members** or **properties**. Some
    authors suggest that the terms have different meanings, usually that attributes
    are settable, while properties are read-only. In Python, the concept of *read-only* is
    rather pointless, so throughout this book, we'll see the two terms used interchangeably.
    In addition, as we'll discuss in [Chapter 5](42cd7e16-073b-485c-8073-554ac64d992f.xhtml),
    *When to Use Object-Oriented Programming*, the `property` keyword has a special
    meaning in Python for a particular kind of attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our fruit inventory application, the fruit farmer may want to know what
    orchard the orange came from, when it was picked, and how much it weighs. They
    might also want to keep track of where each **Basket** is stored. Apples might
    have a color attribute, and barrels might come in different sizes. Some of these
    properties may also belong to multiple classes (we may want to know when apples
    are picked, too), but for this first example, let''s just add a few different
    attributes to our class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f81faab-3b48-4d5a-bb40-00f63bf6caf8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Depending on how detailed our design needs to be, we can also specify the type
    for each attribute. Attribute types are often primitives that are standard to
    most programming languages, such as integer, floating-point number, string, byte,
    or Boolean. However, they can also represent data structures such as lists, trees,
    or graphs, or most notably, other classes. This is one area where the design stage
    can overlap with the programming stage. The various primitives or objects available
    in one programming language may be different from what is available in another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40213909-0fda-4ae3-8422-94ced58e8911.png)'
  prefs: []
  type: TYPE_IMG
- en: Usually, we don't need to be overly concerned with data types at the design
    stage, as implementation-specific details are chosen during the programming stage.
    Generic names are normally sufficient for design. If our design calls for a list
    container type, Java programmers can choose to use a `LinkedList` or an `ArrayList`
    when implementing it, while Python programmers (that's us!) might choose between
    the `list` built-in and a `tuple`.
  prefs: []
  type: TYPE_NORMAL
- en: In our fruit-farming example so far, our attributes are all basic primitives.
    However, there are some implicit attributes that we can make explicit—the associations.
    For a given orange, we might have an attribute referring to the basket that holds
    that orange.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors are actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what data is, the last undefined term is *behaviors*. Behaviors
    are actions that can occur on an object. The behaviors that can be performed on
    a specific class of object are called **methods**. At the programming level, methods
    are like functions in structured programming, but they *magically* have access
    to all the data associated with this object. Like functions, methods can also
    accept **parameters** and return **values**.
  prefs: []
  type: TYPE_NORMAL
- en: A method's parameters are provided to it as a list of objects that need to be
    **passed** into that method. The actual object instances that are passed into
    a method during a specific invocation are usually referred to as **arguments**.
    These objects are used by the method to perform whatever behavior or task it is
    meant to do. Returned values are the results of that task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve stretched our *comparing apples and oranges* example into a basic (if
    far-fetched) inventory application. Let''s stretch it a little further and see
    whether it breaks. One action that can be associated with oranges is the **pick**
    action. If you think about implementation, **pick** would need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the orange in a basket by updating the **Basket** attribute of the orange
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the orange to the **Orange** list on the given **Basket**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, **pick** needs to know what basket it is dealing with. We do this by giving
    the **pick** method a **Basket** parameter. Since our fruit farmer also sells
    juice, we can add a **squeeze** method to the **Orange** class. When called, the
    **squeeze** method might return the amount of juice retrieved, while also removing
    the **Orange** from the **Basket** it was in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class **Basket** can have a **sell** action. When a basket is sold, our
    inventory system might update some data on as-yet unspecified objects for accounting
    and profit calculations. Alternatively, our basket of oranges might go bad before
    we can sell them, so we add a **discard** method. Let''s add these methods to
    our diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d650e06-f671-4acd-9490-f657598e0c46.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding attributes and methods to individual objects allows us to create a **system**
    of interacting objects. Each object in the system is a member of a certain class.
    These classes specify what types of data the object can hold and what methods
    can be invoked on it. The data in each object can be in a different state from
    other instances of the same class; each object may react to method calls differently
    because of the differences in state.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented analysis and design is all about figuring out what those objects
    are and how they should interact. The next section describes principles that can
    be used to make those interactions as simple and intuitive as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding details and creating the public interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key purpose of modeling an object in object-oriented design is to determine
    what the public **interface** of that object will be. The interface is the collection
    of attributes and methods that other objects can access to interact with that
    object. They do not need, and are often not allowed, to access the internal workings
    of the object.
  prefs: []
  type: TYPE_NORMAL
- en: A common real-world example is the television. Our interface to the television
    is the remote control. Each button on the remote control represents a method that
    can be called on the television object. When we, as the calling object, access
    these methods, we do not know or care if the television is getting its signal
    from a cable connection, a satellite dish, or an internet-enabled device. We don't
    care what electronic signals are being sent to adjust the volume, or whether the
    sound is destined for speakers or headphones. If we open the television to access
    the internal workings, for example, to split the output signal to both external
    speakers and a set of headphones, we will void the warranty.
  prefs: []
  type: TYPE_NORMAL
- en: This process of hiding the implementation of an object is suitably called **information
    hiding**. It is also sometimes referred to as **encapsulation**, but encapsulation
    is actually a more all-encompassing term. Encapsulated data is not necessarily
    hidden. Encapsulation is, literally, creating a capsule (think of creating a time
    capsule). If you put a bunch of information into a time capsule, and lock and
    bury it, it is both encapsulated and the information is hidden. On the other hand,
    if the time capsule, has not been buried and is unlocked or made of clear plastic,
    the items inside it are still encapsulated, but there is no information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between encapsulation and information hiding is largely irrelevant,
    especially at the design level. Many practical references use these terms interchangeably.
    As Python programmers, we don't actually have or need true information hiding
    (we'll discuss the reasons for this in [Chapter 2](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml),
    *Objects in Python*), so the more encompassing definition for encapsulation is
    suitable.
  prefs: []
  type: TYPE_NORMAL
- en: The public interface, however, is very important. It needs to be carefully designed
    as it is difficult to change it in the future. Changing the interface will break
    any client objects that are accessing it. We can change the internals all we like,
    for example, to make it more efficient, or to access data over the network as
    well as locally, and the client objects will still be able to talk to it, unmodified,
    using the public interface. On the other hand, if we alter the interface by changing
    publicly accessed attribute names or the order or types of arguments that a method
    can accept, all client classes will also have to be modified. When designing public
    interfaces, keep it simple. Always design the interface of an object based on
    how easy it is to use, not how hard it is to code (this advice applies to user
    interfaces as well).
  prefs: []
  type: TYPE_NORMAL
- en: Remember, program objects may represent real objects, but that does not make
    them real objects. They are models. One of the greatest gifts of modeling is the
    ability to ignore irrelevant details. The model car I built as a child looked
    like a real 1956 Thunderbird on the outside, but it obviously doesn't run. When
    I was too young to drive, these details were overly complex and irrelevant. The
    model is an **abstraction** of a real concept.
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction** is another object-oriented term related to encapsulation and
    information hiding.  Abstraction means dealing with the level of detail that is
    most appropriate to a given task. It is the process of extracting a public interface
    from the inner details. A car''s driver needs to interact with the steering, accelerator,
    and brakes. The workings of the motor, drive train, and brake subsystem don''t
    matter to the driver. A mechanic, on the other hand, works at a different level
    of abstraction, tuning the engine and bleeding the brakes. Here''s an example
    of two abstraction levels for a car:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f449bcf2-2293-4fc2-8b9d-c9b85968ba0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we have several new terms that refer to similar concepts. Let''s summarize
    all this jargon in a couple of sentences: abstraction is the process of encapsulating
    information with separate public and private interfaces. The private interfaces
    can be subject to information hiding.'
  prefs: []
  type: TYPE_NORMAL
- en: The important lesson to take from all these definitions is to make our models
    understandable to other objects that have to interact with them. This means paying
    careful attention to small details. Ensure methods and properties have sensible
    names. When analyzing a system, objects typically represent nouns in the original
    problem, while methods are normally verbs. Attributes may show up as adjectives
    or more nouns. Name your classes, attributes, and methods accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: When designing the interface, imagine you are the object and that you have a
    very strong preference for privacy. Don't let other objects have access to data
    about you unless you feel it is in your best interest for them to have it. Don't
    give them an interface to force you to perform a specific task unless you are
    certain you want them to be able to do that to you.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned to design systems as a group of interacting objects,
    where each interaction involves viewing objects at an appropriate level of abstraction.
    But we don't know yet how to create these levels of abstraction. There are a variety
    of ways to do this; we'll discuss some advanced design patterns in [Chapter 8](9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml),
    *Strings and Serialization,* and [Chapter 9](0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml),
    *The Iterator Pattern*. But even most design patterns rely on two basic object-oriented
    principles known as **composition** and **inheritance**. Composition is simpler,
    so let's start with it.
  prefs: []
  type: TYPE_NORMAL
- en: Composition is the act of collecting several objects together to create a new
    one. Composition is usually a good choice when one object is part of another object.
    We've already seen a first hint of composition in the mechanic example. A fossil-fueled
    car is composed of an engine, transmission, starter, headlights, and windshield,
    among numerous other parts. The engine, in turn, is composed of pistons, a crank
    shaft, and valves. In this example, composition is a good way to provide levels
    of abstraction. The **Car** object can provide the interface required by a driver,
    while also giving access to its component parts, which offers the deeper level
    of abstraction suitable for a mechanic. Those component parts can, of course,
    be further broken down if the mechanic needs more information to diagnose a problem
    or tune the engine.
  prefs: []
  type: TYPE_NORMAL
- en: A car is a common introductory example of composition, but it's not overly useful
    when it comes to designing computer systems. Physical objects are easy to break
    into component objects. People have been doing this at least since the ancient
    Greeks originally postulated that atoms were the smallest units of matter (they,
    of course, didn't have access to particle accelerators). Computer systems are
    generally less complicated than physical objects, yet identifying the component
    objects in such systems does not happen as naturally.
  prefs: []
  type: TYPE_NORMAL
- en: The objects in an object-oriented system occasionally represent physical objects
    such as people, books, or telephones. More often, however, they represent abstract
    ideas. People have names, books have titles, and telephones are used to make calls.
    Calls, titles, accounts, names, appointments, and payments are not usually considered
    objects in the physical world, but they are all frequently-modeled components
    in computer systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try modeling a more computer-oriented example to see composition in action.
    We'll be looking at the design of a computerized chess game. This was a very popular
    pastime among academics in the 80s and 90s. People were predicting that computers
    would one day be able to defeat a human chess master. When this happened in 1997
    (IBM's Deep Blue defeated world chess champion, Gary Kasparov), interest in the
    problem waned. Nowadays, the computer always wins.
  prefs: []
  type: TYPE_NORMAL
- en: As a basic, high-level analysis, a *game* of chess is **played** between two
    *players*, using a chess set featuring a *board* containing sixty-four *positions*
    in an 8x8 grid. The board can have two sets of sixteen *pieces* that can be **moved**,
    in alternating *turns* by the two players in different ways. Each piece can **take**
    other pieces. The board will be required to **draw** itself on the computer *screen*
    after each turn.
  prefs: []
  type: TYPE_NORMAL
- en: I've identified some of the possible objects in the description using *italics*,
    and a few key methods using **bold**. This is a common first step in turning an
    object-oriented analysis into a design. At this point, to emphasize composition,
    we'll focus on the board, without worrying too much about the players or the different
    types of pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start at the highest level of abstraction possible. We have two players
    interacting with a **Chess Set** by taking turns making moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cce8f943-f61d-4166-85dd-c658cf898b48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This doesn''t quite look like our earlier class diagrams, which is a good thing
    since it isn''t one! This is an **object diagram**, also called an **instance
    diagram**. It describes the system at a specific state in time, and is describing
    specific instances of objects, not the interaction between classes. Remember,
    both players are members of the same class, so the class diagram looks a little
    different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2720c3b-6c13-4357-9e08-17834c0b7429.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram shows that exactly two players can interact with one chess set.
    This also indicates that any one player can be playing with only one **Chess Set**
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: However, we're discussing composition, not UML, so let's think about what the
    **Chess Set** is composed of. We don't care what the player is composed of at
    this time. We can assume that the player has a heart and brain, among other organs,
    but these are irrelevant to our model. Indeed, there is nothing stopping said
    player from being Deep Blue itself, which has neither a heart nor a brain.
  prefs: []
  type: TYPE_NORMAL
- en: The chess set, then, is composed of a board and 32 pieces. The board further
    comprises 64 positions. You could argue that pieces are not part of the chess
    set because you could replace the pieces in a chess set with a different set of
    pieces. While this is unlikely or impossible in a computerized version of chess,
    it introduces us to **aggregation**.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation is almost exactly like composition. The difference is that aggregate
    objects can exist independently. It would be impossible for a position to be associated
    with a different chess board, so we say the board is composed of positions. But
    the pieces, which might exist independently of the chess set, are said to be in
    an aggregate relationship with that set.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to differentiate between aggregation and composition is to think
    about the lifespan of the object. If the composite (outside) object controls when
    the related (inside) objects are created and destroyed, composition is most suitable.
    If the related object is created independently of the composite object, or can
    outlast that object, an aggregate relationship makes more sense. Also, keep in
    mind that composition is aggregation; aggregation is simply a more general form
    of composition. Any composite relationship is also an aggregate relationship,
    but not vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s describe our current **Chess Set** composition and add some attributes
    to the objects to hold the composite relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/929aff43-9cc8-4419-8616-0f36d1a1f2ff.png)'
  prefs: []
  type: TYPE_IMG
- en: The composition relationship is represented in UML as a solid diamond. The hollow
    diamond represents the aggregate relationship. You'll notice that the board and
    pieces are stored as part of the **Chess Set** in exactly the same way a reference
    to them is stored as an attribute on the chess set. This shows that, once again,
    in practice, the distinction between aggregation and composition is often irrelevant
    once you get past the design stage. When implemented, they behave in much the
    same way. However, it can help to differentiate between the two when your team
    is discussing how the different objects interact. Often, you can treat them as
    the same thing, but when you need to distinguish between them (usually when talking
    about how long related objects exist), it's great to know the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed three types of relationships between objects: association, composition,
    and aggregation. However, we have not fully specified our chess set, and these
    tools don''t seem to give us all the power we need. We discussed the possibility
    that a player might be a human or it might be a piece of software featuring artificial
    intelligence. It doesn''t seem right to say that a player is *associated* with
    a human, or that the artificial intelligence implementation is *part of* the player
    object. What we really need is the ability to say that *Deep Blue is a player,*
    or that *Gary Kasparov is a player*.'
  prefs: []
  type: TYPE_NORMAL
- en: The *is a* relationship is formed by **inheritance**. Inheritance is the most
    famous, well-known, and over-used relationship in object-oriented programming.
    Inheritance is sort of like a family tree. My grandfather's last name was Phillips
    and my father inherited that name. I inherited it from him. In object-oriented
    programming, instead of inheriting features and behaviors from a person, one class
    can inherit attributes and methods from another class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are 32 chess pieces in our chess set, but there are only
    six different types of pieces (pawns, rooks, bishops, knights, king, and queen),
    each of which behaves differently when it is moved. All of these classes of piece
    have properties, such as color and the chess set they are part of, but they also
    have unique shapes when drawn on the chess board, and make different moves. Let''s
    see how the six types of pieces can inherit from a **Piece** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb334e90-08f3-4736-940b-ea3a653a4cce.png)'
  prefs: []
  type: TYPE_IMG
- en: The hollow arrows indicate that the individual classes of pieces inherit from
    the **Piece** class. All the child classes automatically have a **chess_set**
    and **color** attribute inherited from the base class. Each piece provides a different
    shape property (to be drawn on the screen when rendering the board), and a different
    **move** method to move the piece to a new position on the board at each turn.
  prefs: []
  type: TYPE_NORMAL
- en: We actually know that all subclasses of the **Piece** class need to have a **move**
    method; otherwise, when the board tries to move the piece, it will get confused.
    It is possible that we would want to create a new version of the game of chess
    that has one additional piece (the wizard). Our current design will allow us to
    design this piece without giving it a **move** method. The board would then choke
    when it asked the piece to move itself.
  prefs: []
  type: TYPE_NORMAL
- en: We can fix this by creating a dummy move method on the **Piece** class. The
    subclasses can then **override** this method with a more specific implementation.
    The default implementation might, for example, pop up an error message that says **That
    piece cannot be moved**.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods in subclasses allows very powerful object-oriented systems
    to be developed. For example, if we wanted to implement a **Player** class with
    artificial intelligence, we might provide a `calculate_move` method that takes
    a **Board** object and decides which piece to move where. A very basic class might
    randomly choose a piece and direction and move it accordingly. We could then override
    this method in a subclass with the Deep Blue implementation. The first class would
    be suitable for play against a raw beginner; the latter would challenge a grand
    master. The important thing is that other methods in the class, such as the ones
    that inform the board as to which move was chosen, need not be changed; this implementation
    can be shared between the two classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of chess pieces, it doesn''t really make sense to provide a default
    implementation of the move method. All we need to do is specify that the move
    method is required in any subclasses. This can be done by making **Piece** an
    **abstract class** with the move method declared **abstract**. Abstract methods
    basically say this:'
  prefs: []
  type: TYPE_NORMAL
- en: We demand this method exist in any non-abstract subclass, but we are declining
    to specify an implementation in this class.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, it is possible to make a class that does not implement any methods at
    all. Such a class would simply tell us what the class should do, but provides
    absolutely no advice on how to do it. In object-oriented parlance, such classes
    are called **interfaces**.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance provides abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore the longest word in object-oriented argot. **Polymorphism** is
    the ability to treat a class differently, depending on which subclass is implemented.
    We've already seen it in action with the pieces system we've described. If we
    took the design a bit further, we'd probably see that the **Board** object can
    accept a move from the player and call the **move** function on the piece. The
    board need not ever know what type of piece it is dealing with. All it has to
    do is call the **move** method, and the proper subclass will take care of moving
    it as a **Knight** or a **Pawn**.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is pretty cool, but it is a word that is rarely used in Python
    programming. Python goes an extra step past allowing a subclass of an object to
    be treated like a parent class. A board implemented in Python could take any object
    that has a **move** method, whether it is a bishop piece, a car, or a duck. When
    **move** is called, the **Bishop** will move diagonally on the board, the car
    will drive someplace, and the duck will swim or fly, depending on its mood.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of polymorphism in Python is typically referred to as **duck typing**:
    *if it walks like a duck or swims like a duck, it''s a duck*. We don''t care if
    it really *is a* duck (*is a* being a cornerstone of inheritance), only that it
    swims or walks. Geese and swans might easily be able to provide the duck-like
    behavior we are looking for. This allows future designers to create new types
    of birds without actually specifying an inheritance hierarchy for aquatic birds.
    It also allows them to create completely different drop-in behaviors that the
    original designers never planned for. For example, future designers might be able
    to make a walking, swimming penguin that works with the same interface without
    ever suggesting that penguins are ducks.'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we think of inheritance in our own family tree, we can see that we inherit
    features from more than just one parent. When strangers tell a proud mother that
    her son has *his father's eyes*, she will typically respond along the lines of,
    *yes, but he got my nose*.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design can also feature such **multiple inheritance**, which
    allows a subclass to inherit functionality from multiple parent classes. In practice,
    multiple inheritance can be a tricky business, and some programming languages
    (most famously, Java) strictly prohibit it. However, multiple inheritance can
    have its uses. Most often, it can be used to create objects that have two distinct
    sets of behaviors. For example, an object designed to connect to a scanner and
    send a fax of the scanned document might be created by inheriting from two separate
    `scanner` and `faxer` objects.
  prefs: []
  type: TYPE_NORMAL
- en: As long as two classes have distinct interfaces, it is not normally harmful
    for a subclass to inherit from both of them. However, it gets messy if we inherit
    from two classes that provide overlapping interfaces. For example, if we have
    a motorcycle class that has a `move` method, and a boat class also featuring a
    `move` method, and we want to merge them into the ultimate amphibious vehicle,
    how does the resulting class know what to do when we call `move`? At the design
    level, this needs to be explained, and, at the implementation level, each programming
    language has different ways of deciding which parent class's method is called,
    or in what order.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the best way to deal with it is to avoid it. If you have a design showing
    up like this, you're *probably* doing it wrong. Take a step back, analyze the
    system again, and see if you can remove the multiple inheritance relationship
    in favor of some other association or composite design.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is a very powerful tool for extending behavior. It is also one of
    the most marketable advancements of object-oriented design over earlier paradigms.
    Therefore, it is often the first tool that object-oriented programmers reach for.
    However, it is important to recognize that owning a hammer does not turn screws
    into nails. Inheritance is the perfect solution for obvious *is a* relationships,
    but it can be abused. Programmers often use inheritance to share code between
    two kinds of objects that are only distantly related, with no *is a* relationship
    in sight. While this is not necessarily a bad design, it is a terrific opportunity
    to ask just why they decided to design it that way, and whether a different relationship
    or design pattern would have been more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's tie all our new object-oriented knowledge together by going through a
    few iterations of object-oriented design on a somewhat real-world example. The
    system we'll be modeling is a library catalog. Libraries have been tracking their
    inventory for centuries, originally using card catalogs, and more recently, electronic
    inventories. Modern libraries have web-based catalogs that we can query from our
    homes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with an analysis. The local librarian has asked us to write a new
    card catalog program because their ancient Windows XP-based program is ugly and
    out of date. That doesn't give us much detail, but before we start asking for
    more information, let's consider what we already know about library catalogs.
  prefs: []
  type: TYPE_NORMAL
- en: Catalogs contain lists of books. People search them to find books on certain
    subjects, with specific titles, or by a particular author. Books can be uniquely
    identified by an **International Standard Book Number** (**ISBN**). Each book
    has a **Dewey Decimal System** (**DDS**) number assigned to help find it on a
    particular shelf.
  prefs: []
  type: TYPE_NORMAL
- en: This simple analysis tells us some of the obvious objects in the system. We
    quickly identify **Book** as the most important object, with several attributes
    already mentioned, such as author, title, subject, ISBN, and DDS number, and catalog
    as a sort of manager for books.
  prefs: []
  type: TYPE_NORMAL
- en: We also notice a few other objects that may or may not need to be modeled in
    the system. For cataloging purposes, all we need to search a book by author is
    an `author_name` attribute on the book. However, authors are also objects, and
    we might want to store some other data about the author. As we ponder this, we
    might remember that some books have multiple authors. Suddenly, the idea of having
    a single `author_name` attribute on objects seems a bit silly. A list of authors
    associated with each book is clearly a better idea.
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between author and book is clearly association, since you would
    never say *a book is an author* (it's not inheritance), and saying *a book has
    an author*, though grammatically correct, does not imply that authors are part
    of books (it's not aggregation). Indeed, any one author may be associated with
    multiple books.
  prefs: []
  type: TYPE_NORMAL
- en: We should also pay attention to the noun (nouns are always good candidates for
    objects) *shelf*. Is a shelf an object that needs to be modeled in a cataloging
    system? How do we identify an individual shelf? What happens if a book is stored
    at the end of one shelf, and later moved to the beginning of the next shelf because
    a new book was inserted in the previous shelf?
  prefs: []
  type: TYPE_NORMAL
- en: DDS was designed to help locate physical books in a library. As such, storing
    a DDS attribute with the book should be enough to locate it, regardless of which
    shelf it is stored on. So we can, at least for the moment, remove shelf from our
    list of contending objects.
  prefs: []
  type: TYPE_NORMAL
- en: Another questionable object in the system is the user. Do we need to know anything
    about a specific user, such as their name, address, or list of overdue books?
    So far, the librarian has told us only that they want a catalog; they said nothing
    about tracking subscriptions or overdue notices. In the back of our minds, we
    also note that authors and users are both specific kinds of people; there might
    be a useful inheritance relationship here in the future.
  prefs: []
  type: TYPE_NORMAL
- en: For cataloging purposes, we decide we don't need to identify the user for now.
    We can assume that a user will be searching the catalog, but we don't have to
    actively model them in the system, beyond providing an interface that allows them
    to search.
  prefs: []
  type: TYPE_NORMAL
- en: We have identified a few attributes on the book, but what properties does a
    catalog have? Does any one library have more than one catalog? Do we need to uniquely
    identify them? Obviously, the catalog has to have a collection of the books it
    contains, somehow, but this list is probably not part of the public interface.
  prefs: []
  type: TYPE_NORMAL
- en: What about behaviors? The catalog clearly needs a search method, possibly separate
    ones for authors, titles, and subjects. Are there any behaviors on books? Would
    it need a preview method? Or could preview be identified by a first page attribute
    instead of a method?
  prefs: []
  type: TYPE_NORMAL
- en: The questions in the preceding discussion are all part of the object-oriented
    analysis phase. But intermixed with the questions, we have already identified
    a few key objects that are part of the design. Indeed, what you have just seen
    are several microiterations between analysis and design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likely, these iterations would all occur in an initial meeting with the librarian.
    Before this meeting, however, we can already sketch out a most basic design for
    the objects we have concretely identified, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b3385dd-f401-4fad-a791-8275a1ef2374.png)'
  prefs: []
  type: TYPE_IMG
- en: Armed with this basic diagram and a pencil to interactively improve it, we meet
    up with the librarian. They tell us that this is a good start, but libraries don't
    serve only books; they also have DVDs, magazines, and CDs, none of which have
    an ISBN or DDS number. All of these types of items can be uniquely identified
    by a UPC number, though. We remind the librarian that they have to find the items
    on the shelf, and these items probably aren't organized by UPC. The librarian
    explains that each type is organized in a different way. The CDs are mostly audio
    books, and they only have two dozen in stock, so they are organized by the author's
    last name. DVDs are divided into genre and further organized by title. Magazines
    are organized by title and then refined by the volume and issue number. Books
    are, as we had guessed, organized by the DDS number.
  prefs: []
  type: TYPE_NORMAL
- en: 'With no previous object-oriented design experience, we might consider adding
    separate lists of DVDs, CDs, magazines, and books to our catalog, and search each
    one in turn. The trouble is, except for certain extended attributes, and identifying
    the physical location of the item, these items all behave much the same. This
    is a job for inheritance! We quickly update our UML diagram as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d524ed1b-5d32-40c0-9920-215c3f12b564.png)'
  prefs: []
  type: TYPE_IMG
- en: The librarian understands the gist of our sketched diagram, but is a bit confused
    by the **locate** functionality. We explain using a specific use case where the
    user is searching for the word *bunnies*. The user first sends a search request
    to the catalog. The catalog queries its internal list of items and finds a book
    and a DVD with *bunnies* in the title. At this point, the catalog doesn't care
    whether it is holding a DVD, book, CD, or magazine; all items are the same, as
    far as the catalog is concerned. However, the user wants to know how to find the
    physical items, so the catalog would be remiss if it simply returned a list of
    titles. So, it calls the **locate** method on the two items it has uncovered.
    The book's **locate** method returns a DDS number that can be used to find the
    shelf holding the book. The DVD is located by returning the genre and title of
    the DVD. The user can then visit the DVD section, find the section containing
    that genre, and find the specific DVD as sorted by the titles.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we explain, we sketch a UML **sequence diagram**, explaining how the various
    objects are communicating:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ce3970b-112a-4f5a-bf58-b6fc76f21b8f.png)'
  prefs: []
  type: TYPE_IMG
- en: While class diagrams describe the relationships between classes, sequence diagrams
    describe specific sequences of messages passed between objects. The dashed line
    hanging from each object is a **lifeline** describing the lifetime of the object.
    The wider boxes on each lifeline represent active processing in that object (where
    there's no box, the object is basically sitting idle, waiting for something to
    happen). The horizontal arrows between the lifelines indicate specific messages.
    The solid arrows represent methods being called, while the dashed arrows with
    solid heads represent the method return values.
  prefs: []
  type: TYPE_NORMAL
- en: The half arrowheads indicate asynchronous messages sent to or from an object.
    An asynchronous message typically means the first object calls a method on the
    second object, which returns immediately. After some processing, the second object
    calls a method on the first object to give it a value. This is in contrast to
    normal method calls, which do the processing in the method, and return a value
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence diagrams, like all UML diagrams, are best used only when they are needed.
    There is no point in drawing a UML diagram for the sake of drawing a diagram.
    However, when you need to communicate a series of interactions between two objects,
    the sequence diagram is a very useful tool.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, our class diagram so far is still a messy design. We notice that
    actors on DVDs and artists on CDs are all types of people, but are being treated
    differently from the book authors. The librarian also reminds us that most of
    their CDs are audio books, which have authors instead of artists.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we deal with different kinds of people that contribute to a title?
    One obvious implementation is to create a `Person` class with the person''s name
    and other relevant details, and then create subclasses of this for the artists,
    authors, and actors. However, is inheritance really necessary here? For searching
    and cataloging purposes, we don''t really care that acting and writing are two
    very different activities. If we were doing an economic simulation, it would make
    sense to give separate actor and author classes, and different `calculate_income`
    and `perform_job` methods, but for cataloging purposes, it is enough to know how
    the person contributed to the item. Having thought this through, we recognize
    that all items have one or more `Contributor` objects, so we move the author relationship
    from the book to its parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96a84929-92b2-4fa6-b610-07fb11c70605.png)'
  prefs: []
  type: TYPE_IMG
- en: The multiplicity of the **Contributor**/**LibraryItem** relationship is **many-to-many**,
    as indicated by the ***** character at both ends of one relationship. Any one
    library item might have more than one contributor (for example, several actors
    and a director on a DVD). And many authors write many books, so they be attached
    to multiple library items.
  prefs: []
  type: TYPE_NORMAL
- en: This little change, while it looks a bit cleaner and simpler, has lost some
    vital information. We can still tell who contributed to a specific library item,
    but we don't know how they contributed. Were they the director or an actor? Did
    they write the audio book, or were they the voice that narrated the book?
  prefs: []
  type: TYPE_NORMAL
- en: It would be nice if we could just add a `contributor_type` attribute on the
    **Contributor** class, but this will fall apart when dealing with multi-talented
    people who have both authored books and directed movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to add attributes to each of our **LibraryItem** subclasses to
    hold the information we need, such as **Author** on **Book**, or **Artist** on
    **CD**, and then make the relationship to those properties all point to the **Contributor**
    class. The problem with this is that we lose a lot of polymorphic elegance. If
    we want to list the contributors to an item, we have to look for specific attributes
    on that item, such as **Authors** or **Actors**. We can solve this by adding a
    **GetContributors** method on the **LibraryItem** class that subclasses can override.
    Then the catalog never has to know what attributes the objects are querying; we''ve
    abstracted the public interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b802a09-3415-425c-8579-7c05b120a6ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Just looking at this class diagram, it feels like we are doing something wrong.
    It is bulky and fragile. It may do everything we need, but it feels like it will
    be hard to maintain or extend. There are too many relationships, and too many
    classes would be affected by modifications to any one class. It looks like spaghetti
    and meatballs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've explored inheritance as an option, and found it wanting, we might
    look back at our previous composition-based diagram, where **Contributor** was
    attached directly to **LibraryItem**. With some thought, we can see that we actually
    only need to add one more relationship to a brand-new class to identify the type
    of contributor. This is an important step in object-oriented design. We are now
    adding a class to the design that is intended to *support* the other objects,
    rather than modeling any part of the initial requirements. We are **refactoring**
    the design to facilitate the objects in the system, rather than objects in real
    life. Refactoring is an essential process in the maintenance of a program or design.
    The goal of refactoring is to improve the design by moving code around, removing
    duplicate code or complex relationships in favor of simpler, more elegant designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This new class is composed of a **Contributor** and an extra attribute identifying
    the type of contribution the person has made to the given **LibraryItem**. There
    can be many such contributions to a particular **LibraryItem**, and one contributor
    can contribute in the same way to different items. The following diagram communicates
    this design very well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98765a8a-a5aa-4952-90e6-36830c80c653.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At first, this composition relationship looks less natural than the inheritance-based
    relationships. However, it has the advantage of allowing us to add new types of
    contributions without adding a new class to the design. Inheritance is most useful
    when the subclasses have some kind of **specialization**. Specialization is creating
    or changing attributes or behaviors on the subclass to make it somehow different
    from the parent class. It seems silly to create a bunch of empty classes solely
    for identifying different types of objects (this attitude is less prevalent among
    Java and other *everything is an object* programmers, but it is common among more
    pragmatic Python designers). If we look at the inheritance version of the diagram,
    we can see a bunch of subclasses that don''t actually do anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7decfd4c-2c35-442e-93c5-6189dec87260.png)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes, it is important to recognize when not to use object-oriented principles.
    This example of when not to use inheritance is a good reminder that objects are
    just tools, and not rules.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a practical book, not a textbook. As such, I'm not assigning a bunch
    of fake object-oriented analysis problems to create designs for you to analyze
    and design. Instead, I want to give you some ideas that you can apply to your
    own projects. If you have previous object-oriented experience, you won't need
    to put much effort into this chapter. However, they are useful mental exercises
    if you've been using Python for a while, but have never really cared about all
    that class stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, think about a recent programming project you''ve completed. Identify
    the most prominent object in the design. Try to think of as many attributes for
    this object as possible. Did it have the following: Color? Weight? Size? Profit?
    Cost? Name? ID number? Price? Style?'
  prefs: []
  type: TYPE_NORMAL
- en: Think about the attribute types. Were they primitives or classes? Were some
    of those attributes actually behaviors in disguise? Sometimes, what looks like
    data is actually calculated from other data on the object, and you can use a method
    to do those calculations. What other methods or behaviors did the object have?
    Which objects called those methods? What kinds of relationships did they have
    with this object?
  prefs: []
  type: TYPE_NORMAL
- en: Now, think about an upcoming project. It doesn't matter what the project is;
    it might be a fun free-time project or a multi-million-dollar contract. It doesn't
    have to be a complete application; it could just be one subsystem. Perform a basic
    object-oriented analysis. Identify the requirements and the interacting objects.
    Sketch out a class diagram featuring the highest level of abstraction on that
    system. Identify the major interacting objects. Identify minor supporting objects.
    Go into detail for the attributes and methods of some of the most interesting
    ones. Take different objects to different levels of abstraction. Look for places
    where you can use inheritance or composition. Look for places where you should
    avoid inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is not to design a system (although you're certainly welcome to do
    so if inclination meets both ambition and available time). The goal is to think
    about object-oriented design. Focusing on projects that you have worked on, or
    are expecting to work on in the future, simply makes it real.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, visit your favorite search engine and look up some tutorials on UML.
    There are dozens, so find one that suits your preferred method of study. Sketch
    some class diagrams or a sequence diagram for the objects you identified earlier.
    Don't get too hung up on memorizing the syntax (after all, if it is important,
    you can always look it up again); just get a feel for the language. Something
    will stay lodged in your brain, and it can make communicating a bit easier if
    you can quickly sketch a diagram for your next OOP discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a whirlwind tour through the terminology of the object-oriented
    paradigm, focusing on object-oriented design. We can separate different objects
    into a taxonomy of different classes and describe the attributes and behaviors
    of those objects via the class interface. Abstraction, encapsulation, and information
    hiding are highly-related concepts. There are many different kinds of relationships
    between objects, including association, composition, and inheritance. UML syntax
    can be useful for fun and communication.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore how to implement classes and methods in Python.
  prefs: []
  type: TYPE_NORMAL
