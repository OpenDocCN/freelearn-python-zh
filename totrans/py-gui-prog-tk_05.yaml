- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reducing User Error with Validation and Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Things are going well for our project: the data entry form works well, the
    code is better organized, and the users are excited at the prospect of using the
    application. We''re not ready for production yet, though! Our form doesn''t yet
    perform the promised task of preventing or discouraging user errors: number boxes
    still allow letters, combo boxes aren''t limited to the choices given, and dates
    are just text fields that have to be filled in by hand. In this chapter, we''re
    going to set things right as we work through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Validating user input*, we'll talk about some strategies for enforcing correct
    values in our widgets and how to implement them in Tkinter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Creating validated widget classes*, we'll super-charge Tkinter's widget
    classes with some custom validation logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Implementing validated widgets in our GUI*, we'll use our new widgets to
    improve ABQ Data Entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Automating input*, we'll implement auto-population of data in our widgets
    to save users time and effort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Validating user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first glance, Tkinter's selection of input widgets seems a little disappointing.
  prefs: []
  type: TYPE_NORMAL
- en: It gives us neither a true number entry that only allows digits, nor a truly
    keyboard-friendly, modern drop-down selector. We have no date inputs, email inputs,
    or other specially formatted input widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, these weaknesses can become strengths. Because these widgets assume
    nothing, we can make them behave in a way that's appropriate to our specific needs.
    For example, alphabetical characters may seem inappropriate in a number entry,
    but are they? In Python, strings such as `NaN` and `Infinity` are valid float
    values; having a box that could increment numerals but also handle those string
    values may be very useful in some applications.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, before we can tailor our widgets to our needs, we'll need to think
    about what exactly we want them to do. Let's do some analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies to prevent data errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is no universal answer to how a widget should react to a user trying
    to enter bad data. The validation logic found in various GUI toolkits can differ
    greatly; when bad data is entered, an input widget might validate the user input
    in any of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Prevent the invalid keystrokes from registering at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept the input, but return an error or list of errors when the form is submitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show an error when the user leaves the entry field, perhaps disabling form submission
    until it's corrected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock the user in the entry field until valid data is entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Silently correct the bad data using a best-guess algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The correct behavior in a data entry form (which is filled out hundreds of times
    a day by the same users, who may not even be looking at it) may be different from
    an instrument control panel (where values absolutely must be correct to avoid
    a disaster) or an online user registration form (which is filled out once by a
    user who has never seen it before). We need to ask ourselves – and our users –
    which behavior will best minimize errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'After discussing this with your users on the data entry staff, you come to
    the following set of guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever possible, meaningless keystrokes should be ignored (for example, letters
    in a number field).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields containing bad data should be marked in some visible way at focus-out
    (when the user exits the field) with an error describing the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A required field left empty at focus-out should be marked with an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form submission should be disabled if there are fields with outstanding errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add the following requirements to our specification before moving on.
    Under the Requirements section, update the `Functional Requirements` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So far so good, but how do we implement this?
  prefs: []
  type: TYPE_NORMAL
- en: Validation in Tkinter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tkinter''s validation system is one of those parts of the toolkit that is less
    than intuitive. It relies on three configuration arguments that we can pass into
    any input widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate`: This option determines which type of event will trigger the validation
    callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validatecommand`: This option takes the command that will determine if the
    data is valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalidcommand`: This option takes a command that will run if `validatecommand`
    returns `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This all seems pretty straightforward, but there are some unexpected curves.
    Let's look in depth at each argument.
  prefs: []
  type: TYPE_NORMAL
- en: The validate argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `validate` argument specifies what kind of event triggers the validation.
    It can be one of the following string values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Trigger event |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | Never. This option turns off validation. |'
  prefs: []
  type: TYPE_TB
- en: '| `focusin` | The user selects or enters the widget. |'
  prefs: []
  type: TYPE_TB
- en: '| `focusout` | The user leaves the widget. |'
  prefs: []
  type: TYPE_TB
- en: '| `focus` | Both `focusin` and `focusout`. |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | The user presses a key while in the widget. |'
  prefs: []
  type: TYPE_TB
- en: '| `all` | Any of the `focusin`, `focusout`, or `key` events. |'
  prefs: []
  type: TYPE_TB
- en: Only one `validate` argument can be specified, and all matching events will
    trigger the same validation callback. Most of the time, you will want to use `key`
    and `focusout` (validating on `focusin` is rarely useful), but since there isn't
    a value that combines those two events, it's often best to use `all` and let the
    callback switch its validation logic based on the event type if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The validatecommand argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `validatecommand` argument specifies the callback function that will be
    run when the `validate` event is triggered. This is where things get a little
    tricky. You might think this argument takes the name of a Python function or method,
    but that's not quite it. Instead, we need to give it a tuple containing a string
    reference to a Tcl/Tk function, and (optionally) some **substitution codes** that
    specify information about the triggering event that we want to pass into the function.
  prefs: []
  type: TYPE_NORMAL
- en: How do we get a reference to a Tcl/Tk function? Fortunately, this isn't too
    hard; we just need to pass a Python callable to the `register()` method of any
    Tkinter widget. This returns string reference that we can use with `validatecommand`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a (somewhat pointless) validation command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've retrieved our function reference by passing the `always_good`
    function to `root.register()`. Then we can pass this reference in a tuple to `validatecommand`.
    The validation callback that we register must return a Boolean value indicating
    whether the data in the field is valid or invalid.
  prefs: []
  type: TYPE_NORMAL
- en: A `validatecommand` callback *must* return a Boolean value. If it returns anything
    else (including the implicit `None` value when there is no `return` statement),
    Tkinter will turn off validation on the widget (that is, it will set `validate`
    to `none`). Remember that its purpose is *only* to indicate whether the data is
    acceptable or not. The handling of invalid data will be done by our `invalidcommand`
    callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, it''s not easy to validate the data unless we provide the function
    with some data to be validated. To make Tkinter pass information to our validation
    callback, we can add one or more substitution codes to our `validatecommand` tuple.
    These codes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Value passed |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | A code indicating the action being attempted: `0` for delete, `1`
    for insert, and `-1` for other events. Note that this is passed as a string, and
    not as an integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `%P` | The proposed value that the field would have after the change (key
    events only). |'
  prefs: []
  type: TYPE_TB
- en: '| `%s` | The value currently in the field (key events only). |'
  prefs: []
  type: TYPE_TB
- en: '| `%i` | The index (from `0`) of the text being inserted or deleted on key
    events, or `-1` on non-key events. Note that this is passed as a string, not an
    integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | For insertion or deletion, the text that is being inserted or deleted
    (key events only). |'
  prefs: []
  type: TYPE_TB
- en: '| `%v` | The widget''s `validate` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `%V` | The event type that triggered validation, one of `focusin`, `focusout`,
    `key`, or `forced` (indicating the widget''s variable was changed). |'
  prefs: []
  type: TYPE_TB
- en: '| `%W` | The widget''s name in Tcl/Tk, as a string. |'
  prefs: []
  type: TYPE_TB
- en: 'We can use these codes to create a slightly more useful validated `Entry`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're passing the `%P` substitution code into our `validatecommand` tuple
    so that our callback function will be passed the proposed new value for the widget
    (that is, the value of the widget if the keystroke is accepted). In this case,
    we're going to return `False` if the proposed value contains the `t` character.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the behavior of the widget when the `validatecommand` callback returns
    changes depending on the type of event that triggered validation. If a validation
    callback is triggered by a `key` event and it returns `False`, Tkinter's built-in
    behavior is to reject the keystroke and leave the contents as they are. In the
    event of a `focus` event triggering validation, a `False` return value will simply
    flag the widget as invalid. In both cases, the `invalidcommand` callback will
    also be executed. If we haven't specified a callback, Tkinter will simply do nothing
    further.
  prefs: []
  type: TYPE_NORMAL
- en: For example, run the above script; you'll find you cannot type a `t` in the
    `Entry` widget. That's because the `key` validation returned `False`, so Tkinter
    rejected the keystroke.
  prefs: []
  type: TYPE_NORMAL
- en: The invalidcommand argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `invalidcommand` argument works exactly the same as the `validatecommand`
    argument, requiring the use of the `register()` method and the same substitution
    codes. It specifies a callback function to be run when `validatecommand` returns
    `False`. It could be used to show an error or possibly correct the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what this looks like together, consider the following code for an `Entry`
    widget that only accepts five characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created a simple GUI with an `Entry` widget and a `Label` widget.
    We've also created two functions, one that returns whether or not the length of
    a string is less than six characters, and another that configures the `Label`
    widget to show an error. We then register the two functions with Tk using the
    `root.register()` method, passing them to the `Entry` widget's `validatecommand`
    and `invalidcommand` arguments. We also include the `%P` substitution code so
    that the proposed value of the widget is passed into each function. Note that
    you can pass in as many substitution codes as you wish, and in any order, as long
    as your callback function is written to accept those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Run this example and test its behavior; note that not only can you *not* type
    more than five characters in the box, but you also receive a warning in the label
    that your attempted edit was too long.
  prefs: []
  type: TYPE_NORMAL
- en: Creating validated widget classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, adding even very simple validation to Tkinter widgets involves
    several steps with some less-than-intuitive logic. Adding validation to even a
    fraction of our widgets could get quite verbose and ugly. However, we learned
    in the previous chapter that we can improve on Tkinter widgets by subclassing
    them to add new configuration and functionality. Let's see if we can apply this
    technique to widget validation by creating validated versions of Tkinter's widget
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s implement our five-character entry again, this time as
    a subclass of `ttk.Entry`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time, we've implemented validation by subclassing `Entry` and defining
    our validation logic in a method rather than an external function. This simplifies
    access to the widget in our validation methods, should we need it, and also allows
    us to refer to the methods in `__init__()` before they are actually defined. We've
    also added a `StringVar` called `error` as an instance variable. We can use this
    variable to hold an error message should our validation fail.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've registered these functions using `self.register()` rather than
    `root.register()`. The `register()` method does not have to be run on the `root`
    window object; it can be run on any Tkinter widget. Since we don't know for sure
    that the code using our class will call the root window `root`, or if it will
    be in scope when the `__init__()` method runs, it makes sense to use the `FiveCharEntry`
    widget itself to register the functions. However, this must be done *after* we
    call `super().__init__()`, since the underlying Tcl/Tk object doesn't actually
    exist (and cannot register functions) until that method is run. That is why we're
    using `configure()` to set these values rather than passing them into `super().__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use this class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve created an instance of the `FiveCharEntry` widget as well as a
    `Label` widget to display errors. Note that we pass the widget''s built-in error
    variable, `entry.error`, to the label''s `textvariable` argument. When you execute
    this, you should see the label displaying an error when you try to type more than
    five characters, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The five-character entry refusing to accept "Banana"](img/B17578_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The five-character entry refusing to accept "Banana"'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Date field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s try something a little more useful now: creating a validating `DateEntry`
    widget to use for our `Date` field. Our widget will prevent any keystrokes that
    aren''t valid for a date string, and check for validity of the date on `focusout`.
    If the date is invalid, we''ll mark the field in some way and set an error message
    in a `StringVar`, which some other widget could use to display the error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new file called `DateEntry.py` and begin with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing `tkinter` and `ttk`, we also import `datetime`, which we''ll
    need for validating the date strings entered. As with our previous class, we''ve
    overridden `__init__()` to set up validation and add an error variable. This time,
    however, we''re going to be passing several more arguments into our `validatecommand`
    method: the character being inserted (`%S`), the index where it''s being inserted
    (`%i`), the event type triggering validation (`%V`), and the action type (`%d`).
    `invalidcommand` is receiving only the event type (`%V`). Since we''re triggering
    validation on all events, we''ll need this value to decide how to handle the invalid
    data appropriately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create a method called `_toggle_error()` to turn an error state
    on or off in the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We'll use this method to handle how our widget behaves when an error occurs
    or is corrected. It starts by setting our error variable to the string provided.
    If the string is not blank, we set a visual error indicator (in this case, turning
    the text red); if it's blank, we turn off the visual indicator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have that, we can create our `_validate()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method will take an "innocent until proven guilty" approach to validating
    the user input, so we begin by toggling off any error state and setting a `valid`
    flag to `True`. Then, we'll start looking at keystroke events. The line `if action
    == '0':` tells us if the user is trying to delete characters. We always want to
    allow this so that the user can edit the field, so that should always return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The basic format of an ISO date is four digits, a dash, two digits, a dash,
    and two digits. We can test whether the user is following this format by checking
    whether the inserted characters match our expectations at the inserted index.
    For example, the line `index in ('0','1', '2', '3', '5', '6', '8', '9')` will
    tell us if the character is being inserted at one of the positions that requires
    a digit, and if so we check that the character is a digit. The characters at indexes
    `4` and `7` should be a dash. Any other keystroke is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Although you might expect them to be integers, Tkinter passes both action codes
    and character indexes as strings. Keep this in mind when writing your comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a hopelessly naive heuristic for a correct date, since it allows
    for complete nonsense dates like `0000-97-46`, or right-looking-but-still-wrong
    dates like `2000-02-29`, it at least enforces the basic format and removes a large
    number of invalid keystrokes. A completely accurate partial date analyzer is a
    project unto itself, but for now, this will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking our date for correctness on focus-out is simpler and much more foolproof,
    as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since we have access to the final value the user meant to enter at this point,
    we can use `datetime.strptime()` to try to convert the string to a Python `datetime`
    object using the format `%Y-%m-%d`. If this fails, we know the date is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end of the method, we return our `valid` flag. As you saw previously,
    it's sufficient to return `False` for keystroke events to prevent the character
    from being inserted; but for errors on focus events, we'll need to respond in
    some user-visible way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be handled in our `_on_invalid()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have configured this method to receive only the event type, which we'll use
    to ignore keystroke events (they're already adequately handled by the default
    behavior). For any other event type, we'll use our `_toggle_error()` method to
    set our visual indicator and the error string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the `DateEntry` class with a small test script at the end of the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and run it to try the new `DateEntry` class. Try entering various
    bad dates or invalid keystrokes, and then click the second `Entry` widget to unfocus
    the `DateEntry` and note what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A validating DateEntry widget warning us about a bad date string.](img/B17578_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: A validating DateEntry widget warning us about a bad date string'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing validated widgets in our GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to validate your widgets, you have your work cut out for
    you! We have 17 input widgets, and you'll have to write validation code like that
    shown in the previous section for all of them to get the behavior we need. Along
    the way, you'll need to make sure the widgets respond consistently to errors and
    present a consistent API to the application.
  prefs: []
  type: TYPE_NORMAL
- en: If that sounds like something you'd like to put off indefinitely, I can't blame
    you. Maybe there's a way we can cut down the amount of repetitive code we need
    to write.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the power of multiple inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have learned that Python allows us to create new classes by subclassing,
    inheriting features from the superclass, and only adding or changing what's different
    about our new class. Python also supports building classes using **multiple inheritance**,
    in which a subclass can inherit from multiple superclasses. We can exploit this
    feature to our advantage by creating what's called a **mixin class**.
  prefs: []
  type: TYPE_NORMAL
- en: Mixin classes contain only a specific set of functionalities that we want to
    be able to "mix in" with other classes to compose a new class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a class called `Fruit` with a `_taste` class attribute
    and a `taste()` method that prints a message indicating how the fruit tastes.
    We then have a mixin class called `PeelableMixin`. The mixin class adds an instance
    attribute called `_peeled` to indicate if the fruit has been peeled, as well as
    a `peel()` method to update the `_peeled` attribute. It also overrides the `taste()`
    method to check if the fruit is peeled before tasting. Note that the mixin class's
    `__init__()` method also calls the superclass initializer, even though it doesn't
    inherit from another class. We'll see why this is in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use multiple inheritance to create a new class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Plantain` class is created from the combination of the `PeelableMixin`
    and the `Fruit` class. When we create a class using multiple inheritance, the
    rightmost class we specify is called the **base class**, and mixin classes should
    be specified before it (that is, to the left of the base class). Thus, `Fruit`
    is the base class in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an instance of our class and call `taste()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the resulting subclass has both a `taste()` and a `peel()` method,
    but note that there are two versions of each method defined between all the classes.
    When we call one of these methods, which version is used?
  prefs: []
  type: TYPE_NORMAL
- en: In a multiple inheritance situation, `super()` does something a little more
    complex than just standing in for the superclass. It looks up the chain of inheritance
    using something called the **method resolution order** (**MRO**) and determines
    the nearest class that defines the method we're calling. The resolution order
    starts with the current class, and then follows the chain of superclasses from
    the leftmost to the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, when we call `plantain.taste()`, a series of method resolutions occurs,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`plantain.taste()` is resolved to `PeelableMixin.taste()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PeelableMixin.taste()` then calls `self.peel()`. Since `self` is a `Plantain`
    object, `self.peel()` is resolved to `Plantain.peel()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plaintain.peel()` prints a message and calls `super().peel()`. Python resolves
    this call to the leftmost class with a `peel()` method, `PeelableMixin.peel()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When that's returned, `PeelableMixin.taste()` then calls `super().taste()`.
    The next leftmost class from `PeelableMixin` is `Fruit`, so this is resolved to
    `Fruit.taste()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fruit.taste()` refers to the class variable `_taste`. Even though the method
    being run is in the `Fruit` class, the class of our object is `Plantain`, so `Plantain._taste`
    is used here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this seems confusing, just remember that `self.method()` or `self.attribute`
    will always look for `method()` or `attribute` in the current class first, and
    then follow the list of inherited classes from left to right until the method
    or attribute is found. The `super()` object will do the same, except that it skips
    the current class.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why we called `super().__init__()` inside the mixin class's
    initializer in the example.
  prefs: []
  type: TYPE_NORMAL
- en: Without this call, only the mixin class initializer would be called. By calling
    `super().__init__()`, Python will also continue up the MRO chain and call the
    base class initializer. This is particularly important to remember when creating
    mixins for Tkinter classes, since the Tkinter class's initializer creates the
    actual Tcl/Tk object.
  prefs: []
  type: TYPE_NORMAL
- en: The method resolution order of a class is stored in its `__mro__` property;
    you can inspect this method in a Python shell or debugger if you're having trouble
    with inherited methods or attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `PeelableMixin` is not usable on its own: it only works when combined
    with a class that has a `taste()` method. This is why it''s a mixin class: it
    is meant to be mixed in to enhance other classes, not used on its own.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Python does not give us a way to explicitly annotate in code
    that a class is a mixin or what classes it must be mixed with, so be sure to document
    your mixin classes well.
  prefs: []
  type: TYPE_NORMAL
- en: Building a validating mixin class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s apply our knowledge of multiple inheritance to build a mixin class that
    will help us create validated widget classes with less boilerplate code. Open
    `data_entry_app.py` and add the new class just above your `Application` class
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've started this class as usual, though we're not subclassing anything this
    time because this is a mixin class. The constructor also has an extra argument
    called `error_var`. This will allow us to pass in a variable to use for the error
    message; if we don't, the class creates its own. Remember that the call to `super().__init__()`
    will ensure that the base class initializer will be executed as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set up validation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we've done before, we're registering instance methods for validation and
    invalid data handling, and then using `configure` to set them up with the widget.
    We'll go ahead and pass in all the substitution codes (except `%w`, the widget
    name, since it's fairly useless inside a class context). We're running validation
    on `all` conditions, so we can capture both `focus` and `key` events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll define our error condition handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will just change the text color to red if there's an error, or black otherwise.
    Unlike our previous validated widget classes, we won't set the error string in
    this function; instead, we'll do that in the validation callback since we'll have
    a better idea of what the error is in that context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our validation callback will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a mixin, our `_validate()` method doesn't actually contain any
    validation logic. Rather, it's going to start by handling a few setup chores,
    like toggling off the error and clearing the error message. It then checks to
    see if the widget is disabled by retrieving the last item in the widget's `state`
    value. If it is disabled, the value of the widget is immaterial, so validation
    should always pass.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the method calls an event-specific callback method, depending on
    the event type passed in. We only care about the `key` and `focusout` events right
    now, so any other event just returns `True`. Those event-specific methods will
    be defined in our subclasses to determine the actual validation logic used.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we call the individual methods using keyword arguments; when we
    create our subclasses, we'll be overriding these methods. By using keyword arguments,
    our overridden functions can just specify the needed keywords or extract individual
    arguments from `**kwargs`, rather than having to get all the arguments in the
    right order. Also, notice that all the arguments are passed into `_key_validate()`,
    but only `event` is passed into `_focusout_validate()`. Focus events don't pass
    anything useful for any of the other arguments, so there's no point in passing
    them along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll put in placeholders for the event-specific validation methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The ultimate idea here is that our subclasses only need to override one or both
    of `_focusout_validate()` or `_key_validate()`, depending on what we care about
    for that widget. If we don't override them, they just return `True`, so validation
    passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s do something similar for our invalid input handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We take an identical approach to these methods. Unlike the validate methods,
    though, our invalid data handlers don't need to return anything. For invalid `key`
    events, we do nothing by default, and for invalid input on `focusout` events,
    we toggle on our error status.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we want to add is a way to manually execute validation on the
    widget. Keystroke validation only really makes sense in the context of entering
    keys, but there may be times when we want to manually run the focus-out checks
    since they effectively check the complete entered value. Let''s implement that
    with the following public method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we''re just duplicating the logic that occurs when a focus-out
    event happens: run the validation function, and if it fails, run the invalid handler.
    This completes the `ValidatedMixin`. Now let''s see how it works by applying it
    to some of our widgets.'
  prefs: []
  type: TYPE_NORMAL
- en: Building validating input widgets with ValidatedMixin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, let''s think through what classes we need to implement with our new
    `ValidatedMixin` class:'
  prefs: []
  type: TYPE_NORMAL
- en: All our fields except the Notes field are required (when not disabled), so we'll
    need a basic `Entry` widget that registers an error if there's no input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have one Date field, so we need an `Entry` widget that enforces a valid date
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a number of `Spinbox` widgets for decimal or integer input. We'll need
    to make sure these only accept valid number strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a few `Combobox` widgets that don't behave quite the way we want them
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Requiring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start with a basic `Entry` widget that requires data. We can use these
    for the Technician and Seed Sample fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class just after the `ValidatedMixin` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There's no keystroke validation to do here, so we just need to create `_focusout_validate()`.
    All we need to do in that method is check whether the entered value is empty.
    If so, we just set an `error` string and return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: That's all there is to it!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Date widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let''s apply the mixin class to the `DateEntry` class we made before,
    keeping the same validation algorithm. Add the following code just under the `RequiredEntry`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we've once again simply overridden the `key` and `focus` validation
    methods, this time copying in the validation logic we used in our `DateEntry`
    widget from the previous section. The `_focusout_validate()` method also includes
    the logic from our `RequiredEntry` class too, since the `Date` value is required.
  prefs: []
  type: TYPE_NORMAL
- en: Those classes were both pretty easy to create; let's move on to something a
    bit more intricate.
  prefs: []
  type: TYPE_NORMAL
- en: A better Combobox widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The drop-down widgets in different toolkits or widget sets behave fairly consistently
    when it comes to mouse operation, but the response to keystrokes varies; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Some do nothing, such as the Tkinter `OptionMenu`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some require the use of arrow keys to select items, such as the Tkinter `ListBox`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some move to the first entry that begins with any key pressed and cycle through
    entries beginning with that letter on subsequent presses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some narrow down the list to entries that match what's typed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to think about what behavior our `Combobox` widget should have. Since
    our users are accustomed to doing data entry with the keyboard, and some have
    difficulty with the mouse, the widget needs to work well with the keyboard. Making
    them use repeated keystrokes to select options is not very intuitive, either.
    After talking with the data entry staff, you decide on this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: If the proposed text matches no entries, the keystroke will be ignored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the proposed text matches a single entry, the widget is set to that value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A delete or backspace clears the entire box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see if we can implement this with validation. Add another class after
    the `DateEntry` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `_key_validate()` method starts out by setting up a valid flag and doing
    a quick check to see if this is a delete action. If it is, we set the value to
    a blank string and return `True`. That takes care of the last requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll add the logic to match the proposed text to our values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A copy of the widget's list of values is retrieved using its `cget()` method.
    Then, we use a list comprehension to reduce this list to only the entries that
    begin with the proposed text. To make matching case-insensitive, we're calling
    `lower()` on both the values in the list item and the proposed text before comparing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Every Tkinter widget supports the `cget()` method. It can be used to retrieve
    any of the widget's configuration values by name.
  prefs: []
  type: TYPE_NORMAL
- en: If the length of the matching list is `0`, nothing starts with the typed value
    and we reject the keystroke. If it's `1`, we've found our match, so we'll set
    the variable to that value. This is done by calling the widget's `set()` method
    and passing in the matching value. As a final touch, we'll send the cursor to
    the end of the field using the combo box's `.icursor()`. This isn't strictly necessary,
    but it looks better than leaving the cursor in the middle of the text. Note that
    we set `valid` to `False` even though the value matched successfully; since we
    are setting the value ourselves to the matching item, we want to stop any further
    input to the widget. Otherwise, the proposed keystroke would be appended to the
    end of the value we set, creating an invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that if our matching list contains more than one value, the method
    will just return `True`, allowing the user to continue typing and filtering the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add the `focusout` validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We don't have to do much here, because the key validation method ensures that
    the only possible values are a blank field or an item from the `values` list,
    but since all fields require a value, we'll copy in the validation logic from
    `RequiredEntry`.
  prefs: []
  type: TYPE_NORMAL
- en: That takes care of our `Combobox` widget. Next, we'll deal with the `Spinbox`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: A range-limited Spinbox widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A number entry seems like it shouldn't be too complicated to deal with, but
    there are several subtleties to work through to make it bulletproof. In addition
    to limiting the field to valid number strings, you'll want to enforce the `from_`,
    `to`, and `increment` arguments as the minimum, maximum, and precision of the
    input, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm needs to implement the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Deletion is always allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digits are always allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `from_` is less than 0, a minus is allowed as the first character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `increment` has a decimal component, one (and only one) dot is allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the proposed value is greater than the `to` value, ignore the keystroke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the proposed value requires more precision than `increment`, ignore the keystroke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On `focusout`, make sure the value is a valid number string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also on `focusout`, make sure the value is greater than the `from_` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a lot of rules, so let''s proceed slowly as we try to implement them.
    The first thing we''ll want to do is import the `Decimal` class from the standard
    library. At the top of the file, add the following to the end of the import list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `Decimal` class helps our decimal values be a bit more precise than the
    built-in `float` class, and also makes converting between numbers and strings
    a bit easier. `InvalidOperation` is a decimal-specific exception we can use in
    our validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a new `ValidatedSpinbox` class under the `ValidatedCombobox`
    class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by overriding the `__init__()` method so that we can specify some
    defaults and grab the `from_`, `to`, and `increment` values from the initializer
    arguments for use in establishing our validation rules. Note that we have set
    defaults for `to` and `from_`: `-Infinity` and `Infinity`. Both `float` and `Decimal`
    will happily accept these values and treat them as you''d expect them to do. Recall
    that if we specify one limit, we must also specify the other. Adding these defaults
    allows us to only specify the one we need, and our `Spinbox` will act as we expect
    it to.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have run the superclass's initializer method, we're going to figure
    out the precision value; that is, the number of digits we want to the right of
    the decimal.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we're first going to retrieve the `increment` value from the keyword
    arguments, using `1.0` if it's not specified. We then convert this value to a
    `Decimal` object. Why do this? The `Spinbox` widget's arguments can be passed
    in as floats, integers, or strings. Regardless of how you pass them in, Tkinter
    converts them to floats when the `Spinbox` initializer is run. Determining the
    precision of a float is problematic because of floating-point error, so we want
    to convert it to a Python `Decimal` before it becomes a float.
  prefs: []
  type: TYPE_NORMAL
- en: What is a floating-point error? Floats attempt to represent decimal numbers
    in binary form. Open a Python shell and enter `1.2 / 0.2`. You might be surprised
    to find the answer is `5.999999999999999` rather than `6`. This is a result of
    calculations being done on binary numbers rather than decimal numbers, and it's
    a source of computation error in nearly every programming language. Python offers
    us the `Decimal` class, which takes a numeric string and stores it in a way that
    makes mathematical operations safe from floating-point errors.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we cast `increment` to `str` before passing it to `Decimal`. Ideally,
    we should pass `increment` to our widget as a string to ensure it will be interpreted
    correctly, but if we need to pass in a float for some reason, `str` will do some
    sensible rounding first.
  prefs: []
  type: TYPE_NORMAL
- en: Having converted `increment` to a `Decimal` object, we can extract its precision
    value by taking the exponent of the smallest valid decimal place. We'll use this
    value in the validation method to make sure our entered data doesn't have too
    many decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: Our constructor is now settled, so let's write the validation methods. The `_key_validate()`
    method is a bit tricky, so we'll walk through it chunk by chunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, because deletion should always work, we'll return `True` immediately
    if the action is a deletion. After that, we retrieve the `from_` and `to` values
    using `cget()` and declare some flag variables to indicate if negatives and decimals
    should be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to test if the proposed keystroke is a valid character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Valid characters are digits, the `-` symbol, and the decimal (`.`). The minus
    sign is only valid at index `0`, and only when negative numbers are allowed. The
    decimal can only appear once, and only if our precision is less than `1`. We've
    put all these conditions in a list and passed it to the built-in `any()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `any()` function takes a list of expressions and returns `True`
    if any one of the expressions in the list is true. There's also an `all()` function
    that returns `True` only if every expression in the list is true. These functions
    allow you to condense a long chain of Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost guaranteed at this point to have a valid `Decimal` string, but
    not quite; we might have just the `-`, `.`, or `-.` characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those are not valid `Decimal` strings, but they are valid *partial* entries,
    so we should allow them. This code will check for those combinations and allow
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have not yet returned at this point, the proposed text can only be a
    valid `Decimal` string, so we''ll make a `Decimal` from it and do some final tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Our last two tests check to see whether the proposed text is either greater
    than our maximum value or has more precision than the increment that we specified
    (the reason we use a `<` operator here is because precision is given as a negative
    value for decimal places). Finally, in case nothing has been returned yet, we
    return the `valid` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes care of key validation; our focus-out validator is much simpler,
    as you can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With the entire intended value at our disposal, we only need to make sure it's
    a valid `Decimal` string and within the specified value range. In theory, our
    key validation should have prevented an invalid decimal string or high value from
    being entered, but it doesn't hurt to check regardless.
  prefs: []
  type: TYPE_NORMAL
- en: With that method completed, our `ValidatedSpinbox` is ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Radiobutton widgets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Validating `Radiobutton` widgets may seem initially pointless since the widget
    itself can only be on or off; however, validating a *group* of buttons can be
    quite useful in some situations. For example, in our ABQ data form, the Lab field
    is required to have a value, but currently the user can submit a record without
    clicking on one of the options.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we're going to create a new class that will represent a group of
    buttons and add validation code to this compound widget.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, our mixin class cannot help us here as neither our compound widget
    nor Ttk `Radiobutton` widgets can support the `validate`, `validatecommand`, or
    `invalidcommand` arguments. Therefore, we'll have to implement validation of the
    button group without help from Tkinter's validation system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we''ll subclass `ttk.Frame` to build the compound widget on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The initializer for this class takes a number of keyword values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`variable` will be the control variable for the group''s value. If not passed
    in, it will be created by the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error_var` is a control variable for the error string. Just as with our other
    validated classes, we have allowed the possibility of accepting a `StringVar`
    control variable to hold the error string, or we just create one if one wasn''t
    passed in, saving it as `self.error`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values` will be a list containing the string values that each button in the
    group represents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`button_args` will be a dictionary of keyword arguments that we can pass to
    the individual `Radiobutton` widgets. This will allow us to pass arguments to
    the buttons separately from the `Frame` container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The remaining positional and keyword arguments are passed to the superclass
    initializer. After saving the keyword values to instance variables, we''ll next
    create the buttons like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did in the `LabelInput` initializer, we are iterating through the
    `values` list, creating a `Radiobutton` widget for each value, and binding it
    to the common control variable. Each one is packed onto the `Frame` from the left
    side of the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the initializer, we need to trigger a validation callback whenever
    the `Frame` widget loses focus. To do that, we can just use `bind()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever the widget loses focus, the validation callback will be called.
    Let''s write that callback next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This method will begin by setting the error variable to an empty string and
    then simply check if our bound variable contains a value. If it's empty, the error
    string is populated.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can use this compound widget with our application, we'll need to make
    one minor change to the `LabelInput` class. Remember that `LabelInput` makes sure
    that the correct control variable keyword argument gets passed into the widget
    initializer. We need to make sure our new compound widget class is getting the
    correct keyword (`variable`, in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `LabelInput` initializer like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With that, the `ValidatedRadio` widget should be ready to use!
  prefs: []
  type: TYPE_NORMAL
- en: Updating our form with validated widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our widgets are all made, it''s time to make use of them in our form
    GUI. In `data_entry_app.py`, scroll down to the `DataRecordForm` class''s `__init__()`
    method, and we''ll start updating our widgets one row at a time. Line 1 is fairly
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It's as simple as swapping out the `input_class` value in each `LabelInput`
    call with one of our new classes. Go ahead and run your application and try out
    the widgets. Try some different valid and invalid dates in the `DateEntry`, and
    see how the `ValidatedCombobox` widget works (`RequiredEntry` won't do much at
    this point since the only visible indication is red text, and there's no text
    to mark red if it's empty; we'll address that in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s work on line 2, which includes the Lab, Plot, and Seed Sample inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: An astute reader might note that this shouldn't work, since our list of values
    contains integers, and the `ValidatedCombobox` widget's validation callback assumes
    the values are strings (for example, we run `lower()` on each item in the list,
    and compare the item to the proposed string). It turns out that Tkinter converts
    the items in the value list to strings implicitly as it converts the call to Tcl/Tk.
    This is good to be aware of as you're writing validation methods on fields containing
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Let''s move on now to the Environmental Data. We only need to update
    the number entries to `ValidatedSpinbox` widgets here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Save and execute the script at this point and give the `ValidatedSpinbox` widget
    a try. You should find it impossible to enter values greater than the maximum
    or with more than two decimal places, and should also find the text turns red
    if you leave it less than the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll update the first row of Plant Data with more `ValidatedSpinbox`
    widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Save and run the form again; you should find that these widgets will not allow
    you to type a decimal place, since the increment is at the default (`1.0`).
  prefs: []
  type: TYPE_NORMAL
- en: All that remains is our last row of number inputs. Before we do those, however,
    let's address some issues of form widget interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing validation interaction between form widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we''ve used validation to create widgets that can validate based on
    the user''s input to that widget. However, sometimes widgets might need to validate
    based on the state of another widget on the form. We have two such examples on
    our form:'
  prefs: []
  type: TYPE_NORMAL
- en: Our Height fields (Min Height, Med Height, and Max Height) should not allow
    a user to enter a Min Height that is greater than the other two fields, a Max
    Height that is less than the other two fields, nor a Med Height that is not between
    the other fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our Equipment Fault checkbox should disable entry of Environmental Data, since
    we do not want to record data suspected of being faulty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically updating the Spinbox range
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To solve the problem with our Height fields, we're going to update our `ValidatedSpinbox`
    widget so that its ranges can be dynamically updated. To do this, we can use the
    variable tracing feature we learned about in *Chapter 4*, *Organizing Our Code
    with Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Our strategy will be to allow optional `min_var` and `max_var` arguments to
    be passed into the `ValidatedSpinbox` class, and then set a trace on these variables
    to update the `ValidatedSpinbox` object's minimum or maximum values whenever the
    corresponding variable is changed. We'll also have a `focus_update_var` variable
    that will be updated with the `Spinbox` widget's value at focus-out time. This
    variable can then be passed in as the `min_var` or `max_var` variable to a second
    `ValidatedSpinbox` so that the first widget's value can alter the second's valid
    range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make these changes to our `ValidatedSpinbox`. To start, update the `ValidatedSpinbox.__init__()`
    method with our new keyword arguments as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of our code for this feature is going to require that the `Spinbox` has
    a variable bound to it, so the next thing we''re going to do is make sure that
    happens; put this code at the end of `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We start by retrieving the `textvariable` from the keyword arguments; if it's
    not set to anything, we'll just create a `DoubleVar` and make it our variable.
    We're storing a reference to the variable so we can use it easily in our instance
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this arrangement could cause problems if a variable is assigned later
    using `configure()`. This won't be a problem in our code, but if you're using
    this class in your own Tkinter programs, you may want to override `configure()`
    to make sure the variable reference is kept in sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, still in `__init__()`, let''s set up our minimum and maximum variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we pass in either a `min_var` or `max_var` argument, the value is stored
    and a trace is configured. The callback for the trace points to an appropriately
    named private method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need to store a reference to the `focus_update_var` argument and
    bind focus-out events to a method that will be used to update it. To do that,
    add the following code to `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `bind()` method can be called on any Tkinter widget, and it's used to connect
    widget events to a Python callable. Events can be keystrokes, mouse movements
    or clicks, focus events, window management events, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add the callback methods for our `trace()` and `bind()` commands.
    We''ll start with the one that updates the `focus_update_var`, which we''ll call
    `_set_focus_update_var()`. Add it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This method simply gets the widget's current value and, if there is a `focus_update_var`
    argument present in the instance, sets it to the same value. Note that we don't
    set the value if there's an error currently present on the widget, since it wouldn't
    make sense to update the value to something invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that the method takes an `event` argument. We don't use this argument,
    but it is necessary since this is a callback for a bind. When Tkinter calls a
    bind callback, it passes in an event object that contains information about the
    event that triggered the callback. Even if you aren't going to use this information,
    your function or method needs to be able to take this argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the callback for setting the minimum, starting with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first thing this method does is retrieve the current value of the widget
    using `self.get()`. The reason we're doing this is because the `Spinbox` widget
    has the slightly annoying default behavior of correcting its value when the `to`
    or `from_` values are changed, moving too-low values to the `from_` value and
    too-high values to the `to` value. This kind of silent auto-correction might slip
    past the attention of our user and cause bad data to be saved.
  prefs: []
  type: TYPE_NORMAL
- en: What we would prefer is to leave the out-of-range value as-is and mark it as
    an error; so to work around the `Spinbox` widget, we're going to save the current
    value, change the configuration, and then put the original value back in the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'After storing the current value in `current`, we attempt to get the value of
    the `min_var` and set our widget''s `from_` value from it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: There are several things that could go wrong here, such as a blank or invalid
    value in `min_var`, all of which should raise either a `tk.TclError` or a `ValueError`.
    In any case, we'll just do nothing, leaving the current minimum in place.
  prefs: []
  type: TYPE_NORMAL
- en: It's generally a bad idea to just silence exceptions; however, in this case,
    there's nothing we can reasonably do if the variable is bad except ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to write the `current` value that we saved back into the
    field, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If `current` is empty, we just delete the contents of the field; otherwise,
    we set the input's variable to `current`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll want to trigger the widget''s focus-out validation to see if
    the current value is acceptable in the new range; we can do that by calling our
    `trigger_focusout_validation()` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_set_maximum()` method will be identical to this method, except that it
    will update the `to` value using `max_var` instead. It is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: That finishes our `ValidatedSpinbox` changes. Now we can implement the last
    line of our Plant Data with this new capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to set up variables to store the minimum and maximum height,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Each variable is a `DoubleVar`, set to `-infinity` or `infinity`, effectively
    defaulting to no minimum or maximum. Our widgets won't be affected by the values
    of these variables until they're actually changed (triggering the trace callback),
    so they won't initially override the `to` or `from_` values entered into the widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these need not be instance variables, as our widgets will store references
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll create the Min Height widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We'll use `max_height_var` to update the maximum here, and set the `focus_update_var`
    to `min_height_var` so that entry into the Min Height widget will update the minimum
    height variable. We do not want to set a `min_var` on this field because its value
    represents the minimum for other fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s update the Max Height widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This time, we use our `min_height_var` variable to set the widget's minimum
    value and set the `max_height_var` to be updated with the widget's current value
    on focus-out. We do not set a `max_var` on this field since its value will represent
    the maximum and shouldn't be constrained beyond its initial limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the Median Height field should be updated like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're setting the minimum and maximum values for the field from the `min_height_var`
    and `max_height_var` variables, respectively. We're not updating any variables
    from the Median Height field, although we could add additional variables and code
    here to make sure that Min Height couldn't go above it or Max Height below it.
    In most cases, it won't matter as long as the user is entering data in order since
    Median Height is last.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder why we don''t just use the bound variables from Min Height
    and Max Height to hold these values instead. If you try this, you''ll discover
    the reason: the bound variable updates as you type, which means your partial value
    instantly becomes the new maximum or minimum value. We''d rather wait until the
    user has committed to the value to update the ranges, and thus we created a separate
    variable that is only updated on focus-out.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic disabling of fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To implement the disabling of our Environment Data fields when the EquipmentFault
    checkbox is activated, we'll once again use control variable tracing. This time,
    however, instead of implementing it at the widget class level, we'll implement
    it in our compound widget, the `LabelInput`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the `LabelInput` class in your code, and let''s add a new keyword argument
    to its `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `disable_var` argument will allow us to pass in a Boolean control variable
    that will be monitored to determine if our field should be disabled. To make use
    of it, we''ll need to store it in the `LabelInput` instance and configure a trace.
    Add this code to the end of `LabelInput.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The trace is linked to an instance method called `_check_disable()`. This method
    will need to check the value of `disable_var` and take appropriate action with
    the `LabelInput` widget's input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the method in our `LabelInput` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: First, our method uses `hasattr` to see if this `LabelInput` even has a `disable_var`.
    In theory, the method shouldn't even get called if it doesn't, since there would
    be no trace, but just to be sure, we'll check and simply return if the instance
    variable doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a `disable_var`, we'll check its value to see if it's `True`. If
    it is, we disable the input widget. To disable an input widget, we need to configure
    its `state` property. The `state` property determines the current disposition
    of the widget. In this case, we want to disable it, so we can set `state` to the
    `tk.DISABLED` constant. That will have the effect of "graying out" our field and
    making it read-only. We also want to clear out any information in the disabled
    fields, to make sure the user understands no data will be recorded for these fields.
    So, we'll set the variable to an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: If the `disable_var` is false, we need to re-enable the widget. To do that,
    we can just set its state to `tk.NORMAL`.
  prefs: []
  type: TYPE_NORMAL
- en: The `state` property will be covered in more detail in *Chapter 9*, *Improving
    the Look with Styles and Themes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that method written, we just need to update our Environmental Data fields
    with a `disable_var` variable. Scroll back to your `DataRecordForm.__init__()`
    method and find where we''ve created those fields. We''ll update them like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In each case, we've added the `disable_var` argument and set it to `self._vars['Equipment
    Fault']`. If you run the script now, you should find that checking the Equipment
    Fault box disables and clears these three fields, and unchecking it re-enables
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Our form is now much better at enforcing correct data and catching potential
    errors during data entry, but it's not quite user-friendly yet. Let's see what
    can be done about that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you run the application, you may notice that while fields with the focus-out
    errors turn red, we don't get to see the actual error. This is a bit of a problem
    for user-friendliness, so let's see if we can fix it. Our plan will be to update
    the `LabelInput` compound widget with another `Label` that can display an error
    string in the event of an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, first locate your `LabelInput` class. Add this code to the
    end of the `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here, we check to see if our input has an error variable, and if not, we create
    one. Our validated widgets should already have such a variable, but unvalidated
    widgets such as the `BoundText` widget used for the `Notes` field do not, so we
    need this check to make sure.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're creating and placing a `Label` widget and binding the error variable
    to its `textvariable` argument. This will update the `Label` contents with whatever
    our widget's `error` variable contains as it is updated by the validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: Save the application, run it, and try entering some bad data in the fields (for
    example, a low value in one of the `Spinbox` widgets). You should see an error
    pop up under the field when you focus the next field. Success!
  prefs: []
  type: TYPE_NORMAL
- en: There is one small issue to fix, though. If you happen to be focused on an Environment
    Data field like Humidity when you click the Equipment Fault checkbox, an error
    will be left under the field. The reason is that clicking the checkbox causes
    the field to lose focus, triggering its validation. Meanwhile, the `_check_disable()`
    method sets its value to an invalid blank string, which the validation logic rejects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is for us to clear the error string when we disable the field.
    In the `LabelInput._check_disable()` method, update the code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Run the application again and you should see the errors disappear when the checkbox
    is checked.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing form submission on error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final step in preventing errors from getting into our CSV file is to stop
    the application from saving the record if the form has known errors.
  prefs: []
  type: TYPE_NORMAL
- en: Record saving happens in our `Application` object, so we need a way for that
    object to determine the error state of the form before it saves the data. That
    means our `DataRecordForm` will need a public method. We'll call that method `get_errors()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `DataRecordForm` class, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin by defining an empty `dict` object to store the errors. We''ll store
    our errors in the dictionary as `field: error_string` so that the calling code
    can be specific about the fields that have errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that our `LabelInput` class attaches a reference to itself to the control
    variable passed into its `__init__()` method. We can use this reference now as
    we loop through our dictionary of variables. For each variable, we''ve done the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve its input widget and the associated `error` variable from the `LabelWidget`
    reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input defines a `trigger_focusout_validation()` method, we call it, just
    to be sure that its value has been validated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is invalid, that should populate the error variable; so, if `error`
    is not empty, we add it to the `errors` dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we've gone through all the fields, we can return the `errors` dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have a way to retrieve the form''s errors, we need to utilize it
    in the `Application` class''s `on_save()` method. Locate that method, and then
    add the following code to the beginning of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Recall that our `Application` object stores a reference to the form in `self.recordform`.
    We can now retrieve its dictionary of errors by calling its `get_errors()` method.
    If the dictionary is not empty, we'll construct an error string by joining all
    its keys (that is, the field names) and appending them to an error message. This
    is then passed to the `status` control variable, causing it to be displayed in
    the status bar. Finally, we return from the method so that the remaining logic
    in `on_save()` is not executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the application and try it out by trying to save a blank form. You should
    get error messages in all fields and a message at the bottom telling you which
    fields have errors, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The application with all errors showing.](img/B17578_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: The application with all errors showing'
  prefs: []
  type: TYPE_NORMAL
- en: Automating input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preventing users from entering bad data is one way to improve the quality of
    their output; another approach is to automate the entry of data wherever the values
    are predictable. Using our understanding of how the forms are likely to be filled
    out, we can insert values that are very likely to be correct for certain fields.
  prefs: []
  type: TYPE_NORMAL
- en: Remember from *Chapter 2*, *Designing GUI Applications*, that the forms are
    nearly always recorded the same day that they're filled out, starting with Plot
    1 and going to Plot 20 in order for each paper form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also remember that the Date, Time, Lab, and Technician values remain the same
    for each form that is filled in. That gives us the possibility of implementing
    some helpful automation, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: The current date can automatically be inserted in the Date field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the previous Plot was not the last plot in the lab, we can increment its
    value and leave the Time, Technician, and Lab values the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how we can implement these changes for the users.
  prefs: []
  type: TYPE_NORMAL
- en: Date automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inserting the current date is an easy place to start. The place to do this is
    in the `DataRecordForm.reset()` method, which is called when the form is initialized
    and every time a record is saved to set up the form for a new record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update that method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: After clearing the values of all the variables, we're going to get the current
    date in ISO format using `datetime.today().strftime()`, just as we do for the
    datestamp in `Application.on_save()`. Once we have that value, it's simply a matter
    of setting the `Date` variable to it.
  prefs: []
  type: TYPE_NORMAL
- en: As a final touch, we should update the focus of the form to the next input that
    needs entry, in this case, the Time field. Otherwise, the user would have to manually
    tab through the Date field, which is already filled in. To do this, we have accessed
    the input widget associated with the `Time` variable by way of its `label_widget`
    member and called the widget's `focus()` method. This method gives the widget
    keyboard focus.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Plot, Lab, Time, and Technician
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Handling Plot, Lab, Time, and Technician is a bit more complex. Our strategy
    will go something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Before clearing the data, store the Plot, Lab, Time, and Technician values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear all the values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the stored Plot value is less than the last value (20), we'll put the Lab,
    Time, and Technician values back in the fields. We'll also increment the Plot
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the stored Plot value *is* the last value (or no value), leave those fields
    blank.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin to add this logic to the `reset()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Before anything else in `reset()`, we're going to get the values of the affected
    fields and save them. Note that we have put `plot` in a `try/except` block. In
    the event that the Plot input is blank, it will throw a `TclError`, since a blank
    string is an invalid integer string. In that case, we'll assign the plot to be
    a blank string and carry on.
  prefs: []
  type: TYPE_NORMAL
- en: We're also retrieving the list of possible plot values by accessing the Plot
    widget by way of the Plot variable's `label_widget` member. Since we know there
    are 20 plots in each lab, we could just hardcode a list of 1 to 20 here, but that
    kind of hardcoding of information is bad form; if plots are added or eliminated
    from the lab, we would have to scour our code for the number 20 to fix all the
    places where we'd made this assumption. It's far better to query the widget itself
    to find out its possible values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, at the end of this method (after clearing the fields and setting the
    date), let''s add this code to update the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This code checks to see if the plot value is a blank string, `0`, or the last
    value in the list of plot values. If it's not, we start populating the automated
    fields. First Lab, Time, and Technician are populated with our stored values.
    Then we need to increment the Plot value.
  prefs: []
  type: TYPE_NORMAL
- en: Plot *should* be an integer at this point, but because of Tkinter's habit of
    implicitly casting things to string, it's better to work with it as though it
    were not. So, instead of merely incrementing the value of Plot, we're instead
    going to retrieve its index from `plot_values` and increment that instead. Then
    we can set the value of the Plot variable to the incremented index.
  prefs: []
  type: TYPE_NORMAL
- en: As a final touch, we will set the focus of the form to the Seed Sample input,
    just as we did previously with the Time input.
  prefs: []
  type: TYPE_NORMAL
- en: Our validation and automation code is complete, and the form is now ready for
    a trial run with our users. It's definitely an improvement over the CSV entry
    at this point and will help data entry to make quick work of those forms. Great
    work!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application has really come a long way. In this chapter, we learned about
    Tkinter validation, created a validation mixin class, and used it to create validated
    versions of the `Entry`, `Combobox`, and `Spinbox` widgets. We also learned how
    to validate widgets like `Radiobutton`, which don't support the built-in validation
    framework. We validated different kinds of data on keystrokes and focus events,
    and created fields that dynamically change state or update their constraints based
    on the values of related fields. Finally, we automated input on several fields
    to reduce the amount of manual data entry required by the user.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to prepare our code base for expansion by learning
    how to organize a large application for easier maintenance. More specifically,
    we'll learn about the MVC pattern and how to structure our code in multiple files
    for simpler maintenance. We'll also learn about version control software and how
    it can help us keep track of changes.
  prefs: []
  type: TYPE_NORMAL
