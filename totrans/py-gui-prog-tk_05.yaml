- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Reducing User Error with Validation and Automation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过验证和自动化减少用户错误
- en: 'Things are going well for our project: the data entry form works well, the
    code is better organized, and the users are excited at the prospect of using the
    application. We''re not ready for production yet, though! Our form doesn''t yet
    perform the promised task of preventing or discouraging user errors: number boxes
    still allow letters, combo boxes aren''t limited to the choices given, and dates
    are just text fields that have to be filled in by hand. In this chapter, we''re
    going to set things right as we work through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目进展顺利：数据输入表单运行良好，代码组织得更好，用户对使用应用程序的前景感到兴奋。尽管如此，我们还没有准备好投入生产！我们的表单还没有执行承诺的任务，即防止或劝阻用户错误：数字框仍然允许字母，组合框没有限制在给定的选择中，日期只是需要手动填写的文本字段。在本章中，我们将通过以下主题来纠正这些问题：
- en: In *Validating user input*, we'll talk about some strategies for enforcing correct
    values in our widgets and how to implement them in Tkinter.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *验证用户输入* 中，我们将讨论一些在控件中强制正确值并如何在Tkinter中实现它们的策略。
- en: In *Creating validated widget classes*, we'll super-charge Tkinter's widget
    classes with some custom validation logic.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *创建验证控件类* 中，我们将使用一些自定义验证逻辑来增强Tkinter的控件类。
- en: In *Implementing validated widgets in our GUI*, we'll use our new widgets to
    improve ABQ Data Entry.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *在我们的GUI中实现验证控件* 中，我们将使用我们新的控件来改进ABQ数据输入。
- en: In *Automating input*, we'll implement auto-population of data in our widgets
    to save users time and effort.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *自动化输入* 中，我们将实现控件中的数据自动填充，以节省用户的时间和精力。
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Validating user input
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: At first glance, Tkinter's selection of input widgets seems a little disappointing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 初看Tkinter的输入控件选择似乎有点令人失望。
- en: It gives us neither a true number entry that only allows digits, nor a truly
    keyboard-friendly, modern drop-down selector. We have no date inputs, email inputs,
    or other specially formatted input widgets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它既没有提供只允许数字的真正数字输入，也没有提供真正键盘友好的、现代的下拉选择器。我们没有日期输入、电子邮件输入或其他特殊格式的输入控件。
- en: Nevertheless, these weaknesses can become strengths. Because these widgets assume
    nothing, we can make them behave in a way that's appropriate to our specific needs.
    For example, alphabetical characters may seem inappropriate in a number entry,
    but are they? In Python, strings such as `NaN` and `Infinity` are valid float
    values; having a box that could increment numerals but also handle those string
    values may be very useful in some applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这些弱点可以成为优势。因为这些控件没有任何假设，我们可以使它们以适合我们特定需求的方式表现。例如，在数字输入中，字母字符可能看起来不合适，但它们合适吗？在Python中，如
    `NaN` 和 `Infinity` 这样的字符串是有效的浮点值；有一个可以递增数字但也可以处理这些字符串值的框，在某些应用中可能非常有用。
- en: Of course, before we can tailor our widgets to our needs, we'll need to think
    about what exactly we want them to do. Let's do some analysis.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们能够根据我们的需求定制我们的控件之前，我们需要考虑我们确切想要它们做什么。让我们进行分析。
- en: Strategies to prevent data errors
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止数据错误的策略
- en: 'There is no universal answer to how a widget should react to a user trying
    to enter bad data. The validation logic found in various GUI toolkits can differ
    greatly; when bad data is entered, an input widget might validate the user input
    in any of the following ways:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于控件应该如何响应用户尝试输入错误数据的问题，没有统一的答案。在各种GUI工具包中找到的验证逻辑可能大相径庭；当输入错误数据时，输入控件可能会以以下任何一种方式验证用户输入：
- en: Prevent the invalid keystrokes from registering at all
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全阻止无效按键注册
- en: Accept the input, but return an error or list of errors when the form is submitted
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受输入，但在表单提交时返回错误或错误列表
- en: Show an error when the user leaves the entry field, perhaps disabling form submission
    until it's corrected
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户离开输入字段时显示错误，可能禁用表单提交直到更正
- en: Lock the user in the entry field until valid data is entered
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户锁定在输入字段中，直到输入有效数据
- en: Silently correct the bad data using a best-guess algorithm
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最佳猜测算法静默地纠正错误数据
- en: The correct behavior in a data entry form (which is filled out hundreds of times
    a day by the same users, who may not even be looking at it) may be different from
    an instrument control panel (where values absolutely must be correct to avoid
    a disaster) or an online user registration form (which is filled out once by a
    user who has never seen it before). We need to ask ourselves – and our users –
    which behavior will best minimize errors.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数据输入表单（每天由相同用户填写数百次，他们甚至可能没有注意到它）的正确行为可能与仪表控制面板（值必须绝对正确以避免灾难）或在线用户注册表单（由从未见过的小部件的用户填写一次）不同。我们需要问自己——以及我们的用户——哪种行为将最好地最小化错误。
- en: 'After discussing this with your users on the data entry staff, you come to
    the following set of guidelines:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在与数据输入人员用户讨论后，你得出以下一系列指南：
- en: Whenever possible, meaningless keystrokes should be ignored (for example, letters
    in a number field).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，应忽略无意义的按键（例如，数字字段中的字母）。
- en: Fields containing bad data should be marked in some visible way at focus-out
    (when the user exits the field) with an error describing the problem.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在焦点移出时（当用户退出字段时），应通过描述问题的错误以某种可见方式标记包含不良数据的字段。
- en: A required field left empty at focus-out should be marked with an error.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在焦点移出时留空的必填字段应标记为错误。
- en: Form submission should be disabled if there are fields with outstanding errors.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有字段存在未解决的错误，应禁用表单提交。
- en: 'Let''s add the following requirements to our specification before moving on.
    Under the Requirements section, update the `Functional Requirements` as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们将以下要求添加到我们的规范中。在“要求”部分，更新“功能要求”如下：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So far so good, but how do we implement this?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但我们如何实现它？
- en: Validation in Tkinter
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter中的验证
- en: 'Tkinter''s validation system is one of those parts of the toolkit that is less
    than intuitive. It relies on three configuration arguments that we can pass into
    any input widget:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的验证系统是工具箱中不太直观的部分之一。它依赖于三个我们可以传递给任何输入小部件的配置参数：
- en: '`validate`: This option determines which type of event will trigger the validation
    callback.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate`参数确定哪种类型的事件将触发验证回调。'
- en: '`validatecommand`: This option takes the command that will determine if the
    data is valid.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validatecommand`参数：此选项接受确定数据是否有效的命令。'
- en: '`invalidcommand`: This option takes a command that will run if `validatecommand`
    returns `False`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalidcommand`：此选项接受一个命令，如果`validatecommand`返回`False`，则运行该命令。'
- en: This all seems pretty straightforward, but there are some unexpected curves.
    Let's look in depth at each argument.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎很简单，但也有一些意外的曲线。让我们深入查看每个参数。
- en: The validate argument
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`validate`参数'
- en: 'The `validate` argument specifies what kind of event triggers the validation.
    It can be one of the following string values:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate`参数指定了触发验证的事件类型。它可以是指定的以下字符串值之一：'
- en: '| Value | Trigger event |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 触发事件 |'
- en: '| `none` | Never. This option turns off validation. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `none` | 从不。此选项关闭验证。 |'
- en: '| `focusin` | The user selects or enters the widget. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `focusin` | 用户选择或输入小部件。 |'
- en: '| `focusout` | The user leaves the widget. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `focusout` | 用户离开小部件。 |'
- en: '| `focus` | Both `focusin` and `focusout`. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `focus` | `focusin`和`focusout`。 |'
- en: '| `key` | The user presses a key while in the widget. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `key` | 用户在小部件中按下一个键。 |'
- en: '| `all` | Any of the `focusin`, `focusout`, or `key` events. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `all` | 任何`focusin`、`focusout`或`key`事件。 |'
- en: Only one `validate` argument can be specified, and all matching events will
    trigger the same validation callback. Most of the time, you will want to use `key`
    and `focusout` (validating on `focusin` is rarely useful), but since there isn't
    a value that combines those two events, it's often best to use `all` and let the
    callback switch its validation logic based on the event type if necessary.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 只能指定一个`validate`参数，所有匹配的事件将触发相同的验证回调。大多数时候，你将想要使用`key`和`focusout`（在`focusin`上验证很少有用），但由于没有结合这两个事件的值，通常最好使用`all`，并在必要时让回调根据事件类型切换其验证逻辑。
- en: The validatecommand argument
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`validatecommand`参数'
- en: The `validatecommand` argument specifies the callback function that will be
    run when the `validate` event is triggered. This is where things get a little
    tricky. You might think this argument takes the name of a Python function or method,
    but that's not quite it. Instead, we need to give it a tuple containing a string
    reference to a Tcl/Tk function, and (optionally) some **substitution codes** that
    specify information about the triggering event that we want to pass into the function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`validatecommand` 参数指定了当 `validate` 事件被触发时将运行的回调函数。这里事情变得有点棘手。你可能认为这个参数接受一个
    Python 函数或方法的名称，但事实并非如此。相反，我们需要提供一个包含对 Tcl/Tk 函数的字符串引用的元组，以及（可选的）一些 **替换代码**，这些代码指定了我们想要传递给函数的触发事件的详细信息。'
- en: How do we get a reference to a Tcl/Tk function? Fortunately, this isn't too
    hard; we just need to pass a Python callable to the `register()` method of any
    Tkinter widget. This returns string reference that we can use with `validatecommand`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何获取一个 Tcl/Tk 函数的引用？幸运的是，这并不太难；我们只需要将一个 Python 可调用对象传递给任何 Tkinter 小部件的 `register()`
    方法。这会返回一个字符串引用，我们可以用它来与 `validatecommand` 一起使用。
- en: 'For example, we can create a (somewhat pointless) validation command like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个（有点无意义的）验证命令，如下所示：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we've retrieved our function reference by passing the `always_good`
    function to `root.register()`. Then we can pass this reference in a tuple to `validatecommand`.
    The validation callback that we register must return a Boolean value indicating
    whether the data in the field is valid or invalid.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过将 `always_good` 函数传递给 `root.register()` 来检索我们的函数引用。然后我们可以将这个引用作为一个元组传递给
    `validatecommand`。我们注册的验证回调必须返回一个布尔值，表示字段中的数据是否有效或无效。
- en: A `validatecommand` callback *must* return a Boolean value. If it returns anything
    else (including the implicit `None` value when there is no `return` statement),
    Tkinter will turn off validation on the widget (that is, it will set `validate`
    to `none`). Remember that its purpose is *only* to indicate whether the data is
    acceptable or not. The handling of invalid data will be done by our `invalidcommand`
    callback.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`validatecommand` 回调 *必须* 返回一个布尔值。如果它返回任何其他内容（包括没有 `return` 语句时的隐式 `None` 值），Tkinter
    将关闭小部件的验证（即，它将 `validate` 设置为 `none`）。请记住，它的目的 *仅* 是指示数据是否可接受。无效数据的处理将由我们的 `invalidcommand`
    回调完成。'
- en: 'Of course, it''s not easy to validate the data unless we provide the function
    with some data to be validated. To make Tkinter pass information to our validation
    callback, we can add one or more substitution codes to our `validatecommand` tuple.
    These codes are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除非我们向函数提供一些要验证的数据，否则很难验证数据。为了使 Tkinter 将信息传递给我们的验证回调，我们可以在 `validatecommand`
    元组中添加一个或多个替换代码。这些代码如下：
- en: '| Code | Value passed |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 传递的值 |'
- en: '| `%d` | A code indicating the action being attempted: `0` for delete, `1`
    for insert, and `-1` for other events. Note that this is passed as a string, and
    not as an integer. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 指示尝试的操作的代码：`0` 表示删除，`1` 表示插入，以及 `-1` 表示其他事件。请注意，这作为字符串传递，而不是整数。 |'
- en: '| `%P` | The proposed value that the field would have after the change (key
    events only). |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `%P` | 变更后字段将具有的提议值（仅限关键事件）。 |'
- en: '| `%s` | The value currently in the field (key events only). |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 当前字段中的值（仅限关键事件）。 |'
- en: '| `%i` | The index (from `0`) of the text being inserted or deleted on key
    events, or `-1` on non-key events. Note that this is passed as a string, not an
    integer. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `%i` | 在按键事件中插入或删除的文本的索引（从 `0` 开始），或在非按键事件中为 `-1`。请注意，这作为字符串传递，而不是整数。 |'
- en: '| `%S` | For insertion or deletion, the text that is being inserted or deleted
    (key events only). |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `%S` | 用于插入或删除的文本（仅限关键事件）。 |'
- en: '| `%v` | The widget''s `validate` value. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `%v` | 小部件的 `validate` 值。 |'
- en: '| `%V` | The event type that triggered validation, one of `focusin`, `focusout`,
    `key`, or `forced` (indicating the widget''s variable was changed). |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `%V` | 触发验证的事件类型，可以是 `focusin`、`focusout`、`key` 或 `forced`（表示小部件的变量已更改）。
    |'
- en: '| `%W` | The widget''s name in Tcl/Tk, as a string. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `%W` | Tcl/Tk 中小部件的名称，作为字符串。 |'
- en: 'We can use these codes to create a slightly more useful validated `Entry`,
    like so:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些代码创建一个稍微更有用的验证 `Entry`，如下所示：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we're passing the `%P` substitution code into our `validatecommand` tuple
    so that our callback function will be passed the proposed new value for the widget
    (that is, the value of the widget if the keystroke is accepted). In this case,
    we're going to return `False` if the proposed value contains the `t` character.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `%P` 替换代码传递到我们的 `validatecommand` 元组中，以便我们的回调函数将接收到小部件的提议新值（即，如果按键被接受，则小部件的值）。在这种情况下，如果提议的值包含
    `t` 字符，我们将返回 `False`。
- en: Note that the behavior of the widget when the `validatecommand` callback returns
    changes depending on the type of event that triggered validation. If a validation
    callback is triggered by a `key` event and it returns `False`, Tkinter's built-in
    behavior is to reject the keystroke and leave the contents as they are. In the
    event of a `focus` event triggering validation, a `False` return value will simply
    flag the widget as invalid. In both cases, the `invalidcommand` callback will
    also be executed. If we haven't specified a callback, Tkinter will simply do nothing
    further.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 `validatecommand` 回调返回时，小部件的行为会根据触发验证的事件类型而改变。如果验证回调由 `key` 事件触发并返回 `False`，Tkinter
    的内置行为是拒绝按键并保持内容不变。如果 `focus` 事件触发验证，则 `False` 返回值将简单地标记小部件为无效。在这两种情况下，`invalidcommand`
    回调也将被执行。如果我们没有指定回调，Tkinter 将不会采取任何进一步的操作。
- en: For example, run the above script; you'll find you cannot type a `t` in the
    `Entry` widget. That's because the `key` validation returned `False`, so Tkinter
    rejected the keystroke.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行上面的脚本；您会发现您不能在 `Entry` 小部件中键入 `t`。这是因为 `key` 验证返回 `False`，所以 Tkinter 拒绝了按键。
- en: The invalidcommand argument
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`invalidcommand` 参数'
- en: The `invalidcommand` argument works exactly the same as the `validatecommand`
    argument, requiring the use of the `register()` method and the same substitution
    codes. It specifies a callback function to be run when `validatecommand` returns
    `False`. It could be used to show an error or possibly correct the input.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`invalidcommand` 参数与 `validatecommand` 参数完全相同，需要使用 `register()` 方法以及相同的替换代码。它指定了一个在
    `validatecommand` 返回 `False` 时要运行的回调函数。它可以用来显示错误或可能纠正输入。'
- en: 'To see what this looks like together, consider the following code for an `Entry`
    widget that only accepts five characters:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些代码组合在一起的样子，请考虑以下仅接受五个字符的 `Entry` 小部件的代码：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we've created a simple GUI with an `Entry` widget and a `Label` widget.
    We've also created two functions, one that returns whether or not the length of
    a string is less than six characters, and another that configures the `Label`
    widget to show an error. We then register the two functions with Tk using the
    `root.register()` method, passing them to the `Entry` widget's `validatecommand`
    and `invalidcommand` arguments. We also include the `%P` substitution code so
    that the proposed value of the widget is passed into each function. Note that
    you can pass in as many substitution codes as you wish, and in any order, as long
    as your callback function is written to accept those arguments.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个简单的 GUI，其中包含一个 `Entry` 小部件和一个 `Label` 小部件。我们还创建了两个函数，一个用于返回字符串长度是否小于六个字符，另一个用于配置
    `Label` 小部件以显示错误。然后我们使用 `root.register()` 方法将这两个函数注册到 Tk 中，将它们传递给 `Entry` 小部件的
    `validatecommand` 和 `invalidcommand` 参数。我们还包括了 `%P` 替换代码，以便将小部件的提议值传递给每个函数。请注意，您可以传递任意多的替换代码，并且可以按任意顺序传递，只要您的回调函数能够接受这些参数。
- en: Run this example and test its behavior; note that not only can you *not* type
    more than five characters in the box, but you also receive a warning in the label
    that your attempted edit was too long.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例并测试其行为；请注意，您不仅不能在框中键入超过五个字符，而且您还会在标签中收到警告，表明您的尝试编辑过长。
- en: Creating validated widget classes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建经过验证的小部件类
- en: As you can see, adding even very simple validation to Tkinter widgets involves
    several steps with some less-than-intuitive logic. Adding validation to even a
    fraction of our widgets could get quite verbose and ugly. However, we learned
    in the previous chapter that we can improve on Tkinter widgets by subclassing
    them to add new configuration and functionality. Let's see if we can apply this
    technique to widget validation by creating validated versions of Tkinter's widget
    classes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使在 Tkinter 小部件中添加非常简单的验证也涉及几个步骤和一些不太直观的逻辑。即使只对我们的部分小部件添加验证也可能变得冗长且难以看懂。然而，我们在上一章中学到，我们可以通过子类化
    Tkinter 小部件来改进它们，以添加新的配置和功能。让我们看看我们是否可以将这种技术应用于小部件验证，通过创建 Tkinter 小部件类的验证版本。
- en: 'For example, let''s implement our five-character entry again, this time as
    a subclass of `ttk.Entry`, like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们再次实现我们的五字符输入，这次作为 `ttk.Entry` 的子类，如下所示：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time, we've implemented validation by subclassing `Entry` and defining
    our validation logic in a method rather than an external function. This simplifies
    access to the widget in our validation methods, should we need it, and also allows
    us to refer to the methods in `__init__()` before they are actually defined. We've
    also added a `StringVar` called `error` as an instance variable. We can use this
    variable to hold an error message should our validation fail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们通过子类化 `Entry` 并在方法中定义我们的验证逻辑而不是外部函数来实现验证。这简化了我们在验证方法中对小部件的访问，如果我们需要的话，并且也允许我们在它们实际定义之前在
    `__init__()` 中引用这些方法。我们还添加了一个名为 `error` 的 `StringVar` 作为实例变量。如果我们的验证失败，我们可以使用这个变量来保存错误消息。
- en: Note that we've registered these functions using `self.register()` rather than
    `root.register()`. The `register()` method does not have to be run on the `root`
    window object; it can be run on any Tkinter widget. Since we don't know for sure
    that the code using our class will call the root window `root`, or if it will
    be in scope when the `__init__()` method runs, it makes sense to use the `FiveCharEntry`
    widget itself to register the functions. However, this must be done *after* we
    call `super().__init__()`, since the underlying Tcl/Tk object doesn't actually
    exist (and cannot register functions) until that method is run. That is why we're
    using `configure()` to set these values rather than passing them into `super().__init__()`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `self.register()` 而不是 `root.register()` 来注册这些函数。`register()` 方法不需要在
    `root` 窗口对象上运行；它可以在任何 Tkinter 小部件上运行。由于我们无法确定使用我们类代码的人是否会调用 `root` 窗口，或者它是否在 `__init__()`
    方法运行时处于作用域内，因此使用 `FiveCharEntry` 小部件本身来注册函数是有意义的。然而，这必须在调用 `super().__init__()`
    之后完成，因为底层的 Tcl/Tk 对象实际上并不存在（并且不能注册函数），直到该方法运行。这就是为什么我们使用 `configure()` 来设置这些值，而不是将它们传递给
    `super().__init__()` 的原因。
- en: 'We can then use this class like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此类如下：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we''ve created an instance of the `FiveCharEntry` widget as well as a
    `Label` widget to display errors. Note that we pass the widget''s built-in error
    variable, `entry.error`, to the label''s `textvariable` argument. When you execute
    this, you should see the label displaying an error when you try to type more than
    five characters, like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `FiveCharEntry` 小部件的实例以及一个 `Label` 小部件来显示错误。请注意，我们将小部件的内置错误变量 `entry.error`
    传递给标签的 `textvariable` 参数。当你执行这个操作时，你应该会看到标签在尝试输入超过五个字符时显示错误，如下所示：
- en: '![The five-character entry refusing to accept "Banana"](img/B17578_05_01.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![五字符输入拒绝接受 "Banana"](img/B17578_05_01.png)'
- en: 'Figure 5.1: The five-character entry refusing to accept "Banana"'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：五字符输入拒绝接受 "Banana"
- en: Creating a Date field
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建日期字段
- en: 'Let''s try something a little more useful now: creating a validating `DateEntry`
    widget to use for our `Date` field. Our widget will prevent any keystrokes that
    aren''t valid for a date string, and check for validity of the date on `focusout`.
    If the date is invalid, we''ll mark the field in some way and set an error message
    in a `StringVar`, which some other widget could use to display the error.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试做一些更有用的东西：创建一个用于我们的 `Date` 字段的验证 `DateEntry` 小部件。我们的小部件将阻止任何对于日期字符串无效的按键，并在
    `focusout` 时检查日期的有效性。如果日期无效，我们将以某种方式标记字段，并在 `StringVar` 中设置一个错误消息，其他小部件可以使用它来显示错误。
- en: 'First, open a new file called `DateEntry.py` and begin with the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个名为 `DateEntry.py` 的新文件，并从以下代码开始：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After importing `tkinter` and `ttk`, we also import `datetime`, which we''ll
    need for validating the date strings entered. As with our previous class, we''ve
    overridden `__init__()` to set up validation and add an error variable. This time,
    however, we''re going to be passing several more arguments into our `validatecommand`
    method: the character being inserted (`%S`), the index where it''s being inserted
    (`%i`), the event type triggering validation (`%V`), and the action type (`%d`).
    `invalidcommand` is receiving only the event type (`%V`). Since we''re triggering
    validation on all events, we''ll need this value to decide how to handle the invalid
    data appropriately.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入 `tkinter` 和 `ttk` 之后，我们还导入了 `datetime`，这是为了验证输入的日期字符串。与之前的类一样，我们重写了 `__init__()`
    方法来设置验证并添加一个错误变量。然而，这一次，我们将向我们的 `validatecommand` 方法传递更多的参数：要插入的字符（`%S`），插入的索引位置（`%i`），触发验证的事件类型（`%V`），以及动作类型（`%d`）。`invalidcommand`
    只接收事件类型（`%V`）。由于我们将在所有事件上触发验证，我们需要这个值来决定如何适当地处理无效数据。
- en: 'Next, let''s create a method called `_toggle_error()` to turn an error state
    on or off in the widget:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为 `_toggle_error()` 的方法来在小部件中打开或关闭错误状态：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We'll use this method to handle how our widget behaves when an error occurs
    or is corrected. It starts by setting our error variable to the string provided.
    If the string is not blank, we set a visual error indicator (in this case, turning
    the text red); if it's blank, we turn off the visual indicator.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个方法来处理小部件在发生错误或被纠正时的行为。它首先将我们的错误变量设置为提供的字符串。如果字符串不为空，我们设置一个视觉错误指示器（在这种情况下，将文本变为红色）；如果为空，我们关闭视觉指示器。
- en: 'Now that we have that, we can create our `_validate()` method, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些，我们可以创建我们的 `_validate()` 方法，如下所示：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method will take an "innocent until proven guilty" approach to validating
    the user input, so we begin by toggling off any error state and setting a `valid`
    flag to `True`. Then, we'll start looking at keystroke events. The line `if action
    == '0':` tells us if the user is trying to delete characters. We always want to
    allow this so that the user can edit the field, so that should always return `True`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将采取“无罪直到被证明有罪”的方法来验证用户输入，所以我们首先关闭任何错误状态并将 `valid` 标志设置为 `True`。然后，我们将开始查看按键事件。`if
    action == '0':` 这行代码告诉我们用户是否正在尝试删除字符。我们总是希望允许这样做，以便用户可以编辑字段，所以它应该总是返回 `True`。
- en: The basic format of an ISO date is four digits, a dash, two digits, a dash,
    and two digits. We can test whether the user is following this format by checking
    whether the inserted characters match our expectations at the inserted index.
    For example, the line `index in ('0','1', '2', '3', '5', '6', '8', '9')` will
    tell us if the character is being inserted at one of the positions that requires
    a digit, and if so we check that the character is a digit. The characters at indexes
    `4` and `7` should be a dash. Any other keystroke is invalid.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ISO日期的基本格式是四位数字，一个连字符，两位数字，一个连字符，再是两位数字。我们可以通过检查插入的字符是否与我们的期望匹配来测试用户是否遵循了这种格式。例如，`index
    in ('0','1', '2', '3', '5', '6', '8', '9')` 这行代码将告诉我们字符是否被插入到需要数字的一个位置，如果是，我们将检查该字符是否为数字。索引
    `4` 和 `7` 的字符应该是连字符。任何其他按键都是无效的。
- en: Although you might expect them to be integers, Tkinter passes both action codes
    and character indexes as strings. Keep this in mind when writing your comparisons.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能期望它们是整数，Tkinter 将动作代码和字符索引都作为字符串传递。在编写比较时请记住这一点。
- en: While this is a hopelessly naive heuristic for a correct date, since it allows
    for complete nonsense dates like `0000-97-46`, or right-looking-but-still-wrong
    dates like `2000-02-29`, it at least enforces the basic format and removes a large
    number of invalid keystrokes. A completely accurate partial date analyzer is a
    project unto itself, but for now, this will do.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个对于正确日期来说极其天真的启发式方法，因为它允许像 `0000-97-46` 或看起来正确但实际上错误的日期 `2000-02-29` 这样的完全无意义的日期，但它至少强制执行了基本格式，并移除了一大堆无效的按键。一个完全准确的日期部分分析器是一个独立的项目，但就目前而言，这已经足够了。
- en: 'Checking our date for correctness on focus-out is simpler and much more foolproof,
    as you can see here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 检查在焦点移出时日期的正确性更为简单且更不容易出错，正如你在这里可以看到的：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we have access to the final value the user meant to enter at this point,
    we can use `datetime.strptime()` to try to convert the string to a Python `datetime`
    object using the format `%Y-%m-%d`. If this fails, we know the date is invalid.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在可以访问用户打算输入的最终值，我们可以使用 `datetime.strptime()` 尝试使用格式 `%Y-%m-%d` 将字符串转换为
    Python `datetime` 对象。如果这失败，我们知道日期是无效的。
- en: Finally, at the end of the method, we return our `valid` flag. As you saw previously,
    it's sufficient to return `False` for keystroke events to prevent the character
    from being inserted; but for errors on focus events, we'll need to respond in
    some user-visible way.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在方法末尾，我们返回我们的 `valid` 标志。正如你之前看到的，对于按键事件，返回 `False` 就足以防止字符被插入；但对于焦点事件上的错误，我们需要以某种用户可见的方式做出响应。
- en: 'This will be handled in our `_on_invalid()` method as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的 `_on_invalid()` 方法中处理，如下所示：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have configured this method to receive only the event type, which we'll use
    to ignore keystroke events (they're already adequately handled by the default
    behavior). For any other event type, we'll use our `_toggle_error()` method to
    set our visual indicator and the error string.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了此方法，使其仅接收事件类型，我们将使用它来忽略按键事件（它们已经被默认行为充分处理）。对于任何其他事件类型，我们将使用我们的 `_toggle_error()`
    方法来设置我们的视觉指示器和错误字符串。
- en: 'Let''s test the `DateEntry` class with a small test script at the end of the
    file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在文件的末尾使用一个小测试脚本来测试 `DateEntry` 类：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save the file and run it to try the new `DateEntry` class. Try entering various
    bad dates or invalid keystrokes, and then click the second `Entry` widget to unfocus
    the `DateEntry` and note what happens.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并运行它以尝试新的 `DateEntry` 类。尝试输入各种错误的日期或无效的按键，然后点击第二个 `Entry` 小部件以取消 `DateEntry`
    的焦点，并注意发生了什么。
- en: 'You should see something like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下内容：
- en: '![A validating DateEntry widget warning us about a bad date string.](img/B17578_05_02.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![一个验证的 DateEntry 小部件警告我们关于一个错误的日期字符串。](img/B17578_05_02.png)'
- en: 'Figure 5.2: A validating DateEntry widget warning us about a bad date string'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：一个验证的 DateEntry 小部件警告我们关于一个错误的日期字符串
- en: Implementing validated widgets in our GUI
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的 GUI 中实现验证小部件
- en: Now that you know how to validate your widgets, you have your work cut out for
    you! We have 17 input widgets, and you'll have to write validation code like that
    shown in the previous section for all of them to get the behavior we need. Along
    the way, you'll need to make sure the widgets respond consistently to errors and
    present a consistent API to the application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何验证你的小部件，你有很多工作要做！我们有 17 个输入小部件，你必须为它们都编写像上一节中所示的那种验证代码，以获得我们需要的功能。在这个过程中，你需要确保小部件对错误做出一致的反应，并向应用程序提供一个一致的
    API。
- en: If that sounds like something you'd like to put off indefinitely, I can't blame
    you. Maybe there's a way we can cut down the amount of repetitive code we need
    to write.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来像是你想无限期推迟的事情，我无法责怪你。也许有一种方法我们可以减少我们需要编写的重复代码量。
- en: Introducing the power of multiple inheritance
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍多重继承的强大功能
- en: So far, we have learned that Python allows us to create new classes by subclassing,
    inheriting features from the superclass, and only adding or changing what's different
    about our new class. Python also supports building classes using **multiple inheritance**,
    in which a subclass can inherit from multiple superclasses. We can exploit this
    feature to our advantage by creating what's called a **mixin class**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到 Python 允许我们通过子类化来创建新类，从超类继承特性，并且只添加或更改我们新类中不同的部分。Python 还支持使用
    **多重继承** 来构建类，其中子类可以继承多个超类。我们可以通过创建所谓的 **混合类** 来利用这个特性。
- en: Mixin classes contain only a specific set of functionalities that we want to
    be able to "mix in" with other classes to compose a new class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类只包含我们想要能够“混合”到其他类中以组成新类的一组特定功能。
- en: 'Take a look at the following example code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的示例代码：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we have a class called `Fruit` with a `_taste` class attribute
    and a `taste()` method that prints a message indicating how the fruit tastes.
    We then have a mixin class called `PeelableMixin`. The mixin class adds an instance
    attribute called `_peeled` to indicate if the fruit has been peeled, as well as
    a `peel()` method to update the `_peeled` attribute. It also overrides the `taste()`
    method to check if the fruit is peeled before tasting. Note that the mixin class's
    `__init__()` method also calls the superclass initializer, even though it doesn't
    inherit from another class. We'll see why this is in a moment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个名为 `Fruit` 的类，它有一个 `_taste` 类属性和一个 `taste()` 方法，该方法打印一条消息，指示水果的口感。然后我们有一个名为
    `PeelableMixin` 的混合类。混合类添加了一个实例属性 `_peeled`，用来指示水果是否已被剥皮，以及一个 `peel()` 方法来更新 `_peeled`
    属性。它还重写了 `taste()` 方法，在品尝之前检查水果是否已被剥皮。请注意，即使混合类没有从另一个类继承，其 `__init__()` 方法也会调用超类初始化器。我们稍后将看到这是为什么。
- en: 'Now, let''s use multiple inheritance to create a new class, like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用多重继承来创建一个新的类，如下所示：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Plantain` class is created from the combination of the `PeelableMixin`
    and the `Fruit` class. When we create a class using multiple inheritance, the
    rightmost class we specify is called the **base class**, and mixin classes should
    be specified before it (that is, to the left of the base class). Thus, `Fruit`
    is the base class in this case.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plantain`类是由`PeelableMixin`和`Fruit`类的组合创建的。当我们使用多重继承创建类时，我们指定的最右侧的类被称为**基类**，混入类应该在其之前指定（即位于基类的左侧）。因此，在这种情况下`Fruit`是基类。'
- en: 'Let''s create an instance of our class and call `taste()`, like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们类的实例并调用`taste()`，如下所示：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the resulting subclass has both a `taste()` and a `peel()` method,
    but note that there are two versions of each method defined between all the classes.
    When we call one of these methods, which version is used?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，生成的子类既有`taste()`方法也有`peel()`方法，但请注意，在所有类之间定义了每种方法的两个版本。当我们调用这些方法之一时，使用的是哪个版本？
- en: In a multiple inheritance situation, `super()` does something a little more
    complex than just standing in for the superclass. It looks up the chain of inheritance
    using something called the **method resolution order** (**MRO**) and determines
    the nearest class that defines the method we're calling. The resolution order
    starts with the current class, and then follows the chain of superclasses from
    the leftmost to the base class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重继承的情况下，`super()`所做的比仅仅代表超类要复杂一些。它使用称为**方法解析顺序**（**MRO**）的东西来查找继承链，并确定定义我们正在调用的方法的最近类。解析顺序从当前类开始，然后按照从左侧到基类的超类链进行。
- en: 'Thus, when we call `plantain.taste()`, a series of method resolutions occurs,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们调用`plantain.taste()`时，会发生一系列的方法解析，如下所示：
- en: '`plantain.taste()` is resolved to `PeelableMixin.taste()`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plantain.taste()`解析为`PeelableMixin.taste()`。'
- en: '`PeelableMixin.taste()` then calls `self.peel()`. Since `self` is a `Plantain`
    object, `self.peel()` is resolved to `Plantain.peel()`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后`PeelableMixin.taste()`调用`self.peel()`。由于`self`是一个`Plantain`对象，`self.peel()`解析为`Plantain.peel()`。
- en: '`Plaintain.peel()` prints a message and calls `super().peel()`. Python resolves
    this call to the leftmost class with a `peel()` method, `PeelableMixin.peel()`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Plaintain.peel()`打印一条消息并调用`super().peel()`。Python将此调用解析为具有`peel()`方法的左侧最接近的类，即`PeelableMixin.peel()`。'
- en: When that's returned, `PeelableMixin.taste()` then calls `super().taste()`.
    The next leftmost class from `PeelableMixin` is `Fruit`, so this is resolved to
    `Fruit.taste()`.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当返回结果时，`PeelableMixin.taste()`然后调用`super().taste()`。从`PeelableMixin`开始的下一个左侧类是`Fruit`，因此这解析为`Fruit.taste()`。
- en: '`Fruit.taste()` refers to the class variable `_taste`. Even though the method
    being run is in the `Fruit` class, the class of our object is `Plantain`, so `Plantain._taste`
    is used here.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fruit.taste()`引用类变量`_taste`。即使正在运行的方法在`Fruit`类中，但我们的对象类是`Plantain`，所以这里使用`Plantain._taste`。'
- en: If this seems confusing, just remember that `self.method()` or `self.attribute`
    will always look for `method()` or `attribute` in the current class first, and
    then follow the list of inherited classes from left to right until the method
    or attribute is found. The `super()` object will do the same, except that it skips
    the current class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很复杂，只需记住`self.method()`或`self.attribute`将始终首先在当前类中查找`method()`或`attribute`，然后从左到右按照继承的类列表进行查找，直到找到方法或属性。`super()`对象将做同样的事情，但它会跳过当前类。
- en: This is the reason why we called `super().__init__()` inside the mixin class's
    initializer in the example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为什么在示例中在混入类的初始化器中调用`super().__init__()`的原因。
- en: Without this call, only the mixin class initializer would be called. By calling
    `super().__init__()`, Python will also continue up the MRO chain and call the
    base class initializer. This is particularly important to remember when creating
    mixins for Tkinter classes, since the Tkinter class's initializer creates the
    actual Tcl/Tk object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不进行此调用，则只会调用混入类的初始化器。通过调用`super().__init__()`，Python还会继续沿着MRO链向上调用基类初始化器。这在创建Tkinter类的混入类时尤其重要，因为Tkinter类的初始化器创建了实际的Tcl/Tk对象。
- en: The method resolution order of a class is stored in its `__mro__` property;
    you can inspect this method in a Python shell or debugger if you're having trouble
    with inherited methods or attributes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 类的方法解析顺序存储在其`__mro__`属性中；如果你在使用继承的方法或属性时遇到问题，可以在Python壳或调试器中检查此方法。
- en: 'Note that `PeelableMixin` is not usable on its own: it only works when combined
    with a class that has a `taste()` method. This is why it''s a mixin class: it
    is meant to be mixed in to enhance other classes, not used on its own.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`PeelableMixin`不能单独使用：它只能在具有`taste()`方法的类结合使用时工作。这就是为什么它是一个混合类：它旨在与其他类混合以增强其他类，而不是单独使用。
- en: Unfortunately, Python does not give us a way to explicitly annotate in code
    that a class is a mixin or what classes it must be mixed with, so be sure to document
    your mixin classes well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python没有提供一种方法来显式地在代码中注释一个类是混合类或它必须与哪些类混合，所以请确保很好地记录你的混合类。
- en: Building a validating mixin class
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建验证混合类
- en: 'Let''s apply our knowledge of multiple inheritance to build a mixin class that
    will help us create validated widget classes with less boilerplate code. Open
    `data_entry_app.py` and add the new class just above your `Application` class
    definition:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用我们对多重继承的知识来构建一个混合类，这将帮助我们用更少的样板代码创建验证小部件类。打开`data_entry_app.py`并在你的`Application`类定义之上添加新类：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've started this class as usual, though we're not subclassing anything this
    time because this is a mixin class. The constructor also has an extra argument
    called `error_var`. This will allow us to pass in a variable to use for the error
    message; if we don't, the class creates its own. Remember that the call to `super().__init__()`
    will ensure that the base class initializer will be executed as well.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样开始这个类，尽管这次我们没有子类化任何东西，因为这是一个混合类。构造函数还有一个额外的参数，称为`error_var`。这将允许我们传递一个用于错误消息的变量；如果没有，类将创建自己的。记住，对`super().__init__()`的调用将确保执行基类初始化器。
- en: 'Next, we set up validation, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置验证，如下所示：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we've done before, we're registering instance methods for validation and
    invalid data handling, and then using `configure` to set them up with the widget.
    We'll go ahead and pass in all the substitution codes (except `%w`, the widget
    name, since it's fairly useless inside a class context). We're running validation
    on `all` conditions, so we can capture both `focus` and `key` events.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所做的那样，我们正在注册实例方法以进行验证和无效数据处理，然后使用`configure`将它们与小部件一起设置。我们将继续传递所有替换代码（除了`%w`，即小部件名称，因为它在类上下文中相当无用）。我们在所有条件下运行验证，因此我们可以捕获`focus`和`key`事件。
- en: 'Now, we''ll define our error condition handler:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义我们的错误条件处理器：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will just change the text color to red if there's an error, or black otherwise.
    Unlike our previous validated widget classes, we won't set the error string in
    this function; instead, we'll do that in the validation callback since we'll have
    a better idea of what the error is in that context.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅在存在错误时将文本颜色更改为红色，否则为黑色。与之前的验证小部件类不同，我们不会在这个函数中设置错误字符串；相反，我们将在验证回调中这样做，因为在那样的上下文中我们将更好地了解错误是什么。
- en: 'Our validation callback will look like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的验证回调将如下所示：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since this is a mixin, our `_validate()` method doesn't actually contain any
    validation logic. Rather, it's going to start by handling a few setup chores,
    like toggling off the error and clearing the error message. It then checks to
    see if the widget is disabled by retrieving the last item in the widget's `state`
    value. If it is disabled, the value of the widget is immaterial, so validation
    should always pass.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个混合类，我们的`_validate()`方法实际上不包含任何验证逻辑。相反，它将首先处理一些设置任务，例如关闭错误并清除错误消息。然后，它检查小部件是否被禁用，通过检索小部件`state`值中的最后一个项目来实现。如果它被禁用，小部件的值无关紧要，因此验证应该始终通过。
- en: After that, the method calls an event-specific callback method, depending on
    the event type passed in. We only care about the `key` and `focusout` events right
    now, so any other event just returns `True`. Those event-specific methods will
    be defined in our subclasses to determine the actual validation logic used.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，该方法根据传入的事件类型调用特定的事件回调方法。我们现在只关心`key`和`focusout`事件，所以任何其他事件都返回`True`。这些特定的事件方法将在我们的子类中定义，以确定实际使用的验证逻辑。
- en: Notice that we call the individual methods using keyword arguments; when we
    create our subclasses, we'll be overriding these methods. By using keyword arguments,
    our overridden functions can just specify the needed keywords or extract individual
    arguments from `**kwargs`, rather than having to get all the arguments in the
    right order. Also, notice that all the arguments are passed into `_key_validate()`,
    but only `event` is passed into `_focusout_validate()`. Focus events don't pass
    anything useful for any of the other arguments, so there's no point in passing
    them along.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用关键字参数调用单个方法；当我们创建我们的子类时，我们将覆盖这些方法。通过使用关键字参数，我们的覆盖函数只需指定所需的关键字或从`**kwargs`中提取单个参数，而不必按正确的顺序获取所有参数。此外，请注意，所有参数都传递给了`_key_validate()`，但只有`event`传递给了`_focusout_validate()`。焦点事件不会传递任何有用的参数给其他任何参数，所以没有必要传递它们。
- en: 'Next, we''ll put in placeholders for the event-specific validation methods:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为特定事件的验证方法添加占位符：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The ultimate idea here is that our subclasses only need to override one or both
    of `_focusout_validate()` or `_key_validate()`, depending on what we care about
    for that widget. If we don't override them, they just return `True`, so validation
    passes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最终想法是，我们的子类只需要覆盖一个或两个`_focusout_validate()`或`_key_validate()`，具体取决于我们对该小部件的关注点。如果我们不覆盖它们，它们将默认返回`True`，因此验证通过。
- en: 'Now, let''s do something similar for our invalid input handler:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的无效输入处理程序做类似的事情：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We take an identical approach to these methods. Unlike the validate methods,
    though, our invalid data handlers don't need to return anything. For invalid `key`
    events, we do nothing by default, and for invalid input on `focusout` events,
    we toggle on our error status.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这些方法采取相同的方法。与验证方法不同，我们的无效数据处理程序不需要返回任何内容。对于无效的`key`事件，我们默认不执行任何操作，对于`focusout`事件上的无效输入，我们切换错误状态。
- en: 'The last thing we want to add is a way to manually execute validation on the
    widget. Keystroke validation only really makes sense in the context of entering
    keys, but there may be times when we want to manually run the focus-out checks
    since they effectively check the complete entered value. Let''s implement that
    with the following public method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后想添加的是一种手动在控件上执行验证的方法。按键验证仅在输入键的上下文中才有意义，但有时我们可能想手动运行焦点退出检查，因为它们实际上检查了完整输入值。让我们通过以下公共方法来实现这一点：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this method, we''re just duplicating the logic that occurs when a focus-out
    event happens: run the validation function, and if it fails, run the invalid handler.
    This completes the `ValidatedMixin`. Now let''s see how it works by applying it
    to some of our widgets.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们只是在复制焦点退出事件发生时的逻辑：运行验证函数，如果失败，则运行无效处理程序。这完成了`ValidatedMixin`。现在让我们通过将其应用于我们的某些小部件来看看它是如何工作的。
- en: Building validating input widgets with ValidatedMixin
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ValidatedMixin构建验证输入小部件
- en: 'To begin, let''s think through what classes we need to implement with our new
    `ValidatedMixin` class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下我们需要使用我们的新`ValidatedMixin`类实现哪些类：
- en: All our fields except the Notes field are required (when not disabled), so we'll
    need a basic `Entry` widget that registers an error if there's no input.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了注释字段之外，我们所有的字段都是必需的（当未禁用时），因此我们需要一个基本的`Entry`小部件，如果没有任何输入，它会注册一个错误。
- en: We have one Date field, so we need an `Entry` widget that enforces a valid date
    string.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个日期字段，因此我们需要一个强制有效日期字符串的`Entry`小部件。
- en: We have a number of `Spinbox` widgets for decimal or integer input. We'll need
    to make sure these only accept valid number strings.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有几个用于十进制或整数输入的`Spinbox`小部件。我们需要确保这些小部件只接受有效的数字字符串。
- en: We have a few `Combobox` widgets that don't behave quite the way we want them
    to.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有几个`Combobox`小部件，它们的行为并不完全符合我们的期望。
- en: Let's get started!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Requiring data
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需求数据
- en: Let's start with a basic `Entry` widget that requires data. We can use these
    for the Technician and Seed Sample fields.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从需要数据的基本`Entry`小部件开始。我们可以将这些用于技术人员和种子样本字段。
- en: 'Add a new class just after the `ValidatedMixin` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ValidatedMixin`类之后添加一个新类：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There's no keystroke validation to do here, so we just need to create `_focusout_validate()`.
    All we need to do in that method is check whether the entered value is empty.
    If so, we just set an `error` string and return `False`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有按键验证要做，所以我们只需要创建`_focusout_validate()`。在那个方法中，我们只需要检查输入值是否为空。如果是，我们只需设置一个`error`字符串并返回`False`。
- en: That's all there is to it!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！
- en: Creating a Date widget
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建日期小部件
- en: 'Next, let''s apply the mixin class to the `DateEntry` class we made before,
    keeping the same validation algorithm. Add the following code just under the `RequiredEntry`
    class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将混合类应用到我们之前制作的`DateEntry`类上，保持相同的验证算法。在`RequiredEntry`类下方添加以下代码：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this class, we've once again simply overridden the `key` and `focus` validation
    methods, this time copying in the validation logic we used in our `DateEntry`
    widget from the previous section. The `_focusout_validate()` method also includes
    the logic from our `RequiredEntry` class too, since the `Date` value is required.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们再次简单地重写了`key`和`focus`验证方法，这次复制了我们之前在`DateEntry`小部件中使用的验证逻辑。`_focusout_validate()`方法也包括了`RequiredEntry`类的逻辑，因为日期值是必需的。
- en: Those classes were both pretty easy to create; let's move on to something a
    bit more intricate.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类都很容易创建；让我们继续做一些更复杂的事情。
- en: A better Combobox widget
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个更好的Combobox小部件
- en: 'The drop-down widgets in different toolkits or widget sets behave fairly consistently
    when it comes to mouse operation, but the response to keystrokes varies; for example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不同工具包或小部件集中的下拉小部件在鼠标操作方面表现相当一致，但按键响应各不相同；例如：
- en: Some do nothing, such as the Tkinter `OptionMenu`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些不做任何事情，例如Tkinter的`OptionMenu`
- en: Some require the use of arrow keys to select items, such as the Tkinter `ListBox`
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些需要使用箭头键来选择项目，例如Tkinter的`ListBox`
- en: Some move to the first entry that begins with any key pressed and cycle through
    entries beginning with that letter on subsequent presses
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些将列表缩小到以按下的任何键开头的第一个条目，并在后续按下时循环显示以该字母开头的条目
- en: Some narrow down the list to entries that match what's typed
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些将列表缩小到与输入的文本匹配的条目
- en: 'We need to think about what behavior our `Combobox` widget should have. Since
    our users are accustomed to doing data entry with the keyboard, and some have
    difficulty with the mouse, the widget needs to work well with the keyboard. Making
    them use repeated keystrokes to select options is not very intuitive, either.
    After talking with the data entry staff, you decide on this behavior:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑我们的`Combobox`小部件应该有什么行为。由于我们的用户习惯于使用键盘进行数据输入，并且有些人使用鼠标有困难，因此小部件需要与键盘很好地协同工作。让他们使用重复的按键来选择选项也不是很直观。在与数据输入人员交谈后，你决定采用以下行为：
- en: If the proposed text matches no entries, the keystroke will be ignored
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提议的文本与任何条目都不匹配，则忽略按键
- en: When the proposed text matches a single entry, the widget is set to that value
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提议的文本与单个条目匹配时，小部件被设置为该值
- en: A delete or backspace clears the entire box
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除或退格键清除整个框
- en: 'Let''s see if we can implement this with validation. Add another class after
    the `DateEntry` definition:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能否通过验证来实现这一点。在`DateEntry`定义之后添加另一个类：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `_key_validate()` method starts out by setting up a valid flag and doing
    a quick check to see if this is a delete action. If it is, we set the value to
    a blank string and return `True`. That takes care of the last requirement.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`_key_validate()`方法首先设置一个有效标志并快速检查这是否是一个删除操作。如果是，我们将值设置为空字符串并返回`True`。这样就处理了最后一个要求。'
- en: 'Now, we''ll add the logic to match the proposed text to our values:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加将提议文本与我们的值匹配的逻辑：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A copy of the widget's list of values is retrieved using its `cget()` method.
    Then, we use a list comprehension to reduce this list to only the entries that
    begin with the proposed text. To make matching case-insensitive, we're calling
    `lower()` on both the values in the list item and the proposed text before comparing
    them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小部件的`cget()`方法检索其值列表的副本。然后，我们使用列表推导来将此列表缩减到仅包含以提议文本开头的条目。为了使匹配不区分大小写，我们在比较之前在列表项中的值和提议文本上都调用`lower()`
- en: Every Tkinter widget supports the `cget()` method. It can be used to retrieve
    any of the widget's configuration values by name.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Tkinter小部件都支持`cget()`方法。它可以用来通过名称检索小部件的任何配置值。
- en: If the length of the matching list is `0`, nothing starts with the typed value
    and we reject the keystroke. If it's `1`, we've found our match, so we'll set
    the variable to that value. This is done by calling the widget's `set()` method
    and passing in the matching value. As a final touch, we'll send the cursor to
    the end of the field using the combo box's `.icursor()`. This isn't strictly necessary,
    but it looks better than leaving the cursor in the middle of the text. Note that
    we set `valid` to `False` even though the value matched successfully; since we
    are setting the value ourselves to the matching item, we want to stop any further
    input to the widget. Otherwise, the proposed keystroke would be appended to the
    end of the value we set, creating an invalid input.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配列表的长度为`0`，则没有以输入值开头的项，我们将拒绝按键。如果它是`1`，我们就找到了匹配项，因此我们将变量设置为该值。这是通过调用小部件的`set()`方法并传递匹配值来完成的。作为最后的润色，我们将使用组合框的`.icursor()`将光标移至字段的末尾。这并不是严格必要的，但看起来比将光标留在文本中间要好。注意，尽管值匹配成功，我们仍然将`valid`设置为`False`；由于我们正在将值自行设置为匹配项，我们希望停止任何进一步的输入到小部件。否则，建议的按键将被附加到我们设置的值的末尾，从而创建一个无效的输入。
- en: Also note that if our matching list contains more than one value, the method
    will just return `True`, allowing the user to continue typing and filtering the
    list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果我们的匹配列表包含多个值，该方法将仅返回`True`，允许用户继续输入并过滤列表。
- en: 'Next, let''s add the `focusout` validator:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加`focusout`验证器：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We don't have to do much here, because the key validation method ensures that
    the only possible values are a blank field or an item from the `values` list,
    but since all fields require a value, we'll copy in the validation logic from
    `RequiredEntry`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不需要做太多，因为键验证方法确保唯一可能的值是空白字段或`values`列表中的项，但由于所有字段都需要值，我们将从`RequiredEntry`复制验证逻辑。
- en: That takes care of our `Combobox` widget. Next, we'll deal with the `Spinbox`
    widget.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就处理好了`Combobox`小部件。接下来，我们将处理`Spinbox`小部件。
- en: A range-limited Spinbox widget
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个范围受限的Spinbox小部件
- en: A number entry seems like it shouldn't be too complicated to deal with, but
    there are several subtleties to work through to make it bulletproof. In addition
    to limiting the field to valid number strings, you'll want to enforce the `from_`,
    `to`, and `increment` arguments as the minimum, maximum, and precision of the
    input, respectively.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 数字输入看起来似乎处理起来不会太复杂，但有一些细微之处需要处理以确保其健壮性。除了限制字段为有效的数字字符串外，你还需要强制执行`from_`、`to`和`increment`参数分别为输入的最小值、最大值和精度。
- en: 'The algorithm needs to implement the following rules:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 算法需要实现以下规则：
- en: Deletion is always allowed
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除总是允许的
- en: Digits are always allowed
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字总是允许的
- en: If `from_` is less than 0, a minus is allowed as the first character
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`from_`小于0，允许负号作为第一个字符
- en: If `increment` has a decimal component, one (and only one) dot is allowed
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`increment`有小数部分，则允许一个（且仅一个）点
- en: If the proposed value is greater than the `to` value, ignore the keystroke
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果建议的值大于`to`值，则忽略按键
- en: If the proposed value requires more precision than `increment`, ignore the keystroke
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果建议的值需要比`increment`更高的精度，则忽略按键
- en: On `focusout`, make sure the value is a valid number string
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`focusout`时，确保值是一个有效的数字字符串
- en: Also on `focusout`, make sure the value is greater than the `from_` value
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`focusout`时，确保值大于`from_`值
- en: 'This is a lot of rules, so let''s proceed slowly as we try to implement them.
    The first thing we''ll want to do is import the `Decimal` class from the standard
    library. At the top of the file, add the following to the end of the import list:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多规则，所以让我们慢慢来，在尝试实现它们的过程中。我们首先想要做的是从标准库中导入`Decimal`类。在文件顶部，将以下内容添加到导入列表的末尾：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Decimal` class helps our decimal values be a bit more precise than the
    built-in `float` class, and also makes converting between numbers and strings
    a bit easier. `InvalidOperation` is a decimal-specific exception we can use in
    our validation logic.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decimal`类帮助我们的十进制值比内置的`float`类更精确，并且也使得在数字和字符串之间进行转换变得更容易。`InvalidOperation`是我们可以在验证逻辑中使用的特定于十进制的异常。'
- en: 'Now, let''s add a new `ValidatedSpinbox` class under the `ValidatedCombobox`
    class, like so:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`ValidatedCombobox`类下添加一个新的`ValidatedSpinbox`类，如下所示：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We start by overriding the `__init__()` method so that we can specify some
    defaults and grab the `from_`, `to`, and `increment` values from the initializer
    arguments for use in establishing our validation rules. Note that we have set
    defaults for `to` and `from_`: `-Infinity` and `Infinity`. Both `float` and `Decimal`
    will happily accept these values and treat them as you''d expect them to do. Recall
    that if we specify one limit, we must also specify the other. Adding these defaults
    allows us to only specify the one we need, and our `Spinbox` will act as we expect
    it to.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过重写`__init__()`方法来指定一些默认值，并从初始化参数中获取`from_`、`to`和`increment`值，以便在建立验证规则时使用。请注意，我们已经为`to`和`from_`设置了默认值：`-Infinity`和`Infinity`。`float`和`Decimal`都乐意接受这些值，并按你期望的方式处理它们。回想一下，如果我们指定一个限制，我们必须也指定另一个。添加这些默认值允许我们只指定所需的那个，并且我们的`Spinbox`将按预期工作。
- en: Once we have run the superclass's initializer method, we're going to figure
    out the precision value; that is, the number of digits we want to the right of
    the decimal.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行了超类初始化方法，我们将确定精度值；即我们希望小数点右边的数字位数。
- en: To do this, we're first going to retrieve the `increment` value from the keyword
    arguments, using `1.0` if it's not specified. We then convert this value to a
    `Decimal` object. Why do this? The `Spinbox` widget's arguments can be passed
    in as floats, integers, or strings. Regardless of how you pass them in, Tkinter
    converts them to floats when the `Spinbox` initializer is run. Determining the
    precision of a float is problematic because of floating-point error, so we want
    to convert it to a Python `Decimal` before it becomes a float.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先从关键字参数中检索`increment`值，如果没有指定，则使用`1.0`。然后我们将此值转换为`Decimal`对象。为什么要这样做？`Spinbox`小部件的参数可以是浮点数、整数或字符串。无论你如何传递它们，Tkinter都会在`Spinbox`初始化器运行时将它们转换为浮点数。由于浮点数错误，确定浮点数的精度是有问题的，所以我们希望在它成为浮点数之前将其转换为Python的`Decimal`。
- en: What is a floating-point error? Floats attempt to represent decimal numbers
    in binary form. Open a Python shell and enter `1.2 / 0.2`. You might be surprised
    to find the answer is `5.999999999999999` rather than `6`. This is a result of
    calculations being done on binary numbers rather than decimal numbers, and it's
    a source of computation error in nearly every programming language. Python offers
    us the `Decimal` class, which takes a numeric string and stores it in a way that
    makes mathematical operations safe from floating-point errors.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是浮点数错误？浮点数试图以二进制形式表示十进制数。打开Python壳，并输入`1.2 / 0.2`。你可能会惊讶地发现答案是`5.999999999999999`而不是`6`。这是在二进制数上而不是在十进制数上进行计算的结果，并且是几乎所有编程语言中的计算错误来源。Python为我们提供了`Decimal`类，它接受一个数字字符串并将其以使数学运算免受浮点数错误影响的方式存储。
- en: Notice that we cast `increment` to `str` before passing it to `Decimal`. Ideally,
    we should pass `increment` to our widget as a string to ensure it will be interpreted
    correctly, but if we need to pass in a float for some reason, `str` will do some
    sensible rounding first.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在将`increment`传递给`Decimal`之前将其转换为`str`。理想情况下，我们应该将`increment`作为字符串传递给我们的小部件以确保它被正确解释，但如果出于某种原因需要传递一个浮点数，`str`将首先进行一些合理的舍入。
- en: Having converted `increment` to a `Decimal` object, we can extract its precision
    value by taking the exponent of the smallest valid decimal place. We'll use this
    value in the validation method to make sure our entered data doesn't have too
    many decimal places.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将`increment`转换为`Decimal`对象后，我们可以通过取最小有效小数位的指数来提取其精度值。我们将在验证方法中使用这个值来确保我们输入的数据没有太多小数位。
- en: Our constructor is now settled, so let's write the validation methods. The `_key_validate()`
    method is a bit tricky, so we'll walk through it chunk by chunk.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小部件构造器现在已经确定，所以让我们编写验证方法。`_key_validate()`方法有点棘手，所以我们将分块进行讲解。
- en: 'First, we start the method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始这个方法：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, because deletion should always work, we'll return `True` immediately
    if the action is a deletion. After that, we retrieve the `from_` and `to` values
    using `cget()` and declare some flag variables to indicate if negatives and decimals
    should be allowed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，因为删除操作应该始终有效，所以如果操作是删除，我们将立即返回`True`。之后，我们使用`cget()`获取`from_`和`to`的值，并声明一些标志变量来指示是否允许负数和小数。
- en: 'Next, we need to test if the proposed keystroke is a valid character:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要测试所提出的按键是否是一个有效的字符：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Valid characters are digits, the `-` symbol, and the decimal (`.`). The minus
    sign is only valid at index `0`, and only when negative numbers are allowed. The
    decimal can only appear once, and only if our precision is less than `1`. We've
    put all these conditions in a list and passed it to the built-in `any()` function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的字符是数字、`-` 符号和十进制（`.`）。减号仅在索引 `0` 处有效，并且仅当允许负数时有效。小数只能出现一次，并且只有当我们的精度小于 `1`
    时才有效。我们将所有这些条件放入一个列表中，并将其传递给内置的 `any()` 函数。
- en: The built-in `any()` function takes a list of expressions and returns `True`
    if any one of the expressions in the list is true. There's also an `all()` function
    that returns `True` only if every expression in the list is true. These functions
    allow you to condense a long chain of Boolean expressions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `any()` 函数接受一个表达式列表，如果列表中的任何一个表达式为真，则返回 `True`。还有一个 `all()` 函数，只有当列表中的所有表达式都为真时才返回
    `True`。这些函数允许你压缩一长串布尔表达式。
- en: We're almost guaranteed at this point to have a valid `Decimal` string, but
    not quite; we might have just the `-`, `.`, or `-.` characters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎可以肯定有一个有效的 `Decimal` 字符串，但还不完全确定；我们可能只有 `-`、`.` 或 `-.` 这些字符。
- en: 'Those are not valid `Decimal` strings, but they are valid *partial* entries,
    so we should allow them. This code will check for those combinations and allow
    them:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是有效的 `Decimal` 字符串，但它们是有效的 *部分* 输入，因此我们应该允许它们。此代码将检查这些组合并允许它们：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we have not yet returned at this point, the proposed text can only be a
    valid `Decimal` string, so we''ll make a `Decimal` from it and do some final tests:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在此点还没有返回，则提议的文本只能是一个有效的 `Decimal` 字符串，因此我们将从它创建一个 `Decimal` 对象并进行一些最终测试：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Our last two tests check to see whether the proposed text is either greater
    than our maximum value or has more precision than the increment that we specified
    (the reason we use a `<` operator here is because precision is given as a negative
    value for decimal places). Finally, in case nothing has been returned yet, we
    return the `valid` value.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的两个测试是检查提议的文本是否大于我们的最大值，或者比我们指定的增量（我们在这里使用 `<` 操作符的原因是精度以负值表示小数位数）有更多的精度。最后，如果没有返回任何内容，我们将返回
    `valid` 值。
- en: 'That takes care of key validation; our focus-out validator is much simpler,
    as you can see:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这就处理了键验证；我们的焦点外验证器要简单得多，如下所示：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With the entire intended value at our disposal, we only need to make sure it's
    a valid `Decimal` string and within the specified value range. In theory, our
    key validation should have prevented an invalid decimal string or high value from
    being entered, but it doesn't hurt to check regardless.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拥有整个预期值的情况下，我们只需要确保它是一个有效的 `Decimal` 字符串，并且处于指定的值范围内。从理论上讲，我们的键验证应该阻止无效的十进制字符串或高值被输入，但进行检查并无害处。
- en: With that method completed, our `ValidatedSpinbox` is ready to go.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 完成该方法后，我们的 `ValidatedSpinbox` 就可以使用了。
- en: Validating Radiobutton widgets
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证 Radiobutton 小部件
- en: Validating `Radiobutton` widgets may seem initially pointless since the widget
    itself can only be on or off; however, validating a *group* of buttons can be
    quite useful in some situations. For example, in our ABQ data form, the Lab field
    is required to have a value, but currently the user can submit a record without
    clicking on one of the options.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 `Radiobutton` 小部件可能一开始看起来毫无意义，因为小部件本身只能处于开启或关闭状态；然而，在某些情况下，验证一组按钮可能非常有用。例如，在我们的
    ABQ 数据表单中，实验室字段必须有一个值，但当前用户可以提交一个记录而不点击任何一个选项。
- en: To fix this, we're going to create a new class that will represent a group of
    buttons and add validation code to this compound widget.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将创建一个新的类来表示一组按钮，并将验证代码添加到这个复合小部件中。
- en: Unfortunately, our mixin class cannot help us here as neither our compound widget
    nor Ttk `Radiobutton` widgets can support the `validate`, `validatecommand`, or
    `invalidcommand` arguments. Therefore, we'll have to implement validation of the
    button group without help from Tkinter's validation system.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的混合类在这里帮不上忙，因为我们的复合小部件和 Ttk `Radiobutton` 小部件都不支持 `validate`、`validatecommand`
    或 `invalidcommand` 参数。因此，我们将不得不在没有 Tkinter 验证系统帮助的情况下实现按钮组的验证。
- en: 'To begin, we''ll subclass `ttk.Frame` to build the compound widget on:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将对 `ttk.Frame` 进行子类化，以构建复合小部件：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The initializer for this class takes a number of keyword values:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的初始化器接受多个关键字参数：
- en: '`variable` will be the control variable for the group''s value. If not passed
    in, it will be created by the class.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variable` 将是控制该组值的控制变量。如果没有传入，它将由该类创建。'
- en: '`error_var` is a control variable for the error string. Just as with our other
    validated classes, we have allowed the possibility of accepting a `StringVar`
    control variable to hold the error string, or we just create one if one wasn''t
    passed in, saving it as `self.error`.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error_var` 是错误字符串的控制变量。正如我们其他已验证的类一样，我们允许接受一个 `StringVar` 控制变量来保存错误字符串，或者如果没有传入，我们创建一个，将其保存为
    `self.error`。'
- en: '`values` will be a list containing the string values that each button in the
    group represents.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values` 将是一个包含每个按钮在组中代表的字符串值的列表。'
- en: '`button_args` will be a dictionary of keyword arguments that we can pass to
    the individual `Radiobutton` widgets. This will allow us to pass arguments to
    the buttons separately from the `Frame` container.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`button_args` 将是一个关键字参数的字典，我们可以将其传递给单个 `Radiobutton` 小部件。这将允许我们单独从 `Frame`
    容器传递参数给按钮。'
- en: 'The remaining positional and keyword arguments are passed to the superclass
    initializer. After saving the keyword values to instance variables, we''ll next
    create the buttons like so:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的位置参数和关键字参数被传递给超类初始化器。在将关键字值保存到实例变量之后，我们将创建按钮，如下所示：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Just as we did in the `LabelInput` initializer, we are iterating through the
    `values` list, creating a `Radiobutton` widget for each value, and binding it
    to the common control variable. Each one is packed onto the `Frame` from the left
    side of the widget.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 `LabelInput` 初始化器中所做的那样，我们正在遍历 `values` 列表，为每个值创建一个 `Radiobutton` 小部件，并将其绑定到公共控制变量。每个小部件都从小部件的左侧开始填充到
    `Frame` 中。
- en: 'To finish the initializer, we need to trigger a validation callback whenever
    the `Frame` widget loses focus. To do that, we can just use `bind()`, like so:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成初始化器，我们需要在 `Frame` 小部件失去焦点时触发验证回调。为此，我们可以简单地使用 `bind()`，如下所示：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, whenever the widget loses focus, the validation callback will be called.
    Let''s write that callback next:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当小部件失去焦点时，验证回调将被调用。让我们接下来编写这个回调：
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This method will begin by setting the error variable to an empty string and
    then simply check if our bound variable contains a value. If it's empty, the error
    string is populated.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先将错误变量设置为空字符串，然后简单地检查我们的边界变量是否包含值。如果它是空的，错误字符串将被填充。
- en: Before we can use this compound widget with our application, we'll need to make
    one minor change to the `LabelInput` class. Remember that `LabelInput` makes sure
    that the correct control variable keyword argument gets passed into the widget
    initializer. We need to make sure our new compound widget class is getting the
    correct keyword (`variable`, in this case).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用这个复合小部件与我们的应用程序一起使用之前，我们需要对 `LabelInput` 类进行一个小修改。记住，`LabelInput` 确保正确的控制变量关键字参数被传递到小部件初始化器中。我们需要确保我们的新复合小部件类得到正确的关键字（在这种情况下是
    `variable`）。
- en: 'Update the `LabelInput` initializer like so:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `LabelInput` 初始化器如下：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With that, the `ValidatedRadio` widget should be ready to use!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，`ValidatedRadio` 小部件应该准备好使用了！
- en: Updating our form with validated widgets
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的表单以使用验证小部件
- en: 'Now that our widgets are all made, it''s time to make use of them in our form
    GUI. In `data_entry_app.py`, scroll down to the `DataRecordForm` class''s `__init__()`
    method, and we''ll start updating our widgets one row at a time. Line 1 is fairly
    straightforward:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经制作了所有小部件，是时候在我们的表单 GUI 中使用它们了。在 `data_entry_app.py` 中，滚动到 `DataRecordForm`
    类的 `__init__()` 方法，我们将逐行更新我们的小部件。第 1 行相当直接：
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It's as simple as swapping out the `input_class` value in each `LabelInput`
    call with one of our new classes. Go ahead and run your application and try out
    the widgets. Try some different valid and invalid dates in the `DateEntry`, and
    see how the `ValidatedCombobox` widget works (`RequiredEntry` won't do much at
    this point since the only visible indication is red text, and there's no text
    to mark red if it's empty; we'll address that in the next section).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像在每个 `LabelInput` 调用中用我们新的类之一替换 `input_class` 值一样简单。继续运行你的应用程序并尝试这些小部件。在 `DateEntry`
    中尝试一些不同的有效和无效日期，看看 `ValidatedCombobox` 小部件是如何工作的（`RequiredEntry` 在这一点上不会做太多，因为唯一的可见指示是红色文本，如果没有文本标记为红色，那么它就是空的；我们将在下一节中解决这个问题）。
- en: 'Now let''s work on line 2, which includes the Lab, Plot, and Seed Sample inputs:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理第 2 行，它包括 Lab、Plot 和 Seed Sample 输入：
- en: '[PRE40]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: An astute reader might note that this shouldn't work, since our list of values
    contains integers, and the `ValidatedCombobox` widget's validation callback assumes
    the values are strings (for example, we run `lower()` on each item in the list,
    and compare the item to the proposed string). It turns out that Tkinter converts
    the items in the value list to strings implicitly as it converts the call to Tcl/Tk.
    This is good to be aware of as you're writing validation methods on fields containing
    numbers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一个敏锐的读者可能会注意到这不应该工作，因为我们的值列表包含整数，而 `ValidatedCombobox` 小部件的验证回调假定值是字符串（例如，我们在列表中的每个项上运行
    `lower()`，并将项与提议的字符串进行比较）。实际上，Tkinter 在将调用转换为 Tcl/Tk 时隐式地将值列表中的项转换为字符串。当你编写包含数字的字段的验证方法时，了解这一点是很好的。
- en: 'Great! Let''s move on now to the Environmental Data. We only need to update
    the number entries to `ValidatedSpinbox` widgets here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在让我们继续到环境数据。我们只需要更新这里的数字输入到 `ValidatedSpinbox` 小部件：
- en: '[PRE41]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Save and execute the script at this point and give the `ValidatedSpinbox` widget
    a try. You should find it impossible to enter values greater than the maximum
    or with more than two decimal places, and should also find the text turns red
    if you leave it less than the minimum.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在此点保存并执行脚本，并尝试使用 `ValidatedSpinbox` 小部件。你应该会发现无法输入大于最大值或超过两位小数的值，并且如果小于最小值，文本也会变成红色。
- en: 'Next, we''ll update the first row of Plant Data with more `ValidatedSpinbox`
    widgets:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新植物数据的第一行，添加更多的 `ValidatedSpinbox` 小部件：
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Save and run the form again; you should find that these widgets will not allow
    you to type a decimal place, since the increment is at the default (`1.0`).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并再次运行表单；你应该会发现这些小部件不允许你输入小数点，因为增量是默认的 (`1.0`)。
- en: All that remains is our last row of number inputs. Before we do those, however,
    let's address some issues of form widget interaction.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是我们最后一行数字输入。在我们做这些之前，让我们解决一些表单小部件交互的问题。
- en: Implementing validation interaction between form widgets
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现表单小部件之间的验证交互
- en: 'So far, we''ve used validation to create widgets that can validate based on
    the user''s input to that widget. However, sometimes widgets might need to validate
    based on the state of another widget on the form. We have two such examples on
    our form:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用验证来创建可以根据用户输入到该小部件的输入进行验证的小部件。然而，有时小部件可能需要根据表单上另一个小部件的状态进行验证。在我们的表单上有两个这样的例子：
- en: Our Height fields (Min Height, Med Height, and Max Height) should not allow
    a user to enter a Min Height that is greater than the other two fields, a Max
    Height that is less than the other two fields, nor a Med Height that is not between
    the other fields.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的高度字段（最小高度、中等高度和最大高度）不应允许用户输入一个大于其他两个字段的最小高度，一个小于其他两个字段的最大高度，或者一个不在其他字段之间的中等高度。
- en: Our Equipment Fault checkbox should disable entry of Environmental Data, since
    we do not want to record data suspected of being faulty.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的设备故障复选框应该禁用环境数据的输入，因为我们不希望记录被怀疑有故障的数据。
- en: Dynamically updating the Spinbox range
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态更新 Spinbox 范围
- en: To solve the problem with our Height fields, we're going to update our `ValidatedSpinbox`
    widget so that its ranges can be dynamically updated. To do this, we can use the
    variable tracing feature we learned about in *Chapter 4*, *Organizing Our Code
    with Classes*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们高度字段的问题，我们将更新我们的 `ValidatedSpinbox` 小部件，使其范围可以动态更新。为此，我们可以使用我们在 *第4章*，*使用类组织我们的代码*
    中学到的变量跟踪功能。
- en: Our strategy will be to allow optional `min_var` and `max_var` arguments to
    be passed into the `ValidatedSpinbox` class, and then set a trace on these variables
    to update the `ValidatedSpinbox` object's minimum or maximum values whenever the
    corresponding variable is changed. We'll also have a `focus_update_var` variable
    that will be updated with the `Spinbox` widget's value at focus-out time. This
    variable can then be passed in as the `min_var` or `max_var` variable to a second
    `ValidatedSpinbox` so that the first widget's value can alter the second's valid
    range.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略将是允许可选的 `min_var` 和 `max_var` 参数传递给 `ValidatedSpinbox` 类，然后对这些变量设置跟踪，以便在相应变量更改时更新
    `ValidatedSpinbox` 对象的最小值或最大值。我们还将有一个 `focus_update_var` 变量，该变量将在 `Spinbox` 小部件失去焦点时更新其值。然后，这个变量可以作为
    `min_var` 或 `max_var` 变量传递给第二个 `ValidatedSpinbox`，这样第一个小部件的值就可以改变第二个的有效范围。
- en: 'Let''s make these changes to our `ValidatedSpinbox`. To start, update the `ValidatedSpinbox.__init__()`
    method with our new keyword arguments as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `ValidatedSpinbox` 进行以下更改。首先，更新 `ValidatedSpinbox.__init__()` 方法，如下添加我们的新关键字参数：
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Some of our code for this feature is going to require that the `Spinbox` has
    a variable bound to it, so the next thing we''re going to do is make sure that
    happens; put this code at the end of `__init__()`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此功能的一些代码将需要 `Spinbox` 有一个变量绑定到它，所以接下来我们要确保这一点；将此代码放在 `__init__()` 的末尾：
- en: '[PRE44]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We start by retrieving the `textvariable` from the keyword arguments; if it's
    not set to anything, we'll just create a `DoubleVar` and make it our variable.
    We're storing a reference to the variable so we can use it easily in our instance
    methods.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从关键字参数中检索 `textvariable`；如果它没有设置任何值，我们将创建一个 `DoubleVar` 并将其作为变量。我们存储对变量的引用，以便我们可以在实例方法中轻松使用它。
- en: Note that this arrangement could cause problems if a variable is assigned later
    using `configure()`. This won't be a problem in our code, but if you're using
    this class in your own Tkinter programs, you may want to override `configure()`
    to make sure the variable reference is kept in sync.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果稍后使用 `configure()` 分配变量，这种安排可能会引起问题。在我们的代码中这不会是问题，但如果你在自己的 Tkinter 程序中使用这个类，你可能想要覆盖
    `configure()` 方法以确保变量引用保持同步。
- en: 'Next, still in `__init__()`, let''s set up our minimum and maximum variables:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，仍然在 `__init__()` 中，让我们设置我们的最小值和最大值变量：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we pass in either a `min_var` or `max_var` argument, the value is stored
    and a trace is configured. The callback for the trace points to an appropriately
    named private method.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递了 `min_var` 或 `max_var` 参数，则值将被存储并配置一个跟踪。跟踪的回调指向一个适当命名的私有方法。
- en: 'We''ll also need to store a reference to the `focus_update_var` argument and
    bind focus-out events to a method that will be used to update it. To do that,
    add the following code to `__init__()`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要存储对 `focus_update_var` 参数的引用，并将焦点离开事件绑定到一个将用于更新它的方法。为此，将以下代码添加到 `__init__()`
    中：
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `bind()` method can be called on any Tkinter widget, and it's used to connect
    widget events to a Python callable. Events can be keystrokes, mouse movements
    or clicks, focus events, window management events, and more.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()` 方法可以在任何 Tkinter 小部件上调用，它用于将小部件事件连接到 Python 可调用函数。事件可以是按键、鼠标移动或点击、焦点事件、窗口管理事件等。'
- en: 'Now, we need to add the callback methods for our `trace()` and `bind()` commands.
    We''ll start with the one that updates the `focus_update_var`, which we''ll call
    `_set_focus_update_var()`. Add it as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加 `trace()` 和 `bind()` 命令的回调方法。我们将从更新 `focus_update_var` 的那个开始，我们将称之为
    `_set_focus_update_var()`。如下添加：
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This method simply gets the widget's current value and, if there is a `focus_update_var`
    argument present in the instance, sets it to the same value. Note that we don't
    set the value if there's an error currently present on the widget, since it wouldn't
    make sense to update the value to something invalid.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法只是获取小部件的当前值，如果实例中存在 `focus_update_var` 参数，则将其设置为相同的值。请注意，如果小部件上当前存在错误，我们不会设置值，因为将值更新为无效内容是没有意义的。
- en: Also notice that the method takes an `event` argument. We don't use this argument,
    but it is necessary since this is a callback for a bind. When Tkinter calls a
    bind callback, it passes in an event object that contains information about the
    event that triggered the callback. Even if you aren't going to use this information,
    your function or method needs to be able to take this argument.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，该方法接受一个 `event` 参数。我们不使用此参数，但它是必要的，因为这是一个绑定回调。当 Tkinter 调用一个绑定回调时，它会传递一个包含触发回调的事件信息的事件对象。即使你不会使用这些信息，你的函数或方法也需要能够接受这个参数。
- en: 'Now, let''s create the callback for setting the minimum, starting with this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建设置最小值的回调，从以下内容开始：
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first thing this method does is retrieve the current value of the widget
    using `self.get()`. The reason we're doing this is because the `Spinbox` widget
    has the slightly annoying default behavior of correcting its value when the `to`
    or `from_` values are changed, moving too-low values to the `from_` value and
    too-high values to the `to` value. This kind of silent auto-correction might slip
    past the attention of our user and cause bad data to be saved.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的第一步是使用 `self.get()` 获取小部件的当前值。我们这样做的原因是因为 `Spinbox` 小部件有一个稍微令人烦恼的默认行为，即当
    `to` 或 `from_` 值改变时，它会自动纠正其值，将过低值移动到 `from_` 值，将过高值移动到 `to` 值。这种无声的自动纠正可能会逃过用户的注意，导致保存错误数据。
- en: What we would prefer is to leave the out-of-range value as-is and mark it as
    an error; so to work around the `Spinbox` widget, we're going to save the current
    value, change the configuration, and then put the original value back in the field.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更希望保留超出范围的值不变，并将其标记为错误；因此，为了绕过 `Spinbox` 小部件，我们将保存当前值，更改配置，然后将原始值放回字段。
- en: 'After storing the current value in `current`, we attempt to get the value of
    the `min_var` and set our widget''s `from_` value from it, like so:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在将当前值存储在 `current` 中后，我们尝试获取 `min_var` 的值，并使用它设置小部件的 `from_` 值，如下所示：
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There are several things that could go wrong here, such as a blank or invalid
    value in `min_var`, all of which should raise either a `tk.TclError` or a `ValueError`.
    In any case, we'll just do nothing, leaving the current minimum in place.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会出现几个问题，例如 `min_var` 中的空白或无效值，所有这些问题都应引发 `tk.TclError` 或 `ValueError`。在任何情况下，我们只是什么也不做，保留当前最小值不变。
- en: It's generally a bad idea to just silence exceptions; however, in this case,
    there's nothing we can reasonably do if the variable is bad except ignore it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，只是静默异常并不是一个好主意；然而，在这种情况下，如果变量有问题，我们除了忽略它外，合理地无法做任何事情。
- en: 'Now, we just need to write the `current` value that we saved back into the
    field, like so:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将保存的 `current` 值写回字段，如下所示：
- en: '[PRE50]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If `current` is empty, we just delete the contents of the field; otherwise,
    we set the input's variable to `current`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `current` 为空，我们只需删除字段的内容；否则，我们将输入的变量设置为 `current`。
- en: 'Finally, we''ll want to trigger the widget''s focus-out validation to see if
    the current value is acceptable in the new range; we can do that by calling our
    `trigger_focusout_validation()` method, like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将想要触发小部件的焦点退出验证，以查看当前值是否在新范围内可接受；我们可以通过调用我们的 `trigger_focusout_validation()`
    方法来实现，如下所示：
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `_set_maximum()` method will be identical to this method, except that it
    will update the `to` value using `max_var` instead. It is shown here:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`_set_maximum()` 方法将与这个方法相同，只是它将使用 `max_var` 更新 `to` 值。它在这里显示：'
- en: '[PRE52]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: That finishes our `ValidatedSpinbox` changes. Now we can implement the last
    line of our Plant Data with this new capability.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的 `ValidatedSpinbox` 变更。现在我们可以使用这种新功能实现植物数据中的最后一行。
- en: 'First, we''ll need to set up variables to store the minimum and maximum height,
    as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置变量来存储最小和最大高度，如下所示：
- en: '[PRE53]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Each variable is a `DoubleVar`, set to `-infinity` or `infinity`, effectively
    defaulting to no minimum or maximum. Our widgets won't be affected by the values
    of these variables until they're actually changed (triggering the trace callback),
    so they won't initially override the `to` or `from_` values entered into the widgets.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都是一个 `DoubleVar`，设置为 `-infinity` 或 `infinity`，实际上默认没有最小值或最大值。我们的小部件直到它们实际更改（触发跟踪回调）才会受到这些变量值的影响，因此它们最初不会覆盖小部件中输入的
    `to` 或 `from_` 值。
- en: Note that these need not be instance variables, as our widgets will store references
    to them.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些不需要是实例变量，因为我们的小部件将存储对它们的引用。
- en: 'Now, we''ll create the Min Height widget, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建最小高度小部件，如下所示：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We'll use `max_height_var` to update the maximum here, and set the `focus_update_var`
    to `min_height_var` so that entry into the Min Height widget will update the minimum
    height variable. We do not want to set a `min_var` on this field because its value
    represents the minimum for other fields.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `max_height_var` 来更新这里的高度，并将 `focus_update_var` 设置为 `min_height_var`，以便进入最小高度小部件将更新最小高度变量。我们不想在这个字段上设置
    `min_var`，因为它的值代表其他字段的最小值。
- en: 'Next, let''s update the Max Height widget:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新最大高度小部件：
- en: '[PRE55]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This time, we use our `min_height_var` variable to set the widget's minimum
    value and set the `max_height_var` to be updated with the widget's current value
    on focus-out. We do not set a `max_var` on this field since its value will represent
    the maximum and shouldn't be constrained beyond its initial limits.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用`min_height_var`变量设置部件的最小值，并将`max_height_var`设置为在焦点移出时更新部件的当前值。我们在这个字段上不设置`max_var`，因为它的值将代表最大值，不应该超出其初始限制。
- en: 'Finally, the Median Height field should be updated like so:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Median Height字段应该更新如下：
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we're setting the minimum and maximum values for the field from the `min_height_var`
    and `max_height_var` variables, respectively. We're not updating any variables
    from the Median Height field, although we could add additional variables and code
    here to make sure that Min Height couldn't go above it or Max Height below it.
    In most cases, it won't matter as long as the user is entering data in order since
    Median Height is last.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们分别从`min_height_var`和`max_height_var`变量设置字段的最低和最高值。我们不会更新Median Height字段的任何变量，尽管我们可以在这里添加额外的变量和代码，以确保Min
    Height不会超过它，Max Height不会低于它。在大多数情况下，只要用户按顺序输入数据，Median Height作为最后一个字段，这通常不会很重要。
- en: 'You might wonder why we don''t just use the bound variables from Min Height
    and Max Height to hold these values instead. If you try this, you''ll discover
    the reason: the bound variable updates as you type, which means your partial value
    instantly becomes the new maximum or minimum value. We''d rather wait until the
    user has committed to the value to update the ranges, and thus we created a separate
    variable that is only updated on focus-out.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们不直接使用Min Height和Max Height的绑定变量来保存这些值。如果你尝试这样做，你会发现原因：绑定变量会在你输入时更新，这意味着你的部分值会立即成为新的最大值或最小值。我们宁愿等到用户已经确认了值再更新范围，因此我们创建了一个单独的变量，它只在焦点移出时更新。
- en: Dynamic disabling of fields
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态禁用字段
- en: To implement the disabling of our Environment Data fields when the EquipmentFault
    checkbox is activated, we'll once again use control variable tracing. This time,
    however, instead of implementing it at the widget class level, we'll implement
    it in our compound widget, the `LabelInput`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在激活EquipmentFault复选框时禁用我们的环境数据字段，我们再次使用控制变量跟踪。然而，这一次，我们不是在部件类级别实现它，而是在我们的复合部件`LabelInput`中实现它。
- en: 'Locate the `LabelInput` class in your code, and let''s add a new keyword argument
    to its `__init__()` method:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中定位`LabelInput`类，并让我们向它的`__init__()`方法添加一个新的关键字参数：
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `disable_var` argument will allow us to pass in a Boolean control variable
    that will be monitored to determine if our field should be disabled. To make use
    of it, we''ll need to store it in the `LabelInput` instance and configure a trace.
    Add this code to the end of `LabelInput.__init__()`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`disable_var`参数将允许我们传递一个布尔控制变量，我们将监控该变量以确定我们的字段是否应该被禁用。为了使用它，我们需要将其存储在`LabelInput`实例中并配置一个跟踪。将以下代码添加到`LabelInput.__init__()`的末尾：'
- en: '[PRE58]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The trace is linked to an instance method called `_check_disable()`. This method
    will need to check the value of `disable_var` and take appropriate action with
    the `LabelInput` widget's input.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪链接到一个名为`_check_disable()`的实例方法。这个方法需要检查`disable_var`的值，并对`LabelInput`部件的输入采取适当的行动。
- en: 'Let''s implement the method in our `LabelInput` class like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`LabelInput`类中这样实现该方法：
- en: '[PRE59]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: First, our method uses `hasattr` to see if this `LabelInput` even has a `disable_var`.
    In theory, the method shouldn't even get called if it doesn't, since there would
    be no trace, but just to be sure, we'll check and simply return if the instance
    variable doesn't exist.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的方法使用`hasattr`来检查这个`LabelInput`是否有`disable_var`。从理论上讲，如果没有这个变量，方法甚至不应该被调用，因为没有跟踪，但为了保险起见，我们将检查并简单地返回，如果实例变量不存在。
- en: If we have a `disable_var`, we'll check its value to see if it's `True`. If
    it is, we disable the input widget. To disable an input widget, we need to configure
    its `state` property. The `state` property determines the current disposition
    of the widget. In this case, we want to disable it, so we can set `state` to the
    `tk.DISABLED` constant. That will have the effect of "graying out" our field and
    making it read-only. We also want to clear out any information in the disabled
    fields, to make sure the user understands no data will be recorded for these fields.
    So, we'll set the variable to an empty string.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有`disable_var`，我们将检查其值以确定它是否为`True`。如果是，我们将禁用输入小部件。要禁用输入小部件，我们需要配置其`state`属性。`state`属性决定了小部件的当前状态。在这种情况下，我们希望禁用它，因此可以将`state`设置为`tk.DISABLED`常量。这将使我们的字段变灰，使其只读。我们还希望清除禁用字段中的任何信息，以确保用户理解这些字段不会记录任何数据。因此，我们将变量设置为空字符串。
- en: If the `disable_var` is false, we need to re-enable the widget. To do that,
    we can just set its state to `tk.NORMAL`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`disable_var`为`false`，我们需要重新启用小部件。为此，我们只需将其状态设置为`tk.NORMAL`。
- en: The `state` property will be covered in more detail in *Chapter 9*, *Improving
    the Look with Styles and Themes*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`属性将在第9章*通过样式和主题改进外观*中更详细地介绍。'
- en: 'With that method written, we just need to update our Environmental Data fields
    with a `disable_var` variable. Scroll back to your `DataRecordForm.__init__()`
    method and find where we''ve created those fields. We''ll update them like so:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写了该方法之后，我们只需更新我们的环境数据字段，并添加一个`disable_var`变量。滚动到你的`DataRecordForm.__init__()`方法，找到我们创建这些字段的位置。我们将按如下方式更新它们：
- en: '[PRE60]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In each case, we've added the `disable_var` argument and set it to `self._vars['Equipment
    Fault']`. If you run the script now, you should find that checking the Equipment
    Fault box disables and clears these three fields, and unchecking it re-enables
    them.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们都添加了`disable_var`参数，并将其设置为`self._vars['Equipment Fault']`。如果你现在运行脚本，你应该会发现勾选设备故障框将禁用并清除这三个字段，取消勾选则重新启用它们。
- en: Our form is now much better at enforcing correct data and catching potential
    errors during data entry, but it's not quite user-friendly yet. Let's see what
    can be done about that in the next section.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形式现在在强制正确数据和在数据输入过程中捕获潜在错误方面做得更好，但还不是非常用户友好。让我们看看在下一节中我们能做些什么。
- en: Displaying errors
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示错误
- en: If you run the application, you may notice that while fields with the focus-out
    errors turn red, we don't get to see the actual error. This is a bit of a problem
    for user-friendliness, so let's see if we can fix it. Our plan will be to update
    the `LabelInput` compound widget with another `Label` that can display an error
    string in the event of an error.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你可能会注意到，虽然具有焦点丢失错误的字段变成了红色，但我们看不到实际的错误。这对用户体验来说有点问题，所以让我们看看我们能否解决这个问题。我们的计划是将`LabelInput`复合小部件更新为另一个可以显示错误字符串的`Label`。
- en: 'To implement this, first locate your `LabelInput` class. Add this code to the
    end of the `__init__()` method:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，首先定位你的`LabelInput`类。将以下代码添加到`__init__()`方法的末尾：
- en: '[PRE61]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we check to see if our input has an error variable, and if not, we create
    one. Our validated widgets should already have such a variable, but unvalidated
    widgets such as the `BoundText` widget used for the `Notes` field do not, so we
    need this check to make sure.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查输入是否有错误变量，如果没有，我们创建一个。经过验证的小部件应该已经有了这样的变量，但未经过验证的小部件，如用于`Notes`字段的`BoundText`小部件，则没有，因此我们需要这个检查来确保。
- en: Next, we're creating and placing a `Label` widget and binding the error variable
    to its `textvariable` argument. This will update the `Label` contents with whatever
    our widget's `error` variable contains as it is updated by the validation logic.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们正在创建并放置一个`Label`小部件，并将错误变量绑定到其`textvariable`参数。这将根据验证逻辑的更新来更新`Label`的内容。
- en: Save the application, run it, and try entering some bad data in the fields (for
    example, a low value in one of the `Spinbox` widgets). You should see an error
    pop up under the field when you focus the next field. Success!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 保存应用程序，运行它，并在字段中尝试输入一些错误数据（例如，在`Spinbox`小部件中的一个低值）。当你聚焦到下一个字段时，你应该会在字段下方看到一个错误弹出。成功！
- en: There is one small issue to fix, though. If you happen to be focused on an Environment
    Data field like Humidity when you click the Equipment Fault checkbox, an error
    will be left under the field. The reason is that clicking the checkbox causes
    the field to lose focus, triggering its validation. Meanwhile, the `_check_disable()`
    method sets its value to an invalid blank string, which the validation logic rejects.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有一个小问题需要修复。如果你在点击设备故障复选框时聚焦在环境数据字段，如湿度，那么该字段下将留下一个错误。原因是点击复选框会导致字段失去焦点，触发其验证。同时，`_check_disable()`方法将其值设置为无效的空字符串，验证逻辑会拒绝它。
- en: 'The solution is for us to clear the error string when we disable the field.
    In the `LabelInput._check_disable()` method, update the code like so:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在我们禁用字段时清除错误字符串。在`LabelInput._check_disable()`方法中，更新代码如下：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Run the application again and you should see the errors disappear when the checkbox
    is checked.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序，你应该会在复选框被选中时看到错误消失。
- en: Preventing form submission on error
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻止错误时表单提交
- en: The final step in preventing errors from getting into our CSV file is to stop
    the application from saving the record if the form has known errors.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止错误进入我们的CSV文件的最后一步是停止应用程序在表单有已知错误时保存记录。
- en: Record saving happens in our `Application` object, so we need a way for that
    object to determine the error state of the form before it saves the data. That
    means our `DataRecordForm` will need a public method. We'll call that method `get_errors()`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 记录保存发生在我们的`Application`对象中，因此我们需要一种方法让该对象在保存数据之前确定表单的错误状态。这意味着我们的`DataRecordForm`将需要一个公共方法。我们将称此方法为`get_errors()`。
- en: 'At the end of the `DataRecordForm` class, add the following method:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DataRecordForm`类的末尾，添加以下方法：
- en: '[PRE63]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We begin by defining an empty `dict` object to store the errors. We''ll store
    our errors in the dictionary as `field: error_string` so that the calling code
    can be specific about the fields that have errors.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '我们首先定义一个空的`dict`对象来存储错误。我们将错误存储在字典中，格式为`field: error_string`，这样调用代码可以具体指定哪些字段有错误。'
- en: 'Recall that our `LabelInput` class attaches a reference to itself to the control
    variable passed into its `__init__()` method. We can use this reference now as
    we loop through our dictionary of variables. For each variable, we''ve done the
    following:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们的`LabelInput`类在其`__init__()`方法中将其自身引用附加到传入的控制变量上。现在我们可以使用这个引用来遍历我们的变量字典。对于每个变量，我们做了以下操作：
- en: We retrieve its input widget and the associated `error` variable from the `LabelWidget`
    reference
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`LabelWidget`引用中检索其输入小部件和相关的`error`变量。
- en: If the input defines a `trigger_focusout_validation()` method, we call it, just
    to be sure that its value has been validated
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入定义了`trigger_focusout_validation()`方法，我们调用它，以确保其值已被验证。
- en: If the value is invalid, that should populate the error variable; so, if `error`
    is not empty, we add it to the `errors` dictionary
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值无效，这将填充错误变量；所以，如果`error`不为空，我们将其添加到`errors`字典中。
- en: After we've gone through all the fields, we can return the `errors` dictionary
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们遍历完所有字段后，我们可以返回`errors`字典。
- en: 'Now that we have a way to retrieve the form''s errors, we need to utilize it
    in the `Application` class''s `on_save()` method. Locate that method, and then
    add the following code to the beginning of the method:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了检索表单错误的方法，我们需要在`Application`类的`on_save()`方法中利用它。定位该方法，然后在方法的开头添加以下代码：
- en: '[PRE64]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Recall that our `Application` object stores a reference to the form in `self.recordform`.
    We can now retrieve its dictionary of errors by calling its `get_errors()` method.
    If the dictionary is not empty, we'll construct an error string by joining all
    its keys (that is, the field names) and appending them to an error message. This
    is then passed to the `status` control variable, causing it to be displayed in
    the status bar. Finally, we return from the method so that the remaining logic
    in `on_save()` is not executed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们的`Application`对象在`self.recordform`中存储了对表单的引用。现在我们可以通过调用其`get_errors()`方法来检索其错误字典。如果字典不为空，我们将通过连接所有键（即字段名称）并将它们附加到错误消息中来构造一个错误字符串。然后将其传递给`status`控制变量，使其在状态栏中显示。最后，我们从方法中返回，以便`on_save()`中的剩余逻辑不执行。
- en: 'Start the application and try it out by trying to save a blank form. You should
    get error messages in all fields and a message at the bottom telling you which
    fields have errors, as shown here:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并尝试保存一个空白表单。你应该会在所有字段中收到错误消息，并在底部显示一条消息，告诉你哪些字段有错误，如下所示：
- en: '![The application with all errors showing.](img/B17578_05_03.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![显示所有错误的程序。](img/B17578_05_03.png)'
- en: 'Figure 5.3: The application with all errors showing'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：显示所有错误的程序
- en: Automating input
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化输入
- en: Preventing users from entering bad data is one way to improve the quality of
    their output; another approach is to automate the entry of data wherever the values
    are predictable. Using our understanding of how the forms are likely to be filled
    out, we can insert values that are very likely to be correct for certain fields.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 防止用户输入错误数据是提高他们输出质量的一种方法；另一种方法是自动化数据输入，在这些地方值是可以预测的。利用我们对表单可能如何填写我们的理解，我们可以插入对于某些字段非常可能正确的值。
- en: Remember from *Chapter 2*, *Designing GUI Applications*, that the forms are
    nearly always recorded the same day that they're filled out, starting with Plot
    1 and going to Plot 20 in order for each paper form.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 从*第二章*，*设计GUI应用程序*中记住，表单几乎总是在填写当天记录的，从Plot 1开始，按顺序到Plot 20，以便每个纸质表单。
- en: 'Also remember that the Date, Time, Lab, and Technician values remain the same
    for each form that is filled in. That gives us the possibility of implementing
    some helpful automation, specifically:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，日期、时间、实验室和技术人员值对于每个填写的表单都是相同的。这给了我们实现一些有用自动化的可能性，具体如下：
- en: The current date can automatically be inserted in the Date field
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前日期可以自动插入到日期字段中
- en: If the previous Plot was not the last plot in the lab, we can increment its
    value and leave the Time, Technician, and Lab values the same
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上一个绘图不是实验室中的最后一个绘图，我们可以增加其值，同时保持时间、技术人员和实验室值不变
- en: Let's see how we can implement these changes for the users.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何为用户实现这些更改。
- en: Date automation
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期自动化
- en: Inserting the current date is an easy place to start. The place to do this is
    in the `DataRecordForm.reset()` method, which is called when the form is initialized
    and every time a record is saved to set up the form for a new record.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 插入当前日期是一个容易开始的地方。做这件事的地方是在`DataRecordForm.reset()`方法中，该方法在表单初始化时以及每次记录保存时被调用，以设置表单为新记录做准备。
- en: 'Update that method as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新该方法：
- en: '[PRE65]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After clearing the values of all the variables, we're going to get the current
    date in ISO format using `datetime.today().strftime()`, just as we do for the
    datestamp in `Application.on_save()`. Once we have that value, it's simply a matter
    of setting the `Date` variable to it.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在清除所有变量的值之后，我们将使用`datetime.today().strftime()`获取当前日期的ISO格式，就像我们在`Application.on_save()`中对日期戳所做的那样。一旦我们有了这个值，只需将其设置为`Date`变量即可。
- en: As a final touch, we should update the focus of the form to the next input that
    needs entry, in this case, the Time field. Otherwise, the user would have to manually
    tab through the Date field, which is already filled in. To do this, we have accessed
    the input widget associated with the `Time` variable by way of its `label_widget`
    member and called the widget's `focus()` method. This method gives the widget
    keyboard focus.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的润色，我们应该更新表单的焦点到下一个需要输入的输入字段，在这种情况下，是时间字段。否则，用户将不得不手动通过已经填写好的日期字段。为此，我们通过其`label_widget`成员访问与`Time`变量关联的输入小部件，并调用小部件的`focus()`方法。此方法给小部件提供键盘焦点。
- en: Automating Plot, Lab, Time, and Technician
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化绘图、实验室、时间和技术人员
- en: 'Handling Plot, Lab, Time, and Technician is a bit more complex. Our strategy
    will go something like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 处理绘图、实验室、时间和技术人员稍微复杂一些。我们的策略将类似于以下内容：
- en: Before clearing the data, store the Plot, Lab, Time, and Technician values.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在清除数据之前，存储绘图、实验室、时间和技术人员值。
- en: Clear all the values.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除所有值。
- en: If the stored Plot value is less than the last value (20), we'll put the Lab,
    Time, and Technician values back in the fields. We'll also increment the Plot
    value.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存储的绘图值小于最后一个值（20），我们将把实验室、时间和技术人员值放回字段中。我们还将增加绘图值。
- en: If the stored Plot value *is* the last value (or no value), leave those fields
    blank.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存储的绘图值*是*最后一个值（或没有值），则保留这些字段为空。
- en: 'Let''s begin to add this logic to the `reset()` method, as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下方式开始添加这个逻辑到`reset()`方法：
- en: '[PRE66]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Before anything else in `reset()`, we're going to get the values of the affected
    fields and save them. Note that we have put `plot` in a `try/except` block. In
    the event that the Plot input is blank, it will throw a `TclError`, since a blank
    string is an invalid integer string. In that case, we'll assign the plot to be
    a blank string and carry on.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `reset()` 方法中的任何其他操作之前，我们将获取受影响字段的值并将它们保存。注意，我们将 `plot` 放在一个 `try/except`
    块中。如果绘图输入为空，它将抛出一个 `TclError`，因为空字符串是一个无效的整数字符串。在这种情况下，我们将绘图赋值为空字符串并继续。
- en: We're also retrieving the list of possible plot values by accessing the Plot
    widget by way of the Plot variable's `label_widget` member. Since we know there
    are 20 plots in each lab, we could just hardcode a list of 1 to 20 here, but that
    kind of hardcoding of information is bad form; if plots are added or eliminated
    from the lab, we would have to scour our code for the number 20 to fix all the
    places where we'd made this assumption. It's far better to query the widget itself
    to find out its possible values.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过访问绘图变量的 `label_widget` 成员来检索可能的绘图值列表。由于我们知道每个实验室有20个绘图，我们在这里可以简单地硬编码一个从1到20的列表，但这种信息硬编码的方式是不好的；如果实验室中添加或删除了绘图，我们就必须遍历我们的代码以找到数字20，并修复所有基于这个假设的地方。查询小部件本身以获取其可能的值要更好。
- en: 'Next, at the end of this method (after clearing the fields and setting the
    date), let''s add this code to update the fields:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在清空字段并设置日期之后，让我们添加以下代码来更新字段：
- en: '[PRE67]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This code checks to see if the plot value is a blank string, `0`, or the last
    value in the list of plot values. If it's not, we start populating the automated
    fields. First Lab, Time, and Technician are populated with our stored values.
    Then we need to increment the Plot value.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查绘图值是否为空字符串、`0` 或绘图值列表中的最后一个值。如果不是，我们开始填充自动化字段。首先，实验室、时间和技术人员字段被填充为我们存储的值。然后我们需要增加绘图值。
- en: Plot *should* be an integer at this point, but because of Tkinter's habit of
    implicitly casting things to string, it's better to work with it as though it
    were not. So, instead of merely incrementing the value of Plot, we're instead
    going to retrieve its index from `plot_values` and increment that instead. Then
    we can set the value of the Plot variable to the incremented index.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，绘图应该是一个整数，但由于Tkinter隐式转换东西为字符串的习惯，最好像它不是整数一样处理它。因此，我们不是仅仅增加绘图值，而是从 `plot_values`
    中检索其索引并增加它。然后我们可以将绘图变量的值设置为增加后的索引。
- en: As a final touch, we will set the focus of the form to the Seed Sample input,
    just as we did previously with the Time input.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的润色，我们将表单的焦点设置到种子样本输入框，就像我们之前对时间输入框所做的那样。
- en: Our validation and automation code is complete, and the form is now ready for
    a trial run with our users. It's definitely an improvement over the CSV entry
    at this point and will help data entry to make quick work of those forms. Great
    work!
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的有效性和自动化代码已经完成，表单现在可以与我们的用户进行试验运行。与CSV输入相比，这确实是一个改进，并将帮助数据输入快速处理这些表单。干得好！
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The application has really come a long way. In this chapter, we learned about
    Tkinter validation, created a validation mixin class, and used it to create validated
    versions of the `Entry`, `Combobox`, and `Spinbox` widgets. We also learned how
    to validate widgets like `Radiobutton`, which don't support the built-in validation
    framework. We validated different kinds of data on keystrokes and focus events,
    and created fields that dynamically change state or update their constraints based
    on the values of related fields. Finally, we automated input on several fields
    to reduce the amount of manual data entry required by the user.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已经取得了很大的进步。在本章中，我们学习了Tkinter验证，创建了一个验证混合类，并使用它创建了`Entry`、`Combobox`和`Spinbox`小部件的验证版本。我们还学习了如何验证不支持内置验证框架的`Radiobutton`小部件。我们在按键和焦点事件上验证了不同类型的数据，并创建了根据相关字段值动态改变状态或更新其约束的字段。最后，我们在几个字段上自动化了输入，以减少用户所需的手动数据输入量。
- en: In the next chapter, we're going to prepare our code base for expansion by learning
    how to organize a large application for easier maintenance. More specifically,
    we'll learn about the MVC pattern and how to structure our code in multiple files
    for simpler maintenance. We'll also learn about version control software and how
    it can help us keep track of changes.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过学习如何组织大型应用程序以简化维护来为我们的代码库的扩展做准备。更具体地说，我们将了解MVC模式以及如何将我们的代码结构化到多个文件中以便于维护。我们还将学习版本控制软件以及它是如何帮助我们跟踪变更的。
