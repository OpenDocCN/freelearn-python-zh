["```py\n>>> type(\"Hello, world!\")\n<class 'str'>\n>>> type(42)\n<class 'int'> \n```", "```py\n>>> a_string_variable = \"Hello, world!\"\n>>> type(a_string_variable)\n<class 'str'>\n>>> a_string_variable = 42\n>>> type(a_string_variable)\n<class 'int'> \n```", "```py\n>>> def odd(n):\n...     return n % 2 != 0\n>>> odd(3)\nTrue\n>>> odd(4)\nFalse \n```", "```py\n>>> odd(\"Hello, world!\")\nTraceback (most recent call last):\n  File \"<doctestexamples.md[9]>\", line 1, in <module>\nodd(\"Hello, world!\")\n  File \"<doctestexamples.md[6]>\", line 2, in odd\n    return n % 2 != 0\nTypeError: not all arguments converted during string formatting \n```", "```py\n>>> def odd(n: int) -> bool:\n...     return n % 2 != 0 \n```", "```py\ndef odd(n: int) -> bool:\n    return n % 2 != 0\ndef main():\n    print(odd(\"Hello, world!\"))\nif __name__ == \"__main__\":\n    main() \n```", "```py\n% mypy â€“strict src/bad_hints.py \n```", "```py\nsrc/bad_hints.py:12: error: Function is missing a return type annotation\nsrc/bad_hints.py:12: note: Use \"-> None\" if function does not return a value\nsrc/bad_hints.py:13: error: Argument 1 to \"odd\" has incompatible type \"str\"; expected \"int\" \n```", "```py\nclass MyFirstClass: \n    pass \n```", "```py\n>>> a = MyFirstClass()\n>>> b = MyFirstClass()\n>>> print(a)\n<__main__.MyFirstClass object at 0xb7b7faec>\n>>> print(b)\n<__main__.MyFirstClass object at 0xb7b7fbac> \n```", "```py\n>>> a is b\nFalse \n```", "```py\nclass Point: \n    pass \np1 = Point() \np2 = Point() \np1.x = 5 \np1.y = 4 \np2.x = 3 \np2.y = 6 \nprint(p1.x, p1.y) \nprint(p2.x, p2.y) \n```", "```py\n5 4\n3 6 \n```", "```py\nclass Point: \n    def reset(self): \n        self.x = 0 \n        self.y = 0 \np = Point() \np.reset() \nprint(p.x, p.y) \n```", "```py\n0 0 \n```", "```py\n>>> p = Point() \n>>> Point.reset(p) \n>>> print(p.x, p.y) \n```", "```py\n>>> class Point:\n...     def reset():\n...         pass\n...\n>>> p = Point()\n>>> p.reset()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: reset() takes 0 positional arguments but 1 was given \n```", "```py\nimport math\nclass Point:\n    def move(self, x: float, y: float) -> None:\n        self.x = x\n        self.y = y\n    def reset(self) -> None:\n        self.move(0, 0)\n    def calculate_distance(self, other: \"Point\") -> float:\n        return math.hypot(self.x - other.x, self.y - other.y) \n```", "```py\n>>> point1 = Point()\n>>> point2 = Point()\n>>> point1.reset()\n>>> point2.move(5, 0)\n>>> print(point2.calculate_distance(point1))\n5.0\n>>> assert point2.calculate_distance(point1) == point1.calculate_distance(\n...    point2\n... )\n>>> point1.move(3, 4)\n>>> print(point1.calculate_distance(point2))\n4.47213595499958\n>>> print(point1.calculate_distance(point1))\n0.0 \n```", "```py\n>>> point = Point()\n>>> point.x = 5\n>>> print(point.x)\n5\n>>> print(point.y)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'Point' object has no attribute 'y' \n```", "```py\nclass Point:\n    def __init__(self, x: float, y: float) -> None:\n        self.move(x, y)\n    def move(self, x: float, y: float) -> None:\n        self.x = x\n        self.y = y\n    def reset(self) -> None:\n        self.move(0, 0)\n    def calculate_distance(self, other: \"Point\") -> float:\n        return math.hypot(self.x - other.x, self.y - other.y) \n```", "```py\npoint = Point(3, 5) \nprint(point.x, point.y) \n```", "```py\nclass Point:\n    def __init__(self, x: float = 0, y: float = 0) -> None:\n        self.move(x, y) \n```", "```py\nclass Point:\n    def __init__(\n        self, \n        x: float = 0, \n        y: float = 0\n    ) -> None:\n        self.move(x, y) \n```", "```py\nclass Point:\n    \"\"\"\n    Represents a point in two-dimensional geometric coordinates\n    >>> p_0 = Point()\n    >>> p_1 = Point(3, 4)\n    >>> p_0.calculate_distance(p_1)\n    5.0\n    \"\"\"\n    def __init__(self, x: float = 0, y: float = 0) -> None:\n        \"\"\"\n        Initialize the position of a new point. The x and y\n        coordinates can be specified. If they are not, the\n        point defaults to the origin.\n        :param x: float x-coordinate\n        :param y: float x-coordinate\n        \"\"\"\n        self.move(x, y)\n    def move(self, x: float, y: float) -> None:\n        \"\"\"\n        Move the point to a new location in 2D space.\n        :param x: float x-coordinate\n        :param y: float x-coordinate\n        \"\"\"\n        self.x = x\n        self.y = y\n    def reset(self) -> None:\n        \"\"\"\n        Reset the point back to the geometric origin: 0, 0\n        \"\"\"\n        self.move(0, 0)\n    def calculate_distance(self, other: \"Point\") -> float:\n        \"\"\"\n        Calculate the Euclidean distance from this point \n        to a second point passed as a parameter.\n        :param other: Point instance\n        :return: float distance\n        \"\"\"\n        return math.hypot(self.x - other.x, self.y - other.y) \n```", "```py\nHelp on class Point in module point_2:\nclass Point(builtins.object)\n |  Point(x: float = 0, y: float = 0) -> None\n |  \n |  Represents a point in two-dimensional geometric coordinates\n |  \n |  >>> p_0 = Point()\n |  >>> p_1 = Point(3, 4)\n |  >>> p_0.calculate_distance(p_1)\n |  5.0\n |  \n |  Methods defined here:\n |  \n |  __init__(self, x: float = 0, y: float = 0) -> None\n |      Initialize the position of a new point. The x and y\n |      coordinates can be specified. If they are not, the\n |      point defaults to the origin.\n |      \n |      :param x: float x-coordinate\n |      :param y: float x-coordinate\n |  \n |  calculate_distance(self, other: 'Point') -> float\n |      Calculate the Euclidean distance from this point\n |      to a second point passed as a parameter.\n |      \n |      :param other: Point instance\n |      :return: float distance\n |  \n |  move(self, x: float, y: float) -> None\n |      Move the point to a new location in 2D space.\n |      \n |      :param x: float x-coordinate\n |      :param y: float x-coordinate\n |  \n |  reset(self) -> None\n |      Reset the point back to the geometric origin: 0, 0\n |  \n |  ----------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  __dict__\n |      dictionary for instance variables (if defined)\n |  \n |  __weakref__\n |      list of weak references to the object (if defined) \n```", "```py\n>>> import database\n>>> db = database.Database(\"path/to/data\") \n```", "```py\n>>> from database import Database\n>>> db = Database(\"path/to/data\") \n```", "```py\n>>> from database import Database as DB\n>>> db = DB(\"path/to/data\") \n```", "```py\nfrom database import Database, Query \n```", "```py\nfrom database import * \n```", "```py\nsrc/\n +-- main.py\n +-- ecommerce/\n     +-- __init__.py\n     +-- database.py\n     +-- products.py\n     +-- payments/\n     |   +-- __init__.py\n     |   +-- common.py\n     |   +-- square.py\n     |   +-- stripe.py\n     +-- contact/\n         +-- __init__.py\n         +-- email.py \n```", "```py\n>>> import ecommerce.products\n>>> product = ecommerce.products.Product(\"name1\") \n```", "```py\n>>> from ecommerce.products import Product \n>>> product = Product(\"name2\") \n```", "```py\n>>> from ecommerce import products \n>>> product = products.Product(\"name3\") \n```", "```py\nfrom .database import Database \n```", "```py\nfrom ..database import Database \n```", "```py\nfrom ..contact.email import send_mail \n```", "```py\nfrom .database import db \n```", "```py\nfrom ecommerce import db \n```", "```py\nclass Database:\n    \"\"\"The Database Implementation\"\"\"\n    def __init__(self, connection: Optional[str] = None) -> None:\n        \"\"\"Create a connection to a database.\"\"\"\n        pass\ndatabase = Database(\"path/to/data\") \n```", "```py\nfrom ecommerce.database import database \n```", "```py\ndb: Optional[Database] = None\ndef initialize_database(connection: Optional[str] = None) -> None:\n    global db\n    db = Database(connection) \n```", "```py\ndef get_database(connection: Optional[str] = None) -> Database:\n    global db\n    if not db:\n        db = Database(connection) \n    return db \n```", "```py\nclass Point:\n    \"\"\"\n    Represents a point in two-dimensional geometric coordinates.\n    \"\"\"\n    pass\ndef main() -> None:\n    \"\"\"\n    Does the useful work.\n    >>> main()\n    p1.calculate_distance(p2)=5.0\n    \"\"\"\n    p1 = Point()\n    p2 = Point(3, 4)\n    print(f\"{p1.calculate_distance(p2)=}\")\nif __name__ == \"__main__\":\n    main() \n```", "```py\nfrom typing import Optional\nclass Formatter:\n    def format(self, string: str) -> str:\n        pass\ndef format_string(string: str, formatter: Optional[Formatter] = None) -> str:\n    \"\"\"\n    Format a string using the formatter object, which\n    is expected to have a format() method that accepts\n    a string.\n    \"\"\"\n    **class DefaultFormatter(Formatter):**\n        **\"\"\"Format a string in title case.\"\"\"**\n        **def format(self, string: str) -> str:**\n            **return str(string).title()**\n    if not formatter:\n        formatter = DefaultFormatter()\n    return formatter.format(string) \n```", "```py\n>>> hello_string = \"hello world, how are you today?\"\n>>> print(f\" input: {hello_string}\")\n input: hello world, how are you today?\n>>> print(f\"output: {format_string(hello_string)}\")\noutput: Hello World, How Are You Today? \n```", "```py\n% python -m pip install mypy \n```", "```py\ncd project_directory\npython -m venv env\nsource env/bin/activate    # on Linux or macOS\nenv/Scripts/activate.bat   # on Windows \n```", "```py\nclass Sample:\n    def __init__(\n        self,\n        sepal_length: float,\n        sepal_width: float,\n        petal_length: float,\n        petal_width: float,\n        species: Optional[str] = None,\n    ) -> None:\n        self.sepal_length = sepal_length\n        self.sepal_width = sepal_width\n        self.petal_length = petal_length\n        self.petal_width = petal_width\n        self.species = species\n        self.classification: Optional[str] = None\n    def __repr__(self) -> str:\n        if self.species is None:\n            known_unknown = \"UnknownSample\"\n        else:\n            known_unknown = \"KnownSample\"\n        if self.classification is None:\n            classification = \"\"\n        else:\n            classification = f\", {self.classification}\"\n        return (\n            f\"{known_unknown}(\"\n            f\"sepal_length={self.sepal_length}, \"\n            f\"sepal_width={self.sepal_width}, \"\n            f\"petal_length={self.petal_length}, \"\n            f\"petal_width={self.petal_width}, \"\n            f\"species={self.species!r}\"\n            f\"{classification}\"\n            f\")\"\n        ) \n```", "```py\n def classify(self, classification: str) -> None:\n        self.classification = classification\n    def matches(self) -> bool:\n        return self.species == self.classification \n```", "```py\n>>> from model import Sample\n>>> s2 = Sample(\n...     sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species=\"Iris-setosa\")\n>>> s2\nKnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species='Iris-setosa')\n>>> s2.classification = \"wrong\"\n>>> s2\nKnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species='Iris-setosa', classification='wrong') \n```", "```py\nclass Hyperparameter:\n    \"\"\"A hyperparameter value and the overall quality of the classification.\"\"\"\n    def __init__(self, k: int, training: \"TrainingData\") -> None:\n        self.k = k\n        self.data: weakref.ReferenceType[\"TrainingData\"] = weakref.ref(training)\n        self.quality: float \n```", "```py\n def test(self) -> None:\n        \"\"\"Run the entire test suite.\"\"\"\n        training_data: Optional[\"TrainingData\"] = self.data()\n        if not training_data:\n            raise RuntimeError(\"Broken Weak Reference\")\n        pass_count, fail_count = 0, 0\n        for sample in training_data.testing:\n            sample.classification = self.classify(sample)\n            if sample.matches():\n                pass_count += 1\n            else:\n                fail_count += 1\n        self.quality = pass_count / (pass_count + fail_count) \n```", "```py\nclass TrainingData:\n    \"\"\"A set of training data and testing data with methods to load and test the samples.\"\"\"\n    def __init__(self, name: str) -> None:\n        self.name = name\n        self.uploaded: datetime.datetime\n        self.tested: datetime.datetime\n        self.training: List[Sample] = []\n        self.testing: List[Sample] = []\n        self.tuning: List[Hyperparameter] = [] \n```", "```py\n def load(\n            self, \n            raw_data_source: Iterable[dict[str, str]]\n    ) -> None:\n        \"\"\"Load and partition the raw data\"\"\"\n        for n, row in enumerate(raw_data_source):\n            ... filter and extract subsets (See Chapter 6)\n            ... Create self.training and self.testing subsets \n        self.uploaded = datetime.datetime.now(tz=datetime.timezone.utc) \n```", "```py\n{\n    \"sepal_length\": 5.1, \n    \"sepal_width\": 3.5, \n    \"petal_length\": 1.4, \n    \"petal_width\": 0.2, \n    \"species\": \"Iris-setosa\"\n} \n```", "```py\ndef test(\n        self, \n        parameter: Hyperparameter) -> None:\n    \"\"\"Test this Hyperparameter value.\"\"\"\n    parameter.test()\n    self.tuning.append(parameter)\n    self.tested = datetime.datetime.now(tz=datetime.timezone.utc)\ndef classify(\n        self, \n        parameter: Hyperparameter, \n        sample: Sample) -> Sample:\n    \"\"\"Classify this Sample.\"\"\"\n    classification = parameter.classify(sample)\n    sample.classify(classification)\n    return sample \n```"]