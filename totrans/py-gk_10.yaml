- en: '*Chapter 7*: Multiprocessing, Multithreading, and Asynchronous Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：多进程、多线程和异步编程'
- en: We can write efficient and optimized code for faster execution time, but there
    is always a limit to the amount of resources available for the processes running
    our programs. However, we can still improve application execution time by executing
    certain tasks in parallel on the same machine or across different machines. This
    chapter will cover parallel processing or concurrency in Python for the applications
    running on a single machine. We will cover parallel processing using multiple
    machines in the next chapter. In this chapter, we focus on the built-in support
    available in Python for the implementation of parallel processing. We will start
    with the multithreading in Python followed by discussing the multiprocessing.
    After that, we will discuss how we can design responsive systems using asynchronous
    programming. For each of the approaches, we will design and discuss a case study
    of implementing a concurrent application to download files from a Google Drive
    directory.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写高效且优化的代码以加快执行时间，但程序运行过程中可用的资源量总是有限的。然而，我们仍然可以通过在相同机器或不同机器上并行执行某些任务来提高应用程序的执行时间。本章将涵盖在单台机器上运行的应用程序的并行处理或并发性。我们将在下一章中介绍使用多台机器进行并行处理。在本章中，我们关注
    Python 中用于实现并行处理的内置支持。我们将从 Python 中的多线程开始，然后讨论多进程。之后，我们将讨论如何使用异步编程设计响应式系统。对于每种方法，我们将设计并讨论一个并发应用程序以从
    Google Drive 目录下载文件的案例研究。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding multithreading in Python and its limitations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Python 中的多线程及其限制
- en: Going beyond a single CPU – implementing multiprocessing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越单个 CPU – 实现多进程
- en: Using asynchronous programming for responsive systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步编程实现响应式系统
- en: After completing this chapter, you will be aware of the different options for
    building multithreaded or multiprocessing applications using built-in Python libraries.
    These skills will help you to build not only more efficient applications but also
    build applications for large-scale users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将了解使用内置 Python 库构建多线程或多进程应用程序的不同选项。这些技能将帮助您构建不仅更高效的应用程序，还能构建面向大规模用户的应用程序。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的技术要求：
- en: Python 3 (3.7 or later)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3（3.7 或更高版本）
- en: A Google Drive account
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Google Drive 账户
- en: API key enabled for your Google Drive account
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的 Google Drive 账户启用了 API 密钥
- en: Sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter07](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter07).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在[https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter07](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter07)找到。
- en: We will start our discussion with multithreading concepts in Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从 Python 中的多线程概念开始讨论。
- en: Understanding multithreading in Python and its limitations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Python 中的多线程及其限制
- en: A thread is a basic unit of execution within an operating system process, and
    it consists of its own program counter, a stack, and a set of registers. An application
    process can be built using multiple threads that can run simultaneously and share
    the same memory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是操作系统进程中的一个基本执行单元，它包含自己的程序计数器、一个堆栈和一组寄存器。应用程序进程可以使用多个线程构建，这些线程可以同时运行并共享相同的内存。
- en: 'For multithreading in a program, all the threads of a process share common
    code and other resources, such as data and system files. For each thread, all
    its related information is stored as a data structure inside the operating system
    kernel, and this data structure is called the **Thread Control Block** (**TCB**).
    The TCB has the following main components:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序中的多线程，一个进程的所有线程共享公共代码和其他资源，例如数据和系统文件。对于每个线程，所有相关信息均存储在操作系统内核内部的数据结构中，这个数据结构称为**线程控制块（TCB**）。TCB
    具有以下主要组件：
- en: '**Program Counter (PC)**: This is used to track the execution flow of the program.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序计数器（PC）**：用于跟踪程序的执行流程。'
- en: '**System Registers (REG)**: These registers are used to hold variable data.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统寄存器（REG）**：这些寄存器用于存储变量数据。'
- en: '**Stack**: The stack is an array of registers that manages the execution history.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈**：堆栈是一个寄存器数组，用于管理执行历史。'
- en: 'The anatomy of a thread is exhibited in *Figure 7.1*, with three threads. Each
    thread has its own PC, a stack, and REG, but shares code and other resources with
    other threads:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的解剖结构在 *图 7.1* 中展示，有三个线程。每个线程都有自己的 PC、堆栈和 REG，但与其他线程共享代码和其他资源：
- en: '![Figure 7.1 – Multiple threads in a process'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 进程中的多个线程'
- en: '](img/B17189_07_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_07_01.jpg]'
- en: Figure 7.1 – Multiple threads in a process
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 进程中的多个线程
- en: The TCB also contains a thread identifier, the state of the thread (such as
    running, waiting, or stopped), and a pointer to the process it belongs to. Multithreading
    is an operating system concept. It is a feature offered through the system kernel.
    The operating system facilitates the execution of multiple threads concurrently
    in the same process context, allowing them to share the process memory. This means
    the operating system has full control of which thread will be activated, rather
    than the application. We need to underline this point for a later discussion comparing
    different concurrency options.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TCB 还包含一个线程标识符、线程状态（例如运行、等待或停止），以及指向它所属进程的指针。多线程是操作系统的一个概念。它是通过系统内核提供的一项功能。操作系统简化了在相同进程上下文中同时执行多个线程，使它们能够共享进程内存。这意味着操作系统完全控制哪个线程将被激活，而不是应用程序。我们需要强调这一点，以便在比较不同并发选项的后续讨论中提及。
- en: 'When threads are run on a single-CPU machine, the operating system actually
    switches the CPU from one thread to the other such that the threads appear to
    be running concurrently. Is there any advantage to running multiple threads on
    a single-CPU machine? The answer is yes and no, and it depends on the nature of
    the application. For applications running using only the local memory, there may
    not be any advantage; in fact, it is likely to exhibit lower performance due to
    the overhead of switching threads on a single CPU. But for applications that depend
    on other resources, the execution can be faster because of the better utilization
    of the CPU: when one thread is waiting for another resource, another thread can
    utilize the CPU.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程在单 CPU 机器上运行时，操作系统实际上会切换 CPU 从一个线程到另一个线程，使得线程看起来是并发运行的。在单 CPU 机器上运行多个线程有什么优势吗？答案是是和否，这取决于应用程序的性质。对于仅使用本地内存运行的应用程序，可能没有优势；实际上，由于在单个
    CPU 上切换线程的开销，它可能表现出更低的性能。但对于依赖于其他资源的应用程序，由于 CPU 的更好利用，执行可以更快：当一个线程等待另一个资源时，另一个线程可以利用
    CPU。
- en: When executing multiple threads on multiprocessors or multiple CPU cores, it
    is possible to execute them concurrently. Next, we will discuss the limitations
    of multithreaded programming in Python.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当在多处理器或多 CPU 核心上执行多个线程时，它们可以并发执行。接下来，我们将讨论 Python 多线程编程的限制。
- en: What is a Python blind spot?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Python 的盲点？
- en: From a programming perspective, multithreading is an approach to running different
    parts of an application concurrently. Python uses multiple kernel threads that
    can run the Python user threads. But the Python implementation (*CPython*) allows
    threads to access the Python objects through one global lock, which is called
    the **Global Interpreter Lock (GIL)**. In simple words, the GIL is a mutex that
    allows only one thread to use the Python interpreter at a time and blocks all
    other threads. This is necessary to protect the reference count that is managed
    for each object in Python from garbage collection. Without such protection, the
    reference count can get corrupted if it's updated by multiple threads at the same
    time. The reason for this limitation is to protect the internal interpreter data
    structures and third-party *C* code that is not thread safe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程的角度来看，多线程是同时运行应用程序不同部分的一种方法。Python 使用多个内核线程，可以运行 Python 用户线程。但 Python 实现（*CPython*）允许线程通过一个全局锁访问
    Python 对象，这个锁被称为 **全局解释器锁（GIL）**。简单来说，GIL 是一个互斥锁，它允许一次只有一个线程使用 Python 解释器，并阻止所有其他线程。这是必要的，以保护
    Python 中每个对象管理的引用计数，防止垃圾回收。如果没有这种保护，如果多个线程同时更新，引用计数可能会被破坏。这种限制的原因是为了保护内部解释器数据结构和不是线程安全的第三方
    *C* 代码。
- en: Important note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This GIL limitation does not exist in Jython and IronPython, which are other
    implementations of Python.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种全局解释器锁（GIL）的限制在 Jython 和 IronPython 中不存在，它们是 Python 的其他实现。
- en: 'This Python limitation may give us the impression that there is no advantage
    to writing multithreaded programs in Python. This is not true. We still can write
    code in Python that runs concurrently or in parallel, and we will see it in our
    case study. Multithreading can be beneficial in the following cases:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种Python限制可能会给我们一种印象，即编写Python多线程程序没有优势。这并不正确。我们仍然可以在Python中编写并发或并行运行的代码，我们将在我们的案例研究中看到这一点。在以下情况下，多线程可能是有益的：
- en: '**I/O bound tasks**: When working with multiple I/O operations, there is always
    room to improve performance by running tasks using more than one thread. When
    one thread is waiting for a response from an I/O resource, it will release the
    GIL and let the other threads work. The original thread will wake up as soon as
    the response arrives from the I/O resource.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I/O密集型任务**：当与多个I/O操作一起工作时，通过使用多个线程运行任务，总是有改进性能的空间。当一个线程正在等待I/O资源的响应时，它将释放GIL并让其他线程工作。原始线程将在I/O资源响应到达时立即唤醒。'
- en: '**Responsive GUI application**: For interactive GUI applications, it is necessary
    to have a design pattern to display the progress of tasks running in the background
    (for example, downloading a file) and also to allow a user to work on other GUI
    features while one or more tasks are running in the background. This is all possible
    by using separate threads for the actions initiated by a user through the GUI.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式GUI应用程序**：对于交互式GUI应用程序，有必要有一个设计模式来显示在后台运行的任务（例如，下载文件）的进度，并且允许用户在后台运行一个或多个任务的同时，工作在其他GUI功能上。所有这些都可以通过使用为用户通过GUI发起的操作创建的单独线程来实现。'
- en: '**Multiuser applications**: Threads are also a prerequisite for building multiuser
    applications. A web server and a file server are examples of such applications.
    As soon as a new request arrives in the main thread of such an application, a
    new thread is created to serve the request while the main thread at the back listens
    for a new request.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多用户应用程序**：线程也是构建多用户应用程序的先决条件。Web服务器和文件服务器是这样的应用程序的例子。一旦此类应用程序的主线程收到新的请求，就会创建一个新的线程来处理请求，而主线程在后台监听新的请求。'
- en: Before discussing a case study of a multithreaded application, it is important
    to introduce the key components of multithreaded programming in Python.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论多线程应用程序的案例研究之前，介绍Python多线程编程的关键组件是很重要的。
- en: Learning the key components of multithreaded programming in Python
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习Python多线程编程的关键组件
- en: Multithreading in Python allows us to run different components of a program
    concurrently. To create multiple threads of an application, we will use the Python
    `threading` module, and the main components of this module are described next.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的多线程允许我们并发运行程序的不同组件。为了创建应用程序的多个线程，我们将使用Python的`threading`模块，接下来将描述该模块的主要组件。
- en: We will start by discussing the `threading` module in Python first.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论Python中的`threading`模块。
- en: The threading module
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程模块
- en: The `threading` module comes as a standard module and provides simple and easy-to-use
    methods for building multiple threads of a program. Under the hood, this module
    uses the lower level `_thread` module, which was a popular choice of multithreading
    in the early version of Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading`模块是一个标准模块，它提供了简单且易于使用的多线程构建方法。在底层，此模块使用较低级别的`_thread`模块，这在Python早期版本中是多线程的一个流行选择。'
- en: To create a new thread, we will create an object of the `Thread` class that
    can take a function (to be executed) name as the `target` attribute and arguments
    to be passed to the function as the `args` attribute. A thread can be given a
    name that can be set at the time it is created using the `name` argument with
    the constructor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新线程，我们将创建一个`Thread`类的对象，该对象可以接受一个作为`target`属性要执行的功能名称，以及作为`args`属性传递给函数的参数。一个线程可以被赋予一个名称，可以在创建时使用构造函数的`name`参数来设置。
- en: After creating an object of the `Thread` class, we need to start the thread
    by using the `start` method. To make the main program or thread wait until the
    newly created thread object(s) finishes, we need to use the `join` method. The
    `join` method makes sure that the main thread (a calling thread) waits until the
    thread on which the `join` method is called completes its execution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Thread`类的对象之后，我们需要使用`start`方法启动线程。为了使主程序或线程等待新创建的线程对象完成，我们需要使用`join`方法。`join`方法确保主线程（调用线程）等待被调用`join`方法的线程完成其执行。
- en: 'To explain the process of creating, starting, and waiting to finish the execution
    of a thread, we will create a simple program with three threads. A complete code
    example of such a program is shown next:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释创建、启动和等待线程执行完成的过程，我们将创建一个包含三个线程的简单程序。下面展示了这样一个程序的完整代码示例：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this program, we implemented the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们实现了以下功能：
- en: We created two simple functions, `print_hello` and `print_message`, that are
    to be used by the threads. We used the `sleep` function from the `time` module
    in both functions to make sure that the two functions finish their execution time
    at different times.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了两个简单的函数`print_hello`和`print_message`，这些函数将由线程使用。我们在两个函数中都使用了`time`模块中的`sleep`函数，以确保两个函数在不同的时间完成它们的执行时间。
- en: We created three `Thread` objects. Two of the three objects will execute one
    function (`print_hello`) to illustrate the code sharing by the threads, and the
    third thread object will use the second function (`print_message`), which takes
    one argument as well.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了三个`Thread`对象。其中两个对象将执行一个函数（`print_hello`），以展示线程之间的代码共享，第三个线程对象将使用第二个函数（`print_message`），该函数也接受一个参数。
- en: We started all three threads one by one using the `start` method.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`start`方法逐个启动所有三个线程。
- en: We waited for each thread to finish by using the `join` method.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过使用`join`方法等待每个线程完成。
- en: 'The `Thread` objects can be stored in a list to simplify the `start` and `join`
    operations using a `for` loop. The console output of this program will look like
    this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将`Thread`对象存储在列表中，以简化使用`for`循环的`start`和`join`操作。该程序的控制台输出将如下所示：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Thread 1 and thread 2 have more sleep time than thread 3, so thread 3 will always
    finish first. Thread 1 and thread 2 can finish in any order depending on who gets
    hold of the processor first.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 线程1和线程2的睡眠时间比线程3长，因此线程3将始终先完成。线程1和线程2的完成顺序取决于哪个线程首先获得处理器。
- en: Important note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: By default, the `join` method blocks the caller thread indefinitely. But we
    can use a timeout (in seconds) as an argument to the `join` method. This will
    make the caller thread block only for the timeout period.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`join`方法会无限期地阻塞调用线程。但我们可以将超时时间（以秒为单位）作为`join`方法的参数。这将使调用线程仅在超时期间被阻塞。
- en: We will review a few more concepts before discussing a more complex case study.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论更复杂的案例研究之前，我们将回顾几个更多概念。
- en: Daemon threads
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 守护线程
- en: In a normal application, our main program implicitly waits until all other threads
    finish their execution. However, sometimes we need to run some threads in the
    background so that they run without blocking the main program from terminating
    itself. These threads are known as **daemon threads**. These threads stay active
    as long as the main program (with non-daemon threads) is running, and it is fine
    to terminate the daemon threads once the non-daemon threads exit. The use of daemon
    threads is popular in situations where it is not an issue if a thread dies in
    the middle of its execution without losing or corrupting any data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的应用程序中，我们的主程序会隐式地等待所有其他线程完成执行。然而，有时我们需要在后台运行一些线程，以便它们可以在不阻塞主程序终止的情况下运行。这些线程被称为**守护线程**。只要主程序（包含非守护线程）在运行，这些线程就会保持活跃状态，一旦非守护线程退出，就可以安全地终止守护线程。在不需要担心线程在执行过程中意外死亡而丢失或损坏数据的情况下，守护线程的使用非常普遍。
- en: 'A thread can be declared a daemon thread by using one of the following two
    approaches:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下两种方法之一将线程声明为守护线程：
- en: Pass the `daemon` attribute set to `True` with the constructor (`daemon = True`).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数将`daemon`属性设置为`True`（`daemon = True`）。
- en: Set the `daemon` attribute to `True` on the thread instance (`thread.daemon
    = True`).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程实例上设置`daemon`属性为`True`（`thread.daemon = True`）。
- en: If a thread is set as a daemon thread, we start the thread and forget about
    it. The thread will be automatically killed when the program that called it quits.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个线程被设置为守护线程，我们启动线程然后忘记它。当调用它的程序退出时，线程将被自动杀死。
- en: 'The next code shows the use of both daemon and non-daemon threads:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了同时使用守护线程和非守护线程的使用方法：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this code example, we created one daemon and one non-daemon thread. The
    daemon thread (`daeom_func`) is executing a function that has a sleep time of
    `3` seconds, whereas the non-daemon thread is executing a function (`nondaeom_func`)
    that has a sleep time of 1 second. The sleep time of the two functions is set
    to make sure the non-daemon thread finishes its execution first. The console output
    of this program is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们创建了一个守护线程和一个非守护线程。守护线程（`daeom_func`）正在执行一个睡眠时间为`3`秒的函数，而非守护线程正在执行一个睡眠时间为1秒的函数（`nondaeom_func`）。这两个函数的睡眠时间被设置为确保非守护线程首先完成其执行。该程序的输出控制台如下所示：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since we did not use a `join` method in any thread, the main thread exits first,
    and then the non-daemon thread finishes a bit later with a print message. But
    there is no print message from the daemon thread. This is because the daemon thread
    is terminated as soon as the non-daemon thread finishes its execution. If we change
    the sleep time in the `nondaeom_func` function to `5`, the console output will
    be as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有在任何线程中使用`join`方法，主线程首先退出，然后非守护线程稍后通过打印消息完成。但是守护线程没有打印消息。这是因为非守护线程在非守护线程完成执行后立即终止。如果我们将`nondaeom_func`函数中的睡眠时间改为`5`，控制台输出将如下所示：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By delaying the execution of the non-daemon thread, we make sure the daemon
    thread finished its execution and does not get terminated abruptly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过延迟非守护线程的执行，我们确保守护线程完成了其执行，并且不会突然终止。
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: If we use a `join` on the daemon thread, the main thread will be forced to wait
    for the daemon thread to finish its execution.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在守护线程上使用`join`，主线程将被迫等待守护线程完成其执行。
- en: Next, we will investigate how to synchronize the threads in Python.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何在Python中同步线程。
- en: Synchronizing threads
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步线程
- en: '**Thread synchronization** is a mechanism to ensure that the two or more threads
    do not execute a shared block of code at the same time. The block of code that
    is typically accessing shared data or shared resources is also known as the **critical
    section**. This concept can be made clearer through the following figure:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程同步**是一种机制，确保两个或更多线程不会同时执行共享代码块。通常访问共享数据或共享资源的代码块也称为**关键部分**。这个概念可以通过以下图示来解释得更清楚：'
- en: '![Figure 7.2 – Two threads accessing a critical section of a program'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – 两个线程访问程序的关键部分'
- en: '](img/B17189_07_02.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_07_02.jpg]'
- en: Figure 7.2 – Two threads accessing a critical section of a program
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 两个线程访问程序的关键部分
- en: Multiple threads accessing the critical section at the same time may try to
    access or change the data at the same time, which may result in unpredictable
    results on the data. This situation is called a **race condition**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同时访问关键部分的多个线程可能会尝试同时访问或更改数据，这可能会导致数据出现不可预测的结果。这种情况称为**竞态条件**。
- en: 'To illustrate the concept of the race condition, we will implement a simple
    program with two threads, and each thread increments a shared variable 1 million
    times. We chose a high number for the increment to make sure that we can observe
    the outcome of the race condition. The race condition may also be observed by
    using a lower value for the increment cycle on a slower CPU. In this program,
    we will create two threads that are using the same function (`inc` in this case)
    as the target. The code for accessing the shared variable and incrementing it
    by 1 occurs in the critical section, and the two threads are accessing it without
    any protection. The complete code example is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明竞态条件的概念，我们将实现一个简单的程序，其中包含两个线程，每个线程将共享变量增加1百万次。我们选择了一个较高的增加次数，以确保我们可以观察到竞态条件的结果。在较慢的CPU上，通过降低增加循环的值也可以观察到竞态条件。在这个程序中，我们将创建两个线程，它们使用相同的函数（在这种情况下是`inc`）作为目标。访问共享变量并将其增加1的代码发生在关键部分，并且两个线程都在没有任何保护的情况下访问它。完整的代码示例如下：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The expected value of `x` at the end of the execution is *2,000,000*, which
    will not be observed in the console output. Every time we execute this program,
    we will get a different value of `x` that's a lot lower than 2,000,000\. This
    is because of the race condition between the two threads. Let's look at a scenario
    where threads `Th 1` and `Th 2` are running the critical section (`x+=1`) at the
    same time. Both threads will ask for the current value of `x`. If we assume the
    current value of `x` is `100`, both threads will read it as `100` and increment
    it to a new value of `101`. The two threads will write back to the memory the
    new value of `101`. This is a one-time increment and, in reality, the two threads
    should increment the variable independently of each other and the final value
    of `x` should be `102`. How can we achieve this? This is where thread synchronization
    comes to the rescue.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结束时 `x` 的预期值是 *2,000,000*，这将在控制台输出中观察不到。每次我们执行这个程序时，我们都会得到一个比 2,000,000 低得多的
    `x` 值。这是因为两个线程之间的竞争条件。让我们看看线程 `Th 1` 和 `Th 2` 同时运行临界区 (`x+=1`) 的场景。两个线程都会请求 `x`
    的当前值。如果我们假设 `x` 的当前值是 `100`，两个线程都会读取它为 `100` 并将其增加到新的值 `101`。两个线程会将新的值 `101` 写回内存。这是一个一次性增加，实际上，两个线程应该独立于彼此增加变量，`x`
    的最终值应该是 `102`。我们如何实现这一点？这就是线程同步发挥作用的地方。
- en: 'Thread synchronization can be achieved by using a `Lock` class from the `threading`
    module. The lock is implemented using a `Lock` class provides two methods, `acquire`
    and `release`, which are described next:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `threading` 模块中的 `Lock` 类来实现线程同步。`Lock` 类通过提供 `acquire` 和 `release` 两个方法来实现锁，下面将进行描述：
- en: The `acquire` method is used to acquire a lock. A lock can be `unlocked`), then
    the lock is provided to the requesting thread to proceed. In the case of a non-blocking
    acquire request, the thread execution is not blocked. If the lock is available
    (`unlocked`), then the lock is provided (and `locked`) to the requesting thread
    to proceed, otherwise the requesting thread gets `False` as a response.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `acquire` 方法来获取锁。如果锁是 `unlocked`（未锁定）的，那么锁会被提供给请求的线程以继续执行。在非阻塞获取请求的情况下，线程执行不会被阻塞。如果锁可用（`unlocked`），则将锁提供给（并
    `locked`）请求的线程以继续执行，否则请求的线程会得到 `False` 作为响应。
- en: The `release` method is used to release a lock, which means it resets the lock
    to an `unlocked` state. If there is any thread blocking and waiting for the lock,
    it will allow one of the threads to proceed.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `release` 方法来释放锁，这意味着它将锁重置为 `unlocked` 状态。如果有任何线程正在阻塞并等待锁，它将允许其中一个线程继续执行。
- en: 'The `thread3a.py` code example is revised with the use of a lock around the
    increment statement on the shared variable `x`. In this revised example, we created
    a lock at the main thread level and then passed it to the `inc` function to acquire
    and release a lock around the shared variable. The complete revised code example
    is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread3a.py` 代码示例通过在共享变量 `x` 的增量语句周围使用锁进行了修改。在这个修改后的示例中，我们在主线程级别创建了一个锁，并将其传递给
    `inc` 函数以获取和释放围绕共享变量的锁。完整的修改后的代码示例如下：'
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After using the `Lock` object, the value of `x` is always `2000000`. The `Lock`
    object made sure that only one thread increments the shared variable at a time.
    The advantage of thread synchronization is that you can use system resources with
    enhanced performance and predictable results.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Lock` 对象后，`x` 的值总是 `2000000`。`Lock` 对象确保一次只有一个线程增加共享变量。线程同步的优势在于你可以使用系统资源，以增强性能和可预测的结果。
- en: However, locks have to be used carefully because improper use of locks can result
    in a deadlock situation. Suppose a thread acquires a lock on resource A and is
    waiting to acquire a lock on resource B. But another thread already holds a lock
    on resource B and is looking to acquire a lock resource A. The two threads will
    wait for each other to release the locks, but it will never happen. To avoid deadlock
    situations, the multithreading and multiprocessing libraries come with mechanisms
    such as adding a timeout for a resource to hold a lock, or using a context manager
    to acquire locks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，锁必须谨慎使用，因为不当使用锁可能导致死锁情况。假设一个线程在资源 A 上获取了锁并正在等待获取资源 B 的锁。但另一个线程已经持有资源 B 的锁并正在尝试获取资源
    A 的锁。这两个线程将等待对方释放锁，但这种情况永远不会发生。为了避免死锁情况，多线程和进程库提供了添加资源持有锁的超时时间等机制，或者使用上下文管理器来获取锁。
- en: Using a synchronized queue
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用同步队列
- en: The `Queue` module in Python implements multi-producer and multi-consumer queues.
    Queues are very useful in multithread applications when the information has to
    be exchanged between different threads safely. The beauty of the synchronized
    queue is that they come with all the required locking mechanisms, and there is
    no need to use additional locking semantics.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`Queue`模块实现了多生产者和多消费者队列。在多线程应用程序中，当需要在不同的线程之间安全地交换信息时，队列非常有用。同步队列的美丽之处在于它们自带所有必要的锁定机制，无需使用额外的锁定语义。
- en: 'There are three types of queues in the `Queue` module:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`模块中有三种类型的队列：'
- en: '**FIFO**: In the FIFO queue, the task added first is retrieved first.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FIFO**：在FIFO队列中，首先添加的任务首先被检索。'
- en: '**LIFO**: In the LIFO queue, the last task added is retrieved first.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LIFO**：在LIFO队列中，最后添加的任务首先被检索。'
- en: '**Priority queue**: In this queue, the entries are sorted and the entry with
    the lowest value is retrieved first.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先队列**：在此队列中，条目被排序，具有最低值的条目首先被检索。'
- en: These queues use locks to protect access to the queue entries from competing
    threads. The use of a queue with a multithreaded program is best illustrated with
    a code example. In the next example, we will create a FIFO queue with dummy tasks
    in it. To process the tasks from the queue, we will implement a custom thread
    class by inheriting the `Thread` class. This is another way of implementing a
    thread.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些队列使用锁来保护对队列条目的访问，防止来自竞争线程的访问。使用带有多线程程序的队列的最佳示例是代码示例。在下一个示例中，我们将创建一个包含虚拟任务的FIFO队列。为了从队列中处理任务，我们将通过继承`Thread`类来实现一个自定义线程类。这是实现线程的另一种方式。
- en: 'To implement a custom thread class, we need to override the `init` and `run`
    methods. In the `init` method, it is required to call the `init` method of the
    superclass (the `Thread` class). The `run` method is the execution part of the
    thread class. The complete code example is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个自定义线程类，我们需要重写`init`和`run`方法。在`init`方法中，需要调用超类（`Thread`类）的`init`方法。`run`方法是线程类的执行部分。完整的代码示例如下：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code example, we created five worker threads using the custom thread
    class (`MyThread`). These five worker threads access the queue to get the task
    item from it. After getting the task item, the threads sleep for 1 second and
    then print the thread name and the task name. For each `get` call for an item
    of a queue, a subsequent call of `task_done()` indicates that the processing of
    the task has been completed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我们使用自定义线程类（`MyThread`）创建了五个工作线程。这五个工作线程访问队列以从中获取任务项。获取任务项后，线程将休眠1秒钟，然后打印线程名称和任务名称。对于队列中每个项目的`get`调用，随后的`task_done()`调用表示已完成任务的处理。
- en: It is important to note that we used the `join` method on the `myqueue` object
    and not on the threads. The `join` method on the queue blocks the main thread
    until all items in the queue have been processed and completed (`task_done` is
    called for them). This is a recommended way to block the main thread when a queue
    object is used to hold the tasks' data for threads.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们是在`myqueue`对象上而不是在线程上使用`join`方法。队列上的`join`方法会阻塞主线程，直到队列中的所有项目都已被处理并完成（对它们调用`task_done`）。这是使用队列对象持有线程的任务数据时阻塞主线程的推荐方式。
- en: Next, we will implement an application to download files from Google Drive using
    the `Thread` class, the `Queue` class, and a couple of third-party libraries.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个应用程序，使用`Thread`类、`Queue`类和一些第三方库从Google Drive下载文件。
- en: Case study – a multithreaded application to download files from Google Drive
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 - 一个从Google Drive下载文件的多线程应用程序
- en: 'We have discussed in the previous section that multithreaded applications in
    Python stand out well when different threads are working on input and output tasks.
    That is why we selected to implement an application that downloads files from
    a shared directory of Google Drive. To implement this application, we will need
    the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个章节中，我们讨论了Python中的多线程应用程序在处理输入和输出任务时表现突出。这就是为什么我们选择实现一个从Google Drive共享目录下载文件的应用程序。为了实现此应用程序，我们需要以下内容：
- en: '**Google Drive**: A Google Drive account (a free basic account is fine) with
    one directory marked as shared.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Drive**：一个Google Drive账户（一个免费的基本账户即可），其中一个目录被标记为共享。'
- en: '**API key**: An API key to access Google APIs is required. The API key needs
    to be enabled to use the Google APIs for Google Drive. The API can be enabled
    by following the guidelines on the Google Developers site ([https://developers.google.com/drive/api/v3/enable-drive-api](https://developers.google.com/drive/api/v3/enable-drive-api)).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 密钥**：要访问 Google API，需要一个 API 密钥。需要启用 API 密钥才能使用 Google Drive 的 Google
    API。可以通过遵循 Google 开发者网站上的指南启用 API（[https://developers.google.com/drive/api/v3/enable-drive-api](https://developers.google.com/drive/api/v3/enable-drive-api)）。'
- en: '`pip` tool.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip` 工具。'
- en: '`pip` tool as well. There are other libraries available that offer the same
    functionality. We selected the `gdown` library for its ease of use.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以使用 `pip` 工具。还有其他库提供相同的功能。我们选择了 `gdown` 库，因为它易于使用。
- en: 'To use the `getfilelistpy` module, we need to create a resource data structure.
    This data structure will include a folder identifier as `id` (this will be Google
    Drive folder ID in our case), the API security key (`api_key`) for accessing the
    Google Drive folder, and a list of file attributes (`fields`) to be fetched when
    we get a list of files. We build the resource data structure as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `getfilelistpy` 模块，我们需要创建一个资源数据结构。这个数据结构将包括一个文件夹标识符作为 `id`（在我们的情况下，这将是一个
    Google Drive 文件夹 ID），用于访问 Google Drive 文件夹的 API 安全密钥（`api_key`），以及当我们获取文件列表时需要获取的文件属性列表（`fields`）。我们按照以下方式构建资源数据结构：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We limit the file attributes to the `file id`, `name`, and its `web link` (URL)
    only. Next, we need to add each file item into a queue as a task for threads.
    The queue will be used by multiple worker threads to download the files in parallel.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件属性限制为 `file id`、`name` 和其 `web link`（URL）仅此。接下来，我们需要将每个文件项作为任务添加到队列中，以便线程处理。队列将由多个工人线程用于并行下载文件。
- en: 'To make the application more flexible in terms of the number of workers we
    can use, we build a pool of worker threads. The size of the pool is controlled
    by a global variable that is set at the beginning of the program. We created worker
    threads as per the size of the thread pool. Each worker thread in the pool has
    access to the queue, which has a list of files. Like the previous code example,
    each worker thread will take one file item from the queue at a time, download
    the file, and mark the file item as complete using the `task_done` method. An
    example code for defining a resource data structure and for defining a class for
    the worker thread is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序在工人数量方面更加灵活，我们可以构建一个工人线程池。线程池的大小由一个全局变量控制，该变量在程序开始时设置。我们根据线程池的大小创建了工人线程。池中的每个工人线程都可以访问队列，其中包含文件列表。与之前的代码示例一样，每个工人线程一次从队列中取一个文件项，下载文件，并使用
    `task_done` 方法将文件项标记为完成。定义资源数据结构和定义工人线程类的示例代码如下：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We get the files'' metadata from a Google Drive directory using the resource
    data structure as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下方式使用资源数据结构从 Google Drive 目录获取文件的元数据：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `main` function, we create a `Queue` object to insert file metadata
    into the queue. The `Queue` object is handed over to a pool of worker threads
    for downloading the files. The worker threads will download the files, as discussed
    earlier. We use the `time` class to measure the time it takes to complete the
    download of all the files from the Google Drive directory. The code for the `main`
    function is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们创建一个 `Queue` 对象，将文件元数据插入队列。`Queue` 对象被传递给一组工人线程，用于下载文件。如前所述，工人线程将下载文件。我们使用
    `time` 类来测量从 Google Drive 目录下载所有文件所需的时间。`main` 函数的代码如下：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For this application, we have 10 files in the Google Drive directory, varying
    in size from 500 KB to 3 MB. We ran the application with 1, 5, and 10 worker threads.
    The total time taken to download the 10 files with 1 thread was approximately
    20 seconds. This is almost equivalent to writing a code without any threads. In
    fact, we have written a code to download the same files without any threads and
    made it available with this book's source code as an example. The time it took
    to download 10 files with a non-threaded application was approximately 19 seconds.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们在 Google Drive 目录中有 10 个文件，大小从 500 KB 到 3 MB 不等。我们使用 1、5 和 10 个工人线程运行了应用程序。使用
    1 个线程下载 10 个文件的总时间大约为 20 秒。这几乎等同于不使用任何线程编写代码。实际上，我们已经编写了一个不使用任何线程下载相同文件的代码，并将其作为本书源代码的示例提供。使用非线程应用程序下载
    10 个文件的时间大约为 19 秒。
- en: When we changed the number of worker threads to 5, the time taken to download
    the 10 files reduced significantly to approximately 6 seconds on our MacBook machine
    (Intel Core i5 with 16 GB RAM). If you run the same program on your computer,
    the time may be different, but there will definitely be an improvement if we increase
    the number of worker threads. With 10 threads, we observed the execution time
    to be around 4 seconds. This observation shows that there is an improvement in
    the execution time for I/O bound tasks by using multithreading regardless of the
    GIL limitation it has.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将工作线程的数量更改为5时，在我们的MacBook机器（Intel Core i5，16 GB RAM）上下载10个文件所需的时间显著减少，大约为6秒。如果你在你的电脑上运行相同的程序，时间可能会有所不同，但如果我们增加工作线程的数量，肯定会得到改善。使用10个线程时，我们观察到执行时间大约为4秒。这一观察表明，无论GIL限制如何，通过使用多线程来处理I/O密集型任务都可以提高执行时间。
- en: This concludes our discussion of how to implement threads in Python and how
    to benefit from different locking mechanisms using the `Lock` class and the `Queue`
    class. Next, we will discuss multiprocessing programming in Python.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对如何在Python中实现线程以及如何使用`Lock`类和`Queue`类来利用不同的锁定机制的讨论。接下来，我们将讨论Python中的多进程编程。
- en: Going beyond a single CPU – implementing multiprocessing
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越单个CPU – 实现多进程
- en: We have seen the complexity of multithreaded programming and its limitations.
    The question is whether the complexity of multithreading is worth the effort.
    It may be worth it for I/O-related tasks but not for general application use cases,
    especially when an alternative approach exists. The alternative approach is to
    use multiprocessing because separate Python processes are not constrained by the
    GIL and execution can happen in parallel. This is especially beneficial when applications
    run on multicore processors and involve intensive CPU-demanding tasks. In reality,
    the use of multiprocessing is the only option in Python's built-in libraries to
    utilize multiple processor cores.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了多线程编程的复杂性和其局限性。问题是多线程的复杂性是否值得付出努力。对于I/O相关的任务可能值得，但对于通用应用场景则不然，尤其是当存在替代方法时。替代方法是使用多进程，因为独立的Python进程不受GIL（全局解释器锁）的限制，可以并行执行。这在应用程序运行在多核处理器上且涉及密集型CPU需求任务时尤其有益。实际上，在Python的内置库中，使用多进程是利用多个处理器核心的唯一选项。
- en: '**Graphics Processing Units** (**GPUs**) provide a greater number of cores
    than regular CPUs and are considered more suitable for data processing tasks,
    especially when executing them in parallel. The only caveat is that in order to
    execute a data processing program on a GPU, we have to transfer the data from
    the main memory to the GPU''s memory. This additional step of data transfer will
    be compensated when we are processing a large dataset. But there will be little
    or no benefit if our dataset is small. Using GPUs for big data processing, especially
    for training machine learning models, is becoming a popular option. NVIDIA has
    introduced a GPU for parallel processing called CUDA, which is well supported
    through external libraries in Python.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形处理单元**（**GPU**）比常规CPU拥有更多的核心，被认为更适合数据处理任务，尤其是在并行执行时。唯一的缺点是，为了在GPU上执行数据处理程序，我们必须将数据从主内存传输到GPU内存。当我们处理大型数据集时，这一额外的数据传输步骤将会得到补偿。但如果我们的数据集很小，那么将几乎没有好处。使用GPU进行大数据处理，特别是用于训练机器学习模型，正变得越来越受欢迎。NVIDIA推出了一种用于并行处理的GPU，称为CUDA，它通过Python的外部库得到了良好的支持。'
- en: Each process has a data structure called the **Process Control Block** (**PCB**)
    at the operating system level. Like the TCB, the PCB has a **Process ID** (**PID**)
    for process identification, stores the state of the process (such as running or
    waiting), and has a program counter, CPU registers, CPU scheduling information,
    and many more attributes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程在操作系统级别都有一个称为**进程控制块**（**PCB**）的数据结构。像TCB（线程控制块）一样，PCB有一个**进程ID**（**PID**）用于进程识别，存储进程的状态（如运行或等待），并具有程序计数器、CPU寄存器、CPU调度信息以及许多其他属性。
- en: In the case of multiple processes for CPUs, there is no sharing of memory natively.
    This means there is a lower chance of data corruption. If the two processes have
    to share the data, they need to use some interprocess communication mechanism.
    Python supports interprocess communication through its primitives. In the next
    subsections, we will first discuss the fundamentals of creating processes in Python
    and then discuss how to achieve interprocess communication.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在多CPU进程的情况下，内存共享不是原生的。这意味着数据损坏的可能性较低。如果两个进程需要共享数据，它们需要使用某种进程间通信机制。Python通过其原语支持进程间通信。在接下来的小节中，我们将首先讨论在Python中创建进程的基本原理，然后讨论如何实现进程间通信。
- en: Creating multiple processes
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建多个进程
- en: For multiprocessing programming, Python provides a `multiprocessing` package
    that is very similar to the multithreading package. The `multiprocessing` package
    includes two approaches to implement multiprocessing, which are using the `Process`
    object and the `Pool` object. We will discuss each of these approaches one by
    one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多进程编程，Python提供了一个与多线程包非常相似的`multiprocessing`包。`multiprocessing`包包括两种实现多进程的方法，即使用`Process`对象和`Pool`对象。我们将逐一讨论这些方法。
- en: Using the Process object
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Process对象
- en: 'The processes can be spawned by creating a `Process` object and then using
    its `start` method similar to the `start` method for starting a `Thread` object.
    In fact, the `Process` object offers the same API as the `Thread` object. A simple
    code example for creating multiple child processes is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过创建`Process`对象并使用其`start`方法（类似于启动`Thread`对象的`start`方法）来生成进程。实际上，`Process`对象提供了与`Thread`对象相同的API。创建多个子进程的简单代码示例如下：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As already mentioned, the methods used for the `Process` object are pretty much
    the same as those used for the `Thread` object. The explanation of this example
    is the same as for the example code in the multithreading code examples.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，用于`Process`对象的方法与用于`Thread`对象的方法几乎相同。这个示例的解释与多线程代码示例中的示例代码相同。
- en: Using the Pool object
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Pool对象
- en: 'The `Pool` object offers a convenient way (using its `map` method) of creating
    processes, assigning functions to each new process, and distributing input parameters
    across the processes. We selected the code example with a pool size of `3` but
    provided input parameters for five processes. The reason for setting the pool
    size to `3` is to make sure a maximum of three child processes are active at a
    time, regardless of how many parameters we pass with the `map` method of the `Pool`
    object. The additional parameters will be handed over to the same child processes
    as soon they finish their current execution. Here is a code example with a pool
    size of `3`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool`对象提供了一个方便的方法（使用其`map`方法）来创建进程，将函数分配给每个新进程，并将输入参数分配给各个进程。我们选择了池大小为`3`的代码示例，但提供了五个进程的输入参数。将池大小设置为`3`的原因是确保一次最多只有三个子进程处于活动状态，无论我们通过`Pool`对象的`map`方法传递多少参数。额外的参数将在子进程完成当前执行后立即传递给相同的子进程。以下是一个池大小为`3`的代码示例：'
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The magic of distributing input parameters to a function that is tied to a set
    of pool processes is done by the `map` method. The `map` method waits until all
    functions complete their execution, and that is why there is no need to use a
    `join` method if the processes are created using the `Pool` object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入参数分配给与一组池进程相关联的函数的魔法是通过`map`方法实现的。`map`方法会等待所有函数完成执行，这就是为什么如果使用`Pool`对象创建进程，则不需要使用`join`方法的原因。
- en: 'A few differences between using the `Process` object versus the `Pool` object
    are shown in the following table:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Process`对象与使用`Pool`对象之间的一些差异如下表所示：
- en: '![Table 7.1 – Comparison of using the Pool object and the Process object'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![表7.1 – 使用Pool对象和Process对象比较'
- en: '](img/B17189_07_Table_1.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_07_Table_1.jpg)'
- en: Table 7.1 – Comparison of using the Pool object and the Process object
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 – 使用Pool对象和Process对象比较
- en: Next, we will discuss how to exchange data between processes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何在进程间交换数据。
- en: Sharing data between processes
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程间共享数据
- en: There are two approaches in the multiprocessing package to share data between
    processes. These are **shared memory** and **server process**. They are described
    next.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在多进程包中，有两种方法可以在进程间共享数据。这些是**共享内存**和**服务器进程**。下面将进行描述。
- en: Using shared ctype objects (shared memory)
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用共享ctype对象（共享内存）
- en: 'In this case, a *shared memory* block is created, and the processes have access
    to this shared memory block. The shared memory is created as soon we initiate
    one of the `ctype` datatypes available in the `multiprocessing` package. The datatypes
    are `Array` and `Value`. The `Array` datatype is a `ctype` array and the `Value`
    datatype is a generic `ctype` object, both of which are allocated from the shared
    memory. To create a `ctype` array, we will use a statement like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建了一个*共享内存*块，进程可以访问这个共享内存块。当我们在`multiprocessing`包中初始化一个`ctype`数据类型时，就会创建共享内存。数据类型有`Array`和`Value`。`Array`数据类型是一个`ctype`数组，而`Value`数据类型是一个通用的`ctype`对象，两者都是从共享内存中分配的。为了创建一个`ctype`数组，我们将使用如下语句：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will create an array of the `integer` datatype with a size of `5`. `i`
    is one of the typecodes, and it stands for integer. We can use the `d` typecode
    for float datatypes. We can also initialize the array by providing the sequence
    as a second argument (instead of the size) as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个大小为`5`的`integer`数据类型的数组。`i`是类型码之一，代表整数。我们可以使用`d`类型码来表示浮点数据类型。我们还可以通过提供序列作为第二个参数（而不是大小）来初始化数组，如下所示：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create a `Value` `ctype` object, we will use a statement similar to the
    following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`Value` `ctype`对象，我们将使用类似以下语句：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will create an object of the `integer` datatype because the typecode is
    set to `i`. The value of this object can be accessed or set by using the `value`
    attribute.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`integer`数据类型的对象，因为类型码被设置为`i`。这个对象的价值可以通过使用`value`属性来访问或设置。
- en: Both these `ctype` objects have `Lock` as an optional argument, which is set
    to `True` by default. This argument when set to `True` is used to create a new
    recursive lock object that provides synchronized access to the value of the objects.
    If it is set to `False`, there will be no protection and it will not be a safe
    process. If your process is only accessing the shared memory for reading purposes,
    it is fine to set the `Lock` to `False`. We leave this `Lock` argument as the
    default (`True`) in our next code examples.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个`ctype`对象都有一个可选的`Lock`参数，默认设置为`True`。当这个参数设置为`True`时，用于创建一个新的递归锁对象，该对象提供对对象值的同步访问。如果设置为`False`，则没有保护，并且不是一个安全的过程。如果你的进程只用于读取共享内存，可以将`Lock`设置为`False`。我们在接下来的代码示例中保留这个`Lock`参数为默认值（`True`）。
- en: 'To illustrate the use of these `ctype` objects from the shared memory, we will
    create a default list with three numeric values, a `ctype` array of size `3` to
    hold the incremented values of the original array, and a `ctype` object to hold
    the sum of the incremented array. These objects will be created by a parent process
    in shared memory and will be accessed and updated by a child process from the
    shared memory. This interaction of the parent and the child processes with the
    shared memory is shown in the following figure:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明从共享内存中使用这些`ctype`对象，我们将创建一个包含三个数值的默认列表，一个大小为`3`的`ctype`数组来保存原始数组的增量值，以及一个`ctype`对象来保存增量数组的总和。这些对象将由父进程在共享内存中创建，并由子进程从共享内存中访问和更新。父进程和子进程与共享内存的这种交互在以下图中展示：
- en: '![Figure 7.3 – Use of shared memory by a parent and a child process'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – 父进程和子进程使用共享内存'
- en: '](img/B17189_07_03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_07_03.jpg)'
- en: Figure 7.3 – Use of shared memory by a parent and a child process
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 父进程和子进程使用共享内存
- en: 'A complete code example of using the shared memory is shown next:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了使用共享内存的完整代码：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The shared datatypes (`inc_list` and `sum` in this case) are accessed by both
    the parent process and the child process. It is important to mention that using
    the shared memory is not a recommended option because it requires synchronization
    and locking mechanisms (similar to what we did for multithreading) when the same
    shared memory objects are accessed by multiple processes and the `Lock` argument
    is set to `False`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 共享数据类型（在本例中为`inc_list`和`sum`）被父进程和子进程访问。重要的是要提到，使用共享内存不是一个推荐的选择，因为它在多个进程访问相同的共享内存对象且`Lock`参数设置为`False`时，需要同步和锁定机制（类似于我们为多线程所做的那样）。
- en: The next approach of sharing data between processes is using the server process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程之间共享数据的下一个方法是使用服务器进程。
- en: Using the server process
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用服务器进程
- en: In this case, a server process is started as soon as a Python program starts.
    This new process is used to create and manage the new child processes requested
    by a parent process. This server process can hold Python objects that other processes
    can access using proxies.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一旦 Python 程序启动，就会启动一个服务器进程。这个新进程用于创建和管理父进程请求的新子进程。这个服务器进程可以持有其他进程可以通过代理访问的
    Python 对象。
- en: 'To implement the server process and share the objects between the processes,
    the `multiprocessing` package provides a `Manager` object. The `Manager` object
    supports different data types such as the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现服务器进程并在进程之间共享对象，`multiprocessing` 包提供了一个 `Manager` 对象。`Manager` 对象支持以下数据类型：
- en: Lists
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Dictionaries
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dictionaries
- en: Locks
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁
- en: Rlocks
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rlocks
- en: Queues
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列
- en: Values
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Values
- en: Arrays
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arrays
- en: 'The code example we selected for illustrating the server process creates a
    `dictionary` object using the `Manager` object, then passes the dictionary object
    to different child processes to insert more data and to print out the dictionary
    contents. We will create three child processes for our example: two for inserting
    data into the dictionary object and one for getting the dictionary contents as
    the console output. The interaction between the parent process, the server process,
    and the three child processes is shown in *Figure 7.4*. The parent process creates
    the server process as soon as a new process request is executed using the *Manager*
    context. The child processes are created and managed by the server process. The
    shared data is available within the server process and is accessible by all processes,
    including the parent process:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的用于说明服务器进程的代码示例使用 `Manager` 对象创建了一个 `dictionary` 对象，然后将字典对象传递给不同的子进程以插入更多数据并打印字典内容。在我们的例子中，我们将创建三个子进程：两个用于向字典对象中插入数据，一个用于将字典内容作为控制台输出。父进程、服务器进程和三个子进程之间的交互在
    *图 7.4* 中显示。父进程在执行新进程请求时立即创建服务器进程，使用的是 *Manager* 上下文。子进程由服务器进程创建和管理。共享数据在服务器进程中可用，并且所有进程都可以访问，包括父进程：
- en: '![Figure 7.4 – Use of server process for sharing data between processes'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.4 – 使用服务器进程在进程间共享数据'
- en: '](img/B17189_07_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_07_04.jpg](img/B17189_07_04.jpg)'
- en: Figure 7.4 – Use of server process for sharing data between processes
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.4 – 使用服务器进程在进程间共享数据
- en: 'The complete code example is shown next:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码示例如下：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The server process approach offers more flexibility than the shared memory approach
    because it supports a large variety of object types. However, this comes at the
    cost of slower performance compared to the shared memory approach.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器进程方法比共享内存方法提供了更多的灵活性，因为它支持大量不同类型的对象。然而，这以比共享内存方法更慢的性能为代价。
- en: In the next section, we will explore the options of direct communication between
    the processes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨进程之间直接通信的选项。
- en: Exchanging objects between processes
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程间交换对象
- en: In the previous section, we studied how to share data between the processes
    through an external memory block or a new process. In this section, we will investigate
    exchanging of data between processes using Python objects. The `multiprocessing`
    module provides two options for this purpose. These are using the `Queue` object
    and the `Pipe` object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何通过外部内存块或新进程来在进程之间共享数据。在本节中，我们将探讨使用 Python 对象在进程之间交换数据。`multiprocessing`
    模块为此提供了两种选项。这些是使用 `Queue` 对象和 `Pipe` 对象。
- en: Using the Queue object
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用队列对象
- en: 'The `Queue` object is available from the `multiprocessing` package and is nearly
    the same as the synchronized queue object (`queue.Queue`) that we used for multithreading.
    This `Queue` object is process-safe and does not require any additional protection.
    A code example to illustrate the use of the multiprocessing `Queue` object for
    data exchange is shown next:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue` 对象可以从 `multiprocessing` 包中获得，几乎与我们在多线程中使用的同步队列对象 (`queue.Queue`) 相同。这个
    `Queue` 对象是进程安全的，不需要任何额外的保护。下面是一个代码示例，用于说明如何使用多进程 `Queue` 对象进行数据交换：'
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this code example, we created a standard `list` object and a multiprocessing
    `Queue` object. The `list` and `Queue` objects are passed to a new process, which
    is attached to a function called `copy_data`. This function will copy the data
    from the `list` object to the `Queue` object. A new process is initiated to print
    the contents of the `Queue` object. Note that the data in the `Queue` object is
    set by the previous process and the data will be available to the new process.
    This is a convenient way to exchange data without adding the complexity of shared
    memory or the server process.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们创建了一个标准的`list`对象和一个多进程`Queue`对象。`list`和`Queue`对象被传递给一个新的进程，该进程连接到一个名为`copy_data`的函数。这个函数将从`list`对象复制数据到`Queue`对象。启动了一个新的进程来打印`Queue`对象的内容。请注意，`Queue`对象中的数据由前一个进程设置，并且数据将可供新进程使用。这是一种方便的数据交换方式，无需增加共享内存或服务器进程的复杂性。
- en: Using the Pipe object
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`Pipe`对象
- en: The `Pipe` object is like a pipe between two processes for exchanging data.
    This is why this object is especially useful when two-way communication is required.
    When we create a `Pipe` object, it provides two connection objects, which are
    the two ends of the `Pipe` object. Each connection object provides a `send` and
    a `recv` method to send and receive data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pipe`对象就像两个进程之间交换数据的管道。这就是为什么这个对象在需要双向通信时特别有用。当我们创建一个`Pipe`对象时，它提供了两个连接对象，这是`Pipe`对象的两个端点。每个连接对象提供了一个`send`和`recv`方法来发送和接收数据。'
- en: 'To illustrate the concept and use of the `Pipe` object, we will create two
    functions that will be attached to two separate processes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`Pipe`对象的概念和使用，我们将创建两个函数，这两个函数将连接到两个不同的进程：
- en: The first function is for sending the message through a `Pipe` object connection.
    We will send a few data messages and finish the communication with a `BYE` message.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数是通过`Pipe`对象连接发送消息。我们将发送一些数据消息，并通过一个`BYE`消息完成通信。
- en: The second function is to receive the message using the other connection object
    of the `Pipe` object. This function will run in an infinite loop until it receives
    a `BYE` message.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个函数是使用`Pipe`对象的另一个连接对象接收消息。这个函数将运行在一个无限循环中，直到它接收到一个`BYE`消息。
- en: 'The two functions (or processes) are provided with the two connection objects
    of a pipe. The complete code is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数（或进程）提供了管道的两个连接对象。完整的代码如下：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is important to mention that the data in a `Pipe` object can easily be corrupted
    if the two processes try to read from or write to it using the same connection
    object at the same time. That is why multiprocessing queues are the preferred
    option: because they provide proper synchronization between the processes.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，如果两个进程同时尝试使用相同的连接对象从`Pipe`对象中读取或写入数据，那么`Pipe`对象中的数据很容易被损坏。这就是为什么多进程队列是首选选项：因为它们在进程之间提供了适当的同步。
- en: Synchronization between processes
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程间的同步
- en: Synchronization between processes makes sure that two or more processes do not
    access the same resources or program code at the same time, which is also called
    the `Lock` object, similar to what we used in the case of multithreading.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 进程间的同步确保两个或多个进程不会同时访问相同的资源或程序代码，这也称为`Lock`对象，类似于我们在多线程情况下使用的情况。
- en: 'We illustrated the use of `queues` and `ctype` datatypes with `Lock` set to
    `True`, which is process safe. In the next code example, we will illustrate the
    use of the `Lock` object to make sure one process gets access to the console output
    at a time. We created the processes using the `Pool` object and to pass the same
    `Lock` object to all processes, we used the `Lock` from the `Manager` object and
    not the one from the multiprocessing package. We also used the `partial` function
    to tie the `Lock` object to each process, along with a list to be distributed
    to each process function. Here is the complete code example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Lock`设置为`True`的`queues`和`ctype`数据类型说明了其使用，这是进程安全的。在下一个代码示例中，我们将使用`Lock`对象来确保一次只有一个进程可以访问控制台输出。我们使用`Pool`对象创建了进程，并且为了将相同的`Lock`对象传递给所有进程，我们使用了`Manager`对象中的`Lock`而不是多进程包中的`Lock`。我们还使用了`partial`函数将`Lock`对象绑定到每个进程，以及一个要分配给每个进程函数的列表。以下是完整的代码示例：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we do not use the `Lock` object, the output from the different processes
    can be mixed up.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用`Lock`对象，不同进程的输出可能会混合在一起。
- en: Case study – a multiprocessor application to download files from Google Drive
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 - 一个多进程应用程序，用于从Google Drive下载文件
- en: In this section, we will implement the same case study as we did in the *Case
    study – a multithreaded application to download files from Google Drive* section,
    but using processors instead. The prerequisites and goals are the same as described
    for the case study of the multithreaded application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现与我们在*案例研究 – 从Google Drive下载文件的多线程应用程序*部分中实现的相同案例研究，但使用处理器。前提条件和目标与多线程应用程序的案例研究描述相同。
- en: 'For this application, we used the same code that we built for the multithreaded
    application except that we used processes instead of threads. Another difference
    is that we used the `JoinableQueue` object from the `multiprocessing` module to
    achieve the same functionality as we were getting from the regular `Queue` object.
    Code for defining a resource data structure and for a function to download files
    from Google Drive is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们使用了为多线程应用程序构建的相同代码，只是我们使用了进程而不是线程。另一个区别是我们使用了`multiprocessing`模块中的`JoinableQueue`对象来实现与从常规`Queue`对象获得的功能相同。定义资源数据结构和从Google
    Drive下载文件的函数的代码如下：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We get the files'' metadata, such as the name and HTTP link, from a Google
    Drive directory using the resource data structure as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下资源数据结构从Google Drive目录获取文件的元数据，例如名称和HTTP链接：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our `main` function, we create a `JoinableQueue` object and insert the files''
    metadata into the queue. The queue will be handed over to a pool of processes
    to download the files. The processes will download the files. We used the `time`
    class to measure the time it takes to download all the files from the Google Drive
    directory. The code for the `main` function is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，我们创建一个`JoinableQueue`对象，并将文件的元数据插入队列中。队列将被交给一个进程池以下载文件。进程将下载文件。我们使用了`time`类来测量从Google
    Drive目录下载所有文件所需的时间。`main`函数的代码如下：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We ran this application by varying the different number of processes, such
    as `3`, `5`, `7`, and `10`. We found that the time it took to download the same
    files (as for the case study of multithreading) is slightly better than with the
    multithreaded application. The execution time will vary from machine to machine,
    but on our machine (MacBook Pro: Intel Core i5 with 16 GB RAM), it took around
    5 seconds with 5 processes and 3 seconds with 10 processes running in parallel.
    This improvement of 1 second over the multithreaded application is in line with
    the expected results as multiprocessing provides true concurrency.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过改变不同的进程数量来运行这个应用程序，例如`3`、`5`、`7`和`10`。我们发现下载相同文件所需的时间（与多线程案例研究的情况相同）略好于多线程应用程序。执行时间会因机器而异，但在我们这台机器上（MacBook
    Pro：Intel Core i5，16 GB RAM），使用5个进程时大约需要5秒，使用10个进程并行运行时需要3秒。与多线程应用程序相比，这种1秒的改进与预期结果相符，因为多进程提供了真正的并发性。
- en: Using asynchronous programming for responsive systems
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步编程实现响应式系统
- en: 'With multiprocessing and multithreaded programming, we were mostly dealing
    with synchronous programming, where we request something and wait for the response
    to be received before we move to the next block of code. If any context switching
    is applied, it is provided by the operating system. Asynchronous programming in
    Python is different mainly in the following two aspects:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在多进程和多线程编程中，我们主要处理的是同步编程，其中我们请求某事，并在收到响应之前等待，然后才移动到下一块代码。如果应用了上下文切换，则由操作系统提供。Python中的异步编程主要在以下两个方面有所不同：
- en: The tasks are to be created for asynchronous execution. This means the parent
    caller does not have to wait for the response from another process. The process
    will respond to the caller once it finishes the execution.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要创建的任务用于异步执行。这意味着父调用者不需要等待另一个进程的响应。进程将在执行完成后向调用者做出响应。
- en: The operating system is no longer managing the context switching between the
    processes and the threads. The asynchronous program will be given only a single
    thread in a process, but we can do multiple things with it. In this style of execution,
    every process or task voluntarily releases control whenever it is idle or waiting
    for another resource to make sure that the other tasks get a turn. This concept
    is called **cooperative multitasking**.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统不再管理进程和线程之间的上下文切换。异步程序将只在一个进程中获得一个线程，但我们可以用它做很多事情。在这种执行风格中，每个进程或任务在空闲或等待其他资源时都会自愿释放控制权，以确保其他任务有机会。这个概念被称为**协同多任务**。
- en: Cooperative multitasking is an effective tool for achieving concurrency at the
    application level. In cooperative multitasking, we do not build processes or threads,
    but tasks, which comprises `yield`) while keeping the stack of objects under control
    before it is resumed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 协作多任务处理是实现应用程序级别并发的一种有效工具。在协作多任务处理中，我们不构建进程或线程，而是构建任务，这包括 `yield`（在恢复之前保持对象堆栈的控制）。
- en: For a system based on cooperative multitasking, there is always a question of
    when to release the control back to a scheduler or to an event loop. The most
    commonly used logic is to use the I/O operation as the event to release the control
    because there is always a waiting time involved whenever we are doing an I/O operation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于协作多任务处理的系统，总有一个何时将控制权交还给调度器或事件循环的问题。最常用的逻辑是使用 I/O 操作作为释放控制的事件，因为每次进行 I/O
    操作时都涉及等待时间。
- en: But hold on, is it not the same logic we used for multithreading? We found that
    multithreading improves application performance when dealing with I/O operations.
    But there is a difference here. In the case of multithreading, the operating system
    is managing the context switching between the threads, and it can preempt any
    running thread for any reason and give control to another thread. But in asynchronous
    programming or cooperative multitasking, the tasks or coroutines are not visible
    to the operating systems and cannot be preempted. The coroutines in fact cannot
    be preempted by the main event loop. But this does not mean that the operating
    system cannot preempt the whole Python process. The main Python process is still
    competing for resources with other applications and processes at the operating
    system level.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，这难道不是我们用于多线程的逻辑吗？我们发现，在处理 I/O 操作时，多线程可以提高应用程序的性能。但这里有一个区别。在多线程的情况下，操作系统正在管理线程之间的上下文切换，并且可以出于任何原因抢占任何正在运行的线程，并将控制权交给另一个线程。但在异步编程或协作多任务处理中，任务或协程对操作系统是不可见的，并且不能被抢占。实际上，协程不能被主事件循环抢占。但这并不意味着操作系统不能抢占整个
    Python 进程。主要的 Python 进程仍然在操作系统级别与其他应用程序和进程竞争资源。
- en: In the next section, we will discuss a few building blocks of asynchronous programming
    in Python, which is provided by the `asyncio` module, and we will conclude with
    a comprehensive case study.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论 Python 中异步编程的一些构建块，这些构建块由 `asyncio` 模块提供，并以一个综合案例研究结束。
- en: Understanding the asyncio module
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 asyncio 模块
- en: The `asyncio` module is available in Python 3.5 or later to write concurrent
    programs using the `async/await` syntax. But it is recommended to use Python 3.7
    or later to build any serious `asyncio` application. The library is rich with
    features and supports creating and running Python coroutines, performing network
    I/O operations, distributing tasks to queues, and synchronizing concurrent code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5 或更高版本中的 `asyncio` 模块可用于使用 `async/await` 语法编写并发程序。但建议使用 Python 3.7
    或更高版本来构建任何严肃的 `asyncio` 应用程序。该库功能丰富，支持创建和运行 Python 协程，执行网络 I/O 操作，将任务分配到队列中，以及同步并发代码。
- en: We will start with how to write and execute coroutines and tasks.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从如何编写和执行协程和任务开始。
- en: Coroutines and tasks
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协程和任务
- en: 'Coroutines are the functions that are to be executed asynchronously. A simple
    example of sending a string to the console output using a coroutine is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是那些需要异步执行的功能。以下是一个使用协程将字符串发送到控制台输出的简单示例：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this code example, it is important to note the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，以下事项很重要：
- en: The coroutine takes `delay` and `msg` arguments. The `delay` argument is used
    to add a delay before sending the `msg` string to the console output.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程接受 `delay` 和 `msg` 参数。`delay` 参数用于在将 `msg` 字符串发送到控制台输出之前添加延迟。
- en: We used the `asyncio.sleep` function instead of the traditional `time.sleep`
    function. If the `time.sleep` function is used, control will not be given back
    to the event loop. That is why it is important to use the compatible `asyncio.sleep`
    function.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `asyncio.sleep` 函数而不是传统的 `time.sleep` 函数。如果使用 `time.sleep` 函数，则不会将控制权交还给事件循环。这就是为什么使用兼容的
    `asyncio.sleep` 函数很重要的原因。
- en: The coroutine is executed twice with two different values of the `delay` argument
    by using the `run` method. The `run` method will not execute the coroutines concurrently.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `run` 方法，协程使用两个不同的 `delay` 参数值执行两次。`run` 方法不会并发执行协程。
- en: 'The console output of this program will be as follows. This shows that the
    coroutines are executed one after the other as the total delay added is 3 seconds:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的控制台输出将如下所示。这表明协程是按照添加的总延迟顺序依次执行的，总延迟为3秒：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To run the coroutines in parallel, we need to use the `create_task` function
    from the `asyncio` module. This function creates a task that can be used to schedule
    coroutines to run concurrently.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了并行运行协程，我们需要使用`asyncio`模块中的`create_task`函数。这个函数创建一个任务，可以用来调度协程以并发运行。
- en: 'The next code example is a revised version of `asyncio1.py`, in which we wrapped
    the coroutine (`say` in our case) into a task using the `create_task` function.
    In this revised version, we created two tasks that are wrapping the `say` coroutine.
    We waited for the two tasks to be completed using the `await` keyword:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码示例是`asyncio1.py`的修订版，其中我们使用`create_task`函数将协程（在我们的例子中是`say`）包装成一个任务。在这个修订版中，我们创建了两个任务，它们都包装了`say`协程。我们使用`await`关键字等待两个任务完成：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The console output of this program is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出如下：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This console output shows that the two tasks were completed in 1 second, which
    is proof that the tasks are executed in parallel.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制台输出显示，两个任务在1秒内完成，这证明了任务是并行执行的。
- en: Using awaitable objects
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用可等待对象
- en: An object is awaitable if we can apply the `await` statement to it. The majority
    of `asyncio` functions and modules inside it are designed to work with awaitable
    objects. But most Python objects and third-party libraries are not built for asynchronous
    programming. It is important to select compatible libraries that provide awaitable
    objects to use when building asynchronous applications.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以对对象应用`await`语句，则该对象是可等待的。`asyncio`函数和模块的大多数内部设计都是为了与可等待对象一起工作。但大多数Python对象和第三方库都不是为异步编程而构建的。在构建异步应用程序时，选择提供可等待对象的兼容库非常重要。
- en: 'Awaitable objects are split mainly into three types: coroutines, tasks, and
    `Future` is a low-level object that is like a callback mechanism used to process
    the result coming from the `async`/`await`. The `Future` objects are typically
    not exposed for user-level programming.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可等待对象主要分为三种类型：协程、任务，`Future`是一个低级对象，类似于用于处理来自`async`/`await`的结果的回调机制。通常不会将`Future`对象暴露给用户级编程。
- en: Running tasks concurrently
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行运行任务
- en: If we have to run multiple tasks in parallel, we can use the `await` keyword
    as we did in the previous example. But there is a better way of doing this by
    using the `gather` function. This function will run the awaitable objects in the
    sequence provided. If any of the awaitable objects is a coroutine, it will be
    scheduled as a task. We will see the use of the `gather` function in the next
    section with a code example.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须并行运行多个任务，我们可以像上一个例子中那样使用`await`关键字。但有一种更好的方法，那就是使用`gather`函数。这个函数将按提供的顺序运行可等待对象。如果任何可等待对象是协程，它将被调度为一个任务。我们将在下一节中通过代码示例看到`gather`函数的使用。
- en: Distributing tasks using queues
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用队列分配任务
- en: The `Queue` object in the `asyncio` package is similar to the `Queue` module
    but it is not thread safe. The `aysncio` module provides a variety of queue implementations,
    such as FIFO queues, priority queues, and LIFO queues. The queues in the `asyncio`
    module can be used to distribute the workloads to the tasks.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`包中的`Queue`对象类似于`Queue`模块，但它不是线程安全的。`asyncio`模块提供了各种队列实现，例如FIFO队列、优先队列和LIFO队列。`asyncio`模块中的队列可以用来将工作负载分配给任务。'
- en: 'To illustrate the use of a queue with tasks, we will write a small program
    that will simulate the execution time of a real function by sleeping for a random
    amount of time. The random sleeping time is calculated for 10 such executions
    and added to a `Queue` object as working items by the main process. The `Queue`
    object is passed to a pool of three tasks. Each task in the pool executes the
    assigned coroutine, which consumes the execution time as per the queue entry available
    to it. The complete code is shown next:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明队列与任务的使用，我们将编写一个小程序，通过随机休眠一段时间来模拟真实函数的执行时间。随机休眠时间计算了10次这样的执行，并由主进程将这些执行时间作为工作项添加到`Queue`对象中。`Queue`对象被传递给三个任务池。池中的每个任务执行分配的协程，按照它可用的队列条目消耗执行时间。完整的代码如下：
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We used the `put_no_wait` function of the `Queue` object because it is a non-blocking
    operation. The console output of this program is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`Queue`对象的`put_no_wait`函数，因为它是一个非阻塞操作。这个程序的输出如下：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This clearly shows that the tasks are executed in parallel, and the execution
    is three times better than if tasks are run sequentially.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明，任务是以并行方式执行的，执行效率比顺序执行任务提高了三倍。
- en: So far, we have covered the fundamental concepts of the `asyncio` package in
    Python. Before concluding this topic, we will revisit the case study we did for
    the multithreading section by implementing it using the `asyncio` tasks.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了Python中`asyncio`包的基本概念。在结束这个主题之前，我们将通过使用`asyncio`任务来实现它来回顾我们在多线程部分所做的案例研究。
- en: Case study – asyncio application to download files from Google Drive
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 – 使用asyncio从Google Drive下载文件的应用程序
- en: 'We will implement the same case study as we did in the *Case study – a multithreaded
    application to download files from Google Drive* section, but using the `asyncio`
    module with `async`, `await`, and `async queue`. The prerequisites for this case
    study are the same except that we use the `aiohttp` and `aiofiles` library instead
    of the `gdown` library. The reason is simple: the `gdown` library is not built
    as an async module. There is no benefit of using it with async programming. This
    is an important point to consider whenever selecting libraries to be used with
    async applications.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现与我们在*案例研究 – 从Google Drive下载文件的多线程应用程序*部分所做的相同的案例研究，但使用`asyncio`模块以及`async`、`await`和`async
    queue`。这个案例研究的先决条件与之前相同，只是我们使用`aiohttp`和`aiofiles`库而不是`gdown`库。原因很简单：`gdown`库不是作为一个异步模块构建的。使用异步编程与之结合没有好处。这是一个在选择用于异步应用程序的库时需要考虑的重要观点。
- en: 'For this application, we built a coroutine, `mydownloader`, to download a file
    from Google Drive using the `aiohttp` and `aiofiles` modules. This is shown in
    the following code, and the code that is different from the previous case studies
    is highlighted:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们构建了一个协程`mydownloader`，用于使用`aiohttp`和`aiofiles`模块从Google Drive下载文件。这在上面的代码中显示，与之前的案例研究不同的代码被突出显示：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The process to get the list of files from a shared Google Drive folder is the
    same as we used in the previous case study for multithreading and multiprocessing.
    In this case study, we created a pool of tasks (configurable) based on the `mydownloader`
    coroutine. These tasks are then scheduled to run together, and our parent process
    waits for all tasks to complete their execution. A code to get a list of files
    from Google Drive and then download the files using `asyncio` tasks is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从共享Google Drive文件夹中获取文件列表的过程与我们之前在多线程和多进程案例研究中使用的方法相同。在本案例研究中，我们基于`mydownloader`协程创建了一个任务池（可配置）。然后，这些任务被安排一起运行，我们的父进程等待所有任务完成执行。以下是一个从Google
    Drive获取文件列表并使用`asyncio`任务下载文件的代码示例：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We ran this application by varying the number of tasks, such as 3, 5, 7, and
    10\. We found that the time it took to download the files with the `asyncio` tasks
    is lower than when we downloaded the same files using the multithreading approach
    or the multiprocessing approach. The exact details of the time taken with the
    multithreading approach and the multiprocessing approach are available in the
    *Case study – a multithreaded application to download files from Google Drive*
    and *Case study – a multiprocessor application to download files from Google Drive*
    sections.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过改变任务数量来运行这个应用程序，例如3、5、7和10。我们发现，使用`asyncio`任务下载文件所需的时间比我们使用多线程方法或多进程方法下载相同文件的时间要低。多线程方法和多进程方法所需的确切时间细节可以在*案例研究
    – 从Google Drive下载文件的多线程应用程序*和*案例研究 – 从Google Drive下载文件的多进程应用程序*部分中找到。
- en: 'The execution time can vary from machine to machine, but on our machine (MacBook
    Pro: Intel Core i5 with 16 GB RAM), it took around 4 seconds with 5 tasks and
    2 seconds with 10 tasks running in parallel. This is a significant improvement
    compared to the numbers we observed for the multithreading and multiprocessing
    case studies. This is in line with expected results, as `asyncio` provides a better
    concurrency framework when it comes to I/O-related tasks, but it has to be implemented
    using the right set of programming objects.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时间可能会因机器而异，但在我们机器上（MacBook Pro：Intel Core i5，16 GB RAM），当有5个任务并行运行时，大约需要4秒，当有10个任务并行运行时，需要2秒。与我们在多线程和多进程案例研究中观察到的数字相比，这是一个显著的改进。这与预期结果一致，因为`asyncio`在处理I/O相关任务时提供了一个更好的并发框架，但它必须使用正确的编程对象集来实现。
- en: This concludes our discussion of asynchronous programming. This section provided
    all the core ingredients to build an asynchronous application using the `asyncio`
    package.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对异步编程的讨论。本节提供了使用 `asyncio` 包构建异步应用程序的所有核心要素。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed different options of concurrent programming in
    Python using the standard libraries. We started with multithreading with an introduction
    to the core concepts of concurrent programming. We introduced the challenges with
    multithreading, such as the GIL, which allows only one thread at a time to access
    Python objects. The concepts of locking and synchronization were explored with
    practical examples of Python code. We also discussed the types of task that multithreaded
    programming is more effective for using a case study.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用 Python 标准库进行并发编程的不同选项。我们从介绍并发编程的核心概念开始，介绍了多线程的挑战，例如 GIL，它允许一次只有一个线程访问
    Python 对象。我们通过 Python 代码的实际示例探讨了锁定和同步的概念。我们还通过案例研究讨论了多线程编程更有效的任务类型。
- en: We studied how to achieve concurrency using multiple processes in Python. With
    multiprocessing programming, we learned how to share data between processes using
    shared memory and the server process, and also how to exchange objects safely
    between processes using the `Queue` object and the `Pipe` object. In the end,
    we built the same case study as we did for the multithreading example, but using
    processes instead. Then, we introduced a completely different approach to achieving
    concurrency by using asynchronous programming. This was a complete shift in concept,
    and we started it by looking at the high-level concepts of the `async` and `await`
    keywords and how to build tasks, or coroutines, using the `asyncio` package. We
    concluded the chapter with the same case study we examined for multiprocessing
    and multithreading but using asynchronous programming.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了如何在 Python 中使用多个进程实现并发。通过多进程编程，我们学习了如何使用共享内存和服务器进程在进程之间共享数据，以及如何使用 `Queue`
    对象和 `Pipe` 对象在进程之间安全地交换对象。最后，我们构建了与多线程示例相同的案例研究，但使用进程。然后，我们通过使用异步编程引入了一种完全不同的实现并发的途径。这是一个概念上的完全转变，我们从查看
    `async` 和 `await` 关键字的高级概念以及如何使用 `asyncio` 包构建任务或协程开始。我们以与多进程和多线程相同的案例研究结束本章。
- en: This chapter has provided a lot of hands-on examples of how to implement concurrent
    applications in Python. This knowledge is important for anyone who wants to build
    multithreaded or asynchronous applications using the standard libraries available
    in Python.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了大量关于如何在 Python 中实现并发应用程序的实战示例。这些知识对于任何想要使用 Python 中的标准库构建多线程或异步应用程序的人来说都很重要。
- en: In the next chapter, we will explore using third-party libraries to build concurrent
    applications in Python.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用第三方库在 Python 中构建并发应用程序。
- en: Questions
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What coordinates Python threads? Is it a Python interpreter?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 线程是由什么协调的？是 Python 解释器吗？
- en: What is the GIL in Python?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 中的 GIL 是什么？
- en: When should you use daemon threads?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在什么情况下使用守护线程？
- en: For a system with limited memory, should we use a `Process` object or `Pool`
    object to create processes?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于内存有限的系统，我们应该使用 `Process` 对象还是 `Pool` 对象来创建进程？
- en: What are Futures in the `asyncio` package?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`asyncio` 包中的 Future 是什么？'
- en: What is an event loop in asynchronous programming?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步编程中的事件循环是什么？
- en: How do you write an asynchronous coroutine or function in Python?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Python 中编写异步协程或函数？
- en: Further reading
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Learning Concurrency in Python* by Elliot Forbes'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 并发编程》*，作者 Elliot Forbes'
- en: '*Expert Python Programming* by Michal Jaworski and Tarek Ziade'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《精通 Python 编程》*，作者 Michal Jaworski 和 Tarek Ziade'
- en: '*Python 3 Object-Oriented Programming,* *Second Edition* by Dusty Phillips'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 3 面向对象编程》*，第二版，作者 Dusty Phillips'
- en: '*Mastering Concurrency* *in Python* by Quan Nguyen'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《精通 Python 并发》*，作者 Quan Nguyen'
- en: '*Python Concurrency with asyncio* by Mathew Fowler'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python Concurrency with asyncio》*，作者 Mathew Fowler'
- en: Answers
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The threads and processes are coordinated by the operating system kernel.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程和进程由操作系统内核协调。
- en: Python's GIL is a locking mechanism used by Python to allow only one thread
    to execute at a time.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 的 GIL 是 Python 用来允许一次只执行一个线程的锁定机制。
- en: Daemon threads are used when it is not an issue for a thread to be terminated
    once its main thread terminates.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当线程的终止不会成为问题的时候，可以使用守护线程。
- en: The `Pool` object keeps only the active processes in memory, so it is a better
    choice.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pool`对象只保留内存中的活动进程，因此它是一个更好的选择。'
- en: Futures are like a callback mechanism that is used to process the result coming
    from async/await calls.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期货（Futures）就像是一个回调机制，用于处理来自async/await调用的结果。
- en: An event loop object keeps track of tasks and handles the flow of control between
    them.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件循环对象负责跟踪任务，并处理它们之间的控制流。
- en: We can write an asynchronous coroutine by starting with `async def`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用`async def`来编写异步协程。
