- en: Threads and Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will extend the functionality of our Python GUI using threads,
    queues, and network connections.
  prefs: []
  type: TYPE_NORMAL
- en: A `tkinter` GUI is a single-threaded application. Every function that involves
    sleep or wait time has to be called in a separate thread; otherwise, the `tkinter`
    GUI freezes.
  prefs: []
  type: TYPE_NORMAL
- en: When we run our Python GUI, in Windows Task Manager, we can see that a new `python.exe`
    process has been launched. When we give our Python GUI a `.pyw` extension, then
    the process created will be `python.pyw`, which can be seen in Task Manager as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: When a process is created, the process automatically creates a main thread to
    run our application. This is called a *single-threaded application*.
  prefs: []
  type: TYPE_NORMAL
- en: Single-threaded processes contain the execution of instructions in a single
    sequence. In other words, one command is processed at a time.
  prefs: []
  type: TYPE_NORMAL
- en: For our Python GUI, a single-threaded application will lead to our GUI becoming
    frozen as soon as we call a longer-running task, such as clicking a button that
    has a sleep time of a few seconds. In order to keep our GUI responsive, we have
    to use *multithreading*, and this is what we will study in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Our GUI runs in a single thread. Knowing how to use multiple threads is an important
    concept for GUI development.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create multiple processes by creating multiple instances of our
    Python GUI, as can be seen in Task Manager, where we can see several `python.exe`
    processes running at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Processes are isolated from each other by design and do not share common data.
    In order to communicate between separate processes, we have to use **Inter-Process
    Communication** (**IPC**), which is an advanced technique. Threads, on the other
    hand, do share common data, code, and files, which makes communication between
    threads within the same process much easier than when using IPC. A great explanation
    of threads can be found at [https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSyste](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)[ms/4_Threads.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to keep our Python GUI responsive and keep
    it from freezing. Having this knowledge is essential when creating working GUIs,
    and knowing how to create threads and use queues increases your programming skills.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use TCP/IP to connect our GUI to a network. In addition to that,
    we will read a URL web page, which is also a networking component on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the overview of Python modules for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b53775b-8917-4182-a184-de7f64017f2d.png)'
  prefs: []
  type: TYPE_IMG
- en: We will create threads, queues, and TCP/IP sockets using Python 3.7 or later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum it up, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopping a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing queues among different modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dialog widgets to copy files to your network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TCP/IP to communicate via networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `urlopen` to read data from websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple threads are necessary in order to keep our GUI responsive. Without
    running of our GUI program using multiple threads, our application will freeze
    and possibly crash.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple threads run within the same computer process memory space. There is
    no need for IPC, which would complicate our code. In this recipe, we will avoid
    IPC by using threads.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will increase the size of our `ScrolledText` widget, making it larger.
    Let's increase `scrol_w` to `40` and `scrol_h` to `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by using the latest code from [Chapter 5](42e25c40-ea12-4805-aa6c-2303e6ea36d0.xhtml),
    *Matplotlib Charts*:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Ch04_Code.GUI_OOP_class_imported_tooltip.py` and save it as `GUI_multiple_threads.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the changes shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `self.spin.grid` to use `sticky`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Increase the `width` size of `Entry`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Increase the `width` size of `Combobox` to `14`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e5924910-7719-43f2-9db4-e1a0de6b3c1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Import `Thread` from Python''s built-in `threading` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `method_in_a_thread` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a thread as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a breakpoint or use a `print` statement for the `run_thread` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1cbec86d-a956-41d1-a024-04d66060b70f.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After our first changes in *step 2* to `GUI_multiple_threads.py`, when we run
    the resulting GUI, the `Spinbox` widget is center-aligned in relation to the `Entry`
    widget above it, which does not look good. We'll change this by left-aligning
    the widget. We add `sticky='W'` to the `grid` control to left-align the `Spinbox`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: The GUI could still look better, so next, we increase the size of the `Entry`
    widget to get a more balanced GUI layout. After that, we also increase the `Combobox`
    widget. Running the modified and improved code results in a larger GUI, which
    we will use for this recipe and for the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create and use threads in Python, we have to import the `Thread`
    class from the `threading` module. After adding the `method_in_a_thread` method,
    we can now call our threaded method in the code, saving the instance in a variable
    called `run_thread`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a method that is threaded, but when we run the code, nothing gets
    printed to the console!
  prefs: []
  type: TYPE_NORMAL
- en: We have to start the thread first before it can run, and the next recipe will
    show us how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: However, setting a breakpoint after the GUI main event loop proves that we did
    indeed create a thread object, as can be seen in the Eclipse IDE debugger.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we prepared our GUI to use threads by first increasing the GUI
    size so we can see the results printed to the `ScrolledText` widget in a better
    way. We then imported the `Thread` class from the Python `threading` module. Next,
    we created a method that we call in a thread from within our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show us how to start a thread. It will also demonstrate why
    threads are necessary to keep our GUI responsive during long-running tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first see what happens when we call a function or a method of our GUI
    that has `sleep` associated with it without using threads.
  prefs: []
  type: TYPE_NORMAL
- en: We are using `sleep` here to simulate a real-world application that might have
    to wait for a web server or database to respond, a large file transfer, or complex
    computations to complete its task. `sleep` is a very realistic placeholder and
    shows the principle involved.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a loop into our button callback method with some `sleep` time results
    in our GUI becoming unresponsive and, when we try to close the GUI, things get
    even worse.
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_multiple_threads.py` and save it as `GUI_multiple_threads_sleep_freeze.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code results in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ecfd95d7-7a1a-47a7-92cf-9c6a281ae72e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s move the creation of the thread into its own method and then call this
    method from the button callback method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `GUI_multiple_threads_sleep_freeze.py` and save it as `GUI_multiple_threads_starting_a_thread.py`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the output. Running the code now no longer freezes
    our GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6fd3862f-eef9-49e0-b897-e56fc308af42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can print the instance of the thread by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_multiple_threads_starting_a_thread.py`.
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `print` statement to the code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking the button now creates the following printout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c5a3578-bcb5-4797-8672-31e2550089fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking the button several times, you get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4b267cee-2239-4678-9b00-28ccabc349b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Move the code with `sleep` into a loop in the `method_in_a_thread` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the button, change tabs, and then click on other widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ce438601-2e1f-4ab8-b21f-2b5b49d6aaa4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `GUI_multiple_threads_sleep_freeze.py`, we added a `sleep` statement and
    noticed how our GUI became unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: If we wait long enough, the method will eventually complete, but during this
    time, none of our GUI widgets respond to click events. We solve this problem by
    using threads.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike regular Python functions and methods, we have to `start` a method that
    will be run in its own thread! This is what we did next in `GUI_multiple_threads_starting_a_thread.py`.
    Clicking the button now results in the `create_thread` method being called, which,
    in turn, calls the `method_in_a_thread` method.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a thread and target it at a method. Next, we start the thread
    that runs the targeted method in a new thread. Running the code now no longer
    freezes our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: The GUI itself runs in its own thread, which is the main thread of the application.
  prefs: []
  type: TYPE_NORMAL
- en: When we click the button several times, we can see that each thread gets assigned
    a unique name and ID. After moving the code with `sleep` into a loop in the `method_in_a_thread`
    method, we are able to verify that threads really do solve our problem.
  prefs: []
  type: TYPE_NORMAL
- en: When clicking the button, while the numbers are being printed into the `ScrolledText`
    widget with a five-second delay, we can click around anywhere in our GUI, switch
    tabs, and so on. Our GUI has become responsive again because we are using threads!
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we called the methods of our GUI class in their own threads
    and learned that we have to start the threads. Otherwise, the thread gets created
    but just sits there waiting for us to run its target method. Also, we noticed
    that each thread gets assigned a unique name and ID. And finally, we simulated
    long-running tasks by inserting a `sleep` statement into our code, which showed
    us that threads can indeed solve our problem.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have to start a thread to actually make it do something by calling the `start()`
    method so, intuitively, we expect there to be a matching `stop()` method, but
    there is no such thing. In this recipe, we will learn how to run a thread as a
    background task, which is called a *daemon*. When closing the main thread, which
    is our GUI, all daemons will automatically be stopped as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we call methods in a thread, we can also pass arguments and keyword arguments
    to the method. We start this recipe by doing exactly that. We will start with
    the code from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By adding `args=[8]` to the thread constructor and modifying the targeted method
    to expect arguments, we can pass arguments to the threaded methods. The parameter
    to `args` has to be a sequence, so we will wrap our number in a Python list. Let''s
    go through the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_multiple_threads_starting_a_thread.py` and save it as `GUI_multiple_threads_stopping_a_thread.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change `run_thread` to `self.run_thread` and `arg=[8]`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `num_of_loops` as a new argument to `method_in_a_thread`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code, click the button, and then close the GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21acf656-06a6-4577-b10f-51817b202b84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add `self.run_thread.setDaemon(True)` to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the modified code, click the button, and then close the GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3b911aad-f77e-43d9-9f06-1c182121ef82.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now see how the recipe works!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, `run_thread` is a local variable, which we only access
    within the scope of the method inside which we created `run_thread`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By turning the local variable into a class instance attribute, we can then check
    if the thread is still running by calling `isAlive` on it from another method.
    In `GUI_multiple_threads_stopping_a_thread.py`, we have elevated our local `run_thread`
    variable to an instance attribute of our class. This enables us to access the
    `self.run_thread` variable from any method in our class.
  prefs: []
  type: TYPE_NORMAL
- en: When we click the button and then exit the GUI before the thread has finished,
    we get a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: Threads are expected to finish their assigned task, so when we close the GUI
    before the thread has completed, according to the error, Python tells us that
    the thread we started is not in the main event loop. We can solve this by turning
    the thread into a *daemon*, which will then execute as a background task. What
    this gives us is that as soon as we close our GUI, which is our main thread that
    starts other threads, the daemon threads will cleanly exit. We do this by calling
    the `setDaemon(True)` method on the thread before we start the thread.
  prefs: []
  type: TYPE_NORMAL
- en: When we now click the button and exit our GUI before the thread has completed
    its assigned task, we no longer get any errors. While there is a `start` method
    to make threads run, surprisingly there isn't really an equivalent stop method.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are running a method in a thread, which prints numbers to
    our `ScrolledText` widget. When we exit our GUI, we are no longer interested in
    the thread that used to print to our widget, so by turning the thread into a *daemon*,
    we can exit our GUI cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to use queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Python queue is a data structure that implements the **First In, First Out**
    (**FIFO**) paradigm, basically working like a pipe. You shovel something into
    the pipe on one side and it falls out on the other side of the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between this queue shoveling and shoveling mud into physical
    pipes is that, in Python queues, things do not get mixed up. You put one unit
    in, and that unit comes back out on the other side. Next, you place another unit
    in (say, for example, an instance of a class), and this entire unit will come
    back out on the other end as one piece. It comes back out at the other end in
    the exact order we inserted code into the queue.
  prefs: []
  type: TYPE_NORMAL
- en: A queue is not a stack in which we push and pop data. A stack is a **Last In,
    First Out** (**LIFO**) data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Queues are containers that hold data being fed into the queue from potentially
    different data sources. We can have different clients providing data to the queue
    whenever those clients have data available. Whichever client is ready to send
    data to our queue sends it, and we can then display this data in a widget or send
    it forward to other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple threads to complete assigned tasks in a queue is very useful
    when receiving the final results of processing and displaying them. The data is
    inserted at one end of the queue and then comes out of the other end in an ordered
    fashion, FIFO.
  prefs: []
  type: TYPE_NORMAL
- en: Our GUI might have five different button widgets such that each kicks off a
    different task that we want to display in our GUI in a widget (for example, a
    `ScrolledText` widget). These five different tasks take a different amount of
    time to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a task has completed, we immediately need to know this and display
    this information in our GUI. By creating a shared Python queue and having the
    five tasks write their results to this queue, we can display the result of whichever
    task has been completed immediately using the FIFO approach.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our GUI is ever-increasing in its functionality and usefulness, it starts
    to talk to networks, processes, and websites, and will eventually have to wait
    for data to be made available for the GUI to display.
  prefs: []
  type: TYPE_NORMAL
- en: Creating queues in Python solves the problem of waiting for data to be displayed
    inside our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to create queues in Python, we have to import the `Queue` class from
    the `queue` module. Add the following statement toward the top of the GUI module:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_multiple_threads_starting_a_thread.py` and save it as `GUI_queues.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `click_me` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code and observe the output as illustrated in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e872e17c-7ae7-4d25-b4f1-2daef454f306.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Modify `use_queues` to use `put` and `get`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code and observe the output, as illustrated in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eec7e109-b773-429b-b631-d15519251f45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Write a loop to place many messages into `Queue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/03a2a616-a142-4804-be58-29d29dcffc44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a `while` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code to see the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc9c5e41-1042-480e-ac21-ba99b95023c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s consider the scenario of the endless loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_queues.py` and save it as `GUI_queues_put_get_loop_endless_threaded.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to start `self.run_thread` as a background daemon
    thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `click_me` method, we comment out `self.use_queues()` and now call `self.create_thread()`
    instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code to see the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bcc41345-1ff2-4803-9cbb-7f79f277af56.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `GUI_queues.py`, we first add `import` statements and then create a new method
    to create `Queue`. We call the method within our button click event.
  prefs: []
  type: TYPE_NORMAL
- en: In the code, we create a local `Queue` instance that is only accessible within
    this method. If we wish to access this queue from other places, we have to turn
    it into an instance attribute of our class by using the `self` keyword, which
    binds the local variable to the entire class, making it available from any other
    method within our class. In Python, we often create class instance variables in
    the `__init__(self)` method, but Python is very pragmatic and enables us to create
    those attributes anywhere in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have an instance of a queue. We can see that this works by printing it
    out.
  prefs: []
  type: TYPE_NORMAL
- en: In order to put the data into the queue, we use the `put` command. In order
    to get the data out of the queue, we use the `get` command.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code results in the message first being placed in `Queue`, then
    being taken out of `Queue`, and then being printed to the console. We have placed
    10 messages into `Queue`, but we are only getting the first one out. The other
    messages are still inside `Queue`, waiting to be taken out in a FIFO fashion.
    In order to get all the messages that have been placed into `Queue` out, we can
    create an endless loop.
  prefs: []
  type: TYPE_NORMAL
- en: While this code works, unfortunately, it freezes our GUI. In order to fix this,
    we have to call the method in its own thread, as we did in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: We do this in `GUI_queues_put_get_loop_endless_threaded.py`.
  prefs: []
  type: TYPE_NORMAL
- en: When we now click the button, the GUI no longer freezes and the code works.
    We created `Queue` and placed messages into one side of `Queue` in a FIFO fashion.
    We got the messages out of `Queue` and then printed them to the console (`stdout`).
    We realized that we have to call the method in its own thread because, otherwise,
    our GUI might freeze.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Passing queues among different modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will pass queues around different modules. As our GUI code
    increases in complexity, we want to separate the GUI components from the business
    logic, separating them out into different modules. Modularization allows us to
    reuse code and also makes the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data to be displayed in our GUI comes from different data sources,
    we will face latency issues, which is what queues solve. By passing instances
    of `Queue` among different Python modules, we are separating the different concerns
    of the modules' functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The GUI code ideally would only be concerned with creating and displaying widgets
    and data.
  prefs: []
  type: TYPE_NORMAL
- en: The business logic modules' job is only to do the business logic and supply
    the resulting data to the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: We have to combine the two elements, ideally using as few relationships among
    the different modules as possible, reducing code interdependence.
  prefs: []
  type: TYPE_NORMAL
- en: The coding principle of avoiding unnecessary dependencies is usually called
    *loose coupling*. This is a very important principle and I strongly encourage
    you to look into it, understand it, and apply it to your own coding projects.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand the significance of *loose coupling*, we can draw some
    boxes on a whiteboard or a piece of paper. One box represents our GUI class and
    code, while the other boxes represent business logic, databases, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we draw lines between the boxes, graphing out the interdependencies between
    those boxes, which are our Python modules, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61dc851a-e4f2-423e-89aa-42e8016a91bf.png)'
  prefs: []
  type: TYPE_IMG
- en: While these three boxes connected via three lines might look a little simple,
    this is what you really would draw on a whiteboard in a software team meeting.
    I have left out any labels, but one box could be labeled **UI**, another **database**,
    and a third **business processing logic**.
  prefs: []
  type: TYPE_NORMAL
- en: The fewer lines we have between our Python boxes, the more *loosely coupled*
    our design is.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *How to use queues*, we started to use queues. In this
    recipe, we will pass instances of `Queue` from our main GUI thread to other Python
    modules, which will enable us to write to the `ScrolledText` widget from another
    module while keeping our GUI responsive.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a new Python module in our project. Let''s call it `Queues.py`.
    We''ll place a function into it (no OOP necessary yet). Sequentially, we can state
    it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Python module and name it `Queues.py`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code into this module to place messages into the instance
    queue:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next steps show how we shall import this newly created module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `GUI_queues_put_get_loop_endless_threaded.py` and save it as `GUI_passing_queues_member.py`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to invoke the function from the module we are importing:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In `GUI_passing_queues_member.py`, create an instance of `Queue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `use_queues` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code yields the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/437cc42c-7d33-46aa-9255-d96eaa75cf9d.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we create a new Python module, `Queues.py`. The `write_to_scrol` function
    within it accepts an instance of a class. We use this instance to access the methods
    and attributes of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are relying on the knowledge that our class instance has the two methods
    we are accessing within the function.
  prefs: []
  type: TYPE_NORMAL
- en: In `GUI_passing_queues_member.py`, we first import the `Queues` module, alias
    it to `bq`, and then we use it to call the function residing in the `Queues` module.
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing the module to `bq` is probably not the best name. I meant it to mean
    *background queue* because it runs threads as daemons in the background. I am
    not changing the alias in this third edition as I have used it in the first two
    editions of this book, for reasons of consistency.
  prefs: []
  type: TYPE_NORMAL
- en: In the `click_me` button callback method, we are passing `self` into this function.
    This enables us to use all of the GUI methods from another Python module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The imported module contains the `write_to_scrol` function we are calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By passing in a self-reference from the class instance to the function that
    the class is calling in another module, we now have access to all our GUI elements
    from other Python modules.
  prefs: []
  type: TYPE_NORMAL
- en: '`gui_queue` is an instance attribute and `create_thread` is a method, and both
    are defined in `GUI_passing_queues_member.py`, and we are accessing them via the
    passed-in self-reference inside the `Queues` module.'
  prefs: []
  type: TYPE_NORMAL
- en: We create `Queue` as an instance attribute of our class, placing a reference
    to it in the `__init__` method of the `GUI_passing_queues_member.py` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can put messages into the queue from our new module by simply using
    the passed-in class reference to our GUI. Notice `inst.gui_queue.put` in the `Queues.py`
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After we modified the `use_queues` method, the `create_thread` method in our
    GUI code only reads from the `Queue`, which got filled in by the business logic
    residing in our new module, which has separated the logic from our GUI module.
  prefs: []
  type: TYPE_NORMAL
- en: In order to separate the GUI widgets from the functionality that expresses the
    business logic, we created a class, made a queue an instance attribute of this
    class, and, by passing an instance of the class into a function residing in a
    different Python module, we now have access to all the GUI widgets, as well as
    the queue.
  prefs: []
  type: TYPE_NORMAL
- en: This is the magic of OOP. In the middle of a class, we pass ourselves into a
    function we are calling from within the class using the `self` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is an example of when it makes sense to program in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using dialog widgets to copy files to your network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows us how to copy files from your local hard drive to a network
    location. We will do this by using one of Python's `tkinter` built-in dialogs,
    which enables us to browse our hard drive. We can then select a file to be copied.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe also shows us how to make `Entry` widgets read-only and to default
    `Entry` to a specified location, which speeds up the browsing of our hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will extend Tab 2 of the GUI we were building in the previous recipe, *Passing
    queues among different modules*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following code to the GUI in the `create_widgets()` method toward the
    bottom, where we created Tab Control 2\. The parent of the new widget frame is
    `tab2`, which we created at the very beginning of the `create_widgets()` method.
    As long as you place the following code physically under the creation of `tab2`,
    it will work:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_passing_queues_member.py` and save it as `GUI_copy_files.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code creates the following GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8347b6be-7b48-44df-a0c4-c0849731a102.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the Browse to File... button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ce731b5-969c-4d48-ab42-0378efd326e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Open `GUI_copy_files.py`.
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following two `import` statements:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and click the Browse To button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/82704756-3891-4b5f-85b4-742074b272b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following two lines of code to the creation of the `Entry` widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and see the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ca24e3f-24e2-487a-a5fd-6d5a726d191b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, open `GUI_copy_files.py` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `GUI_copy_files.py` results in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2756175f-0bf5-4ea8-a098-aee15a687d4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `GUI_copy_files.py` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Once we click the button that invokes the `copyFile()` function, we import the
    required module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `GUI_copy_files.py` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code, browse to a file, and click the Copy button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a7baa723-878c-4235-b7c3-57b70c3ff9d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the code, but don''t browse and click the Copy button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f30c5437-aac1-4a63-962c-29eaac6b9960.png)'
  prefs: []
  type: TYPE_IMG
- en: Open `GUI_copy_files.py` and save it as `GUI_copy_files_limit.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/58658b51-0c57-414c-a60a-f9a6e7079baa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the preceding code to observe the output, as illustrated in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d9997425-532d-4e48-acdb-f41a70221cf4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `GUI_copy_files.py`, we add two buttons and two entries to Tab 2 of our GUI.
    We are not yet implementing the functionality of our button callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the Browse to File... button currently prints `hello from getFileName`
    to the console. We can use the `tkinter` built-in file dialogs after adding the
    `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: We can now use the dialogs in our code. Instead of hardcoding a path, we can
    use Python's `os` module to find the full path to where our GUI module resides.
    Clicking the Browse to File... button now opens up the `askopenfilename` dialog.
    We can now open a file in this directory or browse to a different directory. After
    selecting a file and clicking the Open button in the dialog, we will save the
    full path to the file in the `fName` local variable.
  prefs: []
  type: TYPE_NORMAL
- en: It would be nice if, when we opened our Python `askopenfilename` dialog widget,
    we would automatically default to a directory so that we would not have to browse
    all the way to where we were looking for a particular file to be opened. It is
    best to demonstrate how to do this by going back to our GUI Tab 1, which is what
    we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: We can default the values into `Entry` widgets. Back on our Tab 1, this is very
    easy. When we now run the GUI, the `name_entered` entry has a default value. We
    can get the full path to the module we are using, and then we can create a new
    subfolder just below it. We can do this as a module-level global variable, or
    we can create the subfolder within a method.
  prefs: []
  type: TYPE_NORMAL
- en: We set the defaults for both the `Entry` widgets and, after setting them, we
    make the local file `Entry` widget read-only.
  prefs: []
  type: TYPE_NORMAL
- en: This order is important. We have to first populate the entry before we make
    it read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also selecting Tab 2 before calling the main event loop and no longer
    set the focus into the `Entry` of Tab 1\. Calling `select` on our `notebook` of
    `tkinter` is zero-based, so by passing in the value of `1`, we select Tab 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we are not all on the same network, this recipe uses the local hard drive
    in place of a network.
  prefs: []
  type: TYPE_NORMAL
- en: A **UNC** path is a **Universal Naming Convention**, and what this means is
    that by using double backslashes instead of the typical `C:\`, we can access a
    server on a network.
  prefs: []
  type: TYPE_NORMAL
- en: You just have to use the UNC and replace `C:\` with `\\<servername>\<folder>`.
  prefs: []
  type: TYPE_NORMAL
- en: This example can be used to back up our code to a backup directory, which we
    can create if it does not exist by using `os.makedirs`. After selecting a file
    to copy to somewhere else, we import the Python `shutil` module. We need the full
    path to the source of the file to be copied and a network or local directory path,
    and then we append the filename to the path where we will copy it using `shutil.copy`.
  prefs: []
  type: TYPE_NORMAL
- en: '`shutil` is shorthand notation for shell utility.'
  prefs: []
  type: TYPE_NORMAL
- en: We also give feedback to the user via a message box to indicate whether the
    copying succeeded or failed. In order to do this, we import `messagebox` and alias
    it to `msg`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next code, we mix two different approaches of where to place our `import`
    statements. In Python, we have some flexibility that other languages do not provide.
    We typically place all of the `import` statements toward the very top of each
    of our Python modules so that it is clear which modules we are importing. At the
    same time, a modern coding approach is to place the creation of variables close
    to the function or method where they are first being used.
  prefs: []
  type: TYPE_NORMAL
- en: In the code, we import the message box at the top of our Python module, but
    then we also import the `shutil` Python module in a function. Why would we wish
    to do this? Does this even work? The answer is yes, it does work, and we are placing
    this `import` statement into a function because this is the only place in our
    code where we actually do need this module.
  prefs: []
  type: TYPE_NORMAL
- en: If we never call this method, then we will never import the module this method
    requires. In a sense, you can view this technique as the **lazy initialization
    design pattern**. If we don't need it, we don't import it until we really do require
    it in our Python code. The idea here is that our entire code might require, let's
    say, 20 different modules. At runtime, which modules are really needed depends
    upon the user interaction. If we never call the `copyFile()` function, then there
    is no need to import `shutil`.
  prefs: []
  type: TYPE_NORMAL
- en: When we now run our GUI, browse to a file, and click Copy, the file is copied
    to the location we specified in our Entry widget.
  prefs: []
  type: TYPE_NORMAL
- en: If the file does not exist or we forgot to browse to a file and are trying to
    copy the entire parent folder, the code will let us know this as well because
    we are using Python's built-in exception handling capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Our new `Entry` widgets did expand the width of the GUI. While it is sometimes
    nice to be able to see the entire path, at the same time, it pushes other widgets,
    making our GUI look not so good. We can solve this by restricting the width parameter
    of our `Entry` widgets. We do this in `GUI_copy_files_limit.py`. This results
    in a limited GUI size. We can right-arrow in the enabled `Entry` widget to get
    to the end of this widget.
  prefs: []
  type: TYPE_NORMAL
- en: We are copying files from our local hard drive to a network by using the Python
    shell utility. As most of us are not connected to the same local area network,
    we simulate the copying by backing up our code to a different local folder.
  prefs: []
  type: TYPE_NORMAL
- en: We are using one of `tkinter` dialog controls, and by defaulting the directory
    paths, we can increase our efficiency in copying files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using TCP/IP to communicate via networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to use `sockets` to communicate via *TCP/IP*. In order
    to achieve this, we need both an *IP address* and a *port number*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep things simple and independent of changing internet IP addresses,
    we will create our own local TCP/IP server and client, and we will learn how to
    connect the client to the server and read data via a TCP/IP connection.
  prefs: []
  type: TYPE_NORMAL
- en: We will integrate this networking capability into our GUI by using the queues
    we created in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: '**TCP/IP** short for **Transmission Control Protocol/Internet Protocol**, which
    is a set of networking protocols that allows two or more computers to communicate.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new Python module, which will be the TCP server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way to implement a TCP server in Python is to inherit from the `socketserver`
    module. We subclass `BaseRequestHandler` and then override the inherited `handle`
    method. In very few lines of Python code, we can implement a TCP server:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Python module and save it as `TCP_Server.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to create the TCP server and a `start` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Queues.py` and add the following code to create a socket and use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Open `GUI_copy_files_limit.py` and save it as `GUI_TCP_IP.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to start the TCP server in its own thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and click the Click Me! button on Tab 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2a300a1c-026c-4aa3-aa69-a5e7e4abaaa3.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `TCP_Server.py`, we are passing our `RequestHandler` class into a `TCPServer`
    initializer. The empty single quotes are a shortcut for localhost, which is our
    own PC. This is the IP address of `127.0.0.1`. The second item in the tuple is
    the *port number*. We can choose any port number that is not in use on our local
    PC.
  prefs: []
  type: TYPE_NORMAL
- en: We have to make sure that we are using the same port on the client side of the
    TCP connection; otherwise, we would not be able to connect to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we have to start the server first before clients can connect to it.
    We will modify our `Queues.py` module to become the TCP client. When we now click
    the Click Me! button, we are calling `bq.write_to_scrol_TCP(self)`, which then
    creates the socket and connection.
  prefs: []
  type: TYPE_NORMAL
- en: This is all the code we need to talk to the TCP server. In this example, we
    are simply sending some bytes to the server and the server sends them back, prepending
    some strings before returning the response.
  prefs: []
  type: TYPE_NORMAL
- en: This shows the principle of how TCP communications via networks work.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know how to connect to a remote server via TCP/IP, we will use whatever
    commands are designed by the protocol of the program we are interested in communicating
    with. The first step is to connect before we can send commands to specific applications
    residing on a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `write_to_scrol_TCP` function, we use the same loop as before, but now
    we will send the messages to the TCP server. The server modifies the received
    message and then sends it back to us. Next, we place it into the GUI class instance
    queue, which, as in the previous recipes, runs in its own thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note the `b` character before the string and then the rest of the required casting.
  prefs: []
  type: TYPE_NORMAL
- en: We start the TCP server in its own thread in the initializer of the OOP class.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3, we send strings over sockets in binary format. Adding the integer
    index now becomes a little bit convoluted as we have to cast it to a string, encode
    it, and then cast the encoded string into bytes!
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the Click Me! button on Tab 1 now creates the output in our `ScrolledText`
    widget as well as on the console, and the response because of the use of threads
    is very fast. We created a TCP server to simulate connecting to a server in our
    local area network or on the internet. We turned our queues module into a TCP
    client. We are running both the queue and the server in their own background thread,
    which keeps our GUI very responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using urlopen to read data from websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how we can easily read entire web pages by using some of Python's
    built-in modules. We will display the web page data first in its raw format and
    then decode it, and then we will display it in our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will read the data from a web page and then display it in the `ScrolledText`
    widget of our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a new Python module and name it `URL.py`. We then import the
    required functionality to read web pages using Python. We can do this in very
    few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new module and name it `URL.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to open and read the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code and observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/300c4819-faeb-4a64-9f03-b8687d639cbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Compare the result to the official Python web page we just read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c82a0c1-eabe-40f5-af94-b4f73ac47a10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s consider the next scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `URL.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the code into a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Open `GUI_TCP_IP.py` from the previous recipe and save it as `GUI_URL.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `URL` module and modify the `click_me` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code, the output of which is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3ea25447-fbef-40de-a100-8e46dcf4881d.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about the process in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We wrap the `URL.py` code in a `try...except` block similar to Java and C#.
    This is a modern approach to coding, which Python supports. Whenever we have code
    that might not complete, we can experiment with this code and, if it works, all
    is fine. If the block of code in the `try...except` block does not work, the Python
    interpreter will throw one of several possible exceptions, which we can then catch.
    Once we have caught the exception, we can decide what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: There is a hierarchy of exceptions in Python, and we can also create our own
    classes that inherit from and extend the Python exception classes. In the following
    code, we are mainly concerned that the URL we are trying to open might not be
    available, so we wrap our code within a `try...except` code block. If the code
    succeeds in opening the requested URL, all is fine. If it fails, maybe because
    our internet connection is down, we fall into the exception part of the code and
    print out that an exception has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about Python exception handling at [https://docs.python.org/3.7/library/exceptions.html](https://docs.python.org/3.7/library/exceptions.html).
  prefs: []
  type: TYPE_NORMAL
- en: By calling `urlopen` on the official Python website, we get the entire data
    as one long string. The first `print` statement prints this long string out to
    the console. We then call `decode` on the result, and this time we get a little
    over 1,000 lines of web data, including some white space. We also print out `type`
    for calling `urlopen`, which is an `http.client.HTTPResponse` object. Actually,
    we print it out first.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we display this data in our GUI inside the `ScrolledText` widget. In order
    to do so, we have to connect our new module, which reads the data from the web
    page to our GUI. In order to do this, we need a reference to our GUI, and one
    way to do this is by tying our new module to the Tab 1 button callback. We can
    return the decoded HTML data from the Python web page to the `Button` widget,
    which we can then place into the `ScrolledText` control.
  prefs: []
  type: TYPE_NORMAL
- en: We turn our `URL.py` code into a function and return the data to the calling
    code. We can now write the data from our button callback method to the `ScrolledText`
    control by first importing the new module and then inserting the data into the
    widget. We also give it some sleep after the call to `write_to_scrol.`
  prefs: []
  type: TYPE_NORMAL
- en: In `GUI_URL.py`, the HTML data is now displayed in our GUI widget.
  prefs: []
  type: TYPE_NORMAL
