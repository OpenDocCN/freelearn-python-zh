["```py\n$ ros2 interface list | grep example_interfaces/srv\nexample_interfaces/srv/AddTwoInts\nexample_interfaces/srv/SetBool\nexample_interfaces/srv/Trigger\n```", "```py\n$ ros2 interface list | grep std_srvs/srv\nstd_srvs/srv/Empty\nstd_srvs/srv/SetBool\nstd_srvs/srv/Trigger\n```", "```py\n$ ros2 interface show example_interfaces/srv/SetBool\n# some comments\nbool data # e.g. for hardware enabling / disabling\n---\nbool success   # indicate successful run of triggered service\nstring message # informational, e.g. for error messages\n```", "```py\n$ cd ~/ros2_ws/src/my_robot_interfaces/\n$ mkdir srv\n```", "```py\n$ cd ~/ros2_ws/src/my_robot_interfaces/srv/\n$ touch ResetCounter.srv\n```", "```py\nint64 reset_value\n---\nbool success\nstring message\n```", "```py\nrosidl_generate_interfaces(${PROJECT_NAME}\n  \"msg/HardwareStatus.msg\"\n  \"srv/ResetCounter.srv\"\n)\n```", "```py\n$ colcon build --packages-select my_robot_interfaces\n```", "```py\n$ ros2 interface show my_robot_interfaces/srv/ResetCounter\nint64 reset_value\n---\nbool success\nstring message\n```", "```py\n<depend>rclpy</depend>\n<depend>example_interfaces</depend>\n<depend>my_robot_interfaces</depend>\n```", "```py\n#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\nfrom my_robot_interfaces.srv import ResetCounter\n```", "```py\ndef __init__(self):\n    super().__init__(\"number_counter\")\n    self.counter_ = 0\n    self.number_subscriber_ = self.create_subscription(Int64, \"number\", self.callback_number, 10)\n    self.reset_counter_service_ = self.create_service(ResetCounter, \"reset_counter\", self.callback_reset_counter)\n    self.get_logger().info(\"Number Counter has been started.\")\n```", "```py\ndef callback_reset_counter(self, request: ResetCounter.Request, response: ResetCounter.Response):\n    self.counter_ = request.reset_value\n    self.get_logger().info(\"Reset counter to \" + str(self.counter_))\n    response.success = True\n    response.message = \"Success\"\n    return response\n```", "```py\ndef callback_reset_counter(self, request: ResetCounter.Request, response: ResetCounter.Response):\n    if request.reset_value < 0:\n        response.success = False\n        response.message = \"Cannot reset counter to a negative value\"\n    elif request.reset_value > self.counter_:\n        response.success = False\n        response.message = \"Reset value must be lower than current counter value\"\n    else:\n        self.counter_ = request.reset_value\n        self.get_logger().info(\"Reset counter to \" + str(self.counter_))\n        response.success = True\n        response.message = \"Success\"\n    return response\n```", "```py\n$ ros2 run my_py_pkg number_counter\n[INFO] [1712647809.789229368] [number_counter]: Number Counter has been started.\n```", "```py\n<depend>rclcpp</depend>\n<depend>example_interfaces</depend>\n<depend>my_robot_interfaces</depend>\n```", "```py\n#include \"rclcpp/rclcpp.hpp\"\n#include \"example_interfaces/msg/int64.hpp\"\n#include \"my_robot_interfaces/srv/reset_counter.hpp\"\n```", "```py\nusing ResetCounter = my_robot_interfaces::srv::ResetCounter;\n```", "```py\nrclcpp::Service<ResetCounter>::SharedPtr reset_counter_service_;\n```", "```py\nreset_counter_service_ = this->create_service<ResetCounter>(\"reset_counter\",  std::bind(&NumberCounterNode::callbackResetCounter, this, _1, _2));\n```", "```py\nvoid callbackResetCounter(const ResetCounter::Request::SharedPtr request, const ResetCounter::Response::SharedPtr response)\n{\n    if (request->reset_value < 0) {\n        response->success = false;\n        response->message = \"Cannot reset counter to a negative value\";\n    }\n    else if (request->reset_value > counter_) {\n        response->success = false;\n        response->message = \"Reset value must be lower than current counter value\";\n    }\n    else {\n        counter_ = request->reset_value;\n        RCLCPP_INFO(this->get_logger(), \"Reset counter to %d\", counter_);\n        response->success = true;\n        response->message = \"Success\";\n    }\n}\n```", "```py\nfind_package(ament_cmake REQUIRED)\nfind_package(rclcpp REQUIRED)\nfind_package(example_interfaces REQUIRED)\nfind_package(my_robot_interfaces REQUIRED)\n```", "```py\nadd_executable(number_counter src/number_counter.cpp)\nament_target_dependencies(number_counter rclcpp example_interfaces my_robot_interfaces)\n```", "```py\nfatal error: my_robot_interfaces/srv/reset_counter.hpp: No such file or directory\nFailed   <<< my_cpp_pkg [1.49s, exited with code 2]\n```", "```py\n$ ros2 run my_cpp_pkg number_counter\n[INFO] [1712726520.316615636] [number_counter]: Number Counter has been started.\n```", "```py\nfrom my_robot_interfaces.srv import ResetCounter\n```", "```py\ndef __init__(self):\n    super().__init__(\"reset_counter_client\")\n    self.client_ = self.create_client(ResetCounter, \"reset_counter\")\n```", "```py\ndef call_reset_counter(self, value):\n    while not self.client_.wait_for_service(1.0):\n        self.get_logger().warn(\"Waiting for service...\")\n    request = ResetCounter.Request()\n    request.reset_value = value\n    future = self.client_.call_async(request)\n    future.add_done_callback(\n        self.callback_reset_counter_response)\n```", "```py\ndef callback_reset_counter_response(self, future):\n    response = future.result()\n    self.get_logger().info(\"Success flag: \" + str(response.success))\n    self.get_logger().info(\"Message: \" + str(response.message))\n```", "```py\nnode = ResetCounterClientNode()\nnode.call_reset_counter(20)\nrclpy.spin(node)\n```", "```py\n$ ros2 run my_py_pkg reset_counter_client\n[INFO] [1713082991.940407360] [reset_counter_client]: Success flag: False\n[INFO] [1713082991.940899261] [reset_counter_client]: Message: Reset value must be lower than current counter value\n```", "```py\n$ ros2 run my_py_pkg reset_counter_client\n[INFO] [1713082968.101789868] [reset_counter_client]: Success flag: True\n[INFO] [1713082968.102277613] [reset_counter_client]: Message: Success\n```", "```py\n[WARN] [1713082991.437932627] [reset_counter_client]: Waiting for service...\n```", "```py\n[INFO] [1713083108.125753986] [number_counter]: Reset counter to 20\n```", "```py\n#include \"my_robot_interfaces/srv/reset_counter.hpp\"\n```", "```py\nusing ResetCounter = my_robot_interfaces::srv::ResetCounter;\nusing namespace std::chrono_literals;\nusing namespace std::placeholders;\n```", "```py\nrclcpp::Client<ResetCounter>::SharedPtr client_;\n```", "```py\nResetCounterClientNode() : Node(\"reset_counter_client\")\n{\n    client_ = this->create_client<ResetCounter>(\"reset_counter\");\n}\n```", "```py\nvoid callResetCounter(int value)\n{\n    while (!client_->wait_for_service(1s)) {\n        RCLCPP_WARN(this->get_logger(), \"Waiting for the server...\");\n    }\n    auto request = std::make_shared<ResetCounter::Request>();\n    request->reset_value = value;\n    client_->async_send_request(request, std::bind(&ResetCounterClientNode::callbackResetCounterResponse, this, _1));\n}\n```", "```py\nvoid callbackResetCounterResponse(\n    rclcpp::Client<ResetCounter>::SharedFuture future)\n{\n    auto response = future.get();\n    RCLCPP_INFO(this->get_logger(), \"Success flag: %d, Message: %s\", (int)response->success, response->message.c_str());\n}\n```", "```py\nauto node = std::make_shared<ResetCounterClientNode>();\nnode->callResetCounter(20);\nrclcpp::spin(node);\n```", "```py\n$ ros2 service list\n/number_counter/describe_parameters\n/number_counter/get_parameter_types\n/number_counter/get_parameters\n/number_publisher/get_type_description\n/number_counter/list_parameters\n/number_counter/set_parameters\n/number_counter/set_parameters_atomically\n/reset_counter\n```", "```py\n$ ros2 service type /reset_counter\nmy_robot_interfaces/srv/ResetCounter\n```", "```py\n$ ros2 interface show my_robot_interfaces/srv/ResetCounter\nint64 reset_value\n---\nbool success\nstring message\n```", "```py\n$ ros2 service call /reset_counter \\ my_robot_interfaces/srv/ResetCounter {reset_value: 7}\"\nwaiting for service to become available...\nrequester: making request: my_robot_interfaces.srv.ResetCounter_Request(reset_value=7)\nresponse:\nmy_robot_interfaces.srv.ResetCounter_Response(success=True, message='Success')\n```", "```py\n$ ros2 service call /reset_counter \\my_robot_interfaces/srv/ResetCounter \"{reset_value: -7}\"\nwaiting for service to become available...\nrequester: making request: my_robot_interfaces.srv.ResetCounter_Request(reset_value=-7)\nresponse:\nmy_robot_interfaces.srv.ResetCounter_Response(success=False, message='Cannot reset counter to a negative value')\n```", "```py\n$ ros2 run my_py_pkg number_counter --ros-args -r \\ reset_counter:=reset_counter1\n```", "```py\n$ ros2 service list\n# Some other services\n/reset_counter1\n```", "```py\n$ ros2 run my_py_pkg reset_counter_client --ros-args -r \\ reset_counter:=reset_counter1\n```", "```py\n$ ros2 service type /turtle1/set_pen\nturtlesim/srv/SetPen\n$ ros2 interface show turtlesim/srv/SetPen\nuint8 r\nuint8 g\nuint8 b\nuint8 width\nuint8 off\n---\n```", "```py\n$ ros2 service call /turtle1/set_pen turtlesim/srv/SetPen \\ \"{r: 255, g: 0, b: 0}\"\n```", "```py\nfrom turtlesim.srv import SetPen\n```", "```py\nself.set_pen_client_ = self.create_client(SetPen, \"/turtle1/set_pen\")\n```", "```py\ndef call_set_pen(self, r, g, b):\n    while not self.set_pen_client_.wait_for_service(1.0):\n        self.get_logger().warn(\"Waiting for service...\")\n    request = SetPen.Request()\n    request.r = r\n    request.g = g\n    request.b = b\n    future = self.set_pen_client_.call_async(request)\n    future.add_done_callback(\nself.callback_set_pen_response)\ndef callback_set_pen_response(self, future):\n    self.get_logger().info(\"Successfully changed pen color\")\n```", "```py\nif pose.x > 5.5 and self.previous_x_ <= 5.5:\n    self.previous_x_ = pose.x\n    self.get_logger().info(\"Set color to red.\")\n    self.call_set_pen(255, 0, 0)\nelif pose.x <= 5.5 and self.previous_x_ > 5.5:\n    self.previous_x_ = pose.x\n    self.get_logger().info(\"Set color to green.\")\n    self.call_set_pen(0, 255, 0)\n```", "```py\nself.previous_x_ = 0.0\n```", "```py\n$ ros2 topic hz /turtle1/pose\naverage rate: 62.515\n```", "```py\nbool activate\n---\nstring message\n```", "```py\nros2 interface show my_robot_interfaces/srv/ActivateTurtle\n```", "```py\n<depend>my_robot_interfaces</depend>\n```", "```py\nfrom my_robot_interfaces.srv import ActivateTurtle\n```", "```py\nself.is_active_ = True\nself.activate_turtle_service_ = self.create_service(ActivateTurtle, \"activate_turtle\", self.callback_activate_turtle)\n```", "```py\ndef callback_activate_turtle(self, request: ActivateTurtle.Request, response: ActivateTurtle.Response):\n    self.is_active_ = request.activate\n    if request.activate:\n        response.message = \"Starting the turtle\"\n    else:\n        response.message = \"Stopping the turtle\"\n    return response\n```", "```py\ndef callback_pose(self, pose: Pose):\n    if self.is_active_:\n        # Entire code for the callback, inside the \"if\"\n```", "```py\n$ ros2 service call /activate_turtle \\\nmy_robot_interfaces/srv/ActivateTurtle \"{activate: false}\"\n```"]