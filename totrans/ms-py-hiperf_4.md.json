["```py\nimport math\n\nimport time\n\nimport random\n\nclass Memoized:\n\n  def __init__(self, fn):\n\n    self.fn = fn\n\n    self.results = {}\n\n  def __call__(self, *args):\n\n    key = ''.join(map(str, args[0]))\n\n    try:\n\n      return self.results[key]\n\n    except KeyError:\n\n      self.results[key] = self.fn(*args)\n\n    return self.results[key]\n\n@Memoized\n\ndef twoParamsMemoized(values, period):\n\n  totalSum = 0\n\n  for x in range(0, 100):\n\n    for v in values:\n\n      totalSum = math.pow((math.sqrt(v) * period), 4) + totalSum\n\n  return totalSum\n\ndef twoParams(values, period):\n\n  totalSum = 0\n\n  for x in range(0, 100):\n\n    for v in values:\n\n      totalSum = math.pow((math.sqrt(v) * period), 4) + totalSum\n\n  return totalSum\n\ndef performTest():\n\n    valuesList = []\n\n    for i in range(0, 10):\n\n        valuesList.append(random.sample(xrange(1, 101), 10))\n\n    start_time = time.clock()\n\n    for x in range(0, 10):\n\n      for values in valuesList:\n\n          twoParamsMemoized(values, random.random())\n\n    end_time = time.clock() - start_time\n\n    print \"Fixed params, memoized: %s\" % (end_time)\n\n    start_time = time.clock()\n\n    for x in range(0, 10):\n\n      for values in valuesList:\n\n          twoParams(values, random.random())\n\n    end_time = time.clock() - start_time\n\n    print \"Fixed params, without memoizing: %s\" % (end_time)\n\n    start_time = time.clock()\n\n    for x in range(0, 10):\n\n      for values in valuesList:\n\n          twoParamsMemoized(random.sample(xrange(1,2000), 10), random.random())\n\n    end_time = time.clock() - start_time\n\n    print \"Random params, memoized: %s\" % (end_time)\n\n    start_time = time.clock()\n\n    for x in range(0, 10):\n\n      for values in valuesList:\n\n          twoParams(random.sample(xrange(1,2000), 10), random.random())\n\n    end_time = time.clock() - start_time\n\n    print \"Random params, without memoizing: %s\" % (end_time)\n\nperformTest()\n```", "```py\nkey = ''.join(map(str, args[0]))\n```", "```py\ndef complexTrigFunction(x):\n  return math.sin(x) * math.cos(x)**2\n```", "```py\nimport math\nimport time\nfrom collections import defaultdict\nimport itertools\n\ntrig_lookup_table = defaultdict(lambda: 0) \n\ndef drange(start, stop, step):\n    assert(step != 0)\n    sample_count = math.fabs((stop - start) / step)\n    return itertools.islice(itertools.count(start, step), sample_count)\n\ndef complexTrigFunction(x):\n  return math.sin(x) * math.cos(x)**2\n\ndef lookUpTrig(x):\n  return trig_lookup_table[int(x)]\n\nfor x in range(-1000, 1000):\n  trig_lookup_table[x] = complexTrigFunction(x)\n\ntrig_results = []\nlookup_results = []\n\ninit_time = time.clock()\nfor x in drange(-100, 100, 0.1):\n  trig_results.append(complexTrigFunction(x))\nprint \"Trig results: %s\" % (time.clock() - init_time)\n\ninit_time = time.clock()\nfor x in drange(-100, 100, 0.1):\n  lookup_results.append(lookUpTrig(x))\nprint \"Lookup results: %s\" % (time.clock() - init_time)\n\nfor idx in range(0, 200):\n  print \"%s\\t%s\" % (trig_results [idx], lookup_results[idx])\n```", "```py\nimport math\nimport time\nfrom collections import defaultdict\nimport itertools\n\ntrig_lookup_table = defaultdict(lambda: 0) \n\ndef drange(start, stop, step):\n    assert(step != 0)\n    sample_count = math.fabs((stop - start) / step)\n    return itertools.islice(itertools.count(start, step), sample_count)\n\ndef complexTrigFunction(x):\n  return math.sin(x) * math.cos(x)**2\n\nreverse_indexes = {}\nfor x in range(-1000, 1000):\n  trig_lookup_table[x] = complexTrigFunction(math.pi * x / 1000)\n\ncomplex_results = []\nlookup_results = []\n\ninit_time = time.clock()\nfor x in drange(-10, 10, 0.1):\n  complex_results .append(complexTrigFunction(x))\nprint \"Complex trig function: %s\" % (time.clock() - init_time)\n\ninit_time = time.clock()\nfactor = 1000 / math.pi\nfor x in drange(-10 * factor, 10 * factor, 0.1 * factor):\n  lookup_results.append(trig_lookup_table[int(x)])\nprint \"Lookup results: %s\" % (time.clock() - init_time)\n\nfor idx in range(0, len(lookup_results )):\n  print \"%s\\t%s\" % (complex_results [idx], lookup_results [idx])\n```", "```py\nimport math \n\n#original function\ndef degree_sin(deg):\n    return math.sin(deg * math.pi / 180.0)\n\n#optimized function, the factor variable is calculated during function creation time, \n#and so is the lookup of the math.sin method.\ndef degree_sin(deg, factor=math.pi/180.0, sin=math.sin):\n    return sin(deg * factor)\n```", "```py\nimport time\nimport math\n\ndef degree_sin(deg):\n  return math.sin(deg * math.pi / 180.0) * math.cos(deg * math.pi / 180.0)\n\ndef degree_sin_opt(deg, factor=math.pi/180.0, sin=math.sin, cos = math.cos):\n  return sin(deg * factor) * cos(deg * factor)\n\nnormal_times = []\noptimized_times = []\n\nfor y in range(100):\n  init = time.clock()\n   for x in range(1000):\n    degree_sin(x)\n  normal_times.append(time.clock() - init)\n\n  init = time.clock()\n  for x in range(1000):\n    degree_sin_opt(x)\n  optimized_times.append(time.clock() - init)\n\nprint \"Normal function: %s\" % (reduce(lambda x, y: x + y, normal_times, 0) / 100)\nprint \"Optimized function: %s\" % (reduce(lambda x, y: x + y, optimized_times, 0 ) / 100)\n```", "```py\n#using list comprehension to generate a list of the first 50 multiples of 2\nmultiples_of_two = [x for x in range(100) if x % 2 == 0]\n\n#now let's see the same list, generated using a for-loop\nmultiples_of_two = []\nfor x in range(100):\n  if x % 2 == 0:\n    multiples_of_two.append(x)\n```", "```py\nimport dis\nimport timeit\n\nprograms = dict(\n    loop=\"\"\"\nmultiples_of_two = []\nfor x in range(100):\n  if x % 2 == 0:\n    multiples_of_two.append(x)\n\"\"\",\n    comprehension='multiples_of_two = [x for x in range(100) if x % 2 == 0]',\n)\n\nfor name, text in programs.iteritems():\n    print name, timeit.Timer(stmt=text).timeit()\n    code = compile(text, '<string>', 'exec')\n    dis.disassemble(code)\n```", "```py\nmy_list = (x**2 for x in range(100))\n#you can't do this\nprint my_list[1]\n\n#but you can do this\nfor number in my_list:\n  print number\n```", "```py\nimport math\nimport time\n\ndef check_prime(x):\n  values = xrange(2, int(math.sqrt(x)))\n  for i in values:\n    if x % i == 0:\n      return False \n\n  return True\n\ninit = time.clock()\nnumbers_py = [x for x in xrange(1000000) if check_prime(x)]\nprint \"%s\" % (time.clock() - init)\n```", "```py\n#include <stdio.h>\n#include <math.h>\n\nint check_prime(int a)\n{\n  int c;\n  for ( c = 2 ; c <= sqrt(a) ; c++ ) { \n    if ( a%c == 0 )\n     return 0;\n  }\n\n  return 1;\n\n}\n```", "```py\n$gcc -shared -o check_primes.so -fPIC check_primes.c \n\n```", "```py\nimport time\nimport ctypes\nimport math\n\ncheck_primes_types = ctypes.CDLL('./check_prime.so').check_prime\n\ndef check_prime(x):\n  values = xrange(2, int(math.sqrt(x)))\n  for i in values:\n    if x % i == 0:\n      return False \n\n  return True\n\ninit = time.clock()\nnumbers_py = [x for x in xrange(1000000) if check_prime(x)]\nprint \"Full python version: %s seconds\" % (time.clock() - init)\n\ninit = time.clock()\nnumbers_c = [x for x in xrange(1000000) if check_primes_types(x)]\nprint \"C version: %s seconds\" % (time.clock() - init)\nprint len(numbers_py)\n```", "```py\nrandoms = [random.randrange(1, 100) for x in xrange(1000000)]While this one, takes only 0.3 seconds:\nrandoms = [(libc.rand() % 100) for x in xrange(1000000)]\n```", "```py\nimport time\nimport random\nfrom ctypes import cdll\n\nlibc = cdll.LoadLibrary('libc.so.6') #linux systems\n#libc = cdll.msvcrt #windows systems\n\ninit = time.clock()\nrandoms = [random.randrange(1, 100) for x in xrange(1000000)]\nprint \"Pure python: %s seconds\" % (time.clock() - init)\n\ninit = time.clock()\nrandoms = [(libc.rand() % 100) for x in xrange(1000000)]\nprint \"C version : %s seconds\" % (time.clock() - init)\n```", "```py\na = \"This is a string\"\nb = \"This is a string\"\n\nprint id(a) == id(b)  #prints  True\n\nprint id(a) == id(\"This is a string\") #prints True\n\nprint id(b) == id(\"This is another String\") #prints False\n```", "```py\nfull_doc = \"\"\nfor word in word_list:\n  full_doc += word\n```", "```py\nfull_doc = \"\".join(world_list)\n```", "```py\nimport time\nimport sys\n\noption = sys.argv[1]\n\nwords =  [str(x) for x in xrange(1000000)]\n\nif option == '1':\n  full_doc = \"\"\n  init = time.clock()\n  for w in words:\n    full_doc += w\n  print \"Time using for-loop: %s seconds\" % (time.clock() - init)\nelse:\n  init = time.clock()\n  full_doc = \"\".join(words)\n  print \"Time using join: %s seconds\" % (time.clock() - init)\n```", "```py\n    $ /usr/bin/time -f \"Memory: %M bytes\" python script.py 1 \n\n    ```", "```py\n    $ /usr/bin/time -f \"Memory: %M bytes\" python script.py 0 \n\n    ```", "```py\nTime using for-loop: 0.155635 seconds\nMemory: 66212 bytes\n\n```", "```py\nTime using join: 0.015284 seconds\nMemory: 66092 bytes\n\n```", "```py\ndocument = title + introduction + main_piece + conclusion\n```", "```py\ndocument = \"%s%s%s%s\" % (title, introduction, main_piece, conclusion)\n```", "```py\ndocument = \"%(title)s%(introduction)s%(main_piece)s%(conclusion)s\" % locals()\n```", "```py\n    import time\n    def fn(nmbr):\n       return (nmbr ** nmbr) / (nmbr + 1)\n    nmbr = 0\n    init = time.clock()\n    for i in range(1000):\n       fn(i)\n    print \"Total time: %s\" % (time.clock() - init)\n\n    init = time.clock()\n    nmbr = 0\n    for i in range(1000):\n      nmbr = (nmbr ** nmbr) / (nmbr + 1)\n    print \"Total time (inline): %s\" % (time.clock() - init)\n    ```", "```py\n    import random\n    import time\n\n    #Generate 2 random lists of random elements\n    list1 = [ [random.randrange(0, 100), chr(random.randrange(32, 122))] for x in range(100000)]\n    list2 = [ [random.randrange(0, 100), chr(random.randrange(32, 122))] for x in range(100000)]\n\n    #sort by string, using a comparison function\n    init = time.clock()\n    list1.sort(cmp=lambda a,b: cmp(a[1], b[1]))\n    print \"Sort by comp: %s\" % (time.clock() - init) #prints  0.213434\n\n    #sort by key, using the string element as key\n    init = time.clock()\n    list2.sort(key=lambda a: a[1])\n    print \"Sort by key: %s\" % (time.clock() - init) #prints 0.047623\n\n    ```", "```py\n    a = \"hello world\"\n    b = 123\n    #this is faster\n    a,b = b, a\n    #than doing\n    tmp  = a\n    a = b\n    b = tmp\n\n    ```", "```py\n    import time\n    import collections\n\n    class Obj(object):\n      def __init__(self, i):\n        self.i = i\n        self.l = []\n    all = {}\n\n    init = time.clock()\n    for i in range(1000000):\n      all[i] = Obj(i)\n    print \"Regular Objects: %s\" % (time.clock() - init) #prints Regular Objects: 2.384832\n\n    Obj = collections.namedtuple('Obj', 'i l')\n\n    all = {}\n    init = time.clock()\n    for i in range(1000000):\n      all[i] = Obj(i, [])\n    print \"NamedTuples Objects: %s\" % (time.clock() - init) #prints  NamedTuples Objects: 1.272023\n\n    ```"]