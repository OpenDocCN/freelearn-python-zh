<html><head></head><body>
		<div><h1 id="_idParaDest-141" class="chapter-number"><a id="_idTextAnchor143"/><st c="0">6</st></h1>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor144"/><st c="2">Developing Computational and Scientific Applications</st></h1>
			<p><st c="54">Computational scientists always choose easy-to-use, effective, and accurate GUI-based applications for their discovery, analysis, synthesis, data mines, and number crunches to save time and effort in arriving at some conclusions for their studies. </st><st c="303">Although powerful computational tools are available in the market, such as Maple, Matlab, MathCAD, and Mathematica, scientists still prefer mechanisms that can provide them with further customizations to apply their desired precision, accuracy, and calibration for their mathematical and statistical models. </st><st c="611">In other words, they still prefer custom-made applications that can fit with their laboratory setup </st><st c="711">and parameters.</st></p>
			<p><st c="726">Since the utmost priority is to provide scientists with accurate results given an infinite number of data, it is always a challenge as to what application frameworks to use in building scalable, real-time, and fast modules suited to their needs. </st><st c="973">The ultimate requirement is to create and run asynchronous transactions for complex numerical algorithms, which asynchronous Flask </st><st c="1104">can provide.</st></p>
			<p><st c="1116">The Flask has asynchronous components that can build complex, fast, and real-time applications for scientists. </st><st c="1228">Because of its flexibility, asynchronous features, and wide-ranging support, this framework has the complete building blocks that can provide scientists with their tailor-fit </st><st c="1403">scientific software.</st></p>
			<p><st c="1423">This chapter will cover the following computational building blocks that flask[async] </st><st c="1510">can provide:</st></p>
			<ul>
				<li><a id="_idTextAnchor145"/><st c="1522">Uploading </st><strong class="bold"><st c="1533">Comma-Separated Values</st></strong><st c="1555"> (</st><strong class="bold"><st c="1557">CSV</st></strong><st c="1560">) and </st><strong class="bold"><st c="1567">Microsoft Excel Spreadsheets</st></strong><st c="1595"> (</st><strong class="bold"><st c="1597">XLSX</st></strong><st c="1601">) documents </st><st c="1614">for computing</st></li>
				<li><a id="_idTextAnchor146"/><st c="1627">Implementing symbolic computation </st><st c="1662">with visualization</st></li>
				<li><st c="1680">Using the </st><code><st c="1691">pandas</st></code><st c="1697"> module for data and </st><st c="1718">graphical analysis</st></li>
				<li><st c="1736">Creating and rendering </st><st c="1760">LaTeX documents</st></li>
				<li><st c="1775">Building graphical charts with </st><st c="1807">frontend libraries</st></li>
				<li><st c="1825">Building real-time data plots using WebSocket and </st><strong class="bold"><st c="1876">Server-Sent </st></strong><strong class="bold"><st c="1888">Events</st></strong><st c="1894"> (</st><strong class="bold"><st c="1896">SSE</st></strong><st c="1899">)</st></li>
				<li><st c="1901">Using asynchronous background tasks for </st><st c="1941">resource-intensive computations</st></li>
				<li><st c="1972">Incorporating Julia packages </st><st c="2002">with Flask</st></li>
			</ul>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor147"/><st c="2012">Technical requirements</st></h1>
			<p><st c="2035">This chapter will highlight a software prototype for an </st><em class="italic"><st c="2092">Online Housing Pricing Prediction and Analysis</st></em><st c="2138"> application with features expected to appear in many scientific applications. </st><st c="2217">First, it has simple and formal GUIs that capture user data through forms. </st><st c="2292">Forms that will ask for formulas, variable values, and constants with the capability to provide graphical plots, either in real-time or immediately after computations, are used. </st><st c="2470">Second, it is a web application that can be accessible within teams or organizations. </st><st c="2556">Finally, the application can run highly computational tasks asynchronously with the </st><st c="2640">Flask platform.</st></p>
			<p><st c="2655">The test data used in this chapter are from </st><a href="https://www.kaggle.com/datasets/yasserh/housing-prices-dataset"><st c="2700">https://www.kaggle.com/datasets/yasserh/housing-prices-dataset</st></a><st c="2762"> and </st><a href="https://data.world/finance/international-house-price-database"><st c="2767">https://data.world/finance/international-house-price-database</st></a><st c="2828">. On the other hand, this project uses the </st><code><st c="2871">Blueprint</st></code><st c="2880"> approach for managing the modules and components. </st><st c="2931">All files are available </st><st c="2955">at </st><a href="https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch06"><st c="2958">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch06</st></a><st c="3039">.</st></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor148"/><st c="3040">Uploading CSV and XLSX documents for computing</st></h1>
			<p><st c="3087">The application</st><a id="_idIndexMarker367"/><st c="3103"> will deal </st><a id="_idIndexMarker368"/><st c="3114">with XLSX and CSV files that contain numerical data affecting worldwide house prices, such as the periodic actual and </st><a id="_idIndexMarker369"/><st c="3232">nominal </st><strong class="bold"><st c="3240">House Price Index</st></strong><st c="3257"> (</st><strong class="bold"><st c="3259">HPI</st></strong><st c="3262">) of each country and the nominal and actual </st><strong class="bold"><st c="3308">Personal Disposable Income</st></strong><st c="3334"> (</st><strong class="bold"><st c="3336">PDI</st></strong><st c="3339">) of the </st><a id="_idIndexMarker370"/><st c="3349">customers. </st><st c="3360">Also, some documents will show how factors such as the house area, furnishing status, the main road preference, and the number of bedrooms and bathrooms can affect the housing prices in a country. </st><st c="3557">Our application will upload these documents to the server for </st><st c="3619">data analysis.</st></p>
			<p><st c="3633">Flask has built-in support for a single- or multiple-file-uploading process through an HTML </st><code><st c="3726">&lt;form&gt;</st></code><st c="3732"> with </st><code><st c="3738">enctype</st></code><st c="3745"> of </st><code><st c="3749">multipart/form-data</st></code><st c="3768">. It stores all uploaded files in the </st><code><st c="3806">request.files</st></code><st c="3819"> dictionary as </st><code><st c="3834">FileStorage</st></code><st c="3845"> instances. </st><code><st c="3857">FileStorage</st></code><st c="3868"> is a thin wrapper class from the </st><code><st c="3902">werkzeug</st></code><st c="3910"> module used by Flask to represent an incoming file. </st><st c="3963">The following is an HTML script that uploads an XLSX document for data analysis </st><a id="_idIndexMarker371"/><st c="4043">using</st><a id="_idIndexMarker372"/><st c="4048"> the </st><code><st c="4053">pandas</st></code><st c="4059"> module:</st></p>
			<pre class="source-code"><st c="4067">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  … … … … … …
  &lt;body&gt;
    &lt;h1&gt;Data Analysis … Actual House Price Index (HPI)&lt;/h1&gt;
    &lt;form action="{{request.path}}" method="POST" </st><strong class="bold"><st c="4221">enctype="multipart/form-data"</st></strong><st c="4250">&gt;
        Upload XLSX file:
        </st><strong class="bold"><st c="4271">&lt;input type="file" name="data_file"/&gt;</st></strong><st c="4308">&lt;br/&gt;
        &lt;input type="submit" value="Upload File"/&gt;
    &lt;/form&gt;
  &lt;/body&gt;&lt;br/&gt;
  </st><strong class="bold"><st c="4379">{%if df_table == None %}</st></strong><strong class="bold"><st c="4403">&lt;p&gt;No analysis.&lt;/p&gt;</st></strong><strong class="bold"><st c="4423">{% else %}</st></strong><strong class="bold"><st c="4434">{{ table | safe}}</st></strong><strong class="bold"><st c="4452">{% endif %}</st></strong><st c="4464">
&lt;/html&gt;</st></pre>			<p><st c="4472">The following snippet shows the </st><code><st c="4505">view</st></code><st c="4509"> function implementation that renders the given page and accepts the</st><a id="_idIndexMarker373"/><st c="4577"> incoming</st><a id="_idIndexMarker374"/> <st c="4586">XLSX document:</st></p>
			<pre class="source-code"><st c="4601">
from modules.upload import upload_bp
from flask import render_template, request, current_app
</st><strong class="bold"><st c="4695">from werkzeug.utils import secure_filename</st></strong>
<strong class="bold"><st c="4737">from werkzeug.datastructures import FileStorage</st></strong><st c="4785">
import os
</st><strong class="bold"><st c="4796">from pandas import read_excel</st></strong>
<strong class="bold"><st c="4825">from exceptions.custom import (NoneFilenameException, InvalidTypeException, MissingFileException,</st></strong> <strong class="bold"><st c="4923">FileSavingException)</st></strong><st c="4944">
@upload_bp.route('/upload/xlsx/analysis', methods = ["GET", "POST"])
async def show_analysis():
    if request.method == 'GET':
        df_tbl = None
    else:
        uploaded_file:FileStorage = request.files['data_file']
        filename = secure_filename(uploaded_file.filename)
        </st><strong class="bold"><st c="5195">if filename == '':</st></strong><strong class="bold"><st c="5213">raise NoneFilenameException()</st></strong><st c="5243">
        file_ext = os.path.splitext(filename)[1]
        if file_ext not in current_app.config['UPLOAD_FILE_TYPES']:
            </st><strong class="bold"><st c="5345">raise InvalidTypeException()</st></strong><st c="5373">
        if  uploaded_file.filename == '' or uploaded_file == None:
            </st><strong class="bold"><st c="5432">raise MissingFileException()</st></strong><st c="5460">
        try:
            df_xlsx = read_excel(uploaded_file, sheet_name=2, skiprows=[1])
            df_tbl = df_xlsx.loc[: , 'Australia':'US'].describe().to_html()
        except:
            </st><strong class="bold"><st c="5602">raise FileSavingException()</st></strong><st c="5629">
    return render_template("file_upload_pandas_xlsx.html", table=df_tbl), 200</st></pre>			<p><st c="5703">Like any form parameter, the view function accesses the file object from </st><code><st c="5777">request.files</st></code><st c="5790"> through the name of the form field. </st><st c="5827">The file object, wrapped in a </st><code><st c="5857">FileStorage</st></code><st c="5868"> wrapper, provides </st><a id="_idIndexMarker375"/><st c="5887">the</st><a id="_idIndexMarker376"/> <st c="5890">following attributes:</st></p>
			<ul>
				<li><code><st c="5912">filename</st></code><st c="5921">: This provides the raw filename of the </st><st c="5962">file object.</st></li>
				<li><code><st c="5974">stream</st></code><st c="5981">: This provides the input stream object that emits Input/Output methods such as </st><code><st c="6062">read()</st></code><st c="6068">, </st><code><st c="6070">write()</st></code><st c="6077">, </st><code><st c="6079">readline()</st></code><st c="6089">, </st><code><st c="6091">writelines()</st></code><st c="6103">, </st><st c="6105">and </st><code><st c="6109">seek()</st></code><st c="6115">.</st></li>
				<li><code><st c="6116">headers</st></code><st c="6124">: This contains the file’s </st><st c="6152">header information.</st></li>
				<li><code><st c="6171">content-length</st></code><st c="6186">: This pertains to the content-length header of </st><st c="6235">the file.</st></li>
				<li><code><st c="6244">content-type</st></code><st c="6257">: This pertains to the content-type header of </st><st c="6304">the file.</st></li>
			</ul>
			<p><st c="6313">It also contains the following methods that can manage the file </st><st c="6378">at runtime:</st></p>
			<ul>
				<li><code><st c="6389">save(destination)</st></code><st c="6407">: This places the file in </st><st c="6434">a destination.</st></li>
				<li><code><st c="6448">close()</st></code><st c="6456">: This closes the file, </st><st c="6481">if necessary.</st></li>
			</ul>
			<p><st c="6494">Before accessing the file for reading, writing, transformation, or saving, the view function must apply validation and restriction to the file object received. </st><st c="6655">Here are the following areas of concern where to impose </st><st c="6711">red flags:</st></p>
			<ul>
				<li><st c="6721">The existence of the actual </st><st c="6750">uploaded file</st></li>
				<li><st c="6763">A </st><st c="6766">sanitized filename</st></li>
				<li><st c="6784">The accepted valid extension of </st><st c="6817">the file</st></li>
				<li><st c="6825">The accepted </st><st c="6839">file size</st></li>
			</ul>
			<p><st c="6848">The given </st><code><st c="6859">show_analysis()</st></code><st c="6874"> view function raises the following custom exception classes when it encounters a problem on the preceding </st><st c="6981">red flags:</st></p>
			<ul>
				<li><code><st c="6991">NoneFilenameException</st></code><st c="7013">: This is raised when there is no filename in </st><st c="7060">the request.</st></li>
				<li><code><st c="7072">InvalidTypeException</st></code><st c="7093">: This is raised when the sanitized filename gives an </st><st c="7148">empty value.</st></li>
				<li><code><st c="7160">InvalidTypeException</st></code><st c="7181">: This is raised when the uploaded file has an extension not supported by </st><st c="7256">the application.</st></li>
			</ul>
			<p><st c="7272">Also, part of the concern is to sanitize the filename of the multipart object before utilizing it for any file transactions. </st><st c="7398">The immediate use of the raw </st><code><st c="7427">filename</st></code><st c="7435"> attribute of the </st><code><st c="7453">FileStorage</st></code><st c="7464"> instance can expose the application to several vulnerabilities because </st><code><st c="7536">filename</st></code><st c="7544"> can have malware-related symbols, some special characters that are suspicious, and characters denoting the file path, such as </st><code><st c="7671">../../</st></code><st c="7677">, which can cause trouble with the </st><code><st c="7712">save()</st></code><st c="7718"> method. </st><st c="7727">To perform filename sanitation, use the </st><code><st c="7767">secure_filename()</st></code><st c="7784"> utility method of the </st><code><st c="7807">werkzeug.utils</st></code><st c="7821"> module. </st><st c="7830">On the other hand, some of our application’s view functions save their uploaded files inside our project’s folder, but storing them outside the project directory is still the </st><st c="8005">best practice.</st></p>
			<p><st c="8019">Lastly, always enclose </st><a id="_idIndexMarker377"/><st c="8043">the</st><a id="_idIndexMarker378"/><st c="8046"> entire file transactions of the view function with the </st><code><st c="8102">try-except</st></code><st c="8112"> clause and raise the necessary exception classes to log all the underlying problems that will arise at runtime. </st><st c="8225">Now, let us discuss the process after the file uploading with the </st><code><st c="8291">pandas</st></code><st c="8297"> module.</st></p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor149"/><st c="8305">Using the pandas module for data and graphical analysis</st></h1>
			<p><st c="8361">The </st><code><st c="8366">pandas</st></code><st c="8372"> module is a</st><a id="_idIndexMarker379"/><st c="8384"> popular Python library for data analysis because of its easy-to-apply utility functions and a high-performance tabular data structure called </st><code><st c="8583">numpy</st></code><st c="8588"> module, a low-level library that supports multi-dimensional array objects called </st><code><st c="8670">ndarray</st></code><st c="8677"> and its mathematical operations, and </st><code><st c="8715">matplotlib</st></code><st c="8725">, a library for visualizations. </st><st c="8757">So, install these two </st><st c="8779">modules first:</st></p>
			<pre class="console"><st c="8793">
pip install numpy matplotlib</st></pre>			<p><st c="8822">Then, install the </st><code><st c="8841">pandas</st></code><st c="8847"> module:</st></p>
			<pre class="console"><st c="8855">
pip install pandas</st></pre>			<p><st c="8874">Since our data will be coming from XLSX sheets, install the </st><code><st c="8935">openpyxl</st></code><st c="8943"> dependency module of </st><code><st c="8965">pandas</st></code><st c="8971"> that deals with reading and writing </st><st c="9008">XLSX documents:</st></p>
			<pre class="console"><st c="9023">
pip install openpyxl</st></pre>			<p><st c="9044">After installing all the dependency modules, we can start creating the </st><code><st c="9116">DataFrame </st></code><st c="9126">object.</st></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor150"/><st c="9133">Utilizing the DataFrame</st></h2>
			<p><st c="9157">To read an</st><a id="_idIndexMarker381"/><st c="9168"> XLSX document, the </st><code><st c="9188">pandas</st></code><st c="9194"> module</st><a id="_idIndexMarker382"/><st c="9201"> has a </st><code><st c="9208">read_excel()</st></code><st c="9220"> method with parameters such as </st><code><st c="9252">usecols</st></code><st c="9259">, which indicates the columns or range of columns to include, </st><code><st c="9321">skiprows</st></code><st c="9329">, which selects the rows to skip starting from the column row, and </st><code><st c="9396">sheet_name</st></code><st c="9406">, which chooses the sheet to read starting from sheet </st><code><st c="9460">0</st></code><st c="9461">. The following from the previous </st><code><st c="9495">show_analysis()</st></code><st c="9510"> view depicts the data retrieval from sheet </st><code><st c="9554">2</st></code><st c="9555"> of the workbook, excluding </st><st c="9583">row </st><code><st c="9587">1</st></code><st c="9588">:</st></p>
			<pre class="source-code"><st c="9589">
df_xlsx = read_excel(uploaded_file, sheet_name=2, skiprows=[1])</st></pre>			<p><st c="9653">This result will be similar to the following snapshot from a </st><st c="9715">sample </st><code><st c="9722">uploaded_file</st></code><st c="9735">:</st></p>
			<div><div><img src="img/B19383_06_001.jpg" alt="Figure 6.1 – A sample XLSX document containing HPI and PDI data"/><st c="9737"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="11351">Figure 6.1 – A sample XLSX document containing HPI and PDI data</st></p>
			<p><em class="italic"><st c="11414">Figure 6</st></em><em class="italic"><st c="11423">.2</st></em><st c="11425"> shows a</st><a id="_idIndexMarker383"/><st c="11433"> sample </st><code><st c="11441">DataFrame</st></code><st c="11450"> object</st><a id="_idIndexMarker384"/><st c="11457"> extracted from an uploaded housing price data set to the </st><code><st c="11515">show_analysis()</st></code> <st c="11530">view function.</st></p>
			<div><div><img src="img/B19383_06_002.jpg" alt="Figure 6.2 – A sample DataFrame from an uploaded file"/><st c="11545"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12527">Figure 6.2 – A sample DataFrame from an uploaded file</st></p>
			<p><st c="12580">A </st><code><st c="12583">DataFrame</st></code><st c="12592"> object has easy-to-use properties that can extract a portion of the table, such as </st><code><st c="12676">shape</st></code><st c="12681">, </st><code><st c="12683">size</st></code><st c="12687">, </st><code><st c="12689">axes</st></code><st c="12693">, </st><code><st c="12695">at</st></code><st c="12697">, </st><code><st c="12699">columns</st></code><st c="12706">, </st><code><st c="12708">indexes</st></code><st c="12715">, </st><code><st c="12717">ndim</st></code><st c="12721">, </st><code><st c="12723">iloc</st></code><st c="12727">, and </st><code><st c="12733">loc</st></code><st c="12736">. If the goal is to extract only the columns from Australia to the US, the </st><code><st c="12811">loc</st></code><st c="12814"> property should indicate the range of columns that </st><code><st c="12866">DataFrame</st></code><st c="12875"> object will sift its analysis from, as shown in the </st><st c="12928">following snippet:</st></p>
			<pre class="source-code"><st c="12946">
df_tbl = df_xlsx.loc[: , 'Australia':'US'].describe().to_html()</st></pre>			<p><st c="13010">The </st><code><st c="13015">loc</st></code><st c="13018"> property accesses the data values using selected column labels or ranges, while its </st><code><st c="13103">iloc</st></code><st c="13107"> counterpart uses column indices to slice the </st><code><st c="13153">DataFrame</st></code><st c="13162"> instance, like the </st><code><st c="13182">df_tbl</st></code><st c="13188">. Both properties emit mathematical methods, such as </st><code><st c="13241">count()</st></code><st c="13248">, </st><code><st c="13250">mean()</st></code><st c="13256">, </st><code><st c="13258">sum()</st></code><st c="13263">, </st><code><st c="13265">mode()</st></code><st c="13271">, </st><code><st c="13273">std()</st></code><st c="13278">, and </st><code><st c="13284">var()</st></code><st c="13289">. However, the given view function utilizes the </st><code><st c="13337">describe()</st></code><st c="13347"> method to extract the columnar data from </st><code><st c="13389">Australia</st></code><st c="13398"> to the </st><code><st c="13406">US</st></code><st c="13408"> columns on the actual HPI values quarterly from 1975 to the current year. </st><st c="13483">Here is the actual output of our view when a valid XLSX document on housing datasets </st><st c="13568">is uploaded:</st></p>
			<div><div><img src="img/B19383_06_003.jpg" alt="Figure 6.3 – A sample output of the show_analysis() view"/><st c="13580"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15018">Figure 6.3 – A sample output of the show_analysis() view</st></p>
			<p><st c="15074">When rendering data values using Flask, the </st><code><st c="15119">DataFrame</st></code><st c="15128"> object has three utility methods that can provide format-ready results. </st><st c="15201">Here are the </st><st c="15214">three methods:</st></p>
			<ul>
				<li><code><st c="15228">to_html()</st></code><st c="15238">: This generates an HTML table format with </st><st c="15282">the datasets.</st></li>
				<li><code><st c="15295">to_latex()</st></code><st c="15306">: This creates a LaTeX-formatted result with the data ready for </st><st c="15371">PDF transformation.</st></li>
				<li><code><st c="15390">to_markdown()</st></code><st c="15404">: This generates a Markdown-ready template with the </st><st c="15457">data values.</st></li>
			</ul>
			<p><st c="15469">In the case</st><a id="_idIndexMarker385"/><st c="15481"> of </st><code><st c="15485">show_analysis()</st></code><st c="15500">, it </st><a id="_idIndexMarker386"/><st c="15505">uses </st><code><st c="15510">to_html()</st></code><st c="15519"> to render all the captured datasets as an HTML table through </st><code><st c="15581">to_html()</st></code><st c="15590">. However, the rendition will only work with the </st><code><st c="15639">safe</st></code><st c="15643"> Jinja2 filter because Jinja2 will not automatically HTML-escape all the characters provided by </st><code><st c="15739">to_html()</st></code><st c="15748"> for security purposes. </st><em class="italic"><st c="15772">Figure 6</st></em><em class="italic"><st c="15780">.3</st></em><st c="15782"> shows a raw result of rendering tabular values from the </st><code><st c="15839">DataFrame</st></code><st c="15848"> instance containing the values using its </st><code><st c="15890">to_html()</st></code><st c="15899"> method.</st></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor151"/><st c="15907">Rendering graphs and charts using matplotlib</st></h2>
			<p><st c="15952">It is easy to plot</st><a id="_idIndexMarker387"/><st c="15971"> data </st><a id="_idIndexMarker388"/><st c="15977">when </st><a id="_idIndexMarker389"/><st c="15982">contained </st><a id="_idIndexMarker390"/><st c="15992">in a </st><code><st c="15997">DataFrame</st></code><st c="16006"> object’s two-dimension data structure. </st><st c="16046">The </st><code><st c="16050">matplotlib</st></code><st c="16060"> has built-in support for rendering the tabular values as a </st><em class="italic"><st c="16120">line</st></em><st c="16124">, </st><em class="italic"><st c="16126">bar</st></em><st c="16129">, </st><em class="italic"><st c="16131">pie</st></em><st c="16134">, or other graph or chart type. </st><st c="16166">Since our application is a web app, our view functions must render these visuals as images, unlike in a REST application, which returns JSON resources for </st><st c="16321">frontend frameworks.</st></p>
			<p><st c="16341">Now, the first step is to create a </st><code><st c="16377">Figure</st></code><st c="16383"> object. </st><st c="16392">A </st><code><st c="16394">Figure</st></code><st c="16400"> object serves as a canvas of a plot or subplots depending on the visualization approach. </st><st c="16490">It is a plain blank object created by the </st><code><st c="16532">figure()</st></code><st c="16540"> method of the </st><code><st c="16555">matplotlib</st></code><st c="16565"> module or the </st><code><st c="16580">Figure</st></code><st c="16586"> helper class of the </st><code><st c="16607">matplotlib.figure</st></code><st c="16624"> module. </st><st c="16633">It has the following essential properties that need configuration before finalizing </st><st c="16717">the plot:</st></p>
			<ul>
				<li><code><st c="16726">figsize</st></code><st c="16734">: This measures the </st><code><st c="16755">x-</st></code><st c="16757">axis and </st><code><st c="16767">y</st></code><st c="16768">-axis of the </st><st c="16781">canvas’ dimensions.</st></li>
				<li><code><st c="16800">dpi</st></code><st c="16804">: This gauges the dot pixel per inch for </st><st c="16846">the plot.</st></li>
				<li><code><st c="16855">linewidth</st></code><st c="16865">: This measures the borderline of </st><st c="16900">the canvas.</st></li>
				<li><code><st c="16911">edgecolor</st></code><st c="16921">: This applies the color of the </st><st c="16954">canvas’ borderline.</st></li>
				<li><code><st c="16973">facecolor</st></code><st c="16983">: This applies the indicated color to the border area between the canvas borderline and the axes </st><st c="17081">plot borderline.</st></li>
			</ul>
			<p><st c="17097">The following view implementation uploads a file, creates a </st><code><st c="17158">DataFrame</st></code><st c="17167"> object from the uploaded XLSX document, and renders a line graph from the </st><st c="17242">tabular values:</st></p>
			<pre class="source-code"><st c="17257">
from pandas import read_excel
</st><strong class="bold"><st c="17288">from numpy import arange</st></strong>
<strong class="bold"><st c="17312">from matplotlib.figure import Figure</st></strong>
<strong class="bold"><st c="17349">from io import BytesIO</st></strong>
<strong class="bold"><st c="17372">import base64</st></strong><st c="17386">
@upload_bp.route("/upload/xlsx/rhpi/plot/belgium", methods = ['GET', 'POST'])
async def upload_xlsx_hpi_belgium_plot():
    if request.method == 'GET':
        data = None
    else:
        … … … … …
        try:
            df_rhpi = read_excel(uploaded_file, sheet_name=2, </st><strong class="bold"><st c="17618">usecols='C'</st></strong><st c="17629">, skiprows=[1])
            array_rhpi = df_rhpi.to_numpy().flatten()
            array_hpi_index = arange(0, array_rhpi.size )
            </st><strong class="bold"><st c="17733">fig = Figure(figsize=(6, 6), dpi=72,</st></strong> <strong class="bold"><st c="17769">edgecolor='r', linewidth=2, facecolor='y')</st></strong><strong class="bold"><st c="17812">axis = fig.subplots()</st></strong><st c="17834">
            axis.</st><strong class="bold"><st c="17840">plot</st></strong><st c="17845">(array_hpi_index, array_rhpi)
            axis.</st><strong class="bold"><st c="17881">set_xlabel</st></strong><st c="17892">('Quarterly Duration')
            axis.</st><strong class="bold"><st c="17921">set_ylabel</st></strong><st c="17932">('House Price Index')
            axis.</st><strong class="bold"><st c="17960">set_title</st></strong><st c="17970">("Belgium's HPI versus RHPI")
            … … … … … …
            </st><strong class="bold"><st c="18013">output = BytesIO()</st></strong><strong class="bold"><st c="18031">fig.savefig(output, format="png")</st></strong><strong class="bold"><st c="18065">data = base64.b64encode(output.getbuffer())</st></strong> <strong class="bold"><st c="18109">.decode("ascii")</st></strong><st c="18125">
        except:
            raise FileSavingException()
    return render_template("file_upload_xlsx_form.html", </st><code><st c="18271">Figure</st></code><st c="18277"> canvas is now 6 inches x 6 inches in dimension, as managed by its </st><code><st c="18344">figsize</st></code><st c="18351"> parameter. </st><st c="18363">By default, a </st><code><st c="18377">Figure</st></code><st c="18383"> canvas is 6.4 and 4.8 inches. </st><st c="18414">Also, the borderline has an added 2units in thickness, with an </st><code><st c="18477">edgecolor</st></code><st c="18486"> value of ‘</st><code><st c="18497">r</st></code><st c="18499">’, a single character shorthand for color red, and a </st><code><st c="18552">facecolor</st></code><st c="18561"> value of ‘</st><code><st c="18572">y</st></code><st c="18574">’ character notation, which means color yellow. </st><em class="italic"><st c="18622">Figure 6</st></em><em class="italic"><st c="18630">.4</st></em><st c="18632"> shows the outcome of the </st><a id="_idIndexMarker391"/><st c="18658">given</st><a id="_idIndexMarker392"/><st c="18663"> details of</st><a id="_idIndexMarker393"/> <st c="18674">the</st><a id="_idIndexMarker394"/><st c="18678"> canvas:</st></p>
			<div><div><img src="img/B19383_06_004.jpg" alt="Figure 6.4 – A line graph with a customized Figure instance"/><st c="18686"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="18806">Figure 6.4 – A line graph with a customized Figure instance</st></p>
			<p><st c="18865">The next step is to draw up the data values from the </st><code><st c="18919">DataFrame</st></code><st c="18928"> object using </st><code><st c="18942">Axes</st></code><st c="18946"> or the plot of the </st><code><st c="18966">Figure</st></code><st c="18972">. </st><code><st c="18974">Axes</st></code><st c="18978">, not the x-axis and y-axis, is the area on the </st><code><st c="19026">Figure </st></code><st c="19033">canvas where the visualization will happen. </st><st c="19077">There are two ways to create an </st><code><st c="19109">Axes</st></code><st c="19113"> instance:</st></p>
			<ul>
				<li><st c="19123">Using the </st><code><st c="19134">subplots()</st></code><st c="19144"> method of </st><st c="19155">the </st><code><st c="19159">Figure</st></code><st c="19165">.</st></li>
				<li><st c="19166">Using the </st><code><st c="19177">subplots()</st></code><st c="19187"> method of the </st><code><st c="19202">matplotlib</st></code><st c="19212"> module.</st></li>
			</ul>
			<p><st c="19220">Since there is already an existing </st><code><st c="19256">Figure</st></code><st c="19262"> instance, the former is the appropriate approach to create the plotting area. </st><st c="19341">The latter returns a tuple containing a new </st><code><st c="19385">Figure</st></code><st c="19391"> instance, with </st><code><st c="19407">Axes</st></code><st c="19411"> all in with one </st><st c="19428">method call.</st></p>
			<p><st c="19440">Now, an </st><code><st c="19449">Axes</st></code><st c="19453"> instance has almost all the necessary utilities for setting up any </st><code><st c="19521">Figure</st></code><st c="19527"> component, such as </st><code><st c="19547">plot()</st></code><st c="19553">, </st><code><st c="19555">axis()</st></code><st c="19561">, </st><code><st c="19563">bar()</st></code><st c="19568">, </st><code><st c="19570">pie()</st></code><st c="19575">, and </st><code><st c="19581">tick_params()</st></code><st c="19594">. In the given </st><code><st c="19609">upload_xlsx_hpi_belgium_plot()</st></code><st c="19639">, the goal is to create a Line2D graph of the actual HPI values of Belgium by using the </st><code><st c="19727">plot()</st></code><st c="19733"> method. </st><st c="19742">The extracted DataFrame tabular data focuses only on the </st><code><st c="19799">Belgium</st></code><st c="19806"> column (column C), as indicated by the </st><code><st c="19846">usecols</st></code><st c="19853"> parameter of the </st><code><st c="19871">read_excel()</st></code><st c="19883"> statement:</st></p>
			<pre class="source-code"><st c="19894">
df_rhpi = read_excel(uploaded_file, sheet_name=2, </st><code><st c="19978">plot()</st></code><st c="19984">’s x-values or </st><code><st c="20000">scalex</st></code><st c="20006"> will have </st><code><st c="20017">ndarray</st></code><st c="20024"> from </st><code><st c="20030">0</st></code><st c="20031"> to the maximum number of captured HPI values, and its y-values or </st><code><st c="20098">scaley</st></code><st c="20104"> will have the HPI values of Belgium. </st><st c="20142">Its </st><a id="_idIndexMarker395"/><st c="20146">color </st><a id="_idIndexMarker396"/><st c="20152">parameter </st><a id="_idIndexMarker397"/><st c="20162">is set</st><a id="_idIndexMarker398"/><st c="20168"> to </st><code><st c="20172">#fc0366</st></code><st c="20179"> to change the default blue color of the line graph. </st><st c="20232">Aside from </st><code><st c="20243">plot()</st></code><st c="20249">, </st><code><st c="20251">Axes</st></code><st c="20255"> has </st><code><st c="20260">set_title()</st></code><st c="20271"> to add a header title for the image, </st><code><st c="20309">set_xlabel()</st></code><st c="20321"> to add the description of the x-values, </st><code><st c="20362">set_ylabel()</st></code><st c="20374"> for the y-values description, </st><code><st c="20405">set_facecolor()</st></code><st c="20420"> to change the font color of the text, and </st><code><st c="20463">tick_params()</st></code><st c="20476"> to update the color of the x and y tick values. </st><code><st c="20525">Axes</st></code><st c="20529"> also has properties such as </st><code><st c="20558">xaxis</st></code><st c="20563"> and </st><code><st c="20568">yaxis</st></code><st c="20573"> to apply a new color to the x- and y-axis descriptions and spines to adjust the </st><code><st c="20654">linewidth</st></code><st c="20663"> and </st><code><st c="20668">edgecolor</st></code><st c="20677"> of </st><st c="20681">the plot.</st></p>
			<p><st c="20690">After finalizing the plot details, create a </st><code><st c="20735">BytesIO</st></code><st c="20742"> buffer object to contain the </st><code><st c="20772">Figure</st></code><st c="20778"> instance. </st><st c="20789">Saving the </st><code><st c="20800">Figure</st></code><st c="20806"> in </st><code><st c="20810">BytesIO</st></code><st c="20817"> is necessary for decoding the plot as an inline image. </st><st c="20873">The view must pass the </st><code><st c="20896">base64</st></code><st c="20902">-encoded image to its Jinja2 template for rendition. </st><st c="20956">Rendering an inline image through the </st><code><st c="20994">&lt;url&gt;</st></code><st c="20999"> tag is a fast way of displaying images. </st><em class="italic"><st c="21040">Figure 6</st></em><em class="italic"><st c="21048">.5</st></em><st c="21050"> shows the updated line graph for a sample actual HPI dataset </st><st c="21112">for Belgium.</st></p>
			<div><div><img src="img/B19383_06_005.jpg" alt="Figure 6.5 – A final line graph for a sample actual HPI data set for Belgium"/><st c="21124"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="21401">Figure 6.5 – A final line graph for a sample actual HPI data set for Belgium</st></p>
			<p><st c="21477">How about if </st><a id="_idIndexMarker399"/><st c="21491">we </st><a id="_idIndexMarker400"/><st c="21494">have </st><a id="_idIndexMarker401"/><st c="21499">multiple </st><a id="_idIndexMarker402"/><st c="21508">graphs in one </st><code><st c="21522">Axes</st></code><st c="21526"> plot?</st></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor152"/><st c="21532">Rendering multiple line graphs</st></h2>
			<p><st c="21563">Depending on the</st><a id="_idIndexMarker403"/><st c="21580"> goal of </st><a id="_idIndexMarker404"/><st c="21589">the visualization, the </st><code><st c="21612">pandas</st></code><st c="21618"> module with </st><code><st c="21631">matplotlib</st></code><st c="21641"> can handle complex graphical renditions of </st><code><st c="21685">DataFrame</st></code><st c="21694"> object’s data values. </st><st c="21717">The following view function creates two line graphs that can compare Belgium’s actual and nominal HPI values based on a </st><st c="21837">sample dataset:</st></p>
			<pre class="source-code"><st c="21852">
@upload_bp.route("/upload/xlsx/rhpi/hpi/plot/belgium", methods = ['GET', 'POST'])
async def upload_xlsx_belgium_hpi_rhpi_plot():
    if request.method == 'GET':
        data = None
    else:
        … … … … … …
        try:
            </st><strong class="bold"><st c="22045">df_hpi = read_excel(uploaded_file,</st></strong> <strong class="bold"><st c="22079">sheet_name=1, usecols='C', skiprows=[1])</st></strong><strong class="bold"><st c="22120">df_rhpi = read_excel(uploaded_file,</st></strong> <strong class="bold"><st c="22156">sheet_name=2, usecols='C', skiprows=[1])</st></strong><strong class="bold"><st c="22197">array_hpi = df_hpi.to_numpy().flatten()</st></strong><st c="22237">
            array_hpi_index = arange(0, df_rhpi.size )
            </st><strong class="bold"><st c="22281">array_rhpi = df_rhpi.to_numpy().flatten()</st></strong><st c="22322">
            array_rhpi_index = arange(0, df_rhpi.size )
            fig = Figure(figsize=(7, 7), dpi=72, edgecolor='#140dde', linewidth=2, facecolor='#b7b6d4')
            axes = fig.subplots()
            </st><strong class="bold"><st c="22481">lbl1,</st></strong><st c="22486"> = axes.plot(array_hpi_index ,array_hpi, color="#32a8a2")
            </st><strong class="bold"><st c="22544">lbl2</st></strong><st c="22548">, = axes.plot(array_rhpi_index ,array_rhpi, color="#bf8a26")
            axes.set_xlabel('Quarterly Duration')
            axes.set_ylabel('House Price Index')
            </st><strong class="bold"><st c="22684">axes.legend([lbl1, lbl2], ["HPI", "RHPI"])</st></strong><st c="22726">
            axes.set_title("Belgium's HPI versus RHPI")
            … … … … … …
        except:
            raise FileSavingException()
    return render_template("file_upload_xlsx_sheets_form.html", data=data), 200</st></pre>			<p><st c="22894">Compared to the previous </st><code><st c="22920">upload_xlsx_hpi_belgium_plot()</st></code><st c="22950"> view, </st><code><st c="22957">upload_xlsx_belgium_hpi_rhpi_plot()</st></code><st c="22992"> utilizes two sheets from the workbook of an uploaded file, namely </st><code><st c="23059">sheet[1]</st></code><st c="23067"> for the nominal HPI and </st><code><st c="23092">sheet[2]</st></code><st c="23100"> for the actual HPI values of Belgium. </st><st c="23139">It derives separate </st><code><st c="23159">DataFrame</st></code><st c="23168"> object’s tabular values from each worksheet and plots a Line2D graph to compare the trend between the two datasets. </st><st c="23285">Similar to the previous vector transformation in this chapter, this view still uses </st><code><st c="23369">numpy</st></code><st c="23374"> to flatten the extracted vertical vector from the DataFrame’s </st><code><st c="23437">to_numpy()</st></code><st c="23447"> utility method. </st><st c="23464">By the way, the view function only uses one </st><code><st c="23508">Axes</st></code><st c="23512"> plot for </st><st c="23522">both graphs.</st></p>
			<p><st c="23534">Moreover, the view also showcases the inclusion of a </st><code><st c="23767">Axes</st></code><st c="23771">, but this view captures the Line2D objects from the </st><code><st c="23824">plot()</st></code><st c="23830"> method calls and maps each plot with a string label using the </st><code><st c="23893">Axes</st></code><st c="23897">’ </st><code><st c="23900">legend()</st></code><st c="23908"> method. </st><em class="italic"><st c="23917">Figure 6</st></em><em class="italic"><st c="23925">.6</st></em><st c="23927"> shows the result of running </st><code><st c="23956">upload_xlsx_belgium_hpi_rhpi_plot()</st></code><st c="23991"> with an uploaded </st><st c="24009">XLSX document.</st></p>
			<div><div><img src="img/B19383_06_006.jpg" alt="Figure 6.6 – Two line graphs in one Axes plot"/><st c="24023"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="24301">Figure 6.6 – Two line graphs in one Axes plot</st></p>
			<p><st c="24346">Up next, we will </st><a id="_idIndexMarker407"/><st c="24364">see how </st><a id="_idIndexMarker408"/><st c="24372">to plot a pie chart </st><st c="24392">with Flask.</st></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor153"/><st c="24403">Rendering a pie chart from a CSV file</st></h2>
			<p><st c="24441">The </st><code><st c="24446">pandas</st></code><st c="24452"> module </st><a id="_idIndexMarker409"/><st c="24460">can also</st><a id="_idIndexMarker410"/><st c="24468"> read data from CSV files</st><a id="_idIndexMarker411"/><st c="24493"> through its </st><code><st c="24506">read_csv()</st></code><st c="24516"> method. </st><st c="24525">Unlike in </st><code><st c="24535">read_excel()</st></code><st c="24547">, the </st><code><st c="24553">pandas</st></code><st c="24559"> module does not need any dependency to read valid CSV files. </st><st c="24621">The following view uses </st><code><st c="24645">read_csv()</st></code><st c="24655"> to create a DataFrame of values for plotting a </st><st c="24703">pie chart:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="24713">from pandas import read_csv</st></strong><st c="24741">
@upload_bp.route("/upload/csv/pie", methods = ['GET', 'POST'])
async def upload_csv_pie():
    if request.method == 'GET':
        data = None
    else:
        … … … … … …
        try:
            </st><strong class="bold"><st c="24896">df_csv = read_csv(uploaded_file)</st></strong><strong class="bold"><st c="24928">matplotlib.use('agg')</st></strong><st c="24950">
            fig = plt.figure()
            axes = fig.add_subplot(1, 1, 1)
            </st><strong class="bold"><st c="25002">explode = (0.1, 0, 0)</st></strong><strong class="bold"><st c="25023">axes.pie(df_csv.groupby(['FurnishingStatus'])</st></strong><strong class="bold"><st c="25069">['Price'].count(), colors=['#bfe089', '#ebd05b', '#e67eab'],</st></strong><strong class="bold"><st c="25130">labels =["Furnished","Semi-Furnished", "Unfurnished"], autopct ='% 1.1f %%',</st></strong><strong class="bold"><st c="25207">shadow = True, startangle = 90,</st></strong> <strong class="bold"><st c="25239">explode=explode)</st></strong><strong class="bold"><st c="25256">axes.axis('equal')</st></strong><strong class="bold"><st c="25275">axes.legend(loc='lower right',fontsize=7,</st></strong> <strong class="bold"><st c="25317">bbox_to_anchor = (0.75, -01.0) )</st></strong><st c="25350">
           … … … … … …
        except:
            raise FileSavingException()
    return render_template("file_upload_csv_pie_form.html", data=data), 200</st></pre>			<p><st c="25469">The </st><code><st c="25474">pandas</st></code><st c="25480"> module </st><a id="_idIndexMarker412"/><st c="25488">can </st><a id="_idIndexMarker413"/><st c="25492">also read data from CSV </st><a id="_idIndexMarker414"/><st c="25516">files through its </st><code><st c="25534">read_csv()</st></code><st c="25544"> method. </st><st c="25553">Unlike in </st><code><st c="25563">read_excel()</st></code><st c="25575">, the </st><code><st c="25581">pandas</st></code><st c="25587"> module does not need any dependency to read valid </st><st c="25638">CSV files.</st></p>
			<p><st c="25648">On the other hand, the </st><code><st c="25672">Axes</st></code><st c="25676">’ </st><code><st c="25679">pie()</st></code><st c="25684"> method has several parameters to consider before reaching the appropriate pie diagram for the data values. </st><st c="25792">Here are some of the parameters used by the </st><code><st c="25836">upload_csv_pie()</st></code> <st c="25852">view function:</st></p>
			<ul>
				<li><code><st c="25867">explode</st></code><st c="25875">: This provides a list of fraction digits that indicate spaces around the wedges that will make them </st><st c="25977">stand out.</st></li>
				<li><code><st c="25987">colors</st></code><st c="25994">: This provides a list of </st><code><st c="26021">matplotlib</st></code><st c="26031">’s built-in named colors or hexadecimal formatted color code set to each of </st><st c="26108">the widgets.</st></li>
				<li><code><st c="26120">labels</st></code><st c="26127">: This provides a list of string values assigned to </st><st c="26180">each widget.</st></li>
				<li><code><st c="26192">autopct</st></code><st c="26200">: This provides a string-formatted percentage value of </st><st c="26256">each widget.</st></li>
				<li><code><st c="26268">shadow</st></code><st c="26275">: This allows adding a shadow around the </st><st c="26317">pie chart.</st></li>
				<li><code><st c="26327">startangle</st></code><st c="26338">: This provides an angle of rotation for the pie chart to start with its </st><st c="26412">first wedge.</st></li>
			</ul>
			<p><st c="26424">The goal of the</st><a id="_idIndexMarker415"/><st c="26440"> given </st><code><st c="26447">upload_csv_pie()</st></code><st c="26463"> is to</st><a id="_idIndexMarker416"/><st c="26469"> generate</st><a id="_idIndexMarker417"/><st c="26478"> a pie chart based on the number of projected house prices (</st><code><st c="26538">Price</st></code><st c="26544">) per furnishing status (</st><code><st c="26570">FurnishingStatus</st></code><st c="26587">), namely the </st><code><st c="26602">Furnished</st></code><st c="26611">, </st><code><st c="26613">Semi-furnished</st></code><st c="26627">, and </st><code><st c="26633">Fully-furnished</st></code><st c="26648"> houses. </st><st c="26657">The </st><code><st c="26661">groupby()</st></code><st c="26670"> method of the </st><code><st c="26685">df_csv</st></code><st c="26691"> DataFrame extracts the needed data values for the </st><code><st c="26742">pie()</st></code><st c="26747"> method. </st><st c="26756">Now, running this view function will render the </st><st c="26804">following chart:</st></p>
			<div><div><img src="img/B19383_06_007.jpg" alt="Figure 6.7 – Pie chart on Furnishing Status preference"/><st c="26820"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="26951">Figure 6.7 – Pie chart on Furnishing Status preference</st></p>
			<p><st c="27005">If saving the pie chart figure produces the following warning message, </st><code><st c="27077">UserWarning: Starting a Matplotlib GUI outside of the main thread will likely fail.</st></code><st c="27160">, add </st><code><st c="27166">matplotlib.use('agg')</st></code><st c="27187"> anywhere before creating the </st><code><st c="27217">Figure</st></code><st c="27223"> instance </st><a id="_idIndexMarker418"/><st c="27233">to</st><a id="_idIndexMarker419"/><st c="27235"> enable</st><a id="_idIndexMarker420"/><st c="27242"> the non-interactive backend mode for writing files outside the </st><st c="27306">main thread.</st></p>
			<p><st c="27318">How about if we have multiple </st><code><st c="27349">Axes</st></code><st c="27353"> plots in </st><st c="27363">one </st><code><st c="27367">Figure</st></code><st c="27373">?</st></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor154"/><st c="27374">Rendering multiple Axes plots</st></h2>
			<p><st c="27403">A Figure can</st><a id="_idIndexMarker421"/><st c="27416"> contain </st><a id="_idIndexMarker422"/><st c="27425">more than one plot of different graphs and charts. </st><st c="27476">Scientific applications mostly have GUIs that render several charts of varying data calibration, transformation, and analytics. </st><st c="27604">The following view function uploads an XLSX document and creates four plots on a </st><code><st c="27685">Figure</st></code><st c="27691"> to create different graphs of the DataFrame data values extracted from </st><st c="27763">the document:</st></p>
			<pre class="source-code"><st c="27776">
@upload_bp.route("/upload/xlsx/multi/subplot", methods = ['GET', 'POST'])
async def upload_xlsx_multi_subplots():
    if request.method == 'GET':
        data = None
    else:
        … … … … … …
        try:
            df_xlsx = read_excel(uploaded_file, sheet_name=2, skiprows=[1])
            </st><code><st c="28201">axes1</st></code><st c="28206">, creates </st><a id="_idIndexMarker424"/><st c="28216">two line graphs of the actual HPI values of Australia and Belgium for all the quarterly periods, as indicated in the following </st><st c="28343">code block:</st></p>
			<pre class="source-code"><strong class="bold"><st c="28354">axes1.plot(df_xlsx.index.values,</st></strong><strong class="bold"><st c="28387">df_xlsx['Australia'], 'green',</st></strong><strong class="bold"><st c="28418">df_xlsx.index.values,</st></strong><strong class="bold"><st c="28440">df_xlsx['Belgium'], 'red',)</st></strong><st c="28468">
          axes1.set_xlabel('Quarterly Duration')
          axes1.set_ylabel('House Price Index')
          axes1.set_title('RHPI between Australia ………')</st></pre>			<p><st c="28591">The second plot, </st><code><st c="28609">axes2</st></code><st c="28614">, generates a bar chart depicting the mean HPI values of all countries in the tabular values, as shown in the following </st><st c="28734">code block:</st></p>
			<pre class="source-code"><st c="28745">
           index = arange(df_xlsx.loc[: , 'Australia':'US'].shape[1])
           </st><strong class="bold"><st c="28805">axes2.bar(index, df_xlsx.loc[: ,</st></strong> <strong class="bold"><st c="28837">'Australia':'US'].mean(),</st></strong><strong class="bold"><st c="28863">color=(0.1, 0.1, 0.1, 0.1), edgecolor='blue')</st></strong><st c="28909">
           axes2.set_xlabel('Country ID')
           axes2.set_ylabel('Mean HPI')
           axes2.set_xticks(index)
           axes2.set_title('Mean RHPI among countries')</st></pre>			<p><st c="29038">The third plot, </st><code><st c="29055">axes3</st></code><st c="29060">, plots all HPI values of each country in the tabular values from 1975 to the current year, creating multiple </st><st c="29170">line graphs:</st></p>
			<pre class="source-code"><strong class="bold"><st c="29182">axes3.plot(df_xlsx.loc[: , 'Australia':'US'])</st></strong><st c="29228">
            axes3.set_xlabel('Quarterly Duration')
            axes3.set_ylabel('House Price Index')
            axes3.set_title('RHPI trend among countries')</st></pre>			<p><st c="29351">The last </st><a id="_idIndexMarker425"/><st c="29361">plot, </st><code><st c="29367">axes4</st></code><st c="29372">, builds a </st><a id="_idIndexMarker426"/><st c="29383">grouped bar chart showing the HPI values of Japan, South Korea, and New Zealand quarterly </st><st c="29473">in 1975:</st></p>
			<pre class="source-code"><st c="29481">
            width = 0.3
            </st><strong class="bold"><st c="29494">axes4.bar(df_xlsx.loc[0:3,</st></strong> <strong class="bold"><st c="29520">'Japan'].index.values-width, df_xlsx.loc[0:3,</st></strong> <strong class="bold"><st c="29566">'Japan'], width=width, color='#d9182b',</st></strong> <strong class="bold"><st c="29606">label="JP")</st></strong><strong class="bold"><st c="29618">axes4.bar(df_xlsx.loc[0:3, 'S.</st></strong> <strong class="bold"><st c="29649">Korea'].index.values, df_xlsx.loc[0:3, 'S.</st></strong> <strong class="bold"><st c="29692">Korea'], width=width, color='#f09ec1',</st></strong> <strong class="bold"><st c="29731">label="SK")</st></strong><strong class="bold"><st c="29743">axes4.bar(df_xlsx.loc[0:3, 'New</st></strong> <strong class="bold"><st c="29775">Zealand'].index.values+width, df_xlsx.loc[0:3,</st></strong> <strong class="bold"><st c="29822">'New Zealand'], width=width, color='#000',</st></strong> <strong class="bold"><st c="29865">label="NZ")</st></strong><st c="29877">
            axes4.set_xlabel('Quarterly Duration')
            … … … … … …
            axes4.legend()</st></pre>			<p><st c="29943">The given </st><code><st c="29954">axes4</st></code><st c="29959"> setup uses the </st><code><st c="29975">plot()</st></code><st c="29981"> label parameter to assign codes for each bar plot needed by its </st><code><st c="30046">legend()</st></code><st c="30054"> method in forming the diagram’s legends. </st><st c="30096">Running the view function </st><a id="_idIndexMarker427"/><st c="30122">will </st><a id="_idIndexMarker428"/><st c="30127">give us the following </st><st c="30149">multiple graphs:</st></p>
			<div><div><img src="img/B19383_06_008.jpg" alt="Figure 6.8 – A Figure with multiple plots"/><st c="30165"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="30688">Figure 6.8 – A Figure with multiple plots</st></p>
			<p><st c="30729">Flask’s asynchronous components can also support more advanced, informative, and complex mathematical and statistical graphs plotted on a </st><code><st c="30868">Figure</st></code><st c="30874"> with the </st><code><st c="30884">seaborn</st></code><st c="30891"> module. </st><st c="30900">Also, it can create regression plots using various regression techniques using the </st><code><st c="30983">statsmodels</st></code><st c="30994"> module. </st><st c="31003">The next topic will highlight the solving of nonlinear and linear equations </st><a id="_idIndexMarker429"/><st c="31079">with</st><a id="_idIndexMarker430"/><st c="31083"> the </st><code><st c="31088">sympy</st></code><st c="31093"> module.</st></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor155"/><st c="31101">Implementing symbolic computation with visualization</st></h1>
			<p><code><st c="31682">matplotlib</st></code><st c="31692"> and </st><code><st c="31697">numpy</st></code><st c="31702"> modules.</st></p>
			<p><st c="31711">For Flask to recognize symbolic expressions and formulas in a string expression, install the </st><code><st c="31805">sympy</st></code><st c="31810"> module using the </st><code><st c="31828">pip</st></code><st c="31831"> command:</st></p>
			<pre class="console"><st c="31840">
pip install sympy</st></pre>			<p><st c="31858">Then, install the </st><code><st c="31877">mpmath</st></code><st c="31883"> module, a prerequisite of the </st><code><st c="31914">sympy</st></code><st c="31919"> module:</st></p>
			<pre class="console"><st c="31927">
pip install mpmath</st></pre>			<p><st c="31946">After these installations, we can start </st><st c="31987">problem solving.</st></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor156"/><st c="32003">Solving linear equations</st></h2>
			<p><st c="32028">Let us begin </st><a id="_idIndexMarker432"/><st c="32042">with the following asynchronous </st><a id="_idIndexMarker433"/><st c="32074">route implementation that asks for any linear equation with x and y </st><st c="32142">variables only:</st></p>
			<pre class="source-code"><st c="32157">
from modules.equations import eqn_bp
from flask import render_template, request
</st><strong class="bold"><st c="32238">from sympy import sympify</st></strong>
<strong class="bold"><st c="32263">import gladiator as gl</st></strong><st c="32286">
@eqn_bp.route('/eqn/simple/bivar', methods = ['GET', 'POST'])
async def solve_multivariate_linear():
    if request.method == 'GET':
        soln = None
    else:
        </st><strong class="bold"><st c="32434">field_validations</st></strong><st c="32451"> = (
            ('lineqn', gl.required, gl.type_(str),    gl.regex_('[+\-]?(([0-9]+\.[0-9]+)|([0-9]+\.?)|(\.?[0-9]+))[+\-/*][xy]([+\-/*](([0-9]+\.[0-9]+)|([0-9]+\.?)|(\.?[0-9]+))[+\-/*][xy])*([+\-/*](([0-9]+\.[0-9]+)|([0-9]+\.?)|(\.?[0-9]+)))*')),
            ('xvar', gl.required, gl.type_(str), gl.regex_('[0-9]+')),
            ('yvar', gl.required, gl.type_(str), gl.regex_('[0-9]+'))
        )
        form_data = request.form.to_dict()
        </st><strong class="bold"><st c="32839">result = gl.validate(field_validations, form_data )</st></strong><st c="32890">
        if bool(result):
            </st><strong class="bold"><st c="32908">xval = float(form_data['xvar'])</st></strong><strong class="bold"><st c="32939">yval = float(form_data['yvar'])</st></strong><strong class="bold"><st c="32971">eqn = sympify(form_data['lineqn'], {'x': xval,</st></strong> <strong class="bold"><st c="33018">'y': yval})</st></strong><strong class="bold"><st c="33030">soln = eqn.evalf()</st></strong><st c="33049">
        else:
            soln = None
    return render_template('simple_linear_mv_form.html', soln=soln), 200</st></pre>			<p><st c="33136">Assuming that </st><code><st c="33151">xvar</st></code><st c="33155"> and </st><code><st c="33160">yvar</st></code><st c="33164"> are valid form parameter values convertible to </st><code><st c="33212">float</st></code><st c="33217"> and </st><code><st c="33222">lineqn</st></code><st c="33228"> is a valid two-variate string expression with x and y variables, the </st><code><st c="33298">sympify()</st></code><st c="33307"> method of the </st><code><st c="33322">sympy</st></code><st c="33327"> module can convert </st><code><st c="33347">lineqn</st></code><st c="33353"> to a symbolic formula with </st><code><st c="33381">xvar</st></code><st c="33385"> and </st><code><st c="33390">yvar</st></code><st c="33394"> values assigned to the x and y symbols and compute the solution. </st><st c="33460">To extract the exact value of the sympification, the resulting symbolic formula has a method such as </st><code><st c="33561">evalf()</st></code><st c="33568"> that returns a floating-point value of the solution. </st><st c="33622">Now, the </st><code><st c="33631">sympify()</st></code><st c="33640"> method uses the risky </st><code><st c="33663">eval()</st></code><st c="33669"> function, so the mathematical expression, such as </st><code><st c="33720">lineqn</st></code><st c="33726">, requires sanitation by popular validation tools such as </st><code><st c="33784">gladiator</st></code><st c="33793"> before performing sympification. </st><em class="italic"><st c="33827">Figure 6</st></em><em class="italic"><st c="33835">.9</st></em><st c="33837"> shows a sample execution of </st><code><st c="33866">solve_multivariate_linear()</st></code><st c="33893"> with a sample linear equation and the corresponding values for its x </st><st c="33963">and y:</st></p>
			<div><div><img src="img/B19383_06_009.jpg" alt="Figure 6.9 – Solving a linear equation with x and y variables"/><st c="33969"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="34065">Figure 6.9 – Solving a linear equation with x and y variables</st></p>
			<p><st c="34126">Now, not all</st><a id="_idIndexMarker434"/><st c="34139"> real-world problems are solvable</st><a id="_idIndexMarker435"/><st c="34172"> using linear models. </st><st c="34194">Some require non-linear models to derive </st><st c="34235">their solutions.</st></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor157"/><st c="34251">Solving non-linear formulas</st></h2>
			<p><st c="34279">Flask </st><code><st c="34286">async</st></code><st c="34291"> and </st><code><st c="34296">sympy</st></code><st c="34301"> can</st><a id="_idIndexMarker436"/><st c="34305"> also implement a</st><a id="_idIndexMarker437"/><st c="34322"> view function for solving non-linear equations. </st><st c="34371">The </st><code><st c="34375">sympify()</st></code><st c="34384"> method can recognize Python mathematical functions such as </st><code><st c="34444">exp(x)</st></code><st c="34450">, </st><code><st c="34452">log(x)</st></code><st c="34458">, </st><code><st c="34460">sqrt(x)</st></code><st c="34467">, </st><code><st c="34469">cos(x)</st></code><st c="34475">, </st><code><st c="34477">sin(x)</st></code><st c="34483">, and </st><code><st c="34489">pow(x)</st></code><st c="34495">. Thus, creating mathematical expressions with the inclusion of these Python functions is feasible with </st><code><st c="34599">sympy</st></code><st c="34604">. </st><em class="italic"><st c="34606">Figure 6</st></em><em class="italic"><st c="34614">.10</st></em><st c="34617"> shows a view function that computes a solution of a univariate non-linear equation with </st><st c="34706">one variable.</st></p>
			<div><div><img src="img/B19383_06_010.jpg" alt="Figure 6.10 – Solving a non-linear equation with Python functions"/><st c="34719"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="34811">Figure 6.10 – Solving a non-linear equation with Python functions</st></p>
			<p><st c="34876">The strength of the </st><code><st c="34897">sympy</st></code><st c="34902"> module is to extract the parameter values of an equation or equations </st><a id="_idIndexMarker438"/><st c="34973">based on a given result </st><st c="34997">or</st><a id="_idIndexMarker439"/><st c="34999"> solution.</st></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor158"/><st c="35009">Finding solutions for a linear system</st></h2>
			<p><st c="35047">The </st><code><st c="35052">sympy</st></code><st c="35057"> module </st><a id="_idIndexMarker440"/><st c="35065">has a </st><code><st c="35071">solve()</st></code><st c="35078"> method </st><a id="_idIndexMarker441"/><st c="35086">that can solve systems of linear or polynomial equations. </st><st c="35144">The following implementation can find a solution for a system of two </st><st c="35213">polynomial equations:</st></p>
			<pre class="source-code"><st c="35234">
from modules.equations import eqn_bp
from flask import render_template, request
</st><strong class="bold"><st c="35315">from sympy import symbols, sympify, solve</st></strong><st c="35356">
@eqn_bp.route('/eqn/eqnsystem/solve', methods = ['GET', 'POST'])
async def solve_multiple_eqns():
    if request.method == 'GET':
        soln = None
    else:
        field_validations = (
            ('polyeqn1', gl.required, gl.type_(str)),
            ('polyeqn2', gl.required, gl.type_(str))
        )
        form_data = request.form.to_dict()
        result = gl.validate(field_validations, form_data )
        if bool(result):
            </st><strong class="bold"><st c="35712">x, y = symbols('x y')</st></strong><strong class="bold"><st c="35733">eqn1 = sympify(form_data['polyeqn1'])</st></strong><strong class="bold"><st c="35771">eqn2 = sympify(form_data['polyeqn2'])</st></strong><strong class="bold"><st c="35809">soln = solve((eqn1, eqn2),(x, y))</st></strong><st c="35843">
        else:
            soln = None
    return  render_template('complex_multiple_eqns_form.html',   soln=soln), 200y</st></pre>			<p><st c="35936">After the retrieval from </st><code><st c="35962">request.form</st></code><st c="35974"> and a successful validation using </st><code><st c="36009">gladiator</st></code><st c="36018">, the </st><code><st c="36024">polyeqn1</st></code><st c="36032"> and </st><code><st c="36037">polyeqn2</st></code><st c="36045"> string expressions must undergo sympification</st><a id="_idIndexMarker442"/><st c="36091"> through the </st><code><st c="36104">sympify()</st></code><st c="36113"> method </st><a id="_idIndexMarker443"/><st c="36121">to derive their symbolic equations or </st><code><st c="36159">sympy</st></code><st c="36164"> expressions. </st><st c="36178">The function variables, x and y, of these mathematical expressions must have their corresponding </st><code><st c="36275">Symbol</st></code><st c="36281">-type variables utilizing the </st><code><st c="36312">symbols()</st></code><st c="36321"> function of </st><code><st c="36334">sympy</st></code><st c="36339">, a vital mechanism for creating </st><code><st c="36372">Symbol</st></code><st c="36378"> variables out of string variables. </st><st c="36414">The </st><code><st c="36418">solve()</st></code><st c="36425"> method requires a tuple of these symbolic equations in its first parameter and a tuple of </st><code><st c="36516">Symbols</st></code><st c="36523"> in its second parameter to find the solutions of the linear system. </st><st c="36592">If the linear equations are not parallel to each other, the </st><code><st c="36652">solve()</st></code><st c="36659"> method will return a feasible solution in a dictionary format with </st><code><st c="36727">sympy</st></code><st c="36732"> variables </st><st c="36743">as keys.</st></p>
			<p><st c="36751">If we execute </st><code><st c="36766">solve_multiple_eqns()</st></code><st c="36787"> with a simple linear system, such as passing the </st><code><st c="36837">5*x-3*y-9</st></code><st c="36846"> equation to </st><code><st c="36859">polyeqn1</st></code><st c="36867"> and the </st><code><st c="36876">15*x+3*y+12</st></code><st c="36887"> equation to </st><code><st c="36900">polyeqn2</st></code><st c="36908">, </st><code><st c="36910">solve()</st></code><st c="36917"> will provide us with numerical results, as shown in </st><em class="italic"><st c="36970">Figure 6</st></em><em class="italic"><st c="36978">.11</st></em><st c="36981">.</st></p>
			<div><div><img src="img/B19383_06_011.jpg" alt="Figure 6.11 – Solving simple linear equations"/><st c="36982"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="37122">Figure 6.11 – Solving simple linear equations</st></p>
			<p><st c="37167">However, if we have polynomials or non-linear equations such as passing the </st><code><st c="37244">x**2-10*y+10</st></code><st c="37256"> quadratic </st><a id="_idIndexMarker444"/><st c="37267">formula to </st><code><st c="37278">polyeqn1</st></code><st c="37286"> and the </st><code><st c="37295">10*x+5*y-3</st></code><st c="37305"> linear expression to </st><code><st c="37327">polyeqn2</st></code><st c="37335">, the resulting non-linear solutions will be rational values with square roots, as shown in </st><em class="italic"><st c="37427">Figure 6</st></em><em class="italic"><st c="37435">.12</st></em><st c="37438">.</st></p>
			<div><div><img src="img/B19383_06_012.jpg" alt="Figure 6.12 – Solving polynomial system of equations"/><st c="37439"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="37623">Figure 6.12 – Solving polynomial system of equations</st></p>
			<p><st c="37675">There are many </st><a id="_idIndexMarker445"/><st c="37691">possible symbolic computations, formulas, and algorithms that Flask can implement with </st><code><st c="37778">sympy</st></code><st c="37783">. Sometimes, the </st><code><st c="37800">scipy</st></code><st c="37805"> module can help </st><code><st c="37822">sympy</st></code><st c="37827"> solve other mathematical algorithms that are very </st><a id="_idIndexMarker446"/><st c="37878">tedious and complicated, such as </st><st c="37911">approximation problems.</st></p>
			<p><st c="37934">The </st><code><st c="37939">sympy</st></code><st c="37944"> module is also capable of providing graphical analysis </st><st c="38000">through plots.</st></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor159"/><st c="38014">Plotting mathematical expressions</st></h2>
			<p><st c="38048">When it comes</st><a id="_idIndexMarker447"/><st c="38062"> to visualization, </st><code><st c="38081">sympy</st></code><st c="38086"> is capable </st><a id="_idIndexMarker448"/><st c="38098">of rendering graphs and charts created by its built-in </st><code><st c="38153">matplotlib</st></code><st c="38163"> library. </st><st c="38173">The following view function accepts two equations from the user and creates a graphical plot for the equations within the specified range of values </st><st c="38321">for x:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="38327">from sympy import symbols, sympify</st></strong>
<strong class="bold"><st c="38362">from sympy.plotting import plot</st></strong>
<strong class="bold"><st c="38394">import matplotlib</st></strong>
<strong class="bold"><st c="38412">import base64</st></strong>
<strong class="bold"><st c="38426">from io import BytesIO</st></strong>
<strong class="bold"><st c="38449">from PIL import Image</st></strong><st c="38471">
@eqn_bp.route('/eqn/multi/plot', methods = ['GET', 'POST'])
async def plot_two_equations():
    if request.method == 'GET':
        data = None
    else:
        … … … … … …
        form_data = request.form.to_dict()
        result = gl.validate(field_validations, form_data )
        eqn1_upper = float(form_data['eqn1_maxval'])
        eqn1_lower = float(form_data['eqn1_minval'])
        eqn2_upper = float(form_data['eqn2_maxval'])
        eqn2_lower = float(form_data['eqn2_minval'])
        data = None
        if bool(result) and (eqn1_lower &lt;= eqn1_upper) and (eqn2_lower &lt;= eqn2_upper):
            </st><strong class="bold"><st c="38980">matplotlib.use('agg')</st></strong><st c="39001">
            x = symbols('x')
            eqn1 = sympify(form_data['equation1'])
            eqn2 = sympify(form_data['equation2'])
            </st><strong class="bold"><st c="39097">graph = plot(eqn1, (x, eqn1_lower, eqn1_upper), line_color='red', show=False)</st></strong><strong class="bold"><st c="39174">graph.extend(plot(eqn2, (x, eqn2_lower, eqn2_upper), line_color='blue', show=False))</st></strong><st c="39259">
            filename = "./files/img/multi_plot.png"
            </st><strong class="bold"><st c="39300">graph.save(filename)</st></strong><strong class="bold"><st c="39320">img = Image.open(filename)</st></strong><strong class="bold"><st c="39347">image_io = BytesIO()</st></strong><strong class="bold"><st c="39368">img.save(image_io, 'PNG')</st></strong><st c="39394">
            data = base64.b64encode(image_io.getbuffer()) .decode("ascii")
    return render_template('plot_two_eqns_form.html', data=data), 200</st></pre>			<p><st c="39523">After sanitizing the</st><a id="_idIndexMarker449"/><st c="39544"> string equations </st><a id="_idIndexMarker450"/><st c="39562">and deriving the </st><code><st c="39579">sympy</st></code><st c="39584"> formulas, the view can directly create a plot for each formula using the </st><code><st c="39658">plot()</st></code><st c="39664"> method in the </st><code><st c="39679">sympy.plotting</st></code><st c="39693"> module, which is almost similar to that in the </st><code><st c="39741">matplotlib</st></code><st c="39751"> module but within the context of </st><code><st c="39785">sympy</st></code><st c="39790">. The method returns a </st><code><st c="39813">Plot</st></code><st c="39817"> instance that can combine with another </st><code><st c="39857">Plot</st></code><st c="39861"> using its </st><code><st c="39872">extend()</st></code><st c="39880"> method to create multiple plots in one frame. </st><st c="39927">Running the </st><code><st c="39939">plot_two_equations()</st></code><st c="39959"> view will yield line graphs of both </st><code><st c="39996">equation1</st></code><st c="40005"> and </st><code><st c="40010">equation2</st></code><st c="40019">, as shown in </st><em class="italic"><st c="40033">Figure 6</st></em><em class="italic"><st c="40041">.13</st></em><st c="40044">.</st></p>
			<div><div><img src="img/B19383_06_013.jpg" alt="Figure 6.13 – Plotting the two sympy equations"/><st c="40045"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="40186">Figure 6.13 – Plotting the two sympy equations</st></p>
			<p><st c="40232">On the other</st><a id="_idIndexMarker451"/><st c="40245"> hand, the </st><code><st c="40256">Plot</st></code><st c="40260"> instance</st><a id="_idIndexMarker452"/><st c="40269"> has a </st><code><st c="40276">save()</st></code><st c="40282"> method that can store the graphical plot as an image. </st><st c="40337">However, to create an inline image for a Jinja2 rendition, the view needs the </st><code><st c="40415">Image</st></code><st c="40420"> class from </st><code><st c="40519">BytesIO</st></code><st c="40526"> for </st><code><st c="40531">base64</st></code><st c="40537"> encoding.</st></p>
			<p><st c="40547">Let us examine now how asynchronous Flask can manage those scientific data that need LaTeX serialization or </st><st c="40656">PDF renditions.</st></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor160"/><st c="40671">Creating and rendering LaTeX documents</st></h1>
			<p><strong class="bold"><st c="40710">LaTex</st></strong><st c="40716"> is a high-standard</st><a id="_idIndexMarker454"/><st c="40735"> typesetting system used in publishing and packaging technical and scientific papers and literature, especially those documents with charts, graphs, equations, and tabular data. </st><st c="40913">When creating scientific applications, there should be a mechanism for the application to write LaTeX content, save it in a repository, and render it as </st><st c="41066">a response.</st></p>
			<p><st c="41077">But first, our applications will require a LaTeX compiler that assembles and compiles newly created LaTeX documents. </st><st c="41195">Here are two popular tools that offer various </st><st c="41241">LaTeX compilers:</st></p>
			<ul>
				<li><strong class="bold"><st c="41257">TeX Live</st></strong><st c="41266">: This is an open-source </st><a id="_idIndexMarker455"/><st c="41292">LaTeX tool most suitable for creating secured </st><st c="41338">LaTeX documents.</st></li>
				<li><strong class="bold"><st c="41354">MikTeX</st></strong><st c="41361">: This is an open-source LaTeX tool popular for its on-the-fly libraries and </st><st c="41439">up-to-date releases.</st></li>
			</ul>
			<p><st c="41459">Our application will be utilizing MikTeX for its LaTeX compilers. </st><st c="41526">Do not forget to update MikTex for the latest plugins using the console, as shown in </st><em class="italic"><st c="41611">Figure 6</st></em><em class="italic"><st c="41619">.14</st></em><st c="41622">.</st></p>
			<div><div><img src="img/B19383_06_014.jpg" alt="Figure 6.14 – Updating MikTeX using its console"/><st c="41623"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="41943">Figure 6.14 – Updating MikTeX using its console</st></p>
			<p><st c="41990">After the MikTeX installation and update, let’s create the Flask project by installing the </st><code><st c="42082">latex</st></code><st c="42087"> module.</st></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor161"/><st c="42095">Rendering LaTeX documents</st></h2>
			<p><st c="42121">Asynchronous</st><a id="_idIndexMarker456"/><st c="42134"> view functions can create, update, and render LaTeX documents through LaTeX-related modules and </st><code><st c="42231">matplotlib</st></code><st c="42241"> for immediate textual and graphical plots or perform LaTeX to PDF transformation of existing LaTeX documents for rendition. </st><st c="42366">The latter requires the installation of the </st><code><st c="42410">latex</st></code><st c="42415"> module through the </st><code><st c="42435">pip</st></code><st c="42438"> command:</st></p>
			<pre class="console"><st c="42447">
pip install latex</st></pre>			<p><st c="42465">The </st><code><st c="42470">latex</st></code><st c="42475"> module uses its built-in Jinja libraries to access </st><code><st c="42527">latex</st></code><st c="42532"> files stored in the main project. </st><st c="42567">So, the first step is to create a Jinja environment with all the details that will calibrate the Jinja engine regarding LaTeX file handling. </st><st c="42708">The following snippet shows how to set up the Jinja environment using the </st><code><st c="42782">latex.jinja2</st></code><st c="42794"> module:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="42802">from jinja2 import FileSystemLoader, Environment</st></strong>
<strong class="bold"><st c="42851">from latex.jinja2 import make_env</st></strong><st c="42885">
environ:</st><strong class="bold"><st c="42894">Environment</st></strong><st c="42906"> = make_env(loader=FileSystemLoader('files'), </st><strong class="bold"><st c="42952">enable_async=True,</st></strong><st c="42970">
    block_start_string = '\BLOCK{',
    block_end_string = '}',
    variable_start_string = 'VAR{',
    variable_end_string = '}',
    comment_start_string = '#{',
    comment_end_string = '}',
    line_statement_prefix = '%-',
    line_comment_prefix = '%#',
    trim_blocks = True,
    autoescape = False,)</st></pre>			<p><st c="43239">Since </st><code><st c="43246">ch06-project</st></code><st c="43258"> uses </st><code><st c="43264">Blueprint</st></code><st c="43273"> to organize the views and the corresponding components, only the rendition module (</st><code><st c="43357">/modules/rendition</st></code><st c="43376">) that builds the LaTeX web displays can access this environment configuration. </st><st c="43457">This Jinja environment details, defined in </st><code><st c="43500">/modules/rendition/__init__.py</st></code><st c="43530">, declares that the </st><code><st c="43550">files</st></code><st c="43555"> folder in the project directory will become the root folder for our LaTeX documents. </st><st c="43641">Moreover, it tells Jinja the syntax preferences for some LaTeX commands, such as the </st><code><st c="43726">BLOCK</st></code><st c="43731">, </st><code><st c="43733">VAR</st></code><st c="43736">, conditional statement, and comment symbols. </st><st c="43782">Instead of having a backslash pipe (</st><code><st c="43818">"\"</st></code><st c="43822">) in </st><code><st c="43828">\VAR{}</st></code><st c="43834">, the setup wants Jinja to recognize the </st><code><st c="43875">VAR{}</st></code><st c="43880"> statement, an interpolation operator, without the backslash pipe. </st><st c="43947">Violating the given syntax rules will flag an error in Flask. </st><st c="44009">The </st><code><st c="44013">enable_async</st></code><st c="44025"> property, on the other hand, allows the execution of </st><code><st c="44079">latex</st></code><st c="44084"> commands in asynchronous view functions, such as the following</st><a id="_idIndexMarker457"/><st c="44147"> view implementation that opens a document and updates it </st><st c="44205">for display:</st></p>
			<pre class="source-code"><st c="44217">
from modules.rendition import rendition_bp
from flask import send_from_directory
from jinja2 import FileSystemLoader
from latex.jinja2 import make_env
@rendition_bp.route('/render/hpi/plot/eqns', methods = ['GET', 'POST'])
</st><strong class="bold"><st c="44441">async</st></strong><st c="44446"> def convert_latex():
    </st><strong class="bold"><st c="44468">tpl = environ.get_template('/latex/hpi_plot.tex')</st></strong><st c="44517">
    outpath=os.path.join('./files/latex','hpi_plot.pdf')
    outfile=open(outpath,'w')
    </st><strong class="bold"><st c="44597">outfile.write(await tpl.render_async(author='Sherwin</st></strong> <strong class="bold"><st c="44649">John Tragura', title="Rendering HPI Plot with</st></strong> <strong class="bold"><st c="44695">LaTeX", date=datetime.now().strftime("%B %d, %Y"),</st></strong> <strong class="bold"><st c="44746">renderTbl=True))</st></strong><strong class="bold"><st c="44763">outfile.close()</st></strong><st c="44779">
    os.system("pdflatex </st><strong class="bold"><st c="44800">--shell-escape</st></strong><st c="44814"> -output-directory=" + './files/latex' + " " + outpath)
    </st><code><st c="44959">get_template()</st></code><st c="44973"> of the </st><code><st c="44981">Environment</st></code><st c="44992"> instance, </st><code><st c="45003">environ</st></code><st c="45010">, to create a Jinja2 template of a specific LaTeX document from the </st><code><st c="45078">/latex</st></code><st c="45084"> sub-directory of the root folder. </st><st c="45119">The template’s </st><code><st c="45134">render_async()</st></code><st c="45148"> function opens the specified LaTeX document for changes, such as passing context values (e.g., </st><code><st c="45244">author</st></code><st c="45250">, </st><code><st c="45252">title</st></code><st c="45257">, </st><code><st c="45259">date</st></code><st c="45263">, and </st><code><st c="45269">renderTbl</st></code><st c="45278">) to complete </st><st c="45293">the document.</st></p>
			<p><st c="45306">Afterward, the </st><code><st c="45322">view</st></code><st c="45326"> function will convert the document into PDF format, which is the necessary approach for this application. </st><code><st c="45433">os.path.join()</st></code><st c="45447"> will indicate where to save the file. </st><st c="45486">Now, MikTeX offers three compilers to compile and convert the LaTeX document to PDF, namely pdfLaTeX, XeLaTeX, and LuaLaTeX, but our implementation uses pdfLaTeX, which is the default one. </st><code><st c="45675">os.system()</st></code><st c="45686"> will run the compiler and save the PDF into the specific location. </st><st c="45754">To render the content, Flask has a </st><code><st c="45789">send_from_directory()</st></code><st c="45810"> method that can display the content of a PDF file saved in the directory. </st><em class="italic"><st c="45885">Figure 6</st></em><em class="italic"><st c="45893">.15</st></em><st c="45896"> shows the</st><a id="_idIndexMarker458"/><st c="45906"> resulting PDF document by running the </st><code><st c="45945">convert_latex()</st></code> <st c="45960">view function.</st></p>
			<div><div><img src="img/B19383_06_015.jpg" alt="Figure 6.15 – Rendering a LaTeX document as a PDF"/><st c="45975"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="46098">Figure 6.15 – Rendering a LaTeX document as a PDF</st></p>
			<p><st c="46147">Our Flask application</st><a id="_idIndexMarker459"/><st c="46169"> does not only render existing LaTeX documents but also creates one before rendering it to </st><st c="46260">the client.</st></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor162"/><st c="46271">Creating LaTeX documents</st></h2>
			<p><st c="46296">So far, the </st><code><st c="46309">latex</st></code><st c="46314"> module </st><a id="_idIndexMarker460"/><st c="46322">with Jinja2 has no LaTeX creation features that Flask can use to build scientific writeups from various data sources. </st><st c="46440">However, other modules, such as </st><code><st c="46472">pylatex</st></code><st c="46479">, can provide helper classes and methods to serialize LaTeX content at runtime. </st><st c="46559">The following view implementation shows how to generate a LaTeX file with </st><code><st c="46633">DataFrame</st></code><st c="46642"> object’s data derived from an uploaded </st><st c="46682">XLSX document:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="46696">from pylatex import Document, Section, Command, NoEscape, Subsection, Tabular, Center</st></strong>
<strong class="bold"><st c="46782">from pylatex.utils import italic</st></strong>
<strong class="bold"><st c="46815">from pylatex.basic import NewLine</st></strong><st c="46849">
@rendition_bp.route('/create/hpi/desc/latex', methods = ['GET', 'POST'])
async def create_latex_pdf():
    if request.method == 'GET':
         return render_template("hpi_latex_form.html"), 200
    else:
        … … … … … …
        … … … … … …
        try:
            df = read_excel(uploaded_file, sheet_name=2, skiprows=[1])
            hpi_data = df.loc[: , 'Australia':'US'].describe().to_dict()
            hpi_filename = os.path.join('./files/latex','hpi_analysis')</st></pre>			<p><st c="47246">Before anything else, the environment setup must have the MikTeX or TeX Live installation for the LaTeX compilers. </st><st c="47362">Then, install the </st><code><st c="47380">pylatex</st></code><st c="47387"> module through the </st><code><st c="47407">pip</st></code><st c="47410"> command:</st></p>
			<pre class="console"><st c="47419">
pip install pylatex</st></pre>			<p><st c="47439">To start the transaction, the given </st><code><st c="47476">create_latext_pdf()</st></code><st c="47495"> retrieves an uploaded XLSX document to derive the tabular values for the </st><st c="47569">report generation:</st></p>
			<pre class="source-code"><st c="47587">
            geometry_options = {
                "landscape": True,
                "margin": "0.5in",
                "headheight": "20pt",
                "headsep": "10pt",
                "includeheadfoot": True
            }
            doc = Document(page_numbers=True, </st><code><st c="47748">geometry_options=geometry_options</st></code><st c="47781">, </st><code><st c="47783">document_options=['10pt','legalpaper']</st></code><st c="47821">)
            doc.preamble.append(Command('title', 'Mean HPI per Country'))
            doc.preamble.append(Command('author', 'Sherwin John C. </st><st c="47941">Tragura'))
            doc.preamble.append(Command('date', NoEscape(r'\today')))
            doc.append(NoEscape(r'\maketitle'))</st></pre>			<p><st c="48045">Then, it sets up a</st><a id="_idIndexMarker461"/><st c="48064"> dictionary, </st><code><st c="48077">geometry_options</st></code><st c="48093">, that consists of the LaTeX document parameters, such as the document orientation (</st><code><st c="48177">landscape</st></code><st c="48187">), the left, right, top, and bottom margins (</st><code><st c="48233">margin</st></code><st c="48240">), the vertical height from the bottom part of the header down to the topmost area of first the text (</st><code><st c="48343">headsep</st></code><st c="48351">), the space from the top margin to the line where to start the header part (</st><code><st c="48429">headheight</st></code><st c="48440">), and the toggle parameter to include or exclude the document header and footer of the document (</st><code><st c="48539">includeheadfoot</st></code><st c="48555">). </st><st c="48559">This dictionary is essential to the instantiation of the </st><code><st c="48616">pylatex</st></code><st c="48623">’s </st><code><st c="48627">Document container</st></code><st c="48645"> class, which will represent the </st><st c="48678">LaTeX document.</st></p>
			<p><st c="48693">Initially, the LaTeX document will be a blank instance with the desired document parameters indicated by its </st><code><st c="48803">geometry_option</st></code><st c="48818"> constructor parameter and the </st><code><st c="48849">document_options</st></code><st c="48865"> list containing other options such as the font size and paper size. </st><st c="48934">Then, to start customizing the document, the </st><code><st c="48979">view</st></code><st c="48983"> function uses the </st><code><st c="49002">Command</st></code><st c="49009"> class to create custom values to the document’s title, author, and date without escaping the backslash, thus the use of the </st><code><st c="49134">NoEscape</st></code><st c="49142"> class, and append them to the preamble property of the </st><code><st c="49198">Document</st></code><st c="49206"> instance. </st><st c="49217">This process is similar to calling </st><code><st c="49252">\title</st></code><st c="49258">, </st><code><st c="49260">\author</st></code><st c="49267">, and </st><code><st c="49273">\date</st></code><st c="49278"> commands with custom values interpolated by the </st><code><st c="49327">\</st></code><code><st c="49328">VAR{}</st></code><st c="49333"> command.</st></p>
			<p><st c="49342">Next, the view must append the </st><code><st c="49374">\maketitle</st></code><st c="49384"> command without escaping the backslash to typeset all these added document details. </st><st c="49469">The line following </st><code><st c="49488">\maketitle</st></code><st c="49498"> is always the generation of the body content, in our case, the </st><st c="49562">following section:</st></p>
			<pre class="source-code"><st c="49580">
            with doc.create(Section('The Data Analysis')):
              doc.append('Here are the statistical analysis derived from the uploaded excel data.')</st></pre>			<p><st c="49713">The </st><code><st c="49718">pylatex</st></code><st c="49725"> module classes are equivalent to some LaTeX commands, such as </st><code><st c="49788">Axis</st></code><st c="49792">, </st><code><st c="49794">Math</st></code><st c="49798">, </st><code><st c="49800">Matrix</st></code><st c="49806">, </st><code><st c="49808">Center</st></code><st c="49814">, </st><code><st c="49816">Alignat</st></code><st c="49823">, </st><code><st c="49825">Alignref</st></code><st c="49833">, and </st><code><st c="49839">Plot</st></code><st c="49843">. The </st><code><st c="49849">Command</st></code><st c="49856"> class is a module class used to run custom or general commands such as </st><code><st c="49928">\title</st></code><st c="49934">, </st><code><st c="49936">\author</st></code><st c="49943">, and </st><code><st c="49949">\date</st></code><st c="49954">. In this </st><code><st c="49964">create_latex_pdf()</st></code><st c="49982"> view, the content generation started with running the </st><code><st c="50037">Section</st></code><st c="50044"> command</st><a id="_idIndexMarker462"/><st c="50052"> with a section title, </st><em class="italic"><st c="50075">The Data Analysis. </st><st c="50094">A</st></em><st c="50095"> section is an organized part of the content that contains combinations of tables, text, plots, and mathematical equations. </st><st c="50219">After that, the view appends a statement in text form. </st><st c="50274">Since there is no backslash to escape, there is no reason to wrap the test with the </st><code><st c="50358">NoEscape</st></code><st c="50366"> class. </st><st c="50374">Then, we create the sub-sections indicated in the </st><st c="50424">following snippet:</st></p>
			<pre class="source-code"><st c="50442">
                with doc.create(Subsection('Statistical analysis generated by Pandas')):
                    with doc.create(Tabular('| c | c | c | c | c | c | c | c | c |')) as table:
                        table.add_hline()
                        table.add_row(("Country", "Count", "Mean", "Std Dev", "Min", "25%", "50%", "75%", "Max"))
                        table.add_empty_row()
                        for key, value in hpi_data.items():
                            table.add_hline()
                            table.add_row((key, value['count'], value['mean'], value['std'], value['min'], value['25%'], value['50%'], value['75%'], value['max']))
                        table.add_empty_row()
                        table.add_hline()
        except:
            raise FileSavingException()</st></pre>			<p><st c="50987">After the text, the view appends a </st><code><st c="51023">Subsection</st></code><st c="51033"> command, which will granularize the content of the recently created section. </st><st c="51111">Part of its component is the </st><code><st c="51140">Tabular</st></code><st c="51147"> command that will </st><a id="_idIndexMarker463"/><st c="51166">construct a spreadsheet of HPI values derived from the extracted tabular values. </st><st c="51247">After the assemblage of the LaTeX content, the </st><code><st c="51294">create_latex_pdf()</st></code><st c="51312"> view will now generate the PDF for rendition, as shown in the </st><st c="51375">following snippet:</st></p>
			<pre class="source-code"><st c="51393">
        doc.generate_pdf(hpi_filename, clean_tex=False, compiler="pdflatex")
        return send_from_directory('./files/latex', 'hpi_analysis.pdf')</st></pre>			<p><st c="51526">The </st><code><st c="51531">Document</st></code><st c="51539"> instance has a </st><code><st c="51555">generate_pdf()</st></code><st c="51569"> method that compiles and generates the LaTeX file, converts the LaTeX file to its PDF form, and saves both files to a specific directory. </st><st c="51708">Once the PDF is available, the view can render the PDF content through Flask’s </st><code><st c="51787">send_from_directory()</st></code><st c="51808"> method. </st><em class="italic"><st c="51817">Figure 6</st></em><em class="italic"><st c="51825">.16</st></em><st c="51828"> displays the generated PDF of the </st><code><st c="51863">create_latex_pdf()</st></code> <st c="51881">view function.</st></p>
			<div><div><img src="img/B19383_06_016.jpg" alt="Figure 6.16 – A PDF generated by the pylatex module"/><st c="51896"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="52320">Figure 6.16 – A PDF generated by the pylatex module</st></p>
			<p><st c="52371">Aside from rendering PDF content, Flask can also utilize popular frontend libraries for displaying graphs and </st><a id="_idIndexMarker464"/><st c="52482">charts. </st><st c="52490">Let us concentrate on how Flask can integrate with </st><a id="_idIndexMarker465"/><st c="52541">these </st><strong class="bold"><st c="52547">JavaScript</st></strong><st c="52557"> (</st><strong class="bold"><st c="52559">JS</st></strong><st c="52561">)-based libraries in </st><st c="52583">visualizing datasets.</st></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor163"/><st c="52604">Building graphical charts with frontend libraries</st></h1>
			<p><st c="52654">Most developers prefer </st><a id="_idIndexMarker466"/><st c="52678">rendering</st><a id="_idIndexMarker467"/><st c="52687"> graphs and charts using frontend libraries rather than </st><code><st c="52743">matplotlib</st></code><st c="52753">, which requires complex Python coding to refine presentation and lacks UI-related features such as responsiveness, adaptability, and user interaction. </st><st c="52905">This section will highlight the Chart.js, </st><code><st c="52947">Bokeh</st></code><st c="52952">, and </st><code><st c="52958">Plotly</st></code><st c="52964"> libraries, which are all popular libraries with varying strengths and weaknesses as external tools </st><st c="53064">for visualization.</st></p>
			<p><st c="53082">Let’s begin </st><st c="53095">with Chart.js.</st></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor164"/><st c="53109">Plotting with Chart.js</st></h2>
			<p><st c="53132">The most common </st><a id="_idIndexMarker468"/><st c="53149">and popular charting library used in many visualization applications is Chart.js. </st><st c="53231">It is 100% JS, is lightweight, is easy to use, and has a straightforward syntax for designing graphs and charts. </st><st c="53344">The following is the Chart.js implementation that displays the mean HPI values of </st><st c="53426">certain countries:</st></p>
			<pre class="source-code"><st c="53444">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  … … … … … …
  … … … … … …
  </st><strong class="bold"><st c="53508">&lt;script src='https://cdn.jsdelivr.net/npm/chart.js'&gt;&lt;/script&gt;</st></strong><st c="53569">
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;form action="{{request.path}}" method="POST" enctype="multipart/form-data"&gt;
      Upload XLSX file:
      &lt;input type="file" name="data_file"/&gt;&lt;br/&gt;
      &lt;input type="submit" value="Upload File"/&gt;
  &lt;/form&gt;&lt;br/&gt;
  </st><strong class="bold"><st c="53800">&lt;canvas id="linechart" width="300" height="100"&gt;&lt;/canvas&gt;</st></strong><st c="53857">
&lt;/body&gt;
&lt;script&gt;
  </st><strong class="bold"><st c="53875">var linechart = document.getElementById("linechart");</st></strong><strong class="bold"><st c="53928">Chart.defaults.font.family = "Courier";</st></strong><strong class="bold"><st c="53968">Chart.defaults.font.size = 14;</st></strong><strong class="bold"><st c="53999">Chart.defaults.color = "black";</st></strong></pre>			<p><st c="54031">Chart.js is available in </st><a id="_idIndexMarker469"/><st c="54057">three sources:</st></p>
			<ul>
				<li><strong class="bold"><st c="54071">Node.js</st></strong><st c="54079">: By running npm to install the </st><st c="54112">chart.js module.</st></li>
				<li><strong class="bold"><st c="54128">GitHub</st></strong><st c="54135">: By downloading the </st><a href="https://github.com/chartjs/Chart.js/releases/download/v4.4.0/chart.js-4.4.0.tgz"><st c="54157">https://github.com/chartjs/Chart.js/releases/download/v4.4.0/chart.js-4.4.0.tgz</st></a><st c="54236"> file or the latest </st><st c="54256">release available.</st></li>
				<li><strong class="bold"><st c="54274">Content delivery network</st></strong><strong class="bold"><st c="54299"> (CDN)</st></strong><st c="54305">: By</st><a id="_idIndexMarker470"/> <st c="54310">referencing </st><a href="https://cdn.jsdelivr.net/npm/chart.js"><st c="54323">https://cdn.jsdelivr.net/npm/chart.js</st></a><st c="54360">.</st></li>
			</ul>
			<p><st c="54361">Based on the HTML script, our implementation opted for the </st><st c="54421">CDN source.</st></p>
			<p><st c="54432">After referencing Chart.js, create a </st><code><st c="54470">&lt;canvas&gt;</st></code><st c="54478"> tag with the width and height that fits your plot. </st><st c="54530">Then, create a </st><code><st c="54545">Chart()</st></code><st c="54552"> instance with the node or 2D context of </st><code><st c="54593">&lt;canvas&gt;</st></code><st c="54601"> and some</st><a id="_idIndexMarker471"/><st c="54610"> configuration options. </st><st c="54634">Moreover, set new and appropriate values to global default properties such as the font name, font size, and </st><st c="54742">font color:</st></p>
			<pre class="source-code"><st c="54753">
  new Chart(linechart,{
      </st><strong class="bold"><st c="54776">type: 'line',</st></strong><strong class="bold"><st c="54789">options:</st></strong><st c="54798"> {
          </st><strong class="bold"><st c="54801">scales:</st></strong><st c="54808"> {
            </st><strong class="bold"><st c="54811">y</st></strong><st c="54812">: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Mean HPI'
              }
            },
            </st><strong class="bold"><st c="54881">x</st></strong><st c="54882">: {
              offset: true,
              title: {
                display: true,
                text: 'Countries with HPI'
              }
            }
          }
      },
      </st><strong class="bold"><st c="54960">data</st></strong><st c="54964">: {
          borderWidth: ,
          labels : [
            {% for item in labels %}
              "{{ item }}",
            {% endfor %}
          ],</st></pre>			<p><st c="55049">The </st><code><st c="55054">data</st></code><st c="55058"> property provides the x-axis labels, data points, and connecting lines. </st><st c="55131">Its </st><code><st c="55135">datasets</st></code><st c="55143"> sub-property </st><a id="_idIndexMarker472"/><st c="55157">contains the look-and-feel details of the plots with the actual data. </st><st c="55227">Both the </st><code><st c="55236">label</st></code><st c="55241"> and </st><code><st c="55246">data</st></code><st c="55250"> lists are context data supplied by its </st><st c="55290">view function:</st></p>
			<pre class="source-code"><st c="55304">
          datasets: [{
              fill : true,
              barPercentage: 0.5,
              barThickness: 20,
              maxBarThickness: 70,
              borderWidth : 1,
              minBarLength: 5,
              backgroundColor: "rgba(230,112,16,0.88)",
              borderColor : "rgba(38,22,6,0.88)",
              label: 'Mean HPI values',
              data : [
                {% for item in values %}
                  "{{ item }}",
                  {% endfor %}
              ]
            }]
        }
      });
&lt;/script&gt;
&lt;/html&gt;</st></pre>			<p><st c="55617">Now, Chart.js can also build multiple line graphs, varieties of bar graphs, pie charts, and doughnuts, all using the same setup as the given line graph. </st><st c="55771">Running the view function with the given Chart.js</st><a id="_idIndexMarker473"/><st c="55820"> script will render a line graph, as indicated in </st><em class="italic"><st c="55870">Figure 6</st></em><em class="italic"><st c="55878">.17</st></em><st c="55881">.</st></p>
			<div><div><img src="img/B19383_06_017.jpg" alt="Figure 6.17 – A line graph for HPI values per country"/><st c="55882"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="56131">Figure 6.17 – A line graph for HPI values per country</st></p>
			<p><st c="56184">Chart.js supports responsive web design and interactive results, such as the given line graph that provides us with some information during mouse-over on every line dot. </st><st c="56355">Despite its popularity, Chart.js still utilizes HTML canvas, which cannot render efficiently large and complex graphs. </st><st c="56474">Also, it lacks other interactive utilities present in Bokeh </st><st c="56534">and Plotly.</st></p>
			<p><st c="56545">Let us now create </st><a id="_idIndexMarker474"/><st c="56564">graphs using a module friendlier to </st><st c="56600">Python, </st><strong class="bold"><st c="56608">Plotly</st></strong><st c="56614">.</st></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor165"/><st c="56615">Creating graphs with Plotly</st></h2>
			<p><st c="56643">Plotly is also a JS-based</st><a id="_idIndexMarker475"/><st c="56669"> library that can render interactive </st><a id="_idIndexMarker476"/><st c="56706">charts and graphs. </st><st c="56725">It is a popular library for various statistical and mathematical projects that require interactive data visualization and 3D graphics effects and can seamlessly plot </st><st c="56891">DataFrame datasets.</st></p>
			<p><st c="56910">To utilize its classes and methods for plotting graphs, install the </st><code><st c="56979">plotly</st></code><st c="56985"> module through the </st><code><st c="57005">pip</st></code><st c="57008"> command:</st></p>
			<pre class="console"><st c="57017">
pip install plotly</st></pre>			<p><st c="57036">The following view function uses Plotly to create a grouped bar graph about the price and bedroom preferences of buyers categorized according to their furnishing </st><st c="57199">status preference:</st></p>
			<pre class="source-code"><st c="57217">
import json
</st><strong class="bold"><st c="57230">import plotly</st></strong>
<strong class="bold"><st c="57243">import plotly.express as px</st></strong><st c="57271">
@rendition_bp.route("/plotly/csv/bedprice", methods = ['GET', 'POST'])
async def create_plotly_stacked_bar():
    if request.method == 'GET':
        graphJSON = '{}'
    else:
        … … … … … …
        try:
            df_csv = read_csv(uploaded_file)
            </st><strong class="bold"><st c="57483">fig = px.bar(df_csv, x='Bedrooms', y='Price',</st></strong> <strong class="bold"><st c="57528">color='FurnishingStatus', barmode='group')</st></strong><strong class="bold"><st c="57571">graphJSON = json.dumps(fig,</st></strong> <strong class="bold"><st c="57599">cls=plotly.utils.PlotlyJSONEncoder)</st></strong><st c="57635">
        except:
            raise FileSavingException()
    return render_template('plotly.html', </st><code><st c="57813">plotly.express</st></code><st c="57827"> module, which provides several plotting utilities that can set up build graphs with DataFrame as input, similar to </st><code><st c="57943">matplotlib</st></code><st c="57953">’s methods. </st><st c="57966">In the given </st><code><st c="57979">create_plotly_stacked_bar()</st></code><st c="58006"> view function, the goal is to create a grouped bar chart using the </st><code><st c="58074">bar()</st></code><st c="58079"> method from the </st><code><st c="58096">plotly.express</st></code><st c="58110"> module with the </st><code><st c="58127">DataFrame</st></code><st c="58136"> object’s tabular values derived from the uploaded CSV file. </st><st c="58197">The result is a </st><code><st c="58213">Figure</st></code><st c="58219"> in dictionary form containing the details of the </st><st c="58269">desired plot.</st></p>
			<p><st c="58282">After creating the </st><code><st c="58302">Figure</st></code><st c="58308">, the view function will pass the resulting dictionary to the Jinja2 template</st><a id="_idIndexMarker477"/><st c="58385"> for </st><a id="_idIndexMarker478"/><st c="58390">rendition and display using Plotly’s JS library. </st><st c="58439">However, JS can only understand the dictionary details if they are in JSON string format. </st><st c="58529">Thus, use the </st><code><st c="58543">json.dumps()</st></code><st c="58555"> method to convert the dictionary </st><code><st c="58589">fig</st></code> <st c="58592">to string.</st></p>
			<p><st c="58603">The following is the Jinja template that will render the graph using the Plotly </st><st c="58684">JS library:</st></p>
			<pre class="source-code"><st c="58695">
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Plotly Bar Graph&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        … … … … … …
        {%if graphJSON == '{}' %}
            &lt;p&gt;No plot image.&lt;/p&gt;
        {% else %}
            </st><strong class="bold"><st c="58844">&lt;div id='chart' class='chart'&gt;&lt;/div&gt;</st></strong><st c="58880">
        {% endif %}
    &lt;/body&gt;
    </st><strong class="bold"><st c="58901">&lt;script src='https://cdn.plot.ly/plotly-latest.js'&gt;&lt;/script&gt;</st></strong><strong class="bold"><st c="58961">&lt;script type='text/javascript'&gt;</st></strong><strong class="bold"><st c="58993">var graphs = {{ graphJSON | safe }};</st></strong><strong class="bold"><st c="59030">Plotly.plot('chart', graphs, {});</st></strong><strong class="bold"><st c="59064">&lt;/script&gt;</st></strong><st c="59074">
&lt;/html&gt;</st></pre>			<p><st c="59082">The HTML script must reference the latest Plotly library from CDN. </st><st c="59150">Then, a JS script must interpolate the JSON-formatted </st><code><st c="59204">Figure</st></code><st c="59210"> from the view function with a safe filter to spare it from HTML escaping. </st><st c="59285">Also, the JS must apply the </st><code><st c="59313">plot()</st></code><st c="59319"> method of the </st><code><st c="59334">Plotly</st></code><st c="59340"> class library</st><a id="_idIndexMarker479"/><st c="59354"> to</st><a id="_idIndexMarker480"/><st c="59357"> render the figure through the HTML’s </st><code><st c="59395">&lt;div&gt;</st></code><st c="59400"> component. </st><em class="italic"><st c="59412">Figure 6</st></em><em class="italic"><st c="59420">.18</st></em><st c="59423"> shows the bar graph generated by the </st><code><st c="59461">create_plotly_stacked_bar()</st></code><st c="59488"> view function and displayed by its </st><st c="59524">Jinja template.</st></p>
			<div><div><img src="img/B19383_06_018.jpg" alt="Figure 6.18 – A bar graph created by Plotly"/><st c="59539"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="59767">Figure 6.18 – A bar graph created by Plotly</st></p>
			<p><st c="59810">Like Chart.js, the chart provides information regarding a data plot when hovered by the mouse. </st><st c="59906">However, it seems that Chart.js loads faster than Plotly when the data size of the </st><code><st c="59989">DataFrame</st></code><st c="59998"> object’s tabular values increases. </st><st c="60034">Also, there is limited support for colors for the background, foreground, and </st><a id="_idIndexMarker481"/><st c="60112">bar shades, so it is hard to </st><a id="_idIndexMarker482"/><st c="60141">construct a more </st><st c="60158">original theme.</st></p>
			<p><st c="60173">The next JS library supports many popular PyData tools and can generate plots directly from </st><code><st c="60266">pandas'</st></code> <code><st c="60273">DataFrame</st></code><st c="60283">, </st><strong class="bold"><st c="60285">Bokeh</st></strong><st c="60290">.</st></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor166"/><st c="60291">Visualizing data using Bokeh</st></h2>
			<p><st c="60320">Bokeh and </st><a id="_idIndexMarker483"/><st c="60331">Plotly are similar in many ways. </st><st c="60364">They </st><a id="_idIndexMarker484"/><st c="60369">have interactive and 3D graphing features, and both need module installation. </st><st c="60447">However, Bokeh is more Pythonic than Plotly. </st><st c="60492">Because of that, it can transact more with DataFrame objects, especially those with </st><st c="60576">large datasets.</st></p>
			<p><st c="60591">To utilize the library, first install its module using the </st><code><st c="60651">pip</st></code><st c="60654"> command:</st></p>
			<pre class="console"><st c="60663">
pip install bokeh</st></pre>			<p><st c="60681">Once installed, the module provides a figure class from its </st><code><st c="60742">bokeh.plotting</st></code><st c="60756"> module, which is responsible for setting up the plot configuration. </st><st c="60825">The following view implementation uses Bokeh to create a line graph showing the UK’s HPI values through </st><st c="60929">the years:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="60939">from bokeh.plotting import figure</st></strong>
<strong class="bold"><st c="60973">from bokeh.embed import components</st></strong><st c="61008">
@rendition_bp.route('/bokeh/hpi/line', methods = ['GET', 'POST'])
def create_bokeh_line():
    if request.method == 'GET':
        script = None
        div = None
    else:
        … … … … … …
        try:
            df = read_excel(uploaded_file, sheet_name=1, skiprows=[1])
            x = df.index.values
            y = df['UK']
            </st><strong class="bold"><st c="61268">plot = figure(max_width=600, max_height=800,title=None, toolbar_location="below", background_fill_color="#FFFFCC", x_axis_label='Period by Quarter ID', y_axis_label='Nominal HPI')</st></strong><strong class="bold"><st c="61447">plot.line(x,y, line_width=4, color="#CC0000")</st></strong><strong class="bold"><st c="61493">script, div = components(plot)</st></strong><st c="61524">
        except:
            raise FileSavingException()
    return render_template('bokeh.html', script=script, div=div, title="Line Graph of UK's Nominal HPI")</st></pre>			<p><st c="61661">After creating the </st><code><st c="61681">Figure</st></code><st c="61687"> instance with the plot details, such as </st><code><st c="61728">max_width</st></code><st c="61737">, </st><code><st c="61739">max_height</st></code><st c="61749">, </st><code><st c="61751">background_fill_color</st></code><st c="61772">, </st><code><st c="61774">x_axis_label</st></code><st c="61786">, </st><code><st c="61788">y_axis_label</st></code><st c="61800">, and other </st><a id="_idIndexMarker485"/><st c="61812">related </st><a id="_idIndexMarker486"/><st c="61820">configurations, the view function can now invoke any of its </st><em class="italic"><st c="61880">glyph</st></em><st c="61885"> or plotting methods, such as </st><code><st c="61915">vbar()</st></code><st c="61921"> for plotting vertical bar graph, </st><code><st c="61955">hbar()</st></code><st c="61961"> for horizontal bar graph, </st><code><st c="61988">scatter()</st></code><st c="61997"> for scatter plots, and </st><code><st c="62021">wedge()</st></code><st c="62028"> for pie charts. </st><st c="62045">The given </st><code><st c="62055">create_bokeh_line()</st></code><st c="62074"> view utilizes the </st><code><st c="62093">line()</st></code><st c="62099"> method to build a line graph with x and y values derived from the </st><st c="62166">tabular values.</st></p>
			<p><st c="62181">After assembling the </st><code><st c="62203">Figure</st></code><st c="62209"> and its plot, call the </st><code><st c="62233">components()</st></code><st c="62245"> function from </st><code><st c="62260">bokeh.embed</st></code><st c="62271"> to wrap the plot instance and extract a tuple of two HTML embeddable components, namely the script that will contain the data of the graph and the </st><code><st c="62419">div </st></code><st c="62423">component that contains the dashboard embedded in a </st><code><st c="62475">&lt;div&gt;</st></code><st c="62480"> tag. </st><st c="62486">The function must pass these two components to its Jinja template for rendition. </st><st c="62567">The following is the Jinja template that will render the </st><code><st c="62624">div</st></code><st c="62627"> component:</st></p>
			<pre class="source-code"><st c="62638">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Bokeh HPI&lt;/title&gt;
        </st><strong class="bold"><st c="62727">&lt;script src="img/bokeh-3.2.2.js"&gt;&lt;/script&gt;</st></strong><st c="62801">
    &lt;/head&gt;
    &lt;body&gt;
         … … … … … …
        {%if div == None and script == None %}
            &lt;p&gt;No plot image.&lt;/p&gt;
        {% else %}
        </st><strong class="bold"><st c="62900">{{ div | safe }}</st></strong><strong class="bold"><st c="62916">{{ script | safe }}</st></strong><st c="62936">
        {% endif %}
    &lt;/body&gt;
&lt;/html&gt;</st></pre>			<p><st c="62964">Be sure to have the </st><a id="_idIndexMarker487"/><st c="62985">latest </st><a id="_idIndexMarker488"/><st c="62992">Bokeh JS library in your HTML script. </st><st c="63030">Since both </st><code><st c="63041">div</st></code><st c="63044"> and </st><code><st c="63049">script</st></code><st c="63055"> are HTML-embeddable components, the template will directly interpolate them with the filter safe. </st><em class="italic"><st c="63154">Figure 6</st></em><em class="italic"><st c="63162">.19</st></em><st c="63165"> shows the outcome of rendering the </st><code><st c="63201">create_bokeh_line()</st></code><st c="63220"> view function using </st><st c="63241">the datasets:</st></p>
			<div><div><img src="img/B19383_06_019.jpg" alt="Figure 6.19 – A line graph created by Bokeh"/><st c="63254"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="63439">Figure 6.19 – A line graph created by Bokeh</st></p>
			<p><st c="63482">Compared to that </st><a id="_idIndexMarker489"/><st c="63500">of</st><a id="_idIndexMarker490"/><st c="63502"> Plotly and Chart.js, the dashboard of Bokeh is so interactive that you can drag the plot in any direction within the canvas. </st><st c="63628">It offers menu options to save, reset, and wheel- or box-zoom the graph. </st><st c="63701">The only problem with Bokeh is its lack of flexibility when going out of the box for more interactive features. </st><st c="63813">But generally, Bokeh has enough utilities and themes to build powerful </st><st c="63884">embeddable graphs.</st></p>
			<p><st c="63902">From the degree of interactivity of the graphs and charts, let us shift our discussions to building real-time visualization approaches </st><st c="64038">with Flask.</st></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor167"/><st c="64049">Building real-time data plots using WebSocket and SSE</st></h1>
			<p><st c="64103">Flask’s WebSocket</st><a id="_idIndexMarker491"/><st c="64121"> and SSE, discussed</st><a id="_idIndexMarker492"/><st c="64140"> in </st><a href="B19383_05.xhtml#_idTextAnchor111"><em class="italic"><st c="64144">Chapter 5</st></em></a><st c="64153">, are effective mechanisms </st><a id="_idIndexMarker493"/><st c="64180">for implementing real-time</st><a id="_idIndexMarker494"/><st c="64206"> graphical plots. </st><st c="64224">Although other third-party modules can provide Flask with real-time capabilities, these two are still the safest, most flexible, and standard techniques because they are </st><st c="64394">web components.</st></p>
			<p><st c="64409">Let us start with applying WebSocket for </st><st c="64451">real-time charts.</st></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor168"/><st c="64468">Utilizing the WebSocket</st></h2>
			<p><st c="64492">An application </st><a id="_idIndexMarker495"/><st c="64508">can have a WebSocket server that receives data from a form and sends it for plotting to a frontend visualization library. </st><st c="64630">The following </st><code><st c="64644">flask-sock</st></code><st c="64654"> WebSocket server immediately sends all the data it receives from a form page to the Chart.js script for </st><st c="64759">data plotting:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="64773">@sock.route('/ch06/ws/server/hpi/plot')</st></strong><st c="64813">
def ws_server_plot(ws):
    async def process():
        while True:
            </st><strong class="bold"><st c="64871">hpi_data_json = ws.receive()</st></strong><st c="64899">
            hpi_data_dict = loads(hpi_data_json)
            </st><strong class="bold"><st c="64937">json_data = dumps(</st></strong><strong class="bold"><st c="64955">{'period': f"Y{hpi_data_dict['year']}</st></strong> <strong class="bold"><st c="64993">Q{hpi_data_dict['quarter']}"</st></strong><st c="65022">,         </st><strong class="bold"><st c="65024">'hpi': float(hpi_data_dict['hpi'])})</st></strong><strong class="bold"><st c="65060">ws.send(json_data)</st></strong><st c="65079">
    run(process())</st></pre>			<p><st c="65094">The Chart.js script will receive the JSON data as a WebSocket message, scrutinize it, and push it immediately as new labels and dataset values. </st><st c="65239">The following snippet shows the frontend script that manages the WebSocket communication with the </st><code><st c="65337">flask-sock</st></code><st c="65347"> server:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="65355">const socket = new WebSocket('ws://' + location.host +</st></strong> <strong class="bold"><st c="65410">'/ch06/ws/server/hpi/plot');</st></strong><st c="65439">
socket.addEventListener('message', msg =&gt; {
        </st><strong class="bold"><st c="65484">const data = JSON.parse(msg.data);</st></strong><st c="65518">
            if (config.data.labels.length === 20) {
                config.data.labels.shift();
                config.data.datasets[0].data.shift();
            }
            </st><strong class="bold"><st c="65627">config.data.labels.push(data.period);</st></strong><strong class="bold"><st c="65664">config.data.datasets[0].data.push(data.hpi);</st></strong><strong class="bold"><st c="65709">lineChart.update();</st></strong><st c="65729">
      });</st></pre>			<p><st c="65733">The real-time line chart update occurs at every form submission of the new HPI and date values to the</st><a id="_idIndexMarker496"/> <st c="65835">WebSocket server.</st></p>
			<p><st c="65853">Next, let’s see how we can use SSE with Redis as the </st><st c="65907">broker storage.</st></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor169"/><st c="65922">Using SSE</st></h2>
			<p><st c="65932">If WebSocket does</st><a id="_idIndexMarker497"/><st c="65950"> not fit the requirement, SSE can be a possible solution to real-time data plotting. </st><st c="66035">But first, it requires the installation of the Redis database server and the </st><code><st c="66112">redis-py</st></code><st c="66120"> module and the creation of the </st><code><st c="66152">redis-config.py</st></code><st c="66167"> file for the </st><code><st c="66181">Blueprint</st></code><st c="66190"> approach. </st><st c="66201">The following code shows the configuration of the Redis client instance in </st><st c="66276">our application:</st></p>
			<pre class="source-code"><st c="66292">
from redis import Redis
redis_conn = Redis(
    db = 0,
    host='127.0.0.1',
    port=6379,
    decode_responses=True
)</st></pre>			<p><st c="66397">Place this </st><code><st c="66409">redis-config.py</st></code><st c="66424"> file in the project directory </st><st c="66455">with </st><code><st c="66460">main.py</st></code><st c="66467">.</st></p>
			<p><st c="66468">Now, the role of the Redis server is to create a channel where a view function can push the submitted form data containing the data values. </st><st c="66609">The SSE implementation will subscribe to the message channel, listen to incoming messages, retrieve the recently published message, and yield the JSON data to the frontend plotting library. </st><st c="66799">Our application still uses Chart.js for visualization, and here is a snippet that listens to the event stream for</st><a id="_idIndexMarker498"/><st c="66912"> new data plots in </st><st c="66931">JSON format:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="66943">var source = new EventSource("/ch06/sse/hpi/data/stream");</st></strong><st c="67002">
        source.onmessage = function (event) {
            const data = JSON.parse(event.data);
            if (config.data.labels.length === 20) {
                config.data.labels.shift();
                config.data.datasets[0].data.shift();
            }
            </st><strong class="bold"><st c="67186">config.data.labels.push(data.period);</st></strong><strong class="bold"><st c="67223">config.data.datasets[0].data.push(data.hpi);</st></strong><st c="67268">
            lineChart.update();
        };</st></pre>			<p><st c="67291">Like the WebSocket approach, the given frontend script will listen to the stream, receive the JSON data, and validate it before pushing it to the current labels </st><st c="67453">and datasets.</st></p>
			<p><st c="67466">Overall, WebSockets and SSE are not limited to web messaging because they can help establish real-time visualization components for many scientific applications to help solve problems that require </st><st c="67664">impromptu analysis.</st></p>
			<p><st c="67683">Let us now focus on</st><a id="_idIndexMarker499"/><st c="67703"> how Flask can implement computations that consume more server resources and effort and even create higher contention with </st><st c="67826">other components.</st></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor170"/><st c="67843">Using asynchronous background tasks for resource-intensive computations</st></h1>
			<p><st c="67915">There are </st><a id="_idIndexMarker500"/><st c="67926">implementations</st><a id="_idIndexMarker501"/><st c="67941"> of many approximation algorithms and P-complete problems that can create memory-related issues, thread problems, or even memory leaks. </st><st c="68077">To avoid imminent problems when handling solutions for NP-hard problems with indefinite data sets, implement the solutions using asynchronous </st><st c="68219">background tasks.</st></p>
			<p><st c="68236">But first, install the </st><code><st c="68260">celery</st></code><st c="68266"> client using the </st><code><st c="68284">pip</st></code><st c="68287"> command:</st></p>
			<pre class="console"><st c="68296">
pip install celery</st></pre>			<p><st c="68315">Also, install the Redis database server for its broker. </st><st c="68372">Place </st><code><st c="68378">celery_config.py</st></code><st c="68394">, which contains </st><code><st c="68411">celery_init_app()</st></code><st c="68428">, in the project directory and call the method in the </st><code><st c="68482">main.py</st></code><st c="68489"> module.</st></p>
			<p><st c="68497">After the setup and installations, create a service package in the </st><code><st c="68565">Blueprint</st></code><st c="68574"> module folder. </st><code><st c="68590">ch06-project</st></code><st c="68602"> has the following Celery task in the </st><code><st c="68640">hpi_formula.py</st></code><st c="68654"> service module found in the </st><code><st c="68683">internal</st></code> <st c="68691">Blueprint module:</st></p>
			<pre class="source-code"><st c="68709">
@shared_task(ignore_result=False)
def compute_hpi_laspeyre(df_json):
    </st><strong class="bold"><st c="68779">async def compute_hpi_task(df_json):</st></strong><st c="68815">
        try:
            df_dict = loads(df_json)
            df = DataFrame(df_dict)
            df["p1*q0"] = df["p1"] * df["q0"]
            df["p0*q0"] = df["p0"] * df["q0"]
            print(df)
            numer = df["p1*q0"].sum()
            denom = df["p0*q0"].sum()
            hpi = numer/denom
            return hpi
        except Exception as e:
            return 0
    return </st><code><st c="69098">compute_hpi_laspeyre()</st></code><st c="69121"> runs an asynchronous task that computes the HPI value using Laspeyre’s formula with inputs that include the house price for a particular house preference and the number of customers who bought the house for a specific year. </st><st c="69346">The computation will take longer when given a lot of data, so using an asynchronous Celery task to run the formula when the worst-case scenario happens may improve its execution </st><st c="69524">at runtime.</st></p>
			<p><st c="69535">It is always a good practice to run heavy and resource-intensive computations or processes outside the thread of the view function using asynchronous background tasks. </st><st c="69704">It also employs loose coupling between the request-response transactions and the numerical algorithms, which can help avoid the degradation and starvations of </st><st c="69863">these processes.</st></p>
			<p><st c="69879">Integrating </st><a id="_idIndexMarker502"/><st c="69892">popular </st><a id="_idIndexMarker503"/><st c="69900">numerical and symbolic software into the Flask platform can sometimes save migration time when dealing with existing scientific projects. </st><st c="70038">Let us now explore the capability of Flask to integrate with the </st><st c="70103">Julia language.</st></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor171"/><st c="70118">Incorporating Julia packages with Flask</st></h1>
			<p><strong class="bold"><st c="70158">Julia</st></strong><st c="70164"> is a high-powered </st><a id="_idIndexMarker504"/><st c="70183">compiled programming</st><a id="_idIndexMarker505"/><st c="70203"> language that provides mathematical and symbolic libraries. </st><st c="70264">It contains simple syntax for numerical computing and provides better runtime performance for executing </st><st c="70368">its applications.</st></p>
			<p><st c="70385">Although Julia has web frameworks such as Genie, Oxygen, and Bukdu, which can implement Julia-based web applications, it is also possible that Flask applications can run and extract values from </st><st c="70580">Julia functions.</st></p>
			<p><st c="70596">But first, download the latest Julia compiler from </st><a href="https://julialang.org/downloads/"><st c="70648">https://julialang.org/downloads/</st></a><st c="70680"> and install it on your system. </st><st c="70712">Installing an old Julia version into an updated Windows OS will result in a system crash, as indicated in </st><em class="italic"><st c="70818">Figure 6</st></em><em class="italic"><st c="70826">.20</st></em><st c="70829">.</st></p>
			<div><div><img src="img/B19383_06_020.jpg" alt="Figure 6.20 – System crashes due to Flask running outdated Julia"/><st c="70830"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="71132">Figure 6.20 – System crashes due to Flask running outdated Julia</st></p>
			<p><st c="71196">Let’s now take </st><a id="_idIndexMarker506"/><st c="71212">a </st><a id="_idIndexMarker507"/><st c="71214">look at the steps involved in creating and integrating the Julia package into a </st><st c="71294">Flask application.</st></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor172"/><st c="71312">Creating a custom Julia package</st></h2>
			<p><st c="71344">After the installation, go</st><a id="_idIndexMarker508"/><st c="71371"> to the project directory of the Flask app through the console and open a Julia shell by running the </st><code><st c="71472">julia</st></code><st c="71477"> command. </st><st c="71487">Then, follow </st><st c="71500">these instructions:</st></p>
			<ol>
				<li><st c="71519">Run the command using </st><code><st c="71542">Pkg</st></code><st c="71545"> on </st><st c="71549">the shell.</st></li>
				<li><st c="71559">Create a </st><code><st c="71569">Julia</st></code><st c="71574"> package in the Flask app directory by running the </st><st c="71625">following command:</st><pre class="source-code"><st c="71643">
Pkg.generate("Ch06JuliaPkg")</st></pre></li>				<li><st c="71672">Install the </st><code><st c="71685">PythonCall</st></code><st c="71695"> plugin by running the </st><st c="71718">following command:</st><pre class="source-code"><st c="71736">
Pkg.add("PythonCall")</st></pre></li>				<li><st c="71758">Also, install Julia packages such as </st><code><st c="71796">DataFrame</st></code><st c="71805">, </st><code><st c="71807">Pandas</st></code><st c="71813">, and </st><code><st c="71819">Statistics</st></code><st c="71829"> for converting and running Python syntax in the </st><st c="71878">Julia environment.</st></li>
				<li><st c="71896">Finally, run </st><code><st c="71910">Pkg.resolve()</st></code><st c="71923"> and </st><code><st c="71928">Pkg.instantiate()</st></code><st c="71945"> to finalize </st><st c="71958">the setup.</st></li>
			</ol>
			<p><st c="71968">Next, we’ll install the </st><code><st c="71993">juliacall</st></code><st c="72002"> client module and add the Julia-related configuration details to the </st><strong class="bold"><st c="72072">TOML</st></strong><st c="72076"> file.</st></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor173"/><st c="72082">Configuring Julia accessibility in a Flask project</st></h2>
			<p><st c="72133">After creating a </st><a id="_idIndexMarker509"/><st c="72151">Julia custom package</st><a id="_idIndexMarker510"/><st c="72171"> inside the Flask app, open the app’s </st><code><st c="72209">config_dev.toml</st></code><st c="72224"> file and add the following environment variables to integrate Julia into the </st><st c="72302">Flask platform:</st></p>
			<ul>
				<li><code><st c="72317">PYTHON_JULIAPKG_EXE</st></code><st c="72337">: The path to the </st><code><st c="72356">julia.exe</st></code><st c="72365"> file, including the filename (</st><st c="72396">e.g., </st><code><st c="72403">C:/Alibata/Development/Language/Julia-1.9.2/bin/julia</st></code><st c="72456">).</st></li>
				<li><code><st c="72459">PYTHON_JULIAPKG_OFFLINE</st></code><st c="72483">: Set to </st><code><st c="72493">yes</st></code><st c="72496"> to stop any Julia installation in </st><st c="72531">the background.</st></li>
				<li><code><st c="72546">PYTHON_JULIAPKG_PROJECT</st></code><st c="72570">: The path to the newly created custom Julia package inside the Flask app (</st><st c="72646">e.g., </st><code><st c="72653">C:/Alibata/Training/Source/flask/mastering/ch06-web-final/Ch06JuliaPkg/</st></code><st c="72724">).</st></li>
				<li><code><st c="72727">JULIA_PYTHONCALL_EXE</st></code><st c="72748">: The path to the Python compiler of the virtual environment, including the filename (</st><st c="72835">e.g., </st><code><st c="72842">C:/Alibata/Training/Source/flask/mastering/ch06-web-env/Scripts/python</st></code><st c="72912">).</st></li>
			</ul>
			<p><st c="72915">Afterward, install the </st><code><st c="72939">juliacall</st></code><st c="72948"> module through the </st><code><st c="72968">pip</st></code><st c="72971"> command:</st></p>
			<pre class="console"><st c="72980">
pip install juliacall</st></pre>			<p><st c="73002">After the Flask setup, let us now create the Julia code inside the </st><st c="73070">Julia package.</st></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor174"/><st c="73084">Implementing Julia functions in the package</st></h2>
			<p><st c="73128">After the Python</st><a id="_idIndexMarker511"/><st c="73145"> configuration, open </st><code><st c="73166">ch06-web-final\Ch06JuliaPkg\src\Ch06JuliaPkg.jl</st></code><st c="73213"> and create some Julia functions with the imported </st><code><st c="73264">PythonCall</st></code><st c="73274"> package, like in the </st><st c="73296">following snippet:</st></p>
			<pre class="source-code"><st c="73314">
module Ch06JuliaPkg
</st><strong class="bold"><st c="73335">using PythonCall</st></strong>
<strong class="bold"><st c="73351">const re = PythonCall.pynew()</st></strong><st c="73381"> # import re
</st><strong class="bold"><st c="73394">const np = PythonCall.pynew()</st></strong><st c="73423"> # import numpy
function __init__()
    </st><strong class="bold"><st c="73459">PythonCall.pycopy!(re, pyimport("re"))</st></strong><strong class="bold"><st c="73497">PythonCall.pycopy!(re, pyimport("numpy"))</st></strong><st c="73539">
end
</st><strong class="bold"><st c="73544">function sum_array(data_list)</st></strong><strong class="bold"><st c="73573">total = 0</st></strong><strong class="bold"><st c="73583">for n in eachindex(data_list)</st></strong><strong class="bold"><st c="73613">total = total + data_list[n]</st></strong><strong class="bold"><st c="73642">end</st></strong><strong class="bold"><st c="73646">return total</st></strong><st c="73659">
end
export sum_array
end # module Ch06JuliaPkg</st></pre>			<p><st c="73706">All syntax inside the Julia package must be valid Julia syntax. </st><st c="73771">Thus, the given </st><code><st c="73787">sum_array()</st></code><st c="73798"> is a Julia package. </st><st c="73819">On the other hand, importing Python modules requires the </st><a id="_idIndexMarker512"/><st c="73876">instantiation of </st><code><st c="73893">PythonCall</st></code><st c="73903"> through </st><code><st c="73912">pynew()</st></code><st c="73919">, and the actual module mapping happens in its </st><code><st c="73966">__init__()</st></code><st c="73976"> initialization method </st><st c="73999">through </st><code><st c="74007">pycopy()</st></code><st c="74015">.</st></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor175"/><st c="74016">Creating the Julia service module</st></h2>
			<p><st c="74050">To access the</st><a id="_idIndexMarker513"/><st c="74064"> functions in the custom Julia package, such as </st><code><st c="74112">Ch06JuliaPkg</st></code><st c="74124">, create a service module that will activate </st><code><st c="74169">Ch06JuliaPkg</st></code><st c="74181"> and create a Julia module that will execute the Julia commands in Flask in that particular </st><code><st c="74273">Blueprint</st></code><st c="74282"> section. </st><st c="74292">The following is the </st><code><st c="74313">\modules\external\services\julia_transactions.py</st></code><st c="74361"> service module from the external </st><code><st c="74395">Blueprint</st></code><st c="74404"> with the needed </st><code><st c="74421">juliacall</st></code><st c="74430"> executions:</st></p>
			<pre class="source-code"><st c="74442">
import juliacall
from juliacall import Pkg as jlPkg
jlPkg.activate(".\\Ch06JuliaPkg")
jl = juliacall.newmodule("modules.external.services")
jl.seval("using Pkg")
jl.seval("Pkg.instantiate()")
jl.seval("using Ch06JuliaPkg")
jl.seval("using DataFrames")
jl.seval("using PythonCall")</st></pre>			<p><st c="74723">At every startup </st><a id="_idIndexMarker514"/><st c="74741">of the Flask server, the application always activates the Julia package because the application always loads all the services of the blueprints. </st><em class="italic"><st c="74886">Figure 6</st></em><em class="italic"><st c="74894">.21</st></em><st c="74897"> shows the activation process on the server log of the </st><st c="74952">Flask app:</st></p>
			<div><div><img src="img/B19383_06_021.jpg" alt="Figure 6.21 – Julia package activation log during server startup"/><st c="74962"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="75365">Figure 6.21 – Julia package activation log during server startup</st></p>
			<p><st c="75429">The activation may cause degradation to the startup time of the server, which is a disadvantage for Flask. </st><st c="75537">If this performance glitch worsens, it will be advisable to migrate all implementation to popular Julia web frameworks, such as Oxygen, Genie, and Bukduh, instead of pursuing further the </st><st c="75724">Flask integration.</st></p>
			<p><st c="75742">Now, for the view functions to access Julia functions, add service methods in the </st><code><st c="75825">Blueprint</st></code><st c="75834"> service where the activation happens. </st><st c="75873">In our project, the </st><code><st c="75893">modules\external\services\julia_transactions.py</st></code><st c="75940"> service module implements the following </st><code><st c="75981">total_array()</st></code><st c="75994"> service to expose the </st><code><st c="76017">sum_array()</st></code><st c="76028"> function </st><st c="76038">in </st><code><st c="76041">Ch06JuliaPkg</st></code><st c="76053">:</st></p>
			<pre class="source-code"><st c="76055">
async def total_array(arrdata):
    </st><strong class="bold"><st c="76088">result = jl.seval(f"sum_array({arrdata})")</st></strong><st c="76130">
    return result</st></pre>			<p><st c="76144">The Julia module or </st><code><st c="76165">jl</st></code><st c="76167">, using its </st><code><st c="76179">seval()</st></code><st c="76186"> method, is the one that accesses and executes custom or built-in Julia functions in the Flask service. </st><st c="76290">Given that the applications followed all installations and setups given correctly, running </st><code><st c="76381">jl.seval()</st></code><st c="76391"> must not cause any system crash or </st><code><st c="76427">HTTP Status 500</st></code><st c="76442">. Again, the Python service functions that </st><a id="_idIndexMarker515"/><st c="76485">execute </st><code><st c="76493">jl.seval()</st></code><st c="76503"> must be placed in the service module where the Julia package </st><st c="76565">activation happened.</st></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor176"/><st c="76585">Summary</st></h1>
			<p><st c="76593">Flask 3.0 is the best-fit version of Flask that can build scientific applications because of its asynchronous features and asyncio support. </st><st c="76734">The asynchronous WebSocket, SSE, Celery background tasks, and services, together with the mathematical and computational modules, such as </st><code><st c="76872">numpy</st></code><st c="76877">, </st><code><st c="76879">matplotlib</st></code><st c="76889">, </st><code><st c="76891">sympy</st></code><st c="76896">, </st><code><st c="76898">pandas</st></code><st c="76904">, </st><code><st c="76906">scipy</st></code><st c="76911">, and </st><code><st c="76917">seaborn</st></code><st c="76924">, are the core ingredients in building applications that highlight visualizations, computations, and </st><st c="77025">statistical analysis.</st></p>
			<p><st c="77046">Proven by this chapter, Flask supports LaTeX document generation, updating, and rendition, including its PDF transformation. </st><st c="77172">This feature is crucial in most scientific computing that requires archiving, reporting, and </st><st c="77265">records management.</st></p>
			<p><st c="77284">Flask support on visualization is also clear cut in this chapter, from the real-time data plotting down to the native plots of the </st><code><st c="77416">matplotlib</st></code><st c="77426"> module. </st><st c="77435">Flask can utilize JS-based libraries for data plotting of </st><code><st c="77493">DataFrame</st></code><st c="77502"> object’s tabular values seamlessly and in a </st><st c="77547">straightforward manner.</st></p>
			<p><st c="77570">Although not yet stable, the integration of Julia with Flask shows how the interoperability property works with Flask. </st><st c="77690">Using </st><code><st c="77696">PythonCall</st></code><st c="77706"> and </st><code><st c="77711">JuliaCall</st></code><st c="77720"> modules, it is now possible to run existing Julia functions in Flask as long as the setup and configuration </st><st c="77829">are correct.</st></p>
			<p><st c="77841">In conclusion, Flask, particularly the asynchronous version of Flask , is the best option for building web-based scientific applications. </st><st c="77980">The next chapter will discuss how Flask utilizes NoSQL databases and addresses some big </st><st c="78068">data requirements.</st></p>
		</div>
	<div></body></html>