- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built a backend that connects to the database, manages
    user sessions, and sends emails. Now, we will add a specific API to the backend
    that tracks the member’s to-do’s. This will require an API that allows members,
    sessions, and to-dos to be managed.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to build a **RESTful API**, which is a very
    popular style of API and one you’ll likely use and come across in your career.
    You’ll also build an API to manage members and authenticate their actions, which
    could be used in any other app with minimal changes. Finally, we will also build
    an API to track the to-dos, which, again, could be adapted for other uses.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build the API using a RESTful style as it works very well with web apps
    and can be expressed very easily with Quart. A RESTful API is where the functionality
    is grouped by resource with each function being an action acting on the resource.
    For example, the functionality to log in is described as creating a session and
    log out as deleting a session. For a RESTful web app, the action is represented
    by the HTTP verb and the resource by the HTTP path. In addition, the response
    status code is used to indicate the effect of the functionality, with 2XX codes
    indicating success and 4XX codes indicating different types of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to RESTful APIs
  prefs: []
  type: TYPE_NORMAL
- en: While RESTful APIs utilize many HTTP verbs and paths to describe the functionality,
    a more basic style is to have a singular `POST` route. This route is then used
    for all the functionality with the request body describing the function and data.
    A good example is GraphQL, which typically uses only `POST /graphql` with a defined
    message structure. If you’d prefer to use GraphQL take a look at [https://strawberry.rocks](https://strawberry.rocks).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database schema and models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the session API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the member API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the to-do API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following additional folders are required in this chapter and should be
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Empty *backend/src/backend/models/__init__.py* and *backend/tests/models/__init__.py*
    files should also be created.
  prefs: []
  type: TYPE_NORMAL
- en: To follow the development in this chapter, use the companion repository, [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo),
    and see the commits between the tags `r1-ch3-start` and `r1-ch3-end`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database schema and models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we are building a to-do tracking app, which means we need to store
    data about the member and their to-dos. We will do so by placing the data into
    the database, which means we need to define the structure of the data. This structure
    is called the schema and describes the tables in the database.
  prefs: []
  type: TYPE_NORMAL
- en: While the `id` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: ORMs
  prefs: []
  type: TYPE_NORMAL
- en: Schemas and models are often conflated as the same thing, especially when an
    **Object Relational Model** (**ORM**) is used. While using an ORM is simpler to
    begin with, I find it hides important details and makes development harder after
    a short while. This is why, in this book, the model and schema are related but
    different. This also means that we’ll write SQL queries for all interactions with
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by defining the member data and to-do data as both models and schemas
    in a migration, before adding some initial test and development data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the member schema and model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to store information for each member so that we can associate their
    to-dos with them, via a foreign key reference. In addition, we need to store enough
    information so that the member can log in and prove who they are (authenticate
    themselves), which means we need to store their email and password hash. Finally,
    we’ll also store when their account was created and when they verified their email
    – the latter being important if we want to send them emails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema for this data is given by the following SQL, which is given for
    reference and will be used in the *Running the first migration* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The unique index highlighted ensures that there is only one member account per
    email, with email casing being ignored.
  prefs: []
  type: TYPE_NORMAL
- en: SQL formatting
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18727_01.xhtml#_idTextAnchor015) *Setting Up Our System for
    Development*, I mentioned the importance of code formatting and autoformatters.
    Sadly, I haven’t found an autoformatter that works for SQL embedded in Python
    code. However, I recommend you follow the style guide given at [http://sqlstyle.guide/](http://sqlstyle.guide/)
    as I will in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can represent the database table with a Python `dataclass`, which includes
    each column as an attribute with the relevant Python type. This is the model shown
    in the following code, which should be added to *backend/src/backend/models/member.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the model, we can add the following functions to *backend/src/backend/models/member.py*
    in order to convert between the backend model and the SQL that reads from the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These functions allow member information to be read from the database. The highlighted
    line ensures that emails are considered a match if the lowercased email matches.
  prefs: []
  type: TYPE_NORMAL
- en: Email case sensitivity
  prefs: []
  type: TYPE_NORMAL
- en: In our app, we store the email in the case given by the user, while comparing
    lowercased emails. This is the most user-friendly and secure solution, as emails
    can have a case-sensitive local part (before the `@`) but rarely do and must be
    case insensitive for the domain part (after the `@`). Therefore, by storing the
    given casing we ensure the email is delivered while ensuring there is one account
    per email address. More information is available at [https://stackoverflow.com/questions/9807909/are-email-addresses-case-sensitive](https://stackoverflow.com/questions/9807909/are-email-addresses-case-sensitive).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add functions that can alter the data in the database by adding
    the following to *backend/src/models/member.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These functions match the functionality we’ll shortly add to the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The case sensitivity is something we should test, by adding the following to
    *backend/tests/models/test_member.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we want a test to ensure that `insert_member` correctly rejects a second
    member with an email that differs only by casing. The highlighted line ensures
    that the lines within, when executed, raise a `UniqueViolationError` and hence
    prevents the member from being inserted again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to test that the `select_member_by_email` function compares case
    insensitively by adding the following to *backend/tests/models/test_member.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the model code set up this way, we’ll be able to use these functions and
    the class instance directly wherever required in the backend code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the to-do schema and model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We also want to store information for each to-do, specifically the to-do task
    as text, when the to-do is due to be completed (although this should be optional),
    and if the to-do is complete. In addition, every to-do should be linked to the
    member that owns it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema for this data is given by the following SQL, which is given for
    reference and will be used in the *Running the first migration* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding backend model for this table is given by the following code,
    which should be added to *backend/src/backend/models/todo.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `constr` is used in place of `str` in order to ensure that empty strings
    are not considered valid. In addition to the model, we can add the following functions
    to *backend/src/backend/models/todo.py* in order to convert between the backend
    model and the SQL that reads from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These functions allow to-dos to be read from the database, but will only return
    to-dos that are owned by the given `member_id`. Using these functions should ensure
    that we don’t return to-dos to the wrong members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add functions that can alter the data in the database by adding
    the following to *backend/src/models/todo.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that all these functions also take a `member_id` argument and only affect
    the to-dos that belong to the given `member_id`. This will help us avoid authorization
    errors whereby we write code that mistakenly allows a member to access or modify
    another member’s to-do.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is something we should test, by adding the following to *backend/tests/models/test_todo.py*.
    Firstly, we want a test to ensure that `delete_todo` correctly deletes the to-do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted parametrization provides two tests. The first test ensures that
    `member_id 1` can delete their to-do, and the second test ensures that `member_id
    2` cannot delete another user’s to-do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also add a similar test to ensure that the update works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The parametrization provides two tests. The first test ensures that the member
    with `member_id 1` can update their to-do, and the second test ensures that the
    member with `member_id 2` cannot update another user’s to-do.
  prefs: []
  type: TYPE_NORMAL
- en: While we have these important tests in place, we can’t run them until we create
    the database tables via a migration.
  prefs: []
  type: TYPE_NORMAL
- en: Running the first migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While we’ve written the SQL queries required to create the database schema,
    they haven’t run against the database. To run these, Quart-DB provides a migration
    system, whereby we can run queries as the backend starts, but only if they haven’t
    already run. To make use of this, we can add the following code to *backend/src/backend/migrations/0.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To see this migration take effect, you can run `pdm run recreate-db` and then
    start the backend (as the migration will run as the backend starts up). You can
    then use `psql –U tozo` to inspect the database and see the two new tables as
    shown in *Figure 3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: The database schema after the migration.  ](img/B18727_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The database schema after the migration.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a one-to-many relationship between the `members` and `todos` tables
    such that one member has many to-dos. Also note the `schema_migration` table is
    created and managed by Quart-DB to track migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding test and development data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is helpful to have some standardized initial data in the database when developing
    and running tests; for example, we can add a standard member with known credentials
    to log in, rather than have to create a new member every time the database is
    recreated. To do this, we can utilize the data path feature in Quart-DB.
  prefs: []
  type: TYPE_NORMAL
- en: 'For ease of use, we’ll add a single member to the database by adding the following
    to *backend/src/backend/migrations/data.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The password hash value corresponds to a value of `password`, which means the
    login will be with the email, password combination of `member@tozo.dev`, `password`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To instruct Quart-DB to load and run this file, we need to add the following
    configuration variable to *backend/development.env* and *backend/testing.env*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the tests and check that they pass by running the following
    in the *backend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ve defined the data stored by the backend, we can focus on the API, starting
    with session management.
  prefs: []
  type: TYPE_NORMAL
- en: Building the session API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To manage user sessions, we need a **session** (authentication) API that provides
    routes to log in and log out (i.e., to create and delete sessions). Login should
    result in a cookie being set, and logout results in the cookie being deleted.
    As per the authentication setup, login should require an email and matching password.
    We’ll add this API via a sessions blueprint containing login, logout, and status
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A blueprint is a collection of route handlers and is useful to associate the
    related session functionality. It can be created with the following code in *backend/src/backend/blueprints/sessions.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The blueprint then needs to be registered with the app, by adding the following
    to *backend/src/backend/run.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With the blueprint created, we can now add specific functionality as routes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding login functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The login functionality is described in a RESTful style as creating a session,
    and hence the route should be `POST,` expecting an email, a password, and a remember
    flag returning `200` on success and `401` on invalid credentials. This is done
    via the following, which should be added to *backend/src/backend/blueprints/sessions.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This route is rate limited to a lower limit than others (five requests a minute)
    to prevent malicious actors from brute forcing the login. This is where the malicious
    actor keeps trying different passwords in the hope that one will eventually be
    correct and allow login.
  prefs: []
  type: TYPE_NORMAL
- en: The route also validates the request data has the correct `LoginData` structure,
    which ensures that users correctly use this route, and prevents invalid data from
    causing errors in the route handler code.
  prefs: []
  type: TYPE_NORMAL
- en: The route itself tries to fetch the member’s details from the database given
    the email provided in the request data. If there is no data, a `401` response
    is returned. The password provided in the request data is then checked against
    the password hash in the database, with a match resulting in the member being
    logged in with a `200` response. If the passwords don’t match, a `401` response
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Trailing slashes
  prefs: []
  type: TYPE_NORMAL
- en: For this route, and for all others in the app, I’ve added a trailing slash so
    that the path is `/sessions/` rather than `/sessions`. This is a useful convention
    to follow as requests to `/sessions` will be automatically redirected to `/sessions/`
    and hence work despite the missing slash, whereas requests to `/sessions/` would
    not be redirected to `/session` if the route was defined without the trailing
    slash.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in results in a cookie being stored in the member’s browser, which is
    then sent in every subsequent request. The presence and value of this cookie are
    used to determine whether the member is logged in, and which member made the request.
  prefs: []
  type: TYPE_NORMAL
- en: Account enumeration
  prefs: []
  type: TYPE_NORMAL
- en: This implementation will allow an attacker to enumerate emails present in the
    database, which can be considered a security issue. See [*Chapter 7*](B18727_07.xhtml#_idTextAnchor180)*,
    Securing and Packaging the App*, for how to mitigate against this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding logout functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A logout route is described as a session deletion in a RESTful style, therefore
    the route should be `DELETE`, returning `200`. The following should be added to
    *backend/src/backend/blueprints/sessions.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This route is rate exempt as nothing should prevent a member from logging out
    – it is important that the logout function works so that members are logged out
    when they want to be. The route then only needs to call `logout_user`, which results
    in the cookie being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotent routes
  prefs: []
  type: TYPE_NORMAL
- en: Idempotence is a property of a route where the final state is achieved no matter
    how many times the route is called, that is, calling the route once or 10 times
    has the same effect. This is a useful property as it means the route can be safely
    retried if the request fails. For RESTful and HTTP APIs, the routes using `GET`,
    `PUT`, and `DELETE` verbs are expected to be idempotent. In this book, the routes
    using the `GET`, `PUT`, and `DELETE` verbs are idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: Adding status functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is useful to have a route that returns the current session (status) as we’ll
    use it for debugging and testing. For a RESTful API, this should be a `GET` route,
    and the following should be added to *backend/src/backend/blueprints/sessions.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted assertion is used to inform the type checker that `current_user.auth_id`
    cannot be `None` in this function, and hence prevents the type checker from considering
    the subsequent line as an error. The `# nosec` comment informs the bandit security
    checker that this use of `assert` is not a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: The route is rate limited for protection and will only run if the request has
    the correct cookie present from login. The route returns the member’s ID based
    on the value in the cookie as this is also very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should test that these routes work as a user would expect, starting by testing
    that a user can log in, get their status, and then log out as a complete flow.
    This is tested by adding the following to *backend/tests/blueprints/test_sessions.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This test ensures that a member can log in and then access routes that require
    them to be logged in. It then logs the member out and checks that they can no
    longer access the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also test that the login route returns the correct response if the
    wrong credentials are provided by adding the following test to *backend/tests/blueprints/test_sessions.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to allow members to log in and log out. Next, we can focus
    on managing members.
  prefs: []
  type: TYPE_NORMAL
- en: Building the member API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To manage members, we need an API that provides routes to create a member (register),
    confirm the email address, change the password, request a password reset, and
    reset a password.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add this API via a blueprint for the member, containing registration,
    email confirmation, changing password, and password reset functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the members blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, we should create a blueprint for all the member routes, it is created
    with the following code in *backend/src/backend/blueprints/members.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The blueprint then needs to be registered with the app, by adding the following
    to *backend/src/backend/run.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With the blueprint created, we can now add the specific functionality as routes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a member
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our app, we want users to be able to register as members. This requires a
    route that accepts an email and a password. The route should then check the password
    is sufficiently complex, create a new member, and send a welcome email. As the
    route creates a member, it should use the `POST` method to be in the RESTful style.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add a link to the welcome email that the recipient of the email can visit
    to prove they registered with our app. This way, we have verified that the email
    address owner is the same user that registered. The link will work by including
    an authentication token in the path, with the token working as explained in [*Chapter
    2*](B18727_02.xhtml#_idTextAnchor053), *Creating a Reusable Backend with Quart*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by first creating an email template by adding the following
    to *backend/src/backend/templates/welcome.xhtml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The route itself should return `201` on success, as this status code indicates
    a successful creation. This is all achieved by adding the following to *backend/src/backend/blueprints/members.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, the password strength is first checked, using `zxcvbn`, with
    weak passwords resulting in a `400` response. The password is then hashed and
    used with the email to insert a member. The new member’s ID is then used to create
    an email verification token, which is rendered into the email body before being
    sent to the given email address.
  prefs: []
  type: TYPE_NORMAL
- en: When the user follows the link, they will return to our app with the token for
    the email confirmation route to check.
  prefs: []
  type: TYPE_NORMAL
- en: Confirming the email address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a user registers as a member, they are sent a link back to our app that
    includes an email verification token. The token identifies the member and hence
    confirms that the email address is correct. Therefore, we need a route that accepts
    the token and, if valid, confirms the email address. This updates the member’s
    email property in a RESTful sense and hence is achieved by adding the following
    to *backend/src/backend/blueprints/members.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The token is checked via the `loads` method, and if it is expired a `403` response
    is returned, whereas if it is invalid a `400` response is returned. If the token
    is good, the member’s email is marked as verified in the database and a `200`
    response is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Once a user has registered, and hopefully verified their email, they will want
    to be able to change their password.
  prefs: []
  type: TYPE_NORMAL
- en: Changing passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A user will want to change their password, which requires a route that accepts
    their new password and their old password. The old password is checked to make
    the member’s account more secure, as a malicious user gaining access via an unattended
    computer cannot change the member’s password (without also knowing the member’s
    password). The route will also need to check that the new password has sufficient
    complexity as with the registration route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The route should also inform the user that the password has been changed by
    email. Doing so makes the member’s account more secure as the member can take
    corrective action if they are informed about a password change that they didn’t
    authorize. This email is defined by adding the following to *backend/src/backend/templates/password_changed.xhtml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This route will update the password, which in a RESTful style means a `PUT`
    route on the member’s password resource that returns `200` on success. It should
    return a `400` response if the password is not complex enough and a `401` response
    if the old password is incorrect. The following should be added to *backend/src/backend/blueprints/members.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As with the login route, this route has a lower rate limit to mitigate against
    brute force attacks. The code then checks the password strength before checking
    that the old password matches the hash stored in the database. If these checks
    pass, the password hash in the database is updated and an email is sent to the
    member.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is intentionally not useful for member’s that have forgotten
    their password. In that case, they first need to request a password reset.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting a password reset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a member forgets their password, they’ll want a way to reset it. This is
    typically provided by emailing the member a link that they can follow to a password
    reset page with the link containing a token to authorize the reset – as with the
    email verification. For this to work, we first need a route that accepts the user’s
    email address and sends out the link. To start, let’s add the following email
    content to *backend/src/backend/templates/forgotten_password.xhtml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The route itself should accept an email address, and in the RESTful style should
    be a `PUT` to the member email resource. The following should be added to *backend/src/backend/blueprints/members.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This route creates a token using the forgotten-password salt. It is important
    that the salt differs to ensure that these tokens cannot be used in place of the
    email verification token and vice versa. The token is then rendered into the email
    and sent to the member.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the password
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the member follows the link emailed out by the previous route, they will
    visit a page that allows them to enter a new password. Therefore, we need a route
    that accepts the new password and the token. This is achieved by adding the following
    to *backend/src/backend/blueprints/members.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This route checks whether the token is valid, returning either a `400` if it
    is not or a `403` if it has expired. The expiry is important as it protects against
    a member’s email being exposed in the future (as the token will have expired and
    hence is useless). Then, if the password is strong enough, the new hash is placed
    into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Managing members
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added functionality to create members and manage members’ passwords. However,
    we haven’t added functionality to manage a member’s account itself, for example,
    to close and delete it. This functionality will be dependent on the regulatory
    rules of your app as, for example, you may be required to keep data for a certain
    length of time.
  prefs: []
  type: TYPE_NORMAL
- en: With this route, we have all the functionality we require for member accounts
    and can now focus on testing the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should test that these routes work as a user would expect. Firstly, let’s
    test that new members can register and then log in by adding the following to
    *backend/tests/blueprints/test_members.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This test registers a new member with the email `new@tozo.dev` and then checks
    that the welcome email was sent to this address. Next, we need to check that the
    user can confirm their email address by adding the following to *backend/tests/blueprints/test_members.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line allows us to ensure that expired tokens result in a `403`
    response while current tokens succeed. The second test ensures that invalid tokens
    result in a `400` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will test that members can change their password by adding the following
    to *backend/tests/blueprints/test_members.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This test registers a new member and then, while authenticated as that member,
    changes the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can test that a user that has forgotten their password can request
    a reset link by adding the following to *backend/tests/blueprints/test_members.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now we have these simple tests in place, we can focus on the To-Do API.
  prefs: []
  type: TYPE_NORMAL
- en: Building the To-Do API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To manage to-dos, we need an API that provides functionality to create a new
    to-do, retrieve a to-do or to-dos, update a to-do, and delete a to-do (i.e., an
    API that has CRUD functionality). We’ll do this by creating a to-do blueprint
    with a route per CRUD function.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD functionality
  prefs: []
  type: TYPE_NORMAL
- en: '`Create`, `Read`, `Update`, and `Delete`, and is used to describe a set of
    functionalities. It is often used to describe the functionality of RESTful APIs.
    Typically, for a RESTFul API, the Create route uses the `POST` HTTP method, Read
    uses `GET,` Update uses `PUT`, and Delete uses `DELETE`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The blueprint itself can be created with the following code in *backend/src/backend/blueprints/todos.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The blueprint then needs to be registered with the app, by adding the following
    to *backend/src/backend/run.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: With the blueprint created, we can now add specific functionality as routes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a to-do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first functionality we need is to create a to-do. The route should expect
    the to-do data and return the complete to-do with a `201` status code on success.
    Returning the complete to-do is useful as it contains the to-do’s ID and confirms
    that the data is added. A RESTful to-do creation route should use the POST verb
    and have a `/todos/` path. The following should be added to *backend/src/backend/blueprints/todos.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The route is rate limited to prevent malicious usage, with the assumption that
    normal users are unlikely to create more than 10 to-dos in 10 seconds (1 a second
    on average). It is also a route that requires the user to be logged in. The final
    two decorators ensure that the request and response data represent the to-do data
    and a complete to-do.
  prefs: []
  type: TYPE_NORMAL
- en: The route function simply inserts the data into the database and returns the
    complete to-do. Next, users will need to read a to-do from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a to-do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Users will need to read a to-do based on its ID. This will be implemented as
    a `GET` route with the ID specified in the path. The route should then either
    return the to-do or a `404` response if the to-do does not exist. The following
    should be added to *backend/src/backend/blueprints/todos.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As with the creation route, this route includes rate limiting protection, requires
    the user to be logged in, and validates the response data. It then selects the
    to-do from the database based on the ID given in the path and returns it or a
    `404` response if no to-do exists. Note that the `select_todo` function requires
    the member’s ID, ensuring that members cannot read other members’ to-dos.
  prefs: []
  type: TYPE_NORMAL
- en: While reading a single to-do is useful, a user will also need to read all their
    to-dos in one call, which we’ll add next.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the to-dos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A user will need to read all their to-dos, which for a RESTFul API should use
    the `GET` verb and return a list of to-dos on success. We’ll also allow the user
    to filter the to-dos based on the `complete` attribute, which should be optional
    and hence, in a RESTful API, is provided via a `querystring`. The `querystring`
    works via the request path, for example, `/todos/?complete=true` or `/todos/?complete=false`.
    The following should be added to *backend/src/backend/blueprints/todos.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This route includes rate limit protection, requires logged-in usage, validates
    the response data, and includes validation of the `querystring` parameters. We
    can now move on to allowing updates to a to-do.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a to-do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to provide functionality for members to update the data that makes
    up a to-do. For a RESTFul API, this route should use the `PUT` verb, expect the
    to-do data, and return the complete to-do on success or a `404` if the to-do does
    not exist. The following should be added to *backend/src/backend/blueprints/todos.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This route includes rate limit protection, requires logged-in usage, and validates
    the request and response data. It then updates the to-do and returns the updated
    to-do or a `404` response if there is no to-do for the provided ID. Next, we’ll
    allow users to delete to-dos.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a to-do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a RESTFul API, the to-do deletion route should use the `DELETE` verb, and
    return `202` whether the to-do exists or not. The following should be added to
    *backend/src/backend/blueprints/todos.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This route includes rate limit protection, requires logged-in usage, and deletes
    the to-do with the given ID as long as it belongs to the logged-in member.
  prefs: []
  type: TYPE_NORMAL
- en: With all the functionality for to-dos in place, we can now focus on testing
    that it works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should test that these routes work as a user would expect. Firstly, we need
    to ensure we can create new to-dos by adding the following to *backend/tests/blueprints/test_todos.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can ensure we can read to-dos by adding the following to *backend/tests/blueprints/test_todos.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing along the CRUD functionality, we can ensure that to-dos can be updated
    by adding the following to *backend/tests/blueprints/test_todos.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can ensure that to-dos can be deleted by adding the following to
    *backend/tests/blueprints/test_todos.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: With these tests, we have all the functionality we need to manage to-dos.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve defined how we are storing the data in the database and
    then built an API to manage sessions, members, and to-dos. This includes all the
    functionality our app will need via an easy-to-understand RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: While the to-do functionality is unlikely to be directly useful to your app,
    the CRUD functionality is a pattern you should use. In addition, the member and
    session APIs could be used directly in your app. Finally, you’ve hopefully gained
    an understanding of what makes a good RESTful API that you can apply and use elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll create a styled frontend, including validated data
    entry in React, that we can use with this API or any other.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve built a fairly simple RESTful API in this chapter. As your API’s complexity
    increases, I’d recommend following the best practices at [https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api](https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api).
  prefs: []
  type: TYPE_NORMAL
