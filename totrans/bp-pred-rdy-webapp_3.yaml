- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building the API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建API
- en: In the previous chapter, we built a backend that connects to the database, manages
    user sessions, and sends emails. Now, we will add a specific API to the backend
    that tracks the member’s to-do’s. This will require an API that allows members,
    sessions, and to-dos to be managed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个连接到数据库的后端，管理用户会话并发送电子邮件。现在，我们将向后端添加一个特定的API来跟踪成员的待办事项。这需要一个允许管理成员、会话和待办事项的API。
- en: In this chapter, you’ll learn how to build a **RESTful API**, which is a very
    popular style of API and one you’ll likely use and come across in your career.
    You’ll also build an API to manage members and authenticate their actions, which
    could be used in any other app with minimal changes. Finally, we will also build
    an API to track the to-dos, which, again, could be adapted for other uses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何构建一个**RESTful API**，这是一种非常流行的API风格，你可能会在职业生涯中使用并遇到。你还将构建一个用于管理成员并验证其操作的API，这可以在其他应用中通过最小修改使用。最后，我们还将构建一个用于跟踪待办事项的API，这同样可以适应其他用途。
- en: We’ll build the API using a RESTful style as it works very well with web apps
    and can be expressed very easily with Quart. A RESTful API is where the functionality
    is grouped by resource with each function being an action acting on the resource.
    For example, the functionality to log in is described as creating a session and
    log out as deleting a session. For a RESTful web app, the action is represented
    by the HTTP verb and the resource by the HTTP path. In addition, the response
    status code is used to indicate the effect of the functionality, with 2XX codes
    indicating success and 4XX codes indicating different types of errors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用RESTful风格来构建API，因为它非常适合Web应用，并且可以用Quart轻松表达。RESTful API是功能按资源分组的地方，每个函数都是一个作用于资源的操作。例如，登录功能描述为创建会话，注销描述为删除会话。对于RESTful
    Web应用，操作由HTTP动词表示，资源由HTTP路径表示。此外，响应状态码用于指示功能的效果，2XX代码表示成功，4XX代码表示不同类型的错误。
- en: Alternatives to RESTful APIs
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API的替代方案
- en: While RESTful APIs utilize many HTTP verbs and paths to describe the functionality,
    a more basic style is to have a singular `POST` route. This route is then used
    for all the functionality with the request body describing the function and data.
    A good example is GraphQL, which typically uses only `POST /graphql` with a defined
    message structure. If you’d prefer to use GraphQL take a look at [https://strawberry.rocks](https://strawberry.rocks).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RESTful API使用许多HTTP动词和路径来描述功能，但更基本的方式是有一个单一的`POST`路由。然后，这个路由被用于所有功能，请求体描述了功能和数据。一个很好的例子是GraphQL，它通常只使用`POST
    /graphql`和一个定义的消息结构。如果你希望使用GraphQL，请查看[https://strawberry.rocks](https://strawberry.rocks)。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Creating the database schema and models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库模式和模型
- en: Building the session API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建会话API
- en: Building the member API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建成员API
- en: Building the to-do API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建待办事项API
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following additional folders are required in this chapter and should be
    created:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下额外的文件夹，并应创建：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Empty *backend/src/backend/models/__init__.py* and *backend/tests/models/__init__.py*
    files should also be created.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应创建空的`backend/src/backend/models/__init__.py`和`backend/tests/models/__init__.py`文件。
- en: To follow the development in this chapter, use the companion repository, [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo),
    and see the commits between the tags `r1-ch3-start` and `r1-ch3-end`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪本章的开发进度，请使用配套的仓库[https://github.com/pgjones/tozo](https://github.com/pgjones/tozo)，并查看标签`r1-ch3-start`和`r1-ch3-end`之间的提交。
- en: Creating the database schema and models
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库模式和模型
- en: In this book, we are building a to-do tracking app, which means we need to store
    data about the member and their to-dos. We will do so by placing the data into
    the database, which means we need to define the structure of the data. This structure
    is called the schema and describes the tables in the database.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们正在构建一个待办事项跟踪应用，这意味着我们需要存储关于成员及其待办事项的数据。我们将通过将数据放入数据库来实现这一点，这意味着我们需要定义数据的结构。这个结构被称为模式，它描述了数据库中的表。
- en: While the `id` attribute.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的`id`属性。
- en: ORMs
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ORMs
- en: Schemas and models are often conflated as the same thing, especially when an
    **Object Relational Model** (**ORM**) is used. While using an ORM is simpler to
    begin with, I find it hides important details and makes development harder after
    a short while. This is why, in this book, the model and schema are related but
    different. This also means that we’ll write SQL queries for all interactions with
    the database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模式和模型通常被混为一谈，尤其是在使用 **对象关系模型** (**ORM**) 时。虽然一开始使用 ORM 简单，但我发现它隐藏了重要的细节，并在一段时间后使开发变得更加困难。这就是为什么在这本书中，模型和模式是相关的但不同的。这也意味着我们将为与数据库的所有交互编写
    SQL 查询。
- en: We’ll start by defining the member data and to-do data as both models and schemas
    in a migration, before adding some initial test and development data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在迁移中定义成员数据和待办数据作为模型和模式，然后再添加一些初始测试和开发数据。
- en: Creating the member schema and model
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建成员模式及模型
- en: We need to store information for each member so that we can associate their
    to-dos with them, via a foreign key reference. In addition, we need to store enough
    information so that the member can log in and prove who they are (authenticate
    themselves), which means we need to store their email and password hash. Finally,
    we’ll also store when their account was created and when they verified their email
    – the latter being important if we want to send them emails.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个成员存储信息，以便我们可以通过外键引用将他们的待办事项与他们关联起来。此外，我们还需要存储足够的信息，以便成员可以登录并证明他们的身份（进行身份验证），这意味着我们需要存储他们的电子邮件和密码散列。最后，我们还将存储他们的账户创建时间和验证电子邮件的时间
    - 后者如果我们要向他们发送电子邮件则非常重要。
- en: 'The schema for this data is given by the following SQL, which is given for
    reference and will be used in the *Running the first migration* section:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据的模式由以下 SQL 提供给出，仅供参考，并将用于 *运行第一次迁移* 部分：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The unique index highlighted ensures that there is only one member account per
    email, with email casing being ignored.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的唯一索引确保每个电子邮件地址只有一个成员账户，忽略电子邮件的大小写。
- en: SQL formatting
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 格式化
- en: In [*Chapter 1*](B18727_01.xhtml#_idTextAnchor015) *Setting Up Our System for
    Development*, I mentioned the importance of code formatting and autoformatters.
    Sadly, I haven’t found an autoformatter that works for SQL embedded in Python
    code. However, I recommend you follow the style guide given at [http://sqlstyle.guide/](http://sqlstyle.guide/)
    as I will in this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第一章*](B18727_01.xhtml#_idTextAnchor015) *设置我们的开发系统* 中，我提到了代码格式化和自动格式化工具的重要性。遗憾的是，我还没有找到一个适用于嵌入
    Python 代码中的 SQL 的自动格式化工具。然而，我建议您遵循 [http://sqlstyle.guide/](http://sqlstyle.guide/)
    上给出的风格指南，就像我在这本书中做的那样。
- en: 'We can represent the database table with a Python `dataclass`, which includes
    each column as an attribute with the relevant Python type. This is the model shown
    in the following code, which should be added to *backend/src/backend/models/member.py*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 Python `dataclass` 来表示数据库表，其中每个列都作为属性，并具有相关的 Python 类型。这是以下代码中显示的模型，应该添加到
    *backend/src/backend/models/member.py*：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In addition to the model, we can add the following functions to *backend/src/backend/models/member.py*
    in order to convert between the backend model and the SQL that reads from the
    database:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模型外，我们还可以将以下函数添加到 *backend/src/backend/models/member.py* 中，以便在后端模型和从数据库中读取的
    SQL 之间进行转换：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These functions allow member information to be read from the database. The highlighted
    line ensures that emails are considered a match if the lowercased email matches.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数允许从数据库中读取成员信息。突出显示的行确保如果小写的电子邮件匹配，则认为电子邮件是一致的。
- en: Email case sensitivity
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件大小写敏感性
- en: In our app, we store the email in the case given by the user, while comparing
    lowercased emails. This is the most user-friendly and secure solution, as emails
    can have a case-sensitive local part (before the `@`) but rarely do and must be
    case insensitive for the domain part (after the `@`). Therefore, by storing the
    given casing we ensure the email is delivered while ensuring there is one account
    per email address. More information is available at [https://stackoverflow.com/questions/9807909/are-email-addresses-case-sensitive](https://stackoverflow.com/questions/9807909/are-email-addresses-case-sensitive).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们存储用户给出的电子邮件的大小写，同时比较小写的电子邮件。这是最用户友好且最安全的解决方案，因为电子邮件可以有大小写敏感的本地部分（在
    `@` 之前），但很少这样，并且对于域部分（在 `@` 之后）必须是大小写不敏感的。因此，通过存储给定的大小写，我们确保电子邮件被正确投递，同时确保每个电子邮件地址只有一个账户。更多信息请参阅
    [https://stackoverflow.com/questions/9807909/are-email-addresses-case-sensitive](https://stackoverflow.com/questions/9807909/are-email-addresses-case-sensitive)。
- en: 'Next, we need to add functions that can alter the data in the database by adding
    the following to *backend/src/models/member.py*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加可以更改数据库中数据的函数，通过在 *backend/src/models/member.py* 中添加以下内容：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These functions match the functionality we’ll shortly add to the API.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与我们将很快添加到 API 中的功能相匹配。
- en: 'The case sensitivity is something we should test, by adding the following to
    *backend/tests/models/test_member.py*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该通过添加以下内容到 *backend/tests/models/test_member.py* 来测试大小写敏感性：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Firstly, we want a test to ensure that `insert_member` correctly rejects a second
    member with an email that differs only by casing. The highlighted line ensures
    that the lines within, when executed, raise a `UniqueViolationError` and hence
    prevents the member from being inserted again.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要一个测试来确保 `insert_member` 正确地拒绝了一个具有不同大小写的第二个成员。高亮行确保在执行时，其内的行会引发 `UniqueViolationError`，从而防止成员再次被插入。
- en: 'We also need to test that the `select_member_by_email` function compares case
    insensitively by adding the following to *backend/tests/models/test_member.py*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要测试 `select_member_by_email` 函数是否不区分大小写，通过在 *backend/tests/models/test_member.py*
    中添加以下内容：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the model code set up this way, we’ll be able to use these functions and
    the class instance directly wherever required in the backend code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式设置模型代码后，我们将在后端代码的任何需要的地方直接使用这些函数和类实例。
- en: Creating the to-do schema and model
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建待办事项模式和模型
- en: We also want to store information for each to-do, specifically the to-do task
    as text, when the to-do is due to be completed (although this should be optional),
    and if the to-do is complete. In addition, every to-do should be linked to the
    member that owns it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望为每个待办事项存储信息，特别是待办事项任务作为文本，待办事项应完成的日期（尽管这应该是可选的），以及待办事项是否完成。此外，每个待办事项都应该与其所属成员相关联。
- en: 'The schema for this data is given by the following SQL, which is given for
    reference and will be used in the *Running the first migration* section:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据模式由以下 SQL 给出，供参考，将在 *运行第一次迁移* 部分中使用：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The corresponding backend model for this table is given by the following code,
    which should be added to *backend/src/backend/models/todo.py*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的后端模型由以下代码给出，该代码应添加到 *backend/src/backend/models/todo.py* 中：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, `constr` is used in place of `str` in order to ensure that empty strings
    are not considered valid. In addition to the model, we can add the following functions
    to *backend/src/backend/models/todo.py* in order to convert between the backend
    model and the SQL that reads from the database:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`constr` 用于代替 `str`，以确保空字符串不被视为有效。除了模型外，我们还可以在 *backend/src/backend/models/todo.py*
    中添加以下函数，以便在后端模型和从数据库中读取的 SQL 之间进行转换：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These functions allow to-dos to be read from the database, but will only return
    to-dos that are owned by the given `member_id`. Using these functions should ensure
    that we don’t return to-dos to the wrong members.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数允许从数据库中读取待办事项，但只会返回属于给定 `member_id` 的待办事项。使用这些函数应确保我们不会将待办事项返回给错误成员。
- en: 'Next, we need to add functions that can alter the data in the database by adding
    the following to *backend/src/models/todo.py*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加可以更改数据库中数据的函数，通过在 *backend/src/models/todo.py* 中添加以下内容：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that all these functions also take a `member_id` argument and only affect
    the to-dos that belong to the given `member_id`. This will help us avoid authorization
    errors whereby we write code that mistakenly allows a member to access or modify
    another member’s to-do.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些函数也接受一个 `member_id` 参数，并且只影响属于给定 `member_id` 的待办事项。这将帮助我们避免授权错误，即我们编写的代码错误地允许成员访问或修改其他成员的待办事项。
- en: 'This is something we should test, by adding the following to *backend/tests/models/test_todo.py*.
    Firstly, we want a test to ensure that `delete_todo` correctly deletes the to-do:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应该测试的，通过在 *backend/tests/models/test_todo.py* 中添加以下内容。首先，我们想要一个测试来确保 `delete_todo`
    正确地删除了待办事项：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The highlighted parametrization provides two tests. The first test ensures that
    `member_id 1` can delete their to-do, and the second test ensures that `member_id
    2` cannot delete another user’s to-do.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的参数化提供了两个测试。第一个测试确保 `member_id 1` 可以删除他们的待办事项，第二个测试确保 `member_id 2` 不能删除另一个用户的待办事项。
- en: 'We should also add a similar test to ensure that the update works as expected:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该添加一个类似的测试来确保更新按预期工作：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The parametrization provides two tests. The first test ensures that the member
    with `member_id 1` can update their to-do, and the second test ensures that the
    member with `member_id 2` cannot update another user’s to-do.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化提供了两个测试。第一个测试确保 `member_id 1` 的成员可以更新他们的待办事项，第二个测试确保 `member_id 2` 的成员不能更新其他用户的待办事项。
- en: While we have these important tests in place, we can’t run them until we create
    the database tables via a migration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经设置了这些重要的测试，但我们不能运行它们，直到通过迁移创建数据库表。
- en: Running the first migration
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行第一个迁移
- en: 'While we’ve written the SQL queries required to create the database schema,
    they haven’t run against the database. To run these, Quart-DB provides a migration
    system, whereby we can run queries as the backend starts, but only if they haven’t
    already run. To make use of this, we can add the following code to *backend/src/backend/migrations/0.py*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经编写了创建数据库模式的 SQL 查询，但它们还没有在数据库上运行。为了运行这些查询，Quart-DB 提供了一个迁移系统，允许我们在后端启动时运行查询，但前提是它们尚未运行。为了利用这个功能，我们可以在
    *backend/src/backend/migrations/0.py* 文件中添加以下代码：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To see this migration take effect, you can run `pdm run recreate-db` and then
    start the backend (as the migration will run as the backend starts up). You can
    then use `psql –U tozo` to inspect the database and see the two new tables as
    shown in *Figure 3.1*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到此迁移生效，您可以运行 `pdm run recreate-db` 然后启动后端（因为迁移将在后端启动时运行）。然后您可以使用 `psql –U
    tozo` 检查数据库，并看到如图 3.1 所示的两个新表：
- en: '![Figure 3.1: The database schema after the migration.  ](img/B18727_03_01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：迁移后的数据库模式。](img/B18727_03_01.jpg)'
- en: 'Figure 3.1: The database schema after the migration.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：迁移后的数据库模式。
- en: There is a one-to-many relationship between the `members` and `todos` tables
    such that one member has many to-dos. Also note the `schema_migration` table is
    created and managed by Quart-DB to track migrations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`members` 表和 `todos` 表之间存在一对一的关系，即一个成员可以有多个待办事项。此外，请注意，`schema_migration` 表是由
    Quart-DB 创建和管理的，用于跟踪迁移。'
- en: Adding test and development data
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加测试和开发数据
- en: It is helpful to have some standardized initial data in the database when developing
    and running tests; for example, we can add a standard member with known credentials
    to log in, rather than have to create a new member every time the database is
    recreated. To do this, we can utilize the data path feature in Quart-DB.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和运行测试时，在数据库中拥有一些标准化的初始数据很有帮助；例如，我们可以添加一个具有已知凭证的标准成员以登录，而不是每次数据库重建时都必须创建一个新成员。为此，我们可以利用
    Quart-DB 的数据路径功能。
- en: 'For ease of use, we’ll add a single member to the database by adding the following
    to *backend/src/backend/migrations/data.py*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用，我们将在 *backend/src/backend/migrations/data.py* 文件中添加单个成员到数据库，如下所示：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The password hash value corresponds to a value of `password`, which means the
    login will be with the email, password combination of `member@tozo.dev`, `password`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 密码散列值对应于 `password` 的值，这意味着登录将使用 `member@tozo.dev`，`password` 的电子邮件和密码组合。
- en: 'To instruct Quart-DB to load and run this file, we need to add the following
    configuration variable to *backend/development.env* and *backend/testing.env*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要指示 Quart-DB 加载并运行此文件，我们需要在 *backend/development.env* 和 *backend/testing.env*
    文件中添加以下配置变量：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now run the tests and check that they pass by running the following
    in the *backend* directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 *backend* 目录中运行以下命令来运行测试并检查它们是否通过：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we’ve defined the data stored by the backend, we can focus on the API, starting
    with session management.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了后端存储的数据，我们可以专注于API，从会话管理开始。
- en: Building the session API
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 session API
- en: To manage user sessions, we need a **session** (authentication) API that provides
    routes to log in and log out (i.e., to create and delete sessions). Login should
    result in a cookie being set, and logout results in the cookie being deleted.
    As per the authentication setup, login should require an email and matching password.
    We’ll add this API via a sessions blueprint containing login, logout, and status
    functionality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理用户会话，我们需要一个提供登录和登出（即创建和删除会话）路由的 **会话**（身份验证）API。登录应设置一个cookie，而登出则删除cookie。根据身份验证设置，登录应需要电子邮件和匹配的密码。我们将通过包含登录、登出和状态功能的会话蓝图添加此API。
- en: Creating the blueprint
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建蓝图
- en: 'A blueprint is a collection of route handlers and is useful to associate the
    related session functionality. It can be created with the following code in *backend/src/backend/blueprints/sessions.py*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图是一组路由处理程序，用于关联相关的会话功能。它可以通过在 *backend/src/backend/blueprints/sessions.py*
    文件中的以下代码创建：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The blueprint then needs to be registered with the app, by adding the following
    to *backend/src/backend/run.py*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该蓝图需要通过在*backend/src/backend/run.py*中添加以下内容来注册到应用中：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the blueprint created, we can now add specific functionality as routes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了蓝图之后，我们现在可以添加特定功能作为路由。
- en: Adding login functionality
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加登录功能
- en: 'The login functionality is described in a RESTful style as creating a session,
    and hence the route should be `POST,` expecting an email, a password, and a remember
    flag returning `200` on success and `401` on invalid credentials. This is done
    via the following, which should be added to *backend/src/backend/blueprints/sessions.py*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 登录功能被描述为RESTful风格中的创建会话，因此该路由应该是`POST`，期望一个电子邮件、一个密码和一个记住标志，在成功时返回`200`，在凭证无效时返回`401`。这是通过以下内容完成的，应添加到*backend/src/backend/blueprints/sessions.py*：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This route is rate limited to a lower limit than others (five requests a minute)
    to prevent malicious actors from brute forcing the login. This is where the malicious
    actor keeps trying different passwords in the hope that one will eventually be
    correct and allow login.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由的速率限制低于其他路由（每分钟五次请求）以防止恶意行为者暴力破解登录。这就是恶意行为者不断尝试不同密码，希望最终能够正确并允许登录的地方。
- en: The route also validates the request data has the correct `LoginData` structure,
    which ensures that users correctly use this route, and prevents invalid data from
    causing errors in the route handler code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该路由还验证请求数据是否具有正确的`LoginData`结构，这确保了用户正确使用此路由，并防止无效数据在路由处理程序代码中引起错误。
- en: The route itself tries to fetch the member’s details from the database given
    the email provided in the request data. If there is no data, a `401` response
    is returned. The password provided in the request data is then checked against
    the password hash in the database, with a match resulting in the member being
    logged in with a `200` response. If the passwords don’t match, a `401` response
    is returned.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据请求数据中提供的电子邮件，路由本身尝试从数据库中获取成员的详细信息。如果没有数据，则返回`401`响应。然后，将请求数据中提供的密码与数据库中的密码散列进行比对，匹配成功则成员通过`200`响应登录。如果密码不匹配，则返回`401`响应。
- en: Trailing slashes
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随斜杠
- en: For this route, and for all others in the app, I’ve added a trailing slash so
    that the path is `/sessions/` rather than `/sessions`. This is a useful convention
    to follow as requests to `/sessions` will be automatically redirected to `/sessions/`
    and hence work despite the missing slash, whereas requests to `/sessions/` would
    not be redirected to `/session` if the route was defined without the trailing
    slash.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此路由以及应用中的所有其他路由，我已添加了跟随斜杠，以便路径为`/sessions/`而不是`/sessions`。这是一个有用的约定，因为对`/sessions`的请求将被自动重定向到`/sessions/`，因此即使缺少斜杠也能正常工作，而如果路由没有跟随斜杠定义，对`/sessions/`的请求则不会被重定向到`/session`。
- en: Logging in results in a cookie being stored in the member’s browser, which is
    then sent in every subsequent request. The presence and value of this cookie are
    used to determine whether the member is logged in, and which member made the request.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 登录会导致cookie存储在成员的浏览器中，然后在每个后续请求中发送。此cookie的存在和值用于确定成员是否已登录，以及哪个成员发出了请求。
- en: Account enumeration
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 账户枚举
- en: This implementation will allow an attacker to enumerate emails present in the
    database, which can be considered a security issue. See [*Chapter 7*](B18727_07.xhtml#_idTextAnchor180)*,
    Securing and Packaging the App*, for how to mitigate against this.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现将允许攻击者列出数据库中存在的电子邮件，这可以被视为一个安全问题。请参阅[*第7章*](B18727_07.xhtml#_idTextAnchor180)*，关于如何减轻此问题的影响*。
- en: Adding logout functionality
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加注销功能
- en: 'A logout route is described as a session deletion in a RESTful style, therefore
    the route should be `DELETE`, returning `200`. The following should be added to
    *backend/src/backend/blueprints/sessions.py*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注销路由被描述为RESTful风格中的会话删除，因此该路由应该是`DELETE`，返回`200`。以下内容应添加到*backend/src/backend/blueprints/sessions.py*：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This route is rate exempt as nothing should prevent a member from logging out
    – it is important that the logout function works so that members are logged out
    when they want to be. The route then only needs to call `logout_user`, which results
    in the cookie being deleted.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由不受速率限制，因为不应该有任何东西阻止成员注销 – 确保注销功能正常工作，以便成员在想要注销时能够注销。然后，该路由只需要调用`logout_user`，这将导致cookie被删除。
- en: Idempotent routes
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等路由
- en: Idempotence is a property of a route where the final state is achieved no matter
    how many times the route is called, that is, calling the route once or 10 times
    has the same effect. This is a useful property as it means the route can be safely
    retried if the request fails. For RESTful and HTTP APIs, the routes using `GET`,
    `PUT`, and `DELETE` verbs are expected to be idempotent. In this book, the routes
    using the `GET`, `PUT`, and `DELETE` verbs are idempotent.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性是路由的一个属性，即无论该路由被调用多少次，最终状态都是相同的，也就是说，调用该路由一次或十次具有相同的效果。这是一个有用的属性，因为它意味着如果请求失败，可以安全地重试路由。对于RESTful和HTTP
    API，使用 `GET`、`PUT` 和 `DELETE` 动词的路由预期是幂等的。在本书中，使用 `GET`、`PUT` 和 `DELETE` 动词的路由是幂等的。
- en: Adding status functionality
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加状态功能
- en: 'It is useful to have a route that returns the current session (status) as we’ll
    use it for debugging and testing. For a RESTful API, this should be a `GET` route,
    and the following should be added to *backend/src/backend/blueprints/sessions.py*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个返回当前会话（状态）的路由很有用，因为我们将用它进行调试和测试。对于RESTful API，这应该是一个 `GET` 路由，以下内容应添加到 *backend/src/backend/blueprints/sessions.py*：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The highlighted assertion is used to inform the type checker that `current_user.auth_id`
    cannot be `None` in this function, and hence prevents the type checker from considering
    the subsequent line as an error. The `# nosec` comment informs the bandit security
    checker that this use of `assert` is not a security risk.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的断言用于通知类型检查器在此函数中 `current_user.auth_id` 不能为 `None`，从而防止类型检查器将后续行视为错误。`# nosec`
    注释通知bandit安全检查器这种 `assert` 的使用不是安全风险。
- en: The route is rate limited for protection and will only run if the request has
    the correct cookie present from login. The route returns the member’s ID based
    on the value in the cookie as this is also very useful.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护，路由被速率限制，并且只有在请求中存在从登录处获取的正确cookie时才会运行。该路由根据cookie中的值返回成员ID，因为这同样非常有用。
- en: Testing the routes
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试路由
- en: 'We should test that these routes work as a user would expect, starting by testing
    that a user can log in, get their status, and then log out as a complete flow.
    This is tested by adding the following to *backend/tests/blueprints/test_sessions.py*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该测试这些路由是否按用户预期工作，首先测试用户可以登录，获取其状态，然后注销，作为一个完整的流程。这是通过在 *backend/tests/blueprints/test_sessions.py*
    中添加以下内容来测试的：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This test ensures that a member can log in and then access routes that require
    them to be logged in. It then logs the member out and checks that they can no
    longer access the route.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试确保成员可以登录并访问需要他们登录的路由。然后它注销成员并检查他们不能再访问该路由。
- en: 'We should also test that the login route returns the correct response if the
    wrong credentials are provided by adding the following test to *backend/tests/blueprints/test_sessions.py*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该测试如果提供了错误的凭据，登录路由是否返回正确的响应，通过在 *backend/tests/blueprints/test_sessions.py*
    中添加以下测试：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is all we need to allow members to log in and log out. Next, we can focus
    on managing members.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们允许成员登录和注销所需的所有内容。接下来，我们可以专注于管理成员。
- en: Building the member API
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建成员API
- en: To manage members, we need an API that provides routes to create a member (register),
    confirm the email address, change the password, request a password reset, and
    reset a password.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理成员，我们需要一个API，它提供创建成员（注册）、确认电子邮件地址、更改密码、请求密码重置和重置密码的路由。
- en: We’ll add this API via a blueprint for the member, containing registration,
    email confirmation, changing password, and password reset functionality.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过为成员创建一个蓝图来添加此API，包含注册、电子邮件确认、更改密码和密码重置功能。
- en: Creating the members blueprint
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建成员蓝图
- en: 'To begin, we should create a blueprint for all the member routes, it is created
    with the following code in *backend/src/backend/blueprints/members.py*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该为所有成员路由创建一个蓝图，它是在 *backend/src/backend/blueprints/members.py* 中的以下代码创建的：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The blueprint then needs to be registered with the app, by adding the following
    to *backend/src/backend/run.py*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 随后需要将蓝图注册到应用中，通过在 *backend/src/backend/run.py* 中添加以下内容：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With the blueprint created, we can now add the specific functionality as routes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图创建后，我们现在可以添加特定的功能作为路由。
- en: Creating a member
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建成员
- en: In our app, we want users to be able to register as members. This requires a
    route that accepts an email and a password. The route should then check the password
    is sufficiently complex, create a new member, and send a welcome email. As the
    route creates a member, it should use the `POST` method to be in the RESTful style.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们希望用户能够注册成为会员。这需要一个接受电子邮件和密码的路由。然后，该路由应检查密码是否足够复杂，创建一个新的会员，并发送欢迎邮件。当路由创建会员时，它应使用`POST`方法以符合RESTful风格。
- en: We’ll add a link to the welcome email that the recipient of the email can visit
    to prove they registered with our app. This way, we have verified that the email
    address owner is the same user that registered. The link will work by including
    an authentication token in the path, with the token working as explained in [*Chapter
    2*](B18727_02.xhtml#_idTextAnchor053), *Creating a Reusable Backend with Quart*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在欢迎电子邮件中添加一个链接，收件人可以访问以证明他们使用我们的应用进行了注册。这样，我们就验证了电子邮件地址的所有者与注册的用户是同一人。该链接将通过在路径中包含一个认证令牌来工作，该令牌的作用如[*第2章*](B18727_02.xhtml#_idTextAnchor053)中所述，即使用Quart创建可重用的后端。
- en: 'We can do this by first creating an email template by adding the following
    to *backend/src/backend/templates/welcome.xhtml*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过首先创建一个电子邮件模板来实现这一点，将以下内容添加到`backend/src/backend/templates/welcome.xhtml`：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The route itself should return `201` on success, as this status code indicates
    a successful creation. This is all achieved by adding the following to *backend/src/backend/blueprints/members.py*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该路由本身应在成功时返回`201`，因为此状态码表示成功创建。所有这些都可以通过将以下内容添加到`backend/src/backend/blueprints/members.py`来实现：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As can be seen, the password strength is first checked, using `zxcvbn`, with
    weak passwords resulting in a `400` response. The password is then hashed and
    used with the email to insert a member. The new member’s ID is then used to create
    an email verification token, which is rendered into the email body before being
    sent to the given email address.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，首先使用`zxcvbn`检查密码强度，弱密码将导致返回`400`响应。然后，将密码进行散列，并与电子邮件一起插入会员。接着，使用新会员的ID创建一个电子邮件验证令牌，在发送到指定的电子邮件地址之前将其渲染到电子邮件正文中。
- en: When the user follows the link, they will return to our app with the token for
    the email confirmation route to check.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击链接时，他们将通过电子邮件确认路由的令牌返回到我们的应用进行验证。
- en: Confirming the email address
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确认电子邮件地址
- en: 'When a user registers as a member, they are sent a link back to our app that
    includes an email verification token. The token identifies the member and hence
    confirms that the email address is correct. Therefore, we need a route that accepts
    the token and, if valid, confirms the email address. This updates the member’s
    email property in a RESTful sense and hence is achieved by adding the following
    to *backend/src/backend/blueprints/members.py*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户注册为会员时，他们会被发送回我们的应用的一个链接，该链接包含一个电子邮件验证令牌。该令牌识别会员，从而确认电子邮件地址是正确的。因此，我们需要一个接受令牌的路由，如果有效，则确认电子邮件地址。这将在RESTful意义上更新会员的电子邮件属性，因此可以通过将以下内容添加到`backend/src/backend/blueprints/members.py`来实现：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The token is checked via the `loads` method, and if it is expired a `403` response
    is returned, whereas if it is invalid a `400` response is returned. If the token
    is good, the member’s email is marked as verified in the database and a `200`
    response is returned.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`loads`方法检查令牌，如果已过期则返回`403`响应，如果无效则返回`400`响应。如果令牌有效，则在数据库中将会员的电子邮件标记为已验证，并返回`200`响应。
- en: Once a user has registered, and hopefully verified their email, they will want
    to be able to change their password.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户注册，并且希望验证了他们的电子邮件，他们希望能够更改他们的密码。
- en: Changing passwords
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改密码
- en: A user will want to change their password, which requires a route that accepts
    their new password and their old password. The old password is checked to make
    the member’s account more secure, as a malicious user gaining access via an unattended
    computer cannot change the member’s password (without also knowing the member’s
    password). The route will also need to check that the new password has sufficient
    complexity as with the registration route.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能想要更改他们的密码，这需要一个接受他们新密码和旧密码的路由。检查旧密码是为了使会员的账户更加安全，因为恶意用户通过无人看管的电脑获取访问权限时无法更改会员的密码（除非他们也知道会员的密码）。该路由还需要检查新密码的复杂度，与注册路由相同。
- en: 'The route should also inform the user that the password has been changed by
    email. Doing so makes the member’s account more secure as the member can take
    corrective action if they are informed about a password change that they didn’t
    authorize. This email is defined by adding the following to *backend/src/backend/templates/password_changed.xhtml*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 路径还应通知用户密码已通过电子邮件更改。这样做可以使成员的账户更加安全，因为如果成员被告知有未经授权的密码更改，他们可以采取纠正措施。此电子邮件通过在
    *backend/src/backend/templates/password_changed.xhtml* 中添加以下内容来定义：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This route will update the password, which in a RESTful style means a `PUT`
    route on the member’s password resource that returns `200` on success. It should
    return a `400` response if the password is not complex enough and a `401` response
    if the old password is incorrect. The following should be added to *backend/src/backend/blueprints/members.py*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由将更新密码，在RESTful风格中意味着在成员密码资源上的`PUT`路由，在成功时返回`200`。如果密码不够复杂，则应返回`400`响应，如果旧密码不正确，则返回`401`响应。以下内容应添加到
    *backend/src/backend/blueprints/members.py*：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As with the login route, this route has a lower rate limit to mitigate against
    brute force attacks. The code then checks the password strength before checking
    that the old password matches the hash stored in the database. If these checks
    pass, the password hash in the database is updated and an email is sent to the
    member.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与登录路由一样，此路由有一个较低的速率限制，以减轻暴力攻击的风险。然后，代码检查密码强度，然后再检查旧密码是否与数据库中存储的哈希值匹配。如果这些检查通过，数据库中的密码哈希值将被更新，并向成员发送电子邮件。
- en: This functionality is intentionally not useful for member’s that have forgotten
    their password. In that case, they first need to request a password reset.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能故意对忘记密码的成员没有用。在这种情况下，他们首先需要请求密码重置。
- en: Requesting a password reset
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求密码重置
- en: 'If a member forgets their password, they’ll want a way to reset it. This is
    typically provided by emailing the member a link that they can follow to a password
    reset page with the link containing a token to authorize the reset – as with the
    email verification. For this to work, we first need a route that accepts the user’s
    email address and sends out the link. To start, let’s add the following email
    content to *backend/src/backend/templates/forgotten_password.xhtml*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成员忘记了他们的密码，他们希望有一种方法来重置它。这通常是通过向成员发送一个链接来实现的，他们可以点击该链接访问密码重置页面，链接中包含一个用于授权重置的令牌——就像电子邮件验证一样。为了使这成为可能，我们首先需要一个接受用户电子邮件地址并发送链接的路由。首先，让我们将以下电子邮件内容添加到
    *backend/src/backend/templates/forgotten_password.xhtml*：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The route itself should accept an email address, and in the RESTful style should
    be a `PUT` to the member email resource. The following should be added to *backend/src/backend/blueprints/members.py*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 路径本身应接受一个电子邮件地址，并且按照RESTful风格，应是对成员电子邮件资源的`PUT`操作。以下内容应添加到 *backend/src/backend/blueprints/members.py*：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This route creates a token using the forgotten-password salt. It is important
    that the salt differs to ensure that these tokens cannot be used in place of the
    email verification token and vice versa. The token is then rendered into the email
    and sent to the member.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由使用忘记密码的盐创建一个令牌。确保盐不同很重要，以确保这些令牌不能用来代替电子邮件验证令牌，反之亦然。然后，将令牌渲染到电子邮件中并发送给成员。
- en: Resetting the password
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置密码
- en: 'If the member follows the link emailed out by the previous route, they will
    visit a page that allows them to enter a new password. Therefore, we need a route
    that accepts the new password and the token. This is achieved by adding the following
    to *backend/src/backend/blueprints/members.py*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成员跟随之前路由发出的电子邮件中的链接，他们将访问一个允许他们输入新密码的页面。因此，我们需要一个接受新密码和令牌的路由。这是通过在 *backend/src/backend/blueprints/members.py*
    中添加以下内容来实现的：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This route checks whether the token is valid, returning either a `400` if it
    is not or a `403` if it has expired. The expiry is important as it protects against
    a member’s email being exposed in the future (as the token will have expired and
    hence is useless). Then, if the password is strong enough, the new hash is placed
    into the database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由检查令牌是否有效，如果无效则返回`400`，如果已过期则返回`403`。过期很重要，因为它可以防止成员的电子邮件在未来被泄露（因为令牌已过期，因此无用）。然后，如果新密码足够强大，新的哈希值将被放入数据库。
- en: Managing members
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 管理成员
- en: We’ve added functionality to create members and manage members’ passwords. However,
    we haven’t added functionality to manage a member’s account itself, for example,
    to close and delete it. This functionality will be dependent on the regulatory
    rules of your app as, for example, you may be required to keep data for a certain
    length of time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了创建成员和管理成员密码的功能。然而，我们还没有添加管理成员账户本身的功能，例如关闭和删除它。这个功能将取决于您应用的监管规则，例如，您可能需要保留数据一定的时间。
- en: With this route, we have all the functionality we require for member accounts
    and can now focus on testing the functionality.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个路由，我们拥有了所有需要的成员账户功能，现在可以专注于测试这些功能。
- en: Testing the routes
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试路由
- en: 'We should test that these routes work as a user would expect. Firstly, let’s
    test that new members can register and then log in by adding the following to
    *backend/tests/blueprints/test_members.py*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该测试这些路由是否按用户预期的方式工作。首先，让我们通过在`*backend/tests/blueprints/test_members.py*`中添加以下内容来测试新成员可以注册并登录：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This test registers a new member with the email `new@tozo.dev` and then checks
    that the welcome email was sent to this address. Next, we need to check that the
    user can confirm their email address by adding the following to *backend/tests/blueprints/test_members.py*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试使用电子邮件`new@tozo.dev`注册新成员，然后检查是否向此地址发送了欢迎邮件。接下来，我们需要检查用户是否可以通过添加以下内容到`*backend/tests/blueprints/test_members.py*`来确认他们的电子邮件地址：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The highlighted line allows us to ensure that expired tokens result in a `403`
    response while current tokens succeed. The second test ensures that invalid tokens
    result in a `400` response.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行使我们能够确保过期的令牌导致返回`403`响应，而当前令牌则成功。第二个测试确保无效的令牌导致返回`400`响应。
- en: 'Next, we will test that members can change their password by adding the following
    to *backend/tests/blueprints/test_members.py*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将测试成员是否可以通过添加以下内容到`*backend/tests/blueprints/test_members.py*`来更改他们的密码：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This test registers a new member and then, while authenticated as that member,
    changes the password.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试注册新成员，然后，在以该成员身份认证的情况下更改密码。
- en: 'Then we can test that a user that has forgotten their password can request
    a reset link by adding the following to *backend/tests/blueprints/test_members.py*:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以测试忘记密码的用户是否可以通过添加以下内容到`*backend/tests/blueprints/test_members.py*`来请求重置链接：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we have these simple tests in place, we can focus on the To-Do API.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这些简单的测试，我们可以专注于待办事项API。
- en: Building the To-Do API
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建待办事项API
- en: To manage to-dos, we need an API that provides functionality to create a new
    to-do, retrieve a to-do or to-dos, update a to-do, and delete a to-do (i.e., an
    API that has CRUD functionality). We’ll do this by creating a to-do blueprint
    with a route per CRUD function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理待办事项，我们需要一个提供创建新待办事项、检索待办事项或待办事项列表、更新待办事项和删除待办事项（即具有CRUD功能的API）。我们将通过创建一个包含每个CRUD功能的路由的待办事项蓝图来实现这一点。
- en: CRUD functionality
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD功能
- en: '`Create`, `Read`, `Update`, and `Delete`, and is used to describe a set of
    functionalities. It is often used to describe the functionality of RESTful APIs.
    Typically, for a RESTFul API, the Create route uses the `POST` HTTP method, Read
    uses `GET,` Update uses `PUT`, and Delete uses `DELETE`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`创建`、`读取`、`更新`和`删除`，用于描述一组功能。它通常用于描述RESTful API的功能。通常，对于RESTful API，创建路由使用`POST`
    HTTP方法，读取使用`GET`，更新使用`PUT`，删除使用`DELETE`。'
- en: Creating the blueprint
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建蓝图
- en: 'The blueprint itself can be created with the following code in *backend/src/backend/blueprints/todos.py*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码在`*backend/src/backend/blueprints/todos.py*`中创建蓝图：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The blueprint then needs to be registered with the app, by adding the following
    to *backend/src/backend/run.py*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后需要将蓝图注册到应用中，通过在`*backend/src/backend/run.py*`中添加以下内容：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With the blueprint created, we can now add specific functionality as routes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 创建蓝图后，我们现在可以添加特定的功能作为路由。
- en: Creating a to-do
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建待办事项
- en: 'The first functionality we need is to create a to-do. The route should expect
    the to-do data and return the complete to-do with a `201` status code on success.
    Returning the complete to-do is useful as it contains the to-do’s ID and confirms
    that the data is added. A RESTful to-do creation route should use the POST verb
    and have a `/todos/` path. The following should be added to *backend/src/backend/blueprints/todos.py*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要的功能是创建一个待办事项。该路由应期望待办事项数据，并在成功时返回包含`201`状态码的完整待办事项。返回完整的待办事项是有用的，因为它包含了待办事项的ID，并确认数据已添加。一个RESTful的待办事项创建路由应使用POST动词，并具有`/todos/`路径。以下内容应添加到`*backend/src/backend/blueprints/todos.py*`：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The route is rate limited to prevent malicious usage, with the assumption that
    normal users are unlikely to create more than 10 to-dos in 10 seconds (1 a second
    on average). It is also a route that requires the user to be logged in. The final
    two decorators ensure that the request and response data represent the to-do data
    and a complete to-do.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该路由被速率限制以防止恶意使用，假设普通用户在10秒内不太可能创建超过10个待办事项（平均每秒1个）。它也是一个需要用户登录的路由。最后的两个装饰器确保请求和响应数据代表待办事项数据和完整的待办事项。
- en: The route function simply inserts the data into the database and returns the
    complete to-do. Next, users will need to read a to-do from the backend.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 路由函数只是将数据插入数据库并返回完整的待办事项。接下来，用户需要从后端读取一个待办事项。
- en: Reading a to-do
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取待办事项
- en: 'Users will need to read a to-do based on its ID. This will be implemented as
    a `GET` route with the ID specified in the path. The route should then either
    return the to-do or a `404` response if the to-do does not exist. The following
    should be added to *backend/src/backend/blueprints/todos.py*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要根据其ID读取一个待办事项。这将作为一个带有路径中指定ID的`GET`路由来实现。该路由应返回待办事项或如果待办事项不存在则返回`404`响应。以下内容应添加到`*backend/src/backend/blueprints/todos.py*`：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As with the creation route, this route includes rate limiting protection, requires
    the user to be logged in, and validates the response data. It then selects the
    to-do from the database based on the ID given in the path and returns it or a
    `404` response if no to-do exists. Note that the `select_todo` function requires
    the member’s ID, ensuring that members cannot read other members’ to-dos.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建路由一样，此路由包括速率限制保护、需要用户登录，并验证响应数据。然后根据路径中给出的ID从数据库中选择待办事项，并返回它或如果不存在待办事项则返回`404`响应。请注意，`select_todo`函数需要成员的ID，确保成员不能读取其他成员的待办事项。
- en: While reading a single to-do is useful, a user will also need to read all their
    to-dos in one call, which we’ll add next.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然读取单个待办事项很有用，但用户还需要在一次调用中读取他们所有的待办事项，我们将在下面添加。
- en: Reading the to-dos
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取待办事项
- en: 'A user will need to read all their to-dos, which for a RESTFul API should use
    the `GET` verb and return a list of to-dos on success. We’ll also allow the user
    to filter the to-dos based on the `complete` attribute, which should be optional
    and hence, in a RESTful API, is provided via a `querystring`. The `querystring`
    works via the request path, for example, `/todos/?complete=true` or `/todos/?complete=false`.
    The following should be added to *backend/src/backend/blueprints/todos.py*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要读取他们所有的待办事项，对于RESTFul API，应使用`GET`动词并在成功时返回待办事项列表。我们还将允许用户根据`complete`属性过滤待办事项，这应该是可选的，因此在RESTful
    API中，它通过`querystring`提供。`querystring`通过请求路径工作，例如，`/todos/?complete=true`或`/todos/?complete=false`。以下内容应添加到`*backend/src/backend/blueprints/todos.py*`：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This route includes rate limit protection, requires logged-in usage, validates
    the response data, and includes validation of the `querystring` parameters. We
    can now move on to allowing updates to a to-do.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由包括速率限制保护、需要登录使用、验证响应数据，并包括验证`querystring`参数。现在我们可以继续允许更新待办事项。
- en: Updating a to-do
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新待办事项
- en: 'We need to provide functionality for members to update the data that makes
    up a to-do. For a RESTFul API, this route should use the `PUT` verb, expect the
    to-do data, and return the complete to-do on success or a `404` if the to-do does
    not exist. The following should be added to *backend/src/backend/blueprints/todos.py*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供成员更新构成待办事项的数据的功能。对于RESTFul API，此路由应使用`PUT`动词，期望待办事项数据，并在成功时返回完整的待办事项或如果待办事项不存在则返回`404`。以下内容应添加到`*backend/src/backend/blueprints/todos.py*`：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This route includes rate limit protection, requires logged-in usage, and validates
    the request and response data. It then updates the to-do and returns the updated
    to-do or a `404` response if there is no to-do for the provided ID. Next, we’ll
    allow users to delete to-dos.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由包括速率限制保护、需要登录使用，并验证请求和响应数据。然后更新待办事项并返回更新后的待办事项或对于提供的ID没有待办事项时的`404`响应。接下来，我们将允许用户删除待办事项。
- en: Deleting a to-do
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除待办事项
- en: 'For a RESTFul API, the to-do deletion route should use the `DELETE` verb, and
    return `202` whether the to-do exists or not. The following should be added to
    *backend/src/backend/blueprints/todos.py*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RESTFul API，待办事项删除路由应使用`DELETE`动词，无论待办事项是否存在都返回`202`。以下内容应添加到`*backend/src/backend/blueprints/todos.py*`：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This route includes rate limit protection, requires logged-in usage, and deletes
    the to-do with the given ID as long as it belongs to the logged-in member.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由包括速率限制保护，要求登录使用，并且只要待办事项属于登录成员，就会删除具有给定ID的待办事项。
- en: With all the functionality for to-dos in place, we can now focus on testing
    that it works correctly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有待办事项的功能都到位之后，我们现在可以专注于测试它是否正确工作。
- en: Testing the routes
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试路由
- en: 'We should test that these routes work as a user would expect. Firstly, we need
    to ensure we can create new to-dos by adding the following to *backend/tests/blueprints/test_todos.py*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该测试这些路由是否按用户预期的方式工作。首先，我们需要确保我们可以在`backend/tests/blueprints/test_todos.py`中添加以下内容来创建新的待办事项：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we can ensure we can read to-dos by adding the following to *backend/tests/blueprints/test_todos.py*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以确保我们可以在`backend/tests/blueprints/test_todos.py`中添加以下内容来读取待办事项：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Continuing along the CRUD functionality, we can ensure that to-dos can be updated
    by adding the following to *backend/tests/blueprints/test_todos.py*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 继续CRUD功能，我们可以确保可以通过在`backend/tests/blueprints/test_todos.py`中添加以下内容来更新待办事项：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we can ensure that to-dos can be deleted by adding the following to
    *backend/tests/blueprints/test_todos.py*:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以确保可以通过在`backend/tests/blueprints/test_todos.py`中添加以下内容来删除待办事项：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With these tests, we have all the functionality we need to manage to-dos.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些测试，我们拥有了管理待办事项所需的所有功能。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve defined how we are storing the data in the database and
    then built an API to manage sessions, members, and to-dos. This includes all the
    functionality our app will need via an easy-to-understand RESTful API.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们定义了如何在数据库中存储数据，然后构建了一个API来管理会话、成员和待办事项。这包括我们应用将通过易于理解的RESTful API所需的所有功能。
- en: While the to-do functionality is unlikely to be directly useful to your app,
    the CRUD functionality is a pattern you should use. In addition, the member and
    session APIs could be used directly in your app. Finally, you’ve hopefully gained
    an understanding of what makes a good RESTful API that you can apply and use elsewhere.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然待办事项功能可能对你的应用没有直接的帮助，但CRUD模式是你应该使用的模式。此外，成员和会话API可以直接在你的应用中使用。最后，你也许已经理解了什么是一个好的RESTful
    API，并且可以在其他地方应用和使用。
- en: In the next chapter, we’ll create a styled frontend, including validated data
    entry in React, that we can use with this API or any other.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个带样式的前端，包括在React中的验证数据输入，这样我们就可以使用这个API或任何其他API。
- en: Further reading
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We’ve built a fairly simple RESTful API in this chapter. As your API’s complexity
    increases, I’d recommend following the best practices at [https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api](https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个相当简单的RESTful API。随着你的API复杂性的增加，我建议遵循[https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api](https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api)中的最佳实践。
