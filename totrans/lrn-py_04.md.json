["```py\ndef do_report(data_source):\n    # fetch and prepare data\n    data = fetch_data(data_source)\n    parsed_data = parse_data(data)\n    filtered_data = filter_data(parsed_data)\n    polished_data = polish_data(filtered_data)\n\n    # run algorithms on data\n    final_data = analyse(polished_data)\n\n    # create and return report\n    report = Report(final_data)\n    return report\n```", "```py\na = [[1, 2], [3, 4]]\nb = [[5, 1], [2, 1]]\nc = [[sum(i * j for i, j in zip(r, c)) for c in zip(*b)]\n for r in a]\n\n```", "```py\n# this function could also be defined in another module\ndef matrix_mul(a, b):\n    return [[sum(i * j for i, j in zip(r, c)) for c in zip(*b)]\n            for r in a]\n\na = [[1, 2], [3, 4]]\nb = [[5, 1], [2, 1]]\nc = matrix_mul(a, b)\n\n```", "```py\nprice = 100  # GBP, no VAT\nfinal_price1 = price * 1.2\nfinal_price2 = price + price / 5.0\nfinal_price3 = price * (100 + 20) / 100.0\nfinal_price4 = price + price * 0.2\n```", "```py\ndef calculate_price_with_vat(price, vat):\n    return price * (100 + vat) / 100\n```", "```py\ndef my_function():\n    test = 1 # this is defined in the local scope of the function\n    print('my_function:', test)\n\ntest = 0  # this is defined in the global scope\nmy_function()\nprint('global:', test)\n```", "```py\n$ python scoping.level.1.py\nmy_function: 1\nglobal: 0\n\n```", "```py\ndef outer():\n    test = 1  # outer scope\n\n    def inner():\n        test = 2  # inner scope\n        print('inner:', test)\n    inner()\n    print('outer:', test)\ntest = 0  # global scope\nouter()\nprint('global:', test)\n```", "```py\n$ python scoping.level.2.py \ninner: 2\nouter: 1\nglobal: 0\n\n```", "```py\ndef outer():\n    test = 1  # outer scope\n\n    def inner():\n        nonlocal test\n        test = 2  # nearest enclosing scope\n        print('inner:', test)\n    inner()\n    print('outer:', test)\n\ntest = 0  # global scope\nouter()\nprint('global:', test)\n```", "```py\n$ python scoping.level.2.nonlocal.py \ninner: 2\nouter: 2\nglobal: 0\n\n```", "```py\ndef outer():\n    test = 1  # outer scope\n\n    def inner():\n        global test\n        test = 2  # global scope\n        print('inner:', test)\n    inner()\n    print('outer:', test)\n\ntest = 0  # global scope\nouter()\nprint('global:', test)\n```", "```py\n$ python scoping.level.2.global.py\ninner: 2\nouter: 1\nglobal: 2\n\n```", "```py\nx = 3\ndef func(y):\n    print(y)\nfunc(x)  # prints: 3\n```", "```py\nx = 3\ndef func(x):\n    x = 7  # defining a local x, not changing the global one\n\nfunc(x)\nprint(x)  # prints: 3\n```", "```py\nx = [1, 2, 3]\ndef func(x):\n    x[1] = 42  # this affects the caller!\n\nfunc(x)\nprint(x)  # prints: [1, 42, 3]\n```", "```py\nx = [1, 2, 3]\ndef func(x):\n    x[1] = 42  # this changes the caller!\n    x = 'something else'  # this points x to a new string object\n\nfunc(x)\nprint(x)  # still prints: [1, 42, 3]\n```", "```py\ndef func(a, b, c):\n    print(a, b, c)\nfunc(1, 2, 3)  # prints: 1 2 3\n```", "```py\ndef func(a, b, c):\n    print(a, b, c)\nfunc(a=1, c=2, b=3)  # prints: 1 3 2\n```", "```py\ndef func(a, b=4, c=88):\n    print(a, b, c)\n\nfunc(1)              # prints: 1 4 88\nfunc(b=5, a=7, c=9)  # prints: 7 5 9\nfunc(42, c=9)        # prints: 42 4 9\n```", "```py\nfunc(b=1, c=2, 42)  # positional argument after keyword one\n```", "```py\nSyntaxError: non-keyword arg after keyword arg\n\n```", "```py\ndef minimum(*n):\n    # print(n)  # n is a tuple\n    if n:  # explained after the code\n        mn = n[0]\n        for value in n[1:]:\n            if value < mn:\n                mn = value\n        print(mn)\n\nminimum(1, 3, -7, 9)  # n = (1, 3, -7, 9) - prints: -7\nminimum()             # n = () - prints: nothing\n```", "```py\ndef func(*args):\n    print(args)\n\nvalues = (1, 3, -7, 9)\nfunc(values)   # equivalent to: func((1, 3, -7, 9))\nfunc(*values)  # equivalent to: func(1, 3, -7, 9)\n\n```", "```py\ndef func(**kwargs):\n    print(kwargs)\n# All calls equivalent. They print: {'a': 1, 'b': 42}\nfunc(a=1, b=42)\nfunc(**{'a': 1, 'b': 42})\nfunc(**dict(a=1, b=42))\n```", "```py\ndef connect(**options):\n    conn_params = {\n        'host': options.get('host', '127.0.0.1'),\n        'port': options.get('port', 5432),\n        'user': options.get('user', ''),\n        'pwd': options.get('pwd', ''),\n    }\n    print(conn_params)\n    # we then connect to the db (commented out)\n    # db.connect(**conn_params)\n\nconnect()\nconnect(host='127.0.0.42', port=5433)\nconnect(port=5431, user='fab', pwd='gandalf')\n```", "```py\n$ python arguments.variable.db.py\n{'host': '127.0.0.1', 'pwd': '', 'user': '', 'port': 5432}\n{'host': '127.0.0.42', 'pwd': '', 'user': '', 'port': 5433}\n{'host': '127.0.0.1', 'pwd': 'gandalf', 'user': 'fab', 'port': 5431}\n\n```", "```py\ndef kwo(*a, c):\n    print(a, c)\n\nkwo(1, 2, 3, c=7)  # prints: (1, 2, 3) 7\nkwo(c=4)           # prints: () 4\n# kwo(1, 2)  # breaks, invalid syntax, with the following error\n# TypeError: kwo() missing 1 required keyword-only argument: 'c'\n\ndef kwo2(a, b=42, *, c):\n    print(a, b, c)\n\nkwo2(3, b=7, c=99)  # prints: 3 7 99\nkwo2(3, c=13)       # prints: 3 42 13\n# kwo2(3, 23)  # breaks, invalid syntax, with the following error\n# TypeError: kwo2() missing 1 required keyword-only argument: 'c'\n```", "```py\ndef func(a, b, c=7, *args, **kwargs):\n    print('a, b, c:', a, b, c)\n    print('args:', args)\n    print('kwargs:', kwargs)\n\nfunc(1, 2, 3, *(5, 7, 9), **{'A': 'a', 'B': 'b'})\nfunc(1, 2, 3, 5, 7, 9, A='a', B='b')  # same as previous one\n```", "```py\n$ python arguments.all.py \na, b, c: 1 2 3\nargs: (5, 7, 9)\nkwargs: {'A': 'a', 'B': 'b'}\n\n```", "```py\ndef func_with_kwonly(a, b=42, *args, c, d=256, **kwargs):\n    print('a, b:', a, b)\n    print('c, d:', c, d)\n    print('args:', args)\n    print('kwargs:', kwargs)\n\n# both calls equivalent\nfunc_with_kwonly(3, 42, c=0, d=1, *(7, 9, 11), e='E', f='F')\nfunc_with_kwonly(3, 42, *(7, 9, 11), c=0, d=1, e='E', f='F')\n```", "```py\n$ python arguments.all.kwonly.py\na, b: 3 42\nc, d: 0 1\nargs: (7, 9, 11)\nkwargs: {'f': 'F', 'e': 'E'}\n\n```", "```py\ndef func(a=[], b={}):\n    print(a)\n    print(b)\n    print('#' * 12)\n    a.append(len(a))  # this will affect a's default value\n    b[len(a)] = len(a)  # and this will affect b's one\n\nfunc()\nfunc()\nfunc()\n```", "```py\n$ python arguments.defaults.mutable.py\n[]\n{}\n############\n[0]\n{1: 1}\n############\n[0, 1]\n{1: 1, 2: 2}\n############\n\n```", "```py\nfunc()\nfunc(a=[1, 2, 3], b={'B': 1})\nfunc()\n```", "```py\n$ python arguments.defaults.mutable.intermediate.call.py \n[]\n{}\n############\n[1, 2, 3]\n{'B': 1}\n############\n[0]\n{1: 1}\n############\n\n```", "```py\ndef func(a=None):\n    if a is None:\n a = []\n    # do whatever you want with `a` ...\n```", "```py\ndef func():\n    pass\nfunc()  # the return of this call won't be collected. It's lost.\na = func()  # the return of this one instead is collected into `a`\nprint(a)  # prints: None\n\n```", "```py\ndef factorial(n):\n    if n in (0, 1):\n        return 1\n    result = n\n    for k in range(2, n):\n        result *= k\n    return result\n\nf5 = factorial(5)  # f5 = 120\n```", "```py\nfrom functools import reduce\nfrom operator import mul\n\ndef factorial(n):\n    return reduce(mul, range(1, n + 1), 1)\nf5 = factorial(5)  # f5 = 120\n```", "```py\ndef moddiv(a, b):\n    return a // b, a % b\n\nprint(moddiv(20, 7))  # prints (2, 6)\n```", "```py\n    >>> numbers = [4, 1, 7, 5]\n    >>> sorted(numbers)  # won't sort the original `numbers` list\n    [1, 4, 5, 7]\n    >>> numbers  # let's verify\n    [4, 1, 7, 5]  # good, untouched\n    >>> numbers.sort()  # this will act on the list\n    >>> numbers\n    [1, 4, 5, 7]\n\n    ```", "```py\ndef factorial(n):\n    if n in (0, 1):  # base case\n        return 1\n    return factorial(n - 1) * n  # recursive case\n```", "```py\ndef is_multiple_of_five(n):\n    return not n % 5\ndef get_multiples_of_five(n):\n    return list(filter(is_multiple_of_five, range(n)))\nprint(get_multiples_of_five(50))\n```", "```py\ndef get_multiples_of_five(n):\n    return list(filter(lambda k: not k % 5, range(n)))\nprint(get_multiples_of_five(50))\n```", "```py\n# example 1: adder\ndef adder(a, b):\n return a + b\n# is equivalent to:\nadder_lambda = lambda a, b: a + b\n\n# example 2: to uppercase\ndef to_upper(s):\n return s.upper()\n# is equivalent to:\nto_upper_lambda = lambda s: s.upper()\n\n```", "```py\ndef multiplication(a, b=1):\n    \"\"\"Return a multiplied by b. \"\"\"\n    return a * b\n\nspecial_attributes = [\n    \"__doc__\", \"__name__\", \"__qualname__\", \"__module__\",\n    \"__defaults__\", \"__code__\", \"__globals__\", \"__dict__\",\n    \"__closure__\", \"__annotations__\", \"__kwdefaults__\",\n]\n\nfor attribute in special_attributes:\n    print(attribute, '->', getattr(multiplication, attribute))\n```", "```py\n$ python func.attributes.py \n__doc__ -> Return a multiplied by b. \n__name__ -> multiplication\n__qualname__ -> multiplication\n__module__ -> __main__\n__defaults__ -> (1,)\n__code__ -> <code object multiplication at 0x7ff529e79300, file \"ch4/func.attributes.py\", line 1>\n__globals__ -> {... omitted ...}\n__dict__ -> {}\n__closure__ -> None\n__annotations__ -> {}\n__kwdefaults__ -> None\n\n```", "```py\nfrom math import sqrt, ceil\n\ndef get_primes(n):\n    \"\"\"Calculate a list of primes up to n (included). \"\"\"\n    primelist = []\n    for candidate in range(2, n + 1):\n        is_prime = True\n        root = int(ceil(sqrt(candidate)))  # division limit\n        for prime in primelist:  # we try only the primes\n            if prime > root:  # no need to check any further\n                break\n            if candidate % prime == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primelist.append(candidate)\n    return primelist\n```", "```py\ndef square(n):\n    \"\"\"Return the square of a number n. \"\"\"\n    return n ** 2\n\ndef get_username(userid):\n    \"\"\"Return the username of a user given their id. \"\"\"\n    return db.get(user_id=userid).username\n```", "```py\ndef connect(host, port, user, password):\n    \"\"\"Connect to a database.\n\n    Connect to a PostgreSQL database directly, using the given\n    parameters.\n\n    :param host: The host IP.\n    :param port: The desired port.\n    :param user: The connection username.\n    :param password: The connection password.\n    :return: The connection object.\n    \"\"\"\n    # body of the function here...\n    return connection\n```", "```py\nfrom mymodule import myfunc as better_named_func\n```", "```py\nimport unittest  # imports the unittest module\nfrom math import sqrt  # imports one function from math\nfrom random import randint, sample  # two imports at once\n\nfrom mock import patch\nfrom nose.tools import (  # multiline import\n    assert_equal,\n    assert_list_equal,\n    assert_not_in,\n)\n\nfrom karma import nt, utils\n```", "```py\n├── func_from.py\n├── func_import.py\n├── lib\n ├── funcdef.py\n └── __init__.py\n\n```", "```py\ndef square(n):\n    return n ** 2\ndef cube(n):\n    return n ** 3\n```", "```py\nimport lib.funcdef\nprint(lib.funcdef.square(10))\nprint(lib.funcdef.cube(10))\n```", "```py\nfrom lib.funcdef import square, cube\nprint(square(10))\nprint(cube(10))\n```", "```py\nfrom .mymodule import myfunc\n```"]