- en: Chapter 1. GUI Basics – Building an Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kivy is a free, open source Python library that allows for quick and easy development
    of highly interactive multiplatform applications. Kivy''s execution speed is comparable
    to the native mobile alternative, Java for Android or Objective C for iOS. Moreover,
    Kivy has the huge advantage of being able to run on multiple platforms, just as
    HTML5 does; in which case, Kivy performs better because it doesn''t rely on a
    heavy browser, and many of its components are implemented in C using the Cython
    library in such a way that most of the graphics processing runs directly in the
    GPU. Kivy strikes a great balance between performance and portability across various
    hardware and software environments. Kivy emerges with a simple but ambitious goal
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"… same code for every platform, at least what we use every day: Linux/Windows/Mac
    OS X/Android/iOS"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Mathieu Virbel ([http://txzone.net/2011/01/kivy-next-pymt-on-android-step-1-done/](http://txzone.net/2011/01/kivy-next-pymt-on-android-step-1-done/))
  prefs: []
  type: TYPE_NORMAL
- en: This support has being extended to Raspberry Pi, thanks to a crowd funding campaign
    started by Mathieu Virbel, the creator of Kivy. Kivy was introduced for the first
    time at EuroPython 2011 as a Python framework designed for creating natural user
    interfaces. Since then, it has grown bigger and attracted an enthusiastic community.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book requires some knowledge of Python, and very basic terminal skills,
    but also it requires some understanding of **Object-Oriented Programming** (**OOP**)
    concepts. In particular, it is assumed that you understand the concept of **inheritance**
    and the difference between **instances** and **classes**. Refer to the following
    table to review some of these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Concept | URL |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| OOP | [http://en.wikipedia.org/wiki/Object-oriented_programming](http://en.wikipedia.org/wiki/Object-oriented_programming)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Inheritance | [http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)](http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming))
    |'
  prefs: []
  type: TYPE_TB
- en: '| Instance | [http://en.wikipedia.org/wiki/Instance_(computer_science)](http://en.wikipedia.org/wiki/Instance_(computer_science))
    |'
  prefs: []
  type: TYPE_TB
- en: '| Class | [http://en.wikipedia.org/wiki/Class_(computer_science)](http://en.wikipedia.org/wiki/Class_(computer_science))
    |'
  prefs: []
  type: TYPE_TB
- en: 'Before we start, you will need to install Kivy. The installation process for
    all different platforms is documented and regularly updated on the Kivy website:
    [http://kivy.org/docs/installation/installation.html](http://kivy.org/docs/installation/installation.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All code in this book has been tested with Kivy 1.9.0 and both Python 2.7 and
    Python 3.4 (but 3.3 should work fine as well).
  prefs: []
  type: TYPE_NORMAL
- en: Note that packaging support for mobile is not yet complete for Python 3.3+.
    For now, if we want to create mobile apps for Android or iOS, we should use Python
    2.7\. If you want to know your Python version, you can execute `python -V` in
    a terminal to check your installed Python version.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we start by creating user interfaces using one of Kivy's most
    fun and powerful components – the Kivy language (`.kv`). The Kivy Language separates
    logic from presentation in order to keep an easy and intuitive code; it also links
    components at an interface level. In future chapters, you will also learn how
    to build and modify interfaces dynamically using pure Python code and Kivy as
    a library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of all the skills that you are about to learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Launching a Kivy application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Kivy language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating and personalizing widgets (GUI components) through basic properties
    and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating between fixed, proportional, absolute, and relative coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating responsive GUIs through layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularizing code in different files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers all the basics for building a **Graphical User Interface**
    (**GUI**) in Kivy. First, we will learn techniques to run an application and how
    to use and integrate widgets. After that, we will introduce the main project of
    the book, the *Comic Creator*, and program the main structure of the GUI that
    we will continue using in the following two chapters. At the end of this chapter,
    you will be able to build a GUI starting from a pencil and paper sketch, and also
    learn some techniques to make the GUI responsive to the size of the window.
  prefs: []
  type: TYPE_NORMAL
- en: Basic interface – Hello World!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's put our hands on our first code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a Hello World program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is merely Python code. Launching a Kivy program is not any different from
    launching any other Python application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run the code, you open a terminal (line of commands or console)
    and specify the following command in Windows or Linux: `python hello.py --size=150x100`
    (`--size` is a parameter to specify the screen size).'
  prefs: []
  type: TYPE_NORMAL
- en: On a Mac, you must type in `kivy` instead of `python` after installing `Kivy.app`
    in `/Applications`. Lines 2 and 3 verify that we have the appropriate version
    of Kivy installed on our computer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you try to launch our application with an older Kivy version (say 1.8.0)
    than the specified version, then line 3 will raise an `Exception` error. This
    `Exception` is not raised if we have a more recent version.
  prefs: []
  type: TYPE_NORMAL
- en: We omit the call to `kivy.require` in most of the examples in the book, but
    you will find it in the code that you download online ([https://www.packtpub.com](https://www.packtpub.com)/),
    and its use is strongly encouraged in real-life projects. The program uses two
    classes from the Kivy library (lines 5 and 6) – `App` and `Label`. The class **`App`**
    is the starting point of any Kivy application. Consider `App` as the empty window
    where we will add other Kivy components.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `App` class through **inheritance**; the `App` class becomes the
    base class of the `HelloApp` subclass or child class (line 8). In practice, this
    means that the `HelloApp` class has all the variables and methods of `App`, plus
    whatever we define in the body (lines 9 and 10) of the `HelloApp` class. Most
    importantly, `App` is the starting point of any Kivy application. We can see that
    line 13 creates an instance of `HelloApp` and runs it.
  prefs: []
  type: TYPE_NORMAL
- en: Now the `HelloApp` class's body just overrides one of the existing `App` class's
    methods, the `build(self)` method. This method has to return the window content.
    In our case, a **`Label`** that holds the text **Hello World**`!` (line 10). A
    **Label** is a **widget** that allows you to display some text on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **widget** is a Kivy GUI component. Widgets are the minimal graphical units
    that we put together in order to create user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the resulting screen after executing the `hello.py`
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic interface – Hello World!](img/B04244_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, is Kivy just another library for Python? Well, yes. But as part of the library,
    Kivy offers its own language in order to separate the logic from the presentation
    and to link elements of the interface. Moreover, remember that this library will
    allow you to port your applications to many platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start to explore the Kivy language. We will separate the previous Python
    code into two files, one for the presentation (interface), and another for the
    logic. The first file includes the Python lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `hello2.py` code is very similar to `hello.py`. The difference is that the
    method `build(self)` doesn't have the **Hello World!** message. Instead, the message
    has been moved to the `text` property in the Kivy language file (`hello2.kv`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **property** is an attribute that can be used to change the content, appearance,
    or behavior of a widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code (rules) of `hello2.kv`, which shows how we modify
    the `Label` content with the `text` property (line 27):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder how Python or Kivy knows that these two files (`hello2.py`
    and `hello2.kv`) are related. This tends to be confusing at the beginning. The
    key is in the name of the subclass of `App`, which in this case is `HelloApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The beginning part of the `App` class's subclass name must coincide with the
    name of the Kivy file. For example, if the definition of the class is `class FooApp(App)`,
    then the name of the file has to be `foo.kv` and in the same directory of the
    main file (the one that executes the `run()` method of `App`).
  prefs: []
  type: TYPE_NORMAL
- en: Once that consideration is included, this example can be run in the same way
    we ran the previous one. We just need to be sure we are calling the main file
    – `python hello2.py -–size=150x100`.
  prefs: []
  type: TYPE_NORMAL
- en: This is our first contact with the Kivy language, so we should have an in-depth
    look at it. Line 25 (`hello2.kv`) tells Python the minimal version of Kivy that
    should be used. It does the same thing as the previous lines 2 and 3 do in `hello.py`.
    The instructions that start with `#:` in the header of a Kivy language are called
    **directives**. We will also be omitting the version directive throughout the
    rest of this book, but remember to include it in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: The `<Label>:` rule (line 26) indicates that we are going to modify the `Label`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Kivy language is expressed as a sequence of rules. A **rule** is a piece
    of code that defines the content, behavior, and appearance of a Kivy widget class.
    A rule always starts with a widget class name in angle brackets followed by a
    colon, like this, `<Widget Class>:`
  prefs: []
  type: TYPE_NORMAL
- en: Inside the rule, we set the `text` property with `'Hello World!'` (line 27).
    The code in this section will generate the same output screen as before. In general,
    everything in Kivy can be done using pure Python and importing the necessary classes
    from the Kivy library, as we did in the first example (`hello.py`). However, there
    are many advantages of using the Kivy language and therefore this book explains
    all the presentation programming in the Kivy language, unless we need to add dynamic
    components, in which case using Kivy as a traditional Python library is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: If you are an experienced programmer, you might have worried that modifying
    the `Label` class affects all the instances we could potentially create from `Label`,
    and therefore they will all contain the same `Hello World` text. That is true,
    and we are going to study a better approach to doing this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Basic widgets – labels and buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we used the `Label` class, which is one of the multiple
    widgets that Kivy provides. You can think of widgets as interface blocks that
    we use to set up a GUI. Kivy has a complete set of widgets – buttons, labels,
    checkboxes, dropdowns, and many more. You can find them all in the API of Kivy
    under the package `kivy.uix` ([http://kivy.org/docs/api-kivy.html](http://kivy.org/docs/api-kivy.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to learn the basics of how to create our own personalized widget
    without affecting the default configuration of Kivy widgets. In order to do that,
    we will use inheritance to create the `MyWidget` class in the `widgets.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In line 32, we inherit from the base class **`Widget`** and create the subclass
    `MyWidget`. It is a general practice to create your own `Widget` for your applications
    instead of using the Kivy classes directly, because we want to avoid applying
    our changes to all future instances of the widget Kivy class. In the case of our
    previous example (`hello2.kv`), modifying the `Label` class (line 26) would affect
    all of its future instances. In line 37, we instantiated `MyWidget` instead of
    `Label` directly (as we did in `hello2.py`), so we can now distinguish between
    our widget (`MyWidget`) and the Kivy widget (`Widget`). The rest of the code is
    analogous to what we covered before.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the corresponding Kivy language code (`widgets.kv`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that now we are using **buttons** instead of labels. Most of the basic
    widgets in Kivy work in similar ways. In fact, **`Button`** is just a subclass
    of `Label` that incorporates more properties such as background color.
  prefs: []
  type: TYPE_NORMAL
- en: Compare the notation of line 26 (`<Label>:`) in `hello2.kv` with line 43 (`Button:`)
    of the preceding code (`widgets.kv`). We used the rule class notation (`<Class>:`)
    for the `Label` (and `MyWidget`) class, but a different notation (`Instance:`)
    for `Button`. In this way, we defined that `MyWidget` has two instances of `Button`
    (line 43 and 49).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the properties of the `Button` instances. The **`font_size`**
    property sets the size of the text. The **`color`** property sets the text color
    and is specified in RGBA format (red, green, blue, and alpha/transparency). The
    properties **`size`** and **`pos`** set the size and position of the widget and
    consist of a pair of **fixed coordinates** (x for horizontal and y for vertical),
    the exact pixels on the window.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the coordinate (0, 0) is located at the bottom-left corner, the Cartesian
    origin. Many other languages (including CSS) use the top-left corner as the (0,
    0) coordinate, so take note!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of `widgets.py` and `widgets.kv`
    with some helpful annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic widgets – labels and buttons](img/B04244_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A couple of things can be improved in the previous code (`widgets.kv`). First,
    there are some repeated properties for both buttons: `pos`, `color`, and `font_size`.
    Instead of that, let''s create our own `Button` as we did with `MyWidget` so it
    will be easy to keep the buttons'' design consistent. Second, the fixed position
    is quite annoying because the widgets don''t adjust when the screen is resized.
    Let''s make it responsive to the screen size in the `widgets2.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code (`widgets2.kv`), we create (`<MyButton@Button>:`) and customize
    the `MyButton` class (lines 56 to 59) and instances (line 62 to 67). Note the
    differences in the manner we defined `MyWidget` and `MyButton`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we did not define the `MyButton` base class in `widgets.py` as we did
    with `MyWidget` (line 32 of `widgets.py`), we have to specify `@Class` in the
    Kivy language rule (line 56). In the `MyWidget` class case, we also needed to
    define its class from the Python side because we instantiated it directly (line
    37 of `widgets.py`).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, each `Button` class's position is responsive in the sense that
    they are always in the corners of the screen, no matter what the window size is.
    In order to achieve that, we need to use two internal variables – **`self`** and
    **`root`**. You might be familiar with the variable **`self`**. As you have probably
    guessed, it is just a reference to the `Widget` itself. For example, `self.height`
    (line 64) has a value of `50` because that is the height of that particular `MyButton`
    class. The variable **`root`** is a reference to the `Widget` class at the top
    of the hierarchy. For example, the `root.x` (line 64) has a value of `0` because
    that is the position in X-axis of the `MyWidget` instance created on line 37 of
    `widgets.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '`MyWidget` uses all of the window''s space by default; therefore, the origin
    is (0, 0). The **`x`** and **`y`** and **`width`** and **`height`** are also widget
    properties, which we can use to disjoint `pos` and `size` respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Fixed coordinates are still a laborious way to organize widgets and elements
    in the window. Let's move on to something smarter – layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No doubt, fixed coordinates are the most flexible way to organize elements in
    an n-dimensional space; however, it is very time consuming. Instead, Kivy provides
    a set of layouts that will facilitate the work of organizing widgets. A **`Layout`**
    is a `Widget` subclass that implements different strategies to organize embedded
    widgets. For example, one strategy could be organizing widgets in a grid (`GridLayout`).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a simple **`FloatLayout`** example. It works in a very similar
    manner to the way we organize widgets directly inside of another `Widget` subclass,
    except that now we can use **proportional coordinates** ("percentages" of the
    total size of the window) rather than fixed coordinates (exact pixels).
  prefs: []
  type: TYPE_NORMAL
- en: 'That means that we won''t need the calculations we did in the previous section
    with `self` and `root`. Here is the Python code of an example that resembles the
    previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing really new in the preceding code (`floatlayout.py`), except
    the use of `FloatLayout` (line 75). The interesting parts are in the corresponding
    Kivy language (`floatlayout.kv`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In `floatlayout.kv`, we use two new properties – **`size_hint`** (line 83) and
    **`pos_hint`** (lines 88 and 91) .They are similar to `size` and `pos` but receive
    proportional coordinates with values ranging from `0` to `1`; (0, 0) is the bottom-left
    corner and (1, 1) is the top-right corner. For example, the `size_hint` property
    on line 83 sets the width to 40 percent of the window width and the height to
    30 percent of the current window height. Something similar happens to the `pos_hint`
    property (lines 88 and 91 but the notation is different – a Python dictionary
    where the keys (for example, `'x'` or `'top'`) indicate which part of the widget
    is referenced. For example, `'x'` is the left border.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we use the `top` key instead of the `y` one on line 88 and the `right`
    key instead of the `x` one on line 91\. The **`top`** and **`right`** keys respectively
    reference the top and right edges of `Button`. In this case, we could have also
    used `x` and `y` for both axes; for example, we could have written `pos_hint:
    {''x'': .85, ''y'': 0}` as line 91\. However, the **`right`** and **`top`** keys
    avoid us some calculations, making the code clearer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot shows the result, and the available keys for the `pos_hint`
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts](img/B04244_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The available `pos_hint` keys (`x`, **`center_x`**, `right`, `y`, **`center_y`**,
    and `top`) are useful to align the edges or for centering. For example, `pos_hint:
    {''center_x'':.5, ''center_y'':.5}` would align a widget in the middle no matter
    the size of the window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have used the `top` and `right` properties with the fixed positioning
    of `widgets2.kv` (line 64 and 67), but note that `pos` doesn''t accept Python
    dictionaries (`{''x'':0,''y'':0}`), just pairs of values exclusively corresponding
    to (`x`, `y`). Therefore, instead of using the `pos` property, we should use the
    `x`, `center_x`, `right`, `y`, `center_y`, and `top` properties directly (not
    dictionary keys). For example, instead of `pos: root.x, root.top - self.height`
    (line 64), we should have used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The properties `x`, `center_x`, `right`, `y`, `center_y`, and `top` always specify
    **fixed coordinates** (pixels), and not proportional ones. If we want to use **proportional
    coordinates**, we have to be inside a `Layout` (or an `App`) and use the `pos_hint`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also force a `Layout` to use fixed values, but there can be conflicts
    if we are not careful with the properties. If we use any `Layout`; `pos_hint`
    and `size_hint` take priority. If we want to use fixed positioning properties
    (`pos`, `x`, `center_x`, `right`, `y`, `center_y`, `top`), we have to ensure that
    we are not using the `pos_hint` property. Second, if we want to use the `size`,
    `height`, or `width` properties, then we need to set a `None` value to the `size_hint`
    axis we want to use with absolute values. For example, `size_hint: (None, .10)`
    allows us to use height property, but it keeps the width of 10 percent for the
    window''s size.'
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes what we have seen about the positioning and sizing
    properties. The first and second columns indicate the name of the property and
    its respective value. The third and fourth column indicate whether it is available
    for layouts and for widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Value | For layouts | For widgets |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **`size_hint`** | A pair `w`, `h`: `w`, and `h` express a proportion (from
    `0` to `1` or `None`). | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **`size_hint_x`****`size_hint_y`** | A proportion from `0` to `1` or `None`,
    indicating width (`size_hint_x`) or height (`size_hint_y`). | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **`pos_hint`** | Dictionary with one x-axis key (`x`, `center_x`, or `right`)
    and one y-axis key (`y`, `center_y`, or `top`). The values are proportions from
    `0` to `1`. | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **`size`** | A pair `w`, `h`: `w` and `h` indicating fixed width and height
    in pixels. | Yes, but set `size_hint: (None, None)` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **`width`** | Fixed number of pixels. | Yes, but set `size_hint_x: None`
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **`height`** | Fixed number of pixels. | Yes, but set `size_hint_y: None`
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **`pos`** | A pair `x`, `y` indicating a fixed coordinate (`x`, `y`) in pixels.
    | Yes, but don''t use `pos_hint` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **`x, right or center_x`** | Fixed number of pixels. | Yes, but don''t use
    `x, right` or `center_x` in `pos_hint` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **`y, top or center_y`** | Fixed number of pixels. | Yes, but don''t use
    `y, top` or `center_y` in `pos_hint` | Yes |'
  prefs: []
  type: TYPE_TB
- en: We have to be careful because some of the properties behave differently depending
    on the layout we are using. Kivy currently has eight different layouts, which
    are described in the following table. The left-hand side column shows the name
    of the Kivy layout class. The right-hand side column describes briefly how they
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '| Layout | Details |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **`FloatLayout`** | Organizes the widgets with proportional coordinates by
    the `size_hint` and `pos_hint` properties. The values are numbers between 0 and
    1, indicating a proportion to the window size. |'
  prefs: []
  type: TYPE_TB
- en: '| **`RelativeLayout`** | Operates in the same way that `FloatLayout` does,
    but the positioning properties (`pos`, `x`, `center_x`, `right`, `y`, `center_y`,
    `top`) are relative to the `Layout` size and not the window size. |'
  prefs: []
  type: TYPE_TB
- en: '| **`GridLayout`** | Organizes widgets in a grid. You have to specify at least
    one of two properties – `cols` (for columns) or `rows` (for rows). |'
  prefs: []
  type: TYPE_TB
- en: '| **`BoxLayout`** | Organizes widgets in one row or one column depending on
    whether the value of the `orientation` property is `horizontal` or `vertical`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`StackLayout`** | Similar to `BoxLayout`, but it goes to the next row or
    column when it runs out of space. There is more flexibility to set the `orientation`.
    For example, `rl-bt` organizes the widgets in right-to-left, bottom-to-top order.
    Any combination of `lr` (left to right), `rl` (right to left), `tb` (top to bottom),
    and `bt` (bottom to top) is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| **`ScatterLayout`** | Works in a similar manner to `RelativeLayout` but allows
    multitouch gesturing for rotating, scaling, and translating. It is slightly different
    in its implementation, so we will review it later on. |'
  prefs: []
  type: TYPE_TB
- en: '| **`PageLayout`** | Stacks widgets on top of each other, creating a multipage
    effect that allows flipping of pages using side borders. Very often, we will use
    another layout to organize elements inside each of the pages, which are simply
    widgets. |'
  prefs: []
  type: TYPE_TB
- en: 'The Kivy API ([http://kivy.org/docs/api-kivy.html](http://kivy.org/docs/api-kivy.html))
    offers a detailed explanation and good examples of each of the layouts. The behavioral
    difference of the properties depends on the layout, and it is sometimes unexpected.
    Here are some hints that will help us in the GUI building process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size_hint`, `size_hint_x`, and `size_hint_y` work on all the layouts (except
    `PageLayout`), but the behavior might be different. For example, `GridLayout`
    will try to take an average of the x hints and y hints on the same row or column
    respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should use values from 0 to 1 with `size_hint`, `size_hint_x`, and `size_hint_y`.
    However, you can use values higher than 1\. Depending on the layout, Kivy makes
    the widget bigger than the container or tries to recalculate a proportion based
    on the sum of the hints on the same axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pos_hint` only works for `FloatLayout`, `RelativeLayout`, and `BoxLayout`.
    In `BoxLayout`, only the axis-x keys (`x`, `center_x`, `right`) work in the `vertical`
    orientation and vice-versa for the `horizontal` orientation. An analogous rule
    applies for the fixed positioning properties (`pos`, `x`, `center_x`, `right`,
    `y`, `center_y`, and `top`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size_hint`, `size_hint_x`, and `size_hint_y` can always be set as `None` in
    favor of `size`, `width`, and `height`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more properties and particularities of each layout, but with the ones
    covered, we will be able to build almost any GUI. In general, the recommendation
    is to use the layout as it is and, instead of forcing it with the properties we
    are using, it is better to have more layouts and combine them to reach our goals.
    The next section will teach us how to embed layouts and will offer more comprehensive
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Layouts are subclasses of widgets. We have already been embedding widgets inside
    widgets since the beginning (line 43) and it won''t matter if the widgets we are
    embedding are also layouts. In this section, we will work with a comprehensive
    example to explore the effect of the position properties discussed in the previous
    section. The example is not visually appealing, but it will be useful to illustrate
    some concepts and to provide some code that you can use to test different properties.
    The following is the Python code (`layouts.py`) for the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing new in the preceding code – we just created `MyGridLayout`. The final
    output is shown in the next screenshot, with some indications about the different
    layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Embedding layouts](img/B04244_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Embedding layouts
  prefs: []
  type: TYPE_NORMAL
- en: 'In this screenshot, six different Kivy layouts are embedded into a **`GridLayout`**
    of two rows (line 107) in order to show the behavior of different widget properties.
    The code is straightforward, although extensive. Therefore, we are going to study
    the corresponding Kivy language code (`layouts.kv`) in five fragments. The following
    is fragment 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, `MyGridLayout` is defined by the number of rows with the **`rows`**
    property (line 107). Then we add the first two layouts – `FloatLayout` and **`RelativeLayout`**
    with one `Button` each. Both buttons have a defined property of `pos: 0, 0` (lines
    112 and 117) but note in the previous screenshot that the `Button` **F1** (line
    109) is in the bottom-left corner of the whole window, whereas the `Button` **R1**
    (line 114) is in the bottom-left corner of `RelativeLayout`. The reason is that
    the `pos` coordinates in `FloatLayout` are not relative to the position of the
    layout.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `pos_hint` always uses relative coordinates, no matter the layout
    we are using. In other words, the previous example wouldn't have worked if we
    were using `pos_hint` instead of `pos`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fragment 2, one **`GridLayout`** is added to `MyGridLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we use the **`cols`** property to define two columns (line 120)
    and the `spacing` property to separate the internal widgets by 10 pixels from
    each other (line 121). Also, note in the previous screenshot that the first column
    is thinner than the second. We achieved this by setting the `size_hint_x` to `None`
    and `width` to `50` of the buttons **G1** (line 122) and **G3** (line 128).
  prefs: []
  type: TYPE_NORMAL
- en: 'In fragment 3, an **`AnchorLayout`** is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have specified the **`anchor_x`** property to `right` and the **`anchor_y`**
    property to `top` (line 134 and 135) in order to arrange elements in the top-right
    corner of the window as shown in the previous screenshot with both buttons (lines
    136 and 139). This layout is very useful to embed other layouts inside it, for
    example, top menu bars or side bars.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fragment 4, a **`BoxLayout`** is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code illustrates the use of `BoxLayout` with the **`orientation`**
    property set to `horizontal`. Also, the lines 149 and 150 show how to use `size_hint`
    and `pos_hint` to move the button **B2** further up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, fragment 5 adds a **`StackLayout`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we added four buttons of different sizes. It is important to pay
    attention to the previous screenshot on embedding layouts to understand the rules
    that we applied to organize the widgets with the **`orientation`** property set
    to `rl-tb` (right to left, top to bottom, line 155). Also note that the **`padding`**
    property (line 156) adds 10 pixels of space between the widgets and the border
    of `StackLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: PageLayout – swiping pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **`PageLayout`** works in a different manner from other layouts. It is a
    dynamic layout, in the sense that it allows flipping through pages using its borders.
    The idea is that its components are stacked in front of each other, and we can
    just see the one that is on top.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates its use, taking advantage of the example
    from the previous section. The Python code (`pagelayout.py`) is presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing new in this code except the use of the `PageLayout` class.
    For the Kivy language code (`pagelayout.kv`), we will study the properties of
    `PageLayout`. We have simply modified the `layouts.kv` studied in the previous
    section by changing the header of the file (lines 105 to 107), now called `pagelayout.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: All the layouts inherit from a base class called `Layout`. In line 185, we are
    modifying this base class in the same way we did earlier with the `Button` class
    (line 80).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to apply changes to all the child widgets that have a common base
    class (such as `Layout`), we can introduce those changes in the base class. Kivy
    will apply the changes to all the classes that derive from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, layouts don''t have a background color, which is not convenient
    when `PageLayout` stacks them on top of each other, because we can see the elements
    of the layouts on the bottom. Lines 186 to 191 will draw a white (line 187 and
    188) rectangle of the size (line 190) and position (line 191) of the `Layout`.
    In order to do this, we need to use the **`canvas`**, which allows us to draw
    shapes directly on the screen. This topic will be explained in-depth in the next
    chapter ([Chapter 2](ch02.html "Chapter 2. Graphics – the Canvas"), *Graphics
    - The Canvas*). You can see the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PageLayout – swiping pages](img/B04244_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you run the code on your computer, you will notice that it will take you
    to the page corresponding to `AnchorLayout` in the example of the previous section.
    The reason is that we set the **`page`** property to value `3` (line 194). Counting
    from `0`, this property tells Kivy which page to display first. The **`border`**
    property tells Kivy how wide the side borders are (for sliding to the previous
    or the next screen). Finally, **`swipe_threshold`** tells the percentage of the
    screen that we have to slide over, in order to change the page. The next section
    will use some of the layouts and properties learned so far to display a more professional
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Our project – Comic Creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have all the necessary concepts to be able to create any interface we
    want. This section describes the project that we will improve on, as we go through
    the following three chapters – the *Comic Creator*. The basic idea of the project
    is a simple application to draw a stickman. The following screenshot is a sketch
    (wireframe) of the GUI we are aiming for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our project – Comic Creator](img/B04244_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can distinguish several areas in the sketch. First, we need a *drawing space*
    (top-right) for our comics. We need a *tool box* (top-left) with some drawing
    tools to draw our figures and also some *general options* (second from bottom
    to top) – clear the screen, remove the last element, group elements, change color,
    and use the gestures mode. Finally, it would be useful to have a *status bar*
    (center-bottom) to provide some information to the user – number of figures and
    last action performed. According to what we have learned in this chapter, there
    are multiple solutions to organize this screen. We will use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnchorLayout` for the *tool box* area in the top-left corner. Inside it will
    be a `GridLayout` of two columns for the *drawing tools*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnchorLayout` for the *drawing space* in the top-right corner. Inside it will
    be a `RelativeLayout` to have a relative space to draw in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnchorLayout` for the *general options* and *status bar* area at the bottom.
    Inside it will be a `BoxLayout` with vertical orientation to organize the *general
    options* on top of the *status bar*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BoxLayout` with horizontal orientation for the buttons of the *general options*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BoxLayout` with horizontal orientation for the labels of the *status bar*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to use that structure by creating different files for each area
    – `comiccreator.py`, `comiccreator.kv`, `toolbox.kv`, `generaltools.kv`, `drawingspace.kv`,
    and `statusbar.kv`. Let''s start with `comiccreator.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are explicitly loading some of the files with the `Builder.load_file`
    instruction (lines 203 to 206). There is no need to explicitly load `comiccreator.kv`
    because Kivy automatically loads it by extracting the first part of the `ComicCreatorApp`
    name. For `ComicCreator`, we choose `AnchorLayout`. It is not the only option,
    but it gives clarity to the code, because the second level is also composed of
    `AnchorLayout` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Even though using a simple widget would have been clear, it is not possible,
    because the `Widget` class doesn't honor the `size_hint` and `pos_hint` properties
    that are necessary in the `AnchorLayout` internals.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that only layouts honor the `size_hint` and `pos_hint` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `comiccreator.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code follows the previously presented structure for the *Comic Creator*.
    There are basically three `AnchorLayout` instances in the first level (lines 219,
    226, and 233) and a `BoxLayout` that organizes the *general options* and the *status
    bar* (line 236).
  prefs: []
  type: TYPE_NORMAL
- en: We set the width of the `ToolBox` to 100 pixels and the height of the `GeneralOptions`
    and `StatusBar` to 48 and 24 pixels respectively (lines 241 and 245). This brings
    with it an interesting problem – the *drawing space* should use the remaining
    width and height of the screen (no matter the screen size). In order to achieve
    this, we will take advantage of the Kivy **id** (lines 223, 239, and 243), which
    allows us to refer to other components inside the Kivy language. On lines 231
    and 232, we subtract `tool_box.width` from `root.width` (line 231) and `general_options.height`
    and `status_bar.height` from `root.height` (line 232).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Kivy **id** allows us to create internal variables in order to access properties
    of other widgets inside the Kivy language rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s continue exploring the Kivy language in the `toolbox.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a `ToolButton` class that defines the size of the drawing tools
    and also introduces a new Kivy widget – **`ToggleButton`**. The difference with
    the normal `Button` is that it stays pressed until we click on it again. The following
    is an example of the *tool box* with a `ToolButton` activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our project – Comic Creator](img/B04244_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A `ToggleButton` instance can be associated with other `ToggleButton` instances,
    so just one of them is clicked on at a time. We can achieve this by assigning
    the same **`group`** property (line 250) to the `ToggleButton` instances that
    we want to react together. In this case, we want all the instances of `ToolButton`
    belonging to the same group, because we want to draw just one figure at a time;
    we make it part of the class definition (line 247).
  prefs: []
  type: TYPE_NORMAL
- en: On line 252, we implement `ToolBox` as a subclass of `GridLayout` and we add
    some character placeholders (`'O'`, `'/'`, and `'?'`) to the `ToolButton` instances
    that we will substitute for something more appropriate in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for `generaloptions.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of how inheritance can help us separate our components.
    We are using `ToggleButton` instances (lines 269 and 273), and they are not affected
    by the previous `ToolButton` implementation. Also, we didn''t associate them to
    any `group`, so they are independent of each other and will just keep a mode or
    state. The code only defines the `GeneralOptions` class following our initial
    structure. The following is the resulting screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our project – Comic Creator](img/B04244_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `statusbar.kv` file is very similar in the way it uses `BoxLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is that it organizes labels and not buttons. The following is
    the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our project – Comic Creator](img/B04244_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the code for `drawingspace.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Apart from defining that `DrawingSpace` is a subclass of `RelativeLayout`, we
    introduce the Kivy **`markup`**, a nice feature for styling the text of the `Label`
    class. It works in a similar manner to XML-based languages. For example, in HTML,
    `<b>I am bold</b>` would specify bold text. First, you have to activate it (line
    285) and then you just embed the text you want to style between `[tag]` and `[/tag]`
    (line 286). You can find the complete tag list and description in the Kivy API,
    in the documentation for `Label` ([http://kivy.org/docs/api-kivy.uix.label.html](http://kivy.org/docs/api-kivy.uix.label.html)).
    In the previous example, `size` and `color` are self-explanatory; `sub` refers
    to subindexed text; `b` to bold; and `i` to italics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot that shows the GUI of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our project – Comic Creator](img/B04244_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following chapters, we are going to add the respective functionality
    to this interface that, for now, consists of placeholder widgets. However, it
    is exciting what we got with just a few lines of code. Our GUI is ready to go
    and we will be working on its logic from now on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered all the basics and introduced some not-so-basic concepts
    of Kivy. We covered how to configure classes, instances, and templates. Here is
    a list of Kivy elements we have learned to use in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic widgets – `Widget`, `Button`, `ToggleButton`, and `Label`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layouts – `FloatLayout`, `RelativeLayout`, `BoxLayout`, `GridLayout`, `StackLayout`,
    `AnchorLayout`, and `PageLayout`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties – `pos`, `x`, `y`, `center_x`, `center_y`, `top`, `right`, `size`,
    `height`, `width`, `pos_hint`, `size_hint`, `group`, `spacing`, `padding`, `color`,
    `text`, `font_size`, `cols`, `rows`, `orientation`, `anchor_x`, and `anchor_y`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables – `self` and `root`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Others – `id` and the markup tags `size`, `color`, `b`, `i`, and `sub`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more elements from the Kivy language that we can use, but with
    this chapter, we have understood the general idea of how to organize elements.
    With the help of the Kivy API, we should be able to display most of the elements
    available for GUI design. There is, however, a very important element we need
    to study separately – the `canvas`, which allows us to draw vector shapes inside
    widgets, such as the white rectangle we draw as background in the `PageLayout`
    example. It is a very important topic to master in Kivy, and the entire next chapter,
    *Graphics - The Canvas*, will be dedicated to it.
  prefs: []
  type: TYPE_NORMAL
