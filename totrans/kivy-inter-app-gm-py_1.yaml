- en: Chapter 1. GUI Basics – Building an Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. GUI 基础 – 构建界面
- en: 'Kivy is a free, open source Python library that allows for quick and easy development
    of highly interactive multiplatform applications. Kivy''s execution speed is comparable
    to the native mobile alternative, Java for Android or Objective C for iOS. Moreover,
    Kivy has the huge advantage of being able to run on multiple platforms, just as
    HTML5 does; in which case, Kivy performs better because it doesn''t rely on a
    heavy browser, and many of its components are implemented in C using the Cython
    library in such a way that most of the graphics processing runs directly in the
    GPU. Kivy strikes a great balance between performance and portability across various
    hardware and software environments. Kivy emerges with a simple but ambitious goal
    in mind:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 是一个免费的开源 Python 库，它允许快速轻松地开发高度交互的多平台应用程序。Kivy 的执行速度与原生移动替代方案相当，例如 Android
    的 Java 或 iOS 的 Objective C。此外，Kivy 有一个巨大的优势，即能够在多个平台上运行，就像 HTML5 一样；在这种情况下，Kivy
    的性能更好，因为它不依赖于沉重的浏览器，并且许多组件都是使用 Cython 库在 C 中实现的，这样大多数图形处理都直接在 GPU 中运行。Kivy 在各种硬件和软件环境中在性能和可移植性之间取得了很好的平衡。Kivy
    以一个简单但雄心勃勃的目标出现：
- en: '*"… same code for every platform, at least what we use every day: Linux/Windows/Mac
    OS X/Android/iOS"*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"…每个平台相同的代码，至少是我们每天使用的：Linux/Windows/Mac OS X/Android/iOS"*'
- en: Mathieu Virbel ([http://txzone.net/2011/01/kivy-next-pymt-on-android-step-1-done/](http://txzone.net/2011/01/kivy-next-pymt-on-android-step-1-done/))
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Mathieu Virbel ([http://txzone.net/2011/01/kivy-next-pymt-on-android-step-1-done/](http://txzone.net/2011/01/kivy-next-pymt-on-android-step-1-done/))
- en: This support has being extended to Raspberry Pi, thanks to a crowd funding campaign
    started by Mathieu Virbel, the creator of Kivy. Kivy was introduced for the first
    time at EuroPython 2011 as a Python framework designed for creating natural user
    interfaces. Since then, it has grown bigger and attracted an enthusiastic community.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种支持已经扩展到 Raspberry Pi，这要归功于 Mathieu Virbel 发起的众筹活动，他是 Kivy 的创造者。Kivy 首次在 2011
    年的 EuroPython 上推出，作为一个用于创建自然用户界面的 Python 框架。从那时起，它已经变得更大，并吸引了一个热情的社区。
- en: 'This book requires some knowledge of Python, and very basic terminal skills,
    but also it requires some understanding of **Object-Oriented Programming** (**OOP**)
    concepts. In particular, it is assumed that you understand the concept of **inheritance**
    and the difference between **instances** and **classes**. Refer to the following
    table to review some of these concepts:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书需要一些 Python 知识，以及非常基本的终端技能，但它还要求您理解一些面向对象编程（**OOP**）的概念。特别是，假设您理解了继承的概念以及实例和类之间的区别。参考以下表格来回顾一些这些概念：
- en: '| Concept | URL |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | URL |'
- en: '| --- | --- |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| OOP | [http://en.wikipedia.org/wiki/Object-oriented_programming](http://en.wikipedia.org/wiki/Object-oriented_programming)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 面向对象编程 | [http://en.wikipedia.org/wiki/Object-oriented_programming](http://en.wikipedia.org/wiki/Object-oriented_programming)
    |'
- en: '| Inheritance | [http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)](http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming))
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 继承 | [http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)](http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming))
    |'
- en: '| Instance | [http://en.wikipedia.org/wiki/Instance_(computer_science)](http://en.wikipedia.org/wiki/Instance_(computer_science))
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 实例 | [http://en.wikipedia.org/wiki/Instance_(computer_science)](http://en.wikipedia.org/wiki/Instance_(computer_science))
    |'
- en: '| Class | [http://en.wikipedia.org/wiki/Class_(computer_science)](http://en.wikipedia.org/wiki/Class_(computer_science))
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 类 | [http://en.wikipedia.org/wiki/Class_(computer_science)](http://en.wikipedia.org/wiki/Class_(computer_science))
    |'
- en: 'Before we start, you will need to install Kivy. The installation process for
    all different platforms is documented and regularly updated on the Kivy website:
    [http://kivy.org/docs/installation/installation.html](http://kivy.org/docs/installation/installation.html).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，您需要安装 Kivy。所有不同平台的安装过程都有文档记录，并且定期在 Kivy 网站上更新：[http://kivy.org/docs/installation/installation.html](http://kivy.org/docs/installation/installation.html)。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All code in this book has been tested with Kivy 1.9.0 and both Python 2.7 and
    Python 3.4 (but 3.3 should work fine as well).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有代码都已使用 Kivy 1.9.0 以及 Python 2.7 和 Python 3.4（但 3.3 也应该可以正常工作）进行测试。
- en: Note that packaging support for mobile is not yet complete for Python 3.3+.
    For now, if we want to create mobile apps for Android or iOS, we should use Python
    2.7\. If you want to know your Python version, you can execute `python -V` in
    a terminal to check your installed Python version.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python 3.3+版本对移动端的支持尚未完成。目前，如果我们想为Android或iOS创建移动应用，我们应该使用Python 2.7。如果您想了解您的Python版本，您可以在终端中执行`python
    -V`来检查已安装的Python版本。
- en: In this chapter, we start by creating user interfaces using one of Kivy's most
    fun and powerful components – the Kivy language (`.kv`). The Kivy Language separates
    logic from presentation in order to keep an easy and intuitive code; it also links
    components at an interface level. In future chapters, you will also learn how
    to build and modify interfaces dynamically using pure Python code and Kivy as
    a library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先使用Kivy最有趣和最有力的组件之一 – Kivy语言（`.kv`）来创建用户界面。Kivy语言将逻辑与表示分离，以保持代码的简单直观；它还将在界面级别链接组件。在未来的章节中，您还将学习如何使用纯Python代码和Kivy作为库动态构建和修改界面。
- en: 'Here is a list of all the skills that you are about to learn:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您即将学习到的所有技能列表：
- en: Launching a Kivy application
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动Kivy应用程序
- en: Using the Kivy language
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kivy语言
- en: Instantiating and personalizing widgets (GUI components) through basic properties
    and variables
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过基本属性和变量实例化和个性化小部件（GUI组件）
- en: Differentiating between fixed, proportional, absolute, and relative coordinates
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分固定、比例、绝对和相对坐标
- en: Creating responsive GUIs through layouts
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过布局创建响应式GUI
- en: Modularizing code in different files
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的文件中模块化代码
- en: This chapter covers all the basics for building a **Graphical User Interface**
    (**GUI**) in Kivy. First, we will learn techniques to run an application and how
    to use and integrate widgets. After that, we will introduce the main project of
    the book, the *Comic Creator*, and program the main structure of the GUI that
    we will continue using in the following two chapters. At the end of this chapter,
    you will be able to build a GUI starting from a pencil and paper sketch, and also
    learn some techniques to make the GUI responsive to the size of the window.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了在Kivy中构建**图形用户界面**（GUI）的所有基础知识。首先，我们将学习运行应用程序的技术以及如何使用和集成小部件。之后，我们将介绍本书的主要项目，即*漫画创作者*，并编写GUI的主要结构，我们将在接下来的两章中继续使用。在本章结束时，您将能够从铅笔和纸张草图开始构建GUI，并学习一些使GUI能够响应窗口大小的技术。
- en: Basic interface – Hello World!
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本界面 – Hello World！
- en: Let's put our hands on our first code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动手编写我们的第一个代码。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'The following is a Hello World program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个“Hello World”程序：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is merely Python code. Launching a Kivy program is not any different from
    launching any other Python application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是Python代码。启动Kivy程序与启动任何其他Python应用程序没有区别。
- en: 'In order to run the code, you open a terminal (line of commands or console)
    and specify the following command in Windows or Linux: `python hello.py --size=150x100`
    (`--size` is a parameter to specify the screen size).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行代码，您需要在Windows或Linux中打开一个终端（命令行或控制台），并指定以下命令：`python hello.py --size=150x100`（`--size`是一个用于指定屏幕大小的参数）。
- en: On a Mac, you must type in `kivy` instead of `python` after installing `Kivy.app`
    in `/Applications`. Lines 2 and 3 verify that we have the appropriate version
    of Kivy installed on our computer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，您必须在`/Applications`中安装`Kivy.app`后输入`kivy`而不是`python`。第2行和第3行验证我们在计算机上安装了适当的Kivy版本。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you try to launch our application with an older Kivy version (say 1.8.0)
    than the specified version, then line 3 will raise an `Exception` error. This
    `Exception` is not raised if we have a more recent version.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用比指定版本更旧的Kivy版本（比如1.8.0）启动我们的应用程序，那么第3行将引发`Exception`错误。如果我们有一个更新的版本，则不会引发此`Exception`错误。
- en: We omit the call to `kivy.require` in most of the examples in the book, but
    you will find it in the code that you download online ([https://www.packtpub.com](https://www.packtpub.com)/),
    and its use is strongly encouraged in real-life projects. The program uses two
    classes from the Kivy library (lines 5 and 6) – `App` and `Label`. The class **`App`**
    is the starting point of any Kivy application. Consider `App` as the empty window
    where we will add other Kivy components.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的大多数示例中，我们省略了对`kivy.require`的调用，但您将在您在线下载的代码中找到它（[https://www.packtpub.com](https://www.packtpub.com)/），并且强烈建议在实际项目中使用它。程序使用Kivy库中的两个类（第5行和第6行）
    – `App`和`Label`。类**`App`**是任何Kivy应用程序的起点。将`App`视为我们将添加其他Kivy组件的空窗口。
- en: We use the `App` class through **inheritance**; the `App` class becomes the
    base class of the `HelloApp` subclass or child class (line 8). In practice, this
    means that the `HelloApp` class has all the variables and methods of `App`, plus
    whatever we define in the body (lines 9 and 10) of the `HelloApp` class. Most
    importantly, `App` is the starting point of any Kivy application. We can see that
    line 13 creates an instance of `HelloApp` and runs it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过**继承**使用`App`类；`App`类成为`HelloApp`子类或子类的基类（第8行）。在实践中，这意味着`HelloApp`类具有`App`类的所有变量和方法，以及我们在`HelloApp`类的主体（第9行和第10行）中定义的任何内容。最重要的是，`App`是任何Kivy应用程序的起点。我们可以看到第13行创建了一个`HelloApp`实例并运行了它。
- en: Now the `HelloApp` class's body just overrides one of the existing `App` class's
    methods, the `build(self)` method. This method has to return the window content.
    In our case, a **`Label`** that holds the text **Hello World**`!` (line 10). A
    **Label** is a **widget** that allows you to display some text on the screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`HelloApp`类的主体只是覆盖了现有的`App`类的一个方法，即`build(self)`方法。这个方法必须返回窗口内容。在我们的例子中，是一个**`Label`**，它包含文本**Hello
    World**`!`（第10行）。**Label**是一个允许你在屏幕上显示一些文本的**小部件**。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **widget** is a Kivy GUI component. Widgets are the minimal graphical units
    that we put together in order to create user interfaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**小部件**是Kivy GUI组件。小部件是我们为了创建用户界面而组合的最小图形单元。'
- en: 'The following screenshot shows the resulting screen after executing the `hello.py`
    code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了执行`hello.py`代码后的结果屏幕：
- en: '![Basic interface – Hello World!](img/B04244_01_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![基本界面 – Hello World!](img/B04244_01_01.jpg)'
- en: So, is Kivy just another library for Python? Well, yes. But as part of the library,
    Kivy offers its own language in order to separate the logic from the presentation
    and to link elements of the interface. Moreover, remember that this library will
    allow you to port your applications to many platforms.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Kivy仅仅是另一个Python库吗？嗯，是的。但作为库的一部分，Kivy提供自己的语言，以便将逻辑与表示分离，并将界面元素链接起来。此外，请记住，这个库将允许您将应用程序移植到许多平台。
- en: 'Let''s start to explore the Kivy language. We will separate the previous Python
    code into two files, one for the presentation (interface), and another for the
    logic. The first file includes the Python lines:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索Kivy语言。我们将把之前的Python代码分成两个文件，一个用于表示（界面），另一个用于逻辑。第一个文件包括以下Python行：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `hello2.py` code is very similar to `hello.py`. The difference is that the
    method `build(self)` doesn't have the **Hello World!** message. Instead, the message
    has been moved to the `text` property in the Kivy language file (`hello2.kv`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello2.py`代码与`hello.py`非常相似。区别在于`build(self)`方法没有**Hello World!**消息。相反，消息已被移动到Kivy语言文件（`hello2.kv`）中的`text`属性。'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **property** is an attribute that can be used to change the content, appearance,
    or behavior of a widget.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**是一个可以用来改变小部件内容、外观或行为的属性。'
- en: 'The following is the code (rules) of `hello2.kv`, which shows how we modify
    the `Label` content with the `text` property (line 27):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`hello2.kv`的代码（规则），它显示了如何使用`text`属性修改`Label`内容（第27行）：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You might wonder how Python or Kivy knows that these two files (`hello2.py`
    and `hello2.kv`) are related. This tends to be confusing at the beginning. The
    key is in the name of the subclass of `App`, which in this case is `HelloApp`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道Python或Kivy如何知道这两个文件（`hello2.py`和`hello2.kv`）是相关的。这通常在开始时令人困惑。关键是`App`子类的名称，在这个例子中是`HelloApp`。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The beginning part of the `App` class's subclass name must coincide with the
    name of the Kivy file. For example, if the definition of the class is `class FooApp(App)`,
    then the name of the file has to be `foo.kv` and in the same directory of the
    main file (the one that executes the `run()` method of `App`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`类子类名称的开头部分必须与Kivy文件名相匹配。例如，如果类的定义是`class FooApp(App)`，那么文件名必须是`foo.kv`，并且位于主文件（执行`App`的`run()`方法的文件）所在的同一目录中。'
- en: Once that consideration is included, this example can be run in the same way
    we ran the previous one. We just need to be sure we are calling the main file
    – `python hello2.py -–size=150x100`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包含了这个考虑，这个例子就可以像我们运行上一个例子那样运行。我们只需确保我们调用的是主文件 - `python hello2.py --size=150x100`。
- en: This is our first contact with the Kivy language, so we should have an in-depth
    look at it. Line 25 (`hello2.kv`) tells Python the minimal version of Kivy that
    should be used. It does the same thing as the previous lines 2 and 3 do in `hello.py`.
    The instructions that start with `#:` in the header of a Kivy language are called
    **directives**. We will also be omitting the version directive throughout the
    rest of this book, but remember to include it in your own projects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次接触Kivy语言，因此我们应该深入了解一下。第25行（`hello2.kv`）告诉Python应该使用Kivy的最小版本。它与`hello.py`中前两行所做的相同。在Kivy语言头部以`#:`开头的指令被称为**指令**。我们将在本书的其余部分省略版本指令，但请记住在你的项目中包含它。
- en: The `<Label>:` rule (line 26) indicates that we are going to modify the `Label`
    class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Label>:`规则（第26行）表示我们将要修改`Label`类。'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Kivy language is expressed as a sequence of rules. A **rule** is a piece
    of code that defines the content, behavior, and appearance of a Kivy widget class.
    A rule always starts with a widget class name in angle brackets followed by a
    colon, like this, `<Widget Class>:`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy语言以一系列规则的形式表达。**规则**是一段代码，它定义了Kivy小部件类的内 容、行为和外观。一个规则总是以尖括号内的一个小部件类名开头，后面跟着一个冒号，例如这样，`<Widget
    Class>:`
- en: Inside the rule, we set the `text` property with `'Hello World!'` (line 27).
    The code in this section will generate the same output screen as before. In general,
    everything in Kivy can be done using pure Python and importing the necessary classes
    from the Kivy library, as we did in the first example (`hello.py`). However, there
    are many advantages of using the Kivy language and therefore this book explains
    all the presentation programming in the Kivy language, unless we need to add dynamic
    components, in which case using Kivy as a traditional Python library is more appropriate.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在规则内部，我们使用`'Hello World!'`（第27行）设置了`text`属性。本节中的代码将生成与之前相同的输出屏幕。一般来说，Kivy中的所有事情都可以使用纯Python和从Kivy库中导入必要的类来完成，就像我们在第一个例子（`hello.py`）中所做的那样。然而，使用Kivy语言有许多优点，因此本书解释了所有Kivy语言中的展示编程，除非我们需要添加动态组件，在这种情况下，使用Kivy作为传统的Python库更为合适。
- en: If you are an experienced programmer, you might have worried that modifying
    the `Label` class affects all the instances we could potentially create from `Label`,
    and therefore they will all contain the same `Hello World` text. That is true,
    and we are going to study a better approach to doing this in the following section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一位经验丰富的程序员，你可能担心修改`Label`类会影响我们从`Label`创建的所有潜在实例，因此它们都将包含相同的`Hello World`文本。这是真的，我们将在下一节研究一个更好的方法来做这件事。
- en: Basic widgets – labels and buttons
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本小部件 - 标签和按钮
- en: In the last section, we used the `Label` class, which is one of the multiple
    widgets that Kivy provides. You can think of widgets as interface blocks that
    we use to set up a GUI. Kivy has a complete set of widgets – buttons, labels,
    checkboxes, dropdowns, and many more. You can find them all in the API of Kivy
    under the package `kivy.uix` ([http://kivy.org/docs/api-kivy.html](http://kivy.org/docs/api-kivy.html)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们使用了`Label`类，这是Kivy提供的多个小部件之一。你可以把小部件想象成我们用来设置GUI的界面块。Kivy有一套完整的小部件
    - 按钮、标签、复选框、下拉菜单等等。你可以在Kivy的API中找到它们，位于`kivy.uix`包下（[http://kivy.org/docs/api-kivy.html](http://kivy.org/docs/api-kivy.html)）。
- en: 'We are going to learn the basics of how to create our own personalized widget
    without affecting the default configuration of Kivy widgets. In order to do that,
    we will use inheritance to create the `MyWidget` class in the `widgets.py` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何创建我们自己的个性化小部件的基本知识，而不会影响Kivy小部件的默认配置。为了做到这一点，我们将在`widgets.py`文件中使用继承来创建`MyWidget`类：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In line 32, we inherit from the base class **`Widget`** and create the subclass
    `MyWidget`. It is a general practice to create your own `Widget` for your applications
    instead of using the Kivy classes directly, because we want to avoid applying
    our changes to all future instances of the widget Kivy class. In the case of our
    previous example (`hello2.kv`), modifying the `Label` class (line 26) would affect
    all of its future instances. In line 37, we instantiated `MyWidget` instead of
    `Label` directly (as we did in `hello2.py`), so we can now distinguish between
    our widget (`MyWidget`) and the Kivy widget (`Widget`). The rest of the code is
    analogous to what we covered before.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第32行，我们继承自基类**`Widget`**并创建了子类`MyWidget`。创建自己的`Widget`而不是直接使用Kivy类是通用的做法，因为我们希望避免将我们的更改应用到所有未来实例的Kivy
    `Widget`类。在我们的前一个例子（`hello2.kv`）中，修改`Label`类（第26行）将影响其所有未来的实例。在第37行，我们直接实例化了`MyWidget`而不是`Label`（就像我们在`hello2.py`中做的那样），因此我们现在可以区分我们的小部件（`MyWidget`）和Kivy小部件（`Widget`）。其余的代码与之前我们覆盖的内容类似。
- en: 'The following is the corresponding Kivy language code (`widgets.kv`):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的Kivy语言代码（`widgets.kv`）：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that now we are using **buttons** instead of labels. Most of the basic
    widgets in Kivy work in similar ways. In fact, **`Button`** is just a subclass
    of `Label` that incorporates more properties such as background color.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们使用的是**按钮**而不是标签。Kivy中的大多数基本小部件以类似的方式工作。实际上，**`Button`**只是`Label`的子类，它包含更多的属性，如背景颜色。
- en: Compare the notation of line 26 (`<Label>:`) in `hello2.kv` with line 43 (`Button:`)
    of the preceding code (`widgets.kv`). We used the rule class notation (`<Class>:`)
    for the `Label` (and `MyWidget`) class, but a different notation (`Instance:`)
    for `Button`. In this way, we defined that `MyWidget` has two instances of `Button`
    (line 43 and 49).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将`hello2.kv`中第26行的注释（`<Label>:`）与前面代码（`widgets.kv`）中的第43行（`Button:`）进行比较。我们为`Label`（和`MyWidget`）类使用了规则类注释（`<Class>:`），但对于`Button`使用了不同的注释（`Instance:`）。这样，我们定义了`MyWidget`有两个`Button`实例（第43行和第49行）。
- en: Finally, we set the properties of the `Button` instances. The **`font_size`**
    property sets the size of the text. The **`color`** property sets the text color
    and is specified in RGBA format (red, green, blue, and alpha/transparency). The
    properties **`size`** and **`pos`** set the size and position of the widget and
    consist of a pair of **fixed coordinates** (x for horizontal and y for vertical),
    the exact pixels on the window.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置了`Button`实例的属性。**`font_size`**属性设置文本的大小。**`color`**属性设置文本颜色，并指定为RGBA格式（红色、绿色、蓝色和alpha/透明度）。**`size`**和**`pos`**属性设置小部件的大小和位置，由一对**固定坐标**（x为水平，y为垂直）组成，即窗口上的确切像素。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that the coordinate (0, 0) is located at the bottom-left corner, the Cartesian
    origin. Many other languages (including CSS) use the top-left corner as the (0,
    0) coordinate, so take note!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，坐标（0，0）位于左下角，即笛卡尔原点。许多其他语言（包括CSS）使用左上角作为（0，0）坐标，所以请注意！
- en: 'The following screenshot shows the output of `widgets.py` and `widgets.kv`
    with some helpful annotations:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`widgets.py`和`widgets.kv`的输出，并带有一些有用的注释：
- en: '![Basic widgets – labels and buttons](img/B04244_01_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![基本小部件 – 标签和按钮](img/B04244_01_02.jpg)'
- en: 'A couple of things can be improved in the previous code (`widgets.kv`). First,
    there are some repeated properties for both buttons: `pos`, `color`, and `font_size`.
    Instead of that, let''s create our own `Button` as we did with `MyWidget` so it
    will be easy to keep the buttons'' design consistent. Second, the fixed position
    is quite annoying because the widgets don''t adjust when the screen is resized.
    Let''s make it responsive to the screen size in the `widgets2.kv` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码（`widgets.kv`）中，有一些可以改进的地方。首先，按钮有一些重复的属性：`pos`、`color`和`font_size`。相反，让我们像创建`MyWidget`一样创建自己的`Button`，这样就可以轻松保持按钮设计的统一。其次，固定位置相当烦人，因为当屏幕大小调整时，小部件不会调整。让我们在`widgets2.kv`文件中使其对屏幕大小做出响应：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code (`widgets2.kv`), we create (`<MyButton@Button>:`) and customize
    the `MyButton` class (lines 56 to 59) and instances (line 62 to 67). Note the
    differences in the manner we defined `MyWidget` and `MyButton`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码（`widgets2.kv`）中，我们创建并自定义了`MyButton`类（第56至第59行）和实例（第62至第67行）。注意我们定义`MyWidget`和`MyButton`的方式之间的差异。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because we did not define the `MyButton` base class in `widgets.py` as we did
    with `MyWidget` (line 32 of `widgets.py`), we have to specify `@Class` in the
    Kivy language rule (line 56). In the `MyWidget` class case, we also needed to
    define its class from the Python side because we instantiated it directly (line
    37 of `widgets.py`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有在`widgets.py`中将`MyButton`基类定义为`MyWidget`（`widgets.py`的第32行），我们必须在Kivy语言规则（第56行）中指定`@Class`。在`MyWidget`类的情况下，我们也需要从Python端定义它的类，因为我们直接实例化了它（`widgets.py`的第37行）。
- en: In this example, each `Button` class's position is responsive in the sense that
    they are always in the corners of the screen, no matter what the window size is.
    In order to achieve that, we need to use two internal variables – **`self`** and
    **`root`**. You might be familiar with the variable **`self`**. As you have probably
    guessed, it is just a reference to the `Widget` itself. For example, `self.height`
    (line 64) has a value of `50` because that is the height of that particular `MyButton`
    class. The variable **`root`** is a reference to the `Widget` class at the top
    of the hierarchy. For example, the `root.x` (line 64) has a value of `0` because
    that is the position in X-axis of the `MyWidget` instance created on line 37 of
    `widgets.py`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个`Button`类的位置都是响应式的，这意味着它们始终位于屏幕的角落，无论窗口大小如何。为了实现这一点，我们需要使用两个内部变量——**`self`**和**`root`**。你可能对变量**`self`**很熟悉。正如你可能猜到的，它只是对`Widget`本身的引用。例如，`self.height`（第64行）的值为`50`，因为那是特定`MyButton`类的高度。变量**`root`**是对层次结构顶部的`Widget`类的引用。例如，`root.x`（第64行）的值为`0`，因为那是`MyWidget`实例在`widgets.py`的第37行创建时的X轴位置。
- en: '`MyWidget` uses all of the window''s space by default; therefore, the origin
    is (0, 0). The **`x`** and **`y`** and **`width`** and **`height`** are also widget
    properties, which we can use to disjoint `pos` and `size` respectively.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyWidget`默认使用整个窗口空间；因此，原点是（0，0）。`x`、`y`、`width`和`height`也是小部件属性，我们可以使用它们分别断开`pos`和`size`。'
- en: Fixed coordinates are still a laborious way to organize widgets and elements
    in the window. Let's move on to something smarter – layouts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 固定坐标仍然是组织窗口中的小部件和元素的一种费力的方式。让我们转向更智能的方法——布局。
- en: Layouts
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: No doubt, fixed coordinates are the most flexible way to organize elements in
    an n-dimensional space; however, it is very time consuming. Instead, Kivy provides
    a set of layouts that will facilitate the work of organizing widgets. A **`Layout`**
    is a `Widget` subclass that implements different strategies to organize embedded
    widgets. For example, one strategy could be organizing widgets in a grid (`GridLayout`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，固定坐标是组织多维空间中元素的最灵活方式；然而，它非常耗时。相反，Kivy提供了一套布局，将简化组织小部件的工作。**`Layout`**是一个实现不同策略来组织嵌入小部件的`Widget`子类。例如，一种策略可以是按网格（`GridLayout`）组织小部件。
- en: Let's start with a simple **`FloatLayout`** example. It works in a very similar
    manner to the way we organize widgets directly inside of another `Widget` subclass,
    except that now we can use **proportional coordinates** ("percentages" of the
    total size of the window) rather than fixed coordinates (exact pixels).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的**`FloatLayout`**例子开始。它的工作方式与我们直接在另一个`Widget`子类内部组织小部件的方式非常相似，只是现在我们可以使用**比例坐标**（窗口总大小的“百分比”）而不是固定坐标（精确像素）。
- en: 'That means that we won''t need the calculations we did in the previous section
    with `self` and `root`. Here is the Python code of an example that resembles the
    previous one:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不需要在上一节中使用`self`和`root`所做的计算。以下是一个与上一个例子相似的Python代码示例：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is nothing really new in the preceding code (`floatlayout.py`), except
    the use of `FloatLayout` (line 75). The interesting parts are in the corresponding
    Kivy language (`floatlayout.kv`):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码（`floatlayout.py`）中，并没有真正的新内容，除了使用了`FloatLayout`（第75行）。有趣的部分在于相应的Kivy语言（`floatlayout.kv`）中：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In `floatlayout.kv`, we use two new properties – **`size_hint`** (line 83) and
    **`pos_hint`** (lines 88 and 91) .They are similar to `size` and `pos` but receive
    proportional coordinates with values ranging from `0` to `1`; (0, 0) is the bottom-left
    corner and (1, 1) is the top-right corner. For example, the `size_hint` property
    on line 83 sets the width to 40 percent of the window width and the height to
    30 percent of the current window height. Something similar happens to the `pos_hint`
    property (lines 88 and 91 but the notation is different – a Python dictionary
    where the keys (for example, `'x'` or `'top'`) indicate which part of the widget
    is referenced. For example, `'x'` is the left border.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`floatlayout.kv`中，我们使用了两个新属性——**`size_hint`**（第83行）和**`pos_hint`**（第88行和第91行）。它们与`size`和`pos`类似，但接收比例坐标，值范围从`0`到`1`；（0，0）是左下角，（1，1）是右上角。例如，第83行的`size_hint`属性将宽度设置为窗口宽度的40%，将高度设置为当前窗口高度的30%。`pos_hint`属性（第88行和第91行）也有类似的情况，但表示方式不同——一个Python字典，其中键（例如，`'x'`或`'top'`）表示引用小部件的哪个部分。例如，`'x'`是左边界。
- en: 'Note that we use the `top` key instead of the `y` one on line 88 and the `right`
    key instead of the `x` one on line 91\. The **`top`** and **`right`** keys respectively
    reference the top and right edges of `Button`. In this case, we could have also
    used `x` and `y` for both axes; for example, we could have written `pos_hint:
    {''x'': .85, ''y'': 0}` as line 91\. However, the **`right`** and **`top`** keys
    avoid us some calculations, making the code clearer.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，我们在第88行使用`top`键代替`y`键，在第91行使用`right`键代替`x`键。**`top`**和**`right`**键分别引用`Button`的顶部和右侧边缘。在这种情况下，我们也可以使用`x`和`y`来表示两个轴；例如，我们可以将第91行写成`pos_hint:
    {''x'': .85, ''y'': 0}`。然而，**`right`**和**`top`**键避免了我们进行一些计算，使代码更清晰。'
- en: 'The next screenshot shows the result, and the available keys for the `pos_hint`
    dictionary:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了结果，以及`pos_hint`字典中可用的键：
- en: '![Layouts](img/B04244_01_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![布局](img/B04244_01_03.jpg)'
- en: 'The available `pos_hint` keys (`x`, **`center_x`**, `right`, `y`, **`center_y`**,
    and `top`) are useful to align the edges or for centering. For example, `pos_hint:
    {''center_x'':.5, ''center_y'':.5}` would align a widget in the middle no matter
    the size of the window.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '可用的`pos_hint`键（`x`、**`center_x`**、`right`、`y`、**`center_y`**和`top`）对于对齐边缘或居中很有用。例如，`pos_hint:
    {''center_x'':.5, ''center_y'':.5}`可以使小部件无论窗口大小如何都居中。'
- en: 'We could have used the `top` and `right` properties with the fixed positioning
    of `widgets2.kv` (line 64 and 67), but note that `pos` doesn''t accept Python
    dictionaries (`{''x'':0,''y'':0}`), just pairs of values exclusively corresponding
    to (`x`, `y`). Therefore, instead of using the `pos` property, we should use the
    `x`, `center_x`, `right`, `y`, `center_y`, and `top` properties directly (not
    dictionary keys). For example, instead of `pos: root.x, root.top - self.height`
    (line 64), we should have used:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '我们本可以使用`top`和`right`属性与`widgets2.kv`的固定定位（第64行和第67行），但请注意`pos`不接受Python字典（`{''x'':0,''y'':0}`），只接受与（`x`，`y`）相对应的值对。因此，我们不应使用`pos`属性，而应直接使用`x`、`center_x`、`right`、`y`、`center_y`和`top`属性（不是字典键）。例如，我们不应使用`pos:
    root.x, root.top - self.height`（第64行），而应使用：'
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The properties `x`, `center_x`, `right`, `y`, `center_y`, and `top` always specify
    **fixed coordinates** (pixels), and not proportional ones. If we want to use **proportional
    coordinates**, we have to be inside a `Layout` (or an `App`) and use the `pos_hint`
    property.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`x`、`center_x`、`right`、`y`、`center_y`和`top`始终指定**固定坐标**（像素），而不是比例坐标。如果我们想使用**比例坐标**，我们必须在`Layout`（或`App`）内部，并使用`pos_hint`属性。
- en: 'We can also force a `Layout` to use fixed values, but there can be conflicts
    if we are not careful with the properties. If we use any `Layout`; `pos_hint`
    and `size_hint` take priority. If we want to use fixed positioning properties
    (`pos`, `x`, `center_x`, `right`, `y`, `center_y`, `top`), we have to ensure that
    we are not using the `pos_hint` property. Second, if we want to use the `size`,
    `height`, or `width` properties, then we need to set a `None` value to the `size_hint`
    axis we want to use with absolute values. For example, `size_hint: (None, .10)`
    allows us to use height property, but it keeps the width of 10 percent for the
    window''s size.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '我们也可以强制`Layout`使用固定值，但如果我们不小心处理属性，可能会出现冲突。如果我们使用任何`Layout`；`pos_hint`和`size_hint`具有优先级。如果我们想使用固定定位属性（`pos`、`x`、`center_x`、`right`、`y`、`center_y`、`top`），我们必须确保我们没有使用`pos_hint`属性。其次，如果我们想使用`size`、`height`或`width`属性，那么我们需要将`size_hint`轴的值设置为`None`，以使用绝对值。例如，`size_hint:
    (None, .10)`允许我们使用高度属性，但保持窗口宽度的10%。'
- en: The following table summarizes what we have seen about the positioning and sizing
    properties. The first and second columns indicate the name of the property and
    its respective value. The third and fourth column indicate whether it is available
    for layouts and for widgets.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了关于定位和尺寸属性我们所看到的内容。第一列和第二列表示属性的名称及其相应的值。第三列和第四列表示它是否适用于布局和小部件。
- en: '| Property | Value | For layouts | For widgets |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 值 | 对于布局 | 对于小部件 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **`size_hint`** | A pair `w`, `h`: `w`, and `h` express a proportion (from
    `0` to `1` or `None`). | Yes | No |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **`size_hint`** | 一对 `w`，`h`：`w` 和 `h` 表示比例（从 `0` 到 `1` 或 `None`）。 | 是 |
    否 |'
- en: '| **`size_hint_x`****`size_hint_y`** | A proportion from `0` to `1` or `None`,
    indicating width (`size_hint_x`) or height (`size_hint_y`). | Yes | No |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **`size_hint_x`** **`size_hint_y`** | 从 `0` 到 `1` 或 `None` 的比例，表示宽度（`size_hint_x`）或高度（`size_hint_y`）。
    | 是 | 否 |'
- en: '| **`pos_hint`** | Dictionary with one x-axis key (`x`, `center_x`, or `right`)
    and one y-axis key (`y`, `center_y`, or `top`). The values are proportions from
    `0` to `1`. | Yes | No |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **`pos_hint`** | 包含一个x轴键（`x`，`center_x` 或 `right`）和一个y轴键（`y`，`center_y` 或
    `top`）的字典。值是从 `0` 到 `1` 的比例。 | 是 | 否 |'
- en: '| **`size`** | A pair `w`, `h`: `w` and `h` indicating fixed width and height
    in pixels. | Yes, but set `size_hint: (None, None)` | Yes |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **`size`** | 一对 `w`，`h`：`w` 和 `h` 表示以像素为单位的固定宽度和高度。 | 是，但需设置 `size_hint:
    (None, None)` | 是 |'
- en: '| **`width`** | Fixed number of pixels. | Yes, but set `size_hint_x: None`
    | Yes |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **`width`** | 固定像素数。 | 是，但需设置 `size_hint_x: None` | 是 |'
- en: '| **`height`** | Fixed number of pixels. | Yes, but set `size_hint_y: None`
    | Yes |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **`height`** | 固定像素数。 | 是，但需设置 `size_hint_y: None` | 是 |'
- en: '| **`pos`** | A pair `x`, `y` indicating a fixed coordinate (`x`, `y`) in pixels.
    | Yes, but don''t use `pos_hint` | Yes |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **`pos`** | 一对 `x`，`y`：表示像素中的固定坐标（`x`，`y`）。 | 是，但不要使用 `pos_hint` | 是 |'
- en: '| **`x, right or center_x`** | Fixed number of pixels. | Yes, but don''t use
    `x, right` or `center_x` in `pos_hint` | Yes |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **`x, right or center_x`** | 固定像素数。 | 是，但不要在 `pos_hint` 中使用 `x, right` 或
    `center_x` | 是 |'
- en: '| **`y, top or center_y`** | Fixed number of pixels. | Yes, but don''t use
    `y, top` or `center_y` in `pos_hint` | Yes |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **`y, top or center_y`** | 固定像素数。 | 是，但不要在 `pos_hint` 中使用 `y, top` 或 `center_y`
    | 是 |'
- en: We have to be careful because some of the properties behave differently depending
    on the layout we are using. Kivy currently has eight different layouts, which
    are described in the following table. The left-hand side column shows the name
    of the Kivy layout class. The right-hand side column describes briefly how they
    work.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须小心，因为一些属性的行为取决于我们使用的布局。Kivy 目前有八个不同的布局，以下表格中进行了描述。左侧列显示了 Kivy 布局类的名称。右侧列简要描述了它们的工作方式。
- en: '| Layout | Details |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 布局 | 详情 |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **`FloatLayout`** | Organizes the widgets with proportional coordinates by
    the `size_hint` and `pos_hint` properties. The values are numbers between 0 and
    1, indicating a proportion to the window size. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **`FloatLayout`** | 通过 `size_hint` 和 `pos_hint` 属性以比例坐标组织小部件。值是介于0和1之间的数字，表示相对于窗口大小的比例。
    |'
- en: '| **`RelativeLayout`** | Operates in the same way that `FloatLayout` does,
    but the positioning properties (`pos`, `x`, `center_x`, `right`, `y`, `center_y`,
    `top`) are relative to the `Layout` size and not the window size. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **`RelativeLayout`** | 与 `FloatLayout` 以相同的方式操作，但定位属性（`pos`，`x`，`center_x`，`right`，`y`，`center_y`，`top`）相对于
    `Layout` 大小而不是窗口大小。 |'
- en: '| **`GridLayout`** | Organizes widgets in a grid. You have to specify at least
    one of two properties – `cols` (for columns) or `rows` (for rows). |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **`GridLayout`** | 以网格形式组织小部件。您必须指定两个属性中的至少一个——`cols`（用于列）或 `rows`（用于行）。
    |'
- en: '| **`BoxLayout`** | Organizes widgets in one row or one column depending on
    whether the value of the `orientation` property is `horizontal` or `vertical`.
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **`BoxLayout`** | 根据属性 `orientation` 的值是 `horizontal` 或 `vertical`，在一行或一列中组织小部件。
    |'
- en: '| **`StackLayout`** | Similar to `BoxLayout`, but it goes to the next row or
    column when it runs out of space. There is more flexibility to set the `orientation`.
    For example, `rl-bt` organizes the widgets in right-to-left, bottom-to-top order.
    Any combination of `lr` (left to right), `rl` (right to left), `tb` (top to bottom),
    and `bt` (bottom to top) is allowed. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **`StackLayout`** | 与 `BoxLayout` 类似，但在空间不足时将移动到下一行或列。在设置 `orientation` 方面有更多的灵活性。例如，`rl-bt`
    以从右到左、从下到上的顺序组织小部件。允许任何 `lr`（从左到右）、`rl`（从右到左）、`tb`（从上到下）和 `bt`（从下到上）的组合。 |'
- en: '| **`ScatterLayout`** | Works in a similar manner to `RelativeLayout` but allows
    multitouch gesturing for rotating, scaling, and translating. It is slightly different
    in its implementation, so we will review it later on. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **`ScatterLayout`** | 与 `RelativeLayout` 的工作方式类似，但允许多指触控手势进行旋转、缩放和移动。它在实现上略有不同，所以我们稍后会对其进行回顾。|'
- en: '| **`PageLayout`** | Stacks widgets on top of each other, creating a multipage
    effect that allows flipping of pages using side borders. Very often, we will use
    another layout to organize elements inside each of the pages, which are simply
    widgets. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **`PageLayout`** | 将小部件堆叠在一起，创建一个多页效果，允许使用侧边框翻页。我们经常使用另一个布局来组织每个页面内的元素，这些页面只是小部件。|'
- en: 'The Kivy API ([http://kivy.org/docs/api-kivy.html](http://kivy.org/docs/api-kivy.html))
    offers a detailed explanation and good examples of each of the layouts. The behavioral
    difference of the properties depends on the layout, and it is sometimes unexpected.
    Here are some hints that will help us in the GUI building process:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy API ([http://kivy.org/docs/api-kivy.html](http://kivy.org/docs/api-kivy.html))
    提供了每个布局的详细解释和良好示例。属性的行性行为取决于布局，有时可能会出乎意料。以下是一些有助于我们在GUI构建过程中的提示：
- en: '`size_hint`, `size_hint_x`, and `size_hint_y` work on all the layouts (except
    `PageLayout`), but the behavior might be different. For example, `GridLayout`
    will try to take an average of the x hints and y hints on the same row or column
    respectively.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size_hint`、`size_hint_x` 和 `size_hint_y` 在所有布局上（除了 `PageLayout`）都起作用，但行为可能不同。例如，`GridLayout`
    将尝试取同一行或列上的 x 提示和 y 提示的平均值。'
- en: You should use values from 0 to 1 with `size_hint`, `size_hint_x`, and `size_hint_y`.
    However, you can use values higher than 1\. Depending on the layout, Kivy makes
    the widget bigger than the container or tries to recalculate a proportion based
    on the sum of the hints on the same axis.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该使用从0到1的值来设置 `size_hint`、`size_hint_x` 和 `size_hint_y`。然而，你可以使用大于1的值。根据布局的不同，Kivy会使小部件比容器大，或者尝试根据同一轴上的提示总和重新计算比例。
- en: '`pos_hint` only works for `FloatLayout`, `RelativeLayout`, and `BoxLayout`.
    In `BoxLayout`, only the axis-x keys (`x`, `center_x`, `right`) work in the `vertical`
    orientation and vice-versa for the `horizontal` orientation. An analogous rule
    applies for the fixed positioning properties (`pos`, `x`, `center_x`, `right`,
    `y`, `center_y`, and `top`).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pos_hint` 只适用于 `FloatLayout`、`RelativeLayout` 和 `BoxLayout`。在 `BoxLayout`
    中，只有 `axis-x` 键（`x`、`center_x`、`right`）在 `vertical` 方向上工作，反之亦然在 `horizontal` 方向上。对于固定定位属性（`pos`、`x`、`center_x`、`right`、`y`、`center_y`
    和 `top`）也适用类似的规则。'
- en: '`size_hint`, `size_hint_x`, and `size_hint_y` can always be set as `None` in
    favor of `size`, `width`, and `height`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size_hint`、`size_hint_x` 和 `size_hint_y` 可以始终设置为 `None` 以便使用 `size`、`width`
    和 `height`。'
- en: There are more properties and particularities of each layout, but with the ones
    covered, we will be able to build almost any GUI. In general, the recommendation
    is to use the layout as it is and, instead of forcing it with the properties we
    are using, it is better to have more layouts and combine them to reach our goals.
    The next section will teach us how to embed layouts and will offer more comprehensive
    examples.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个布局都有更多属性和特性，但有了这些，我们将能够构建几乎任何GUI。一般来说，建议使用布局的原样，而不是用我们使用的属性强制它，更好的做法是使用更多布局并将它们组合起来以达到我们的目标。下一节将教我们如何嵌入布局，并提供更全面的示例。
- en: Embedding layouts
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入布局
- en: 'Layouts are subclasses of widgets. We have already been embedding widgets inside
    widgets since the beginning (line 43) and it won''t matter if the widgets we are
    embedding are also layouts. In this section, we will work with a comprehensive
    example to explore the effect of the position properties discussed in the previous
    section. The example is not visually appealing, but it will be useful to illustrate
    some concepts and to provide some code that you can use to test different properties.
    The following is the Python code (`layouts.py`) for the example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是小部件的子类。从开始（第43行）我们就已经在小部件内部嵌入小部件了，所以嵌入的小部件是否也是布局并不重要。在本节中，我们将通过一个综合示例来探索上一节讨论的位置属性的效果。这个示例在视觉上可能不太吸引人，但它将有助于说明一些概念，并提供一些你可以用来测试不同属性的代码。以下是为示例编写的
    Python 代码 (`layouts.py`)：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Nothing new in the preceding code – we just created `MyGridLayout`. The final
    output is shown in the next screenshot, with some indications about the different
    layouts:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中没有新内容——我们只是创建了`MyGridLayout`。最终输出在下一张截图中有展示，其中包含了一些关于不同布局的说明：
- en: '![Embedding layouts](img/B04244_01_04.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入布局](img/B04244_01_04.jpg)'
- en: Embedding layouts
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入布局
- en: 'In this screenshot, six different Kivy layouts are embedded into a **`GridLayout`**
    of two rows (line 107) in order to show the behavior of different widget properties.
    The code is straightforward, although extensive. Therefore, we are going to study
    the corresponding Kivy language code (`layouts.kv`) in five fragments. The following
    is fragment 1:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在此截图中，六个不同的Kivy布局被嵌入到两行的**`GridLayout`**中（第107行），以展示不同小部件属性的行为。代码简单明了，尽管内容广泛。因此，我们将分五个片段研究相应的Kivy语言代码（`layouts.kv`）。以下是片段1：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this code, `MyGridLayout` is defined by the number of rows with the **`rows`**
    property (line 107). Then we add the first two layouts – `FloatLayout` and **`RelativeLayout`**
    with one `Button` each. Both buttons have a defined property of `pos: 0, 0` (lines
    112 and 117) but note in the previous screenshot that the `Button` **F1** (line
    109) is in the bottom-left corner of the whole window, whereas the `Button` **R1**
    (line 114) is in the bottom-left corner of `RelativeLayout`. The reason is that
    the `pos` coordinates in `FloatLayout` are not relative to the position of the
    layout.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '在此代码中，`MyGridLayout`通过**`rows`**属性（第107行）定义了行数。然后我们添加了前两个布局——每个布局都有一个`Button`的`FloatLayout`和**`RelativeLayout`**。两个按钮都定义了`pos:
    0, 0`属性（第112行和第117行），但请注意，在前一个截图中的`Button` **F1**（第109行）位于整个窗口的左下角，而`Button` **R1**（第114行）位于`RelativeLayout`的左下角。原因是`FloatLayout`中的`pos`坐标不是相对于布局的位置。'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `pos_hint` always uses relative coordinates, no matter the layout
    we are using. In other words, the previous example wouldn't have worked if we
    were using `pos_hint` instead of `pos`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论我们使用哪种布局，`pos_hint`始终使用相对坐标。换句话说，如果使用`pos_hint`而不是`pos`，前面的例子将不会工作。
- en: 'In fragment 2, one **`GridLayout`** is added to `MyGridLayout`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段2中，向`MyGridLayout`添加了一个**`GridLayout`**：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, we use the **`cols`** property to define two columns (line 120)
    and the `spacing` property to separate the internal widgets by 10 pixels from
    each other (line 121). Also, note in the previous screenshot that the first column
    is thinner than the second. We achieved this by setting the `size_hint_x` to `None`
    and `width` to `50` of the buttons **G1** (line 122) and **G3** (line 128).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用**`cols`**属性定义了两列（第120行），并使用`spacing`属性将内部小部件彼此之间隔开10像素（第121行）。注意，在前一个截图中也注意到，第一列比第二列细。我们通过将按钮**G1**（第122行）和**G3**（第128行）的`size_hint_x`设置为`None`和`width`设置为`50`来实现这一点。
- en: 'In fragment 3, an **`AnchorLayout`** is added:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段3中，添加了一个**`AnchorLayout`**：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have specified the **`anchor_x`** property to `right` and the **`anchor_y`**
    property to `top` (line 134 and 135) in order to arrange elements in the top-right
    corner of the window as shown in the previous screenshot with both buttons (lines
    136 and 139). This layout is very useful to embed other layouts inside it, for
    example, top menu bars or side bars.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将**`anchor_x`**属性设置为`right`，将**`anchor_y`**属性设置为`top`（第134行和第135行），以便将元素排列在窗口的右上角，如前一个截图所示，其中包含两个按钮（第136行和第139行）。这种布局非常适合在其中嵌入其他布局，例如顶部菜单栏或侧边栏。
- en: 'In fragment 4, a **`BoxLayout`** is added:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段4中，添加了一个**`BoxLayout`**：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code illustrates the use of `BoxLayout` with the **`orientation`**
    property set to `horizontal`. Also, the lines 149 and 150 show how to use `size_hint`
    and `pos_hint` to move the button **B2** further up.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了如何使用**`orientation`**属性设置为`horizontal`的`BoxLayout`。此外，第149行和第150行显示了如何使用`size_hint`和`pos_hint`将按钮**B2**向上移动。
- en: 'Finally, fragment 5 adds a **`StackLayout`**:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，片段5添加了一个**`StackLayout`**：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, we added four buttons of different sizes. It is important to pay
    attention to the previous screenshot on embedding layouts to understand the rules
    that we applied to organize the widgets with the **`orientation`** property set
    to `rl-tb` (right to left, top to bottom, line 155). Also note that the **`padding`**
    property (line 156) adds 10 pixels of space between the widgets and the border
    of `StackLayout`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们添加了四个不同大小的按钮。注意，理解嵌入布局的规则非常重要，这些规则是通过将**`orientation`**属性设置为`rl-tb`（从右到左，从上到下，第155行）来组织小部件的。同时注意，**`padding`**属性（第156行）在`StackLayout`的小部件和边框之间增加了10像素的空间。
- en: PageLayout – swiping pages
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面布局——滑动页面
- en: The **`PageLayout`** works in a different manner from other layouts. It is a
    dynamic layout, in the sense that it allows flipping through pages using its borders.
    The idea is that its components are stacked in front of each other, and we can
    just see the one that is on top.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**`PageLayout`** 的工作方式与其他布局不同。它是一种动态布局，从某种意义上说，它允许通过其边框翻页。其理念是它的组件是堆叠在一起的，我们只能看到最上面的一个。'
- en: 'The following example illustrates its use, taking advantage of the example
    from the previous section. The Python code (`pagelayout.py`) is presented here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了其用法，利用了上一节的示例。Python 代码（`pagelayout.py`）如下所示：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is nothing new in this code except the use of the `PageLayout` class.
    For the Kivy language code (`pagelayout.kv`), we will study the properties of
    `PageLayout`. We have simply modified the `layouts.kv` studied in the previous
    section by changing the header of the file (lines 105 to 107), now called `pagelayout.kv`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中除了使用 `PageLayout` 类之外没有新内容。对于 Kivy 语言代码（`pagelayout.kv`），我们将研究 `PageLayout`
    的属性。我们只是简单地修改了上一节中研究的 `layouts.kv` 文件（第 105 至 107 行），现在称为 `pagelayout.kv`：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All the layouts inherit from a base class called `Layout`. In line 185, we are
    modifying this base class in the same way we did earlier with the `Button` class
    (line 80).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有布局都继承自一个名为 `Layout` 的基类。在第 185 行，我们以与之前修改 `Button` 类（第 80 行）相同的方式修改了这个基类。
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we want to apply changes to all the child widgets that have a common base
    class (such as `Layout`), we can introduce those changes in the base class. Kivy
    will apply the changes to all the classes that derive from it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对具有公共基类（如 `Layout`）的所有子小部件应用更改，我们可以在基类中引入这些更改。Kivy 将将这些更改应用到所有从它派生的类中。
- en: 'By default, layouts don''t have a background color, which is not convenient
    when `PageLayout` stacks them on top of each other, because we can see the elements
    of the layouts on the bottom. Lines 186 to 191 will draw a white (line 187 and
    188) rectangle of the size (line 190) and position (line 191) of the `Layout`.
    In order to do this, we need to use the **`canvas`**, which allows us to draw
    shapes directly on the screen. This topic will be explained in-depth in the next
    chapter ([Chapter 2](ch02.html "Chapter 2. Graphics – the Canvas"), *Graphics
    - The Canvas*). You can see the result in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，布局没有背景颜色，这在 `PageLayout` 将它们堆叠在一起时不太方便，因为我们能看到底层布局的元素。第 186 至 191 行将绘制一个白色（第
    187 和 188 行）矩形，其大小（第 190 行）和位置（第 191 行）与 `Layout` 相对应。为了做到这一点，我们需要使用 **`canvas`**，它允许我们在屏幕上直接绘制形状。这个主题将在下一章（[第
    2 章](ch02.html "第 2 章。图形 – 画布"), *图形 - 画布*）中深入解释。您可以在下面的屏幕截图中看到结果：
- en: '![PageLayout – swiping pages](img/B04244_01_05.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![PageLayout – 滑动翻页](img/B04244_01_05.jpg)'
- en: If you run the code on your computer, you will notice that it will take you
    to the page corresponding to `AnchorLayout` in the example of the previous section.
    The reason is that we set the **`page`** property to value `3` (line 194). Counting
    from `0`, this property tells Kivy which page to display first. The **`border`**
    property tells Kivy how wide the side borders are (for sliding to the previous
    or the next screen). Finally, **`swipe_threshold`** tells the percentage of the
    screen that we have to slide over, in order to change the page. The next section
    will use some of the layouts and properties learned so far to display a more professional
    screen.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在电脑上运行代码，你会注意到它会带你到上一节示例中的 `AnchorLayout` 对应的页面。原因是我们将 **`page`** 属性设置为值
    `3`（第 194 行）。从 `0` 开始计数，这个属性告诉 Kivy 首先显示哪个页面。**`border`** 属性告诉 Kivy 侧边框有多宽（用于滑动到上一个或下一个屏幕）。最后，**`swipe_threshold`**
    告诉我们需要滑动屏幕的百分比，才能更改页面。下一节将使用到目前为止学到的某些布局和属性来显示一个更专业的屏幕。
- en: Our project – Comic Creator
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的项目 – 漫画创作器
- en: 'We now have all the necessary concepts to be able to create any interface we
    want. This section describes the project that we will improve on, as we go through
    the following three chapters – the *Comic Creator*. The basic idea of the project
    is a simple application to draw a stickman. The following screenshot is a sketch
    (wireframe) of the GUI we are aiming for:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有必要的概念，能够创建我们想要的任何界面。本节描述了我们将通过以下三个章节（*漫画创作器*）进行改进的项目。该项目的核心思想是一个简单的应用程序，用于绘制一个棍子人。下面的屏幕截图是我们所追求的
    GUI 的草图（线框）：
- en: '![Our project – Comic Creator](img/B04244_01_06.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![我们的项目 – 漫画创作器](img/B04244_01_06.jpg)'
- en: 'We can distinguish several areas in the sketch. First, we need a *drawing space*
    (top-right) for our comics. We need a *tool box* (top-left) with some drawing
    tools to draw our figures and also some *general options* (second from bottom
    to top) – clear the screen, remove the last element, group elements, change color,
    and use the gestures mode. Finally, it would be useful to have a *status bar*
    (center-bottom) to provide some information to the user – number of figures and
    last action performed. According to what we have learned in this chapter, there
    are multiple solutions to organize this screen. We will use the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在草图中区分几个区域。首先，我们需要一个*绘图空间*（右上角）来放置我们的漫画。我们需要一个*工具箱*（左上角）包含一些绘图工具来绘制我们的图形，还有一些*通用选项*（从底部向上数第二个）——清除屏幕、删除最后一个元素、组合元素、更改颜色和使用手势模式。最后，有一个*状态栏*（中心底部）向用户提供一些信息——图形数量和最后执行的操作。根据我们在本章中学到的知识，有多个解决方案来组织这个屏幕。我们将使用以下方案：
- en: '`AnchorLayout` for the *tool box* area in the top-left corner. Inside it will
    be a `GridLayout` of two columns for the *drawing tools*.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左上角的*工具箱*区域使用`AnchorLayout`。在其内部将是一个两列的`GridLayout`，用于*绘图工具*。
- en: '`AnchorLayout` for the *drawing space* in the top-right corner. Inside it will
    be a `RelativeLayout` to have a relative space to draw in.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右上角的*绘图空间*使用`AnchorLayout`。在其内部将是一个`RelativeLayout`，以便在相对空间中绘制。
- en: '`AnchorLayout` for the *general options* and *status bar* area at the bottom.
    Inside it will be a `BoxLayout` with vertical orientation to organize the *general
    options* on top of the *status bar*:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底部的*通用选项*和*状态栏*区域使用`AnchorLayout`。在其内部将是一个垂直方向的`BoxLayout`，用于在*状态栏*上方组织*通用选项*：
- en: '`BoxLayout` with horizontal orientation for the buttons of the *general options*.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于*通用选项*按钮的水平方向的`BoxLayout`。
- en: '`BoxLayout` with horizontal orientation for the labels of the *status bar*.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于*状态栏*标签的水平方向的`BoxLayout`。
- en: 'We are going to use that structure by creating different files for each area
    – `comiccreator.py`, `comiccreator.kv`, `toolbox.kv`, `generaltools.kv`, `drawingspace.kv`,
    and `statusbar.kv`. Let''s start with `comiccreator.py`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过为每个区域创建不同的文件来使用这个结构——`comiccreator.py`、`comiccreator.kv`、`toolbox.kv`、`generaltools.kv`、`drawingspace.kv`和`statusbar.kv`。让我们从`comiccreator.py`开始：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we are explicitly loading some of the files with the `Builder.load_file`
    instruction (lines 203 to 206). There is no need to explicitly load `comiccreator.kv`
    because Kivy automatically loads it by extracting the first part of the `ComicCreatorApp`
    name. For `ComicCreator`, we choose `AnchorLayout`. It is not the only option,
    but it gives clarity to the code, because the second level is also composed of
    `AnchorLayout` instances.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们明确使用`Builder.load_file`指令（第203行到第206行）加载一些文件。没有必要明确加载`comiccreator.kv`，因为Kivy会自动通过提取`ComicCreatorApp`名称的第一部分来加载它。对于`ComicCreator`，我们选择`AnchorLayout`。这不是唯一的选择，但它使代码更清晰，因为第二级也由`AnchorLayout`实例组成。
- en: Even though using a simple widget would have been clear, it is not possible,
    because the `Widget` class doesn't honor the `size_hint` and `pos_hint` properties
    that are necessary in the `AnchorLayout` internals.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用一个简单的部件会更清晰，但这是不可能的，因为`Widget`类不遵守`AnchorLayout`内部所需的`size_hint`和`pos_hint`属性。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that only layouts honor the `size_hint` and `pos_hint` properties.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只有布局才遵守`size_hint`和`pos_hint`属性。
- en: 'Here is the code for `comiccreator.kv`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`comiccreator.kv`的代码：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code follows the previously presented structure for the *Comic Creator*.
    There are basically three `AnchorLayout` instances in the first level (lines 219,
    226, and 233) and a `BoxLayout` that organizes the *general options* and the *status
    bar* (line 236).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遵循之前展示的*漫画创作器*结构。在第一级基本上有三个`AnchorLayout`实例（第219行、第226行和第233行）和一个组织*通用选项*和*状态栏*的`BoxLayout`（第236行）。
- en: We set the width of the `ToolBox` to 100 pixels and the height of the `GeneralOptions`
    and `StatusBar` to 48 and 24 pixels respectively (lines 241 and 245). This brings
    with it an interesting problem – the *drawing space* should use the remaining
    width and height of the screen (no matter the screen size). In order to achieve
    this, we will take advantage of the Kivy **id** (lines 223, 239, and 243), which
    allows us to refer to other components inside the Kivy language. On lines 231
    and 232, we subtract `tool_box.width` from `root.width` (line 231) and `general_options.height`
    and `status_bar.height` from `root.height` (line 232).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`ToolBox`的宽度设置为100像素，将`GeneralOptions`和`StatusBar`的高度分别设置为48像素和24像素（第241行和第245行）。这随之带来一个有趣的问题——*绘图空间*应该使用屏幕剩余的宽度和高度（无论屏幕大小如何）。为了实现这一点，我们将利用Kivy
    **id**（第223行、第239行和第243行），它允许我们在Kivy语言中引用其他组件。在第231行和第232行，我们从`root.width`（第231行）减去`tool_box.width`，从`root.height`（第232行）减去`general_options.height`和`status_bar.height`。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A Kivy **id** allows us to create internal variables in order to access properties
    of other widgets inside the Kivy language rules.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy的**id**允许我们在Kivy语言规则内创建内部变量，以便访问其他小部件的属性。
- en: 'For now, let''s continue exploring the Kivy language in the `toolbox.kv`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续在`toolbox.kv`中探索Kivy语言：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We created a `ToolButton` class that defines the size of the drawing tools
    and also introduces a new Kivy widget – **`ToggleButton`**. The difference with
    the normal `Button` is that it stays pressed until we click on it again. The following
    is an example of the *tool box* with a `ToolButton` activated:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`ToolButton`类，它定义了绘图工具的大小，并引入了一个新的Kivy小部件——**`ToggleButton`**。与普通`Button`的区别在于它会在我们再次点击之前保持按下状态。以下是一个带有激活的`ToolButton`的*工具箱*示例：
- en: '![Our project – Comic Creator](img/B04244_01_07.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![我们的项目 – 漫画创作器](img/B04244_01_07.jpg)'
- en: A `ToggleButton` instance can be associated with other `ToggleButton` instances,
    so just one of them is clicked on at a time. We can achieve this by assigning
    the same **`group`** property (line 250) to the `ToggleButton` instances that
    we want to react together. In this case, we want all the instances of `ToolButton`
    belonging to the same group, because we want to draw just one figure at a time;
    we make it part of the class definition (line 247).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ToggleButton`实例可以与另一个`ToggleButton`实例关联，因此一次只能点击其中一个。我们可以通过将相同的**`group`**属性（第250行）分配给想要一起响应的`ToggleButton`实例来实现这一点。在这种情况下，我们希望属于同一组的所有`ToolButton`实例，因为我们只想一次绘制一个图形；我们将其作为类定义的一部分（第247行）。
- en: On line 252, we implement `ToolBox` as a subclass of `GridLayout` and we add
    some character placeholders (`'O'`, `'/'`, and `'?'`) to the `ToolButton` instances
    that we will substitute for something more appropriate in the following chapters.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在第252行，我们将`ToolBox`实现为一个`GridLayout`的子类，并给`ToolButton`实例添加了一些字符占位符（`'O'`、`'/'`和`'?'`），这些占位符将在后续章节中替换为更合适的内容。
- en: 'The following is the code for `generaloptions.kv`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`generaloptions.kv`文件的代码：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is an example of how inheritance can help us separate our components.
    We are using `ToggleButton` instances (lines 269 and 273), and they are not affected
    by the previous `ToolButton` implementation. Also, we didn''t associate them to
    any `group`, so they are independent of each other and will just keep a mode or
    state. The code only defines the `GeneralOptions` class following our initial
    structure. The following is the resulting screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用继承来帮助我们分离组件的例子。我们使用了`ToggleButton`实例（第269行和第273行），它们不受之前`ToolButton`实现的影响。此外，我们没有将它们关联到任何`group`，因此它们彼此独立，只会保持一种模式或状态。代码只定义了`GeneralOptions`类，遵循我们的初始结构。以下是将得到的截图：
- en: '![Our project – Comic Creator](img/B04244_01_08.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![我们的项目 – 漫画创作器](img/B04244_01_08.jpg)'
- en: 'The `statusbar.kv` file is very similar in the way it uses `BoxLayout`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`statusbar.kv`文件在用法上与`BoxLayout`非常相似：'
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The difference is that it organizes labels and not buttons. The following is
    the screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于它组织的是标签而不是按钮。以下是将得到的截图：
- en: '![Our project – Comic Creator](img/B04244_01_09.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![我们的项目 – 漫画创作器](img/B04244_01_09.jpg)'
- en: 'Finally, the code for `drawingspace.kv`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是`drawingspace.kv`文件的代码：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Apart from defining that `DrawingSpace` is a subclass of `RelativeLayout`, we
    introduce the Kivy **`markup`**, a nice feature for styling the text of the `Label`
    class. It works in a similar manner to XML-based languages. For example, in HTML,
    `<b>I am bold</b>` would specify bold text. First, you have to activate it (line
    285) and then you just embed the text you want to style between `[tag]` and `[/tag]`
    (line 286). You can find the complete tag list and description in the Kivy API,
    in the documentation for `Label` ([http://kivy.org/docs/api-kivy.uix.label.html](http://kivy.org/docs/api-kivy.uix.label.html)).
    In the previous example, `size` and `color` are self-explanatory; `sub` refers
    to subindexed text; `b` to bold; and `i` to italics.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义 `DrawingSpace` 是 `RelativeLayout` 的子类之外，我们还引入了 Kivy 的 **`markup`**，这是一个用于美化
    `Label` 类文本的不错特性。它的工作方式与基于XML的语言类似。例如，在HTML中，`<b>I am bold</b>` 会指定加粗文本。首先，您需要激活它（第285行），然后只需将您想要美化的文本嵌入
    `[tag]` 和 `[/tag]` 之间（第286行）。您可以在 Kivy API 的文档中找到完整的标签列表和描述，在 `Label` 的文档中（[http://kivy.org/docs/api-kivy.uix.label.html](http://kivy.org/docs/api-kivy.uix.label.html)）。在先前的例子中，`size`
    和 `color` 是不言自明的；`sub` 指的是下标文本；`b` 表示加粗；`i` 表示斜体。
- en: 'Here is the screenshot that shows the GUI of our project:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是显示我们项目GUI的截图：
- en: '![Our project – Comic Creator](img/B04244_01_10.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![我们的项目 – 漫画创作器](img/B04244_01_10.jpg)'
- en: In the following chapters, we are going to add the respective functionality
    to this interface that, for now, consists of placeholder widgets. However, it
    is exciting what we got with just a few lines of code. Our GUI is ready to go
    and we will be working on its logic from now on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将为这个目前仅由占位符小部件组成的界面添加相应的功能。然而，仅仅用几行代码就能得到这样的结果，这令人兴奋。我们的GUI已经准备就绪，从现在起我们将专注于其逻辑开发。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter covered all the basics and introduced some not-so-basic concepts
    of Kivy. We covered how to configure classes, instances, and templates. Here is
    a list of Kivy elements we have learned to use in this chapter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了所有基础知识，并介绍了一些不那么基本的概念。我们介绍了如何配置类、实例和模板。以下是本章中我们学习使用的 Kivy 元素列表：
- en: Basic widgets – `Widget`, `Button`, `ToggleButton`, and `Label`
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本小部件 – `Widget`、`Button`、`ToggleButton` 和 `Label`
- en: Layouts – `FloatLayout`, `RelativeLayout`, `BoxLayout`, `GridLayout`, `StackLayout`,
    `AnchorLayout`, and `PageLayout`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局 – `FloatLayout`、`RelativeLayout`、`BoxLayout`、`GridLayout`、`StackLayout`、`AnchorLayout`
    和 `PageLayout`
- en: Properties – `pos`, `x`, `y`, `center_x`, `center_y`, `top`, `right`, `size`,
    `height`, `width`, `pos_hint`, `size_hint`, `group`, `spacing`, `padding`, `color`,
    `text`, `font_size`, `cols`, `rows`, `orientation`, `anchor_x`, and `anchor_y`
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性 – `pos`、`x`、`y`、`center_x`、`center_y`、`top`、`right`、`size`、`height`、`width`、`pos_hint`、`size_hint`、`group`、`spacing`、`padding`、`color`、`text`、`font_size`、`cols`、`rows`、`orientation`、`anchor_x`
    和 `anchor_y`
- en: Variables – `self` and `root`
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 – `self` 和 `root`
- en: Others – `id` and the markup tags `size`, `color`, `b`, `i`, and `sub`
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 – `id` 和标记标签 `size`、`color`、`b`、`i` 和 `sub`
- en: There are many more elements from the Kivy language that we can use, but with
    this chapter, we have understood the general idea of how to organize elements.
    With the help of the Kivy API, we should be able to display most of the elements
    available for GUI design. There is, however, a very important element we need
    to study separately – the `canvas`, which allows us to draw vector shapes inside
    widgets, such as the white rectangle we draw as background in the `PageLayout`
    example. It is a very important topic to master in Kivy, and the entire next chapter,
    *Graphics - The Canvas*, will be dedicated to it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 Kivy 语言中的许多其他元素，但通过本章，我们已经理解了如何组织元素的一般思路。借助 Kivy API，我们应该能够显示大多数用于GUI设计的元素。然而，还有一个非常重要的元素需要单独研究——`canvas`，它允许我们在小部件内部绘制矢量形状，例如在
    `PageLayout` 示例中作为背景绘制的白色矩形。这是 Kivy 中一个非常重要的主题，下一章将完全致力于它。
