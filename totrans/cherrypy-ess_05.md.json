["```py\nfrom sqlobject import *\nclass Song(SQLObject):\ntitle = StringCol()\nposition = IntCol()\nalbum = ForeignKey('Album', cascade=True)\nclass Album(SQLObject):\ntitle = StringCol()\nrelease_year = IntCol()\nartist = ForeignKey('Artist', cascade=True)\nsongs = MultipleJoin('Song', orderBy=\"position\")\nclass Artist(SQLObject):\n# Using alternateID will automatically\n# create a byName() method\nname = StringCol(alternateID=True, unique=True)\nalbums = MultipleJoin('Album')\n\n```", "```py\nfrom sqlalchemy import *\nartist_table = Table('Artist', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('name', String(), unique=True))\nsong_table = Table('Song', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('title', String()),\nColumn('position', Integer),\nColumn('album_id', Integer,\nForeignKey('Album.id')))\nalbum_table = Table('Album', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('title', String()),\nColumn('release_year', Integer),\nColumn('artist_id', Integer,\nForeignKey('Artist.id')))\nclass Artist(object):\ndef __init__(self, name):\nself.id = None\nself.name = name\nclass Album(object):\ndef __init__(self, title, release_year=0):\nself.id = None\nself.title = title\nself.release_year = release_year\nclass Song(object):\ndef __init__(self, title, position=0):\nself.id = None\nself.title = title\nself.position = position\nsong_mapper = mapper(Song, song_table)\nalbum_mapper = mapper(Album, album_table,\nproperties = {'songs': relation(song_mapper,\ncascade=\"all, delete-orphan\")\n})\nartist_mapper = mapper(Artist, artist_table,\nproperties = {'albums': relation(album_mapper,\ncascade=\"all, delete-orphan\")\n})\n\n```", "```py\nfrom dejavu import Unit, UnitProperty\nclass Song(Unit):\ntitle = UnitProperty(unicode)\nposition = UnitProperty(int)\nalbum_id = UnitProperty(int, index=True)\nclass Album(Unit):\ntitle = UnitProperty(unicode)\nrelease_year = UnitProperty(int)\nartist_id = UnitProperty(int, index=True)\ndef songs(self):\nreturn self.Song()\nsongs = property(songs)\ndef artist(self):\nreturn self.Artist()\nartist = property(artist)\ndef on_forget(self):\nfor song in self.Song():\nsong.forget()\nclass Artist(Unit):\nname = UnitProperty(unicode)\ndef albums(self):\nreturn self.Album()\nalbums = property(albums)\ndef on_forget(self):\nfor album in self.Album():\nalbum.forget()\nAlbum.one_to_many('ID', Song, 'album_id')\nArtist.one_to_many('ID', Album, 'artist_id')\n\n```", "```py\n# Create a connection to a SQLlite 'in memory' database\nsqlhub.processConnection =\nconnectionForURI('sqlite:/:memory:?debug=True')\n\n```", "```py\n# Inform SQLAlchemy of the database we will use\n# A SQLlite 'in memory' database\n# Mapped into an engine object and bound to a high\n# level meta data interface\nengine = create_engine('sqlite:///:memory:', echo=True)\nmetadata = BoundMetaData(engine)\n\n```", "```py\n# Create the global arena object\narena = dejavu.Arena()\narena.logflags = dejavu.logflags.SQL + dejavu.logflags.IO\n# Add a storage to the main arena object\nconf = {'Database': \":memory:\"}\narena.add_store(\"main\",\"sqlite\", conf)\n# Register units the arena will be allowed to handle\n# This call must happen after the declaration of the units\n# and those must be part of the current namespace\narena.register_all(globals())\n\n```", "```py\ndef create_tables():\nAlbum.createTable()\nSong.createTable()\nArtist.createTable()\ndef drop_tables():\nSong.dropTable()\nArtist.dropTable()\nAlbum.dropTable()\n\n```", "```py\ndef create_tables():\nartist_table.create(checkfirst=True)\nalbum_table.create(checkfirst=True)\nsong_table.create(checkfirst=True)\ndef drop_tables():\nartist_table.drop(checkfirst=False)\nsong_table.drop(checkfirst=False)\nalbum_table.drop(checkfirst=False)\n\n```", "```py\ndef create_tables():\narena.create_storage(Song)\narena.create_storage(Album)\narena.create_storage(Artist)\ndef drop_tables():\narena.drop_storage(Song)\narena.drop_storage(Album)\narena.drop_storage(Artist)\n\n```", "```py\n# Create an artist\njeff_buckley = Artist(name=\"Jeff Buckley\")\n# Create an album for that artist\ngrace = Album(title=\"Grace\", artist=jeff_buckley, release_year=1994)\n# Add songs to that album\ndream_brother = Song(title=\"Dream Brother\", position=10, album=grace)\nmojo_pin = Song(title=\"Mojo Pin\", position=1, album=grace)\nlilac_wine = Song(title=\"Lilac Wine\", position=4, album=grace)\n\n```", "```py\nsession = create_session(bind_to=engine)\njeff_buckley = Artist(name=\"Jeff Buckley\")\ngrace = Album(title=\"Grace\", release_year=1994)\ndream_brother = Song(title=\"Dream Brother\", position=10)\nmojo_pin = Song(title=\"Mojo Pin\", position=1)\nlilac_wine = Song(title=\"Lilac Wine\", position=4)\ngrace.songs.append(dream_brother)\ngrace.songs.append(mojo_pin)\ngrace.songs.append(lilac_wine)\njeff_buckley.albums.append(grace)\nsession.save(jeff_buckley)\nsession.flush()\n\n```", "```py\nsandbox = arena.new_sandbox()\n# Create an artist unit\njeff_buckley = Artist(name=\"Jeff Buckley\")\nsandbox.memorize(jeff_buckley)\ngrace = Album(title=\"Grace\", release_year=1994)\nsandbox.memorize(grace)\n# Add the album unit to the artist unit\njeff_buckley.add(grace)\ndream_brother = Song(title=\"Dream Brother\", position=10)\nsandbox.memorize(dream_brother)\nmojo_pin = Song(title=\"Mojo Pin\", position=1)\nsandbox.memorize(mojo_pin)\nlilac_wine = Song(title=\"Lilac Wine\", position=4)\nsandbox.memorize(lilac_wine)\n# Add each song unit to the album unit\ngrace.add(dream_brother)\ngrace.add(mojo_pin)\ngrace.add(lilac_wine)\nsandbox.flush_all()\n\n```", "```py\ndef display_info(artist):\nfor album in artist.albums:\nmessage = \"\"\"\n%s released %s in %d\nIt contains the following songs:\\n\"\"\" % (artist.name,\nalbum.title,\nalbum.release_year)\nfor song in album.songs:\nmessage = message + \" %s\\n\" % (song.title, )\nprint message\n\n```", "```py\n# Retrieve an artist by his name\nbuckley = Artist.byName('Jeff Buckley')\ndisplay_info(buckley)\n# Retrieve songs containing the word 'la' from the given artist\n# The AND() function is provided by the SQLObject namespace\nsongs = Song.select(AND(Artist.q.name==\"Jeff Buckley\",\nSong.q.title.contains(\"la\")))\nfor song in songs:\nprint \" %s\" % (song.title,)\n# Retrieve all songs but only display some of them\nsongs = Song.select()\nprint \"Found %d songs, let's show only a few of them:\" %\n(songs.count(), )\nfor song in songs[1:-1]:\nprint \" %s\" % (song.title,)\n# Retrieve an album by its ID\nalbum = Album.get(1)\nprint album.title\n# Delete the album and all its dependencies\n# since we have specified cascade delete\nalbum.destroySelf()\n\n```", "```py\nsession = create_session(bind_to=engine)\n# Retrieve an artist by his name\nbuckley = session.query(Artist).get_by(name='Jeff Buckley')\ndisplay_info(buckley)\n# Retrieve songs containing the word 'la' from the given artist\nsongs = session.query(Song).select(and_(artist_table.c.name==\"Jeff\nBuckley\",\nsong_table.c.title.like\n(\"%la%\")))\nfor song in songs:\nprint \" %s\" % (song.title,)\n# Retrieve all songs but only display some of them\n# Note that we specify the order by clause at this level\nsongs = session.query(Song).select(order_by=[Song.c.position])\nprint \"Found %d songs, let's show only a few of them:\" % (len(songs),)\nfor song in songs[1:-1]:\nprint \" %s\" % (song.title,)\n# Retrieve an album by its ID\nalbum = session.query(Album).get_by(id=1)\nprint album.title\n# Delete the album and all its dependencies\n# since we have specified cascade delete\nsession.delete(album)\nsession.flush()\n\n```", "```py\nsandbox = arena.new_sandbox()\n# Retrieve an artist by his name\nbuckley = sandbox.Artist(name=\"Jeff Buckley\")\ndisplay_info(buckley)\n# Retrieve songs containing the word 'la' from the given artist\n# We will explain in more details the concepts of Expressions\nf = lambda ar, al, s: ar.name == \"Jeff Buckley\" and \"la\" in s.title\n# Note how we express the composition between the units\nresults = sandbox.recall(Artist & Album & Song, f)\nfor artist, album, song in results:\nprint \" %s\" % (song.title,)\n# Retrieve all songs but only display some of them\nsongs = sandbox.recall(Song)\nprint \"Found %d songs, let's show only a few of them:\" % (len(songs),)\nfor song in songs[1:-1]:\nprint \" %s\" % (song.title,)\n# Retrieve an album by its ID\nalbum = sandbox.Album(ID=1)\nprint album.title\n\n```", "```py\nimport dejavu\narena = dejavu.Arena()\nfrom model import Photoblog, Album, Film, Photo\ndef connect():\nconf = {'Connect': \"host=localhost dbname=photoblog user=test\npassword=test\"}\narena.add_store(\"main\", \"postgres\", conf)\narena.register_all(globals())\n\n```", "```py\nfrom dejavu import Unit, UnitProperty\nfrom engine.database import arena\nfrom album import Album\nclass Photoblog(Unit):\nname = UnitProperty(unicode)\ntitle = UnitProperty(unicode)\ndef on_forget(self):\nfor album in self.Album():\nalbum.forget()\nPhotoblog.one_to_many('ID', Album, 'blog_id')\n\n```", "```py\nimport datetime\nfrom dejavu import Unit, UnitProperty\nfrom engine.database import arena\nfrom film import Film\nclass Album(Unit):\nname = UnitProperty(unicode)\ntitle = UnitProperty(unicode)\nauthor = UnitProperty(unicode)\ndescription = UnitProperty(unicode)\ncontent = UnitProperty(unicode, hints={u'bytes': 0})\ncreated = UnitProperty(datetime.datetime)\nmodified = UnitProperty(datetime.datetime)\nblog_id = UnitProperty(int, index=True)\ndef on_forget(self):\nfor film in self.Film():\nfilm.forget()\nAlbum.one_to_many('ID', Film, 'album_id')\n\n```", "```py\nimport datetime\nfrom dejavu import Unit, UnitProperty\nfrom engine.database import arena\nfrom photo import Photo\nclass Film(Unit):\nname = UnitProperty(unicode)\ntitle = UnitProperty(unicode)\ncreated = UnitProperty(datetime.datetime)\nmodified = UnitProperty(datetime.datetime)\nalbum_id = UnitProperty(int, index=True)\ndef on_forget(self):\nfor photo in self.Photo():\nphoto.forget()\nFilm.one_to_many('ID', Photo, 'film_id')\n\n```", "```py\nimport datetime\nfrom dejavu import Unit, UnitProperty\nfrom engine.database import arena\nclass Photo(Unit):\nname = UnitProperty(unicode)\nlegend = UnitProperty(unicode)\nfilename = UnitProperty(unicode)\nfilesize = UnitProperty(int)\nwidth = UnitProperty(int)\nheight = UnitProperty(int)\ncreated = UnitProperty(datetime.datetime)\nmodified = UnitProperty(datetime.datetime)\nfilm_id = UnitProperty(int, index=True)\n\n```", "```py\nUnitProperty(type=unicode, index=False,\nhints=None, key=None, default=None)\n\n```", "```py\nnearClass(nearKey, farClass, farKey)\n\n```", "```py\nFilm.one_to_many('ID', Photo, 'film_id')\n\n```", "```py\nbox = arena.create_sandbox()\nbox = dejavu.Sandbox(arena)\n\n```", "```py\n# Search for all photographs with a width superior to 300 pixels\nf = lambda x: x.width > 300\nbox.recall(Photo, f)\n\n```", "```py\n# Search for all photographs of width superior to 300 pixels\n# within albums created by Sylvain\nbox.recall(Album & Photo, lambda a,\np: a.author == \"Sylvain\" and p.width > 300)\n\n```", "```py\n(Film << Album) & Photo\n\n```", "```py\ndef films(self):\n\"\"\"Returns all the attached films\nalbum = Album()\n...\nfor film in album.films:\n...\n\"\"\"\nreturn self.Film()\nfilms = property(films)\ndef get_all(cls):\n\"\"\"Returns all the existing albums\nfor album in Album.albums:\n...\n\"\"\"\nsandbox = arena.new_sandbox()\nreturn sandbox.recall(Album)\nalbums = classmethod(get_all)\ndef fetch(cls, id):\n\"\"\"Fetch one album by id\"\"\"\nsandbox = arena.new_sandbox()\nreturn sandbox.unit(Album, ID=int(id))\nfetch = classmethod(fetch)\ndef fetch_range(cls, start, end):\n\"\"\"Fetch a range of albums which ID falls into the\nspecified range.\n# This could return up to 5 albums\nalbums = Album.fetch_range(4, 9)\nfor album in albums:\n...\n\"\"\"\nsandbox = arena.new_sandbox()\n# dejavu's views change the capacity of dejavu to\n# perform operations on a Unit\n# here we create a view of the Album unit so that only\n# the created and ID properties appear in the\n# result of the view. A view yields values\n# not units unlike recall or xrecall.\nv = list(sandbox.view(Album, ['created', 'ID']))\nv.sort()\nphotoblogdata access layer, extendingsize = len(v)\nif end > size and start >= size:\nreturn None\nelif end > size and start < size:\nend = size\n# row[0] is the 'created' property value\n# row[1] is the 'ID' property value\ntargets = [row[1] for row in v[start:end]]\nreturn sandbox.recall(Album, lambda x: x.ID in targets)\nfetch_range = classmethod(fetch_range)\ndef create(self, photoblog, name, title, slug, author, description,\ncontent):\n\"\"\"Instanciates the Album,\nadds it to the passed photoblog and\npersists the changes into the database\"\"\"\nsandbox = photoblog.sandbox\nself.name = name\nself.title = title\nself.author = author\nself.description = description\nself.content = content\nself.created = datetime.datetime.now().replace(microsecond=0)\nself.modified = album.created\nself.blog_id = photoblog.ID\nsandbox.memorize(self)\nphotoblog.add(self)\nsandbox.flush_all()\ndef update(self, name, title, slug, author, description, content):\n\"\"\"Updates the attributes of an album and\npersists the changes into the storage\"\"\"\nself.title = title\nself.slug = slug\nself.author = author\nself.description = description\nself.content = content\nself.modified = datetime.datetime.now().replace(microsecond=0)\nself.sandbox.flush_all()\ndef delete(self):\n\"\"\"Delete the album from the storage\"\"\"\nself.sandbox.forget(album)\ndef to_dict(self):\n\"\"\"Return an album as a Python dictionary\"\"\"\nreturn {'id': self.ID,\n'uuid': self.uuid,\n'title': self.title,\n'author': self.author,\n'description': self.description,\n'content': self.content,\n'created': self.created.strftime(\"%d %b. %Y, %H:%M\"),\n'modified': self.modified.strftime(\"%d %b. %Y, %H:%M\")}\ndef to_json(self):\n\"\"\"JSONify an album properties\"\"\"\nreturn simplejson.dumps(self.to_dict())\n\n```"]