<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Programmable Drum Machine</h1>
                </header>
            
            <article>
                
<p> We looked at several common Tkinter widgets, such as Menu, Buttons, Label, and Text, in <a href="41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml" target="_blank">Chapter 2</a>, <em>Making a Text Editor</em>. Let's now expand our experience with Tkinter to make some music. Let's build a cross-platform drum machine using Tkinter and some other Python modules.</p>
<p>Some of the key objectives for this chapter are:</p>
<ul>
<li>Learning to structure Tkinter programs in the <strong>object-oriented style</strong> of programming</li>
<li>Delving deeper into a few more Tkinter widgets, such as Spinbox, Button, Entry, and Checkbutton</li>
<li>Applying the grid geometry manager in a practical project</li>
<li>Understanding the importance of choosing the right <strong>data structure</strong> <span>for our programs</span></li>
<li>Learning to bind <strong>higher-order callback</strong> <strong>functions</strong> <span>to widgets</span></li>
<li>Learning to use Tkinter in conjunction with some standard and third-party modules</li>
<li>Understanding the need for <strong>multithreading</strong> <span>and how to write multithreaded applications</span></li>
<li>Learning about <strong>object</strong> <strong>serialization</strong> <span>or</span> <strong>pickling</strong></li>
<li>Learning about <strong>ttk widgets</strong></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p>Our goal here is to build a programmable drum machine. Let's call it the <kbd>Explosion Drum Machine</kbd>.</p>
<p>The drum machine will let the user create an unlimited number of beat patterns using an unlimited number of drum samples. You can then store multiple riffs in a project and playback or edit the project later on. In its final form, the drum machine would look like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9ac7e30d-1364-4af6-9643-b78b52f5338e.png"/></div>
<p class="mce-root">To create your own drum beat patterns, simply load some drum samples (which can be any audio file with a <kbd>.wav</kbd> or <kbd>.ogg</kbd> extension) using the buttons on the left. You can design your beat patterns by clicking on the buttons on the right.</p>
<p class="mce-root">You can decide the number of <strong>beats per unit</strong> (<strong>BPU</strong>). Most western beats have 4 BPU, a Waltz would have 3 BPU, and some Indian and Arabic rhythms that I composed on this machine had 3-16 BPU! You can also change the <strong>beats per minute (BPM)</strong>, which in turn decides the tempo of the rhythm.</p>
<p class="mce-root">A single pattern, as shown in the previous screenshot, constitutes a single beat pattern. You can design multiple beat patterns by changing the Pattern Number Spinbox widget in the top-left section.</p>
<p class="mce-root">Once you have made some beat patterns, you can even save the pattern and later replay or modify it. The saving and reloading of files are done from the <span class="packt_screen">File</span> menu at the top.</p>
<p class="mce-root">A few drum samples are provided in the <kbd>Loops</kbd> subdirectory; however, you can load any other drum sample. You can download a large number of samples for free from the internet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">We will use some more built-in libraries from the standard Python distribution for this chapter. This includes <kbd>tkinter</kbd>, <kbd>os</kbd>, <kbd>math</kbd>, <kbd>threading</kbd>, and <kbd>pickle</kbd> modules.</p>
<p class="mce-root">To verify that these modules exist, simply run the following statement in your Python3 IDLE interactive prompt:</p>
<pre class="mce-root"> &gt;&gt;&gt; import tkinter, os, math, time, threading, pickle </pre>
<p class="mce-root">This should not cause an error, as Python3 comes with these modules built into the distribution.</p>
<p class="mce-root">Other than this, you need to add an extra Python module called <kbd>pygame</kbd>. We will be using the version named 1.9.3 Package, which can be downloaded at <a href="http://www.pygame.org/download.shtml">http://www.pygame.org/download.shtml</a>.</p>
<p class="mce-root">Linux users may additionally want to take a look at the following page for instructions on getting <kbd>pygame</kbd> to work with Python 3.x: <a href="http://www.pygame.org/wiki/CompileUbuntu?parent=Compilation">http://www.pygame.org/wiki/CompileUbuntu?parent=Compilation</a>.</p>
<p class="mce-root"><kbd>pygame</kbd> is a cross-platform package normally used for making games with Python. However, we will just be using a small module from the package named <kbd>pygame.mixer</kbd>, which is used for loading and playing sounds. The API documentation for this module can be found at <a href="http://www.pygame.org/docs/ref/mixer.html">http://www.pygame.org/docs/ref/mixer.html</a>.</p>
<p class="mce-root">After you have installed the module, you can verify it by importing it:</p>
<pre class="mce-root">&gt;&gt;&gt; import pygame<br/>&gt;&gt;&gt; pygame.version.ver </pre>
<p class="mce-root">If no errors are reported and the version output is 1.9.3, you are ready to program the drum machine. Let's start!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the GUI in OOP</h1>
                </header>
            
            <article>
                
<p class="mce-root">The text editor we developed in the previous chapter was implemented in procedural code. Although it offered some benefits for quick coding, it had some typical limitations:</p>
<ul>
<li class="mce-root">We started encountering global variables</li>
<li class="mce-root">The function definitions needed to be defined above the code that called them</li>
<li class="mce-root">Most importantly, the code was not reusable</li>
</ul>
<p class="mce-root">Therefore, we need some way to ensure that our code is reusable. This is why programmers prefer to use <strong>object-oriented programming</strong> (<strong>OOP</strong>) to organize their code into classes.</p>
<p class="mce-root">OOP is a programming paradigm that shifts the focus onto the objects we want to manipulate rather than the logic required to manipulate them. This is in contrast to procedural programming, which views a program as a logical procedure that takes input, processes it, and produces some output. </p>
<p class="mce-root">OOP provides several benefits, such as <strong>data abstraction</strong>, <strong>encapsulation</strong>, <strong>inheritance</strong>, and <strong>polymorphism</strong>. In addition, OOP provides a clear <strong>modular structure</strong> for programs. Code modification and maintenance are easy, as new objects can be created without modifying the existing ones.</p>
<p class="mce-root">Let's build our drum program using OOP to illustrate some of these features. An indicative OOP structure for our drum program could be as follows (code <kbd>3.01.py</kbd>):</p>
<pre class="mce-root">from tkinter import Tk<br/><br/>PROGRAM_NAME = ' Explosion Drum Machine '<br/><br/>class DrumMachine:<br/><br/>    def __init__(self, root):<br/>        self.root = root<br/>        self.root.title(PROGRAM_NAME)<br/><br/>if __name__ == '__main__':<br/>    root = Tk()<br/>    DrumMachine(root)<br/>    root.mainloop()</pre>
<p class="mce-root">The description of the code is as follows:</p>
<ul>
<li class="mce-root">We create a class structure called <kbd>DrumMachine</kbd> and initialize the Toplevel window passed as an argument to it</li>
<li class="mce-root">If the script is run as a standalone program, that is, <kbd>if __name__ == '__main__'</kbd>, a new <kbd>Tk()</kbd> root object is created and the root window is passed as an argument to the <kbd>DrumMachine</kbd> object</li>
<li class="mce-root">We then initiate an object from the <kbd>DrumMachine</kbd> <span>class </span>to get a Toplevel window</li>
</ul>
<p class="mce-root">Now that we have our Toplevel window ready, let's stop adding any more visual elements and think about something that is critical to how well our program will eventually turn out to be. Let's spend some time finalizing the data structure for our program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finalizing the data structure</h1>
                </header>
            
            <article>
                
<p>As Linus Torvalds, the developer of Linux, once said:</p>
<div class="packt_quote">"Bad programmers worry about the code. Good programmers worry about data structures and their relationships."</div>
<p>What he means is that well-designed data structures make the code very easy to design, maintain, and scale up. In contrast, if you start with a poor data structure, you can't make up for that, even with the best of code.</p>
<p>Start with a good data structure and your code will naturally be more simple, elegant, and easy to maintain.</p>
<p>With that in mind, let's try to decide on a suitable data structure for our program. Go back and take a look at the previous screenshot (under the <em>G</em><em>etting started</em> section). What kind of data structure, do you think, would be needed to capture all the necessary fields of information?</p>
<p>Well, first of all our drum machine needs to keep information about beat patterns. So let's start by creating a list named <kbd>all_patterns = []</kbd>.</p>
<p>Now, each of the patterns within the list needs to capture information about the drum files related to the pattern: the number of units in the pattern, the BPU for the pattern, the BPM, and the buttons clicked to form the pattern.</p>
<p>Accordingly, we need to come up with a data structure where <kbd>all_patterns</kbd> is a list where each item represents a single pattern. Each pattern is then denoted by a dictionary, as follows:</p>
<pre>{<br/> 'list_of_drum_files': a list of location of audio drum files,<br/> 'number_of_units': an integer, 'bpu': an integer,<br/> 'beats_per_minute' : an integer,'button_clicked_list' : a 2<br/> dimensional list of boolean values where True means button is<br/> clicked and false means button is not clicked in the pattern<br/> }<br/> </pre>
<p>It is very important that you get familiar with the preceding data structure definition for our drum machine. Notice that, with just this data in hand, we can define the logic to display everything that you see in the finalized drum machine.</p>
<p>Also notice that this data structure does not contain information about any GUI elements, such as widget information or widget states. As far as possible, we should always strive to cleanly separate the data of the backend (program logic) from the data related to the frontend (user interfaces). Our data structure here merely represents the backend but is sufficient enough to allow us to lay out the logic to determine our frontend.</p>
<div class="packt_infobox">The preceding data structure was what I found to be a good representation of the data at hand. There could have been an equally valid but altogether different representation of the data. There is no one <em>correct answer</em> to the question of data representation. However, building the representation around built-in collections of a language allows us to work with highly optimized code and is generally a good idea. <span>The choice of data structure directly affects the performance of an application—sometimes trivially but at other times very severely.</span></div>
<p>We modify our code accordingly (see code <kbd>3.02.py</kbd>) to initialize this data structure:</p>
<pre>    def init_all_patterns(self):<br/>        self.all_patterns = [<br/>            {<br/>                'list_of_drum_files': [None] * MAX_NUMBER_OF_DRUM_SAMPLES,<br/>                'number_of_units': INITIAL_NUMBER_OF_UNITS,<br/>                'bpu': INITIAL_BPU,<br/>                'is_button_clicked_list':<br/>                self.init_is_button_clicked_list(<br/>                    MAX_NUMBER_OF_DRUM_SAMPLES,<br/>                    INITIAL_NUMBER_OF_UNITS * INITIAL_BPU<br/>                )<br/>            }<br/>            for k in range(MAX_NUMBER_OF_PATTERNS)]</pre>
<p>We also initialize <kbd>is_button_clicked_list</kbd> with all values set to <kbd>False</kbd>, as follows:</p>
<pre>    def init_is_button_clicked_list(self, num_of_rows, num_of_columns):<br/>        return [[False] * num_of_columns for x in range(num_of_rows)]</pre>
<p>To support this structure, we define a few constants (see code <kbd>3.02.py</kbd>):</p>
<pre>MAX_NUMBER_OF_PATTERNS = 10<br/>MAX_NUMBER_OF_DRUM_SAMPLES = 5<br/>INITIAL_NUMBER_OF_UNITS = 4<br/>INITIAL_BPU = 4<br/>INITIAL_BEATS_PER_MINUTE = 240</pre>
<p>Now, if you run this program, you simply see a root window—nothing different from the previous code. But internally our code is reserving memory for all the data we will need to construct our logic. We have laid a strong foundation for our program to run. Believe it or not, we have done half the job.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating broader visual elements</h1>
                </header>
            
            <article>
                
<p>Next, let's lay out the broader visual elements of our program. For the sake of modularity, we divide the program into four broad visual sections, as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/898ba06f-ef69-41f1-8ad0-a1d9034ae921.png"/></div>
<p>Let's define a method called <kbd>init_gui()</kbd>, which is called from within the <kbd>__init__</kbd> method as follows (see code <kbd>3.03.py</kbd>):</p>
<pre>def init_gui(self):<br/>   self.create_top_bar()<br/>   self.create_left_drum_loader()<br/>   self.create_right_button_matrix()<br/>   self.create_play_bar()</pre>
<p>We then proceed to define all four of these methods (<kbd>3.03.py</kbd>). The code is not discussed here, as we have done similar coding in previous chapters.</p>
<p>We begin with the <strong>Top Bar</strong> section. The Top Bar is simple. It has a few labels, three Spinboxes, and an Entry widget. We will not reproduce the entire code here (see code <kbd>3.03.py</kbd>) as we have already seen examples of creating Labels and Entry widgets several times in the previous chapters. For <kbd>Spinbox</kbd>, the options are specified as follows:</p>
<pre>Spinbox(frame, from_=1, to=MAX_BPU, width=5,command=self.on_bpu_changed).grid(row=0, column=7)</pre>
<p>We set the class-level properties accordingly:</p>
<pre> self.beats_per_minute = INITIAL_BEATS_PER_MINUTE<br/> self.current_pattern_index = 0</pre>
<p>Since we will allow multiple patterns to be designed, we need to keep track of the currently showing or active pattern. The <kbd>self.current_pattern_index</kbd> property keeps track of the currently active pattern.</p>
<p>Next, let's code the <kbd>create_left_drum_loader()</kbd> method. This again is pretty self-explanatory. We create a loop (see <kbd>code 3.03.py</kbd>):</p>
<pre>for i in range (MAX_NUMBER_OF_DRUM_SAMPLES):<br/>    # create compound button here<br/>    # create entry widgets here and keep reference to each entry widget in<br/>    #a list for future update of values</pre>
<p>Before we proceed to code the <kbd>create_right_button_matrix()</kbd> method, let's finish coding the <kbd>create_play_bar()</kbd> method, as it is the simpler of the two. All it contains is two Buttons, a Checkbutton, a Spinbox, and an image. We have coded similar widgets earlier in the book, and so I will leave it for you to explore on your own (see code <kbd>3.03.py</kbd>).</p>
<p>Next, let's code the <kbd>create_right_button_matrix()</kbd> method. This is the most complex of all.</p>
<p>The <strong>right button matrix</strong> comprises a two-dimensional array of rows and columns. The number of rows in the matrix equals the constant, <kbd>MAX_NUMBER_OF_DRUM_SAMPLES</kbd>, and the number of columns represents the number of beat units per cycle and is calculated by multiplying the number of units and the number of beats per unit.</p>
<p>The code that creates the button matrix looks like this (see code <kbd>3.03.py</kbd>):</p>
<pre>self.buttons = [[None for x in range(self.find_number_of_columns())] for x in range(MAX_NUMBER_OF_DRUM_SAMPLES)]<br/>for row in range(MAX_NUMBER_OF_DRUM_SAMPLES):<br/>    for col in range(self.find_number_of_columns()):<br/>        self.buttons[row][col] = Button(right_frame,<br/>                 command=self.on_button_clicked(row, col))<br/>        self.buttons[row][col].grid(row=row, column=col)<br/>        self.display_button_color(row, col)</pre>
<p>The associated code for the <kbd>find_number_of_columns()</kbd> method is as follows:</p>
<pre>    def find_number_of_columns(self):<br/>        return int(self.number_of_units_widget.get()) * <br/>          int(self.bpu_widget.get())</pre>
<p>We have already created the button matrix, but we want the buttons to be colored in two alternating shades. Therefore, we define two constants:</p>
<pre>COLOR_1 = 'grey55'<br/>COLOR_2 = 'khaki'</pre>
<p>This can be any hexadecimal color code or any color from Tkinter's predefined list of colors. We also require a third color to represent the button in a pressed state.</p>
<p>The constant <kbd>BUTTON_CLICKED_COLOR = 'green'</kbd> takes care of that.</p>
<p>We then define two methods:</p>
<pre>def display_button_color(self, row, col):<br/>  original_color = COLOR_1 if ((col//self.bpu)%2) else COLOR_2<br/>  button_color = BUTTON_CLICKED_COLOR if<br/>         self.get_button_value(row, col) else original_color<br/>  self.buttons[row][col].config(background=button_color)<br/><br/>def display_all_button_colors(self):<br/>  number_of_columns = self.find_number_of_columns()<br/>  for r in range(MAX_NUMBER_OF_DRUM_SAMPLES):<br/>    for c in range(number_of_columns):<br/>      self.display_button_color(r, c)</pre>
<p>The idea is simple. A button is to be colored green if the value of the button is found to be <kbd>True</kbd> in our data structure, or else the button is to be shaded in patterns of <kbd>COLOR_1</kbd> and <kbd>COLOR_2</kbd> for each alternating unit of beats.</p>
<p>This alternating color is obtained by using this mathematical formula:</p>
<pre>original_color = COLOR_1 if (col//bpu)%2) else COLOR_2</pre>
<p>Remember that we had created a two-dimensional Boolean list called <kbd>is_button_clicked_list</kbd> as a dictionary item in our original data structure to hold this value.</p>
<p>We change the color of the button to <kbd>BUTTON_CLICKED_COLOR</kbd> if that value is found to be <kbd>True</kbd>. Accordingly, we define a <kbd>getter</kbd> method to get the value of the button:</p>
<pre>def get_button_value(self, row, col):<br/>  return <br/>    self.all_patterns[self.current_pattern.get()]  <br/>      ['is_button_clicked_list'][row][col]</pre>
<p>Now each button is attached to the command callback named <kbd>on_button_clicked</kbd>, which is coded as follows (see code <kbd>3.03.py</kbd>):</p>
<pre>def on_button_clicked(self, row, col):<br/>  def event_handler():<br/>    self.process_button_clicked(row, col)<br/>  return event_handler</pre>
<p>Notice something fancy with this piece of code? This method defines a function within the function. It does not return a value as is typical of functions. Instead, it returns a function that can be executed at a later stage. These are called <strong>higher-order functions</strong> or, more precisely, <strong>function closures</strong>.</p>
<p>Why did we need to do this? We had to do this because each button is identified by its unique row and column-based indexes. The row values and column values are only available when the loop runs at the time of creating the buttons. The <kbd>row</kbd> and <kbd>col</kbd> variables are lost after that. We, therefore, need some way to keep these variables alive if we have to identify which button was clicked later on.</p>
<p>These callback functions come to our rescue as they encapsulate the row and column values in the function that they return at the time of creation.</p>
<div class="packt_infobox">Functions are first-class objects in Python. This means that you can pass a function to another function as a parameter and you can return a function from another function. In short, you can treat a function as any other object.<br/>
You can bind a method object to a particular context, as we did in the previous code, by nested scoping of a method within a method. Higher-order functions like these are a common way of associating functions with widgets in GUI programming.</div>
<p>You can find more information about function closures at <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">https://en.wikipedia.org/wiki/Closure_(computer_programming)</a>.<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)"/></p>
<p>We then define a method called <kbd>process_button_clicked</kbd>:</p>
<pre>def process_button_clicked(self, row, col):<br/>   self.set_button_value(row, col, not self.get_button_value(row, col))<br/>   self.display_button_color(row, col)<br/><br/>def set_button_value(self, row, col, bool_value):<br/>   self.all_patterns[self.current_pattern.get()][<br/>           'is_button_clicked_list'][row][col] = bool_value</pre>
<p>The key section in the preceding code is the line that sets the button value opposite to its current value using the <kbd>not</kbd> operator. Once the value is toggled, the method calls the <kbd>display_button_color</kbd> method to recolor the buttons.</p>
<p>Finally, let's complete this iteration by defining some dummy methods for now and attach them as command callbacks to the respective widgets:</p>
<pre>on_pattern_changed()<br/>on_number_of_units_changed()<br/>on_bpu_changed()<br/>on_open_file_button_clicked()<br/>on_button_clicked()<br/>on_play_button_clicked()<br/>on_stop_button_clicked()<br/>on_loop_button_toggled()<br/>on_beats_per_minute_changed()</pre>
<p>That completes the iteration. Now if you run the program (see code <kbd>3.03.py</kbd>), it should display all the broad visual elements:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b2060aae-7d86-4f34-beb2-31140f244c73.png"/></div>
<p>The buttons matrix should be colored in two alternating shades, and pressing the buttons should toggle its color between green and its previous color.</p>
<p>All other widgets remain non-functional at this stage as we have attached them to non-functional command callbacks. We will soon make them functional but, before we do that, let's do something to make all our future coding simple, clean, and elegant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining getter and setter methods</h1>
                </header>
            
            <article>
                
<p>In our previous section, we needed to know the value of a button in a given row and column of the button matrix for a given pattern. If the value was <kbd>True</kbd>, we colored the button green. If the value was <kbd>False</kbd>, we colored it in an alternative color.</p>
<p>We can get the value of the button by calling this line of code:</p>
<pre>self.all_patterns[self.current_pattern.get()]['is_button_clicked_list'][row][col]</pre>
<p>Notice how this line has four sets of square brackets, <kbd>[]</kbd>. Since this nested super-scripting business can soon get ugly, we encapsulated this logic in a method named <kbd>get_button_value(row, col)</kbd>. Now, whenever we need to get a button's value, we can simply call this method with the right parameters.</p>
<p>Now our code will not be littered with those ugly nested superscripts. Whenever we want to get the value of a button, we can call the <kbd>get_button_value(row, col)</kbd> method, which has a nice indicative name for the work it does. Isn't this much more readable and comprehensible than its rather ugly counterpart?</p>
<p>One thing is for sure: all logic that we build from now onward will heavily rely on data we get from, or set to, our data structure. Given that we will need all this data all the time in our program, let's write its <kbd>getter</kbd> and <kbd>setter</kbd> methods in advance. This will certainly make our lives a lot easier.</p>
<p>The goal for this part of the iteration is simple—to define <kbd>getter</kbd> and <kbd>setter</kbd> methods for all the data that we have decided to store in our data structure.</p>
<p>The code is as follows (see <kbd>code 3.04.py</kbd>):</p>
<pre>def get_current_pattern_dict(self):<br/>  return self.all_patterns[self.current_pattern_index]<br/><br/>def get_bpu(self):<br/>  return self.get_current_pattern_dict()['bpu']<br/> <br/>def set_bpu(self):<br/>  self.get_current_pattern_dict()['bpu'] = int(self.bpu_widget.get())<br/> <br/>def get_number_of_units(self):<br/>  return self.get_current_pattern_dict()['number_of_units']<br/> <br/>def set_number_of_units(self):<br/>  self.get_current_pattern_dict()['number_of_units']<br/>          = int(self.number_of_units_widget.get())<br/><br/>def get_list_of_drum_files(self):<br/>  return self.get_current_pattern_dict()['list_of_drum_files']<br/><br/>def get_drum_file_path(self, drum_index):<br/>  return self.get_list_of_drum_files()[drum_index]<br/> <br/>def set_drum_file_path(self, drum_index, file_path):<br/>  self.get_list_of_drum_files()[drum_index] = file_path <br/><br/>def get_is_button_clicked_list(self):<br/>  return self.get_current_pattern_dict()['is_button_clicked_list']<br/><br/>def set_is_button_clicked_list(self, num_of_rows, num_of_columns):<br/>  self.get_current_pattern_dict()['is_button_clicked_list']<br/>        = [[False] * num_of_columns for x in range(num_of_rows)]</pre>
<p>That is all there is to coding the <kbd>getter</kbd> and <kbd>setter</kbd> methods. The code should be self-explanatory if you have understood the underlying data structure, as all that we do here is either get a value or set a value for various items in the data structure.</p>
<p>With these methods now handy, let's complete coding the functionality of widgets we had earlier left uncoded.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The number of units and beats per unit features</h1>
                </header>
            
            <article>
                
<p>We earlier coded the matrix called <kbd>create_right_button_matrix</kbd>, which creates a two-dimensional matrix with the number of rows equal to <kbd>MAX_NUMBER_OF_DRUM_SAMPLES</kbd>. The number of columns would be decided by multiplying the number of units by the beats per unit values selected by the end user. Its formula can be given as follows:</p>
<p class="CDPAlignCenter CDPAlign"><em>Number of columns of buttons = Number of units x BPU</em></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/62fb1dbc-f9ee-45d9-a72d-24fef899dc02.png"/></div>
<p>This means that every time the user changes the number of units or the beats per unit, the button matrix should be redrawn to change the number of columns. This change should also be reflected in our underlying data structure. Let's add this feature to our drum machine.</p>
<p>We had earlier defined two dummy methods—<kbd>on_number_of_units_changed()</kbd> and <kbd>on_bpu_changed()</kbd>. We modify them now as follows (see <kbd>code 3.04.py</kbd>):</p>
<pre>def on_number_of_units_changed(self):<br/>  self.set_number_of_units()<br/>  self.set_is_button_clicked_list(MAX_NUMBER_OF_DRUM_SAMPLES,<br/>                    self.find_number_of_columns())<br/>  self.create_right_button_matrix()<br/> <br/>def on_bpu_changed(self):<br/>  self.set_bpu()<br/>  self.set_is_button_clicked_list(MAX_NUMBER_OF_DRUM_SAMPLES,<br/>                    self.find_number_of_columns())<br/>  self.create_right_button_matrix()</pre>
<p>The preceding methods do two things:</p>
<ul>
<li>Modify the data structure to reflect the changes in BPU or number of units</li>
<li>Call the <kbd>create_right_button_matrix()</kbd> method to recreate the button matrix</li>
</ul>
<p>Now if you go and run the code (see code <kbd>3.04.py</kbd>) and change either the values of number of units or BPU, the button matrix should redraw itself to reflect the change.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading drum samples</h1>
                </header>
            
            <article>
                
<p>Our main objective is to play sound files in the order of a beat pattern decided by the user. To do this, we need to add sound files to the drum machine.</p>
<p>Our program does not have any preloaded drum files. Instead, we want to let the user select from a wide variety of drum files.</p>
<p>Thus, besides the normal drum, you can play a Japanese tsuzumi, an Indian tabla, Latin American bongo drums, or just about any other sound that you want to add to your rhythm. All you need is a small <kbd>.wav</kbd> or <kbd>.ogg</kbd> file containing that sound's sample. </p>
<p>T<span>he drum sample is to be loaded on the left bar, as shown in </span>the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="246" src="assets/6b80c556-2219-4b10-a3a7-7b5cdc2c0de3.png" width="172"/></div>
<p>Let's code the ability to add drum samples to our program.</p>
<p>We have already created buttons with folder icons on the left-hand side of our drum pad. Now we need to make it functional. The desired functionality is simple. When a user clicks on any of the left buttons, they should open a file dialog letting the user choose a <kbd>.wav</kbd> or <kbd>.ogg</kbd> file. When the user selects the file and clicks on <span class="packt_screen">Open</span>, the Entry widget next to that button should be populated with the name of the file.</p>
<p>Further, the location of the drum sample file should be added to our data structure at the appropriate place.</p>
<p>First, we will import the required modules.</p>
<p>We will use the <kbd>filedialog</kbd> module to ask the user to select drum files. We have already used the file dialog module in <a href="41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml">Chapter 2</a>, <em>Making a Text Editor</em>. The functionality here is very similar. We will also need to extract the filename of the given sound sample using the <kbd>os</kbd> module. Let's begin by importing the two modules (see <kbd>code 3.05.py</kbd>):</p>
<pre>import os<br/>from tkinter import filedialog</pre>
<p>The buttons we created for uploading drum files are attached to the <kbd>on_open_file_button_clicked</kbd> method through a command callback. We created a dummy method earlier by that name. We now modify that method to add the required functionality (see <kbd>code 3.05.py</kbd>):</p>
<pre>def on_open_file_button_clicked(self, drum_index):<br/>   def event_handler():<br/>     file_path = filedialog.askopenfilename<br/>        (defaultextension=".wav", filetypes=[("Wave Files",<br/>       "*.wav"), ("OGG Files", "*.ogg")])<br/>     if not file_path:<br/>        return<br/>     self.set_drum_file_path(drum_index, file_path)<br/>     self.display_all_drum_file_names()<br/>     return event_handler</pre>
<p>The preceding method again returns a function, as we need to track which of the drum files was actually selected from all the rows of drum files. </p>
<p>The preceding code does three things:</p>
<ul>
<li>Asks the user for the file path using Tkinter's <kbd>filedialog</kbd></li>
<li>Modifies the underlying data structure to save the provided file path</li>
<li>Calls another method to display the filename in the adjacent Entry widget</li>
</ul>
<p>The next two methods are then responsible for displaying all drum names in the frontend (see code <kbd>3.05.py</kbd>):</p>
<pre>def display_all_drum_file_names(self):<br/>   for i, drum_name in enumerate(self.get_list_of_drum_files()):<br/>       self.display_drum_name(i, drum_name)<br/><br/>def display_drum_name(self, text_widget_num, file_path):<br/>   if file_path is None: return<br/>   drum_name = os.path.basename(file_path)<br/>   self.drum_load_entry_widget [text_widget_num].delete(0, END)<br/>   self.drum_load_entry_widget[text_widget_num].insert(0, drum_name)</pre>
<p>The preceding method uses <kbd>os.path.basename</kbd> from the <kbd>os</kbd> module to obtain the filename from the file path.</p>
<p>This completes the section. Our code is now capable of loading drum samples and storing records of all file paths in the data structure. Go ahead and try loading some drum samples (see code <kbd>3.05.py</kbd>) and the program should display the name of the drum file in the adjacent Entry widget.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Playing the drum machine</h1>
                </header>
            
            <article>
                
<p>Now that we have a mechanism to load drum samples and a mechanism to define beat patterns in place, let's add the ability to play these beat patterns. In many ways, this is the core of our program.</p>
<p>Let's first understand the functionality that we want to achieve here.</p>
<p>Once the user has loaded one or more drum samples and has defined a beat pattern using the toggle buttons, we need to scan each column of the pattern to see if it finds a green button (a <kbd>True</kbd> value in our data structure).</p>
<p>If the value is <kbd>True</kbd> for a given location in the matrix, our code should play the corresponding drum sample before moving ahead. If two or more drum samples are selected in the same column, all the samples should play almost simultaneously.</p>
<p>Moreover, there should be a fixed time gap between the playing of each successive column, which will define the tempo of the music.</p>
<p>To achieve this functionality, we need to import the <kbd>pygame</kbd> module to play the sounds, and the <kbd>time</kbd> module to define the temporal gap between them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initializing pygame</h1>
                </header>
            
            <article>
                
<p>The <kbd>pygame</kbd> module is a set of highly portable modules that runs on most operating systems. We will use the mixer module from <kbd>pygame</kbd> to play the sound files.</p>
<p>Assuming that you have installed the package, let's begin by importing <kbd>pygame</kbd> (see code <kbd>3.06.py</kbd>):</p>
<pre>import pygame</pre>
<p>According to the official API documentation of the mixer module at <a href="http://www.pygame.org/docs/ref/mixer.html">http://www.pygame.org/docs/ref/mixer.html</a>, we need to initialize <kbd>pygame</kbd> before we can play back the audio files.</p>
<p>We initialize <kbd>pygame</kbd> in a new method called <kbd>init_pygame</kbd> (see code <kbd>3.06.py</kbd>):</p>
<pre>def init_pygame(self):<br/> pygame.mixer.pre_init(44100, -16, 1, 512)<br/> pygame.init()</pre>
<p>The <kbd>mixer.pre_init</kbd> method is a special requirement for our drum machine because the lack of it causes a lot of sound lagging. We will not get into the details of audio programming here, but suffice to say that the arguments to the <kbd>pre_init</kbd> method are as follows:</p>
<pre>pre_init(frequency=22050, size=-16, channels=2, buffersize=512) </pre>
<p>After <kbd>pygame</kbd> is initialized like this, the documentation suggests the following code to play the sound. Let's add this to our code as well (see code <kbd>3.06.py</kbd>):</p>
<pre> def play_sound(self, sound_filename):<br/>   if sound_filename is not None:<br/>      pygame.mixer.Sound(sound_filename).play()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Playing complete patterns</h1>
                </header>
            
            <article>
                
<p>Now our program has the ability to play any sound. But we don't just need to play a single sound. We need to play a pattern. Let's define a method called <kbd>play_pattern</kbd>, which reads our internal data structure and plays files accordingly (see code <kbd>3.06.py</kbd>):</p>
<pre class="mce-root">import time<br/>    def play_pattern(self):<br/>        self.now_playing = True<br/>        while self.now_playing:<br/>            play_list = self.get_is_button_clicked_list()<br/>            num_columns = len(play_list[0])<br/>            for column_index in range(num_columns):<br/>                column_to_play = self.get_column_from_matrix(<br/>                      play_list, column_index)<br/>                for i, item in enumerate(column_to_play):<br/>                    if item:<br/>                        sound_filename = self.get_drum_file_path(i)<br/>                        self.play_sound(sound_filename)<br/>                time.sleep(self.time_to_play_each_column())<br/>                if not self.now_playing: break<br/>            if not self.loop: break <br/>        self.now_playing = False</pre>
<p class="mce-root">We also add an associated method that returns the <em>i</em><sup>th</sup> column from a matrix:</p>
<pre>def get_column_from_matrix(self, matrix, i):<br/>  return [row[i] for row in matrix]</pre>
<p>The description of the preceding code is as follows:</p>
<ul>
<li>
<p>We create a class attribute called <kbd>self.keep_playing</kbd> to decide whether the pattern is to be played just once or continuously in a loop.</p>
</li>
<li>
<p>We create another class attribute called <kbd>self.now_playing</kbd> to track whether a beat is currently playing. This will help us to make some decisions on how to handle a sudden close of program or change of pattern by the user.</p>
</li>
<li>
<p>We then fetch the two-dimensional Boolean list from our data structure and scan each column of the list to look for <kbd>True</kbd> values. We get the column data from the matrix by defining a separate method called <kbd>get_column_from_matrix(self, matrix, i)</kbd>.</p>
</li>
<li>
<p>For every column, if a <kbd>True</kbd> value is encountered, we fetch the corresponding drum file path and call the <kbd>self.play_sound()</kbd> method to play the file.</p>
</li>
<li>
<p>The code sleeps for a fixed duration of time before reading the second column. This sleep duration defines the tempo of the drum beat. If the code does not sleep for some time between each column, all the patterns would play almost immediately and would not even sound like a rhythm. We need to import the <kbd>time</kbd> module to use the <kbd>time.sleep()</kbd> method.</p>
</li>
<li>
<p>The amount of time the code sleeps between scanning each column is decided by another method called <kbd>self.time_to_play_each_column()</kbd>, which we define next.</p>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Determining the tempo of a rhythm</h1>
                </header>
            
            <article>
                
<p>The mathematics of defining the tempo of a rhythm is simple. We get the value associated with the <kbd>beats_per_minute</kbd> attribute and divide it by <kbd>60</kbd> to get the beats per second. Then, the time to play each beat (or group of beats simultaneously for a given column) is the reciprocal of <kbd>beats_per_second</kbd>.</p>
<p>The code is as follows (see code <kbd>3.06.py</kbd>):</p>
<pre>def time_to_play_each_column(self):<br/>  beats_per_second = self.beats_per_minute/60<br/>  time_to_play_each_column = 1/beats_per_second<br/>  return time_to_play_each_column</pre>
<p>While we are handling the tempo for the pattern, let's also complete coding of the command callback attached to our beats per minute Spinbox widget (see code <kbd>3.06.py</kbd>):</p>
<pre>def on_beats_per_minute_changed(self):<br/>   self.beats_per_minute = int(self.beats_per_minute_widget.get())</pre>
<p>Now let's code the functionality related to the loop Checkbox. We have already factored in the looping issue in our <kbd>play_pattern</kbd> method using the <kbd>self.loop</kbd> variable. We simply need to set the value of the <kbd>self.loop</kbd> attribute by reading the value of the Spinbox widget (see code <kbd>3.06.py</kbd>):</p>
<pre>def on_loop_button_toggled(self):<br/>  self.loop = self.loopbuttonvar.get()</pre>
<p>With that out of the way, let's code the command callback attached to our <span class="packt_screen">Play</span> button and the <span class="packt_screen">Stop</span> button (see code <kbd>3.06.py</kbd>):</p>
<pre>def on_play_button_clicked(self):<br/>  self.start_play()<br/><br/>def start_play(self):<br/>  self.init_pygame()<br/>  self.play_pattern()<br/><br/>def on_stop_button_clicked(self):<br/>  self.stop_play()<br/><br/>def stop_play(self):<br/>  self.now_playing = False</pre>
<p>Our drum machine is now operational (see code <kbd>3.06.py</kbd>). You can load drum samples and define beat patterns, and when you click on the <span class="packt_screen">Play</span> button, the drum machine plays that beat pattern!</p>
<p>However, there is a small problem. The <kbd>play_sound</kbd> method blocks the main loop of our Tkinter program. It does not relinquish control back to the main loop until it is done playing the sound sample.</p>
<p>Since our <kbd>self.loop</kbd> variable is set to <kbd>True</kbd>, this means that <kbd>pygame</kbd> never returns back control to Tkinter's main loop and our play button and program is stuck! This can be seen in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3f8fd9e9-473b-4d5f-94ae-892dc30c887b.png"/></div>
<p>This means that if you now want to click on the <span class="packt_screen">Stop</span> button or change some other widget, or even close the window, you will have to wait for the play loop to complete, which never happens in our case.</p>
<p>This is clearly a glitch. We need some method to confer back the control to the Tkinter main loop while the play is still in progress.</p>
<p>That brings us to the next iteration, where we discuss and implement <strong>multithreading</strong> in our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tkinter and threading</h1>
                </header>
            
            <article>
                
<p>One of the simplest ways that we can make our root window responsive is to use the <kbd>root.update()</kbd> method within our <kbd>play_pattern</kbd> loop. This updates the <kbd>root.mainloop()</kbd> method after each sound sample is played.</p>
<p>However, this is an inelegant method because the control is passed to the main loop with some staggering experienced in the GUI. Thus, you may experience a slight delay in the responses of other widgets in the Toplevel window.</p>
<p>Further, if some other event causes the method to be called, it could result in a nested event loop.</p>
<p>A better solution would be to run the <kbd>play_pattern</kbd> method from a separate <strong>thread</strong>.</p>
<p>Let's use the threading module of Python to play the pattern in a separate thread. This way, <kbd>pygame</kbd> will not interfere with Tkinter's main loop.</p>
<p>A thread is a coding construct that can advance two or more separate sets of logical workflow together within an instance of a running program (process), <strong>context-switching</strong> between the workflows. Each thread in a running program gets its own stack and its own program counter, but all threads in a process share the same memory.</p>
<p>In contrast to threads, processes are independent execution instances of programs, each maintaining its own state information and address space. Processes can only interact with other processes using interprocess communication mechanisms.</p>
<p>Threading is a topic for a book in itself. However, we will not get into the details and instead will use the threading module from the Python standard library. The threading module provides a higher-level threading interface to hide away the inner complexities of implementing a multithreaded program. To use the module, let's first import the threading module into our namespace (see code <kbd>3.07.py</kbd>):</p>
<pre>import threading</pre>
<p>Now, let's create a method, <kbd>play_in_thread()</kbd>, as follows (<kbd>3.07.py</kbd>): </p>
<pre>def play_in_thread(self):<br/>  self.thread = threading.Thread(target = self.play_pattern)<br/>  self.thread.start() </pre>
<p>Finally, change the <kbd>start_play</kbd> method to call the <kbd>play_in_thread</kbd> rather than calling the <kbd>play_pattern</kbd> directly:</p>
<pre>def start_play(self):<br/>  self.init_pygame()<br/>  self.play_in_thread() # deleted direct call to self.play_pattern()</pre>
<p>Now if you load some drum samples, define the beat patterns, and hit the <span class="packt_screen">Play</span> button, the sound will play in a separate thread without causing other widgets to become unresponsive (see code <kbd>3.07.py</kbd>).</p>
<p>However, this poses a new problem. What happens if the user clicks the <span class="packt_screen">Play</span> button multiple times? That would spawn multiple threads of beat patterns all playing simultaneously.</p>
<p>We can overcome this problem by disabling the <span class="packt_screen">Play</span> button when the audio is playing. This can be achieved by defining <kbd>toggle_play_button_state()</kbd> (see code <kbd>3.07.py</kbd>):</p>
<pre>def toggle_play_button_state(self):<br/>  if self.now_playing:<br/>    self.play_button.config(state="disabled")<br/>  else:<br/>   self.play_button.config(state="normal")</pre>
<p>We then attach this state toggling method onto the Play, Stop, and Loop widget command callbacks, as follows (<kbd>3.07.py</kbd>):</p>
<pre>def on_play_button_clicked(self):<br/>  self.start_play()<br/>  self.toggle_play_button_state()<br/><br/>def on_stop_button_clicked(self):<br/>  self.stop_play()<br/>  self.toggle_play_button_state()<br/><br/>def on_loop_button_toggled(self):<br/>  self.loop = self.to_loop.get()<br/>  self.keep_playing = self.loop<br/>  if self.now_playing:<br/>    self.now_playing = self.loop<br/>    self.toggle_play_button_state()</pre>
<p>We also modify our <kbd>play_pattern()</kbd> method to include a call to <kbd>toggle_play_button_state()</kbd> at the end (see code <kbd>3.07.py</kbd>). This will ensure that when the pattern has ended playing, the <span class="packt_screen">Play</span> button returns to its normal state.</p>
<p>The <span class="packt_screen">Play</span> button now remains in a disabled state as long as some audio is playing. It returns to a normal state when audio isn't playing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tkinter and thread safety</h1>
                </header>
            
            <article>
                
<p>Tkinter is not thread safe. The Tkinter interpreter is valid only in the thread that runs the main loop. Any calls to widgets must ideally be done from the thread that created the main loop. Invoking widget-specific commands from other threads is possible but is not reliable.</p>
<p>When you call a widget from another thread, the events get queued for the interpreter thread, which executes the command and passes the result back to the calling thread. If the main loop is running but not processing events, it sometimes results in unpredictable exceptions.</p>
<p>In fact, if you find yourself calling a widget from a thread other than the main loop, chances are that you have not separated the visual elements from the underlying data structure. You are possibly doing it wrong.</p>
<p>Before we complete this iteration, let's take care of a small detail. What happens if a beat is currently playing and the user hits the Close button on the window? The main loop will die and our audio-playing thread will be left in an orphaned state. This can lead to ugly error messages thrown at the user.</p>
<p>Let's, therefore, override the Close button and stop the audio play before we quit the window. To override the Close button, we add a small line to our class <kbd>__init__</kbd> method, as follows (see code <kbd>3.07.py</kbd>):</p>
<pre> self.root.protocol('WM_DELETE_WINDOW', self.exit_app)</pre>
<p>Then, we define a method called <kbd>exit_app()</kbd>, as follows (see code <kbd>3.07.py</kbd>):</p>
<pre>def exit_app(self):<br/>  self.now_playing = False<br/>  if messagebox.askokcancel("Quit", "Really quit?"):<br/>    self.root.destroy()</pre>
<p>This completes the project iteration.</p>
<p>To summarize, we refined our <kbd>start_play()</kbd> method to play the audio files on a separate thread. We also made sure to disable the <span class="packt_screen">Play</span> button as long as the audio plays. Finally, we overrode the Close button to handle exiting when some audio is currently playing.</p>
<p>We used Python's built-in threading module to play the loops in a separate thread. We also looked at some of the threading-related limitations of Tkinter. However, threading is a vast topic in itself and we have just scratched the surface here.</p>
<p>You can find more details about the threading module at <a href="https://docs.python.org/3/library/threading.html">https://docs.python.org/3/library/threading.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Support for multiple beat patterns</h1>
                </header>
            
            <article>
                
<p>Our drum program is now functional. You can load drum samples and define a beat pattern and our drum machine will play it.</p>
<p>Let's now extend our drum machine to create more than one pattern in the same program. This will provide us with the ability to play different patterns simply by changing the pattern number. This gives the user the ability to make different beats for the intro, verse, chorus, bridge, and other parts of a song. The pattern-changing user interface is highlighted in red in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7606143a-fe26-4e33-8d6e-6ff623910f51.png"/></div>
<p>At the very outset, we have an Entry widget adjacent to the Pattern Number Spinbox widget. We want to display the current pattern number in that Entry widget. We accordingly create a method, <kbd>display_pattern_name()</kbd>, which does this task (see code <kbd>3.08.py</kbd>):</p>
<pre> def display_pattern_name(self):<br/>   self.current_pattern_name_widget.config(state='normal')<br/>   self.current_pattern_name_widget.delete(0, 'end')<br/>   self.current_pattern_name_widget.insert(0,<br/>               'Pattern {}'.format(self.current_pattern_index))<br/>   self.current_pattern_name_widget.config(state='readonly')</pre>
<p>We want the pattern name to display in the text widget when the program initially launches. Therefore, we modify our <kbd>create_top_bar()</kbd> method to include a call to this newly defined method (see code <kbd>3.08.py</kbd>).</p>
<p>A change of pattern requires several changes. First of all, let's modify the <kbd>on_pattern_changed()</kbd> command callback to call a new method, <kbd>change_pattern()</kbd>, as follows (see code <kbd>3.08.py</kbd>):</p>
<pre> def on_pattern_changed(self):<br/>   self.change_pattern()</pre>
<p>Next, let's define the <kbd>change_pattern()</kbd> method:</p>
<pre> def change_pattern(self):<br/>   self.current_pattern_index = int(self.pattern_index_widget.get())<br/>   self.display_pattern_name()<br/>   self.create_left_drum_loader()<br/>   self.display_all_drum_file_names()<br/>   self.create_right_button_matrix()<br/>   self.display_all_button_colors()</pre>
<p>The preceding code should almost read like plain English and the steps involved in a change of pattern should be self-explanatory.</p>
<p>This completes coding our drum machine to support multiple beat patterns. Go ahead and run code <kbd>3.08.py</kbd>. Load some drum files, define the first beat pattern, and play it. Change the beat pattern using the Spinbox widget at the top left,<br/>
load new drums, and define a new pattern. Then, play that pattern. While it is playing, try switching to your first beat pattern. The change should happen seamlessly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving beat patterns</h1>
                </header>
            
            <article>
                
<p>In the preceding iteration, we added the capability to define multiple beat patterns. </p>
<p>However, the beat patterns can be played only on a single script run. When the program is closed and restarted, all previous pattern data is lost.</p>
<p>We need a way to persist or store the beat patterns beyond a single program run. We need the ability to store values in some form of file storage and reload, play, and even edit the patterns. We need some form of <strong>object persistence</strong>.</p>
<p>Python provides several modules for object persistence. The module that we will use for persistence is called the <kbd>pickle</kbd> module. Pickle is a standard library of Python.</p>
<p>An object represented as a string of bytes is called a <strong>pickle</strong> in Python. <strong>Pickling</strong>, also known as object <strong>serialization</strong>, let's us convert our object into a string of bytes. The process of reconstructing the object from the string of bytes is called <strong>unpickling</strong> or <strong>deserialization</strong>.</p>
<p>More information about the <kbd>pickle</kbd> module is available at <a href="http://docs.python.org/3/library/pickle.html">http://docs.python.org/3/library/pickle.html</a>.</p>
<p>Let's illustrate it with a simple example:</p>
<pre>import pickle<br/>party_menu= ['Bread', 'Salad', 'Bordelaise', 'Wine', 'Truffles']<br/>pickle.dump(party_menu, open("my_menu", "wb"))</pre>
<p>First, we serialize or pickle our list, <kbd>party_menu</kbd>, using <kbd>pickle.dump</kbd>, and save it in an external file, <kbd>my_menu</kbd>.</p>
<p>We later retrieve the object using <kbd>pickle.load</kbd>:</p>
<pre>import pickle<br/>menu= pickle.load( open( "my_menu", "rb" ) )<br/>print(menu) # prints ['Bread', 'Salad', 'Bordelaise', 'Wine', 'Truffles']</pre>
<p>Coming back to our drum machine—if we need to store and reuse the beat patterns, we only need to pickle our data structure list, named <kbd>self.all_patterns</kbd>. Having saved the object, we can later easily unpickle the file to reconstruct our beat patterns.</p>
<p>We first need to add three top-menu items to our program, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/87a44fda-a35d-45de-beb5-5c82f1e10240.png"/></div>
<p>The three top-menu items are:</p>
<ul>
<li><strong><span class="packt_screen">File</span></strong> | <strong><span class="packt_screen">Load Project</span></strong></li>
<li><span><span class="packt_screen">File</span> | <span class="packt_screen">Save Project</span></span></li>
<li><span><span class="packt_screen">File</span> | <span class="packt_screen">Exit</span></span></li>
</ul>
<p>While we are creating our menu items, let's also add an <span class="packt_screen">About</span> menu item. </p>
<p>Here, we are particularly interested in saving the project (pickling), and loading the project back (unpickling). The code for menu items is defined in a separate method called <kbd>create_top_menu</kbd>, as shown in the following code (see code <kbd>3.09.py</kbd>):</p>
<pre>def create_top_menu(self):<br/>  self.menu_bar = Menu(self.root)<br/>  self.file_menu = Menu(self.menu_bar, tearoff=0)<br/>  self.file_menu.add_command( <br/>       label="Load Project", command=self.load_project)<br/>  self.file_menu.add_command(<br/>      label="Save Project", command=self.save_project)<br/>  self.file_menu.add_separator()<br/>  self.file_menu.add_command(label="Exit", command=self.exit_app)<br/>  self.menu_bar.add_cascade(label="File", menu=self.file_menu)<br/>  self.about_menu = Menu(self.menu_bar, tearoff=0)<br/>  self.about_menu.add_command(label="About",command=self.show_about)<br/>  self.menu_bar.add_cascade(label="About", menu=self.about_menu)<br/>  self.root.config(menu=self.menu_bar)</pre>
<p>The code is self-explanatory. We have created similar menu items in our last two projects. Finally, to display this menu, we call this method from our <kbd>init_gui()</kbd> method.</p>
<p>To pickle our object, we first import the pickle module into the current namespace, as follows (<kbd>3.09.py</kbd>):</p>
<pre>import pickle </pre>
<p>The <span class="packt_screen">Save Project</span> menu has a command callback attached to <kbd>self.save_project</kbd>, which is where we define the pickling process:</p>
<pre>def save_project(self):<br/>  saveas_file_name = filedialog.asksaveasfilename<br/>               (filetypes = [('Explosion Beat File','*.ebt')],<br/>              title="Save project as...")<br/>  if saveas_file_name is None: return<br/>  pickle.dump( self.all_patterns, open(saveas_file_name, "wb"))<br/>  self.root.title(os.path.basename(saveas_file_name) +PROGRAM_NAME)</pre>
<p>The description of the code is as follows:</p>
<ul>
<li>The <kbd>save_project</kbd> method is called when the user clicks on the <span class="packt_screen">Save Project</span> menu; hence, we need to give the user an option to save the project in a file. </li>
<li>We have chosen to define a new file extension (<kbd>.ebt</kbd>) to keep track of our beat patterns. This is a completely arbitrary choice of extension name.</li>
<li>When the user specifies the filename, it is saved with a <kbd>.ebt</kbd> extension. The file contains the serialized list <kbd>self.all_patterns</kbd>, which is dumped into the file using <kbd>pickle.dump</kbd>.</li>
<li>Lastly, the title of the Toplevel window is changed to reflect the filename. </li>
</ul>
<p>We are done pickling the object. Let's now code the unpickling process. The unpickling process is handled by a method, <kbd>load_project</kbd>, which is called from the <span class="packt_screen">Load Project</span> menu, as follows:</p>
<pre>  def load_project(self):<br/>     file_path = filedialog.askopenfilename(<br/>     filetypes=[('Explosion Beat File', '*.ebt')], title='Load Project')<br/>     if not file_path:<br/>        return<br/>     pickled_file_object = open(file_path, "rb")<br/>     try:<br/>        self.all_patterns = pickle.load(pickled_file_object)<br/>     except EOFError:<br/>        messagebox.showerror("Error", "Explosion Beat file seems corrupted or invalid !")<br/>     pickled_file_object.close()<br/>     try:<br/>       self.change_pattern()<br/>       self.root.title(os.path.basename(file_path) + PROGRAM_NAME)<br/>     except:<br/>       messagebox.showerror("Error",<br/>        "An unexpected error occurred trying to process the beat file")</pre>
<p class="mce-root">The description of the code is as follows:</p>
<ul>
<li class="mce-root">When a user clicks on the <span class="packt_screen">Load Project</span> menu, it triggers a command callback connected to this <kbd>load_project</kbd> method.</li>
<li class="mce-root">The first line of the method prompts the user with an <span class="packt_screen">Open File</span> window. When the user specifies a previously pickled file with a <kbd>.ebt</kbd> extension, the filename is stored in a variable called <kbd>pickled_file_object</kbd>.</li>
<li class="mce-root">If the filename returned is <kbd>None</kbd> because the user cancels the <span class="packt_screen">Open File</span> dialog, nothing is done. The file is then opened in read mode, and the contents of the file are read into <kbd>self.all_patterns</kbd> using <kbd>pickle.load</kbd>.</li>
<li class="mce-root"><kbd>self.all_patterns</kbd> now contains the list of beat patterns defined in the previous pickle.</li>
<li class="mce-root">The file is closed and the first pattern of <kbd>self.all_patterns</kbd> is reconstructed by calling our previously defined <kbd>change_pattern()</kbd> method.</li>
</ul>
<p>This should load the first pattern on our drum machine. Try playing any of the patterns, and you should be able to replay the pattern exactly as it was defined at the time of pickling.</p>
<p>Note, however, that the pickled <kbd>.ebt</kbd> files are not portable from one computer to another. This is because we have just pickled the file path for our drum files. We have not pickled the actual audio files. So if you try to run the <kbd>.ebt</kbd> file on another machine or if the file path to the audio files has changed since the pickling, our code will not be able to load the audio files and will report an error.</p>
<p>The process of pickling uncompressed audio files like those in <kbd>.wav</kbd> files, <kbd>.ogg</kbd> files, or PCM data is the same as the preceding process. After all, these uncompressed audio files are nothing but lists of numbers.</p>
<p>However, trying to pickle audio files here would require us to deviate a lot from our current topic. Therefore, we have not implemented it here.</p>
<div class="packt_tip">Pickling, though great for serialization, is vulnerable to malicious or erroneous data. You may want to pickle only if the data is from a trusted source, or if proper validation mechanisms are in place.<br/>
You may also find the <kbd>json</kbd> module useful for serializing objects in JSON. Also, the <kbd>ElementTree</kbd> and <kbd>xml.minidom</kbd> libraries are relevant for parsing XML data.</div>
<p class="mce-root">To end this section, let's complete coding the response to clicking on the <span class="packt_screen">About</span> menu item:</p>
<pre class="mce-root">def show_about(self):<br/>  messagebox.showinfo(PROGRAM_NAME, <br/>                   "Tkinter GUI Application\n Development  Blueprints")</pre>
<p class="mce-root">This is self-explanatory. We have done similar coding in our previous project.</p>
<p class="mce-root">To summarize this iteration, we used Python's built-in pickle module to pickle and unpickle the beat patterns defined by the user.</p>
<p class="mce-root">This now lets us save our beat patterns. We can later load, replay, and edit these saved patterns in our drum machine (see code <kbd>3.09.py</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with ttk-themed widgets</h1>
                </header>
            
            <article>
                
<p>We are almost done programming our drum machine. However, we would like to end this chapter by introducing you to ttk-themed widgets. </p>
<p>Tkinter does not bind to the native platform widgets on many platforms, such as Microsoft Windows and X11.</p>
<p>The Tk toolkit (and Tkinter) originally appeared on <strong>X-Window systems;</strong> hence, it adopted the motif style that was the <em>de facto</em> standard for GUI development on X-Window systems.</p>
<p>When Tk was ported to other platforms, such as Windows and Mac OS, this motif style started appearing out of place with the look of these platforms.</p>
<p>Due to this, some even argue that Tkinter widgets are rather ugly and do not integrate well with such desktop environments.</p>
<p>Another criticism of Tkinter is based on the fact that Tkinter mixes logic and styling by allowing both to be changed as widget options.</p>
<p>Tkinter was also criticized for lacking any kind of theming support. Although we saw an example of centralized styling via the option database, the method required styling to be done at the widget level. It does not allow for selective styling of two Button widgets differently, for example. This made it difficult for developers to implement visual consistency for similar groups of widgets while differentiating them from other groups of widgets.</p>
<p>As a result of this, many GUI developers moved to Tkinter alternatives, such as <strong>wxPython</strong>, <strong>PySide</strong>, and <strong>PyQT</strong>.</p>
<p>With Tkinter 8.5, the makers of Tkinter have tried to address all these concerns by introducing the <strong>ttk module</strong>, which may be considered as an advance to the original Tkinter module.</p>
<p>Let's take a look at some of the features offered by the ttk-themed widgets module. </p>
<p>One of the first things that ttk does is provide a set of built-in themes that allows Tk widgets to look like the native desktop environment in which the application is running.</p>
<p>Additionally, it introduces 6 new widgets—<strong>Combobox</strong>, <strong>Notebook</strong>, <strong>Progressbar</strong>, <strong>Separator</strong>, <strong>Sizegrip</strong>, and <strong>Treeview</strong> to the list of widgets, in addition to supporting 11 core Tkinter widgets, which are Button, Checkbutton, Entry, Frame, Label, LabelFrame, Menubutton, PanedWindow, Radiobutton, Scale, and Scrollbar.</p>
<p>To use the ttk module, we first import it into the current namespace:</p>
<pre>from tkinter import ttk</pre>
<p>You can display the ttk widgets as follows (see code <kbd>3.10.py</kbd>):</p>
<pre>ttk.Button(root, text='ttk Button').grid(row=1, column=1)<br/>ttk.Checkbutton(root, text='tkCheckButton').grid(row=2, column=1)</pre>
<p>Code <kbd>3.10.py</kbd> provides a comparison of displays between the normal Tkinter widgets and the counterpart ttk widgets, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c5bf786b-584c-448e-9fc0-9704f879de32.png"/></div>
<p>Notice that the preceding screenshot is taken on a Microsoft Windows platform as the differences are more marked on systems that do not explicitly use the X-Window system. Notice how Tkinter widgets (on the left) look out of place on Microsoft Windows as compared to ttk widgets (on the right), which is the native Microsoft Windows look and feel (see code <kbd>3.10.py</kbd>).</p>
<div class="packt_infobox">You can even override the basic Tkinter widgets by importing ttk after Tkinter as follows:<br/>
<kbd>from tkinter import *</kbd><br/>
<kbd>from tkinter.ttk import *</kbd><br/>
This causes all widgets common to Tk and ttk to be replaced by ttk widgets.<br/>
This has the direct benefit of using the new widgets, which gives a better look and feel across platforms.<br/>
However, the disadvantage of this kind of import is that you cannot distinguish the module from which the widget classes are imported. This is important because the Tkinter and ttk widget classes are not completely interchangeable. In this case, an unambiguous solution is to import them, as shown in the following code:<br/>
<kbd>import tkinter as tk</kbd><br/>
<kbd>from tkinter import ttk</kbd></div>
<p>Although most of the configuration options for Tkinter and ttk widgets are common, ttk-themed widgets do not support styling options such as fg, bg, relief, and border. This is purposefully removed from ttk in an attempt to keep logic and styling in different controls.</p>
<p>Instead, all styling-related options are handled by the respective style names. In a standard ttk module, each widget has an associated style name. You can retrieve the default style name of a widget using the <kbd>widget.winfo_class()</kbd> method.</p>
<p>For instance, consider a ttk Button:</p>
<pre>&gt;&gt;&gt; my_button = ttk.Button()<br/>&gt;&gt;&gt; my_button.winfo_class()</pre>
<p>This prints <kbd>Tbutton</kbd>, which is the default style name for <kbd>ttk.Button</kbd>. For a list of default ttk style names for different widgets, refer to <a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/ttk-style-layer.html">http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/ttk-style-layer.html</a>.</p>
<p>In addition to the default style, you can assign a custom style class to a widget or group of widgets. To set up a new style, you use the following:</p>
<pre> style = ttk.Style()</pre>
<p>To configure the style options for a default style, you use the command: </p>
<pre>style.configure('style.Defaultstyle', **styling options)</pre>
<p>To create a new style from the built-in styles, define a style name of the form <kbd>newName.oldName</kbd>. For instance, to create an Entry widget to hold a date, you can call it <kbd>Date.Tentry</kbd>.</p>
<p>To use the new style on a widget, you use the command:</p>
<pre>ttk.Widget(root, style='style.Defaultstyle') </pre>
<p>Next, we will discuss <strong>ttk theming</strong>.</p>
<p>The <kbd>Style</kbd> is used to control the appearance for individual widgets. Themes, on the other hand, control the appearance of the entire GUI. More simply put, a theme is a collection of styles. Grouping styles into themes lets the user switch designs for the entire GUI all at once. Like styles, all themes are uniquely identified by their name.</p>
<p>The list of available themes can be obtained as follows:</p>
<pre> &gt;&gt; from tkinter.ttk import *<br/> &gt;&gt;&gt; style = Style()<br/> &gt;&gt;&gt; style.theme_names()<br/> ('winnative', 'clam', 'alt', 'default', 'classic', 'xpnative')<br/> To obtain the name of the currently active theme:<br/> &gt;&gt;&gt; style.theme_use()<br/> 'default'</pre>
<p>You can change to another theme from the <kbd>style.theme_names()</kbd> list; use the following:</p>
<pre>style.theme_use('your_new_theme_name') </pre>
<p>To explore various styling and theming-related options of ttk, refer to the dummy example (see <kbd>code 3.11.py</kbd>):</p>
<pre> from tkinter import Tk<br/> from tkinter import ttk<br/> root = Tk()<br/> style = ttk.Style()<br/> # defining the global style - applied when no other style is defined<br/> style.configure('.', font='Arial 14', foreground='brown', <br/>   background='yellow')<br/> # this label inherits the global style as style option not specified for it<br/> ttk.Label(root, text='I have no style of my own').pack()<br/> # defining a new style named danger and configuring its style only for the<br/> # button widget<br/> style.configure('danger.TButton', font='Times 12', foreground='red', padding=1)<br/> ttk.Button(root, text='Styled Dangerously',  style='danger.TButton').pack()<br/> # Different styling for different widget states<br/> style.map("new_state_new_style.TButton", foreground=[('pressed', 'red'), ('active', 'blue')])<br/> ttk.Button(text="Different Style for different states",style="new_state_new_style.TButton").pack()<br/> # Overriding current theme styles for the Entry widget<br/> current_theme = style.theme_use()<br/> style.theme_settings( current_theme,<br/>    {"TEntry":<br/>        {"configure":<br/>          {"padding": 10},<br/>          "map": {"foreground": [("focus", "red")] }<br/>        } <br/>    })<br/> print(style.theme_names())<br/> print(style.theme_use())<br/> # this is effected by change of themes even though no style specified<br/> ttk.Entry().pack()<br/> root.mainloop()</pre>
<p>The description of the code is as follows:</p>
<ul>
<li>The first three lines of code import Tkinter and ttk, and set up a new root window.</li>
<li>The next line, <kbd>style = ttk.Style()</kbd>, defines a new style.</li>
<li> The next line configures a program-wide style configuration using <kbd>style.configure</kbd>. The dot character (<kbd>.</kbd>), which is the first argument of <kbd>configure</kbd>, means that this style would apply to the <kbd>Toplevel</kbd> window and to all its child elements. This is the reason why all of our widgets get to have a yellow background.</li>
<li>The next line creates an extension (<kbd>danger</kbd>) to the default style (<kbd>TButton</kbd>). This is how you create custom styles, which are variations on a base default style. </li>
<li>The next line creates a <kbd>ttk.Label</kbd> widget. Since we have not specified any style for this widget, it inherits the global style specified for the Toplevel window.</li>
<li>The next line creates a <kbd>ttk.button</kbd> widget and specifies it to be styled using our custom style definition of <kbd>danger.TButton</kbd>. This is why the foreground color of this button turns red. Notice how it still inherits the background color, yellow, from the global Toplevel style that we defined earlier.</li>
<li>The next two lines of code demonstrate how ttk allows for styling different widget states. In this example, we styled different states for a <kbd>ttk.Button</kbd> widget to display in different colors. Go ahead and click on this second button to see how different styles apply to different states of a button. Here, we use <kbd>map(style, query_options, **kw)</kbd> to specify dynamic values of style for changes in the state of the widget.</li>
<li>The next line fetches the current applicable theme. It then overrides some of the options for the theme's Entry widget using <kbd>style.theme_settings('themename', ***options)</kbd>.</li>
<li>The next line defines an Entry widget but does not specify any style to it. It, therefore, inherits its properties from the theme we configured earlier. If you now type anything in this Entry widget, you will notice that it gets a padding of 10 px and the foreground text color is red inside the Entry widget.</li>
</ul>
<p>Now that we know how to make our widgets look more like native platform widgets, let's change the <strong>Play</strong> and <span class="packt_screen">Stop</span> buttons for our drum machine to <kbd>ttk.button</kbd>. Let's also change the <kbd>Loop</kbd> Checkbutton from <kbd>Tkinter</kbd> Checkbutton to <kbd>ttk</kbd> Checkbutton and add a few separators in the Play Bar section.</p>
<p>The following screenshots show the Play Bar before and after making the changes:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a965371a-280a-4c3f-818c-aefea9b16a94.png"/></div>
<p>We first import <kbd>ttk</kbd> into our namespace and append <kbd>ttk</kbd> to the <span class="packt_screen">Play</span> and <span class="packt_screen">Stop</span> buttons as follows (code <kbd>3.12.py</kbd>):</p>
<pre>from tkinter import ttk</pre>
<p>We then simply modify the buttons and Checkbutton in the <kbd>create_play_bar</kbd>, replacing <kbd>button</kbd> with <kbd>ttk.Button</kbd>, and <kbd>loopbutton</kbd> with <kbd>ttk.Checkbutton</kbd>:</p>
<pre> button = ttk.Button()<br/> loopbutton = ttk.Checkbutton(**options)</pre>
<p>Note that these changes make the Buttons and the Checkbutton look more like the native widgets of your working platform.</p>
<p>Finally, let's add <kbd>ttk.separators</kbd> to our Play Bar (see code <kbd>3.12.py</kbd>). The format for adding separators is as follows:</p>
<pre>ttk.Separator(playbar_frame, orient='vertical').grid(row=start_row, column = 5, sticky="ns", padx=5)</pre>
<p>Note that we cannot change the buttons in the right-button matrix from button to <kbd>ttk.Button</kbd>. This is because ttk buttons do not support specifying options like background color.</p>
<p>This concludes the last iteration of this project. In this iteration, we first saw how and why to use <strong>ttk-themed</strong> widgets to improve the look and feel of our programs. </p>
<p>We then used ttk Buttons and ttk Checkbuttons in our drum program to improve its look. We also saw the reasons why certain Tkinter Buttons in our program could not be replaced by ttk Buttons.</p>
<p>That brings us to the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Here's a quick summary of things we covered in this chapter.</p>
<p>We started by learning how to structure the Tkinter program as classes and objects.</p>
<p>We then decided the data structure for our program. This enabled us to set the ground for writing the rest of the program logic, maintaining a clean separation between data, logic, and its visual representation. We saw the vital benefits of deciding the data structure in advance.</p>
<p>We also worked with more Tkinter widgets such as Spinbox, Button, Entry, and Checkbutton. We also saw the grid geometry manager in action in the chapter.</p>
<p>We then saw how to bind widgets to higher-order functions using command callbacks. This is a very common technique used in GUI programming.</p>
<p>We then understood multithreaded programming in the context of Tkinter. We moved the audio playback onto a separate thread. This enabled us to keep the audio playing without hampering Tkinter's main loop in any way.</p>
<p>We then understood how to persist an object's state with the pickle module and then how to unpickle it later to retrieve the state of the object.</p>
<p>Finally, we saw how to use ttk-themed widgets to ensure that our GUI feels native on the platform where it is run.</p>
<p>Congratulations! You have now completed coding your drum machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QA section</h1>
                </header>
            
            <article>
                
<p><span>Before you proceed to the next chapter, make sure you can answer these questions to your satisfaction:</span></p>
<ul>
<li>How do you organize a Tkinter program in an object-oriented fashion? What are the advantages of using an object-oriented structure as apposed to writing pure procedural code? What are the disadvantages?</li>
<li>At what stage of programming should you consider drafting a data structure for your GUI program? What are the benefits of having a data structure or model in place?</li>
<li>What are higher-order functions?</li>
<li>Why is threading required? What are its advantages and disadvantages?</li>
<li>What is the difference between a process and a thread?</li>
<li>What is object persistence? </li>
<li>How do you pickle and unpickle objects in Python?</li>
<li>Besides pickling, what are the other common modes of persisting objects?</li>
<li>What are ttk widgets? Why are they used?</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Read about object-oriented programming terminologies like class, objects, constructor, inheritance, encapsulation, class methods, static methods, getters, setters, and their specific implementation in Python. A good place to start would be the official documentation of classes at <a href="https://docs.python.org/3/tutorial/classes.html">https://docs.python.org/3/tutorial/classes.html</a>.</p>
<p>Read the official documentation of Python object serialization at <a href="https://docs.python.org/3/library/pickle.html">https://docs.python.org/3/library/pickle.html</a>.<a href="https://docs.python.org/3/library/pickle.html"/></p>
<p>Read more about threading, context switching, and thread-based parallelism in general, along with its specific implementation in Python. The official documentation for threading is located at <a href="https://docs.python.org/3/library/threading.html">https://docs.python.org/3/library/threading.html</a>.<a href="https://docs.python.org/3/library/threading.html"/></p>
<p> </p>


            </article>

            
        </section>
    </body></html>