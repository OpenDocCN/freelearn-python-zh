<html><head></head><body>
  <div><h1 class="chapterNumber">1</h1>
    <h1 id="_idParaDest-13" class="chapterTitle">Understanding Microservices</h1>
    <p class="normal">We are always trying to improve how we create software. Computer programming is less than 100 years old, and we have evolved rapidly through technology, design, and philosophy to improve the tools and applications we produce.</p>
    <p class="normal">Microservices have revolutionized software products by improving the readability and scalability of services, and have allowed organizations to speed up their release cycles and be more responsive to the needs of their customers. Everybody wants to ship new products and new features to their customers as fast as possible. They want to be <em class="italic">agile</em> by iterating often, and they want to ship, ship, and ship again.</p>
    <p class="normal">With thousands of customers using your service simultaneously, it is considered good practice to push an experimental feature to production and remove it again if needed, instead of waiting for months to publish it and many other features at the same time.</p>
    <p class="normal">Companies such, as Netflix, are promoting their continuous delivery techniques where small changes are made very often in production and tested on a subset of the user base. They've developed tools such as <strong class="keyword">Spinnaker</strong> (<a href="http://www.spinnaker.io/">http://www.spinnaker.io/</a>) to automate as many steps as possible to update production and ship their features in the cloud as independent microservices.</p>
    <p class="normal">But if you read Hacker News or Reddit, it can be quite hard to untangle what's useful for you and what's just buzzword-compliant journalistic-style information. As <em class="italic">Edsger Dijkstra</em>, noted computer science researcher and discoverer of the famous shortest-path routing algorithm, put it:</p>
    <blockquote class="packt_quote">"Write a paper promising salvation, make it a structured something or a virtual something, or abstract, distributed or higher-order or applicative and you can almost be certain of having started a new cult." <p class="cite">—Edsger W. Dijkstra</p>
    </blockquote>
    <p class="normal">This book will take you through the creation of a traditional monolithic service and provide guidance on how to identify components that will be more effective as microservices. We will cover ways to integrate with other services, pass messages and schedule tasks, and securely deploy our service in Amazon Web Services. </p>
    <p class="normal">This chapter is going to help you understand what microservices are, and will then focus on the various ways in which you can implement them using Python. It is composed of the following sections:</p>
    <ul>
      <li class="bullet">The origins of service-oriented architecture</li>
      <li class="bullet">The monolithic approach to building an application</li>
      <li class="bullet">The microservices approach to building applications</li>
      <li class="bullet">Benefits of microservices</li>
      <li class="bullet">Potential pitfalls in microservices</li>
      <li class="bullet">Implementing microservices with Python</li>
    </ul>
    <p class="normal">Hopefully, once you've reached the end of the chapter, you will be able to dive into the rest of the book and build microservices with a good understanding of what they are and what they're not—and how you can use Python.</p>
    <h1 id="_idParaDest-14" class="title">The origins of service-oriented architecture</h1>
    <p class="normal">There is<a id="_idIndexMarker000"/> no official standard for microservices, so it is helpful to look at a bit of the history in this area of software design. When discussing microservices, <strong class="keyword">Service-Oriented Architecture</strong> (<strong class="keyword">SOA</strong>) is often used as a starting point. SOA is a way of thinking about software architecture that encourages reusable software components that provide well-defined interfaces. This allows those components to be reused and applied to new situations.</p>
    <p class="normal">Each unit in the preceding definition is a self-contained service that implements one facet of a business and provides its feature through some interface.</p>
    <p class="normal">While SOA clearly states that services should be standalone processes, it does not enforce what protocols should be used for those processes to interact with each other and is quite vague about how you deploy and organize your application.</p>
    <p class="normal">If you read <a id="_idIndexMarker001"/>the <strong class="keyword">SOA Manifesto</strong> (<a href="http://www.soa-manifesto.org">http://www.soa-manifesto.org</a>), first published on the web circa 2009, the authors don't even mention whether the services interact via a network, although contemporary understanding of the principles mostly involves networked services.</p>
    <p class="normal">SOA services could communicate via <strong class="keyword">Inter-Process Communication</strong> (<strong class="keyword">IPC</strong>) using sockets on the same <a id="_idIndexMarker002"/>machine, through shared memory, through <a id="_idIndexMarker003"/>indirect message queues, or even with <strong class="keyword">Remote Procedure Calls</strong> (<strong class="keyword">RPC</strong>). The options are extensive, and SOA is a useful set of principles for a wide variety of situations.</p>
    <p class="normal">However, it is common to say that microservices are one specialization of SOA, because they allow us to focus on the needs of the organization, its safety, and the scaling and separation of its software.</p>
    <p class="normal">If we want to give a complete definition of microservices, the best way to understand it is in the <a id="_idIndexMarker004"/>context of different software architectures. We will start with a monolith, and then discuss how microservices are different. </p>
    <h1 id="_idParaDest-15" class="title">The monolithic approach</h1>
    <p class="normal">With a<a id="_idIndexMarker005"/> monolith, everything about the service is in one place – the API, database, and all associated tools are managed as part of one code base. Let's take a very simple example of a traditional monolithic application: a hotel booking website.</p>
    <p class="normal">Besides the static HTML content, the website has a booking feature that will let its users book hotels in any city in the world. Users can search for hotels, then book them with their credit cards.</p>
    <p class="normal">When a user performs a search on the hotel website, the application goes through the following steps:</p>
    <ol>
      <li class="numbered">It runs a couple of SQL queries against its hotel database.</li>
      <li class="numbered">An HTTP request is made to a partner's service to add more hotels to the list.</li>
      <li class="numbered">Results are sent to the JavaScript embedded in the web page, to render the information for the viewer.</li>
    </ol>
    <p class="normal">From there, once the user has found the perfect hotel and selected the booking option, the application performs these steps:</p>
    <ol>
      <li class="numbered" value="1">The customer gets created in the database, if needed, and has to authenticate</li>
      <li class="numbered">Payment is carried out by interacting with the bank's web service</li>
      <li class="numbered">The app saves the payment details in the database for legal reasons</li>
      <li class="numbered">A receipt is generated using a PDF generator</li>
      <li class="numbered">A recap email is sent to the user using the email service</li>
      <li class="numbered">A reservation email is forwarded to the third-party hotel using the email service</li>
      <li class="numbered">A database entry is added to keep track of the reservation</li>
    </ol>
    <p class="normal">This process is a simplified model, of course, but describes enough for us to learn from.</p>
    <p class="normal">The application interacts with a database that contains the hotel's information, the reservation details, the billing, the user information, and so on. It also interacts with external services<a id="_idIndexMarker006"/> for sending emails, making payments, and getting more hotels from partners.</p>
    <p class="normal">In the early<a id="_idIndexMarker007"/> days of the web, a new service would commonly use a <strong class="keyword">LAMP</strong> (<strong class="keyword">Linux-Apache-MySQL-Perl/PHP/Python</strong>) architecture. With this approach, every incoming request generates a cascade of SQL queries on the database, and a few network calls to external services, then the server generates the HTML response using a template engine.</p>
    <p class="normal">The following diagram illustrates this centralized architecture:</p>
    <figure class="mediaobject"><img src="img/B17108_01_01_.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.1: A sample monolithic service architecture</p>
    <p class="normal">This application<a id="_idIndexMarker008"/> is a typical monolith, and it has a lot of benefits. The biggest one is that the whole application is in a single code base, and when the project coding starts, it makes everything simpler. Building a good test coverage is easy, and you can organize your code in a clean and structured way inside the code base. Storing all the data in a single database also simplifies the development of the application. You can tweak the data model, and how the code will query it.</p>
    <p class="normal">The deployment is also straightforward; we can build a package, install it, and run it somewhere. To scale up, we can run several instances of the booking app, and run several databases with some replication mechanism in place.</p>
    <p class="normal">If your application stays small, this model works well and is easy to maintain for a single team. But projects usually grow, and they get bigger than what was first intended. And having the whole application in a single code base brings some nasty issues along the way. For instance, if you need to make a sweeping change that is large in scope, such as changing your banking service or your database layer, the risks impact the whole application. These changes can have a huge impact on the project and need to be tested well before being deployed, and such testing often can't be exhaustive. Changes like this will happen in a project's life.</p>
    <p class="normal">Small changes can also generate collateral damage because different parts of the system have different uptime and stability requirements. Putting the billing and reservation processes at <a id="_idIndexMarker009"/>risk because the function that creates a PDF crashes the server is a bit of a problem.</p>
    <p class="normal">Uncontrolled growth is another issue. The application is bound to get new features, and with developers leaving and joining the project, the code might start to get messy, the tests a bit slower, and the deployment more fragile. This growth usually ends up with a spaghetti code base that's hard to maintain, with a hairy database that needs complicated migration plans every time some developer refactors the data model.</p>
    <p class="normal">The other form of growth that makes the project interesting is capacity management. If just one element in the application needs to scale very differently than the rest, then scaling the application becomes much trickier; for example, if the hotel room availability starts being used to generate website advertising, as well as serving people visiting the website.</p>
    <p class="normal">Large software projects usually take a couple of years to mature, and then they slowly start to turn into an incomprehensible mess that's hard to maintain. And it does not happen because developers are bad. It happens because as the complexity grows, fewer people fully understand the implications of every small change they make. </p>
    <p class="normal">So, they try to work in isolation with a fragment of the code base, and the mess only becomes visible when you view the entire structure of the project. We've all been there.</p>
    <p class="normal">It's not fun, and developers who work on such a project dream of building the application from scratch with the newest framework. And by doing so, they usually face the same issues again – the same story is repeated.</p>
    <p class="normal">To summarize, with a monolithic architecture there are benefits:</p>
    <ul>
      <li class="bullet">Starting a project as a monolith is easy, and probably the best approach.</li>
      <li class="bullet">A centralized database simplifies the design and organization of the data.</li>
      <li class="bullet">Deploying one application is simple.</li>
    </ul>
    <p class="normal">However:</p>
    <ul>
      <li class="bullet">Any change in the code can impact unrelated features. When something breaks, the whole application may break.</li>
      <li class="bullet">Solutions to scale your application are limited: you can deploy several instances, but if one particular feature inside the app takes all the resources, it impacts everything.</li>
      <li class="bullet">As the code base grows, it's hard to keep it clean and under control.</li>
    </ul>
    <p class="normal">There are, of course, some ways to avoid some of the issues described here.</p>
    <p class="normal">The obvious solution is to split the application into separate pieces, even if the resulting code is still <a id="_idIndexMarker010"/>going to run in a single process. Developers do this by building their apps with external libraries and frameworks. Those tools can be in-house or <a id="_idIndexMarker011"/>from the <strong class="keyword">Open-Source Software</strong> (<strong class="keyword">OSS</strong>) community.</p>
    <p class="normal">If you build a web<a id="_idIndexMarker012"/> app in<a id="_idIndexMarker013"/> Python using a framework like <strong class="keyword">Quart</strong> or <strong class="keyword">Flask</strong>, you are able to focus on the business logic, and it becomes very appealing to externalize some of your code into framework extensions and small Python packages. And splitting your code into small packages is often a good idea to control your application growth.</p>
    <blockquote class="packt_quote">"Small is beautiful." <p class="cite">—The UNIX philosophy</p>
    </blockquote>
    <p class="normal">For instance, the PDF generator described in the hotel booking app could be a separate Python package<a id="_idIndexMarker014"/> that uses <strong class="keyword">ReportLab</strong> and some templates to do the work. It's highly likely that this package could be reused in some other applications, and maybe even <a id="_idIndexMarker015"/>published to the <strong class="keyword">Python Package Index</strong> (<strong class="keyword">PyPI</strong>) for the community.</p>
    <p class="normal">But you're still building a single application and some problems persist, like the inability to scale parts differently, or any indirect issue introduced by a buggy dependency.</p>
    <p class="normal">You'll even face new challenges because you're now using dependencies. One problem that you'll face is <em class="italic">dependency hell</em>. If two parts of your application use the same library, you could get into the situation where one part of your application requires a new version for a feature that has been added, but another component can't use the newer one because something else has changed, and you are now in <em class="italic">dependency hell</em>. There's a good chance you will eventually have some ugly workaround for this problem in a large project, such as having a copy of the dependency that you now need to maintain separately to keep the fix up to date.</p>
    <p class="normal">Of course, all the problems described in this section do not appear on day one when the project starts, but rather pile up over time.</p>
    <p class="normal">Let's now look <a id="_idIndexMarker016"/>at how the same application would look if we were to use microservices to build it.</p>
    <h1 id="_idParaDest-16" class="title">The microservice approach</h1>
    <p class="normal">If we were to<a id="_idIndexMarker017"/> build the same application using microservices, we would organize the code into several separate components that run in separate processes. We have already discussed the PDF report generator, and we can examine the rest of the application and see where we could split it into different microservices, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="img/B17108_01_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.2: A sample microservice architecture</p>
    <p class="normal">Don't be afraid of the number of components displayed in this diagram. The internal interactions of the monolithic application are just being made visible by separate pieces. We've shifted <a id="_idIndexMarker018"/>some of the complexity and ended up with these seven standalone components:</p>
    <ol>
      <li class="numbered" value="1"><strong class="keyword">Booking UI</strong>: A frontend service that generates the web user interface, and interacts with all the other microservices.</li>
      <li class="numbered"><strong class="keyword">PDF reports</strong>: A very simple service that will create PDFs for receipts or any other document given a template and some data. Also known as the PDF reporting service.</li>
      <li class="numbered"><strong class="keyword">Search</strong>: A service<a id="_idIndexMarker019"/> that can be queried to get a list of hotels when given a location. This service has its own database.</li>
      <li class="numbered"><strong class="keyword">Payments</strong>: A service that interacts with the third-party bank service, and manages a billing database. It also sends emails on successful payment.</li>
      <li class="numbered"><strong class="keyword">Reservations</strong>: Manages reservations and changes to bookings.</li>
      <li class="numbered"><strong class="keyword">Users</strong>: Stores the user information, and interacts with users via emails.</li>
      <li class="numbered"><strong class="keyword">Authentication</strong>: An OAuth 2-based service that returns authentication tokens, which each microservice can use to authenticate when calling others.</li>
    </ol>
    <p class="normal">Those microservices, along with a few external services, like the email service, would provide a feature set similar to the monolithic application. In this design, each component communicates using the HTTP protocol, and features are made available through RESTful web services.</p>
    <p class="normal">There's no centralized database, as each microservice deals internally with its own data structures, and the data that gets in and out uses a language-agnostic format like JSON. It could use XML or YAML as long as it can be produced and consumed by any language, and travel through HTTP requests and responses.</p>
    <p class="normal">The Booking <a id="_idIndexMarker020"/>UI service is a bit particular in that regard, since it generates the <strong class="keyword">User Interface</strong> (<strong class="keyword">UI</strong>). Depending on the frontend framework used to build the UI, the Booking UI output could be a mix of HTML and JSON, or even plain JSON if the interface uses a static JavaScript-based client-side tool to generate the interface directly in the browser.</p>
    <p class="normal">But besides this particular UI case, a web application designed with microservices is a composition of several microservices, which may interact with each other through HTTP to provide the whole system.</p>
    <p class="normal">In that context, microservices are logical units that focus on a very particular task. Here's a full definition attempt:</p>
    <div><p class="Information-Box--PACKT-">A microservice is a lightweight application that provides a narrow list of features with a well-defined contract. It's a component with a single responsibility that can be developed and deployed independently.</p>
    </div>
    <p class="normal">This definition does not mention HTTP or JSON, because you could consider, for example, a small UDP-based service that exchanges binary data as a microservice, or a service that <a id="_idIndexMarker021"/>communicates using gRPC. (gRPC is a recursive acronym that stands for gRPC Remote Procedure Call, an open-source remote procedure call system.)</p>
    <p class="normal">But in our<a id="_idIndexMarker022"/> case, and throughout the book, all our microservices are just simple web applications that use the HTTP protocol and consume and produce JSON when it's not a UI.</p>
    <h1 id="_idParaDest-17" class="title">Microservice benefits</h1>
    <p class="normal">While the <a id="_idIndexMarker023"/>microservices architecture looks more complicated than its monolithic counterpart, it offers multiple advantages. It offers the following:</p>
    <ul>
      <li class="bullet">Separation of concerns</li>
      <li class="bullet">Smaller projects to deal with</li>
      <li class="bullet">More scaling and deployment options</li>
    </ul>
    <p class="normal">We will discuss them in more detail in the following sections.</p>
    <h2 id="_idParaDest-18" class="title">Separation of concerns</h2>
    <p class="normal">First of all, each <a id="_idIndexMarker024"/>microservice can be developed independently by a separate team. For instance, building a reservation service can be a full project on its own. The team in charge can code it in the programming language and database of their choice, as long as it has a well-documented HTTP API.</p>
    <p class="normal">That also means the evolution of the app is more under control than with monoliths. For example, if the payment system changes its underlying interactions with the bank, the impact is localized inside that service, and the rest of the application stays stable and is probably unaffected.</p>
    <p class="normal">This is known as loose coupling, and <a id="_idIndexMarker025"/>improves the overall project velocity as we apply, at the service level, a philosophy similar to the <em class="italic">single responsibility</em> principle. By contrast, a tightly coupled payment service would need inside knowledge of how the system represents its data or performs its task.</p>
    <p class="normal">Robert Martin, the author of many widely respected books about software engineering, defined the single responsibility principle to explain that a class should have only one reason to change; in other words, each class should provide a single, well-defined feature. Applied to microservices, it means that we want to make sure that each microservice focuses on a single role.</p>
    <h2 id="_idParaDest-19" class="title">Smaller projects</h2>
    <p class="normal">The second<a id="_idIndexMarker026"/> benefit is breaking the complexity of the project. When you add a feature to an application such as PDF reporting, even if you do it cleanly, you make the code base bigger, more complicated, and sometimes slower. Building that feature in a separate application avoids this problem and makes it easier to write it with whatever tools you want. You can refactor it often, shorten your release cycles, and stay on top of things. The growth of the application remains under your control.</p>
    <p class="normal">Dealing with a smaller project also reduces risks when improving the application: if a team wants to try out the latest programming language or framework, they can iterate quickly on a prototype that implements the same microservice API, try it out, and decide whether or not to stick with it.</p>
    <p class="normal">One real-life example is the Firefox Sync storage microservice. There were experiments to switch from storing data in MySQL, to an implementation that stores users' data in standalone SQLite databases. The risks of an experimental prototype were mitigated by isolating the storage feature in a microservice with a well-defined HTTP API. This minimized the unexpected interactions with other components and allowed a small subset of the user base to try out the new version of the service.</p>
    <p class="normal">Reducing the size of each component also makes it easier to think about for developers, especially new ones joining the team or ones who are stressed about handling an outage with the service. Instead of having to work through an entire system, a developer can focus on a smaller area and not worry about the rest of the application's features.</p>
    <h2 id="_idParaDest-20" class="title">Scaling and deployment</h2>
    <p class="normal">Finally, having<a id="_idIndexMarker027"/> your<a id="_idIndexMarker028"/> application split into components makes it easier to scale depending on your constraints. Let's say your business grows and there are many more customers who book hotels each day, and the PDF generation starts to use more resources and slows down. To tackle this problem, you can deploy that specific microservice in some servers that have bigger CPUs or more memory.</p>
    <p class="normal">Another typical example is a high memory usage microservice, such as ones that interact with in-memory<a id="_idIndexMarker029"/> databases <a id="_idIndexMarker030"/>such as <strong class="keyword">Redis</strong> or <strong class="keyword">Memcached</strong>. You could tweak your deployments, consequently, by using servers with less CPU and a lot more RAM.</p>
    <p class="normal">We can, thus, summarize the benefits of microservices as follows:</p>
    <ul>
      <li class="bullet">A team can develop each microservice independently, and use whatever technology stack makes sense. They can define a custom release cycle. All they need to define is a language-agnostic HTTP API.</li>
      <li class="bullet">Developers split the application complexity into logical components. Each microservice focuses on doing one thing well.</li>
      <li class="bullet">Since microservices are standalone applications, there's finer control over deployments, which makes scaling easier.</li>
    </ul>
    <p class="normal">The microservices architecture is good at solving a lot of the problems that may arise once <a id="_idIndexMarker031"/>your application starts to grow. However, we need to <a id="_idIndexMarker032"/>be aware of some of the new issues that are brought along.</p>
    <h1 id="_idParaDest-21" class="title">Pitfalls of microservices</h1>
    <p class="normal">As discussed<a id="_idIndexMarker033"/> earlier, building an application with microservices has many benefits, but it's not a silver bullet by any means.</p>
    <p class="normal">You need to be aware of these main problems you might have to deal with when coding microservices:</p>
    <ul>
      <li class="bullet">Illogical splitting</li>
      <li class="bullet">More network interactions</li>
      <li class="bullet">Data storing and sharing</li>
      <li class="bullet">Compatibility issues</li>
      <li class="bullet">Testing</li>
    </ul>
    <p class="normal">These issues will be covered in detail in the following sections.</p>
    <h2 id="_idParaDest-22" class="title">Illogical splitting</h2>
    <p class="normal">The first<a id="_idIndexMarker034"/> issue of a microservice architecture is how it gets designed. There's no way a team can come up with the perfect microservice architecture on their first shot. Some microservices like the PDF generator are an obvious use case. But as soon as you deal with the business logic, there's a good chance that your code will move around before you get a good grasp of how to split things into the right set of microservices.</p>
    <p class="normal">The design needs to mature with some try-and-fail cycles. And adding and removing microservices can be more painful than refactoring a monolithic application. You can mitigate this problem by avoiding splitting your app into microservices if the split is not evident.</p>
    <p class="normal">If there's any doubt that the split makes sense, keeping the code in the same app is the safe bet. It's always easier to split apart some of the code into a new microservice later than to merge two microservices back in the same code base because the decision turned out to be wrong.</p>
    <p class="normal">For instance, if you always have to deploy two microservices together, or if one change in a microservice <a id="_idIndexMarker035"/>impacts the data model of the other one, the odds are that you did not split the application correctly and that those two services should be reunited.</p>
    <h2 id="_idParaDest-23" class="title">More network interactions</h2>
    <p class="normal">The second<a id="_idIndexMarker036"/> problem is the number of network interactions added to build the same application. In the monolithic version, even if the code gets messy, everything happens in the same process, and you can send back the result without having to call too many backend services to build the actual response.</p>
    <p class="normal">That requires extra attention to how each backend service is called and raises a lot of questions, like the following:</p>
    <ul>
      <li class="bullet">What happens when the Booking UI cannot reach the PDF reporting service because of a network split or a laggy service?</li>
      <li class="bullet">Does the Booking UI call the other services synchronously or asynchronously?</li>
      <li class="bullet">How will that impact the response time?</li>
    </ul>
    <p class="normal">We will need to have a solid strategy to be able to answer all those questions, and we will address those in <em class="chapterRef">Chapter 6</em>, <em class="italic">Interacting with Other Services</em>.</p>
    <h2 id="_idParaDest-24" class="title">Data storing and sharing</h2>
    <p class="normal">Another<a id="_idIndexMarker037"/> problem is data storing and sharing. An effective <a id="_idIndexMarker038"/>microservice needs to be independent of other microservices, and ideally, should not share a database. What does this mean for our hotel booking app?</p>
    <p class="normal">Again, that raises a lot of questions, such as the following:</p>
    <ul>
      <li class="bullet">Do we use the same users' IDs across all databases, or do we have independent IDs in each service and keep it as a hidden implementation detail?</li>
      <li class="bullet">Once a user is added to the system, do we replicate some of her information in other services' databases via strategies like data pumping, or is that overkill?</li>
      <li class="bullet">How do we deal with data removal?</li>
    </ul>
    <p class="normal">These are hard questions to answer, and there are many different ways to solve those problems, as <a id="_idIndexMarker039"/>we'll <a id="_idIndexMarker040"/>learn throughout the book.</p>
    <div><p class="Information-Box--PACKT-">Avoiding data duplication as much as possible while keeping microservices in isolation is one of the biggest challenges in designing microservices-based applications.</p>
    </div>
    <h2 id="_idParaDest-25" class="title">Compatibility issues</h2>
    <p class="normal">Another <a id="_idIndexMarker041"/>problem happens when a feature change impacts several microservices. If a change affects, in a backward-incompatible way, the data that travels between services, you're in for some trouble.</p>
    <p class="normal">Can you deploy your new service, and will it work with older versions of other services? Or do you need to change and deploy several services at once? Does it mean you've just stumbled on some services that should probably be merged back together?</p>
    <p class="normal">Good versioning and API design hygiene helps to mitigate those issues, as we will discover in the second part of the book, when we'll build our application.</p>
    <h2 id="_idParaDest-26" class="title">Testing</h2>
    <p class="normal">Lastly, when <a id="_idIndexMarker042"/>you want to do some end-to-end tests and deploy your whole app, you have to deal with many components. You need to have a robust and agile deployment process to be efficient. You need to be able to play with your whole application when you develop it. You can't fully test things out with just one piece of the puzzle, although having a clean and well-defined interface does help.</p>
    <p class="normal">Many of the recent developments in cloud orchestration tools, such as Kubernetes, Terraform, and CloudFormation make life much easier when deploying an application that consists of several components. They can be used to create test and staging environments as well as production, customer-facing deployments. The popularity of these tools has helped in the success and adoption of microservices.</p>
    <div><p class="Information-Box--PACKT-">Microservices-style architecture boosts deployment tools' innovation, and deployment tools lower the bar for the approval of microservices-style architecture.</p>
    </div>
    <p class="normal">The pitfalls of using microservices can be summarized as follows:</p>
    <ul>
      <li class="bullet">Premature splitting of an application into microservices can lead to architectural problems.</li>
      <li class="bullet">Network interactions between microservices add potential points of failure and additional overhead.</li>
      <li class="bullet">Testing and deploying microservices can be complex.</li>
      <li class="bullet">And the biggest challenge—data sharing between microservices is hard.</li>
    </ul>
    <p class="normal">You should not worry too much about all the pitfalls described in this section for now. They may seem overwhelming, and the traditional monolithic application may look like a safer bet, but in the long term, splitting your project into microservices will make many of your tasks, as a <a id="_idIndexMarker043"/>developer or as an <strong class="keyword">operations person</strong> (<strong class="keyword">ops</strong>), easier. It can also make running a service cheaper. To add more capacity to a monolithic application, you need a larger server, or the ability to add more large servers. If the architecture is distributed and based around microservices, then extra resources can be added in smaller<a id="_idIndexMarker044"/> increments, holding far closer to the amount actually needed. And as we will discover in <em class="chapterRef">Chapter 9:</em> <em class="italic">Deployment, Running, and Scaling</em>, it can be easier to set a cloud service provider up to automatically scale based on demand.</p>
    <h1 id="_idParaDest-27" class="title">Implementing microservices with Python</h1>
    <p class="normal">Python <a id="_idIndexMarker045"/>is <a id="_idIndexMarker046"/>an amazingly versatile language. As you probably already know, Python is used to build many different kinds of applications – from simple system scripts that perform tasks on a server to large object-oriented applications that run services for millions of users. Python is also used in machine learning and data analysis tools.</p>
    <p class="normal">Python sits <a id="_idIndexMarker047"/>comfortably in the top five languages in the TIOBE index (<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>), and has reached as high as number two. It's probably even bigger in the web development world since languages like C are rarely used as main languages to build web applications.</p>
    <div><p class="Information-Box--PACKT-">This book makes the assumption that you are already familiar with the Python programming language. If you are not an experienced Python developer, you can read the book <em class="italic">Expert Python Programming</em>, <em class="italic">Third Edition</em>, where you will learn advanced programming skills in Python.</p>
    </div>
    <p class="normal">However, some developers criticize Python for being slow and unfit for building efficient web services. Python is slow, and this is undeniable, though it is fast enough for most situations. But it still is the language of choice for building microservices, and many major companies happily use it.</p>
    <p class="normal">This section will give you some background on the different ways you can write microservices <a id="_idIndexMarker048"/>using Python, offer some insights on <a id="_idIndexMarker049"/>asynchronous versus synchronous programming, and conclude with some details on Python performance.</p>
    <h2 id="_idParaDest-28" class="title">How web services work</h2>
    <p class="normal">If we <a id="_idIndexMarker050"/>imagine a simple program that<a id="_idIndexMarker051"/> answers queries on the web, the description is straightforward. A new connection is made, and the protocol is negotiated. A request is made, and some processing is done: perhaps a database is queried. Then a response is structured and sent, and the connection is closed. This is often how we want to think about our application's logic, because it keeps things simple for the developer as well as anyone else responsible for the program once it's running. </p>
    <p class="normal">The web is a big, complicated place, though. Various parts of the internet will try to do malicious things to a vulnerable web service they find. Others just behave badly because they have not been set up well. Even when things are working well, there are different HTTP protocol versions, encryption, load balancing, access control, and a whole set of other things to think about. </p>
    <p class="normal">Rather than reinvent all of this technology, there are <strong class="keyword">interfaces</strong> and <strong class="keyword">frameworks</strong> that let us use the tools that other people have built, and spend more of our time working on our own applications. They let<a id="_idIndexMarker052"/> us use web servers such as <strong class="keyword">Apache</strong> and <strong class="keyword">nginx</strong> and let<a id="_idIndexMarker053"/> them handle the difficult parts of being on the web, such as certificate management, load balancing, and handling multiple website identities. Our application then has a smaller, more manageable configuration to control its behavior.</p>
    <h2 id="_idParaDest-29" class="title">The WSGI standard</h2>
    <p class="normal">What strikes <a id="_idIndexMarker054"/>most web developers who start with Python is how easy it is to get a web application up and running.</p>
    <p class="normal">Inspired by <a id="_idIndexMarker055"/>the older <strong class="keyword">Common Gateway Interface</strong> (<strong class="keyword">CGI</strong>), the<a id="_idIndexMarker056"/> Python web community has created a standard called the <strong class="keyword">Web Server Gateway Interface</strong> (<strong class="keyword">WSGI</strong>). It simplifies how you can write a Python application in order to serve HTTP requests. When your code uses this standard, your project can be executed by standard web servers like Apache or nginx, using WSGI extensions like <code class="Code-In-Text--PACKT-">uwsgi</code> or <code class="Code-In-Text--PACKT-">mod_wsgi</code>.</p>
    <p class="normal">Your application just has to deal with incoming requests and send back JSON responses, and Python includes all that goodness in its standard library.</p>
    <p class="normal">You can create a fully functional microservice that returns the server's local time with a vanilla Python module of fewer than 10 lines:</p>
    <pre class="programlisting code"><code class="hljs-code">import json
import time 
def application(environ, start_response): 
    headers = [('Content-type', 'application/json')] 
    start_response('200 OK', headers) 
    return [bytes(json.dumps({'time': time.time()}), 'utf8')] 
</code></pre>
    <p class="normal">Since its introduction, the WSGI protocol has become an essential standard, and the Python web <a id="_idIndexMarker057"/>community has widely adopted it. Developers have written middleware, which are functions you can hook before or after the WSGI application function itself, to do something within the environment.</p>
    <p class="normal">Some web <a id="_idIndexMarker058"/>frameworks, such as <strong class="keyword">Bottle</strong> (<a href="http://bottlepy.org">http://bottlepy.org</a>), were created specifically around that standard, and soon enough, every framework out there could be used through WSGI in one way or another.</p>
    <p class="normal">The biggest problem with WSGI, though, is its synchronous nature. More recently, the <strong class="keyword">Asynchronous Server Gateway Interface</strong> (<strong class="keyword">ASGI</strong>) has emerged as a successor to WSGI, allowing frameworks to operate asynchronously with the same seamless behavior as before. What are synchronous and asynchronous applications? We will cover that now.</p>
    <h2 id="_idParaDest-30" class="title">Workers, threads, and synchronicity</h2>
    <p class="normal">Thinking<a id="_idIndexMarker059"/> back <a id="_idIndexMarker060"/>to <a id="_idIndexMarker061"/>our simple application that handles requests, our model of the program is synchronous. This means that it accepts a piece of work, does that work, and returns the result, but while it's doing all of that, the program can't do anything else. Any other requests that come in when it's already working on something will have to wait. </p>
    <p class="normal">There are several approaches to solving this problem, from using worker pools to early context switching environments, and more recently, full asynchronous Python.</p>
    <h3 id="_idParaDest-31" class="title">A worker pool approach</h3>
    <p class="normal">Accepting a <a id="_idIndexMarker062"/>new request is often very fast, and the bulk of the time is taken up by doing the work that has been requested. Reading a request that tells you "Give me a list of all our customers in Paris" takes much less time than putting the list together and sending it back. </p>
    <p class="normal">When an application has lots of requests arriving, an effective strategy is to ensure that all the heavy lifting is done using other processes or threads. Starting a new thread can be slow, and starting a new process is even slower, and so a common technique is to start these workers early and keep them around, giving them new work to do as it arrives. </p>
    <p class="normal">This is an old technique and a very effective one, but it does have limitations. As far as each worker is concerned, it receives work, and can't do anything else until it has finished. This means that if you have eight worker processes, you can only handle eight simultaneous requests. Your application could create more workers if it is running low, but there is always a bottleneck.</p>
    <p class="normal">There is also a practical limit to the number of processes and threads that an application can create, and swapping between them takes a lot of time that a responsive application can't always afford.</p>
    <h3 id="_idParaDest-32" class="title">Being asynchronous</h3>
    <p class="normal">One important <a id="_idIndexMarker063"/>thing to realize is that computers interacting with each other is a slow process. Not from a human perspective, where a new message from a family member can appear on our phones in the blink of an eye, but from the perspective of the computer itself.</p>
    <p class="normal">There are several charts available that suggest "<em class="italic">Latency Numbers Every Programmer Should Know</em>," originally by <em class="italic">Jeff Dean</em> and <em class="italic">Peter Norvig</em>. A version of it can be found at <a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html">https://colin-scott.github.io/personal_website/research/interactive_latency.html</a>. </p>
    <p class="normal">There are a lot of numbers in these tables, but the important ones for us are the ones about network traffic. We can learn that reading about 1 MB from a computer's memory takes about 3,000 ns, but sending a packet over the network to a computer in the same building, and getting a response, can take about 500,000 ns. Talking to a computer on another continent can take hundreds of milliseconds.</p>
    <p class="normal">To put this in human terms: it might take you a few seconds to remember that you need to ask someone a question. Sending them the question and hearing back that they've read it, whether or not you get the answer you need, might take two days. </p>
    <p class="normal">You don't really want to be sitting there doing nothing while waiting for an answer, but that's what a process usually does if it's synchronous. An asynchronous program is aware that some tasks it has been told to perform might take a long time, and so it can get on with<a id="_idIndexMarker064"/> some other work while it is waiting, without necessarily having to use other processes or threads. </p>
    <h3 id="_idParaDest-33" class="title">Twisted, Tornado, Greenlets, and Gevent</h3>
    <p class="normal">For a<a id="_idIndexMarker065"/> long <a id="_idIndexMarker066"/>time, non-WSGI<a id="_idIndexMarker067"/> frameworks<a id="_idIndexMarker068"/> like <strong class="keyword">Twisted</strong> and <strong class="keyword">Tornado</strong> were the popular answers for concurrency when using Python, allowing developers to specify <strong class="keyword">callbacks</strong> for many simultaneous requests. In a sequential program, you might call a function and wait for it to return a value to you. A callback is a technique where the calling part of the program doesn't wait but instead tells the function what it should do with the result it generates. Often this is another function that it should call.</p>
    <p class="normal">Another popular approach involved Greenlets and Gevent. The <strong class="keyword">Greenlet</strong> project (<a href="https://github.com/python-greenlet/greenlet">https://github.com/python-greenlet/greenlet</a>) is a package based on the <strong class="keyword">Stackless</strong> project, a <a id="_idIndexMarker069"/>particular CPython implementation, and provides <em class="italic">greenlets</em>.</p>
    <p class="normal">Greenlets are <em class="italic">pseudo-threads</em> that are very cheap to instantiate, unlike real threads, and that can be used to call Python functions. Within those functions, you can <em class="italic">switch</em>, and give back the control to another function. The switching is done with an event loop and allows you to write an asynchronous application using a thread-like interface paradigm.</p>
    <p class="normal">However, switching from one greenlet to another has to be done explicitly, and the resulting code can quickly become messy and hard to understand. That's where Gevent can become very <a id="_idIndexMarker070"/>useful. The <strong class="keyword">Gevent</strong> project (<a href="http://www.gevent.org/">http://www.gevent.org/</a>) is built on top of Greenlet and offers an implicit and automatic way of switching between greenlets, among many other things.</p>
    <p class="normal">With the experience from all of these options, Python now has <code class="Code-In-Text--PACKT-">asyncio</code> as a core feature of the language since 3.5, and this is what we will be using in our code.</p>
    <h3 id="_idParaDest-34" class="title">Asynchronous Python </h3>
    <p class="normal">When <em class="italic">Guido</em><em class="italic"><a id="_idIndexMarker071"/></em><em class="italic"> van Rossum</em> started to work on adding async features in Python 3, part of the community pushed for a Gevent-like solution, because it made a lot of sense to write applications in a synchronous, sequential fashion rather than having to add explicit callbacks like in Tornado or Twisted.</p>
    <p class="normal">But Guido picked the explicit technique and experimented in a project called <strong class="keyword">Tulip</strong> inspired by Twisted. Eventually, the <code class="Code-In-Text--PACKT-">asyncio</code> module was born out of that side project and added into Python.</p>
    <p class="normal">In hindsight, implementing an explicit event loop mechanism in Python instead of going the Gevent way makes a lot of sense. The way the Python core developers coded asyncio, and how they extended the language with the <code class="Code-In-Text--PACKT-">async</code> and <code class="Code-In-Text--PACKT-">await</code> keywords to implement coroutines, made asynchronous applications built with vanilla Python 3.5+ code look very elegant and close to synchronous programming.</p>
    <p class="normal">Python 3 has introduced a full set of features and helpers in the asyncio package to build asynchronous<a id="_idIndexMarker072"/> applications; refer to <a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>.</p>
    <p class="normal"><strong class="keyword">aiohttp</strong> (<a href="http://aiohttp.readthedocs.io">http://aiohttp.readthedocs.io</a>) is one of the most mature asyncio packages, and <a id="_idIndexMarker073"/>building the earlier "time" microservice with it would simply need these few lines:</p>
    <pre class="programlisting code"><code class="hljs-code">from aiohttp import web  
import time 
async def handle(request): 
    return web.json_response({'time': time.time()}) 
if __name__ == '__main__': 
    app = web.Application() 
    app.router.add_get('/', handle) 
    web.run_app(app) 
</code></pre>
    <p class="normal">In this small example, we're very close to how we would implement a synchronous app. The only hint we're using asynchronous code is the <code class="Code-In-Text--PACKT-">async</code> keyword, which marks the <code class="Code-In-Text--PACKT-">handle</code> function as being a coroutine.</p>
    <p class="normal">And this concept is what's going to be used at every level of an async Python app going forward. Here's another example using <code class="Code-In-Text--PACKT-">aiopg</code>, a PostgreSQL library for asyncio from the project documentation:</p>
    <pre class="programlisting code"><code class="hljs-code">import asyncio 
import aiopg 
# Start an example postgres instance with:
# docker run -p5432:5432 --name some-postgres \
# -e POSTGRES_PASSWORD=mysecretpassword -d postgres
dsn = "dbname=postgres user=postgres password=mysecretpassword host=127.0.0.1"
async def go():
    pool = await aiopg.create_pool(dsn)
    async with pool.acquire() as conn:
        async with conn.cursor() as cur:
            await cur.execute("SELECT 1")
            ret = []
            async for row in cur:
                ret.append(row)
            assert ret == [(1,)]
    await pool.clear()
loop = asyncio.get_event_loop()
loop.run_until_complete(go())
</code></pre>
    <p class="normal">With a few <code class="Code-In-Text--PACKT-">async</code> and <code class="Code-In-Text--PACKT-">await</code> prefixes, the function that performs an SQL query and sends back<a id="_idIndexMarker074"/> the result looks a lot like a synchronous function. We will explain more about this code in later chapters.</p>
    <p class="normal">If you need to use a library that is not asynchronous in your code, to use it from your asynchronous code means that you will need to go through some extra and challenging work if you want the different libraries to work well together. </p>
    <p class="normal">There are many great synchronous frameworks to build microservices with Python, like <strong class="keyword">Bottle</strong>, <strong class="keyword">Pyramid</strong> with <strong class="keyword">Cornice</strong>, or <strong class="keyword">Flask</strong>. We will be using one that is very similar to Flask, but is also asynchronous: <strong class="keyword">Quart</strong>.</p>
    <div><p class="Information-Box--PACKT-">Keep in mind that whatever Python web framework you use, you should be able to transpose all the examples in this book. This is because most of the coding involved when building microservices is very close to plain Python, and the framework is mostly to route the requests and offer a few helpers.</p>
    </div>
    <h2 id="_idParaDest-35" class="title">Language performance</h2>
    <p class="normal">In the<a id="_idIndexMarker075"/> previous sections, we went through the two different ways to write microservices: asynchronous versus synchronous, and whatever technique you use, the speed of Python directly impacts the performance of your microservice.</p>
    <p class="normal">Of course, everyone knows Python is slower than Java or Go, but execution speed is not always the top priority. A microservice is often a thin layer of code that sits most of its life waiting for some network responses from other services. Its core speed is usually less important than how fast your SQL queries will take to return from your Postgres server, because the latter will represent most of the time spent building the response.</p>
    <p class="normal">It's also important to remember that how long you spend developing the software can be just as important. If your services are rapidly changing, or a new developer joins and has to understand the code, it is important to have code that is easy to understand, develop, and deploy.</p>
    <p class="normal">But wanting an application that's as fast as possible is legitimate.</p>
    <p class="normal">One controversial <a id="_idIndexMarker076"/>topic in the Python community around speeding up the language is how the <strong class="keyword">Global Interpreter Lock</strong> (<strong class="keyword">GIL</strong>) can affect performance, because multi-threaded applications cannot use several processes.</p>
    <p class="normal">The GIL has <a id="_idIndexMarker077"/>good reasons to exist. It protects non-thread-safe parts of the CPython interpreter and exists in other languages like Ruby. And all attempts to remove it so far have failed to produce a faster CPython implementation.</p>
    <p class="normal">For microservices, besides preventing the usage of multiple cores in the same process, the GIL will slightly degrade performance under high load because of the system calls overhead introduced by the mutex.</p>
    <p class="normal">However, all the scrutiny around the GIL has been beneficial: work has been done in the past to reduce GIL contention in the interpreter, and in some areas, Python's performance has improved a lot. Changes in Python 3.8 to introduce subinterpreters and multiple locks have also helped with some areas.</p>
    <p class="normal">Bear in mind that even if the core team removes all the GIL performance issues, Python is an interpreted and garbage collected language and suffers performance penalties for those properties.</p>
    <p class="normal">Python provides the <code class="Code-In-Text--PACKT-">dis</code> module if you are interested in seeing how the interpreter decomposes a function. In the following example, the interpreter will decompose a simple function that yields incremented values from a sequence in no less than 22 steps:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; def myfunc(data): 
...     for value in data: 
...         yield value + 1 
... 
&gt;&gt;&gt; import dis 
&gt;&gt;&gt; dis.dis(myfunc) 
  2           0 LOAD_FAST             0 (data)
              2 GET_ITER
        &gt;&gt;    4 FOR_ITER             14 (to 20)
              6 STORE_FAST            1 (value)
  3           8 LOAD_FAST             1 (value)
             10 LOAD_CONST            1 (1)
             12 BINARY_ADD
             14 YIELD_VALUE
             16 POP_TOP
             18 JUMP_ABSOLUTE         4
        &gt;&gt;   20 LOAD_CONST            0 (None)
             22 RETURN_VALUE
</code></pre>
    <p class="normal">A similar <a id="_idIndexMarker078"/>function written in a statically compiled language will dramatically reduce the number of operations required to produce the same result. There are ways to speed up Python execution, though.</p>
    <p class="normal">One is to write a part of your code in compiled code by building extensions in C, Rust, or another compiled language, or using a static extension of the language like <strong class="keyword">Cython</strong> (<a href="http://cython.org/">http://cython.org/</a>), but <a id="_idIndexMarker079"/>that makes your code more complicated.</p>
    <p class="normal">Another solution is by simply running your application using the <strong class="keyword">PyPy</strong> interpreter (<a href="http://pypy.org/">http://pypy.org/</a>). This<a id="_idIndexMarker080"/> can give noticeable performance improvements just by swapping out the Python interpreter.</p>
    <p class="normal">PyPy <a id="_idIndexMarker081"/>implements a <strong class="keyword">Just-In-Time</strong> (<strong class="keyword">JIT</strong>) compiler. This compiler directly replaces, at runtime, pieces of Python with machine code that can be directly used by the CPU. The whole trick for the JIT compiler is to detect in real time, ahead of the execution, when and how to do it.</p>
    <p class="normal">Even if PyPy is always a few Python versions behind CPython, it has reached a point where you can use it in production, and its performance can be quite amazing. In one of our projects at Mozilla that needs fast execution, the PyPy version was almost as fast as the Go version, and we decided to use Python there instead.</p>
    <div><p class="Information-Box--PACKT-">The Pypy Speed Center website is a great place to look at how PyPy compares to CPython ( <a href="http://speed.pypy.org/">http://speed.pypy.org/</a>).</p>
    </div>
    <p class="normal">However, if your program uses C extensions or has any other compiled dependencies, you will need to recompile them for PyPy, and that extra work must be balanced against the speed improvements, especially if you are depending on another project or other developers to maintain the extensions you are using.</p>
    <p class="normal">But if you build your microservice with a standard set of libraries, chances are that it will work out of the box with the PyPy interpreter, so that's worth a try. In any case, for most projects, the benefits of Python and its ecosystem largely surpass the performance issues described in this section, because the overhead in a microservice is rarely a problem. And if performance is a problem, the microservice approach <a id="_idIndexMarker082"/>allows you to rewrite and scale performance-critical components without affecting the rest of the system.</p>
    <h1 id="_idParaDest-36" class="title">Summary</h1>
    <p class="normal">In this chapter, we've compared the monolithic and microservice approaches to building web applications, and it became apparent that there's not a binary choice where you have to pick one model on day one and stick with it.</p>
    <p class="normal">You should see microservices as an improvement of an application that started its life as a monolith. As the project matures, parts of the service logic should migrate into microservices. It is a useful approach, as we've learned in this chapter, but it should be done carefully to avoid falling into some common traps.</p>
    <p class="normal">Another important lesson is that Python is considered to be one of the best languages to write web applications and, therefore, microservices. For the same reasons, it's a language of choice in other areas, and also because it provides many mature frameworks and packages to do the work.</p>
    <p class="normal">Python can be a slow language, and that can be a problem in very specific cases. Knowing what makes it slow, and the different solutions to avoid this issue, will usually be enough to work through any trouble.</p>
    <p class="normal">We've rapidly looked at several frameworks, both synchronous and asynchronous, and for the rest of the book, we'll be using Quart. The next chapter will introduce this fantastic framework.</p>
  </div>
</body></html>