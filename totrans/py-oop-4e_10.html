<html><head></head><body>
  <div><h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-215" class="chapterTitle">The Iterator Pattern</h1>
    <p class="normal">We've discussed how many of Python's built-ins and idioms seem, at first blush, to fly in the face of object-oriented principles, but are actually providing access to real objects under the hood. In this chapter, we'll discuss how the <code class="Code-In-Text--PACKT-">for</code> loop, which seems so structured, is actually a lightweight wrapper around a set of object-oriented principles. We'll also see a variety of extensions to this syntax that automatically create even more types of object. We will cover the following topics:</p>
    <ul>
      <li class="bullet">What design patterns are</li>
      <li class="bullet">The iterator protocol – one of the most powerful design patterns</li>
      <li class="bullet">List, set, and dictionary comprehensions</li>
      <li class="bullet">Generator functions, and how they build on other patterns</li>
    </ul>
    <p class="normal">The case study for this chapter will revisit the algorithms for partitioning sample data into testing and training subsets to see how the iterator design pattern applies to this part of the problem.</p>
    <p class="normal">We'll start with an overview of what design patterns are and why they're so important.</p>
    <h1 id="_idParaDest-216" class="title">Design patterns in brief</h1>
    <p class="normal">When engineers and architects decide to build a bridge, or a tower, or a building, they follow certain principles to ensure structural integrity. There are various possible designs for bridges (suspension and cantilever, for example), but if the engineer doesn't use one of the standard designs, and doesn't have a brilliant new design, it is likely the bridge they design will collapse.</p>
    <p class="normal">Design patterns are <a id="_idIndexMarker711"/>an attempt to bring this same formal definition for correctly designed structures to software engineering. There are many different design patterns to solve different general problems. Design patterns are applied to solve a common problem faced by developers in some specific situation. The design pattern is a suggestion as to the ideal solution for that problem, in terms of object-oriented design. What's central to a pattern is that it is reused often in unique contexts. One clever solution is a good idea. Two similar solutions might be a coincidence. Three or more reuses of an idea and it starts to look like a repeating pattern.</p>
    <p class="normal">Knowing<a id="_idIndexMarker712"/> design patterns and choosing to use them in our software does not, however, guarantee that we are creating a <em class="italic">correct</em> solution. In 1907, the Québec Bridge (to this day, the longest cantilever bridge in the world, just short of a kilometer long) collapsed before construction was completed, because the engineers who designed it grossly underestimated the weight of the steel used to construct it. Similarly, in software development, we may incorrectly choose or apply a design pattern, and create software that <em class="italic">collapses</em> under normal operating situations or when stressed beyond its original design limits.</p>
    <p class="normal">Any one design pattern proposes a set of objects interacting in a specific way to solve a general problem. The job of the programmer is to recognize when they are facing a specific version of such a problem, then to choose and adapt the general pattern to their precise needs.</p>
    <p class="normal">In this chapter, we'll look deeply at the iterator design pattern. This pattern is so powerful and pervasive that the Python developers have provided multiple syntaxes to access the object-oriented principles underlying the pattern. We will be covering other design patterns in the next two chapters. Some of them have language support and some don't, but none of them are so intrinsically a part of the Python coder's daily life as the iterator pattern.</p>
    <h1 id="_idParaDest-217" class="title">Iterators</h1>
    <p class="normal">In typical design pattern parlance, an <strong class="keyword">iterator</strong> is an object with a <code class="Code-In-Text--PACKT-">next()</code> method and a <code class="Code-In-Text--PACKT-">done()</code> method; the <a id="_idIndexMarker713"/>latter returns <code class="Code-In-Text--PACKT-">True</code> if there are no items left in the sequence. In a programming language without built-in support for iterators, the iterator would be used like this:</p>
    <pre class="programlisting code"><code class="hljs-code">while not iterator.done(): 
    item = iterator.next() 
    # do something with the item 
</code></pre>
    <p class="normal">In Python, iteration is available across many language features, so the method gets a special name, <code class="Code-In-Text--PACKT-">__next__</code>. This method can be accessed using the <code class="Code-In-Text--PACKT-">next(iterator)</code> built-in. Rather than a <code class="Code-In-Text--PACKT-">done()</code> method, Python's iterator protocol raises the <code class="Code-In-Text--PACKT-">StopIteration</code> exception to notify the client that the iterator has completed. Finally, we have the much more readable <code class="Code-In-Text--PACKT-">for item in iterator:</code> syntax to actually access items in an iterator instead of messing around with a <code class="Code-In-Text--PACKT-">while</code> statement. Let's look at each these in more detail.</p>
    <h2 id="_idParaDest-218" class="title">The iterator protocol</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Iterator</code> abstract <a id="_idIndexMarker714"/>base class, in the <code class="Code-In-Text--PACKT-">collections.abc</code> module, defines the <em class="italic">iterator</em> protocol in Python. This definition is also referenced by the <code class="Code-In-Text--PACKT-">typing</code> module to provide suitable type hints. At the foundation, any <code class="Code-In-Text--PACKT-">Collection</code> class definition must be <code class="Code-In-Text--PACKT-">Iterable</code>. To be <code class="Code-In-Text--PACKT-">Iterable</code> means implementing an <code class="Code-In-Text--PACKT-">__iter__()</code> method; this method creates an <code class="Code-In-Text--PACKT-">Iterator</code> object.</p>
    <figure class="mediaobject"><img src="img/B17070_10_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.1: The abstractions for Iterable</p>
    <p class="normal">As mentioned, an <code class="Code-In-Text--PACKT-">Iterator</code> class must define a <code class="Code-In-Text--PACKT-">__next__()</code> method that the <code class="Code-In-Text--PACKT-">for</code> statement (and other features that support iteration) can call to get a new element from the sequence. In addition, every <code class="Code-In-Text--PACKT-">Iterator</code> class must also fulfill the <code class="Code-In-Text--PACKT-">Iterable</code> interface. This means an <code class="Code-In-Text--PACKT-">Iterator</code> will also provide an <code class="Code-In-Text--PACKT-">__iter__()</code> method. </p>
    <p class="normal">This might sound a bit confusing, so have a look at the following example. Note that this is a very verbose way to solve this problem. It explains iteration and the two protocols in question, but we'll be looking at several more readable ways to get this effect later in this chapter:</p>
    <pre class="programlisting code"><code class="hljs-code">from typing import Iterable, Iterator
class CapitalIterable(Iterable[str]):
    def __init__(self, string: str) -&gt; None:
        self.string = string
    def __iter__(self) -&gt; Iterator[str]:
        return CapitalIterator(self.string)
class CapitalIterator(Iterator[str]):
    def __init__(self, string: str) -&gt; None:
        self.words = [w.capitalize() for w in string.split()]
        self.index = 0
    def __next__(self) -&gt; str:
        if self.index == len(self.words):
            raise StopIteration()
        word = self.words[self.index]
        self.index += 1
        return word
</code></pre>
    <p class="normal">This example<a id="_idIndexMarker715"/> defines a <code class="Code-In-Text--PACKT-">CapitalIterable</code> class whose job is to loop over each of the words in a string and output them with the first letter capitalized. We formalized this by using the <code class="Code-In-Text--PACKT-">Iterable[str]</code> type hint as a superclass to make it clear what our intention was. Most of the work of this iterable class is delegated to the <code class="Code-In-Text--PACKT-">CapitalIterator</code> implementation. One way to interact with this iterator is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; iterable = CapitalIterable('the quick brown fox jumps over the lazy dog')
&gt;&gt;&gt; iterator = iter(iterable)
&gt;&gt;&gt; while True:
...     try:
...         print(next(iterator))
...     except StopIteration:
...         break
...     
The
Quick
Brown
Fox
Jumps
Over
The
Lazy
Dog  
</code></pre>
    <p class="normal">This example first constructs an iterable, assigning it to a variable with the boringly obvious name of <code class="Code-In-Text--PACKT-">iterable</code>. It then retrieves a <code class="Code-In-Text--PACKT-">CapitalIterator</code> instance from the <code class="Code-In-Text--PACKT-">iterable</code> object. The distinction may need explanation; the iterable is an object with elements that can be iterated over. Normally, these elements can be looped over multiple times, maybe even at the same time or in overlapping code. The iterator, on the other hand, represents a specific location in that iterable; some of the items have been consumed and some have not. Two different iterators might be at different places in the list of words, but any one iterator can mark only one place.</p>
    <p class="normal">Each time <code class="Code-In-Text--PACKT-">next()</code> is <a id="_idIndexMarker716"/>called on the iterator, it returns another token from the iterable, in order, and updates its internal state to point to the next item. Eventually, the iterator will be exhausted (won't have any more elements to return), in which case a <code class="Code-In-Text--PACKT-">StopIteration</code> exception is raised, and we break out of the <code class="Code-In-Text--PACKT-">while</code> statement.</p>
    <p class="normal">Python has a simpler syntax for constructing an iterator from an iterable:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; for i in iterable:
...     print(i)
...     
The
Quick
Brown
Fox
Jumps
Over
The
Lazy
Dog  
</code></pre>
    <p class="normal">As you can see, the <code class="Code-In-Text--PACKT-">for</code> statement, in spite of not looking remotely object-oriented, is actually a shortcut to some fundamentally object-oriented design principles. Keep this in mind as we discuss comprehensions, as they, too, appear to be the polar opposite of an object-oriented tool. Yet, they use the same iteration protocol as <code class="Code-In-Text--PACKT-">for</code> statements and are another kind of shortcut.</p>
    <p class="normal">The number of iterable classes in Python is large. We're not surprised when strings, tuples, and lists are iterable. A set, clearly, must be iterable, even if the order of elements may be difficult to predict. A mapping will iterate over the keys by default; other iterators<a id="_idIndexMarker717"/> are available. A file iterates over the available lines. A regular expression has a method, <code class="Code-In-Text--PACKT-">finditer()</code>, that is an iterator over each instance of a matching substring that it can find. The <code class="Code-In-Text--PACKT-">Path.glob()</code> method will iterate over matching items in a directory. The <code class="Code-In-Text--PACKT-">range()</code> object is also an iterator. You get the idea: anything even vaguely collection-like will support some kind of iterator.</p>
    <h1 id="_idParaDest-219" class="title">Comprehensions</h1>
    <p class="normal">Comprehensions are <a id="_idIndexMarker718"/>simple, but powerful, syntaxes that allow us to transform or filter an iterable object in as little as one line of code. The resultant object can be a perfectly normal list, set, or dictionary, or it can be a <em class="italic">generator expression</em> that can be efficiently consumed while keeping just one element in memory at a time.</p>
    <h2 id="_idParaDest-220" class="title">List comprehensions</h2>
    <p class="normal">List <a id="_idIndexMarker719"/>comprehensions are one of the most powerful tools in<a id="_idIndexMarker720"/> Python, so people tend to think of them as advanced. They're not. Indeed, we've taken the liberty of littering previous examples with comprehensions, assuming you would understand them. While it's true that advanced programmers use comprehensions a lot, it's not because they're advanced. It's because a comprehension is so fundamental to Python, it can handle many of the most common operations in application software.</p>
    <p class="normal">Let's have a look at one of those common operations; namely, converting a list of items into a list of related items. Specifically, let's assume we just read a list of strings from a file, and now we want to convert it to a list of integers. We know every item in the list is an integer, and we want to do some activity (say, calculate an average) on those numbers. Here's one simple way to approach it:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; input_strings = ["1", "5", "28", "131", "3"]
 
&gt;&gt;&gt; output_integers = [] 
&gt;&gt;&gt; for num in input_strings: 
...    output_integers.append(int(num)) 
</code></pre>
    <p class="normal">This works fine and it's only three lines of code. If you aren't used to comprehensions, you may not even think it looks ugly! Now, look at the same code using a list comprehension:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; output_integers = [int(num) for num in input_strings] 
</code></pre>
    <p class="normal">We're down to one line and, importantly for performance, we've dropped an <code class="Code-In-Text--PACKT-">append</code> method call for each item in the list. Overall, it's pretty easy to tell what's going on, even if you're not used to comprehension syntax.</p>
    <p class="normal">The square brackets<a id="_idIndexMarker721"/> indicate, as always, that we're creating a<a id="_idIndexMarker722"/> list. Inside this list is a <code class="Code-In-Text--PACKT-">for</code> clause that iterates over each item in the input sequence. The only thing that may be confusing is what's happening between the list's opening brace and the start of the <code class="Code-In-Text--PACKT-">for</code> statement. Whatever expression is provided here is applied to <em class="italic">each</em> of the items in the input list. The item in question is referenced by the <code class="Code-In-Text--PACKT-">num</code> variable from the <code class="Code-In-Text--PACKT-">for</code> clause. So, this expression applies the <code class="Code-In-Text--PACKT-">int</code> function to each element and stores the resulting integer in the new list.</p>
    <p class="normal">Terminology-wise, we call this a <strong class="keyword">mapping</strong>. We are applying the result expression, <code class="Code-In-Text--PACKT-">int(num)</code> in this example, to map values from the source iterable to create a resulting iterable list.</p>
    <p class="normal">That's all there is to a basic list comprehension. Comprehensions are highly optimized, making them far faster than <code class="Code-In-Text--PACKT-">for</code> statements when processing a large number of items. When used wisely, they're also more readable. These are two compelling reasons to use them widely.</p>
    <p class="normal">Converting one list of items into a related list isn't the only thing we can do with a list comprehension. We can also choose to exclude certain values by adding an <code class="Code-In-Text--PACKT-">if</code> statement inside the comprehension. We call this a <strong class="keyword">filter</strong>. Have a look:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; output_integers = [int(num) for num in input_strings if len(num) &lt; 3]
&gt;&gt;&gt; output_integers
[1, 5, 28, 3]
</code></pre>
    <p class="normal">The essential difference between this example and the previous one is the <code class="Code-In-Text--PACKT-">if len(num) &lt; 3</code> clause. This extra code excludes any strings with more than two characters. The <code class="Code-In-Text--PACKT-">if</code> clause is applied to each element <strong class="keyword">before</strong> the final <code class="Code-In-Text--PACKT-">int()</code> function, so it's testing the length of a string. Since our input strings are all integers at heart, it excludes any number over 99.</p>
    <p class="normal">A list comprehension can be used to map input values to output values, applying a filter along the way to include or exclude any values that meet a specific condition. A great many algorithms involve mapping and filtering operations.</p>
    <p class="normal">Any iterable can be the input to a list comprehension. In other words, anything we can wrap in a <code class="Code-In-Text--PACKT-">for</code> statement can also be used as the source for a comprehension. </p>
    <p class="normal">For example, text<a id="_idIndexMarker723"/> files are iterable; each call to <code class="Code-In-Text--PACKT-">__next__()</code> on <a id="_idIndexMarker724"/>the file's iterator will return one line of the file. We can examine the lines of a text file by naming the open file in the <code class="Code-In-Text--PACKT-">for</code> clause of a list comprehension. We can then use the <code class="Code-In-Text--PACKT-">if</code> clause to extract interesting lines of text. This example finds a subset of lines in a test file:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; source_path = Path('src') / 'iterator_protocol.py'
&gt;&gt;&gt; with source_path.open() as source:
...     examples = [line.rstrip() 
...         for line in source 
...         if "&gt;&gt;&gt;" in line]
</code></pre>
    <p class="normal">In this example, we've added some whitespace to make the comprehension more readable (list comprehensions don't <em class="italic">have</em> to fit on one physical line even though they're one logical line). This example creates a list of lines that have the "<code class="Code-In-Text--PACKT-">&gt;&gt;&gt;</code>" prompt in them. The presence of "<code class="Code-In-Text--PACKT-">&gt;&gt;&gt;</code>" suggests there might be a doctest example in this file. The list of lines has <code class="Code-In-Text--PACKT-">rstrip()</code> applied to remove trailing whitespace, like the <code class="Code-In-Text--PACKT-">\n</code> that ends each line of text returned by the iterator. The resulting list object, <code class="Code-In-Text--PACKT-">examples</code>, suggests some of the test cases that can be found within the code. (This isn't as clever as doctest's own parser.)</p>
    <p class="normal">Let's extend this example to capture the line numbers for each example with a "<code class="Code-In-Text--PACKT-">&gt;&gt;&gt;</code>" prompt in it. This is a common requirement, and the built-in <code class="Code-In-Text--PACKT-">enumerate()</code> function helps us pair a number with each item provided by the iterator:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; with source_path.open() as source:
...     examples = [(number, line.rstrip()) 
...         for number, line in enumerate(source, start=1) 
...         if "&gt;&gt;&gt;" in line]
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">enumerate()</code> function consumes an iterable, providing an iterable sequence of two-tuples of a number and the original item. If the line passes our "<code class="Code-In-Text--PACKT-">&gt;&gt;&gt;</code>" test, we'll create a two-tuple of the number and the cleaned-up text. We've done some sophisticated processing in – effectively – one line of code. Essentially, though, it's a filter and a mapping. First it extracts tuples from the source, then it filters the lines that match the given <code class="Code-In-Text--PACKT-">if</code> clause, then it evaluates the <code class="Code-In-Text--PACKT-">(number, line.rstrip())</code> expression to create resulting tuples, and finally, collects it all into a list object. The ubiquity of this iterate-filter-map-collect pattern drives the idea behind a list comprehension.</p>
    <h2 id="_idParaDest-221" class="title">Set and dictionary comprehensions</h2>
    <p class="normal">Comprehensions aren't restricted to lists. We can use a similar syntax with braces to create sets and dictionaries as well. Let's start with sets. One way to create a set is to wrap a list comprehension in the <code class="Code-In-Text--PACKT-">set()</code> constructor, which converts it to a set. But why waste memory on an intermediate list that gets discarded, when we can create a set directly?</p>
    <p class="normal">Here's an example that uses a named tuple to model author/title/genre triples, and then retrieves a set of all the authors that write in a specific genre:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from typing import NamedTuple
&gt;&gt;&gt; class Book(NamedTuple):
...     author: str
...     title: str
...     genre: str
&gt;&gt;&gt; books = [
...     Book("Pratchett", "Nightwatch", "fantasy"),
...     Book("Pratchett", "Thief Of Time", "fantasy"),
...     Book("Le Guin", "The Dispossessed", "scifi"),
...     Book("Le Guin", "A Wizard Of Earthsea", "fantasy"),
...     Book("Jemisin", "The Broken Earth", "fantasy"),
...     Book("Turner", "The Thief", "fantasy"),
...     Book("Phillips", "Preston Diamond", "western"),
...     Book("Phillips", "Twice Upon A Time", "scifi"),
... ]
</code></pre>
    <p class="normal">We've defined a small library of instances of the <code class="Code-In-Text--PACKT-">Book</code> class. We can create a set from each of these objects by using a set comprehension. It looks a lot like a list comprehension, but uses <code class="Code-In-Text--PACKT-">{}</code> instead of <code class="Code-In-Text--PACKT-">[]</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; fantasy_authors = {b.author for b in books if b.genre == "fantasy"}
</code></pre>
    <p class="normal">The highlighted <a id="_idIndexMarker725"/>set comprehension<a id="_idIndexMarker726"/> sure is short in comparison to the demo-data setup! If we were to use a list comprehension, of course, Terry Pratchett would have been listed twice. As it is, the nature of sets removes the duplicates, and we end up with the following:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; fantasy_authors
{'Pratchett', 'Le Guin', 'Turner', 'Jemisin'}
</code></pre>
    <p class="normal">Note that sets don't have a defined ordering, so your output may differ from this example. For testing purposes, we'll sometimes set the <code class="Code-In-Text--PACKT-">PYTHONHASHSEED</code> environment variable to impose an order. This introduces a tiny security vulnerability, so it's only suitable for testing.</p>
    <p class="normal">Still using braces, we can introduce a colon to make <code class="Code-In-Text--PACKT-">key:value</code> pairs required to create a dictionary comprehension. For example, it may be useful to quickly look up the author or genre in a dictionary if we know the title. We can use a dictionary comprehension to map titles to <code class="Code-In-Text--PACKT-">books</code> objects:</p>
    <pre class="programlisting code"><code class="hljs-code">fantasy_titles = {b.title: b for b in books if b.genre == "fantasy"}
</code></pre>
    <p class="normal">Now, we have a <a id="_idIndexMarker727"/>dictionary, and can look up books by title using the normal<a id="_idIndexMarker728"/> syntax, <code class="Code-In-Text--PACKT-">fantasy_titles['Nightwatch']</code>. We've created a high-performance index from a lower-performance sequence.</p>
    <p class="normal">In summary, comprehensions are not advanced Python, nor are they features that subvert object-oriented programming. They are a more concise syntax for creating a list, set, or dictionary from an existing iterable source of data. </p>
    <h2 id="_idParaDest-222" class="title">Generator expressions</h2>
    <p class="normal">Sometimes we want <a id="_idIndexMarker729"/>to process a new sequence without pulling a new list, set, or dictionary into system memory. If we're iterating over items one at a time, and don't actually care about having a complete container (such as a list or dictionary) created, a container is a waste of memory. When processing one item at a time, we only need the current object available in memory at any one moment. But when we create a container, all the objects have to be stored in that container before we start processing them.</p>
    <p class="normal">For example, consider a program that processes log files. A very simple log might contain information in this format:</p>
    <pre class="programlisting con"><code class="hljs-con">Apr 05, 2021 20:03:29 DEBUG This is a debugging message.
Apr 05, 2021 20:03:41 INFO This is an information method.
Apr 05, 2021 20:03:53 WARNING This is a warning. It could be serious.
Apr 05, 2021 20:03:59 WARNING Another warning sent.
Apr 05, 2021 20:04:05 INFO Here's some information.
Apr 05, 2021 20:04:17 DEBUG Debug messages are only useful if you want to figure something out.
Apr 05, 2021 20:04:29 INFO Information is usually harmless, but helpful.
Apr 05, 2021 20:04:35 WARNING Warnings should be heeded.
Apr 05, 2021 20:04:41 WARNING Watch for warnings.
</code></pre>
    <p class="normal">Log files for popular web <a id="_idIndexMarker730"/>servers, databases, or email servers can contain many gigabytes of data (one of the authors once had to clean nearly two terabytes of logs off a misbehaving system). If we want to process each line in the log, we can't use a list comprehension; it would create a list containing every line in the file. This probably wouldn't fit in RAM and could bring the computer to its knees, depending on the operating system.</p>
    <p class="normal">If we used a <code class="Code-In-Text--PACKT-">for</code> statement on the log file, we could process one line at a time before reading the next one into memory. Wouldn't be nice if we could use comprehension syntax to get the same effect?</p>
    <p class="normal">This is where generator expressions come in. They use the same syntax as comprehensions, but they don't create a final container object. We call them <strong class="keyword">lazy</strong>; they reluctantly produce values on demand. To create a generator expression, wrap the comprehension in <code class="Code-In-Text--PACKT-">()</code> instead of <code class="Code-In-Text--PACKT-">[]</code> or <code class="Code-In-Text--PACKT-">{}</code>.</p>
    <p class="normal">The following code parses a log file in the previously presented format and outputs a new log file that contains only the <code class="Code-In-Text--PACKT-">WARNING</code> lines:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; full_log_path = Path.cwd() / "data" / "sample.log"
&gt;&gt;&gt; warning_log_path = Path.cwd() / "data" / "warnings.log"
&gt;&gt;&gt; with full_log_path.open() as source:
...     warning_lines = (line for line in source if "WARN" in line)
...     with warning_log_path.open('w') as target:
...         for line in warning_lines:
...             target.write(line)
</code></pre>
    <p class="normal">We've opened the <code class="Code-In-Text--PACKT-">sample.log</code> file, a file perhaps too large to fit in memory. A generator expression will filter out the warnings (in this case, it uses the <code class="Code-In-Text--PACKT-">if</code> syntax and leaves the line unmodified). This is lazy, and doesn't really do anything until we consume its output. We can open another file as a subset. The final <code class="Code-In-Text--PACKT-">for</code> statement consumes each individual line from the <code class="Code-In-Text--PACKT-">warning_lines</code> generator. At no time is the full log file read into memory; the processing happens one line at a time. </p>
    <p class="normal">If we run it on our sample file, the resulting <code class="Code-In-Text--PACKT-">warnings.log</code> file looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con">Apr 05, 2021 20:03:53 WARNING This is a warning. It could be serious.
Apr 05, 2021 20:03:59 WARNING Another warning sent.
Apr 05, 2021 20:04:35 WARNING Warnings should be heeded.
Apr 05, 2021 20:04:41 WARNING Watch for warnings.
</code></pre>
    <p class="normal">Of course, with a short input file, we could have safely used a list comprehension, doing all the processing in memory. When the file is millions of lines long, the generator expression will have a huge impact on both memory and speed.</p>
    <div><p class="Tip--PACKT-">The core of a comprehension is the generator expression. Wrapping a generator in <code class="Code-In-Text--PACKT-">[]</code> creates a list. Wrapping a generator in <code class="Code-In-Text--PACKT-">{}</code> creates a set. Using <code class="Code-In-Text--PACKT-">{}</code> and <code class="Code-In-Text--PACKT-">:</code> to separate keys and values creates a dictionary. Wrapping a generator in <code class="Code-In-Text--PACKT-">()</code> is still a generator expression, not a tuple.</p>
    </div>
    <p class="normal">Generator <a id="_idIndexMarker731"/>expressions are frequently most useful inside function calls. For example, we can call <code class="Code-In-Text--PACKT-">sum</code>, <code class="Code-In-Text--PACKT-">min</code>, or <code class="Code-In-Text--PACKT-">max</code> on a generator expression instead of a list, since these functions process one object at a time. We're only interested in the aggregate result, not any intermediate container.</p>
    <p class="normal">In general, of the four options, a generator expression should be used whenever possible. If we don't actually need a list, set, or dictionary, but simply need to filter or apply a mapping to items in a sequence, a generator expression will be most efficient. If we need to know the length of a list, or sort the result, remove duplicates, or create a dictionary, we'll have to use the comprehension syntax and create a resulting collection.</p>
    <h1 id="_idParaDest-223" class="title">Generator functions</h1>
    <p class="normal">Generator functions <a id="_idIndexMarker732"/>embody the essential features of a generator expression, which is the generalization of a comprehension. The generator function syntax looks even less object-oriented than anything we've seen, but we'll discover that once again, it is a syntax shortcut to create a kind of iterator object. It helps us build processing following the standard iterator-filter-mapping pattern.</p>
    <p class="normal">Let's take the log file example a little further. If we want to decompose the log into columns, we'll have to do a more significant transformation as part of the mapping step. This will involve a regular expression to find the timestamp, the severity word, and the message as a whole. We'll look at a number of solutions to this problem to show how generators and generator functions can be applied to create the objects we want.</p>
    <p class="normal">Here's a version, avoiding generator expressions entirely:</p>
    <pre class="programlisting code"><code class="hljs-code">import csv
import re
from pathlib import Path
from typing import Match, cast
def extract_and_parse_1(
        full_log_path: Path, warning_log_path: Path
)-&gt; None:
    with warning_log_path.open("w") as target:
        writer = csv.writer(target, delimiter="\t")
        pattern = re.compile(
            r"(\w\w\w \d\d, \d\d\d\d \d\d:\d\d:\d\d) (\w+) (.*)")
        with full_log_path.open() as source:
            for line in source:
                if "WARN" in line:
                    line_groups = cast(
                        Match[str], pattern.match(line)).groups()
                    writer.writerow(line_groups)
</code></pre>
    <p class="normal">We've defined a regular expression to match three groups:</p>
    <ul>
      <li class="bullet">The complex date string, <code class="Code-In-Text--PACKT-">(\w\w\w \d\d, \d\d\d\d \d\d:\d\d:\d\d),</code> which is a generalization of strings like "<code class="Code-In-Text--PACKT-">Apr 05, 2021 20:04:41</code>".</li>
      <li class="bullet">The severity level, <code class="Code-In-Text--PACKT-">(\w+)</code>, which matches a run of letters, digits, or underscores. This will match words like INFO and DEBUG.</li>
      <li class="bullet">An optional message, <code class="Code-In-Text--PACKT-">(.*)</code>, which will collect all characters to the end of the line.</li>
    </ul>
    <p class="normal">This pattern is <a id="_idIndexMarker733"/>assigned to the <code class="Code-In-Text--PACKT-">pattern</code> variable. As an alternative, we could also use <code class="Code-In-Text--PACKT-">split(' ')</code> to break the line into space-separated words; the first four words are the date, the next word is the severity, and all the remaining words are the message. This isn't as flexible as defining a regular expression.</p>
    <p class="normal">The decomposition of the line into groups involves two steps. First, we apply <code class="Code-In-Text--PACKT-">pattern.match()</code> to the line of text to create a <code class="Code-In-Text--PACKT-">Match</code> object. Then we interrogate the <code class="Code-In-Text--PACKT-">Match</code> object for the sequence of groups that matched. We have a <code class="Code-In-Text--PACKT-">cast(Match[str], pattern.match(line))</code> to tell <strong class="" style="font-style: italic;">mypy</strong> that every line will create a <code class="Code-In-Text--PACKT-">Match</code> object. The type hint for <code class="Code-In-Text--PACKT-">re.match()</code> is <code class="Code-In-Text--PACKT-">Optional[Match]</code> because it returns a <code class="Code-In-Text--PACKT-">None</code> when there's no <code class="Code-In-Text--PACKT-">Match</code>. We're using <code class="Code-In-Text--PACKT-">cast()</code> to make the claim that every line will match, and if it doesn't match, we want this function to raise an exception.</p>
    <p class="normal">This deeply nested function seems maintainable, but so many levels of indent in so few lines is kind of ugly. More alarmingly, if there is some irregularity in the file, and we want to handle the case where the <code class="Code-In-Text--PACKT-">pattern.match(line)</code> returns <code class="Code-In-Text--PACKT-">None</code>, we'd have to include another <code class="Code-In-Text--PACKT-">if</code> statement, leading to even deeper levels of nesting. Deeply nested conditional processing leads to statements where the conditions under which they are executed can be obscure. </p>
    <p class="normal">The reader has to mentally integrate all of the preceding <code class="Code-In-Text--PACKT-">if</code> statements to work out the condition. This can be a problem with this kind of solution.</p>
    <p class="normal">Now let's consider a truly<a id="_idIndexMarker734"/> object-oriented solution, without any shortcuts:</p>
    <pre class="programlisting code"><code class="hljs-code">import csv
import re
from pathlib import Path
from typing import Match, cast, Iterator, Tuple, TextIO
class WarningReformat(Iterator[Tuple[str, ...]]):
    pattern = re.compile(
        r"(\w\w\w \d\d, \d\d\d\d \d\d:\d\d:\d\d) (\w+) (.*)")
    def __init__(self, source: TextIO) -&gt; None:
        self.insequence = source
    def __iter__(self) -&gt; Iterator[tuple[str, ...]]:
        return self
    def __next__(self) -&gt; tuple[str, ...]:
        line = self.insequence.readline()
        while line and "WARN" not in line:
            line = self.insequence.readline()
        if not line:
            raise StopIteration
        else:
            return tuple(
                cast(Match[str], 
                     self.pattern.match(line)
                ).groups()
            )
def extract_and_parse_2(
        full_log_path: Path, warning_log_path: Path
) -&gt; None:
    with warning_log_path.open("w") as target:
        writer = csv.writer(target, delimiter="\t")
        with full_log_path.open() as source:
            filter_reformat = WarningReformat(source)
            for line_groups in filter_reformat:
                writer.writerow(line_groups)
</code></pre>
    <p class="normal">We've defined a formal <code class="Code-In-Text--PACKT-">WarningReformat</code> iterator that emits the three-tuple of the date, warning, and message. We've used a type hint of <code class="Code-In-Text--PACKT-">tuple[str, ...]</code> because it matches the output from the <code class="Code-In-Text--PACKT-">self.pattern.match(line).groups()</code> expression: it's a sequence of strings, with no constraint on how many will be present. The iterator is initialized with a <code class="Code-In-Text--PACKT-">TextIO</code> object, something file-like that has a <code class="Code-In-Text--PACKT-">readline()</code> method.</p>
    <p class="normal">This <code class="Code-In-Text--PACKT-">__next__()</code> method reads lines from the file, discarding any lines that are not <code class="Code-In-Text--PACKT-">WARNING</code> lines. When we encounter a <code class="Code-In-Text--PACKT-">WARNING</code> line, we parse it and return the three-tuple of strings. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">extract_and_parse_2()</code> function <a id="_idIndexMarker735"/>uses an instance of the <code class="Code-In-Text--PACKT-">WarningReformat</code> class in a <code class="Code-In-Text--PACKT-">for</code> statement; this will evaluate the <code class="Code-In-Text--PACKT-">__next__()</code> method repeatedly to process the subsequent <code class="Code-In-Text--PACKT-">WARNING</code> line. When we run out of lines, the <code class="Code-In-Text--PACKT-">WarningReformat</code> class raises a <code class="Code-In-Text--PACKT-">StopIteration</code> exception to tell the function statement we're finished iterating. It's pretty ugly compared to the other examples, but it's also powerful; now that we have a class in our hands, we can do whatever we want with it.</p>
    <p class="normal">With that background behind us, we finally get to see true generators in action. This next example does <em class="italic">exactly</em> the same thing as the previous one: it creates an object with a <code class="Code-In-Text--PACKT-">__next__()</code> method that raises <code class="Code-In-Text--PACKT-">StopIteration</code> when it's out of inputs:</p>
    <pre class="programlisting code"><code class="hljs-code">from __future__ import annotations
import csv
import re
from pathlib import Path
from typing import Match, cast, Iterator, Iterable
def warnings_filter(
        source: Iterable[str]
) -&gt; Iterator[tuple[str, ...]]:
    pattern = re.compile(
        r"(\w\w\w \d\d, \d\d\d\d \d\d:\d\d:\d\d) (\w+) (.*)")
    for line in source:
        if "WARN" in line:
            yield tuple(
                cast(Match[str], pattern.match(line)).groups())
def extract_and_parse_3(
        full_log_path: Path, warning_log_path: Path
) -&gt; None:
    with warning_log_path.open("w") as target:
        writer = csv.writer(target, delimiter="\t")
        with full_log_path.open() as infile:
            filter = warnings_filter(infile)
            for line_groups in filter:
                writer.writerow(line_groups)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">yield</code> statement in the <code class="Code-In-Text--PACKT-">warning_filters()</code> function is the key to generators. When Python sees <code class="Code-In-Text--PACKT-">yield</code> in a function, it takes that function and wraps it up in an object that follows the <code class="Code-In-Text--PACKT-">Iterator</code> protocol, not unlike the class defined in our previous example. Think of the <code class="Code-In-Text--PACKT-">yield</code> statement as similar to the <code class="Code-In-Text--PACKT-">return</code> statement; it returns a line. Unlike <code class="Code-In-Text--PACKT-">return</code>, however, the function is only suspended. When it is called again (via <code class="Code-In-Text--PACKT-">next()</code>), it will start where it left off – on the line after the <code class="Code-In-Text--PACKT-">yield</code> statement – instead of at the beginning of the function. In this example, there is no line <em class="italic">a</em><em class="italic">fter</em> the <code class="Code-In-Text--PACKT-">yield</code> statement, so it jumps to the next iteration of the <code class="Code-In-Text--PACKT-">for</code> statement. Since the <code class="Code-In-Text--PACKT-">yield</code> statement is inside an <code class="Code-In-Text--PACKT-">if</code> statement, it only yields lines that contain <code class="Code-In-Text--PACKT-">WARNING</code>.</p>
    <p class="normal">While it looks like this is just<a id="_idIndexMarker736"/> a function looping over the lines, it is actually creating a special type of object, a generator object:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; print(warnings_filter([]))
&lt;generator object warnings_filter at 0xb728c6bc&gt;  
</code></pre>
    <p class="normal">All the function does is create and return a generator object. In this example, an empty list was provided, and a generator was built. The generator object has <code class="Code-In-Text--PACKT-">__iter__()</code> and <code class="Code-In-Text--PACKT-">__next__()</code> methods on it, just like the one we created from a class definition in the previous example. (Using the <code class="Code-In-Text--PACKT-">dir()</code> built-in function on it will reveal what else is part of a generator.) Whenever the <code class="Code-In-Text--PACKT-">__next__()</code> method is called, the generator runs the function until it finds a <code class="Code-In-Text--PACKT-">yield</code> statement. It then suspends execution, retaining the current state, and returning the value from <code class="Code-In-Text--PACKT-">yield</code>. The next time the <code class="Code-In-Text--PACKT-">__next__()</code> method is called, it restores the state and picks up execution where it left off.</p>
    <p class="normal">This generator function is nearly identical to this generator expression:</p>
    <pre class="programlisting code"><code class="hljs-code">warnings_filter = (
    tuple(cast(Match[str], pattern.match(line)).groups())
    for line in source
    if "WARN" in line
)
</code></pre>
    <p class="normal">We can see how these various patterns align. The generator expression has all the elements of the statements, slightly compressed, and in a different order:</p>
    <figure class="mediaobject"><img src="img/B17070_10_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.2: Generator functions compared with generator expressions</p>
    <p class="normal">A <a id="_idIndexMarker737"/>comprehension, then, is a generator wrapped in <code class="Code-In-Text--PACKT-">[]</code> or <code class="Code-In-Text--PACKT-">{}</code> to create a concrete object. In some cases, it can make sense to use <code class="Code-In-Text--PACKT-">list()</code>, <code class="Code-In-Text--PACKT-">set()</code>, or <code class="Code-In-Text--PACKT-">dict()</code> as a wrapper around a generator. This is helpful when we're considering replacing the generic collection with a customized collection of our own. Changing <code class="Code-In-Text--PACKT-">list()</code> into <code class="Code-In-Text--PACKT-">MySpecialContainer()</code> seems to make the change more apparent.</p>
    <p class="normal">The generator expression has the advantage of being short and appearing right where it's needed. The generator function has a name and parameters, meaning it can be reused. More importantly, a generator function can have multiple statements and more complex processing logic in the cases where statements are needed. One common reason for switching from a generator expression to a function is to add exception handling.</p>
    <h2 id="_idParaDest-224" class="title">Yield items from another iterable</h2>
    <p class="normal">Often, when we build a generator function, we end up in a situation where we want to yield data from another <a id="_idIndexMarker738"/>iterable object, possibly a list comprehension or generator expression we constructed inside the generator, or perhaps some external items that were passed into the function. We'll look at how to do this with the <code class="Code-In-Text--PACKT-">yield from</code> statement.</p>
    <p class="normal">Let's adapt the generator example a bit so that instead of accepting an input file, it accepts the name of a directory. The idea is to keep our existing warnings filter generator in place, but tweak the structure of the functions that use it. We'll operate on iterators as both input and result; this way the same function could be used regardless of whether the log lines came from a file, memory, the web, or another iterator.</p>
    <p class="normal">This version of the code illustrates a new <code class="Code-In-Text--PACKT-">file_extract()</code> generator. This does some basic setup before yielding information from the <code class="Code-In-Text--PACKT-">warnings_filter()</code> generator:</p>
    <pre class="programlisting code"><code class="hljs-code">def file_extract(
        path_iter: Iterable[Path]
) -&gt; Iterator[tuple[str, ...]]:
    for path in path_iter:
        with path.open() as infile:
            yield from warnings_filter(infile)
def extract_and_parse_d(
        directory: Path, warning_log_path: Path) -&gt; None:
    with warning_log_path.open("w") as target:
        writer = csv.writer(target, delimiter="\t")
        log_files = list(directory.glob("sample*.log"))
        for line_groups in file_extract(log_files):
            writer.writerow(line_groups)
</code></pre>
    <p class="normal">Our top-level<a id="_idIndexMarker739"/> function <code class="Code-In-Text--PACKT-">extract_and_parse_d()</code> has a slight change to use the <code class="Code-In-Text--PACKT-">file_extract()</code> function instead of opening a file and applying the <code class="Code-In-Text--PACKT-">warnings_filter()</code> to one file. The <code class="Code-In-Text--PACKT-">file_extract()</code> generator will yield all of the <code class="Code-In-Text--PACKT-">WARNING</code> lines from <em class="italic">all</em> of the files provided in the argument value. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">yield from</code> syntax is a useful shortcut when writing chained generators. </p>
    <p class="normal">What's central in this example is the laziness of each of the generators involved. Consider what happens when the <code class="Code-In-Text--PACKT-">extract_and_parse_d()</code> function, the client, makes a demand:</p>
    <ol>
      <li class="numbered">The client evaluates <code class="Code-In-Text--PACKT-">file_extract(log_files)</code>. Since this is in a <code class="Code-In-Text--PACKT-">for</code> statement, there's an <code class="Code-In-Text--PACKT-">__iter__()</code> method evaluation.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">file_extract()</code> generator gets an iterator from the <code class="Code-In-Text--PACKT-">path_iter</code> iterable, and uses this to get the next <code class="Code-In-Text--PACKT-">Path</code> instance. The <code class="Code-In-Text--PACKT-">Path</code> object is used to create a file object that's provided to the <code class="Code-In-Text--PACKT-">warnings_filter()</code> generator.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">warnings_filter()</code> generator uses the file's iterator over lines to read until it finds a <code class="Code-In-Text--PACKT-">WARNING</code> line, which it parses, yielding exactly one tuple. The fewest number of lines were read to find this line.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">file_extract()</code> generator is yielding from the <code class="Code-In-Text--PACKT-">warnings_filter()</code> generator, so the single tuple is provided to the ultimate client, the <code class="Code-In-Text--PACKT-">extract_and_parse_d()</code> function. </li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">extract_and_parse_d()</code> function writes the single tuple to the open CSV file, and then demands another tuple. This request goes to <code class="Code-In-Text--PACKT-">file_extract()</code>, which pushes the demand down to <code class="Code-In-Text--PACKT-">warnings_filter()</code>, which pushes the demand to an open file to provide lines until a <code class="Code-In-Text--PACKT-">WARNING</code> line is found.</li>
    </ol>
    <p class="normal">Each generator<a id="_idIndexMarker740"/> is lazy and provides one response, doing the least amount of work it can get away with to produce the result. This means that a directory with a huge number of giant log files is processed by having one open log file, and one current line being parsed and processed. It won't fill memory no matter how large the files are.</p>
    <p class="normal">We've seen how generator functions can provide data to other generator functions. We can do this with ordinary generator expressions, also. We'll make some small changes to the <code class="Code-In-Text--PACKT-">warnings_filter()</code> function to show how we can create a stack of generator expressions.</p>
    <h2 id="_idParaDest-225" class="title">Generator stacks</h2>
    <p class="normal">The<a id="_idIndexMarker741"/> generator function (and the generator expression) for <code class="Code-In-Text--PACKT-">warnings_filter</code> makes an unpleasant assumption. The use of <code class="Code-In-Text--PACKT-">cast()</code> makes a claim to <strong class="" style="font-style: italic;">mypy</strong> that's – perhaps – a bad claim to make. Here's the example:</p>
    <pre class="programlisting code"><code class="hljs-code">warnings_filter = (
    tuple(cast(Match[str], pattern.match(line)).groups())
    for line in source
    if "WARN" in line
)
</code></pre>
    <p class="normal">The use of <code class="Code-In-Text--PACKT-">cast()</code> is a way of claiming the <code class="Code-In-Text--PACKT-">pattern.match()</code> will always yield a <code class="Code-In-Text--PACKT-">Match[str]</code> object. This isn't a great assumption to make. Someone may change the format of the log file to include a multiple-line message, and our <code class="Code-In-Text--PACKT-">WARNING</code> filter would crash every time we encountered a multi-line message.</p>
    <p class="normal">Here's a message that would cause problems followed by a message that's easy to process:</p>
    <pre class="programlisting con"><code class="hljs-con">Jan 26, 2015 11:26:01 INFO This is a multi-line information
message, with misleading content including WARNING
and it spans lines of the log file WARNING used in a confusing way
Jan 26, 2015 11:26:13 DEBUG Debug messages are only useful if you want to figure something out.
</code></pre>
    <p class="normal">The first line has the word <code class="Code-In-Text--PACKT-">WARN</code> in a multi-line message that will break our assumption about lines that contain the word <code class="Code-In-Text--PACKT-">WARN</code>. We need to handle this with a little more care.</p>
    <p class="normal">We can rewrite this generator expression to create a generator function, and add an assignment statement (to save the <code class="Code-In-Text--PACKT-">Match</code> object) and an <code class="Code-In-Text--PACKT-">if</code> statement to further decompose the filtering. We can use the walrus operator <code class="Code-In-Text--PACKT-">:=</code> to save the <code class="Code-In-Text--PACKT-">Match</code> object, also.</p>
    <p class="normal">We could reframe the <a id="_idIndexMarker742"/>generator expression as the following generator function:</p>
    <pre class="programlisting code"><code class="hljs-code">def warnings_filter(source: Iterable[str]
) -&gt; Iterator[Sequence[str]]:
    pattern = re.compile
        (r"(\w\w\w \d\d, \d\d\d\d \d\d:\d\d:\d\d) (\w+) (.*)")
    for line in source:
        if match := pattern.match(line):
            if "WARN" in match.group(2):
                yield match.groups()
</code></pre>
    <p class="normal">As we noted above, this complex filtering tends toward deeply nested <code class="Code-In-Text--PACKT-">if</code> statements, which can create logic that's difficult to summarize. In this case, the two conditions aren't terribly complex. An alternative is to change this into a series of map and filter stages, each of which does a separate, small transformation on the input. We can decompose the matching and filtering into the following:</p>
    <ul>
      <li class="bullet">Map the source line to an <code class="Code-In-Text--PACKT-">Optional[Match[str]]</code> object using the <code class="Code-In-Text--PACKT-">pattern.match()</code> method.</li>
      <li class="bullet">Filter to reject any <code class="Code-In-Text--PACKT-">None</code> objects, passing only good <code class="Code-In-Text--PACKT-">Match</code> objects and applying the <code class="Code-In-Text--PACKT-">groups()</code> method to create a <code class="Code-In-Text--PACKT-">List[str]</code>.</li>
      <li class="bullet">Filter the strings to reject the non-<code class="Code-In-Text--PACKT-">WARN</code> lines, and pass the <code class="Code-In-Text--PACKT-">WARN</code> lines.</li>
    </ul>
    <p class="normal">Each of these stages is a generator expression following the standard pattern. We can expand the <code class="Code-In-Text--PACKT-">warnings_filter</code> expression into a stack of three expressions:</p>
    <pre class="programlisting code"><code class="hljs-code">possible_match_iter = (pattern.match(line) for line in source)
group_iter = (
    match.groups() for match in possible_match_iter if match)
warnings_filter = (
    group for group in group_iter if "WARN" in group[1])
</code></pre>
    <p class="normal">These expressions are, of course, utterly lazy. The final <code class="Code-In-Text--PACKT-">warnings_filter</code> uses the iterable, <code class="Code-In-Text--PACKT-">group_iter</code>. This iterable gets matches from another generator, <code class="Code-In-Text--PACKT-">possible_match_iter</code>, which gets source text lines from the <code class="Code-In-Text--PACKT-">source</code> object, an iterable source of lines. Since each of these generators is getting items from another lazy iterator, there's only one line of data being processed through the <code class="Code-In-Text--PACKT-">if</code> clause and the final expression clause at each stage of this process.</p>
    <p class="normal">Note that we can exploit the surrounding <code class="Code-In-Text--PACKT-">()</code> to break each expression into multiple lines. This can help show the map or filter operation that's embodied in each expression.</p>
    <p class="normal">We can inject additional processing as long as it fits this essential mapping-and-filtering design pattern. Before moving on, we're going to switch to a slightly more friendly regular expression for locating lines in our log file:</p>
    <pre class="programlisting code"><code class="hljs-code">pattern = re.compile(
    r"(?P&lt;dt&gt;\w\w\w \d\d, \d\d\d\d \d\d:\d\d:\d\d)"
    r"\s+(?P&lt;level&gt;\w+)"
    r"\s+(?P&lt;msg&gt;.*)"
)
</code></pre>
    <p class="normal">This regular expression is broken into three adjacent strings; Python will automatically concatenate string literals. The expression uses three named groups. The date-time stamp, for example, is <a id="_idIndexMarker743"/>group number one, a hard-to-remember bit of trivia. The <code class="Code-In-Text--PACKT-">?P&lt;dt&gt;</code> inside the <code class="Code-In-Text--PACKT-">()</code> means the <code class="Code-In-Text--PACKT-">groupdict()</code> method of a <code class="Code-In-Text--PACKT-">Match</code> object will have the key <code class="Code-In-Text--PACKT-">dt</code> in the resulting dictionary. As we introduce more processing steps, we'll need to be much more clear about the intermediate results.</p>
    <p class="normal">Here's an image of the regular expression that can sometimes be helpful:</p>
    <figure class="mediaobject"><img src="img/B17070_10_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.3: Log line regular expression diagram</p>
    <p class="normal">Let's expand this example to transform the date-time stamp to another format. This involves injecting a transformation from the input format to the desired output format. We can do this in one big gulp, or we can do it in a series of small sips. </p>
    <p class="normal">This sequence of steps makes it easier to add or change one individual step without breaking the entire pipeline of processing:</p>
    <pre class="programlisting code"><code class="hljs-code">possible_match_iter = (
    pattern.match(line) for line in source)
group_iter = (
    match.groupdict() for match in possible_match_iter if match)
warnings_iter = (
    group for group in group_iter if "WARN" in group["level"])
dt_iter = (
    (
        datetime.datetime.strptime(g["dt"], "%b %d, %Y %H:%M:%S"),
        g["level"],
        g["msg"],
    )
    for g in warnings_iter
)
warnings_filter = (
    (g[0].isoformat(), g[1], g[2]) for g in dt_iter)
</code></pre>
    <p class="normal">We've created two additional stages. One parses the input time to create a Python <code class="Code-In-Text--PACKT-">datetime</code> object; the second stage formats the <code class="Code-In-Text--PACKT-">datetime</code> object as an ISO. Breaking the transformation down into small steps lets us treat each mapping operation and each filtering operating as discrete, separate steps. We can add, change, and delete with a little more flexibility when we create these smaller, easier-to-understand steps. The idea is to isolate each <a id="_idIndexMarker744"/>transformation into a separate object, described by a generator expression.</p>
    <p class="normal">The result of the <code class="Code-In-Text--PACKT-">dt_iter</code> expression is an iterable over anonymous tuples. This is a place where a <code class="Code-In-Text--PACKT-">NamedTuple</code> can add clarity. See <em class="chapterRef">Chapter 7</em>, <em class="italic">Python Data Structures</em>, for more information on <code class="Code-In-Text--PACKT-">NamedTuple</code>.</p>
    <p class="normal">We have an additional way to look at these transformational steps, using the built-in <code class="Code-In-Text--PACKT-">map()</code> and <code class="Code-In-Text--PACKT-">filter()</code> functions. These functions provide features similar to generator expressions, using another, slightly different syntax:</p>
    <pre class="programlisting code"><code class="hljs-code">possible_match_iter = map(pattern.match, source)
good_match_iter = filter(None, possible_match_iter)
group_iter = map(lambda m: m.groupdict(), good_match_iter)
warnings_iter = filter(lambda g: "WARN" in g["level"], group_iter)
dt_iter = map(
    lambda g: (
        datetime.datetime.strptime(g["dt"], "%b %d, %Y %H:%M:%S"),
        g["level"],
        g["msg"],
    ),
    warnings_iter,
)
warnings_filter = map(
    lambda g: (g[0].isoformat(), g[1], g[2]), dt_iter)
</code></pre>
    <p class="normal">The lambda objects are anonymous functions. Each lambda is a callable object with parameters and a single expression that is evaluated and returned. There's no name and no statements in the body of a lambda. Each stage in this pipeline is a discrete mapping or filtering operation. While we can combine mapping and filtering into a single <code class="Code-In-Text--PACKT-">map(lambda ..., filter(lambda ..., source))</code>, this can be too confusing to be helpful.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">possible_match_iter</code> applies the <code class="Code-In-Text--PACKT-">pattern.match()</code> to each line. The <code class="Code-In-Text--PACKT-">good_match_iter</code> uses the special <code class="Code-In-Text--PACKT-">filter(None, source)</code> that passes non-<code class="Code-In-Text--PACKT-">None</code> objects, and rejects <code class="Code-In-Text--PACKT-">None</code> objects. The <code class="Code-In-Text--PACKT-">group_iter</code> uses a lambda to evaluate <code class="Code-In-Text--PACKT-">m.groups()</code> for each object, <code class="Code-In-Text--PACKT-">m</code>, in <code class="Code-In-Text--PACKT-">good_match_iter</code>. The <code class="Code-In-Text--PACKT-">warnings_iter</code> will filter the <code class="Code-In-Text--PACKT-">group_iter</code> results, keeping only the <code class="Code-In-Text--PACKT-">WARN</code> lines, and rejecting all others. The <code class="Code-In-Text--PACKT-">dt_iter</code> and the final <code class="Code-In-Text--PACKT-">warnings_filter</code> expressions perform a conversion from the source datetime format to a generic <code class="Code-In-Text--PACKT-">datetime</code> object, followed by formatting the <code class="Code-In-Text--PACKT-">datetime</code> object in a different string format.</p>
    <p class="normal">We've seen a number<a id="_idIndexMarker745"/> of ways of approaching a complex map-filter problem. We can write nested <code class="Code-In-Text--PACKT-">for</code> and <code class="Code-In-Text--PACKT-">if</code> statements. We can create explicit <code class="Code-In-Text--PACKT-">Iterator</code> subclass definitions. We can create iterator-based objects using function definitions that include the <code class="Code-In-Text--PACKT-">yield</code> statement. This provides us the formal interface of the <code class="Code-In-Text--PACKT-">Iterator</code> class without the lengthy boilerplate required to define <code class="Code-In-Text--PACKT-">__iter__()</code> and <code class="Code-In-Text--PACKT-">__next__()</code> methods. Additionally, we can use generator expressions and even comprehensions to apply the iterator design pattern in a number of common contexts.</p>
    <p class="normal">The iterator pattern is a foundational aspect of Python programming. Every time we work with a collection, we'll be iterating through the items, and we'll be using an iterator. Because iteration is so central, there are a variety of ways of tackling the problem. We can use <code class="Code-In-Text--PACKT-">for</code> statements, generator functions, generator expressions, and we can build our own iterator classes.</p>
    <h1 id="_idParaDest-226" class="title">Case study</h1>
    <p class="normal">Python makes extensive use of iterators and iterable collections. This underlying aspect appears in many places. Each <code class="Code-In-Text--PACKT-">for</code> statement makes implicit use of this. When we use functional programming techniques, such as generator expressions, and the <code class="Code-In-Text--PACKT-">map()</code>, <code class="Code-In-Text--PACKT-">filter()</code>, and <code class="Code-In-Text--PACKT-">reduce()</code> functions, we're exploiting iterators.</p>
    <p class="normal">Python has an <code class="Code-In-Text--PACKT-">itertools</code> module full of additional iterator-based design patterns. This is worthy of study because it provides many examples of common operations that are readily available using built-in constructs.</p>
    <p class="normal">We can apply these concepts in a number of places in our case study:</p>
    <ul>
      <li class="bullet">Partitioning all the original samples into testing and training subsets.</li>
      <li class="bullet">Testing a particular <em class="italic">k</em> and distance hyperparameter set by classifying all the test cases.</li>
      <li class="bullet">The <em class="italic">k</em>-nearest neighbors (<em class="italic">k</em>-NN) algorithm itself and how it locates the <em class="italic">k</em> nearest neighbors from all the training samples.</li>
    </ul>
    <p class="normal">The common aspect of these three processing examples is the "for all" aspect of each one. We'll take a little side-trip into the math behind comprehensions and generator functions. The math isn't terribly complex, but the following section can be thought of as deep background. After this digression, we'll dive into partitioning data into training and testing subsets using the iterator concepts.</p>
    <h2 id="_idParaDest-227" class="title">The Set Builder background</h2>
    <p class="normal">Formally, we can <a id="_idIndexMarker746"/>summarize operations like partitioning, testing, and even locating nearest neighbors with a logic expression. Some developers like the formality of it because it can help describe the processing without forcing a specific Python implementation.</p>
    <p class="normal">Here's the essential rule for partitioning, for example. This involves a "for all" condition that describes the elements of a set of samples, <em class="italic">S</em>:</p>
    <figure class="mediaobject"><img src="img/B17070_10_001.png" alt="" style="height: 2em;"/></figure>
    <p class="normal">In other words, for all <em class="italic">s</em> in the universe of available samples, <em class="italic">S</em>, the value of <em class="italic">s</em> is either in the training set, <em class="italic">R</em>, or the testing set, <em class="italic">E</em>. This summarizes the result of a successful partition of the data. It doesn't describe an algorithm, directly, but having this rule can help us be sure we haven't missed something important. </p>
    <p class="normal">We can also summarize a performance metric for testing. The recall metric has a "for all" implied by the <em class="italic">∑</em> construct:</p>
    <figure class="mediaobject"><img src="img/B17070_10_002.png" alt="" style="height: 4em;"/></figure>
    <p class="normal">The quality score, <em class="italic">q</em>, is the sum for all <em class="italic">e</em> in the testing set, <em class="italic">E</em>, of 1 where the <code class="Code-In-Text--PACKT-">knn()</code> classifier applied to <em class="italic">e</em> matches the species for <em class="italic">e</em>, <code class="Code-In-Text--PACKT-">s(e)</code>, otherwise 0. This can map nicely to a Python generator expression. </p>
    <p class="normal">The <em class="italic">k</em>-NN algorithm involves a bit more complexity in its definition. We can think of it as a partitioning problem. We need to start with a collection of ordered pairs. Each pair is the distance from an <a id="_idIndexMarker747"/>unknown, <em class="italic">u</em>, to a training sample, <em class="italic">r</em>, summarized as <img src="img/B17070_10_003.png" alt="" style="height: 1em;"/>. As we saw in <em class="chapterRef">Chapter 3</em>, there are a number of ways to compute this distance. This has to be done for all training samples, <em class="italic">r,</em> in the universe of training samples, <em class="italic">R</em>:</p>
    <figure class="mediaobject"><img src="img/B17070_10_004.png" alt="" style="height: 2em;"/></figure>
    <p class="normal">Then we need to partition these distances into two subsets, <em class="italic">N</em>, and <em class="italic">F</em> (near and far) such that all distances in <em class="italic">N</em> are less than or equal to all distances in <em class="italic">F</em>:</p>
    <figure class="mediaobject"><img src="img/B17070_10_005.png" alt="" style="height: 2em;"/></figure>
    <p class="normal">We also need to be sure the number of elements in the near set, <em class="italic">N,</em> is equal to the desired number of neighbors, <em class="italic">k</em>. </p>
    <p class="normal">This final formalism exposes an interesting nuance to the computation. What if there are more than <em class="italic">k</em> neighbors with the same distance metric? Should <em class="italic">all</em> of the equidistant training samples be included in voting? Or should we arbitrarily slice exactly <em class="italic">k</em> of the equidistant samples? If we "arbitrarily" slice, what's the exact rule that gets used for choosing among the equidistant training samples? Does the selection rule even matter? These could be significant issues, and they're outside the scope of this book.</p>
    <p class="normal">The example later in the chapter uses the <code class="Code-In-Text--PACKT-">sorted()</code> function, which tends to preserve the original order. Can this lead to a bias to our classifier when confronted with equidistant choices? This, too, may be a significant issue, and it's also outside the scope of this book.</p>
    <p class="normal">Given a little bit of set theory, we can tackle the ideas of partitioning the data, and computing the <em class="italic">k</em> nearest neighbors, making use of the common iterator features. We'll start with the partitioning algorithm's implementation in Python.</p>
    <h2 id="_idParaDest-228" class="title">Multiple partitions</h2>
    <p class="normal">Our goal is to separate testing and training data. There's a tiny bump in the road, however, called <strong class="keyword">deduplication</strong>. The statistical measures of overall quality rely on the training and testing sets<a id="_idIndexMarker748"/> being independent; this means we need to avoid duplicate samples being split between testing and training sets. Before we can create testing and training partitions, we need to find any duplicates. </p>
    <p class="normal">We can't – easily – compare<a id="_idIndexMarker749"/> each sample with all of the other samples. For a large set of samples, this may take a very long time. A pool of ten thousand samples would lead to 100 million checks for duplication. This isn't practical. Instead, we can partition our data into subgroups where the values for all the measured features are <em class="italic">likely</em> to be equal. Then, from those subgroups, we can choose testing and training samples. This lets us avoid comparing every sample with all of the other samples to look for duplicates.</p>
    <p class="normal">If we use Python's internal hash values, we can create buckets containing samples that may have equal values. In Python, if items are equal, they must have the same integer hash value. The inverse is not true: items may coincidentally have the same hash value, but may not actually be equal.</p>
    <p class="normal">Formally, we can say this:</p>
    <figure class="mediaobject"><img src="img/B17070_10_006.png" alt="" style="height: 2em;"/></figure>
    <p class="normal">That is, if two objects in Python, <em class="italic">a</em> and <em class="italic">b</em>, are equal, they must also have the same hash value <img src="img/B17070_10_007.png" alt="" style="height: 1em;"/>. The reverse is not true because equality is more than a simple hash value check; it's possible that <img src="img/B17070_10_008.png" alt="" style="height: 1em;"/>; the hash values may be the same, but the underlying objects aren't actually equal. We call this a "hash collision" of two unequal values.</p>
    <p class="normal">Continuing this thought, the following is a matter of definition for modulo:</p>
    <figure class="mediaobject"><img src="img/B17070_10_009.png" alt="" style="height: 2em;"/></figure>
    <p class="normal">If two values are equal, they are also equal to any modulo of those values. When we want to know if <code class="Code-In-Text--PACKT-">a == b</code>, we can ask if <code class="Code-In-Text--PACKT-">a % 2 == b % 2</code>; if both numbers are odd or both numbers are even, then there's a chance <code class="Code-In-Text--PACKT-">a</code> and <code class="Code-In-Text--PACKT-">b</code> could be equal. If one number is even and the other is odd, there's no way they can be equal.</p>
    <p class="normal">For complex objects, we can<a id="_idIndexMarker750"/> use <code class="Code-In-Text--PACKT-">hash(a) % m == hash(b) % m</code>. If the two hash values, modulo <em class="italic">m</em>, are the same, then the hash values could be the same, and the two objects, <code class="Code-In-Text--PACKT-">a</code> and <code class="Code-In-Text--PACKT-">b</code>, could also be equal. We know it's possible for several objects to have the same hash value, and even more objects to have the same hash value modulo <em class="italic">m</em>. </p>
    <p class="normal">While this doesn't tell us if two items are equal, this technique limits the domain of objects required for exact equality comparison to very small pools of a few items instead of the entire set of all samples. We can avoid duplicates if we avoid splitting up one of these subgroups.</p>
    <p class="normal">Here's a view of seven samples broken into three subgroups based on their hash codes modulo 3. Most of the subgroups have items that are potentially equal, but actually aren't equal. One of the groups has an actual duplicate sample:</p>
    <figure class="mediaobject"><img src="img/B17070_10_04.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.4: Partitioning sample data to locate duplicates</p>
    <p class="normal">To find the duplicate sample, we don't need to compare each sample against the other six. We can look within each subgroup and compare a few samples to see if they happen to be duplicates.</p>
    <p class="normal">The idea behind this <a id="_idIndexMarker751"/>deduplication approach is to separate the entire suite of samples into sixty buckets where the samples have equal hash values, modulo sixty. Samples in the same bucket <em class="italic">could</em> be equal, and as a simple expedient, we can treat them as equal. Samples in separate buckets have different hash values and cannot possibly be equal. </p>
    <p class="normal">We can avoid having duplicate samples in both testing and training by using an entire bucket's set of samples together. That way, the duplicates are either all testing or all training, but never split.</p>
    <p class="normal">Here's a partition function that first creates 60 separate buckets for samples. Then, some fraction of the buckets are allocated for testing, the rest for training. Specifically, 12, 15, or 20 buckets out of 60 are about 20%, 25%, or 33% of the population. Here's an implementation that deduplicates as it partitions into testing and training subsets:</p>
    <pre class="programlisting code"><code class="hljs-code">import itertools
from typing import DefaultDict, Iterator
ModuloDict = DefaultDict[int, List[KnownSample]]
def partition_2(
    samples: Iterable[KnownSample], 
    training_rule: Callable[[int], bool]
) -&gt; tuple[TrainingList, TestingList]:
    rule_multiple = 60
    partitions: ModuloDict = collections.defaultdict(list)
    for s in samples:
        partitions[hash(s) % rule_multiple].append(s)
    training_partitions: list[Iterator[TrainingKnownSample]] = []
    testing_partitions: list[Iterator[TestingKnownSample]] = []
    for i, p in enumerate(partitions.values()):
        if training_rule(i):
            training_partitions.append(
                TrainingKnownSample(s) for s in p)
        else:
            testing_partitions.append(
                TestingKnownSample(s) for s in p)
    training = list(itertools.chain(*training_partitions))
    testing = list(itertools.chain(*testing_partitions))
    return training, testing
</code></pre>
    <p class="normal">There are three<a id="_idIndexMarker752"/> steps in this partitioning:</p>
    <ol>
      <li class="numbered" value="1">We create sixty separate lists of samples that – because the hashes are equal – may have duplicates. We keep these batches together to avoid splitting duplicates so they're in both testing and training subsets.</li>
      <li class="numbered">We build two lists of iterators. Each list has an iterator over a subset of the buckets. The <code class="Code-In-Text--PACKT-">training_rule()</code> function is used to make sure we get 12/60, 15/60, or 20/60 buckets in testing, and the rest in training. Since each of these iterators is lazy, these lists of iterators can be used to accumulate samples.</li>
      <li class="numbered">Finally, we use the <code class="Code-In-Text--PACKT-">itertools.chain</code> to consume values from a sequence of generators. A chain of iterators will consume the items from each of the various individual bucket-level iterators to create the two final partitions of samples.</li>
    </ol>
    <p class="normal">Note that the type hint for <code class="Code-In-Text--PACKT-">ModuloDict</code> defines a subtype of the generic <code class="Code-In-Text--PACKT-">DefaultDict</code>. It provides a key of <code class="Code-In-Text--PACKT-">int</code> and the value will be a <code class="Code-In-Text--PACKT-">list[KnownSample]</code> instances. We've provided this named type to avoid repeating the long definition of the dictionaries we'll be working with.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">itertools.chain()</code> is a pretty clever kind of iterator. It consumes data from other iterators. Here's an example:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; p1 = range(1, 10, 2)
&gt;&gt;&gt; p2 = range(2, 10, 2)
&gt;&gt;&gt; itertools.chain(p1, p2)
&lt;itertools.chain object at ...&gt;
&gt;&gt;&gt; list(itertools.chain(p1, p2))
[1, 3, 5, 7, 9, 2, 4, 6, 8]
</code></pre>
    <p class="normal">We created two <code class="Code-In-Text--PACKT-">range()</code> objects, <code class="Code-In-Text--PACKT-">p1</code>, and <code class="Code-In-Text--PACKT-">p2</code>. A chain object will be an iterator, and we used the <code class="Code-In-Text--PACKT-">list()</code> function to consume all the values.</p>
    <p class="normal">The steps above can <a id="_idIndexMarker753"/>create a large mapping as an intermediate data structure. It also creates sixty generators, but these don't require very much memory. The final two lists contain references to the same <code class="Code-In-Text--PACKT-">Sample</code> objects as the partitioning dictionary. The good news is the mapping is temporary and only exists during this function.</p>
    <p class="normal">This function also depends on a <code class="Code-In-Text--PACKT-">training_rule()</code> function. This function has a type hint of <code class="Code-In-Text--PACKT-">Callable[[int], bool]</code>. Given the index value for a partition (a value from 0 to 59, inclusive), we can assign it to a testing or training partition. </p>
    <p class="normal">We can use different implementations to get to 80%, 75%, or 66% testing data. For example:</p>
    <pre class="programlisting code"><code class="hljs-code">lambda i: i % 4 != 0
</code></pre>
    <p class="normal">The above lambda object will perform a 75% training and 25% testing split.</p>
    <p class="normal">Once we've partitioned the data, we can use iterators for classifying samples as well as testing the quality of our classification process. </p>
    <h2 id="_idParaDest-229" class="title">Testing</h2>
    <p class="normal">The testing<a id="_idIndexMarker754"/> process can also be defined as a higher-order function, a function that accepts a function as a parameter value. We can summarize the testing effort as a map-reduce problem. Given a <code class="Code-In-Text--PACKT-">Hyperparameter</code> with a <em class="italic">k</em> value and a distance algorithm, we<a id="_idIndexMarker755"/> need to use an iterator for the following two steps:</p>
    <ul>
      <li class="bullet">A function classifies all test samples, mapping each test sample to 1 if the classification was correct or 0 for an incorrect classification. This is the map part of map-reduce.</li>
      <li class="bullet">A function computes a summary with the count of correct values from the long sequence of actual classified samples. This is the reduce part of map-reduce.</li>
    </ul>
    <p class="normal">Python provides high-level functions for these map and reduce operations. This allows us to focus on the details of the mapping and ignore the boilerplate part of iterating over the data items.</p>
    <p class="normal">Looking forward to the next section, we'll want to refactor the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class to split the classifier algorithm into a separate, standalone function. We'll make the classifier function a <strong class="keyword">Strategy</strong> that we provide when we create an instance of the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class. Doing this means we can more easily experiment with some alternatives. We'll look at three different ways to approach refactoring a class.</p>
    <p class="normal">Here's one definition that relies on an external classifier function:</p>
    <pre class="programlisting code"><code class="hljs-code">Classifier = Callable[
    [int, DistanceFunc, TrainingList, AnySample], str]
class Hyperparameter(NamedTuple):
    k: int
    distance_function: DistanceFunc
    training_data: TrainingList
    classifier: Classifier
    def classify(self, unknown: AnySample) -&gt; str:
        classifier = self.classifier
        return classifier(
            self.k, self.distance_function,             self.training_data, 
            unknown
        )
    def test(self, testing: TestingList) -&gt; int:
        classifier = self.classifier
        test_results = (
            ClassifiedKnownSample(
                t.sample,
                classifier(
                    self.k, self.distance_function, 
                    self.training_data, t.sample
                ),
            )
            for t in testing
        )
        pass_fail = map(
            lambda t: (
                1 if t.sample.species == t.classification else 0),
            test_results
        )
        return sum(pass_fail)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">test()</code> method uses two mapping operations and a reduce operation. First, we define a generator that will map each testing sample to a <code class="Code-In-Text--PACKT-">ClassifiedKnownSample</code> object. This object has the original sample and the results of the classification.</p>
    <p class="normal">Second, we define a generator that will map each <code class="Code-In-Text--PACKT-">ClassifiedKnownSample</code> object to a 1 (for a test that matched the expected species) or a 0 (for a test that failed). This generator depends on the first generator to provide values.</p>
    <p class="normal">The actual <a id="_idIndexMarker756"/>work is the summation: this consumes values from the second generator. The second generator consumes objects from the first generator. This technique can minimize the volume of data in memory at any one time. It also decomposes a complex algorithm into two separate steps, allowing us to make changes as necessary.</p>
    <p class="normal">There's an optimization available here, also. The value of <code class="Code-In-Text--PACKT-">t.classification</code> in the second generator is <code class="Code-In-Text--PACKT-">self.classify(t.sample.sample)</code>. It's possible to reduce this to a single generator and eliminate creating intermediate <code class="Code-In-Text--PACKT-">ClassifiedKnownSample</code> objects. </p>
    <p class="normal">Here's how the test operation looks. We can build a <code class="Code-In-Text--PACKT-">Hyperparameter</code> instance using a function for distance, <code class="Code-In-Text--PACKT-">manhattan()</code>, and a classifier function, <code class="Code-In-Text--PACKT-">k_nn_1()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">h = Hyperparameter(1, manhattan, training_data, k_nn_1)
h.test(testing_data)
</code></pre>
    <p class="normal">We'll look at the implementations of various classifiers in the next two sections. We'll start with the base definition, <code class="Code-In-Text--PACKT-">k_nn_1()</code>, and then look at one based on the <code class="Code-In-Text--PACKT-">bisect</code> module next.</p>
    <h2 id="_idParaDest-230" class="title">The essential k-NN algorithm </h2>
    <p class="normal">We can summarize<a id="_idIndexMarker757"/> the <em class="italic">k</em>-NN algorithm as having the following steps:</p>
    <ol>
      <li class="numbered" value="1">Create a list of all (distance, training sample) pairs.</li>
      <li class="numbered">Sort these in ascending order.</li>
      <li class="numbered">Pick to the first <em class="italic">k</em>, which will be the <em class="italic">k</em> nearest neighbors.</li>
      <li class="numbered">Chose the mode (the highest frequency) label for the <em class="italic">k</em> nearest neighbors.</li>
    </ol>
    <p class="normal">The implementation would look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">class Measured(NamedTuple):
    distance: float
    sample: TrainingKnownSample
def k_nn_1(
    k: int, dist: DistanceFunc, training_data: TrainingList, 
    unknown: AnySample
) -&gt; str:
    distances = sorted(
        map(
           lambda t: Measured(dist(t, unknown), t), training_data
        )
    )
    k_nearest = distances[:k]
    k_frequencies: Counter[str] = collections.Counter(
        s.sample.sample.species for s in k_nearest
    )
    mode, fq = k_frequencies.most_common(1)[0]
    return mode
</code></pre>
    <p class="normal">While clear, this does accumulate a large number of distance values in the <code class="Code-In-Text--PACKT-">distances</code> list object, when only <em class="italic">k</em> are actually needed. The <code class="Code-In-Text--PACKT-">sorted()</code> function consumes the source generator and creates a (potentially large) list of intermediate values.</p>
    <p class="normal">One of the high-cost parts of this specific <em class="italic">k</em>-NN algorithm is sorting the entire set of training data after the distances have been computed. We summarize the complexity with the description as an <em class="italic">O(n log n)</em> operation. A way to avoid cost is to avoid sorting the entire set of distance computations.</p>
    <p class="normal"><em class="italic">Steps 1</em> to <em class="italic">3</em> can be optimized to keep only the <em class="italic">k</em> smallest distance values. We can do this by using the <code class="Code-In-Text--PACKT-">bisect</code> module to locate the position in a sorted list where a new value can be inserted. If we only keep values that are smaller than the <em class="italic">k</em> values in the list, we can avoid a lengthy sort.</p>
    <h2 id="_idParaDest-231" class="title">k-NN using the bisect module</h2>
    <p class="normal">Here's an alternative implementation<a id="_idIndexMarker758"/> of <em class="italic">k</em>-NN that tries to avoid sorting all of the distance computations:</p>
    <ol>
      <li class="numbered" value="1">For each training sample:<ol>
          <li class="alphabetic-l2">Compute the distance from this training sample to the unknown sample.</li>
          <li class="alphabetic-l2">If it's greater than the last of the <em class="italic">k</em> nearest neighbors seen so far, discard the new distance.</li>
          <li class="alphabetic-l2">Otherwise, find a spot among the <em class="italic">k</em> values; insert the new item; truncate the list to length <em class="italic">k</em>.</li>
        </ol>
      </li>
      <li class="numbered">Find the frequencies of result values among the <em class="italic">k</em> nearest neighbors.</li>
      <li class="numbered">Choose the mode (the highest frequency) among the <em class="italic">k</em> nearest neighbors.</li>
    </ol>
    <p class="normal">If we seed the list of <em class="italic">k</em> nearest neighbors with floating point infinity values, <img src="img/B17070_10_011.png" alt="" style="height: 0.22em;"/> to mathematicians, <code class="Code-In-Text--PACKT-">float("inf") </code>in Python, then the first few computed distances, <em class="italic">d</em>, will be kept because <img src="img/B17070_10_012.png" alt="" style="height: 0.4em;"/>. After the first <em class="italic">k</em> distances have been computed, the remaining distances must be smaller than one of the <em class="italic">k</em> neighbor's distances to be relevant:</p>
    <pre class="programlisting code"><code class="hljs-code">def k_nn_b(
    k: int, dist: DistanceFunc, training_data: TrainingList, 
    unknown: AnySample
) -&gt; str:
    k_nearest = [
        Measured(float("inf"), cast(TrainingKnownSample, None)) 
        for _ in range(k)
    ]
    for t in training_data:
        t_dist = dist(t, unknown)
        if t_dist &gt; k_nearest[-1].distance:
            continue
        new = Measured(t_dist, t)
        k_nearest.insert(bisect.bisect_left(k_nearest, new), new)
        k_nearest.pop(-1)
    k_frequencies: Counter[str] = collections.Counter(
        s.sample.sample.species for s in k_nearest
    )
    mode, fq = k_frequencies.most_common(1)[0]
    return mode
</code></pre>
    <p class="normal">Instead of sorting all distances into a big list, we're inserting (and removing) one distance from a much smaller list. After the first <em class="italic">k</em> distances are computed, this algorithm involves two kinds of state change: a new item is inserted into the <em class="italic">k</em> nearest neighbors, and the most distant of the <em class="italic">k+1</em> neighbors is removed. While this doesn't change the overall <a id="_idIndexMarker759"/>complexity in a dramatic way, these are relatively inexpensive operations when performed on a very small list of only <em class="italic">k</em> items.</p>
    <h2 id="_idParaDest-232" class="title">k-NN using the heapq module</h2>
    <p class="normal">We have yet another <a id="_idIndexMarker760"/>trick up our sleeve. We can use the <code class="Code-In-Text--PACKT-">heapq</code> module to maintain a sorted list of items. This lets us implement the sorting operation as each item is placed into the overall list. This doesn't reduce the general complexity of the processing, but it replaces two inexpensive insert and pop operations with <em class="italic">potentially</em> less expensive insert operations.</p>
    <p class="normal">The idea is to start with an empty list and insert items into the list, ensuring that (a) the items are kept in order, and (b) the item at the head of the list always has the least distance. The heap queue algorithm can maintain an upper bound on the size of the queue. Keeping only <em class="italic">k</em> items should also reduce the volume of data required in memory.</p>
    <p class="normal">We can then pop <em class="italic">k</em> items from the heap to retrieve the nearest neighbors.</p>
    <pre class="programlisting code"><code class="hljs-code">def k_nn_q(
    k: int, dist: DistanceFunc, training_data: TrainingList, 
    unknown: AnySample
) -&gt; str:
    measured_iter = (
        Measured(dist(t, unknown), t) for t in training_data)
    k_nearest = heapq.nsmallest(k, measured_iter)
    k_frequencies: Counter[str] = collections.Counter(
        s.sample.sample.species for s in k_nearest
    )
    mode, fq = k_frequencies.most_common(1)[0]
    return mode
</code></pre>
    <p class="normal">This is elegantly simple. It's not, however, remarkably fast. It turns out that the cost of computing the distances outweighs the cost savings from using a more advanced heap queue to reduce the number of items being sorted.</p>
    <h2 id="_idParaDest-233" class="title">Conclusion</h2>
    <p class="normal">We can compare these distinct <em class="italic">k</em>-NN algorithms by providing a consistent set of training and test data. We'll use a function like the following:</p>
    <pre class="programlisting code"><code class="hljs-code">def test_classifier(
        training_data: List[TrainingKnownSample],
        testing_data: List[TestingKnownSample],
        classifier: Classifier) -&gt; None:
    h = Hyperparameter(
        k=5,
        distance_function=manhattan,
        training_data=training_data,
        classifier=classifier)
    start = time.perf_counter()
    q = h.test(testing_data)
    end = time.perf_counter()
    print(
        f'| {classifier.__name__:10s} '
        f'| q={q:5}/{len(testing_data):5} '
        f'| {end-start:6.3f}s |')
</code></pre>
    <p class="normal">We've created a consistent <code class="Code-In-Text--PACKT-">Hyperparameter</code> instance. Each instance has a common value of <em class="italic">k</em> and a common distance function; they have a distinct classifier algorithm. We can execute the <code class="Code-In-Text--PACKT-">test()</code> method and display the time required.</p>
    <p class="normal">A <code class="Code-In-Text--PACKT-">main()</code> function can use this to examine the various classifiers:</p>
    <pre class="programlisting code"><code class="hljs-code">def main() -&gt; None:
    test, train = a_lot_of_data(5_000)
    print("| algorithm  | test quality  | time    |")
    print("|------------|---------------|---------|")
    test_classifier(test, train, k_nn_1)
    test_classifier(test, train, k_nn_b)
    test_classifier(test, train, k_nn_q)
</code></pre>
    <p class="normal">We've applied each of the classifiers to a consistent set of data. We haven't shown the <code class="Code-In-Text--PACKT-">a_lot_of_data()</code> function. This creates two lists of <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> and <code class="Code-In-Text--PACKT-">TestingKnownSample</code> instances. We've left this as an exercise for the reader.</p>
    <p class="normal">Here are the performance results comparing these alterative <em class="italic">k</em>-NN algorithms:</p>
    <table id="table001-4" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">algorithm</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">test quality</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">time</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">k_nn_1</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">q= 241/ 1000</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">6.553s</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">k_nn_b</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">q= 241/ 1000</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">3.992s</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">k_nn_q</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">q= 241/ 1000</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">5.294s</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">The test quality is the number of correct test cases. The number is low because the data is completely random, and a correct classification rate of about 25% is what's expected if our random data uses four different species names.</p>
    <p class="normal">The original algorithm, <code class="Code-In-Text--PACKT-">k_nn_1</code>, is the slowest, something we suspected. This provides the necessary evidence that optimization of this may be necessary. The <code class="Code-In-Text--PACKT-">bisect</code> based processing, row <code class="Code-In-Text--PACKT-">k_nn_b</code> in the table, suggests that working with a small list outweighs the costs of performing the bisect operation many times. The <code class="Code-In-Text--PACKT-">heapq</code> processing time, row <code class="Code-In-Text--PACKT-">k_nn_h</code>, was better than the original algorithm, but only by about 20%.</p>
    <p class="normal">It's important to do both a theoretical analysis of the algorithm's complexity as well as a benchmark with actual data. Before spending time and effort on performance improvement, we need to start with benchmark analysis to identify where we might be able to do things more efficiently. It's also important to confirm that the processing is correct before trying to optimize performance.</p>
    <p class="normal">In some cases, we'll need detailed analysis of specific functions or even Python operators. The <code class="Code-In-Text--PACKT-">timeit</code> module can be helpful here. We might need to do something like the following:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import timeit
&gt;&gt;&gt; m = timeit.timeit(
...     "manhattan(d1, d2)",
...     """
... from model import Sample, KnownSample, TrainingKnownSample, TestingKnownSample
... from model import manhattan, euclidean
... d1 = TrainingKnownSample(KnownSample(Sample(1, 2, 3, 4), "x"))
... d2 = KnownSample(Sample(2, 3, 4, 5), "y")
... """)
</code></pre>
    <p class="normal">The value computed for <code class="Code-In-Text--PACKT-">m</code> can help us make a concrete comparison between distance computations. The <code class="Code-In-Text--PACKT-">timeit</code> module will execute the given statement, <code class="Code-In-Text--PACKT-">manhattan(d1, d2)</code>, after performing the one-time setup of some imports and creation of sample data.</p>
    <p class="normal">Iterators are both a performance boost and a potential way to clarify the overall design. They can be helpful with our case study because so much of the processing iterates over large collections of data.</p>
    <h1 id="_idParaDest-234" class="title">Recall</h1>
    <p class="normal">This chapter looked at a design pattern that seems ubiquitous in Python, the iterator. The Python iterator concept is a foundation of the language and is used widely. In this chapter we examined a number of aspects:</p>
    <ul>
      <li class="bullet">Design patterns are good ideas we see repeated in software implementations, designs, and architectures. A good design pattern has a name, and a context where it's usable. Because it's only a pattern, not reusable code, the implementation details will vary each time the pattern is followed.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Iterator</code> protocol is one of the most powerful design patterns because it provides a consistent way to work with data collections. We can view strings, tuples, lists, sets, and even files as iterable collections. A mapping contains a number of iterable collections including the keys, the values, and the items (key and value pairs.) </li>
      <li class="bullet">List, set, and dictionary comprehensions are short, pithy summaries of how to create a new collection from an existing collection. They involve a source iterable, an optional filter, and a final expression to define the objects in the new collection.</li>
      <li class="bullet">Generator functions build on other patterns. They let us define iterable objects that have map and filter capabilities.</li>
    </ul>
    <h1 id="_idParaDest-235" class="title">Exercises</h1>
    <p class="normal">If you don't use comprehensions in your daily coding very often, the first thing you should do is search through some existing code and find some <code class="Code-In-Text--PACKT-">for</code> loops. See whether any of them can be trivially converted to a generator expression or a list, set, or dictionary comprehension.</p>
    <p class="normal">Test the claim that list comprehensions are faster than <code class="Code-In-Text--PACKT-">for</code> loops. This can be done with the built-in <code class="Code-In-Text--PACKT-">timeit</code> module. Use the help documentation for the <code class="Code-In-Text--PACKT-">timeit.timeit</code> function to find out how to use it. Basically, write two functions that do the same thing, one using a list comprehension, and one using a <code class="Code-In-Text--PACKT-">for</code> loop to iterate over several thousand items. Pass each function into <code class="Code-In-Text--PACKT-">timeit.timeit</code>, and compare the results. If you're feeling adventurous, compare generators and generator expressions as well. Testing code using <code class="Code-In-Text--PACKT-">timeit</code> can become addictive, so bear in mind that code does not need to be hyperfast unless it's being executed an immense number of times, such as on a huge input list or file.</p>
    <p class="normal">Play around with generator functions. Start with basic iterators that require multiple values (mathematical sequences are canonical examples; the Fibonacci sequence is overused if you can't think of anything better). Try some more advanced generators that do things such as take multiple input lists and somehow yield values that merge them. Generators can also be used on files; can you write a simple generator that shows lines that are identical in two files?</p>
    <p class="normal">Extend the log processing exercise to replace the <code class="Code-In-Text--PACKT-">WARNING</code> filter with a time range filter; all the messages between Jan 26, 2015 11:25:46 and Jan 26, 2015 11:26:15, for example. </p>
    <p class="normal">Once you can find <code class="Code-In-Text--PACKT-">WARNING</code> lines or lines within a specific time, combine the two filters to select only the warnings within the given time. You can use an <code class="Code-In-Text--PACKT-">and</code> condition within a single generator, or combine multiple generators, in effect building an <code class="Code-In-Text--PACKT-">and</code> condition. Which seems more adaptable to changing requirements?</p>
    <p class="normal">When we presented the class <code class="Code-In-Text--PACKT-">WarningReformat(Iterator[Tuple[str, ...]]):</code> example of an iterator, we made a questionable design decision. The <code class="Code-In-Text--PACKT-">__init__()</code> method accepted an open file as an argument value and the <code class="Code-In-Text--PACKT-">__next__()</code> method used <code class="Code-In-Text--PACKT-">readline()</code> on that file. What if we change this slightly and create an explicit iterator object that we use inside another iterator?</p>
    <pre class="programlisting code"><code class="hljs-code">def __init__(self, source: TextIO) -&gt; None:
    self.insequence = iter(source)
</code></pre>
    <p class="normal">If we make this change, then <code class="Code-In-Text--PACKT-">__next__()</code> can use <code class="Code-In-Text--PACKT-">line = next(self.insequence)</code> instead of <code class="Code-In-Text--PACKT-">line = self.insequence.readline()</code>. Switching from <code class="Code-In-Text--PACKT-">object.readline()</code> to <code class="Code-In-Text--PACKT-">next(object)</code> is an interesting generalization. Does it change anything about the <code class="Code-In-Text--PACKT-">extract_and_parse_2()</code> function? Does it permit us to use generator expressions along with the <code class="Code-In-Text--PACKT-">WarningReformat</code> iterator? </p>
    <p class="normal">Take this one further step. Refactor the <code class="Code-In-Text--PACKT-">WarningReformat</code> class into two separate classes, one to filter for <code class="Code-In-Text--PACKT-">WARN</code> and a separate class to parse and reformat each line of the input log. Rewrite the <code class="Code-In-Text--PACKT-">extract_and_parse_2()</code> function using instances of these two classes. Which is "better"? What metric did you use to evaluate "better"?</p>
    <p class="normal">The case study summarized the <em class="italic">k</em>-NN algorithm as a kind of comprehension to compute distance values, sort and pick the <em class="italic">k</em> nearest. The case study didn't talk much about the partitioning algorithm to separate training data from test data. This, too, seems like it might work out as a pair of list comprehensions. There's an interesting problem here, though. We'd like to create two lists, reading the source exactly once. This isn't easily done with list comprehensions. However, look at the <code class="Code-In-Text--PACKT-">itertools</code> module for some possible designs. Specifically, the <code class="Code-In-Text--PACKT-">itertools.tee()</code> function will provide multiple iterables from a single source. </p>
    <p class="normal">Look at the recipes section of the <code class="Code-In-Text--PACKT-">itertools</code> module. How can the <code class="Code-In-Text--PACKT-">itertools.partition()</code> function be used to partition data?</p>
    <h1 id="_idParaDest-236" class="title">Summary</h1>
    <p class="normal">In this chapter, we learned that design patterns are useful abstractions that provide best-practice solutions for common programming problems. We covered our first design pattern, the iterator, as well as numerous ways that Python uses and abuses this pattern for its own nefarious purposes. The original iterator pattern is extremely object-oriented, but it is also rather ugly and verbose to code around. However, Python's built-in syntax abstracts the ugliness away, leaving us with a clean interface to these object-oriented constructs.</p>
    <p class="normal">Comprehensions and generator expressions can combine container construction with iteration in a single line. Generator functions can be constructed using the <code class="Code-In-Text--PACKT-">yield</code> syntax. </p>
    <p class="normal">We'll cover several more design patterns in the next two chapters.</p>
  </div>
</body></html>