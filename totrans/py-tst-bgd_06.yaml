- en: 'Chapter 6. Running Your Tests: Follow Your Nose'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*So far, we''ve talked a lot about how to write tests, but we haven''t said
    much about how to run them. We''ve had to explicitly tell Python which tests to
    run, and we''ve had the either worry about which version of Python we were using
    (in the case of doctest) or put an `if __name__ == ''__main__''` inside every
    module (for unittest). Clearly, there''s room for improvement, when it comes to
    running tests.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about a Python tool called Nose, which automatically finds and executes
    tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to make Nose find and execute doctest tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to make Nose find and execute unittest tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use Nose's internal test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it!
  prefs: []
  type: TYPE_NORMAL
- en: What is Nose?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nose is a tool for finding and running all of your tests, in one easy step.
    It finds tests in multiple files, organizes them, runs them, and presents you
    with a nice report at the end. You don't have to put any special code in your
    files to make the tests runnable and you don't have to worry about which Python
    version you're running, unless your tests make use of recently added features
    to the language. Nose understands doctest and unittest tests; it even adds a few
    features to both.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Nose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of this writing, Nose's home page is [http://code.google.com/p/python-nose/](http://code.google.com/p/python-nose/),
    with downloads available at [http://code.google.com/p/python-nose/downloads/list](http://code.google.com/p/python-nose/downloads/list).
    Go ahead and download the latest version, and uncompress it into a temporary directory.
    If you're using Windows, you'll need a program such as 7-Zip ([http://7-zip.org/](http://7-zip.org/))
    to uncompress the file; Linux and Mac users won't need any special software.
  prefs: []
  type: TYPE_NORMAL
- en: 'After uncompressing Nose, we need to install it. Everything we had to consider
    when installing Mocker applies here too: If you installed Python, you can just
    change to the Nose directory and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you didn''t install Python, but you''re using version 2.6 or higher, you
    can instead type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you go for the `--user` installation, you might need to add a directory
    to the search path of your operating system. You''ll know you need to if you can''t
    run the `nosetests` program after installing it. On Linux or Mac, the directory
    that you need to add is `~/.local/bin`, while on Windows it''s `%APPDATA%\Python\Scripts`.
    Additionally, on Windows you may need to create a file called `nosetests.bat`
    in the `%APPDATA%\Python\Scripts directory`, containing the line: `@python %APPDATA%\Python\Scripts\nosetests.`'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a tool called `easy_install` can simplify the installation process
    of Python modules and packages. If you want to give it a try, download and install
    setuptools from [http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools),
    and then run the command easy_install nose. Once that command is executed, you
    should be ready to use Nose.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing it, you should be able to run `nosetests` by typing its name
    on the command line. If you run it in an empty directory, you should see output
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Nose](img/8846_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Organizing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All right, we've got Nose installed, so what's it good for? Nose looks through
    a directory's structure, finds the test files, sorts out the tests that they contain,
    runs the tests, and reports the results back to you. That's a lot of work that
    it saves you from having to do each time you want to run your tests (which should
    be often).
  prefs: []
  type: TYPE_NORMAL
- en: Nose recognizes test files based on their names. Any file whose name contains
    `test` or `Test` either at the beginning or following any of the characters `_`,
    `.`, or `–` (this is often referred to as "underscore", dot, or dash) is recognized
    as a file that contains unittest `TestCase`s (or Nose's own test functions, which
    we'll talk about later) which should be executed. Any directory whose name matches
    the same pattern is recognized as a directory that might contain tests, and so
    should be searched for test files. Nose can find and execute doctest tests as
    well, either embedded in docstrings or written in separate test files. By default,
    it won't look for doctest tests unless we tell it to. We'll see how to change
    the default shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Nose is so willing to go looking for our tests, we have a lot of freedom
    with respect to how we organize them. It often turns out to be a good idea to
    separate all of the tests into their own directory, or for larger projects into
    a whole tree of directories. A big project can end up having thousands of tests,
    so organizing them for easy navigation is a big benefit. If doctests are being
    used as documentation, as well as testing, it''s probably a good idea to store
    them in yet another separate directory, with a name that communicates that they
    are documentary. For a moderately-sized project, the recommended structure might
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing tests](img/8846_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That structure is only a recommendation (it's for your benefit, not for Nose's).
    If a different structure would make things easier for you, go ahead and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – organizing tests from previous chapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to take our tests from the previous chapters and organize them all
    into a tree of directories. Then we'll use Nose to run them all.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory to hold our code and tests; you can choose any name for it,
    but I'll refer to it as `project` here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put `pid.py`, `operations.py` and `testable.py` inside of `project`. When we
    run `nosetests` in the `project` directory, modules (and packages) stored in `project`
    will be accessible to all of the tests, no matter where the test is stored in
    the directory tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a subdirectory called `test_chapter2`, and place the `test.txt` and `test.py`
    files from Chapter 2 in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a subdirectory called `test_chapter3`, and place the final `pid.txt`
    file from Chapter 3 in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a subdirectory called `test_chapter4`, and place the code from the Chapter
    4 examples (if you have them) and *Time for action* sections in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a subdirectory called `test_chapter5`, and place the code from the Chapter
    5 examples (if you have them) and *Time for action* sections into it. Because
    Chapter 5 uses unittest tests, we also need to rename each of the files so that
    Nose will recognize them as test files. Good names for the files are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that you have the tests all put together and organized, let''s run them.
    To do that, change to the `project` directory and type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can leave off the `-v` if you want. All it does is to tell Nose to give
    a more detailed report of what it's doing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All of the tests should run. We expect to see a few failures, since some of
    the tests from previous chapters were intended to fail, for illustrative purposes.
    There's one failure though, that we need to consider:![Time for action – organizing
    tests from previous chapters](img/8846_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first part of that error report can be safely ignored: it just means that
    the whole doctest file is being treated as a failing test by Nose. The useful
    information comes in the second part of the report. It''s telling us that where
    we expected to get a previous time of 1.0, we''re instead getting a very large
    number (which will be different, and larger, when you run the test for yourself,
    since it happens to represent the time in seconds since a point several decades
    in the past). What''s going on? Didn''t we replace `time.time` for that test with
    a mock? Let''s take a look at the relevant part of `pid.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We mocked `time.time`, but we did it the ad hoc way instead of by using Mocker''s
    `replace` method. This means that modules which did a `from` `time` `import` `time`
    and were imported before the test file is executed will have imported the real
    `time` function, and won''t know about our mock. So, was `pid.py` imported by
    some other thing, before `pid.txt` imported it? As it happens, it was: Nose itself
    imported it when it was scanning for tests to execute. If we''re using Nose, we
    can''t count on our import statements actually being the first to import any given
    module. We can fix the problem easily, though, by using Mocker (Note that we''re
    only looking at the first test in the file here. There is another test that also
    needs to be fixed in the same way):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now when we use nosetests to run the tests again, the only failures are the
    expected ones. Here's the overview that Nose prints because we passed the `-v`
    command line option:![Time for action – organizing tests from previous chapters](img/8846_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We ran all of those tests, with a single command. Pretty good, right? We're
    getting to the point now where testing is becoming broadly useful.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Nose, we don't need those goofy `if` `__name__ == '__main__'` blocks
    at the end of each unittest file, and we don't need to memorize any arcane commands
    to execute the doctest files. We can store our tests in a separate and well-organized
    directory structure, and run them all with a single, quick, and simple command.
    We can also easily run a subset of our tests, by passing the filenames, module
    names, or directories containing the tests that we want to run as command line
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how hidden assumptions can break tests, just as they can break the
    code being tested. Until now, we've been assuming that when one of our tests imports
    a module, that's the first time the module has been imported. Some of our tests
    relied on that assumption to replace library objects with mocks. Now that we're
    dealing with running many tests aggregated together, with no guaranteed order
    of execution, that assumption wasn't reliable. On top of that, the module we had
    trouble with actually had to be imported to search it for tests, before any of
    our tests were run. That would have been a problem, except we already have a tool
    for replacing library objects, regardless of the order of imports. A quick switch
    of the affected tests to use Mocker and we're good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Finding doctests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nosetests` command that we used in the previous section was fairly easy
    to understand, but it was still a bit long to type in all of the time. Instead
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d really like to be able to just type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To execute our tests, and still have it find and execute all of our doctests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it''s a simple matter to tell Nose that we want it to use different
    defaults for the values of those command line switches. To do this, just create
    a configuration file called `nose.cfg` or `.noserc` (either name will work) in
    your home directory, and placing the following inside of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From now on, whenever you run `nosetests`, it will assume those options, unless
    you tell it otherwise. You don't have to type them on the command line any more.
    You can use the same trick for any option that Nose can accept on the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're a Windows user, you might not be sure what the phrase 'home directory'
    is supposed to refer to in this context. As far as Python is concerned, your home
    directory is defined by your environment variables. If `HOME` is defined, that's
    your home directory. Otherwise, if `USERPROFILE` is defined (it usually is, pointing
    at `C:\Documents and Settings\USERNAME`) then that's what is considered to be
    your home directory. Otherwise, the directory described by `HOMEDRIVE` and `HOMEPATH`
    (often `C:\`)is your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Nose's search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've said before that Nose looks for tests in directories and modules whose
    names start with `test` or `Test`, or contain a '`_`','`.`'`,` or '`-`' followed
    by `test` or `Test`. That's the default, but it's not actually the whole story.
  prefs: []
  type: TYPE_NORMAL
- en: If you know regular expressions, you can customize the pattern that Nose uses
    to look for tests. You do this by passing the `--include=REGEX` command line option
    or by putting `include=REGEX` in your `nose.cfg` or `.noserc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Nose will (in addition to looking for names as described above) also look for
    names that start with `doc` or `Doc`. That means you can call the directory containing
    your doctest files `docs`, `Documentation`, `doctests`, and so on, and Nose will
    still find it and run the tests. If you use this option often, you'll almost certainly
    want to add it to your configuration file, as described under the previous heading.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full syntax and use of regular expressions is a subject in itself, and has
    been the topic of many books. However, you can find everything you need, to do
    this sort of thing in the Python documentation at [http://docs.python.org/library/re.html](http://docs.python.org/library/re.html).
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – testing with Nose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By running `nosetests --processes=4`, Nose can be made to launch four testing
    processes, which can provide a big performance gain if you're running the tests
    on a quad-core system. How would you make Nose always launch four testing processes,
    without being told on the command line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If some of your tests were stored in a directory called `specs`, how would you
    tell Nose that it should search that directory for tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following will by default be recognized by Nose as possibly containing
    tests: `UnitTests`, `unit_tests`, `TestFiles`, `test_files`, `doctests`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a go hero – nosing around
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write some `doctest` and `unittest` tests for the following specification, and
    create a directory tree to contain them and the code that they describe. Write
    the code using the test-driven methodology, and use Nose to run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Nose and doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: doesn't just support doctest, it actually enhances it. When you're using Nose,
    you can write test fixtures for your doctest files.
  prefs: []
  type: TYPE_NORMAL
- en: If you pass `--doctest-fixtures=_fixture` on the command line, Nose will go
    looking for a fixture file whenever it finds a doctest file. The name of the fixture
    file is based on the name of the doctest file and is calculated by appending the
    doctest fixture suffix (in other words, the value of `doctest-fixtures`) to the
    main part of the doctest file name, and then adding `.py` to the end. For example,
    if Nose found a doctest file called `pid.txt`, and had been told that `doctest-fixtures=_fixture`,
    it would try to find the test fixture in a file called `pid_fixture.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test fixture file for a doctest is very simple: it''s just a Python module
    that contains a `setup()` or `setUp()` function and a `teardown()` or `tearDown()`
    function. The setup function is executed before the doctest file, and the teardown
    function is executed after.'
  prefs: []
  type: TYPE_NORMAL
- en: The fixture operates in a different namespace to the doctest file, so none of
    the variables that get defined in the fixture module are visible in the actual
    tests. If you want to share variables between the fixture and the test, you'll
    probably want to do it by making a simple little module to hold the variables,
    which you can import into both the fixture and the test.
  prefs: []
  type: TYPE_NORMAL
- en: Mocker replacements work fine when done in a doctest fixture. As long as you
    don't `restore()` them during the setup (and why would you do a silly thing like
    that?) then they'll still be in place when the test uses the replaced object.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a fixture for a doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll provide a mock `time.time()` in our test fixture and use it in our doctest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `times.txt` containing the following doctest code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the doctest file using Nose, and the following screen gets displayed:![Time
    for action – creating a fixture for a doctest](img/8846_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unless your computer''s clock was reset to the beginning of the epoch at just
    the right moment, the doctest failed. We need a mock to replace `time.time()`
    if we want these tests to pass reliably. Create a file called `times_fixture.py`
    and insert the following Python code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now when we run Nose and tell it how to find doctest fixtures, the doctest passes,
    because it's using the mock that we set up in the fixture:![Time for action –
    creating a fixture for a doctest](img/8846_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you use this facility often, it makes sense to add `doctest-fixtures=_fixture`
    to your Nose configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nose and unittest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nose enhances unittest, by providing test fixtures at the package and module
    levels. The package setup function is run before any of the tests in any of the
    modules in a package, while the teardown function is run after all of the tests
    in all of the modules in the package have completed. Similarly, the module setup
    is run before any of the tests in a given module execute, and the module teardown
    is executed after all of the tests in the module have been executed.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a module fixture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll build a test module with a module-level fixture. In the fixture, we'll
    replace the `datetime.date.today` function, which normally returns an object representing
    the current date. We want it to return a specific value, so that our tests can
    know what to expect.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `tests`. We'll use this directory in this *Time for
    action*, as well as in the next one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the `tests` directory, create a file called `module_fixture_tests.py`
    containing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that there are two `TestCase` classes in this module. Using pure unittest,
    we'd have to duplicate the fixture code in each of those classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go ahead and run the tests by moving to the directory that contains the `tests`
    directory and typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Nose will recognize tests as a directory that may contain tests (because of
    the directory name), find the `module_fixtures_tests.py` file, run the `setup`
    function, run all of the tests, and then run the `teardown` function. There won't
    be much to see though, aside from a simple report of how many tests passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saved ourselves some time and effort by using a second 'layer' of test fixtures,
    which wrap around entire test modules instead of single test methods. By doing
    this, we saved ourselves from duplicating the fixture code inside every test class
    in the module, but this savings comes with a cost. The setup and teardown aren't
    run before and after each test, as normal test fixtures are. Instead, all of the
    tests in the module happen between a single module-level setup/teardown pair,
    which means that if a test does something that affects the environment created
    by the setup function, it won't be undone before the next test runs. In other
    words, isolation of tests is not guaranteed with respect to the environment created
    by a module-level fixture.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll expand on the previous *Time for action* by including a package-level
    test fixture. Like the module-level test fixture, this is a labor-saving feature
    of Nose.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a package fixture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we'll create a fixture that wraps around all the test modules in an entire
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file called `__init__.py` in the `tests` directory that we created
    in the last *Time for action* section. (That''s two underbars, the word ''init,
    and two more underbars). The presence of this file tells Python that the directory
    is a package. Place the following code inside of `__init__.py` in the `tests`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It's fairly common that `__init__.py` files are completely empty, but they're
    a perfect place for code that is general to an entire package, so that's where
    Nose looks for a package-level fixture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new file called `package_fixtures_tests.py` to the `tests` directory,
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the already-existing `module_fixtures_tests.py` (We
    could place it in its own file too. The point is placing it in a separate module
    from the tests in step 2, for you to see that the package test fixture is in place):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go ahead an run the tests again. (You won''t see much output, but that means
    everything worked) Go to the directory containing `tests` and run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We worked with yet another layer of test fixture, this time wrapping around
    all of the test modules in the `tests` directory. As you can see from looking
    at the code that we just wrote, the environment created by the package-level test
    fixture is available in every test in every module in the package.
  prefs: []
  type: TYPE_NORMAL
- en: Like module-level test fixtures, package-level test fixtures can be a big labor-saving
    shortcut. However, they don't provide you with the protection against communication
    between tests that *real* test-level fixtures do.
  prefs: []
  type: TYPE_NORMAL
- en: Nose's own testing framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nose supports two new kinds of tests: stand-alone test functions and non-TestCase
    test classes. It finds these tests by using the same pattern matching that it
    uses to find test modules. When looking through a module whose name matches the
    pattern, any functions or classes whose names also match the pattern, are assumed
    to be tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using Nose-specific tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll write a few tests that demonstrate Nose's support for test functions and
    non-TestCase test classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `nose_specific_tests.py` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the following text to the same file, outside of the `grouped_tests`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the tests, although as usual you don''t want to see any output beyond a
    report of how many tests were executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `grouped_tests` class contains a test fixture (the `setup` and `teardown`
    methods) and two tests, but it's not a unittest `TestCase` class. Nose recognized
    it as a test class because its name follows the same pattern that Nose looks for,
    when it checks module names to find test modules. It then looks through the class
    for a test fixture (and any test methods), and runs them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Since the class isn't a `TestCase`, the tests don't have access to any of unittest's
    `assert` methods; Nose considers such a test to pass unless it raises an exception.
    Python has an `assert` statement that raises an exception if its expression is
    false, which is helpful for this sort of thing. It's not as nice as `assertEqual`,
    but it does the job in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote another test in the function `standalone_test`. Like `grouped_tests`,
    `standalone_test` is recognized as a test by Nose because its name matches the
    same pattern that Nose uses to search for test modules. Nose runs `standalone_test`
    as a test, and reports a failure if it raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: We were able to attach a test fixture to `standalone_test`, by setting its `setup`
    and `teardown` attributes to a pair of functions that we defined for that purpose.
    As usual, the setup function gets executed before the test function and the teardown
    function gets run after.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about the Nose testing meta-framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How Nose finds the files that contain tests, and how you can adapt the process
    to fit into your organization scheme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run all of your tests with Nose, whether they are doctest, unittest,
    or nose-specific tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Nose enhances the other frameworks with additional support for test fixtures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Nose's test functions and non-TestCase test classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've learned about Nose and running all of our tests easily, we're
    ready to tackle a complete test-driven project—which is the topic of the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
