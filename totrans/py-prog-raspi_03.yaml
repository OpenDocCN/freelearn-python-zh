- en: Conditional Statements, Functions, and Lists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句、函数和列表
- en: In this chapter, we will build upon what you learned in the previous chapter.
    You will learn about conditional statements and how to make use of logical operators
    to check conditions using conditional statements. Next, you will learn to write
    simple functions in Python and discuss interfacing inputs to the Raspberry Pi's
    GPIO header using a tactile switch (momentary push button). We will also discuss
    motor control (this is a run-up to the final project) using the Raspberry Pi Zero
    and control the motors using the switch inputs. Let's get to it!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于你之前学到的内容进行构建。你将学习关于条件语句以及如何使用逻辑运算符通过条件语句检查条件。接下来，你将学习如何在Python中编写简单的函数，并讨论使用触摸开关（瞬间按键）将输入接口连接到树莓派的GPIO引脚。我们还将讨论使用树莓派Zero进行电机控制（这是最终项目的预热），并通过开关输入控制电机。让我们开始吧！
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Conditional statements in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的条件语句
- en: Using conditional inputs to take actions based on GPIO pin states
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于GPIO引脚状态的GPIO输入进行操作
- en: Breaking out of loops using conditional statement
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件语句跳出循环
- en: Functions in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的函数
- en: GPIO callback functions
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPIO回调函数
- en: Motor control in Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的电机控制
- en: Conditional statements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'In Python, conditional statements are used to determine if a specific condition
    is met by testing whether a condition is `true` or `false`. Conditional statements
    are used to determine how a program is executed. For example, conditional statements
    could be used to determine whether it is time to turn on the lights. The syntax
    is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，条件语句用于通过测试条件是否为`true`或`false`来确定是否满足特定条件。条件语句用于确定程序的执行方式。例如，条件语句可以用来确定是否是时候打开灯光了。语法如下：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The condition is usually tested using a logical operator, and the set of tasks
    under the indented block is executed. Let''s consider the example, `check_address_if_statement.py`
    (available for download with this chapter) where the user input to a program needs
    to be verified using a `yes` or `no` question:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 条件通常使用逻辑运算符进行测试，然后执行缩进块下的任务集。让我们考虑一个例子，`check_address_if_statement.py`（与本章一起提供下载）中，程序需要使用`yes`或`no`问题来验证用户的输入：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the program expects a `yes` or `no` input. If the user provides
    the input `yes`, the condition `if check_address == "yes"` is `true`, the message
    `Your address has been saved` is printed on the screen.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序期望输入`yes`或`no`。如果用户提供了输入`yes`，条件`if check_address == "yes"`为`true`，屏幕上会打印消息`您的地址已保存`。
- en: Likewise, if the user input is `no`, the program executes the indented code
    block under the logical test condition `if check_address == "no"` and deletes
    the variable `address`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果用户输入是`no`，程序将执行逻辑测试条件`if check_address == "no"`下的缩进代码块，并删除变量`address`。
- en: An if-else statement
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if-else语句
- en: 'In the preceding example, we used an `if` statement to test each condition.
    In Python, there is an alternative option named the `if-else` statement. The `if-else`
    statement enables testing an alternative condition if the main condition is not
    `true`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`if`语句测试每个条件。在Python中，有一个名为`if-else`的替代选项。`if-else`语句允许在主条件不为`true`时测试替代条件：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, if the user input is `yes`, the indented code block under `if`
    is executed. Otherwise, the code block under `else` is executed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果用户输入是`yes`，则执行`if`下的缩进代码块。否则，执行`else`下的代码块。
- en: if-elif-else statement
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if-elif-else语句
- en: 'In the preceding example, the program executes any piece of code under the
    `else` block for any user input other than `yes` that is if the user pressed the
    return key without providing any input or provided random characters instead of
    `no`, the `if-elif-else` statement works as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，程序对除了`yes`之外的所有用户输入执行`else`块下的任何代码，也就是说，如果用户按下了回车键而没有提供任何输入，或者提供了除`no`之外的随机字符，`if-elif-else`语句的工作方式如下：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the user input is `yes`, the indented code block under the `if` statement
    is executed. If the user input is `no`, the indented code block under `elif` (*else-if*)
    is executed. If the user input is something else, the program prints the message:
    `Invalid input. Try again`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入是`yes`，则执行`if`语句下的缩进代码块。如果用户输入是`no`，则执行`elif`（*else-if*）语句下的缩进代码块。如果用户输入其他内容，程序将打印消息：`无效输入。请重试`。
- en: It is important to note that the code block indentation determines the block
    of code that needs to be executed when a specific condition is met. We recommend
    modifying the indentation of the conditional statement block and find out what
    happens to the program execution. This will help understand the importance of
    indentation in Python.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，代码块的缩进决定了在满足特定条件时需要执行的代码块。我们建议修改条件语句块的缩进，并找出程序执行会发生什么。这将有助于理解缩进在Python中的重要性。
- en: In the three examples that we discussed so far, it could be noted that an `if`
    statement does not need to be complemented by an `else` statement. The `else`
    and `elif` statements need to have a preceding `if` statement or the program execution
    would result in an error.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止讨论的三个例子中，可以注意到`if`语句不需要由`else`语句补充。`else`和`elif`语句需要有一个前面的`if`语句，否则程序执行将导致错误。
- en: Breaking out of loops
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳出循环
- en: 'Conditional statements can be used to break out of a loop execution (`for`
    loop and `while` loop). When a specific condition is met, an `if` statement can
    be used to break out of a loop:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句可以用来跳出循环执行（`for`循环和`while`循环）。当满足特定条件时，可以使用`if`语句跳出循环：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the `while` loop is executed in an infinite loop.
    The value of `i` is incremented and printed on the screen. The program breaks
    out of the `while` loop when the value of `i` is greater than `100` and the value
    of `i` is printed from 1 to 100.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`while`循环以无限循环的方式执行。`i`的值增加并在屏幕上打印。当`i`的值大于`100`时，程序跳出`while`循环，并将`i`的值从1打印到100。
- en: 'The applications of conditional statements: executing tasks using GPIO'
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句的应用：使用GPIO执行任务
- en: In the previous chapter, we discussed interfacing outputs to the Raspberry Pi's
    GPIO. Let's discuss an example where a simple push button is pressed. A button
    press is detected by reading the GPIO pin state. We are going to make use of conditional
    statements to execute a task based on the GPIO pin state.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了将输出连接到Raspberry Pi的GPIO。现在让我们讨论一个简单的按钮被按下的例子。按钮按下是通过读取GPIO引脚状态来检测的。我们将利用条件语句根据GPIO引脚状态执行任务。
- en: Let us connect a button to the Raspberry Pi's GPIO. All you need to get started
    are a button, pull-up resistor, and a few jumper wires. The figure given later
    shows an illustration on connecting the push button to the Raspberry Pi Zero.
    One of the push button's terminals is connected to the ground pin of the Raspberry
    Pi Zero's GPIO pin.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一个按钮连接到Raspberry Pi的GPIO。开始所需的所有东西只是一个按钮、上拉电阻和一些跳线。后面的图示展示了如何将按钮连接到Raspberry
    Pi Zero。按钮的一个端子连接到Raspberry Pi Zero GPIO引脚的地线。
- en: 'The schematic of the button''s interface is shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮接口的原理图如下所示：
- en: '![](img/image_03_001.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_001.png)'
- en: Raspberry Pi GPIO schematic
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi GPIO原理图
- en: The other terminal of the push button is pulled up to 3.3V using a 10 K resistor.
    The junction of the push button terminal and the 10 K resistor is connected to
    the GPIO pin 2 (refer to the BCM GPIO pin map shared in the earlier chapter).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的另一端通过一个10 K欧姆电阻拉到3.3V。按钮端子和10 K欧姆电阻的连接点连接到GPIO引脚2（参考前面章节中共享的BCM GPIO引脚图）。
- en: '![](img/image_03_002.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_002.png)'
- en: Interfacing the push button to the Raspberry Pi Zero's GPIO - an image generated
    using Fritzing
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将按钮连接到Raspberry Pi Zero的GPIO - 使用Fritzing生成的图像
- en: Let's review the code required to review the button state. We make use of loops
    and conditional statements to read the button inputs using the Raspberry Pi Zero.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下检查按钮状态的代码。我们使用循环和条件语句通过Raspberry Pi Zero读取按钮输入。
- en: We will be making use of the `gpiozero` library introduced in the previous chapter.
    The code sample for this section is `GPIO_button_test.py` and available for download
    along with this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前面章节中介绍的`gpiozero`库。本节的代码示例为`GPIO_button_test.py`，与本章一起提供下载。
- en: In a later chapter, we will discuss **object-oriented programming** (**OOP**).
    For now, let's briefly discuss the concept of classes for this example. A **class**
    in Python is a blueprint that contains all the attributes that define an object.
    For example, the `Button` class of the `gpiozero` library contains all attributes
    required to interface a button to the Raspberry Pi Zero's GPIO interface. These
    attributes include button states and functions required to check the button states
    and so on. In order to interface a button and read its states, we need to make
    use of this blueprint. The process of creating a copy of this blueprint is called
    instantiation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将讨论**面向对象编程**（**OOP**）。现在，让我们简要地讨论一下这个例子中的类概念。Python中的**类**是一个包含定义对象的全部属性的蓝图。例如，`gpiozero`库中的`Button`类包含了将按钮连接到Raspberry
    Pi Zero的GPIO接口所需的所有属性。这些属性包括按钮状态和检查按钮状态的函数等。为了将按钮连接并读取其状态，我们需要使用这个蓝图。创建这个蓝图副本的过程称为实例化。
- en: 'Let''s get started with importing the `gpiozero` library and instantiate the
    `Button` class of the `gpiozero` library (we will discuss Python''s classes, objects,
    and their attributes in a later chapter). The button is interfaced to GPIO pin
    2\. We need to pass the pin number as an argument during instantiation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入`gpiozero`库并实例化`gpiozero`库中的`Button`类开始（我们将在后面的章节中讨论Python的类、对象及其属性）。按钮连接到GPIO引脚2。在实例化时，我们需要将引脚号作为参数传递：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `gpiozero` library''s documentation is available at [http://gpiozero.readthedocs.io/en/v1.2.0/api_input.html](http://gpiozero.readthedocs.io/en/v1.2.0/api_input.html). According
    to the documentation, there is a variable named `is_pressed` in the `Button` class
    that could be tested using a conditional statement to determine if the button
    is pressed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiozero`库的文档可以在[http://gpiozero.readthedocs.io/en/v1.2.0/api_input.html](http://gpiozero.readthedocs.io/en/v1.2.0/api_input.html)找到。根据文档，`Button`类中有一个名为`is_pressed`的变量，可以通过条件语句来测试按钮是否被按下：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Whenever the button is pressed, the message `Button pressed` is printed on
    the screen. Let''s stick this code snippet inside an infinite loop:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每当按钮被按下时，屏幕上会打印出`Button pressed`消息。让我们将这个代码片段放在一个无限循环中：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In an infinite `while` loop, the program constantly checks for a button press
    and prints the message as long as the button is being pressed. Once the button
    is released, it goes back to checking whether the button is pressed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个无限`while`循环中，程序会不断检查按钮是否被按下，只要按钮被按下，就会打印消息。一旦按钮被释放，程序会回到检查按钮是否被按下的状态。
- en: Breaking out a loop by counting button presses
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过计数按钮按下次数来跳出循环
- en: 'Let''s review another example where we would like to count the number of button
    presses and break out of the infinite loop when the button has received a predetermined
    number of presses:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾另一个例子，其中我们想要计数按钮按下次数，并在按钮接收到预定的按下次数后跳出无限循环：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding example is available for downloading along with this chapter as
    `GPIO_button_loop_break.py`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可以作为本章的附件下载，文件名为`GPIO_button_loop_break.py`。
- en: In this example, the program checks for the state of the `is_pressed` variable.
    On receiving a button press, the program can be paused until the button is released
    using the `wait_for_release` method. When the button is released, the variable
    used to store the number of presses is incremented by one.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序会检查`is_pressed`变量的状态。当接收到按钮按下信号时，程序可以通过使用`wait_for_release`方法暂停，直到按钮释放。当按钮释放时，用于存储按下次数的变量会增加1。
- en: The program breaks out of the infinite loop, when the button has received 10
    presses.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮接收到10次按下时，程序会跳出无限循环。
- en: '![](img/image_03_003.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_03_003.png)'
- en: A red momentary push button interfaced to Raspberry Pi Zero GPIO pin 2
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个红色瞬态按钮连接到Raspberry Pi Zero的GPIO引脚2
- en: Functions in Python
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的函数
- en: We briefly discussed functions in Python. Functions execute a predefined set
    of task. `print` is one example of a function in Python. It enables printing something
    to the screen. Let's discuss writing our own functions in Python.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地讨论了Python中的函数。函数执行一组预定义的任务。`print`是Python中函数的一个例子。它允许将某些内容打印到屏幕上。让我们讨论如何在Python中编写自己的函数。
- en: 'A function can be declared in Python using the `def` keyword. A function could
    be defined as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`def`关键字在Python中声明一个函数。一个函数可以这样定义：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this function `my_func`, the `print` statement is written under an indented
    code block. Any block of code that is indented under the function definition is
    executed when the function is called during the code execution. The function could
    be executed as `my_func()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`my_func`函数中，`print`语句是在缩进的代码块下编写的。任何在函数定义下缩进的代码块在代码执行期间函数被调用时都会执行。函数可以按`my_func()`执行。
- en: 'Passing arguments to a function:'
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向函数传递参数：
- en: A function is always defined with parentheses. The parentheses are used to pass
    any requisite arguments to a function. Arguments are parameters required to execute
    a function. In the earlier example, there are no arguments passed to the function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 函数总是用括号定义的。括号用于向函数传递任何必需的参数。参数是执行函数所需的参数。在先前的示例中，没有向函数传递任何参数。
- en: 'Let''s review an example where we pass an argument to a function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个向函数传递参数的示例：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, `a` and `b` are arguments to the function. The function adds
    `a` and `b` and prints the sum on the screen. When the function `add_function`
    is called by passing the arguments `3` and `2` as `add_function(3,2)` where `a` is
    `3` and `b` is `2`, respectively.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`a`和`b`是函数的参数。该函数将`a`和`b`相加，并在屏幕上打印总和。当通过传递参数`3`和`2`调用函数`add_function`（即`add_function(3,2)`，其中`a`为`3`，`b`为`2`）时。
- en: 'Hence, the arguments `a` and `b` are required to execute function, or calling
    the function without the arguments would result in an error. Errors related to
    missing arguments could be avoided by setting default values to the arguments:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要`a`和`b`这两个参数来执行函数，或者在没有参数的情况下调用函数会导致错误。可以通过为参数设置默认值来避免与缺少参数相关的错误：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding function expects two arguments. If we pass only one argument to
    this function, the other defaults to zero. For example, `add_function(a=3)`, `b`
    defaults to `0`, or `add_function(b=2)`, `a` defaults to `0`. When an argument
    is not furnished while calling a function, it defaults to zero (declared in the
    function).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数期望两个参数。如果我们只向这个函数传递一个参数，则另一个参数默认为`0`。例如，`add_function(a=3)`，`b`默认为`0`，或者`add_function(b=2)`，`a`默认为`0`。当在调用函数时没有提供参数，它默认为`0`（在函数中声明）。
- en: Similarly, the `print` function prints any variable passed as an argument. If
    the `print` function is called without any arguments, a blank line is printed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`print`函数可以打印任何作为参数传递的变量。如果没有参数传递给`print`函数，则打印一个空行。
- en: Returning values from a function
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从函数返回值
- en: 'Functions can perform a set of defined operations and finally return a value
    at the end. Let''s consider the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以执行一系列定义的操作，并在最后返回一个值。让我们考虑以下示例：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the function returns a square of the argument. In Python, the
    `return` keyword is used to return a value requested upon completion of execution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，函数返回参数的平方。在Python中，使用`return`关键字在执行完成后返回请求的值。
- en: The scope of variables in a function
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数中变量的作用域
- en: 'There are two types of variables in a Python program: local and global variables.
    **Local variables** are local to a function, that is, it is a variable declared
    within a function is accessible within that function. The example is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序中有两种类型的变量：局部变量和全局变量。**局部变量**是函数内的局部变量，即在一个函数内声明的变量只在该函数内可访问。以下是一个示例：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, the variables `a` and `b` are local to the function `add_function`.
    Let''s consider an example of a **global variable**:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，变量`a`和`b`是函数`add_function`的局部变量。让我们考虑一个**全局变量**的示例：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, the variables `a` and `b` are declared in the main body of the
    Python script. They are accessible across the entire program. Now, let''s consider
    this example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，变量`a`和`b`是在Python脚本的主体中声明的。它们在整个程序中都是可访问的。现在，让我们考虑以下示例：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The program output is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出如下：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this case, when `my_function` is called, the value of `a` is `5` and the
    value of `a` is `3` in the `print` statement of the main body of the script. In
    Python, it is not possible to explicitly modify the value of global variables
    inside functions. In order to modify the value of a global variable, we need to
    make use of the `global` keyword:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当调用`my_function`时，`a`的值为`5`，而在脚本的主体`print`语句中`a`的值为`3`。在Python中，无法在函数内部显式修改全局变量的值。为了修改全局变量的值，我们需要使用`global`关键字：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In general, it is not recommended to modify variables inside functions as it
    is not a very safe practice of modifying variables. The best practice would be
    passing variables as arguments and returning the modified value. Consider the
    following example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不建议在函数内部修改变量，因为这并不是一个安全的变量修改实践。最佳实践是将变量作为参数传递，并返回修改后的值。考虑以下示例：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding program, the value of `a` is `3`. It is passed as an argument
    to `my_function`. The function returns `5`, which is saved to `a`. We were able
    to safely modify the value of `a`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`a` 的值为 `3`。它被用作 `my_function` 的参数。函数返回 `5`，并将其保存到 `a` 中。我们能够安全地修改 `a`
    的值。
- en: GPIO callback functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPIO 回调函数
- en: 'Let''s review some uses of functions with the GPIO example. Functions can be
    used in order to handle specific events related to the GPIO pins of the Raspberry
    Pi. For example, the `gpiozero` library provides the capability of calling a function
    either when a button is pressed or released:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下使用 GPIO 示例中函数的一些用法。函数可以用来处理与 Raspberry Pi 的 GPIO 引脚相关的特定事件。例如，`gpiozero`
    库提供了在按钮被按下或释放时调用函数的能力：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we make use of the attributes `when_pressed` and `when_released`
    of the library's GPIO class. When the button is pressed, the function `button_pressed`
    is executed. Likewise, when the button is released, the function `button_released`
    is executed. We make use of the `while` loop to avoid exiting the program and
    keep listening for button events. The `pass` keyword is used to avoid an error
    and nothing happens when a `pass` keyword is executed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用了库的 GPIO 类的 `when_pressed` 和 `when_released` 属性。当按钮被按下时，执行 `button_pressed`
    函数。同样，当按钮被释放时，执行 `button_released` 函数。我们使用 `while` 循环来避免程序退出并持续监听按钮事件。`pass` 关键字用于避免错误，当执行
    `pass` 关键字时，不会发生任何事情。
- en: This capability of being able to execute different functions for different events
    is useful in applications like *home automation*. For example, it could be used
    to turn on lights when it is dark and vice versa.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 能够针对不同事件执行不同函数的能力在诸如*智能家居*等应用中非常有用。例如，它可以用来自动开关灯，当光线暗淡时打开，反之亦然。
- en: DC motor control in Python
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 中的直流电机控制
- en: In this section, we will discuss motor control using the Raspberry Pi Zero.
    Why discuss motor control? As we progress through different topics in this book,
    we will culminate in building a mobile robot. Hence, we need to discuss writing
    code in Python to control a motor using a Raspberry Pi.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论使用 Raspberry Pi Zero 进行电机控制。为什么要讨论电机控制？随着我们在本书中探讨不同主题的进展，我们将最终构建一个移动机器人。因此，我们需要讨论使用
    Raspberry Pi 编写代码来控制电机。
- en: 'In order to control a motor, we need an **H-bridge motor driver** (Discussing
    H-bridge is beyond our scope. There are several resources for H-bridge motor drivers:
    [http://www.mcmanis.com/chuck/robotics/tutorial/h-bridge/](http://www.mcmanis.com/chuck/robotics/tutorial/h-bridge/)).
    There are several motor driver kits designed for the Raspberry Pi. In this section,
    we will make use of the following kit: [https://www.pololu.com/product/2753](https://www.pololu.com/product/2753).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制电机，我们需要一个**H-bridge 电机驱动器**（讨论 H-bridge 超出了我们的范围。有关 H-bridge 电机驱动器的资源有：[http://www.mcmanis.com/chuck/robotics/tutorial/h-bridge/](http://www.mcmanis.com/chuck/robotics/tutorial/h-bridge/)）。为
    Raspberry Pi 设计了几个电机驱动器套件。在本节中，我们将使用以下套件：[https://www.pololu.com/product/2753](https://www.pololu.com/product/2753)。
- en: 'The **Pololu** product page also provides instructions on how to connect the
    motor. Let''s get to writing some Python code to operate the motor:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pololu** 产品页面还提供了如何连接电机的说明。让我们开始编写一些 Python 代码来操作电机：'
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/image_03_004.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_004.png)'
- en: Raspberry Pi based motor control
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Raspberry Pi 的电机控制
- en: In order to control the motor, let's declare the pins, the motor's speed pins
    and direction pins. As per the motor driver's documentation, the motors are controlled
    by GPIO pins 12, 13 and 5, 6, respectively.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制电机，让我们声明引脚、电机速度引脚和方向引脚。根据电机驱动器的文档，电机由 GPIO 引脚 12、13 和 5、6 分别控制。
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Controlling the motor is as simple as turning on the motor using the `on()`
    method and moving the motor in the forward direction using the `forward()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 控制电机就像使用 `on()` 方法打开电机，并使用 `forward()` 方法将电机向前移动一样简单：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, reversing the motor direction could be done by calling the `reverse()` method.
    Stopping the motor could be done by:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以通过调用 `reverse()` 方法来反转电机的方向。停止电机可以通过以下方式完成：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Some mini-project challenges for the reader
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为读者提供的几个迷你项目挑战
- en: 'Here are some of mini-project challenged for our readers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些为读者准备的迷你项目挑战：
- en: In this chapter, we discussed interfacing inputs for the Raspberry Pi and controlling
    motors. Think about a project where we could drive a mobile robot that reads inputs
    from whisker switches and operate a mobile robot. Is it possible to build a wall
    following robot in combination with the limit switches and motors?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Raspberry Pi的输入接口和电机控制。考虑一个项目，我们可以驱动一个读取触须开关输入并操作移动机器人的移动机器人。结合限位开关和电机，能否构建一个跟随墙壁的机器人？
- en: We discussed controlling a DC motor in this chapter. How do we control a stepper
    motor using a Raspberry Pi?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章我们讨论了直流电机的控制。我们如何使用Raspberry Pi控制步进电机？
- en: How can we interface a motion sensor to control the lights at home using a Raspberry
    Pi Zero?
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用Raspberry Pi Zero将运动传感器连接到家中控制灯光？
- en: Read on to find out!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读以了解更多！
- en: Interested in playing tricks on your friends with your Raspberry Pi Zero? Check
    this book's website!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 想要在你的朋友面前玩些小把戏吗？用你的Raspberry Pi Zero？查看这本书的网站！
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed conditional statements and the applications of
    conditional statements in Python. We also discussed functions in Python, passing
    arguments to a function, returning values from a function and scope of variables
    in a Python program. We discussed callback functions and motor control in Python.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们讨论了条件语句及其在Python中的应用。我们还讨论了Python中的函数，包括向函数传递参数、从函数返回值以及在Python程序中变量的作用域。我们还讨论了回调函数和Python中的电机控制。
