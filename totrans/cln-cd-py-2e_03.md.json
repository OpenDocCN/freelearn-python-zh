["```py\n>>> configuration = {\"dbport\": 5432}\n>>> configuration.get(\"dbhost\", \"localhost\")\n'localhost'\n>>> configuration.get(\"dbport\")\n5432 \n```", "```py\n>>> import os\n>>> os.getenv(\"DBHOST\")\n'localhost'\n>>> os.getenv(\"DPORT\", 5432)\n5432 \n```", "```py\n>>> def connect_database(host=\"localhost\", port=5432):\n...     logger.info(\"connecting to database server at %s:%i\", host, port) \n```", "```py\nclass DataTransport:\n    \"\"\"An example of an object handling exceptions of different levels.\"\"\"\n    _RETRY_BACKOFF: int = 5\n    _RETRY_TIMES: int = 3\n    def __init__(self, connector: Connector) -> None:\n        self._connector = connector\n        self.connection = None\n    def deliver_event(self, event: Event):\n        try:\n            self.connect()\n            data = event.decode()\n            self.send(data)\n        except ConnectionError as e:\n            logger.info(\"connection error detected: %s\", e)\n            raise\n        except ValueError as e:\n            logger.error(\"%r contains incorrect data: %s\", event, e)\n            raise\n    def connect(self):\n        for _ in range(self._RETRY_TIMES):\n            try:\n                self.connection = self._connector.connect()\n            except ConnectionError as e:\n                logger.info(\n                    \"%s: attempting new connection in %is\", e, self._RETRY_BACKOFF,\n                )\n                time.sleep(self._RETRY_BACKOFF)\n            else:\n                return self.connection\n        raise ConnectionError(f\"Couldn't connect after {self._RETRY_TIMES} times\")\n    def send(self, data: bytes):\n        return self.connection.send(data) \n```", "```py\ndef connect_with_retry(connector: Connector, retry_n_times: int, retry_backoff: int = 5):\n    \"\"\"Tries to establish the connection of <connector> retrying\n    <retry_n_times>, and waiting <retry_backoff> seconds between attempts.\n    If it can connect, returns the connection object.\n    If it's not possible to connect after the retries have been exhausted, raises ``ConnectionError``.\n    :param connector:         An object with a ``.connect()`` method.\n    :param retry_n_times int: The number of times to try to call\n                              ``connector.connect()``.\n    :param retry_backoff int: The time lapse between retry calls.\n    \"\"\"\n    for _ in range(retry_n_times):\n        try:\n            return connector.connect()\n        except ConnectionError as e:\n            logger.info(\"%s: attempting new connection in %is\", e, retry_backoff)\n            time.sleep(retry_backoff)\n    exc = ConnectionError(f\"Couldn't connect after {retry_n_times} times\")\n    logger.exception(exc)\n    raise exc \n```", "```py\nclass DataTransport:\n    \"\"\"An example of an object that separates the exception handling by\n    abstraction levels.\n    \"\"\"\n    _RETRY_BACKOFF: int = 5\n    _RETRY_TIMES: int = 3\n    def __init__(self, connector: Connector) -> None:\n        self._connector = connector\n        self.connection = None\n    def deliver_event(self, event: Event):\n        self.connection = connect_with_retry(self._connector, self._RETRY_TIMES, self._RETRY_BACKOFF)\n        self.send(event)\n    def send(self, event: Event):\n        try:\n            return self.connection.send(event.decode())\n        except ValueError as e:\n            logger.error(\"%r contains incorrect data: %s\", event, e)\n            raise \n```", "```py\ntry:\n    process_data()\nexcept:\n    pass \n```", "```py\nimport contextlib\nwith contextlib.suppress(KeyError):\n    process_data() \n```", "```py\nclass InternalDataError(Exception):\n    \"\"\"An exception with the data of our domain problem.\"\"\"\ndef process(data_dictionary, record_id):\n    try:\n        return data_dictionary[record_id]\n    except KeyError as e:\n        raise InternalDataError(\"Record not present\") from e \n```", "```py\ntry:\n    assert condition.holds(), \"Condition is not satisfied\"\nexcept AssertionError:\n    alternative_procedure() \n```", "```py\nresult = condition.holds()\nassert result > 0, f\"Error with {result}\" \n```", "```py\ndef process_students_list(students):\n    # do some processing...\n    students_ranking = sorted(\n        students, key=lambda s: s.passed * 11 - s.failed * 5 - s.years * 2\n    )\n    # more processing\n    for student in students_ranking:\n        print(\n            \"Name: {0}, Score: {1}\".format(\n                student.name,\n                (student.passed * 11 - student.failed * 5 - student.years * 2),\n            )\n        ) \n```", "```py\ndef score_for_student(student):\n    return student.passed * 11 - student.failed * 5 - student.years * 2\ndef process_students_list(students):\n    # do some processing...\n    students_ranking = sorted(students, key=score_for_student)\n    # more processing\n    for student in students_ranking:\n        print(\n            \"Name: {0}, Score: {1}\".format(\n                student.name, score_for_student(student)\n            )\n        ) \n```", "```py\nclass ComplicatedNamespace:\n    \"\"\"A convoluted example of initializing an object with some properties.\"\"\"\n    ACCEPTED_VALUES = (\"id_\", \"user\", \"location\")\n    @classmethod\n    def init_with_data(cls, **data):\n        instance = cls()\n        for key, value in data.items():\n            if key in cls.ACCEPTED_VALUES:\n                setattr(instance, key, value)\n        return instance \n```", "```py\n>>> cn = ComplicatedNamespace.init_with_data(\n...     id_=42, user=\"root\", location=\"127.0.0.1\", extra=\"excluded\"\n... )\n>>> cn.id_, cn.user, cn.location\n(42, 'root', '127.0.0.1')\n>>> hasattr(cn, \"extra\")\nFalse \n```", "```py\nclass Namespace:\n    \"\"\"Create an object from keyword arguments.\"\"\"\n\n    ACCEPTED_VALUES = (\"id_\", \"user\", \"location\")\n\n    def __init__(self, **data):\n        for attr_name, attr_value in data.items():\n            if attr_name in self.ACCEPTED_VALUES:\n                setattr(self, attr_name, attr_value) \n```", "```py\nif os.path.exists(filename):\n    with open(filename) as f:\n        ... \n```", "```py\ntry:\n    with open(filename) as f:\n        ...\nexcept FileNotFoundError as e:\n    logger.error(e) \n```", "```py\nclass TransactionalPolicy(collections.UserDict):\n    \"\"\"Example of an incorrect use of inheritance.\"\"\"\n    def change_in_policy(self, customer_id, **new_policy_data):\n        self[customer_id].update(**new_policy_data) \n```", "```py\n>>> policy = TransactionalPolicy({\n...     \"client001\": { \n...         \"fee\": 1000.0, \n...         \"expiration_date\": datetime(2020, 1, 3), \n...     } \n... }) \n>>> policy[\"client001\"]\n{'fee': 1000.0, 'expiration_date': datetime.datetime(2020, 1, 3, 0, 0)}\n>>> policy.change_in_policy(\"client001\", expiration_date=datetime(2020, 1, 4))\n>>> policy[\"client001\"]\n{'fee': 1000.0, 'expiration_date': datetime.datetime(2020, 1, 4, 0, 0)} \n```", "```py\n>>> dir(policy)\n[ # all magic and special method have been omitted for brevity...\n 'change_in_policy', 'clear', 'copy', 'data', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'] \n```", "```py\nclass TransactionalPolicy:\n    \"\"\"Example refactored to use composition.\"\"\"\n    def __init__(self, policy_data, **extra_data):\n        self._data = {**policy_data, **extra_data}\n    def change_in_policy(self, customer_id, **new_policy_data):\n        self._data[customer_id].update(**new_policy_data)\n    def __getitem__(self, customer_id):\n        return self._data[customer_id]\n    def __len__(self):\n        return len(self._data) \n```", "```py\nclass BaseModule:\n    module_name = \"top\"\n    def __init__(self, module_name):\n        self.name = module_name\n    def __str__(self):\n        return f\"{self.module_name}:{self.name}\"\nclass BaseModule1(BaseModule):\n    module_name = \"module-1\"\nclass BaseModule2(BaseModule):\n    module_name = \"module-2\"\nclass BaseModule3(BaseModule):\n    module_name = \"module-3\"\nclass ConcreteModuleA12(BaseModule1, BaseModule2):\n    \"\"\"Extend 1 & 2\"\"\"\nclass ConcreteModuleB23(BaseModule2, BaseModule3):\n    \"\"\"Extend 2 & 3\"\"\" \n```", "```py\n>>> str(ConcreteModuleA12(\"test\"))\n'module-1:test' \n```", "```py\n>>> [cls.__name__ for cls in ConcreteModuleA12.mro()]\n['ConcreteModuleA', 'BaseModule1', 'BaseModule2', 'BaseModule', 'object'] \n```", "```py\nclass BaseTokenizer:\n    def __init__(self, str_token):\n        self.str_token = str_token\n    def __iter__(self):\n        yield from self.str_token.split(\"-\") \n```", "```py\n>>> tk = BaseTokenizer(\"28a2320b-fd3f-4627-9792-a2b38e3c46b0\")\n>>> list(tk)\n['28a2320b', 'fd3f', '4627', '9792', 'a2b38e3c46b0'] \n```", "```py\nclass UpperIterableMixin:\n    def __iter__(self):\n        return map(str.upper, super().__iter__())\nclass Tokenizer(UpperIterableMixin, BaseTokenizer):\n    pass \n```", "```py\n>>> def function(argument):\n...     argument += \" in function\"\n...     print(argument)\n... \n>>> immutable = \"hello\"\n>>> function(immutable)\nhello in function\n>>> mutable = list(\"hello\")\n>>> immutable\n'hello'\n>>> function(mutable)\n['h', 'e', 'l', 'l', 'o', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n']\n>>> mutable\n['h', 'e', 'l', 'l', 'o', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n']\n>>> \n```", "```py\n>>> a = list(range(5))\n>>> b = a  # the function call is doing something like this\n>>> b.append(99)\n>>> b\n[0, 1, 2, 3, 4, 99]\n>>> a\n[0, 1, 2, 3, 4, 99] \n```", "```py\n>>> def f(first, second, third):\n...     print(first)\n...     print(second)\n...     print(third)\n... \n>>> l = [1, 2, 3]\n>>> f(*l)\n1\n2\n3 \n```", "```py\n>>> a, b, c = [1, 2, 3]\n>>> a\n1\n>>> b\n2\n>>> c\n3 \n```", "```py\n>>> def show(e, rest):\n...     print(\"Element: {0} - Rest: {1}\".format(e, rest))\n... \n>>> first, *rest = [1, 2, 3, 4, 5]\n>>> show(first, rest)\nElement: 1 - Rest: [2, 3, 4, 5]\n>>> *rest, last = range(6)\n>>> show(last, rest)\nElement: 5 - Rest: [0, 1, 2, 3, 4]\n>>> first, *middle, last = range(6)\n>>> first\n0\n>>> middle\n[1, 2, 3, 4]\n>>> last\n5\n>>> first, last, *empty = 1, 2\n>>> first\n1\n>>> last\n2\n>>> empty\n[] \n```", "```py\nfrom dataclasses import dataclass\n\nUSERS = [\n    (i, f\"first_name_{i}\", f\"last_name_{i}\")\n    for i in range(1_000)\n]\n\n@dataclass\nclass User:\n    user_id: int\n    first_name: str\n    last_name: str\ndef bad_users_from_rows(dbrows) -> list:\n    \"\"\"A bad case (non-pythonic) of creating ``User``s from DB rows.\"\"\"\n    return [User(row[0], row[1], row[2]) for row in dbrows]\ndef users_from_rows(dbrows) -> list:\n    \"\"\"Create ``User``s from DB rows.\"\"\"\n    return [\n        User(user_id, first_name, last_name)\n        for (user_id, first_name, last_name) in dbrows\n    ] \n```", "```py\n[User(*row) for row in dbrows] \n```", "```py\nmax(...)\n    max(iterable, *[, default=obj, key=func]) -> value\n    max(arg1, arg2, *args, *[, key=func]) -> value\n\n    With a single iterable argument, return its biggest item. The\n    default keyword-only argument specifies an object to return if\n    the provided iterable is empty.\n    With two or more arguments, return the largest argument. \n```", "```py\nfunction(**{\"key\": \"value\"}) \n```", "```py\nfunction(key=\"value\") \n```", "```py\n>>> def function(**kwargs):\n...     print(kwargs)\n... \n>>> function(key=\"value\")\n{'key': 'value'} \n```", "```py\ndef function(**kwargs):  # wrong\n    timeout = kwargs.get(\"timeout\", DEFAULT_TIMEOUT)\n    ... \n```", "```py\ndef function(timeout=DEFAULT_TIMEOUT, **kwargs):  # better\n    ... \n```", "```py\n>>> def my_function(x, y):\n...     print(f\"{x=}, {y=}\")\n...\n>>> my_function(1, 2) \nx=1, y=2 \n>>> my_function(x=1, y=2) \nx=1, y=2\n>>> my_function(y=2, x=1) \nx=1, y=2\n>>> my_function(1, y=2)\nx=1, y=2 \n```", "```py\n>>> def my_function(x, y, /):\n...     print(f\"{x=}, {y=}\")\n...\n>>> my_function(1, 2)\nx=1, y=2\n>>> my_function(x=1, y=2)\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nTypeError: my_function() got some positional-only arguments passed as keyword arguments: 'x, y' \n```", "```py\n>>> def my_function(x, y, *args, kw1, kw2=0):\n...     print(f\"{x=}, {y=}, {kw1=}, {kw2=}\")\n...\n>>> my_function(1, 2, kw1=3, kw2=4)\nx=1, y=2, kw1=3, kw2=4\n>>> my_function(1, 2, kw1=3)\nx=1, y=2, kw1=3, kw2=0 \n```", "```py\nresult = my_function(1, 2, True) \n```", "```py\nresult = my_function(1, 2, use_new_implementation=True) \n```", "```py\ntrack_request(request.headers, request.ip_addr, request.request_id) \n```", "```py\ndef calculate_price(base_price: float, tax: float, discount: float) -> float:\n    return (base_price * (1 + tax)) * (1 - discount)\ndef show_price(price: float) -> str:\n    return \"$ {0:,.2f}\".format(price)\ndef str_final_price(\n    base_price: float, tax: float, discount: float, fmt_function=str\n) -> str:\n    return fmt_function(calculate_price(base_price, tax, discount)) \n```", "```py\n>>> str_final_price(10, 0.2, 0.5)\n'6.0'\n>>> str_final_price(1000, 0.2, 0)\n'1200.0'\n>>> str_final_price(1000, 0.2, 0.1, fmt_function=show_price)\n'$ 1,080.00' \n```", "```py\nfrom myproject.constants import CONNECTION_TIMEOUT \n```"]