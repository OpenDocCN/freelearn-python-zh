<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Creating the GUI Form and Adding Widgets</h1></div></div></div><p>In this chapter, we start creating amazing GUIs using Python 3:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating our first Python GUI</li><li class="listitem" style="list-style-type: disc">Preventing the GUI from being resized</li><li class="listitem" style="list-style-type: disc">Adding a label to the GUI form</li><li class="listitem" style="list-style-type: disc">Creating buttons and changing their text property</li><li class="listitem" style="list-style-type: disc">Text box widgets</li><li class="listitem" style="list-style-type: disc">Setting the focus to a widget and disabling widgets</li><li class="listitem" style="list-style-type: disc">Combo box widgets</li><li class="listitem" style="list-style-type: disc">Creating a check button with different initial states</li><li class="listitem" style="list-style-type: disc">Using radio button widgets</li><li class="listitem" style="list-style-type: disc">Using scrolled text widgets</li><li class="listitem" style="list-style-type: disc">Adding several widgets in a loop</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introduction</h1></div></div></div><p>In this chapter, we will develop our first GUI in Python. We start with the minimum code required to build a running GUI application. Each recipe then adds different widgets to the GUI form.</p><p>In the first two recipes, we show the entire code, consisting of only a few lines of code. In the following recipes we only show the code to be added to the previous recipes.</p><p>By the end of this chapter, we will have created a working GUI application that consists of labels, buttons, text boxes, combo boxes, and check buttons in various states, as well as radio buttons that change the background color of the GUI.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Creating our first Python GUI</h1></div></div></div><p>Python is<a id="id0" class="indexterm"/> a very powerful programming language. It ships with the built-in tkinter module. In only a few lines of code (four, to be precise) we can build our first Python GUI.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Getting ready</h2></div></div></div><p>To follow this recipe, a working Python development environment is a prerequisite. The IDLE GUI that ships with Python is enough to start. IDLE was built using tkinter!</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>All the recipes in this book were developed using Python 3.4 on a Windows 7 64-bit OS. They have not been tested on any other configuration. As Python is a cross-platform language, the code from each recipe is expected to run everywhere.</p><p>If you are using a Mac, it does come built-in with Python, yet it might be missing some modules such as tkinter, which we will use throughout this book.</p><p>We are using Python 3 and the creator of Python intentionally chose not to make it backwards compatible with Python 2.</p><p>If you are<a id="id1" class="indexterm"/> using a Mac or Python 2, you might have to install Python 3 from <a class="ulink" href="http://www.python.org">www.python.org</a> in order to successfully run the recipes in this book.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>How to do it...</h2></div></div></div><p>Here are the four lines of Python code required to create the resulting GUI:</p><div><pre class="programlisting">import tkinter as tk     # 1
win = tk.Tk()            # 2
win.title("Python GUI")  # 3
win.mainloop()           # 4</pre></div><p>Execute this code and admire the result:</p><div><img src="img/B04829_01_01.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>How it works...</h2></div></div></div><p>In line 1, we import the built-in <code class="literal">tkinter</code> module and alias it as <code class="literal">tk</code> to simplify our Python code. In line 2, we create an instance of the <code class="literal">Tk</code> class by calling its constructor (the parentheses<a id="id2" class="indexterm"/> appended to <code class="literal">Tk</code> turn the class into an instance). We are using the alias <code class="literal">tk</code> so we don't have to use the longer word <code class="literal">tkinter</code>. We are assigning the class instance to a variable named <code class="literal">win</code> (short for a window). As Python is a dynamically typed language, we did not have to declare this variable before assigning to it and we did not have to give it a specific type. <em>Python infers the type from the assignment of this statement</em>. Python is a strongly typed language, so every variable always has a type. We just don't have to specify its type beforehand like in other languages. This makes Python a very powerful and productive language to program in.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>A little note about classes and types:</p><p>In Python every variable always has a type. We cannot create a variable without assigning it a type. Yet, in Python, we do not have to declare the type beforehand, as we have to do in the C programming language.</p><p>Python is smart enough to infer the type. At the time of writing, C# also has this capability.</p><p>Using Python, we can create our own classes using the <code class="literal">class</code> keyword instead of the <code class="literal">def</code> keyword.</p><p>In order to assign the class to a variable, we first have to create an instance of our class. We create the instance and assign this instance to our variable.</p><div><pre class="programlisting">class AClass(object):
    print('Hello from AClass')

classInstance = AClass()</pre></div><p>Now the variable <code class="literal">classInstance</code> is of the type <code class="literal">AClass</code>.</p><p>If this sounds confusing, do not worry. We will cover OOP in the coming chapters.</p></div></div><p>In line 3, we use the instance variable of the class (<code class="literal">win</code>) to give our window a title via the <code class="literal">title</code> property. In line 4, we start the window's event loop by calling the <code class="literal">mainloop</code> method on the class instance <code class="literal">win</code>. Up to this point in our code, we created an instance and set one property <em>but the GUI will not be displayed until we start the main event loop</em>.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>An event loop is a mechanism that makes our GUI work. We can think of it as an endless loop where our GUI is waiting for events to be sent to it. A button click creates an event within our GUI or our GUI being resized also creates an event.</p><p>We can write all of our GUI code in advance and nothing will be displayed on the user's screen until we call this endless loop (<code class="literal">win.mainloop()</code> in the code shown above).</p><p>The event loop ends when the user clicks the red <strong>X</strong> button or a widget that we have programmed to end our GUI. When the event loop ends, our GUI also ends.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>There's more...</h2></div></div></div><p>This <a id="id3" class="indexterm"/>recipe used a minimum amount of Python code to create our first GUI program. However, throughout this book, we will use OOP when it makes sense.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Preventing the GUI from being resized</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Getting ready</h2></div></div></div><p>This <a id="id4" class="indexterm"/>recipe extends the previous one. Therefore, it is necessary to have typed Recipe 1 yourself into a project of your own or downloaded the code from <a class="ulink" href="https://www.packtpub.com/support">https://www.packtpub.com/support</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>How to do it...</h2></div></div></div><p>We are preventing the GUI from being resized.</p><div><pre class="programlisting">import tkinter as tk        # 1 imports

win = tk.Tk()               # 2 Create instance
win.title("Python GUI")     # 3 Add a title       
    
win.resizable(0, 0)         # 4 Disable resizing the GUI

win.mainloop()              # 5 Start GUI</pre></div><p>Running the code creates this GUI:</p><div><img src="img/B04829_01_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How it works...</h2></div></div></div><p>Line 4 prevents the Python GUI from being resized.</p><p>Running this<a id="id5" class="indexterm"/> code will result in a GUI similar to the one we created in Recipe 1. However, the user can no longer resize it. Also, notice how the maximize button in the toolbar of the window is grayed out.</p><p>Why is this important? Because, once we add widgets to our form, resizing can make our GUI look not as good as we want it to be. We will add widgets to our GUI in the next recipes.</p><p>
<code class="literal">Resizable()</code> is a method of the <code class="literal">Tk()</code> class and, by passing in <code class="literal">(0, 0),</code> we prevent the GUI from being resized. If we pass in other values, we hard-code the x and y start up size of the GUI, <em>but that won't make it nonresizable</em>.</p><p>We also added comments to our code in preparation for the recipes contained in this book.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>In visual programming IDEs such as Visual Studio .NET, C# programmers often do not think of preventing the user from resizing the GUI they developed in this language. That creates inferior GUIs. Adding this one line of Python code can make our users appreciate our GUI.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Adding a label to the GUI form</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Getting ready</h2></div></div></div><p>We <a id="id6" class="indexterm"/>are extending the first recipe. We will leave the GUI resizable, so don't use the code from the second recipe (or comment the <code class="literal">win.resizable</code> line 4 out).</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How to do it...</h2></div></div></div><p>In order to add a <code class="literal">Label</code> widget to our GUI, we are importing the <code class="literal">ttk</code> module from <code class="literal">tkinter</code>. Please note the two import statements.</p><div><pre class="programlisting"># imports                  # 1
import tkinter as tk       # 2
from tkinter import ttk    # 3</pre></div><p>Add the following code just above <code class="literal">win.mainloop()</code> located at the bottom of recipes 1 and 2.</p><div><pre class="programlisting"># Adding a Label           # 4
ttk.Label(win, text="A Label").grid(column=0, row=0) # 5</pre></div><p>Running the code adds a label to our GUI:</p><div><img src="img/B04829_01_03.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>How it works...</h2></div></div></div><p>In line 3 of the above code, we are importing a separate module from <code class="literal">tkinter</code>. The <code class="literal">ttk</code> module has some advanced widgets that make our GUI look great. In a sense, <code class="literal">ttk</code> is an extension within <code class="literal">tkinter</code>.</p><p>We still need to import <code class="literal">tkinter</code> itself, but we have to specify that we now want to also use <code class="literal">ttk</code> from <code class="literal">tkinter</code>.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>
<code class="literal">ttk</code> stands for 'themed tk". It improves our GUI look and feel.</p></div></div><p>Line 5 above adds the label to the GUI, just before we call <code class="literal">mainloop</code> (not shown here to preserve space. See recipes 1 or 2).</p><p>We are <a id="id7" class="indexterm"/>passing our window instance into the <code class="literal">ttk.Label</code> constructor and setting the text property. This becomes the text our <code class="literal">Label</code> will display.</p><p>We are also making use of the <em>grid layout manager</em>, which we'll explore in much more depth in <a class="link" href="ch02.html" title="Chapter 2. Layout Management">Chapter 2</a>, <em>Layout Management</em>.</p><p>Note how our GUI suddenly got much smaller than in previous recipes.</p><p>The reason why it became so small is that we added a widget to our form. Without a widget, <code class="literal">tkinter</code> uses a default size. Adding a widget causes optimization, which generally means using as little space as necessary to display the widget(s).</p><p>If we make the text of the label longer, the GUI will expand automatically. We will cover this automatic form size adjustment in a later recipe in <a class="link" href="ch02.html" title="Chapter 2. Layout Management">Chapter 2</a>, <em>Layout Management</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>There's more...</h2></div></div></div><p>Try resizing and maximizing this GUI with a label and watch what happens.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Creating buttons and changing their text property</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Getting ready</h2></div></div></div><p>This <a id="id8" class="indexterm"/>recipe<a id="id9" class="indexterm"/> extends the previous one. You can download the entire code from the Packt Publishing website.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How to do it...</h2></div></div></div><p>We are adding a button that, when clicked, performs an action. In this recipe, we will update the label we added in the previous recipe, as well as updating the text property of the button.</p><div><pre class="programlisting"># Modify adding a Label                                      # 1
aLabel = ttk.Label(win, text="A Label")                      # 2
aLabel.grid(column=0, row=0)                                 # 3


# Button Click Event Callback Function                       # 4
def clickMe():                                               # 5
    action.configure(text="** I have been Clicked! **")
    aLabel.configure(foreground='red')

# Adding a Button                                            # 6
action = ttk.Button(win, text="Click Me!", command=clickMe)  # 7
action.grid(column=1, row=0)                                 # 8</pre></div><p>Before <a id="id10" class="indexterm"/>clicking<a id="id11" class="indexterm"/> the button:</p><div><img src="img/B04829_01_04.jpg" alt="How to do it..."/></div><p>After clicking the button, the color of the label has been changed, and so has the text of the button. Action!</p><div><img src="img/B04829_01_05.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How it works...</h2></div></div></div><p>In line 2 we are now assigning the label to a variable and in line 3 we use this variable to position the label within the form. We will need this variable to change its properties in the <code class="literal">clickMe()</code> function. By default, this is a module-level variable so we can access it inside the function as long as we declare the variable above the function that calls it.</p><p>Line 5 is the event handler that is being invoked once the button gets clicked.</p><p>In line 7, we create the button and bind the command to the <code class="literal">clickMe()</code> function.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>GUIs are event-driven. Clicking the button creates an event. We bind what happens when this event occurs in the callback function using the command property of the <code class="literal">ttk.Button</code> widget. Notice how we do not use parentheses; only the name <code class="literal">clickMe</code>.</p></div></div><p>We also change the text of the label to include <code class="literal">red</code> as in the printed book, this might otherwise not be obvious. When you run the code you can see that the color did indeed change.</p><p>Lines 3 and 8 both use the grid layout manager, which will be discussed in the following chapter. This aligns <a id="id12" class="indexterm"/>both<a id="id13" class="indexterm"/> the label and the button.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>There's more...</h2></div></div></div><p>We will continue to add more and more widgets to our GUI and we will make use of many built-in properties in other recipes in the book.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Text box widgets</h1></div></div></div><p>In <code class="literal">tkinter</code>, the<a id="id14" class="indexterm"/> typical textbox widget is called <code class="literal">Entry</code>. In this recipe, we will add such an <code class="literal">Entry</code> to our GUI. We will make our label more useful by describing what the <code class="literal">Entry</code> is doing for the user.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Getting ready</h2></div></div></div><p>This recipe builds upon the <em>Creating buttons and changing their text property</em> recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How to do it...</h2></div></div></div><div><pre class="programlisting"># Modified Button Click Function   # 1
def clickMe():                     # 2
    action.configure(text='Hello ' + name.get())
    
# Position Button in second row, second column (zero-based)
action.grid(column=1, row=1)

# Changing our Label               # 3
ttk.Label(win, text="Enter a name:").grid(column=0, row=0) # 4

# Adding a Textbox Entry widget    # 5
name = tk.StringVar()              # 6
nameEntered = ttk.Entry(win, width=12, textvariable=name) # 7
nameEntered.grid(column=0, row=1)  # 8</pre></div><p>Now our GUI looks like this:</p><div><img src="img/B04829_01_06.jpg" alt="How to do it..."/></div><p>After <a id="id15" class="indexterm"/>entering some text and clicking the button, there is the following change in the GUI:</p><div><img src="img/B04829_01_07.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How it works...</h2></div></div></div><p>In line 2 we are getting the value of the <code class="literal">Entry</code> widget. We are not using OOP yet, so how come we can access the value of a variable that was not even declared yet?</p><p>Without using OOP classes, in Python procedural coding we have to physically place a name above a statement that tries to use that name. So how come this works (it does)?</p><p>The answer is that the button click event is a callback function, and by the time the button is clicked by a user, the variables referenced in this function are known and do exist.</p><p>Life is good.</p><p>Line 4 gives our label a more meaningful name, because now it describes the textbox below it. We moved the button down next to the label to visually associate the two. We are still using the grid layout manager, to be explained in more detail in <a class="link" href="ch02.html" title="Chapter 2. Layout Management">Chapter 2</a>, <em>Layout Management</em>.</p><p>Line 6 creates a variable <code class="literal">name</code>. This variable is bound to the <code class="literal">Entry</code> and, in our <code class="literal">clickMe()</code> function, we are able to retrieve the value of the <code class="literal">Entry</code> box by calling <code class="literal">get()</code> on this variable. This works like a charm.</p><p>Now we see that while the button displays the entire text we entered (and more), the textbox <code class="literal">Entry</code> widget<a id="id16" class="indexterm"/> did not expand. The reason for this is that we had hard-coded it to a width of 12 in line 7.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Python is a dynamically-typed language and infers the type from the assignment. What this means is if we assign a string to the variable <code class="literal">name,</code> the variable will be of the type string, and if we assign an integer to <code class="literal">name,</code> this variable's type will be integer.</p><p>Using tkinter, we have to declare the variable <code class="literal">name</code> as the type <code class="literal">tk.StringVar()</code> before we can use it successfully. The reason is this that Tkinter is not Python. We can use it from Python but it is not the same language.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Setting the focus to a widget and disabling widgets</h1></div></div></div><p>While<a id="id17" class="indexterm"/> our GUI is nicely improving, it would be more convenient<a id="id18" class="indexterm"/> and useful to have the cursor appear in the <code class="literal">Entry</code> widget as soon as the GUI appears. Here we learn how to do this.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Getting ready</h2></div></div></div><p>This recipe extends the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>How to do it...</h2></div></div></div><p>Python is truly great. All we have to do to set the focus to a specific control when the GUI appears is call the <code class="literal">focus()</code> method on an instance of a <code class="literal">tkinter</code> widget we previously created. In our current GUI example, we assigned the <code class="literal">ttk.Entry</code> class instance to a variable we named <code class="literal">nameEntered</code>. Now we can give it the focus.</p><p>Place the following code just above the bottom of the module that starts the main windows event loop, just like in previous recipes. If you get some errors, make sure you are placing calls to variables below the code where they are declared. We are not using OOP as of yet, so this is still necessary. Later, it will no longer be necessary to do this.</p><div><pre class="programlisting">nameEntered.focus()            # Place cursor into name Entry</pre></div><p>On a Mac, you might have to set the focus to the GUI window first before being able to set the focus to the <code class="literal">Entry</code> widget in this window.</p><p>Adding this one line of Python code places the cursor into our text <code class="literal">Entry</code> box, giving the text <code class="literal">Entry</code> box the focus. As soon as the GUI appears, we can type into this text box without <a id="id19" class="indexterm"/>having to click it first.</p><div><img src="img/B04829_01_08.jpg" alt="How to do it..."/></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>Note how the cursor now defaults to residing inside the text <code class="literal">Entry</code> box.</p></div></div><p>We <a id="id20" class="indexterm"/>can also disable widgets. To do that, we set a property on the widget. We can make the button disabled by adding this one line of Python code:</p><div><pre class="programlisting">action.configure(state='disabled')    # Disable the Button Widget</pre></div><p>After adding the above line of Python code, clicking the button no longer creates any action!</p><div><img src="img/B04829_01_09.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How it works...</h2></div></div></div><p>This code is self-explanatory. We set the focus to one control and disable another widget. Good naming in programming languages helps to eliminate lengthy explanations. Later in this book, there will be some advanced tips on how to do this while programming at work or practicing our programming skills at home.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec28"/>There's more...</h2></div></div></div><p>Yes. This is only the first chapter. There is much more to come.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Combo box widgets</h1></div></div></div><p>In this recipe, <a id="id21" class="indexterm"/>we will improve our GUI by adding drop-down combo boxes that can have initial default values. While we can restrict the user to only certain choices, at the same time, we can allow the user to type in whatever they wish.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec29"/>Getting ready</h2></div></div></div><p>This recipe extends the previous recipes.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How to do it...</h2></div></div></div><p>We are inserting another column between the <code class="literal">Entry</code> widget and the <code class="literal">Button</code> using the grid layout manager. Here is the Python code.</p><div><pre class="programlisting">ttk.Label(win, text="Choose a number:").grid(column=1, row=0)  # 1
number = tk.StringVar()                         # 2
numberChosen = ttk.Combobox(win, width=12, textvariable=number) #3
numberChosen['values'] = (1, 2, 4, 42, 100)     # 4
numberChosen.grid(column=1, row=1)              # 5
numberChosen.current(0)                         # 6</pre></div><p>This code, when added to previous recipes, creates the following GUI. Note how, in line 4 in the preceding code, we assign a tuple with default values to the combo box. These values then appear in the drop-down box. We can also change them if we like (by typing in different values when the application is running).</p><div><img src="img/B04829_01_10.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec31"/>How it works...</h2></div></div></div><p>Line 1 adds a second label to match the newly created combo box (created in line 3). Line 2 assigns the value of the box to a variable of a special <code class="literal">tkinter</code> type (<code class="literal">StringVar</code>), as we did in a previous recipe.</p><p>Line 5 aligns the<a id="id22" class="indexterm"/> two new controls (label and combo box) within our previous GUI layout, and line 6 assigns a default value to be displayed when the GUI first becomes visible. This is the first value of the <code class="literal">numberChosen['values']</code> tuple, the string <code class="literal">"1"</code>. We did not place quotes around our tuple of integers in line 4, but they got casted into strings because, in line 2, we declared the values to be of type <code class="literal">tk.StringVar</code>.</p><p>The screenshot shows the selection made by the user (<strong>42</strong>). This value gets assigned to the <code class="literal">number</code> variable.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec32"/>There's more...</h2></div></div></div><p>If we want to restrict the user to only be able to select the values we have programmed into the <code class="literal">Combobox</code>, we can do that by passing the <em>state property</em> into the constructor. Modify line 3 in the previous code to:</p><div><pre class="programlisting">numberChosen = ttk.Combobox(win, width=12, textvariable=number, state='readonly')</pre></div><p>Now users can no longer type values into the <code class="literal">Combobox</code>. We can display the value chosen by the user by adding the following line of code to our Button Click Event Callback function:</p><div><pre class="programlisting"># Modified Button Click Callback Function
def clickMe():
    action.configure(text='Hello ' + name.get()+ ' ' + numberChosen.get())</pre></div><p>After choosing a number, entering a name, and then clicking the button, we get the following GUI result, which now also displays the number selected:</p><div><img src="img/B04829_01_11.jpg" alt="There's more..."/></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Creating a check button with different initial states</h1></div></div></div><p>In this<a id="id23" class="indexterm"/> recipe, we will add three <code class="literal">Checkbutton</code> widgets, each with a different initial state.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec33"/>Getting ready</h2></div></div></div><p>This recipe extends the previous recipes.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How to do it...</h2></div></div></div><p>We are creating three <code class="literal">Checkbutton</code> widgets that differ in their states. The first is disabled and has a checkmark in it. The user cannot remove this checkmark as the widget is disabled.</p><p>The second <code class="literal">Checkbutton</code> is enabled and, by default, has no checkmark in it, but the user can click it to add a checkmark.</p><p>The third <code class="literal">Checkbutton</code> is both enabled and checked by default. The users can uncheck and recheck the widget as often as they like.</p><div><pre class="programlisting"># Creating three checkbuttons    # 1
chVarDis = tk.IntVar()           # 2
check1 = tk.Checkbutton(win, text="Disabled", variable=chVarDis, state='disabled')                     # 3
check1.select()                  # 4
check1.grid(column=0, row=4, sticky=tk.W) # 5

chVarUn = tk.IntVar()            # 6
check2 = tk.Checkbutton(win, text="UnChecked", variable=chVarUn)
check2.deselect()                # 8
check2.grid(column=1, row=4, sticky=tk.W) # 9                  

chVarEn = tk.IntVar()            # 10
check3 = tk.Checkbutton(win, text="Enabled", variable=chVarEn)
check3.select()                  # 12
check3.grid(column=2, row=4, sticky=tk.W) # 13</pre></div><p>Running the new code results in the following GUI:</p><div><img src="img/B04829_01_12.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec35"/>How it works...</h2></div></div></div><p>In lines 2, 6, and 10, we create three variables of type <code class="literal">IntVar</code>. In the following line, for each of these variables we create a <code class="literal">Checkbutton</code>, passing in these variables. They will hold the state of the <code class="literal">Checkbutton</code> (unchecked or checked). By default, that is either 0 (unchecked) or 1 (checked) so the type of the variable is a <code class="literal">tkinter</code> integer.</p><p>We <a id="id24" class="indexterm"/>place these <code class="literal">Checkbutton</code> widgets in our main window so the first argument passed into the constructor is the parent of the widget; in our case <code class="literal">win</code>. We give each <code class="literal">Checkbutton</code> a different label via its <code class="literal">text</code> property.</p><p>Setting the sticky property of the grid to <code class="literal">tk.W</code> means that the widget will be aligned to the west of the grid. This is very similar to Java syntax and it means that it will be aligned to the left. When we resize our GUI, the widget will remain on the left side and not be moved towards the center of the GUI.</p><p>Lines 4 and 12 place a checkmark into the <code class="literal">Checkbutton</code> widget by calling the <code class="literal">select()</code> method on these two <code class="literal">Checkbutton</code> class instances.</p><p>We continue to arrange our widgets using the grid layout manager, which will be explained in more detail in <a class="link" href="ch02.html" title="Chapter 2. Layout Management">Chapter 2</a>, <em>Layout Management</em>.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Using radio button widgets</h1></div></div></div><p>In this<a id="id25" class="indexterm"/> recipe, we will create three <code class="literal">tkinter Radiobutton</code> widgets. We will also add some code that changes the color of the main form depending upon which <code class="literal">Radiobutton</code> is selected.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec36"/>Getting ready</h2></div></div></div><p>This recipe extends the previous recipes.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec37"/>How to do it...</h2></div></div></div><p>We are adding the following code to the previous recipe:</p><div><pre class="programlisting"># Radiobutton Globals   # 1
COLOR1 = "Blue"         # 2
COLOR2 = "Gold"         # 3
COLOR3 = "Red"          # 4

# Radiobutton Callback  # 5
def radCall():          # 6
   radSel=radVar.get()
   if   radSel == 1: win.configure(background=COLOR1)
   elif radSel == 2: win.configure(background=COLOR2)
   elif radSel == 3: win.configure(background=COLOR3)

# create three Radiobuttons   # 7
radVar = tk.IntVar()          # 8
rad1 = tk.Radiobutton(win, text=COLOR1, variable=radVar, value=1,               command=radCall)              # 9
rad1.grid(column=0, row=5, sticky=tk.W)  # 10

rad2 = tk.Radiobutton(win, text=COLOR2, variable=radVar, value=2, command=radCall)                             # 11
rad2.grid(column=1, row=5, sticky=tk.W)  # 12

rad3 = tk.Radiobutton(win, text=COLOR3, variable=radVar, value=3, command=radCall)                             # 13
rad3.grid(column=2, row=5, sticky=tk.W)  # 14</pre></div><p>Running<a id="id26" class="indexterm"/> this code and selecting the <code class="literal">Radiobutton</code> named <strong>Gold</strong> creates the following window:</p><div><img src="img/B04829_01_13.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How it works...</h2></div></div></div><p>In lines 2-4 we create some module-level global variables, which we will use in the creation of each radio button as well as in the callback function that creates the action of changing the background color of the main form (using the instance variable <code class="literal">win</code>).</p><p>We are<a id="id27" class="indexterm"/> using global variables to make it easier to change the code. By assigning the name of the color to a variable and using this variable in several places, we can easily experiment with different colors. Instead of doing a global search-and-replace of a hard-coded string (which is prone to errors), we just need to change <a id="id28" class="indexterm"/>one line of code and everything else will work. This is<a id="id29" class="indexterm"/> known as the <strong>DRY principle</strong>, which stands for <strong>Don't Repeat Yourself</strong>. This is an OOP concept that we will use in later recipes of the book.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>The names of the colors we are assigning to the variables (<code class="literal">COLOR1</code>, <code class="literal">COLOR2 …</code>) are <code class="literal">tkinter</code> keywords (technically, they are <em>symbolic names</em>). If we use names that are not <code class="literal">tkinter</code> color keywords, then the code will not work.</p></div></div><p>Line 6 is the <em>callback function</em> that changes the background of our main form (<code class="literal">win</code>) depending upon the user's selection.</p><p>In line 8 we are creating a <code class="literal">tk.IntVar</code> variable. What is important about this is that we are creating only one variable to be used by all three radio buttons. As can be seen from the above screenshot, no matter which <code class="literal">Radiobutton</code> we select, all the others will automatically be unselected for us.</p><p>Lines 9 to 14 create the three radio buttons, assign them to the main form, and pass in the variable to be used in the callback function that creates the action of changing the background of our main window.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>While this is the first recipe that changes the color of a widget, quite honestly, it looks a bit ugly. A large portion of the following recipes in this book explain how to make our GUI look truly amazing.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec39"/>There's more...</h2></div></div></div><p>Here is a <a id="id30" class="indexterm"/>small sample of the available symbolic color names that you can look up at the official tcl manual page:</p><p>
<a class="ulink" href="http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm">http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm</a>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Red</p>
</th><th style="text-align: left" valign="bottom">
<p>Green</p>
</th><th style="text-align: left" valign="bottom">
<p>Blue</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>alice blue</p>
</td><td style="text-align: left" valign="top">
<p>240</p>
</td><td style="text-align: left" valign="top">
<p>248</p>
</td><td style="text-align: left" valign="top">
<p>255</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>AliceBlue</p>
</td><td style="text-align: left" valign="top">
<p>240</p>
</td><td style="text-align: left" valign="top">
<p>248</p>
</td><td style="text-align: left" valign="top">
<p>255</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Blue</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>255</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Gold</p>
</td><td style="text-align: left" valign="top">
<p>255</p>
</td><td style="text-align: left" valign="top">
<p>215</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Red</p>
</td><td style="text-align: left" valign="top">
<p>255</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td></tr></tbody></table></div><p>Some <a id="id31" class="indexterm"/>of the names create the same color, so <code class="literal">alice blue</code> creates the same color as <code class="literal">AliceBlue</code>. In this recipe we used the symbolic names <code class="literal">Blue</code>, <code class="literal">Gold</code>, and <code class="literal">Red</code>.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Using scrolled text widgets</h1></div></div></div><p>
<code class="literal">ScrolledText</code> widgets are much larger than simple <code class="literal">Entry</code> widgets and span multiple lines. They <a id="id32" class="indexterm"/>are widgets like Notepad and wrap lines, automatically enabling vertical scrollbars when the text gets larger than the height of the <code class="literal">ScrolledText</code> widget.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec40"/>Getting ready</h2></div></div></div><p>This recipe extends the previous recipes. You can download the code for each chapter of this book from the Packt Publishing website.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec41"/>How to do it...</h2></div></div></div><p>By adding the following lines of code, we create a <code class="literal">ScrolledText</code> widget:</p><div><pre class="programlisting"># Add this import to the top of the Python Module    # 1
from tkinter import scrolledtext      # 2

# Using a scrolled Text control       # 3
scrolW  = 30                          # 4
scrolH  =  3                          # 5
scr = scrolledtext.ScrolledText(win, width=scrolW, height=scrolH, wrap=tk.WORD)                         # 6
scr.grid(column=0, columnspan=3)      # 7</pre></div><p>We can actually type into our widget, and if we type enough words, the lines will automatically wrap around!</p><div><img src="img/B04829_01_14.jpg" alt="How to do it..."/></div><p>Once we<a id="id33" class="indexterm"/> type in more words than the height of the widget can display, the vertical scrollbar becomes enabled. This all works out-of-the-box without us needing to write any more code to achieve this.</p><div><img src="img/B04829_01_15.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec42"/>How it works...</h2></div></div></div><p>In line 2 we are importing the module that contains the <code class="literal">ScrolledText</code> widget class. Add that to the top of the module, just below the other two <code class="literal">import</code> statements.</p><p>Lines 4 and 5 define the width and height of the <code class="literal">ScrolledText</code> widget we are about to create. These are hard-coded values we are passing into the <code class="literal">ScrolledText</code> widget constructor in line 6.</p><p>These values are <em>magic numbers</em> found by experimentation to work well. You might experiment by changing <code class="literal">srcolW</code> from 30 to 50 and observe the effect!</p><p>In line 6 we are setting a property on the widget by passing in <code class="literal">wrap=tk.WORD</code>.</p><p>By <a id="id34" class="indexterm"/>setting the <code class="literal">wrap</code> property to <code class="literal">tk.WORD</code> we are telling the <code class="literal">ScrolledText</code> widget to break lines by words, so that we do not wrap around within a word. The default option is <code class="literal">tk.CHAR</code>, which wraps any character regardless of whether we are in the middle of a word.</p><p>The second screenshot shows that the vertical scrollbar moved down because we are reading a longer text that does not entirely fit into the x, y dimensions of the <code class="literal">SrolledText</code> control we created.</p><p>Setting the <code class="literal">columnspan</code> property of the grid widget to <code class="literal">3</code> for the <code class="literal">SrolledText</code> widget makes this widget span all three columns. If we did not set this property, our <code class="literal">SrolledText</code> widget would only reside in column one, which is not what we want.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Adding several widgets in a loop</h1></div></div></div><p>So far<a id="id35" class="indexterm"/> we have created several widgets of the same type (for example. <code class="literal">Radiobutton</code>) by basically copying and pasting the same code and then modifying the variations (for example, the column number). In this recipe, we start refactoring our code to make it less redundant.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec43"/>Getting ready</h2></div></div></div><p>We<a id="id36" class="indexterm"/> are refactoring some parts of the previous recipe's code, so you need that code to apply to this recipe to.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec44"/>How to do it...</h2></div></div></div><div><pre class="programlisting"># First, we change our Radiobutton global variables into a list.
colors = ["Blue", "Gold", "Red"]              # 1

# create three Radiobuttons using one variable
radVar = tk.IntVar()

Next we are selecting a non-existing index value for radVar.
radVar.set(99)                                # 2

Now we are creating all three Radiobutton widgets within one loop.

for col in range(3):                          # 3
    curRad = 'rad' + str(col)  
    curRad = tk.Radiobutton(win, text=colors[col], variable=radVar,     value=col, command=radCall)
    curRad.grid(column=col, row=5, sticky=tk.W)


We have also changed the callback function to be zero-based, using the list instead of module-level global variables. 

# Radiobutton callback function                # 4
def radCall():
   radSel=radVar.get()
   if   radSel == 0: win.configure(background=colors[0])
   elif radSel == 1: win.configure(background=colors[1])
   elif radSel == 2: win.configure(background=colors[2])</pre></div><p>Running<a id="id37" class="indexterm"/> this code will create the same window as before, but <a id="id38" class="indexterm"/>our code is much cleaner and easier to maintain. This will help us when we expand our GUI in the following recipes.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec45"/>How it works...</h2></div></div></div><p>In line 1, we have turned our global variables into a list.</p><p>In line 2, we are setting a default value to the <code class="literal">tk.IntVar</code> variable we named <code class="literal">radVar</code>. This is important because, while in the previous recipe we had set the value for <code class="literal">Radiobutton</code> widgets starting at 1, in our new loop it is much more convenient to use Python's zero-based indexing. If we did not set the default value to a value outside the range of our <code class="literal">Radiobutton</code> widgets, one of the radio buttons would be selected when the GUI appears. While this in itself might not be so bad, <em>it would not trigger the callback</em> and we would end up with a radio button selected that does not do its job (that is, change the color of the main win form).</p><p>In line 3 we are replacing the three previously hard-coded creations of the Radiobutton widgets with a loop, which does the same. It is just more concise (fewer lines of code) and much more maintainable. For example, if we want to create 100 instead of just 3 <code class="literal">Radiobutton</code> widgets, all we have to change is the number inside Python's range operator. We would not have to type or copy and paste 97 sections of duplicate code, just one number.</p><p>Line 4 shows the modified callback, which physically lives above the previous lines. We placed it below to give emphasis to the more important parts of this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec46"/>There's more...</h2></div></div></div><p>This recipe concludes the first chapter of this book. All the following recipes in all of the next chapters will build upon the GUI we have constructed so far, greatly enhancing it.</p></div></div></div>
</body></html>