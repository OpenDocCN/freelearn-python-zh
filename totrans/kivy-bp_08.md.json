["```py\n/* ANSI C-style comment */\n// C++ one-line comment\n```", "```py\nfloat a; // this has no direct Python equivalent\nint b = 1;\n```", "```py\nfloat pow2(float x)\n{\n    return x * x;\n}\n```", "```py\nif (x < 9.0)\n{\n    x = 9.0;\n}\n```", "```py\nvoid main(void)\n{\n    // code\n}\n```", "```py\nfrom kivy.app import App\nfrom kivy.base import EventLoop\nfrom kivy.graphics import Mesh\nfrom kivy.graphics.instructions import RenderContext\nfrom kivy.uix.widget import Widget\n\nclass GlslDemo(Widget):\n    def __init__(self, **kwargs):\n        Widget.__init__(self, **kwargs)\n        self.canvas = RenderContext(use_parent_projection=True)\n        self.canvas.shader.source = 'basic.glsl'\n        # Set up geometry here.\n\nclass GlslApp(App):\n    def build(self):\n        EventLoop.ensure_window()\n        return GlslDemo()\n\nif __name__ == '__main__':\n    GlslApp().run()\n```", "```py\ndef __init__(self, **kwargs):\n    Widget.__init__(self, **kwargs)\n    self.canvas = RenderContext(use_parent_projection=True)\n    self.canvas.shader.source = 'basic.glsl'\n\n    fmt = ( # Step 1\n        (b'vPosition', 2, 'float'),\n    )\n\n    vertices = ( # Step 2\n        0,   0,\n        255, 0,\n        255, 255,\n        0,   255,\n    )\n\n    indices = (0, 1, 2, 2, 3, 0)  # Step 3\n\n    with self.canvas:\n        Mesh(fmt=fmt, mode='triangles',  # Step 4\n             indices=indices, vertices=vertices)\n```", "```py\nvertices = (\n    0,   0,\n    255, 0,\n    255, 255,\n    0,   255,\n)\n```", "```py\nindices = (\n    0, 1, 2, # Three vertices make a triangle.\n    2, 3, 0, # And another one.\n)\n```", "```py\n---vertex\n$HEADER$\n\nvoid main(void)\n{\n    // vertex shader\n    gl_Position = ...\n}\n\n---fragment\n$HEADER$\n\nvoid main(void)\n{\n    // fragment shader\n    gl_FragColor = ...\n}\n```", "```py\nvarying vec4 frag_color;\nvarying vec2 tex_coord0;\n\nattribute vec2 vPosition;\nattribute vec2 vTexCoords0;\n\nuniform mat4  modelview_mat;\nuniform mat4  projection_mat;\nuniform vec4  color;\nuniform float opacity;\n```", "```py\nvarying vec4 frag_color;\nvarying vec2 tex_coord0;\n\nuniform sampler2D texture0;\n```", "```py\nvoid main(void)\n{\n    vec4 pos = vec4(vPosition.xy, 0.0, 1.0);\n    gl_Position = projection_mat * modelview_mat * pos;\n}\n```", "```py\nvoid main(void)\n{\n    gl_FragColor = vec4(1.0, 0.0, 0.5, 1.0);\n}\n```", "```py\nvoid main(void)\n{\n    float r = gl_FragCoord.x / 255.0;\n    float g = gl_FragCoord.y / 255.0;\n    float b = 0.5 * (r + g);\n    gl_FragColor = vec4(r, g, b, 1.0);\n}\n```", "```py\nfmt = (\n    (b'vPosition', 2, 'float'),\n    (b'vColor', 3, 'float'),\n)\n\nvertices = (\n    0,   0,   0.462, 0.839, 1,\n    255, 0,   0.831, 0.984, 0.474,\n    255, 255, 1,     0.541, 0.847,\n    0,   255, 1,     0.988, 0.474,\n)\n\nindices = (0, 1, 2, 2, 3, 0)\n```", "```py\nattribute vec3 vColor;\n\nvoid main(void)\n{\n    frag_color = vec4(vColor.rgb, 1.0);\n    vec4 pos = vec4(vPosition.xy, 0.0, 1.0);\n    gl_Position = projection_mat * modelview_mat * pos;\n}\n```", "```py\nvoid main(void)\n{\n    gl_FragColor = frag_color;\n}\n```", "```py\nfmt = (\n    (b'vPosition', 2, 'float'),\n    (b'vTexCoords0', 2, 'float'),\n)\n\nvertices = (\n    0,   0,   0, 1,\n    255, 0,   1, 1,\n    255, 255, 1, 0,\n    0,   255, 0, 0,\n)\n```", "```py\nfrom kivy.core.image import Image\n\nwith self.canvas:\n    Mesh(fmt=fmt, mode='triangles',\n         indices=indices, vertices=vertices,\n         texture=Image('kivy.png').texture)\n```", "```py\nvoid main(void)\n{\n    tex_coord0 = vTexCoords0;\n    vec4 pos = vec4(vPosition.xy, 0.0, 1.0);\n    gl_Position = projection_mat * modelview_mat * pos;\n}\n```", "```py\nvoid main(void)\n{\n    gl_FragColor = texture2D(texture0, tex_coord0);\n}\n```", "```py\nfrom kivy.base import EventLoop\nfrom kivy.clock import Clock\n\nclass StarfieldApp(App):\n    def build(self):\n        EventLoop.ensure_window()\n        return Starfield()\n\n    def on_start(self):\n        Clock.schedule_interval(self.root.update_glsl,\n                                60 ** -1)\n```", "```py\nfrom kivy.core.image import Image\nfrom kivy.graphics.instructions import RenderContext\nfrom kivy.uix.widget import Widget\n\nNSTARS = 1000\n\nclass Starfield(Widget):\n    def __init__(self, **kwargs):\n        Widget.__init__(self, **kwargs)\n        self.canvas = RenderContext(use_parent_projection=True)\n        self.canvas.shader.source = 'starfield.glsl'\n\n        self.vfmt = (\n            (b'vCenter',     2, 'float'),\n            (b'vScale',      1, 'float'),\n            (b'vPosition',   2, 'float'),\n            (b'vTexCoords0', 2, 'float'),\n        )\n\n        self.vsize = sum(attr[1] for attr in self.vfmt)\n\n        self.indices = []\n        for i in range(0, 4 * NSTARS, 4):\n            self.indices.extend((\n                i, i + 1, i + 2, i + 2, i + 3, i))\n\n        self.vertices = []\n        for i in range(NSTARS):\n            self.vertices.extend((\n                0, 0, 1, -24, -24, 0, 1,\n                0, 0, 1,  24, -24, 1, 1,\n                0, 0, 1,  24,  24, 1, 0,\n                0, 0, 1, -24,  24, 0, 0,\n            ))\n\n        self.texture = Image('star.png').texture\n\n        self.stars = [Star(self, i) for i in range(NSTARS)]\n```", "```py\nimport math\nfrom random import random\n\nclass Star:\n    angle = 0\n    distance = 0\n    size = 0.1\n\n    def __init__(self, sf, i):\n        self.sf = sf\n        self.base_idx = 4 * i * sf.vsize\n        self.reset()\n\n    def reset(self):\n        self.angle = 2 * math.pi * random()\n        self.distance = 90 * random() + 10\n        self.size = 0.05 * random() + 0.05\n```", "```py\nfrom kivy.graphics import Mesh\n\ndef update_glsl(self, nap):\n    x0, y0 = self.center\n    max_distance = 1.1 * max(x0, y0)\n\n    for star in self.stars:\n        star.distance *= 2 * nap + 1\n        star.size += 0.25 * nap\n\n        if (star.distance > max_distance):\n            star.reset()\n        else:\n            star.update(x0, y0)\n\n    self.canvas.clear()\n\n    with self.canvas:\n        Mesh(fmt=self.vfmt, mode='triangles',\n             indices=self.indices, vertices=self.vertices,\n             texture=self.texture)\n```", "```py\ndef iterate(self):\n    return range(self.j,\n                 self.j + 4 * self.sf.vsize,\n                 self.sf.vsize)\n\ndef update(self, x0, y0):\n    x = x0 + self.distance * math.cos(self.angle)\n    y = y0 + self.distance * math.sin(self.angle)\n\n    for i in self.iterate():\n        self.sf.vertices[i:i + 3] = (x, y, self.size)\n```", "```py\nattribute vec2  vCenter;\nattribute float vScale;\n\nvoid main(void)\n{\n    tex_coord0 = vTexCoords0;\n    mat4 move_mat = mat4\n        (1.0, 0.0, 0.0, vCenter.x,\n         0.0, 1.0, 0.0, vCenter.y,\n         0.0, 0.0, 1.0, 0.0,\n         0.0, 0.0, 0.0, 1.0);\n    vec4 pos = vec4(vPosition.xy * vScale, 0.0, 1.0) * move_mat;\n    gl_Position = projection_mat * modelview_mat * pos;\n}\n```", "```py\nvoid main(void)\n{\n    gl_FragColor = texture2D(texture0, tex_coord0);\n}\n```"]