- en: Chapter 38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduction to Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: 38.1 What is Object-Oriented Programming?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Part VII](part07.html) all the programs that you read or even wrote, were
    using subprograms (functions and void functions). This programming style is called
    procedural programming and most of the time it is just fine! But when it comes
    to writing large programs, or working in a big company such as Microsoft, Facebook,
    or Google, object-oriented programming is a must use programming style!
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming, usually referred to as OOP, is a style of programming
    that focuses on objects. In OOP, data and functionality are combined and encapsulated
    inside something called an object. Applying object-oriented programming principles
    enables you to maintain your code more easily, and write code that can be easily
    understood and used by others.
  prefs: []
  type: TYPE_NORMAL
- en: What does the statement “OOP focuses on objects” truly mean? Let's consider
    an example from the real world. Imagine a car. How would you describe a particular
    car? It has specific attributes, such as the brand, the model, the color, and
    the license plate. Additionally, there are specific actions this car can perform,
    or have performed on it. For instance, someone can turn it on or off, accelerate
    or apply the brakes, or park.
  prefs: []
  type: TYPE_NORMAL
- en: In OOP, this car can be represented as an object with specific attributes (commonly
    referred to as fields) that can perform specific actions (referred to as methods).
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, you may now be asking yourself, “How can I create objects in the
    first place?” The answer is simple! All you need is a class. A class resembles
    a "rubber inkpad stamp”! In Figure 38-1 there is a stamp (this is the class) with
    four empty fields and three actions (methods).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter38-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38-1 A class resembles a “rubber inkpad stamp”
  prefs: []
  type: TYPE_NORMAL
- en: Someone who uses this stamp can stamp-out many cars (these are the objects).
    In Figure 38-2, for example, a little boy stamped-out those two cars and then
    he colored them and filled out each car's fields with specific attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter38-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38-2 You can use the same rubber stamp as a template to stamp-out many
    cars
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The process of creating a new object (a new instance of
    a class) is called “instantiation”.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)A class is a template and every object is created from a
    class. Each class should be designed to carry out one, and only one, task! This
    is why, most of the time, more than one class is used to build an entire application!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In OOP, the rubber stamp is the class. You can use the same
    class as a template to create (instantiate) many objects!'
  prefs: []
  type: TYPE_NORMAL
- en: 38.2 Classes and Objects in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have a grasp of the theoretical concepts behind classes and objects,
    let's dive into writing a real class in Python! The following code fragment creates
    the class Car. There are four fields and three methods within the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'class Car:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Define four fields'
  prefs: []
  type: TYPE_NORMAL
- en: brand = ""
  prefs: []
  type: TYPE_NORMAL
- en: model = ""
  prefs: []
  type: TYPE_NORMAL
- en: color = ""
  prefs: []
  type: TYPE_NORMAL
- en: licensePlate = ""
  prefs: []
  type: TYPE_NORMAL
- en: '#Define method turnOn()'
  prefs: []
  type: TYPE_NORMAL
- en: 'def turnOn(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("The car turns on")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Define method turnOff()'
  prefs: []
  type: TYPE_NORMAL
- en: 'def turnOff(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("The car turns off")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Define method accelerate()'
  prefs: []
  type: TYPE_NORMAL
- en: 'def accelerate(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("The car accelerates")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And here''s an interesting tidbit: Fields and methods within classes are essentially
    just ordinary variables and subprograms respectively!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In Object-Oriented Programming (OOP), the terms used are
    “methods” (instead of “functions”) and “void methods” (instead of “void functions”).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The class Car is just a template. No objects are created
    yet!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)No need to wonder what this self keyword is, yet! It will
    be explained thoroughly in the next section ([Section 38.3](#toc_3)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The name of a class should follow the Upper Camel Case convention
    as well as all the rules for naming variables presented in [Section 5.4](chapter05.html#toc_4).'
  prefs: []
  type: TYPE_NORMAL
- en: To create two objects (or in other words to create two instances of the class
    Car), you need the following two lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: car1 = Car()
  prefs: []
  type: TYPE_NORMAL
- en: car2 = Car()
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)An object is nothing more than an instance of a class, and
    this is why, many times, it may be called a “class instance” or “class object”.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)When you create a new object (a new instance of a class)
    the process is called “instantiation”.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have created (instantiated) two objects, you can assign values
    to their fields. To do so, use the dot notation. This means you need to write
    the name of the object, followed by a dot and then the name of the field or method
    you want to access. The following code fragment creates two objects, car1 and
    car2, and assigns values to their fields.
  prefs: []
  type: TYPE_NORMAL
- en: car1 = Car()
  prefs: []
  type: TYPE_NORMAL
- en: car2 = Car()
  prefs: []
  type: TYPE_NORMAL
- en: car1.brand = "Mazda"
  prefs: []
  type: TYPE_NORMAL
- en: car1.model = "6"
  prefs: []
  type: TYPE_NORMAL
- en: car1.color = "Gray"
  prefs: []
  type: TYPE_NORMAL
- en: car1.licensePlate = "AB1234"
  prefs: []
  type: TYPE_NORMAL
- en: car2.brand = "Ford"
  prefs: []
  type: TYPE_NORMAL
- en: car2.model = "Focus"
  prefs: []
  type: TYPE_NORMAL
- en: car2.color = "Blue"
  prefs: []
  type: TYPE_NORMAL
- en: car2.licensePlate = "XY9876"
  prefs: []
  type: TYPE_NORMAL
- en: 'print(car1.brand)    #It displays: Mazda'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(car2.brand)    #It displays: Ford'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In the previous example, car1 and car2 are two instances
    of the same class. Using car1 and car2 with dot notation allows you to refer to
    only one instance at a time. If you make any changes to one instance they will
    not affect the other instance!'
  prefs: []
  type: TYPE_NORMAL
- en: The next code fragment calls the methods turnOff() and accelerate() of the objects
    car1 and car2 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: car1.turnOff()
  prefs: []
  type: TYPE_NORMAL
- en: car2.accelerate()
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)A class is a template that cannot be executed, whereas
    an object is an instance of a class that can be executed!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)One class can be used to create (instantiate) as many
    objects as you want!'
  prefs: []
  type: TYPE_NORMAL
- en: 38.3 The Constructor and the Keyword self
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, there is a method that has a special role and is called constructor.
    The constructor method is executed automatically whenever an instance of a class
    (an object) is created. Any initialization that you want to do with your object
    can be done within this method. In Python, the constructor is a method whose name
    is __init__().
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that there is a double underscore at the beginning
    of the name and another double underscore at the end of the name __init__().'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the following example. The constructor method __init__() is called
    twice automatically, once when the object p1 is created and once when the object
    p2 is created, which means that the message “An object was created” is displayed
    twice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.3a'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Person:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("An object was created")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: p1 = Person()    #Create object p1
  prefs: []
  type: TYPE_NORMAL
- en: p2 = Person()    #Create object p2
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, in the formal argument list of the __init__() method,
    there is an argument named self. In object-oriented programming (OOP) with Python,
    this argument serves as a reference variable that points to the current object.
    Take a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.3b'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Person:'
  prefs: []
  type: TYPE_NORMAL
- en: name = None
  prefs: []
  type: TYPE_NORMAL
- en: age = None
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("An object was created")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'def sayInfo(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("I am", self.name)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("I am", self.age, "years old")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'person1 = Person()   #Create object person1'
  prefs: []
  type: TYPE_NORMAL
- en: '#Assign values to its fields'
  prefs: []
  type: TYPE_NORMAL
- en: person1.name = "John"
  prefs: []
  type: TYPE_NORMAL
- en: person1.age = 14
  prefs: []
  type: TYPE_NORMAL
- en: 'person1.sayInfo()   #Call the method sayInfo() of the object person1'
  prefs: []
  type: TYPE_NORMAL
- en: Even though there is no actual argument in the statement person1.sayInfo() where
    the method is called, a formal argument (the keyword self) does exist in the statement
    def sayInfo(self) where the method is defined. Obviously, it would be more correct
    if that call were made as person1.sayInfo(person1). Written this way, it would
    make better sense! This actual argument person1 would be passed (assigned) to
    the formal argument self! Yes, this is probably more correct, but always keep
    in mind that Python is a “write less, do more” language! So there is no need for
    you to pass the object itself. Python will do it for you!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you don''t remember what a formal or actual argument
    is, please re-read [Section 35.5](chapter35.html#toc_5).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that when declaring the fields name and age outside
    of a method (but within the class), you need to write the field name without dot
    notation. To access the fields, however, from within a method, you must use dot
    notation (for example, self.name and self.age).'
  prefs: []
  type: TYPE_NORMAL
- en: A question that is probably spinning around in your head right now is “Why is
    it necessary to refer to these fields name and age within the method sayInfo()
    as self.name and self.age? Is it really necessary to use the keyword self in front
    of them?” A simple answer is that there is always a possibility that you could
    have two extra local variables of the same name (name and age) within the method.
    So you need a way to distinguish among those local variables and the object's
    fields. If you are confused, try to understand the following example. There is
    a field b within the class MyClass and a local variable b within the method myMethod()
    of the class. The self keyword is used to differentiate between the local variable
    and the field.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.3c'
  prefs: []
  type: TYPE_NORMAL
- en: 'class FooClass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'b = None   #This is a field'
  prefs: []
  type: TYPE_NORMAL
- en: 'def myMethod(self):'
  prefs: []
  type: TYPE_NORMAL
- en: b = "***"    #This is a local variable
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(b, self.b, b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: x = FooClass()    #Create object x
  prefs: []
  type: TYPE_NORMAL
- en: 'x.b = "Hello!"   #Assign a value to its field'
  prefs: []
  type: TYPE_NORMAL
- en: 'x.myMethod()     #It displays: *** Hello! ***'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The keyword self can be used to refer to any member (field
    or method) of a class from within a method of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 38.4 Passing Initial Values to the Constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any method, even the constructor method __init__(), can have formal arguments
    within its formal argument list. For example, in the constructor method you can
    use arguments to pass some initial values to the object during creation. The example
    that follows creates four objects, each of which represents a Titan^([[24]](footnotes.html#Endnote_24))
    from Greek mythology.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.4a'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Titan:'
  prefs: []
  type: TYPE_NORMAL
- en: name = None
  prefs: []
  type: TYPE_NORMAL
- en: gender  = None
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, n, g):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = n
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self.gender = g
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'titan1 = Titan("Cronus", "male")   #Create object titan1'
  prefs: []
  type: TYPE_NORMAL
- en: titan2 = Titan("Oceanus", "male")  #Create object titan2
  prefs: []
  type: TYPE_NORMAL
- en: 'titan3 = Titan("Rhea", "female")   #Create object titan3'
  prefs: []
  type: TYPE_NORMAL
- en: 'titan4 = Titan("Phoebe", "female") #Create object titan4'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that, even though there are three formal arguments
    in the constructor, there are only two actual arguments in the statements that
    call the constructor. Since Python is a “do more, write less” computer language,
    there is no need to pass the object itself. Python will do it for you!'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, it is legal to have one field and one local variable (or even a formal
    argument) with the same name. So, the class Titan can also be written as follows
  prefs: []
  type: TYPE_NORMAL
- en: 'class Titan:'
  prefs: []
  type: TYPE_NORMAL
- en: name = None
  prefs: []
  type: TYPE_NORMAL
- en: gender = None
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, gender ):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name  #Fields and arguments can have the same name
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self.gender = gender
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The variables name and gender are arguments used to pass values to the constructor
    whereas self.name and self.gender are fields used to store values within the object.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, in Python, you can simplify class Titan even more. The example
    that follows uses a simplified version of the class Titan.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.4b'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Titan:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, gender):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self.gender = gender
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'titan1 = Titan("Cronus", "male")   #Create object titan1'
  prefs: []
  type: TYPE_NORMAL
- en: titan2 = Titan("Oceanus", "male")  #Create object titan2
  prefs: []
  type: TYPE_NORMAL
- en: 'titan3 = Titan("Rhea", "female")   #Create object titan3'
  prefs: []
  type: TYPE_NORMAL
- en: 'titan4 = Titan("Phoebe", "female") #Create object titan4'
  prefs: []
  type: TYPE_NORMAL
- en: print(titan1.name, "-", titan1.gender)
  prefs: []
  type: TYPE_NORMAL
- en: print(titan2.name, "-", titan2.gender)
  prefs: []
  type: TYPE_NORMAL
- en: print(titan3.name, "-", titan3.gender)
  prefs: []
  type: TYPE_NORMAL
- en: print(titan4.name, "-", titan4.gender)
  prefs: []
  type: TYPE_NORMAL
- en: 38.5 Class Fields vs Instance Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until this point, what you've learned is that it is not too bad to have fields
    declared outside of the constructor, as shown in the program that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'class HistoryEvents:'
  prefs: []
  type: TYPE_NORMAL
- en: day = None  #This field is declared outside of the
  prefs: []
  type: TYPE_NORMAL
- en: '#constructor. It is called "class field"'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Define the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Object Instantiation")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: h1 = HistoryEvents()        #Create object h1
  prefs: []
  type: TYPE_NORMAL
- en: h1.day = "4th of July"
  prefs: []
  type: TYPE_NORMAL
- en: h2 = HistoryEvents()        #Create object h2
  prefs: []
  type: TYPE_NORMAL
- en: h2.day = "28th of October"
  prefs: []
  type: TYPE_NORMAL
- en: print(h1.day)
  prefs: []
  type: TYPE_NORMAL
- en: print(h2.day)
  prefs: []
  type: TYPE_NORMAL
- en: You have also learned that you can rewrite this code and declare the field day
    inside the constructor, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'class HistoryEvents:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, day):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Object Intantiation")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self.day = day  #This field is declared inside the
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#constructor. It is called "instance field"'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'h1 = HistoryEvents("4th of July")     #Create object h1'
  prefs: []
  type: TYPE_NORMAL
- en: 'h2 = HistoryEvents("28th of October") #Create object h2'
  prefs: []
  type: TYPE_NORMAL
- en: print(h1.day)
  prefs: []
  type: TYPE_NORMAL
- en: print(h2.day)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)When a field is declared outside of the constructor, it
    is called a “class field” but when it is declared inside the constructor, it is
    called an “instance field”.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)A class field is shared by all instances of the class whereas
    an instance field is unique to each instance.'
  prefs: []
  type: TYPE_NORMAL
- en: So, which programming style is better? They both seem to be okay! Well, the
    second one is not just better—you can say that this is the right way to write
    a class! Why? Because, in some cases, when mutable data structures (such as lists
    and dictionaries) are used as class fields, they may produce undesirable results.
    Take a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'class HistoryEvents:'
  prefs: []
  type: TYPE_NORMAL
- en: 'events = []         #Class field shared by all instances'
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, day):'
  prefs: []
  type: TYPE_NORMAL
- en: self.day = day  #Instance field unique to each instance
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: h1 = HistoryEvents("4th of July")  #Create object h1
  prefs: []
  type: TYPE_NORMAL
- en: '#Assign values to the fields of h1'
  prefs: []
  type: TYPE_NORMAL
- en: 'h1.events.append("1776: Declaration of Independence in United States")'
  prefs: []
  type: TYPE_NORMAL
- en: 'h1.events.append("1810: French troops occupy Amsterdam")'
  prefs: []
  type: TYPE_NORMAL
- en: h2 = HistoryEvents("28th of October")  #Create object h2
  prefs: []
  type: TYPE_NORMAL
- en: '#Assign values to the fields of h2'
  prefs: []
  type: TYPE_NORMAL
- en: 'h2.events.append("969: Byzantine troops occupy Antioch")'
  prefs: []
  type: TYPE_NORMAL
- en: 'h2.events.append("1940: Ohi Day in Greece")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in h1.events:'
  prefs: []
  type: TYPE_NORMAL
- en: print(event)
  prefs: []
  type: TYPE_NORMAL
- en: You may expect that the last for-loop displays only the two events of the 4^(th)
    of July. Your thinking is correct, but the output result proves you wrong! The
    last for-loop displays four events, as shown in Figure 38-3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter38-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38-3 When mutable data types are used as class fields, they may produce
    undesirable results
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)List events is a mutable data structure. In Python, mutable
    data structures should never be used as a class field, since they produces undesirable
    results.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)It is advised to utilize as few class fields as possible!
    Use instance fields instead! The less the number of class fields the better.'
  prefs: []
  type: TYPE_NORMAL
- en: The next example, is the correct version of the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'class HistoryEvents:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, day):'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.day = day   #Instance field unique to each instance'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'self.events = [] #Instance field unique to each instance'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'h1 = HistoryEvents("4th of July")     #Create object h1'
  prefs: []
  type: TYPE_NORMAL
- en: '#Assign values to the fields of h1'
  prefs: []
  type: TYPE_NORMAL
- en: 'h1.events.append("1776: Declaration of Independence in United States")'
  prefs: []
  type: TYPE_NORMAL
- en: 'h1.events.append("1810: French troops occupy Amsterdam")'
  prefs: []
  type: TYPE_NORMAL
- en: 'h2 = HistoryEvents("28th of October") #Create object h2'
  prefs: []
  type: TYPE_NORMAL
- en: '#Assign values to the fields of h2'
  prefs: []
  type: TYPE_NORMAL
- en: 'h2.events.append("969: Byzantine troops occupy Antioch")'
  prefs: []
  type: TYPE_NORMAL
- en: 'h2.events.append("1940: Ohi Day in Greece")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in h1.events:'
  prefs: []
  type: TYPE_NORMAL
- en: print(event)
  prefs: []
  type: TYPE_NORMAL
- en: 38.6 Getter and Setter Methods vs Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A field is a variable declared directly in a class. The principles of the object-oriented
    programming, though, state that the data of a class should be hidden and safe
    from accidental alteration. Think that one day you will probably be writing classes
    that other programmers will use in their programs. So, you don't want them to
    know what is inside your classes! The internal operation of your classes should
    be kept hidden from the outside world. By not exposing a field, you manage to
    hide the internal implementation of your class. Fields should be kept private
    to a class and accessed through get and set methods (or through properties).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Generally speaking, programmers should use fields only for
    data that have private or protected accessibility. In Java, or C# you can set
    a field as private or protected using special keywords.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand all of this new stuff through an example. Suppose you
    write the following class that converts a degrees Fahrenheit temperature into
    its degrees Celsius equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.6a'
  prefs: []
  type: TYPE_NORMAL
- en: 'class FahrenheitToCelsius:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, value):'
  prefs: []
  type: TYPE_NORMAL
- en: self.temperature = value
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#This method gets the temperature'
  prefs: []
  type: TYPE_NORMAL
- en: 'def getTemperature(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return 5.0 / 9.0 * (self.temperature - 32.0)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = FahrenheitToCelsius(-68)   #Create object x'
  prefs: []
  type: TYPE_NORMAL
- en: print(x.getTemperature())
  prefs: []
  type: TYPE_NORMAL
- en: This class is almost perfect but has a main disadvantage. It doesn't take into
    consideration that a temperature cannot go below −459.67 degrees Fahrenheit (−273.15
    degrees Celsius). This temperature is called absolute zero. So a novice programmer
    who uses your class and knows absolutely nothing about physics, might pass a value
    of −500 degrees Fahrenheit to the constructor, as shown in the code fragment that
    follows
  prefs: []
  type: TYPE_NORMAL
- en: 'x = FahrenheitToCelsius(-500)   #Create object x'
  prefs: []
  type: TYPE_NORMAL
- en: print(x.getTemperature())
  prefs: []
  type: TYPE_NORMAL
- en: Even though the program can run perfectly well and display a value of −295.55
    degrees Celsius, unfortunately this temperature cannot exist in the entire universe!
    So a slightly different version of this class might partially solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.6b'
  prefs: []
  type: TYPE_NORMAL
- en: 'class FahrenheitToCelsius:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, value):'
  prefs: []
  type: TYPE_NORMAL
- en: self.setTemperature(value)  #Use a method to set the value of the field temperature
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#This method gets the temperature'
  prefs: []
  type: TYPE_NORMAL
- en: 'def getTemperature(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return 5.0 / 9.0 * (self.temperature - 32.0)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#This method sets the temperature'
  prefs: []
  type: TYPE_NORMAL
- en: 'def setTemperature(self, value):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if value >= -459.67:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self.temperature = value
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: raise ValueError("There is no temperature below -459.67")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = FahrenheitToCelsius(-50)   #Create object x. This calls the constructor
    which,'
  prefs: []
  type: TYPE_NORMAL
- en: '#in turn, calls the setter.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(x.getTemperature())
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The raise statement forces the program to throw an exception
    (a runtime error) causing the flow of execution to stop.'
  prefs: []
  type: TYPE_NORMAL
- en: This time, a method named setTemperature() is used to set the value of the field
    temperature. This is better, but not exactly perfect, because the programmer must
    be careful and always remember to use this method each time they wish to change
    the value of the field temperature. The problem is that the value of the field
    temperature can still be directly changed using its name, as shown in the code
    fragment that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'x = FahrenheitToCelsius(-50) #Create object x'
  prefs: []
  type: TYPE_NORMAL
- en: print(x.getTemperature())
  prefs: []
  type: TYPE_NORMAL
- en: x.setTemperature(-65)        #This is okay!
  prefs: []
  type: TYPE_NORMAL
- en: print(x.getTemperature())
  prefs: []
  type: TYPE_NORMAL
- en: 'x.temperature = -500         #Unfortunately, this is still permitted!'
  prefs: []
  type: TYPE_NORMAL
- en: print(x.getTemperature())
  prefs: []
  type: TYPE_NORMAL
- en: This is where a property should be used! A property is a class member that provides
    a flexible mechanism to read, write, or compute the value of a field that you
    want to keep private. Properties expose fields, but hide implementation!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.6c'
  prefs: []
  type: TYPE_NORMAL
- en: 'class FahrenheitToCelsius:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, value):'
  prefs: []
  type: TYPE_NORMAL
- en: self.temperature = value  #Property is initialized. This calls the setter
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'def getTemperature(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return 5.0 / 9 * (self._temperature - 32)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'def setTemperature(self, value):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if value >= -459.67:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self._temperature = value
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: raise ValueError("There is no temperature below -459.67")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Define a property'
  prefs: []
  type: TYPE_NORMAL
- en: temperature = property(getTemperature, setTemperature)
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = FahrenheitToCelsius(-50)   #Create object x. This calls the constructor
    which,'
  prefs: []
  type: TYPE_NORMAL
- en: '#in turn, calls the setter.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print(x.temperature)     #This calls the getter'
  prefs: []
  type: TYPE_NORMAL
- en: x.temperature = -65      #This calls the setter.
  prefs: []
  type: TYPE_NORMAL
- en: 'print(x.temperature)     #This calls the getter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'x.temperature = -500     #This calls the setter and throws an error'
  prefs: []
  type: TYPE_NORMAL
- en: print(x.temperature)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note the underscore ( _ ) at the beginning of the field
    temperature. In Python, an underscore at the beginning of a variable name can
    be used to denote a “private field”.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what does the statement temperature = property(getTemperature, setTemperature)
    do anyway?
  prefs: []
  type: TYPE_NORMAL
- en: When a statement tries to access the value of the field temperature, the getTemperature()
    method is called automatically and similarly, when a statement tries to assign
    a value to the field temperature the setTemperature() method is called automatically!
    So, everything seems to be okay now! But is it, really?
  prefs: []
  type: TYPE_NORMAL
- en: One last thing can be done to make things even better! You can completely get
    rid of the methods getTemperature() and setTemperature() because you don't want
    to have two ways to access the value of the field temperature, as shown in the
    code fragment that follows
  prefs: []
  type: TYPE_NORMAL
- en: x = FahrenheitToCelsius(0)  #Create object x
  prefs: []
  type: TYPE_NORMAL
- en: '#There are still two ways to access the value of the field _temperature'
  prefs: []
  type: TYPE_NORMAL
- en: x.setTemperature(-100)  #Use the method
  prefs: []
  type: TYPE_NORMAL
- en: x.temperature = -100    #Use the property
  prefs: []
  type: TYPE_NORMAL
- en: In order to completely get rid of the methods getTemperature() and setTemperature()
    you can use some of the decorators that Python supports.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.6d'
  prefs: []
  type: TYPE_NORMAL
- en: 'class FahrenheitToCelsius:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, value):'
  prefs: []
  type: TYPE_NORMAL
- en: self.temperature = value    #Property is initialized. This calls the setter
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Use the decorator @property to define the getter'
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def temperature(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return 5.0 / 9 * (self._temperature - 32)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Use the decorator @field_name.setter to define the setter'
  prefs: []
  type: TYPE_NORMAL
- en: '@temperature.setter'
  prefs: []
  type: TYPE_NORMAL
- en: 'def temperature(self, value):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if value >= -459.67:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self._temperature = value
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: raise ValueError("There is no temperature below -459.67")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: x = FahrenheitToCelsius(-50)  #Create object x. This calls the constructor which,
  prefs: []
  type: TYPE_NORMAL
- en: '#in turn, calls the setter.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(x.temperature)          #This calls the getter.
  prefs: []
  type: TYPE_NORMAL
- en: 'x.temperature = -65           #This calls the setter.'
  prefs: []
  type: TYPE_NORMAL
- en: print(x.temperature)          #This calls the getter.
  prefs: []
  type: TYPE_NORMAL
- en: x.temperature = -500          #This calls the setter and throws an error
  prefs: []
  type: TYPE_NORMAL
- en: print(x.temperature)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Please note that the two methods and the field share the
    same name, temperature.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)A decorator is a function that takes another function as
    an argument and returns a new, prettier version of that function. Decorators allow
    you to change the behavior or extend the functionality of a function without changing
    the function''s body.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 38.6-1 The Roman Numerals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Roman numerals are shown in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| Number | Roman Numeral |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | I |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | II |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | III |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | IV |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | V |'
  prefs: []
  type: TYPE_TB
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a class named Romans which includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a property named number. It will be used to get and set the value of a private
    field named _number in integer format. The setter must throw an error when the
    number is not recognized.
  prefs: []
  type: TYPE_NORMAL
- en: b)a property named roman. It will be used to get and set the value of the private
    field _number in Roman numeral format. The setter must throw an error when the
    Roman numeral is not recognized.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Using the class cited above, write a Python program that displays the Roman
    numeral that corresponds to the value of 3 as well as the number that corresponds
    to the Roman numeral value of “V”.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The getter and setter of the property number are very simple so there is nothing
    special to explain. The getter and setter of the property roman, however, need
    some explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The getter of the property roman can be written as follows
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the getter'
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def roman(self):'
  prefs: []
  type: TYPE_NORMAL
- en: if self._number == 1
  prefs: []
  type: TYPE_NORMAL
- en: return "I"
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elif self._number == 2
  prefs: []
  type: TYPE_NORMAL
- en: return "II"
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elif self._number == 3
  prefs: []
  type: TYPE_NORMAL
- en: return "III"
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elif self._number == 4
  prefs: []
  type: TYPE_NORMAL
- en: return "IV"
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elif self._number == 5
  prefs: []
  type: TYPE_NORMAL
- en: return "V"
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, since you now know many about dictionaries, you can use a better approach,
    as shown in the code fragment that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the getter'
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def roman(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'number2roman = {1: "I", 2: "II", 3: "III", 4: "IV", 5: "V"}'
  prefs: []
  type: TYPE_NORMAL
- en: return number2roman[self._number]
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, the setter can be as follows
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the setter'
  prefs: []
  type: TYPE_NORMAL
- en: '@roman.setter'
  prefs: []
  type: TYPE_NORMAL
- en: 'def roman(self, key):'
  prefs: []
  type: TYPE_NORMAL
- en: 'roman2number = {"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if key in roman2number:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self._number = roman2number[key]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: raise ValueError("Roman numeral not recognized")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.6-1'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Romans:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the getter'
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def number(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self._number
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Define the setter'
  prefs: []
  type: TYPE_NORMAL
- en: '@number.setter'
  prefs: []
  type: TYPE_NORMAL
- en: 'def number(self, value):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if value >= 1 and value <= 5:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self._number = value
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: raise ValueError("Number not recognized")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Define the getter'
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def roman(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'number2roman = {1: "I", 2: "II", 3: "III", 4: "IV", 5: "V"}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return number2roman[self._number]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Define the setter'
  prefs: []
  type: TYPE_NORMAL
- en: '@roman.setter'
  prefs: []
  type: TYPE_NORMAL
- en: 'def roman(self, key):'
  prefs: []
  type: TYPE_NORMAL
- en: 'roman2number = {"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if key in roman2number:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self._number = roman2number[key]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: raise ValueError("Roman numeral not recognized")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: x = Romans()        #Create object x
  prefs: []
  type: TYPE_NORMAL
- en: x.number = 3
  prefs: []
  type: TYPE_NORMAL
- en: 'print(x.number)     #It displays: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(x.roman)      #It displays: III'
  prefs: []
  type: TYPE_NORMAL
- en: x.roman = "V"
  prefs: []
  type: TYPE_NORMAL
- en: 'print(x.number)     #It displays: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(x.roman)      #It displays: V'
  prefs: []
  type: TYPE_NORMAL
- en: 38.7 Can a Method Call Another Method of the Same Class?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Section 36.2](chapter36.html#toc_2) you learned that a subprogram can call
    another subprogram. Obviously, the same applies when it comes to methods—a method
    can call another method of the same class! Methods are nothing more than subprograms
    after all! So, if you want a method to call another method of the same class you
    should use the keyword self in front of the method that you want to call (using
    dot notation) as shown in the example that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.7'
  prefs: []
  type: TYPE_NORMAL
- en: 'class JustAClass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def foo1(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("foo1 was called")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'self.foo2()     #Call foo2() using dot notation'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'def foo2(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("foo2 was called")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: x = JustAClass()
  prefs: []
  type: TYPE_NORMAL
- en: x.foo1()    #Call foo1() which, in turn, will call foo2()
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 38.7-1 Doing Math
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a class named DoingMath which includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a void method named square that accepts a number through its formal argument
    list and then calculates its square and displays the message “The square of XX
    is YY”, where XX and YY must be replaced by actual values.
  prefs: []
  type: TYPE_NORMAL
- en: b)a void method named squareRoot that accepts a number through its formal argument
    list and then calculates its square root and displays the message “The square
    root of XX is YY” where XX and YY must be replaced by actual values. However,
    if the number is less than zero, the method must display an error message.
  prefs: []
  type: TYPE_NORMAL
- en: c)a void method named displayResults that accepts a number through its formal
    argument list and then calls the methods square() and squareRoot() to display
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Using the class cited above, write a Python program that prompts the user
    to enter a number. The program must then display the root and the square root
    of that number.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is quite simple. The methods square(), squareRoot(), and displayResults()
    must have a formal argument within their formal argument list so as to accept
    a passed value. The solution is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.7-1'
  prefs: []
  type: TYPE_NORMAL
- en: from math import sqrt
  prefs: []
  type: TYPE_NORMAL
- en: 'class DoingMath:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def square(self, x):          #Argument x accepts passed value'
  prefs: []
  type: TYPE_NORMAL
- en: print("The square of", x, "is", x ** 2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'def squareRoot(self, x):     #Argument x accepts passed value'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x < 0:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Cannot calculate square root")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Square root of", x, "is", sqrt(x))
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'def displayResults(self, x): #Argument x accepts passed value'
  prefs: []
  type: TYPE_NORMAL
- en: self.square(x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self.squareRoot(x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: dm = DoingMath()
  prefs: []
  type: TYPE_NORMAL
- en: 'b = float(input("Enter a number: "))'
  prefs: []
  type: TYPE_NORMAL
- en: dm.displayResults(b)
  prefs: []
  type: TYPE_NORMAL
- en: 38.8 Class Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Class inheritance is one of the main concepts of OOP. It lets you write a class
    using another class as a base. When a class is based on another class, the programmers
    use to say “it inherits the other class”. The class that is inherited is called
    the parent class, the base class, or the superclass. The class that does the inheriting
    is called the child class, the derived class, or the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: A child class automatically inherits all the methods and fields of the parent
    class.  The best part, however, is that you can add additional characteristics
    (methods or fields) to the child class. Therefore, you use inheritance when you
    have to write several classes that share many common characteristics but aren't
    entirely identical. To do this, you work as follows. First, you write a parent
    class containing all the common characteristics. Next, you write child classes
    that inherit all those common characteristics from the parent class. Finally,
    you add any additional and unique characteristics, specific to each child class.
    Just as with humans, it's these additional and unique characteristics that set
    a child apart from its parent, right?
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that you want to write a program that keeps track of the teachers
    and students in a school. They have some characteristics in common, such as name
    and age, but they also have specific characteristics such as salary for teachers
    and final grade for students that are not in common. What you can do here is write
    a parent class named SchoolMember that contains all those characteristics that
    both teachers and students have in common. Then you can write two child classes
    named Teacher and Student, one for teachers and one for students. Both child classes
    can inherit the class SchoolMember but additional fields, named salary and finalGrade,
    must be added to the child classes Teacher and Student correspondingly.
  prefs: []
  type: TYPE_NORMAL
- en: The parent class SchoolMember is shown here
  prefs: []
  type: TYPE_NORMAL
- en: 'class SchoolMember:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, age):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self.age = age
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("A school member was initialized")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want a class to inherit the class SchoolMember, it must be defined as
    follows
  prefs: []
  type: TYPE_NORMAL
- en: 'class Name(SchoolMember):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, age [, …]):'
  prefs: []
  type: TYPE_NORMAL
- en: '#Call the constructor of the class SchoolMember'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: super().__init__(name, age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define additional fields for this class
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Additional statement or block of statements
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define additional methods and/or properties for this class
  prefs: []
  type: TYPE_NORMAL
- en: where Name is the name of the child class.
  prefs: []
  type: TYPE_NORMAL
- en: So, the class Teacher can be as follows
  prefs: []
  type: TYPE_NORMAL
- en: 'class Teacher(SchoolMember):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, age, salary):'
  prefs: []
  type: TYPE_NORMAL
- en: '#Call the constructor of the class SchoolMember'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: super().__init__(name, age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'self.salary = salary   #This is an additional field for this class'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("A teacher was initialized") #This is an additional statement for this
    constructor'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#This is an additional method for this class'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValues(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Name:", self.name)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Age:", self.age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Salary:", self.salary)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The statement super().__init__(name, age) calls the constructor
    of the class SchoolMember and initializes the fields name and age of the class
    Teacher.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the class Student can be as follows
  prefs: []
  type: TYPE_NORMAL
- en: 'class Student(SchoolMember):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, age, finalGrade):'
  prefs: []
  type: TYPE_NORMAL
- en: '#Call the constructor of the class SchoolMember'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: super().__init__(name, age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self.finalGrade = finalGrade  #This is an additional field for this class
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("A student was initialized") #This is an additional statement for this
    constructor'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#This is an additional method for this class'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValues(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Name:", self.name)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Age:", self.age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Final grade:", self.finalGrade)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The statement super().__init__(name, age) calls the constructor
    of the class SchoolMember and initializes the fields name and age of the class
    Student.'
  prefs: []
  type: TYPE_NORMAL
- en: The complete Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_38.8'
  prefs: []
  type: TYPE_NORMAL
- en: '#Define the class SchoolMember.'
  prefs: []
  type: TYPE_NORMAL
- en: 'class SchoolMember:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, age):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self.age = age
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("A school member was initialized")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Define the class Teacher. It inherits the class SchoolMember.'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Teacher(SchoolMember):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, age, salary):'
  prefs: []
  type: TYPE_NORMAL
- en: '#Call the constructor of the class SchoolMember'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: super().__init__(name, age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'self.salary = salary   #This is an additional field for this class'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("A teacher was initialized") #This is an additional statement for this
    constructor'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#This is an additional method for this class'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValues(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Name:", self.name)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Age:", self.age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Salary:", self.salary)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Define the class Student. It inherits the class SchoolMember.'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Student(SchoolMember):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name, age, finalGrade):'
  prefs: []
  type: TYPE_NORMAL
- en: '#Call the constructor of the class SchoolMember'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: super().__init__(name, age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: self.finalGrade = finalGrade  #This is an additional field for this class
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("A student was initialized") #This is an additional statement for this
    constructor'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#This is an additional method for this class'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValues(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Name:", self.name)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Age:", self.age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Final grade:", self.finalGrade)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: teacher1 = Teacher("Mr. John Scott", 43, 35000)
  prefs: []
  type: TYPE_NORMAL
- en: teacher2 = Teacher("Mrs. Ann Carter", 5, 32000)
  prefs: []
  type: TYPE_NORMAL
- en: student1 = Student("Peter Nelson", 14, "A")
  prefs: []
  type: TYPE_NORMAL
- en: student2 = Student("Helen Morgan", 13, "B")
  prefs: []
  type: TYPE_NORMAL
- en: teacher1.displayValues()
  prefs: []
  type: TYPE_NORMAL
- en: teacher2.displayValues()
  prefs: []
  type: TYPE_NORMAL
- en: student1.displayValues()
  prefs: []
  type: TYPE_NORMAL
- en: student2.displayValues()
  prefs: []
  type: TYPE_NORMAL
- en: '38.9 Review Questions: True/False'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose true or false for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Procedural programming is better than object-oriented programming when it
    comes to writing large programs.
  prefs: []
  type: TYPE_NORMAL
- en: 2)Object-oriented programming focuses on objects.
  prefs: []
  type: TYPE_NORMAL
- en: 3)An object combines data and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 4)Object-oriented programming enables you to maintain your code more easily
    but your code cannot be used easily by others.
  prefs: []
  type: TYPE_NORMAL
- en: 5)You can create an object without using a class.
  prefs: []
  type: TYPE_NORMAL
- en: 6)The process of creating a new instance of a class is called “installation”.
  prefs: []
  type: TYPE_NORMAL
- en: 7)In OOP, you always have to create at least two instances of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 8)The __init__() method is executed when an object is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 9)When you create two instances of the same class, the __init__() method of
    the class will be executed twice.
  prefs: []
  type: TYPE_NORMAL
- en: 10)When a field is declared outside of the constructor, it is called an “instance
    field”.
  prefs: []
  type: TYPE_NORMAL
- en: 11)A class field is shared by all instances of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 12)The principles of the object-oriented programming state that the data of
    a class should be hidden and safe from accidental alteration.
  prefs: []
  type: TYPE_NORMAL
- en: 13)A property is a class member that provides a flexible mechanism to read,
    write, or compute the value of a field.
  prefs: []
  type: TYPE_NORMAL
- en: 14)A property exposes the internal implementation of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 15)Class inheritance is one of the main concepts of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 16)When a class is inherited, it is called the “derived class”.
  prefs: []
  type: TYPE_NORMAL
- en: 17)A parent class automatically inherits all the methods and fields of the child
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 38.10 Review Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Do the following
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a class named Geometry that includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a method named rectangleArea that accepts the base and the height of a rectangle
    through its formal argument list and then calculates and returns its area.
  prefs: []
  type: TYPE_NORMAL
- en: b)a method named triangleArea that accepts the base and the height of a triangle
    through its formal argument list and then calculates and returns its area. It
    is given that
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter10-05.png)
  prefs: []
  type: TYPE_NORMAL
- en: ii)Using the class cited above, write a Python program that prompts the user
    to enter the side of a square, the base and the height of a rectangle, and the
    base and the height of a triangle, and then displays the area for each one of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 2)Do the following
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a class named Pet which includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a constructor
  prefs: []
  type: TYPE_NORMAL
- en: b)an instance field named kind
  prefs: []
  type: TYPE_NORMAL
- en: c)an instance field named legsNumber
  prefs: []
  type: TYPE_NORMAL
- en: d)a void method named startRunning that displays the message “Pet is running”
  prefs: []
  type: TYPE_NORMAL
- en: e)a void method named stopRunning that displays the message “Pet stopped”
  prefs: []
  type: TYPE_NORMAL
- en: ii)Write a Python program that creates two instances of the class Pet (for example,
    a dog and a monkey) and then calls some of their methods.
  prefs: []
  type: TYPE_NORMAL
- en: 3)Do the following
  prefs: []
  type: TYPE_NORMAL
- en: i)In the class Pet of the previous exercise
  prefs: []
  type: TYPE_NORMAL
- en: a)alter the fields kind and legsNumber to private fields _kind and _legsNumber
    correspondingly.
  prefs: []
  type: TYPE_NORMAL
- en: b)add a property named kind. It will be used to get and set the value of the
    field _kind. The setter must throw an error when the field is set to an empty
    value.
  prefs: []
  type: TYPE_NORMAL
- en: c)add a property named legsNumber. It will be used to get and set the value
    of the field _legsNumber. The setter must throw an error when the field is set
    to a negative value.
  prefs: []
  type: TYPE_NORMAL
- en: d)alter the constructor to accept initial values for the properties kind and
    legsNumber through its formal argument list.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Write a Python program that creates one instance of the class Pets (for example,
    a dog) and then calls both of its methods. Then try to set erroneous values for
    properties kind and legsNumber and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 4)Do the following
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a class named Box that includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a constructor that accepts initial values for three private fields named _width,
    _length, and _height through its formal argument list.
  prefs: []
  type: TYPE_NORMAL
- en: b)a void method named displayVolume that calculates and displays the volume
    of a box whose dimensions are _width, _length, and _height. It is given that
  prefs: []
  type: TYPE_NORMAL
- en: volume = width × length × height
  prefs: []
  type: TYPE_NORMAL
- en: c)a void method named displayDimensions that displays box's dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Using the class cited above, write a Python program that prompts the user
    to enter the dimensions of 30 boxes, and then displays their dimensions and their
    volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Create a list of 30 objects of the class Box.'
  prefs: []
  type: TYPE_NORMAL
- en: 5)In the class Box of the previous exercise add three properties named width,
    length, and height. They will be used to get and set the values of the fields
    _width, _length, and _height. The setters must throw an error when the corresponding
    field is set to a negative value or zero.
  prefs: []
  type: TYPE_NORMAL
- en: 6)Do the following
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a class named Cube that includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a constructor that accepts an initial value for a private field named _edge
    through its formal argument list.
  prefs: []
  type: TYPE_NORMAL
- en: b)a void method named displayVolume that calculates and displays the volume
    of a cube whose edge length is edge. It is given that
  prefs: []
  type: TYPE_NORMAL
- en: volume = edge³
  prefs: []
  type: TYPE_NORMAL
- en: c)a void method named displayOneSurface that calculates and displays the surface
    area of one side of a cube whose edge length is _edge.
  prefs: []
  type: TYPE_NORMAL
- en: d)a void method named displayTotalSurface that calculates and displays the total
    surface area of a cube whose edge length is _edge. It is given that
  prefs: []
  type: TYPE_NORMAL
- en: total surface = 6 × edge²
  prefs: []
  type: TYPE_NORMAL
- en: ii)Using the class cited above, write a Python program that prompts the user
    to enter the edge length of a cube, and then displays its volume, the surface
    area of one of its sides, and its total surface area.
  prefs: []
  type: TYPE_NORMAL
- en: 7)In the class Cube of the previous exercise add a property named edge. It will
    be used to get and set the value of the private field _edge. The setter must throw
    an error when the field is set to a negative value or zero.
  prefs: []
  type: TYPE_NORMAL
- en: 8)Do the following
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a class named Circle that includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a constructor and a private field named _radius with an initial value of −1.
  prefs: []
  type: TYPE_NORMAL
- en: b)a property named radius. It will be used to get and set the value of the field
    _radius. The getter must throw an error when the field has not yet been set, and
    the setter must throw an error when the field is set to a negative value or zero.
  prefs: []
  type: TYPE_NORMAL
- en: c)a method named getDiameter that calculates and returns the diameter of a circle
    whose radius is _radius. It is given that
  prefs: []
  type: TYPE_NORMAL
- en: diameter = 2 × radius
  prefs: []
  type: TYPE_NORMAL
- en: d)a method named getArea that calculates and returns the area of a circle whose
    radius is _radius. It is given that
  prefs: []
  type: TYPE_NORMAL
- en: area = 3.14 × radius²
  prefs: []
  type: TYPE_NORMAL
- en: e)a method named getPerimeter that calculates and returns the perimeter of a
    circle whose radius is _radius. It is given that
  prefs: []
  type: TYPE_NORMAL
- en: perimeter = 2 × 3.14 × radius
  prefs: []
  type: TYPE_NORMAL
- en: ii)Write a subprogram named displayMenu that displays the following menu.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Enter radius
  prefs: []
  type: TYPE_NORMAL
- en: 2)Display radius
  prefs: []
  type: TYPE_NORMAL
- en: 3)Display diameter
  prefs: []
  type: TYPE_NORMAL
- en: 4)Display area
  prefs: []
  type: TYPE_NORMAL
- en: 5)Display perimeter
  prefs: []
  type: TYPE_NORMAL
- en: 6)Exit
  prefs: []
  type: TYPE_NORMAL
- en: iii)Using the subprogram and the class cited above, write a Python program that
    displays the previously mentioned menu and prompts the user to enter a choice
    (of 1 to 6). If choice 1 is selected, the program must prompt the user to enter
    a radius. If choice 2 is selected, the program must display the radius entered
    in choice 1\. If choices 3, 4, or 5 are selected, the program must display the
    diameter, the area, or the perimeter correspondingly of a circle whose radius
    is equal to the radius entered in choice 1\. The process must repeat as many times
    as the user wishes.
  prefs: []
  type: TYPE_NORMAL
- en: 9)Assume that you work in a computer software company that is going to create
    a word processor application. You are assigned to write a class that will be used
    to provide information to the user.
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a class named Info that includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a property named userText. It will be used to get and set the value of a private
    field named _userText. The setter must throw an error when the field is set to
    an empty value.
  prefs: []
  type: TYPE_NORMAL
- en: b)a  method named getSpacesCount that returns the total number of spaces that
    property userText contains.
  prefs: []
  type: TYPE_NORMAL
- en: c)a  method named getWordsCount that returns the total number of words that
    property userText contains.
  prefs: []
  type: TYPE_NORMAL
- en: d)a method named getVowelsCount that returns the total number of vowels that
    property userText contains.
  prefs: []
  type: TYPE_NORMAL
- en: e)a method named getLettersCount that returns the  total number of characters
     (excluding spaces) that property userText contains.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Using the class cited above, write a testing program that prompts the user
    to enter a text and then displays all available information. Assume that the user
    enters only space characters or letters (uppercase or lowercase) and the words
    are separated by a single space character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: In a text of three words, there are two spaces, which means that the
    total number of words is one more than the total number of spaces. Count the total
    number of spaces, and then you can easily find the total number of words!'
  prefs: []
  type: TYPE_NORMAL
- en: '10)During the Cold War after World War II, messages were encrypted so that
    if the enemies intercepted them, they could not decrypt them without the decryption
    key. A very simple encryption algorithm is alphabetic rotation. The algorithm
    moves all letters N steps "up" in the alphabet, where N is the encryption key.
    For example, if the encryption key is 2, you can encrypt a message by replacing
    the letter A with the letter C, the letter B with the letter D, the letter C with
    the letter E, and so on.  Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a class named EncryptDecrypt that includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a constructor and a private field named _encrDecrKey with an initial value
    of −1.
  prefs: []
  type: TYPE_NORMAL
- en: b)a property named encrDecrKey. It will be used to get and set the value of
    the field _encrDecrKey. The getter must throw an error when the field has not
    yet been set, and the setter must throw an error when the field is not set to
    a value between 1 and 26.
  prefs: []
  type: TYPE_NORMAL
- en: c)a method named encrypt that accepts a message through its formal argument
    list and then returns the encrypted message.
  prefs: []
  type: TYPE_NORMAL
- en: d)a method named decrypt that accepts an encrypted message through its formal
    argument list and then returns the decrypted message.
  prefs: []
  type: TYPE_NORMAL
- en: 'ii)Write a subprogram named displayMenu that displays the following menu:'
  prefs: []
  type: TYPE_NORMAL
- en: 1)Enter encryption/decryption key
  prefs: []
  type: TYPE_NORMAL
- en: 2)Encrypt a message
  prefs: []
  type: TYPE_NORMAL
- en: 3)Decrypt a message
  prefs: []
  type: TYPE_NORMAL
- en: 4)Exit
  prefs: []
  type: TYPE_NORMAL
- en: iii)Using the subprogram and the class cited above, write a Python program that
    displays the menu previously mentioned and then prompts the user to enter a choice
    (of 1 to 4). If choice 1 is selected, the program must prompt the user to enter
    an encryption/decryption key. If choice 2 is selected, the program must prompt
    the user to enter a message and then display the encrypted message. If choice
    3 is selected, the program must prompt the user to enter an encrypted message
    and then display the decrypted message. The process must repeat as many times
    as the user wishes. Assume that the user enters only lowercase letters or a space
    for the message.
  prefs: []
  type: TYPE_NORMAL
- en: '11)Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a parent class named Vehicle that includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a constructor that accepts initial values for three instance fields named
    numberOfWheels, color, length, width, and height through its formal argument list.
  prefs: []
  type: TYPE_NORMAL
- en: b)two void methods named startEngine and stopEngine that display the messages
    “The engine started” and “The engine stopped”, correspondingly.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Write a child class named Car that inherits the class Vehicle. Additionally,
    it includes
  prefs: []
  type: TYPE_NORMAL
- en: a)a constructor with an additional instance field named bootCapacity and an
    initial value of zero.
  prefs: []
  type: TYPE_NORMAL
- en: b)a void method named turnWindshieldWipersOn that displays the message “The
    windshield wipers have been turned on!”.
  prefs: []
  type: TYPE_NORMAL
- en: iii)Write a child class named Motorcycle that inherits the class Vehicle. Additionally,
    it must include
  prefs: []
  type: TYPE_NORMAL
- en: a)a constructor with an additional instance field named hasLuggage and an initial
    value of False.
  prefs: []
  type: TYPE_NORMAL
- en: b)a void method named doAWheelie that displays the message “I am doing a wheelie!!!”
  prefs: []
  type: TYPE_NORMAL
- en: iv)Using the classes cited above, write a Python program that creates two instances
    of the class Car and one instance of the class Motorcycle, assigns some values
    to their fields, and then calls all of their methods.
  prefs: []
  type: TYPE_NORMAL
- en: '12)Alter the Python program of [Section 38.8 - Class Inheritance](#toc_10)
    (file_38.8) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: i)In the class SchoolMember, alter the fields name and age to private fields
    _name and _age correspondingly, and add getter and setter methods for both of
    them. The setter method of the field _name must throw an error when it is set
    to an empty value, whereas the setter method of the field _age must throw an error
    when it is set to a negative value or zero.
  prefs: []
  type: TYPE_NORMAL
- en: ii)In the class Teacher, alter the field salary to private field _salary, and
    add getter and setter methods for it. The setter method must throw an error when
    the field is set to a negative value.
  prefs: []
  type: TYPE_NORMAL
- en: iii)In the class Student, alter the field finalGrade to private field _finalGrade,
    and add getter and setter methods for it. The setter method must throw an error
    when the field is set to a value other than A, B, C, D, E, or F.
  prefs: []
  type: TYPE_NORMAL
- en: 13)Alter the Python program of the previous exercise so that, instead of getter
    and setter methods, it uses properties.
  prefs: []
  type: TYPE_NORMAL
