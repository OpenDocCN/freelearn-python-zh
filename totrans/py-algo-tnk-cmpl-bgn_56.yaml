- en: Chapter 38
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第38章
- en: Introduction to Object-Oriented Programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程简介
- en: 38.1 What is Object-Oriented Programming?
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.1 什么是面向对象编程？
- en: In [Part VII](part07.html) all the programs that you read or even wrote, were
    using subprograms (functions and void functions). This programming style is called
    procedural programming and most of the time it is just fine! But when it comes
    to writing large programs, or working in a big company such as Microsoft, Facebook,
    or Google, object-oriented programming is a must use programming style!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第七部分](part07.html)中，你阅读或甚至编写的所有程序都在使用子程序（函数和空函数）。这种编程风格被称为过程式编程，大多数情况下都很不错！但是，当涉及到编写大型程序，或者在像微软、Facebook或Google这样的大公司工作时，面向对象编程是必须使用的编程风格！
- en: Object-oriented programming, usually referred to as OOP, is a style of programming
    that focuses on objects. In OOP, data and functionality are combined and encapsulated
    inside something called an object. Applying object-oriented programming principles
    enables you to maintain your code more easily, and write code that can be easily
    understood and used by others.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程，通常简称为OOP，是一种关注对象的编程风格。在OOP中，数据和功能被组合并封装在称为对象的东西中。应用面向对象编程原则可以使你更容易地维护代码，并编写其他人可以轻松理解和使用的代码。
- en: What does the statement “OOP focuses on objects” truly mean? Let's consider
    an example from the real world. Imagine a car. How would you describe a particular
    car? It has specific attributes, such as the brand, the model, the color, and
    the license plate. Additionally, there are specific actions this car can perform,
    or have performed on it. For instance, someone can turn it on or off, accelerate
    or apply the brakes, or park.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: “面向对象编程关注对象”的声明真正意味着什么？让我们考虑一个现实世界的例子。想象一辆车。你会如何描述一辆特定的车？它有特定的属性，如品牌、型号、颜色和车牌。此外，这辆车可以执行特定的动作，或者有人对它执行了这些动作。例如，有人可以打开或关闭它，加速或刹车，或者停车。
- en: In OOP, this car can be represented as an object with specific attributes (commonly
    referred to as fields) that can perform specific actions (referred to as methods).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP中，这辆车可以表示为一个具有特定属性（通常称为字段）的对象，它可以执行特定的动作（称为方法）。
- en: Obviously, you may now be asking yourself, “How can I create objects in the
    first place?” The answer is simple! All you need is a class. A class resembles
    a "rubber inkpad stamp”! In Figure 38-1 there is a stamp (this is the class) with
    four empty fields and three actions (methods).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你现在可能正在问自己，“我如何首先创建对象？”答案是简单的！你需要的只是一个类。一个类就像一个“橡皮印泥章”！在图38-1中有一个章（这是类）和四个空字段以及三个动作（方法）。
- en: '![Image](img/chapter38-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter38-01.png)'
- en: Figure 38-1 A class resembles a “rubber inkpad stamp”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图38-1 一节课就像一个“橡皮印泥章”
- en: Someone who uses this stamp can stamp-out many cars (these are the objects).
    In Figure 38-2, for example, a little boy stamped-out those two cars and then
    he colored them and filled out each car's fields with specific attributes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个章的人可以印出很多汽车（这些都是对象）。例如，在图38-2中，一个小男孩印出了那两辆汽车，然后他为它们上色，并为每辆汽车的各个字段填充了特定的属性。
- en: '![Image](img/chapter38-02.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter38-02.png)'
- en: Figure 38-2 You can use the same rubber stamp as a template to stamp-out many
    cars
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图38-2 你可以使用相同的橡皮章作为模板来印出许多汽车
- en: '![](img/notice.jpg)The process of creating a new object (a new instance of
    a class) is called “instantiation”.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)创建一个新对象（类的新的实例）的过程被称为“实例化”。'
- en: '![](img/notice.jpg)A class is a template and every object is created from a
    class. Each class should be designed to carry out one, and only one, task! This
    is why, most of the time, more than one class is used to build an entire application!'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)类是一个模板，每个对象都是从一个类创建的。每个类都应该被设计来执行一个，并且只有一个任务！这就是为什么，大多数情况下，需要使用多个类来构建整个应用程序！'
- en: '![](img/notice.jpg)In OOP, the rubber stamp is the class. You can use the same
    class as a template to create (instantiate) many objects!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)在面向对象编程（OOP）中，橡皮章就是类。你可以使用相同的类作为模板来创建（实例化）许多对象！'
- en: 38.2 Classes and Objects in Python
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.2 Python中的类和对象
- en: Now that you have a grasp of the theoretical concepts behind classes and objects,
    let's dive into writing a real class in Python! The following code fragment creates
    the class Car. There are four fields and three methods within the class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了类和对象背后的理论概念，让我们深入编写一个真正的Python类！下面的代码片段创建了Car类。类中有四个字段和三个方法。
- en: 'class Car:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Car:'
- en: '#Define four fields'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '# 定义四个字段'
- en: brand = ""
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: brand = ""
- en: model = ""
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: model = ""
- en: color = ""
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: color = ""
- en: licensePlate = ""
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: licensePlate = ""
- en: '#Define method turnOn()'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '#Define method turnOn()'
- en: 'def turnOn(self):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'def turnOn(self):'
- en: print("The car turns on")
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("汽车开启")
- en: '#Define method turnOff()'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '#Define method turnOff()'
- en: 'def turnOff(self):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 'def turnOff(self):'
- en: print("The car turns off")
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("汽车关闭")
- en: '#Define method accelerate()'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '#Define method accelerate()'
- en: 'def accelerate(self):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'def accelerate(self):'
- en: print("The car accelerates")
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("汽车加速")
- en: 'And here''s an interesting tidbit: Fields and methods within classes are essentially
    just ordinary variables and subprograms respectively!'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的细节：类内的字段和方法本质上只是普通的变量和子程序！
- en: '![](img/notice.jpg)In Object-Oriented Programming (OOP), the terms used are
    “methods” (instead of “functions”) and “void methods” (instead of “void functions”).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)在面向对象编程（OOP）中，使用的术语是“方法”（而不是“函数”）和“void方法”（而不是“void函数”）。'
- en: '![](img/notice.jpg)The class Car is just a template. No objects are created
    yet!'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)Car类只是一个模板。目前还没有创建任何对象！'
- en: '![](img/notice.jpg)No need to wonder what this self keyword is, yet! It will
    be explained thoroughly in the next section ([Section 38.3](#toc_3)).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)无需现在就好奇这个self关键字是什么，它将在下一节（[第38.3节](#toc_3)）中详细解释。'
- en: '![](img/notice.jpg)The name of a class should follow the Upper Camel Case convention
    as well as all the rules for naming variables presented in [Section 5.4](chapter05.html#toc_4).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)类的名称应遵循大驼峰命名法，以及[第5.4节](chapter05.html#toc_4)中提到的所有变量命名规则。'
- en: To create two objects (or in other words to create two instances of the class
    Car), you need the following two lines of code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建两个对象（换句话说，创建Car类的两个实例），你需要以下两行代码。
- en: car1 = Car()
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: car1 = Car()
- en: car2 = Car()
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: car2 = Car()
- en: '![](img/notice.jpg)An object is nothing more than an instance of a class, and
    this is why, many times, it may be called a “class instance” or “class object”.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)对象不过是一个类的实例，这就是为什么它很多时候可能被称为“类实例”或“类对象”。'
- en: '![](img/remember.jpg)When you create a new object (a new instance of a class)
    the process is called “instantiation”.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![记住](img/remember.jpg)当你创建一个新的对象（类的新的实例）时，这个过程被称为“实例化”。'
- en: Now that you have created (instantiated) two objects, you can assign values
    to their fields. To do so, use the dot notation. This means you need to write
    the name of the object, followed by a dot and then the name of the field or method
    you want to access. The following code fragment creates two objects, car1 and
    car2, and assigns values to their fields.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了（实例化）两个对象，你可以为它们的字段赋值。为此，使用点表示法。这意味着你需要写出对象的名称，然后是一个点，然后是你想要访问的字段或方法的名称。以下代码片段创建了两个对象，car1和car2，并将值赋给它们的字段。
- en: car1 = Car()
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: car1 = Car()
- en: car2 = Car()
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: car2 = Car()
- en: car1.brand = "Mazda"
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: car1.brand = "Mazda"
- en: car1.model = "6"
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: car1.model = "6"
- en: car1.color = "Gray"
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: car1.color = "Gray"
- en: car1.licensePlate = "AB1234"
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: car1.licensePlate = "AB1234"
- en: car2.brand = "Ford"
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: car2.brand = "Ford"
- en: car2.model = "Focus"
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: car2.model = "Focus"
- en: car2.color = "Blue"
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: car2.color = "Blue"
- en: car2.licensePlate = "XY9876"
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: car2.licensePlate = "XY9876"
- en: 'print(car1.brand)    #It displays: Mazda'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(car1.brand)    #它显示：马自达'
- en: 'print(car2.brand)    #It displays: Ford'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(car2.brand)    #它显示：福特'
- en: '![](img/notice.jpg)In the previous example, car1 and car2 are two instances
    of the same class. Using car1 and car2 with dot notation allows you to refer to
    only one instance at a time. If you make any changes to one instance they will
    not affect the other instance!'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)在上面的例子中，car1和car2是同一类的两个实例。使用car1和car2的点表示法可以让你一次只引用一个实例。如果你对其中一个实例进行任何更改，它将不会影响另一个实例！'
- en: The next code fragment calls the methods turnOff() and accelerate() of the objects
    car1 and car2 respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: The next code fragment calls the methods turnOff() and accelerate() of the objects
    car1 and car2 respectively.
- en: car1.turnOff()
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: car1.turnOff()
- en: car2.accelerate()
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: car2.accelerate()
- en: '![](img/remember.jpg)A class is a template that cannot be executed, whereas
    an object is an instance of a class that can be executed!'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![记住](img/remember.jpg)类是一个不能执行的模板，而对象是类的实例，它可以被执行！'
- en: '![](img/remember.jpg)One class can be used to create (instantiate) as many
    objects as you want!'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![记住](img/remember.jpg)一个类可以被用来创建（实例化）你想要的任意数量的对象！'
- en: 38.3 The Constructor and the Keyword self
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.3 构造函数和关键字 self
- en: In Python, there is a method that has a special role and is called constructor.
    The constructor method is executed automatically whenever an instance of a class
    (an object) is created. Any initialization that you want to do with your object
    can be done within this method. In Python, the constructor is a method whose name
    is __init__().
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，有一个具有特殊作用的方法，称为构造函数。构造函数在创建类的实例（对象）时自动执行。您想要在对象中进行的任何初始化都可以在这个方法中完成。在
    Python 中，构造函数是一个名为 __init__() 的方法。
- en: '![](img/notice.jpg)Note that there is a double underscore at the beginning
    of the name and another double underscore at the end of the name __init__().'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)请注意，在名称的开头和结尾都有一个双下划线 __init__()。'
- en: Take a look at the following example. The constructor method __init__() is called
    twice automatically, once when the object p1 is created and once when the object
    p2 is created, which means that the message “An object was created” is displayed
    twice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的例子。构造函数方法 __init__() 会自动调用两次，一次是在创建对象 p1 时，一次是在创建对象 p2 时，这意味着会显示两次消息“创建了一个对象”。
- en: '![](img/my_exercise_header.png) file_38.3a'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.3a'
- en: 'class Person:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Person:'
- en: '#Define the constructor'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '# 定义构造函数'
- en: 'def __init__(self):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: print("An object was created")
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("创建了一个对象")
- en: '#Main code starts here'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '# 主代码从这里开始'
- en: p1 = Person()    #Create object p1
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'p1 = Person()    # 创建对象 p1'
- en: p2 = Person()    #Create object p2
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'p2 = Person()    # 创建对象 p2'
- en: As you may have noticed, in the formal argument list of the __init__() method,
    there is an argument named self. In object-oriented programming (OOP) with Python,
    this argument serves as a reference variable that points to the current object.
    Take a look at the following example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，在 __init__() 方法的形式参数列表中，有一个名为 self 的参数。在 Python 的面向对象编程（OOP）中，这个参数作为一个引用变量，指向当前对象。看一下下面的例子。
- en: '![](img/my_exercise_header.png) file_38.3b'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.3b'
- en: 'class Person:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Person:'
- en: name = None
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: name = None
- en: age = None
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: age = None
- en: '#Define the constructor'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '# 定义构造函数'
- en: 'def __init__(self):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: print("An object was created")
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("创建了一个对象")
- en: 'def sayInfo(self):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'def sayInfo(self):'
- en: print("I am", self.name)
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("我是", self.name)
- en: print("I am", self.age, "years old")
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("我今年", self.age, "岁")
- en: '#Main code starts here'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '# 主代码从这里开始'
- en: 'person1 = Person()   #Create object person1'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'person1 = Person()    # 创建对象 person1'
- en: '#Assign values to its fields'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '# 为其字段分配值'
- en: person1.name = "John"
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: person1.name = "John"
- en: person1.age = 14
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: person1.age = 14
- en: 'person1.sayInfo()   #Call the method sayInfo() of the object person1'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'person1.sayInfo()    # 调用对象 person1 的 sayInfo() 方法'
- en: Even though there is no actual argument in the statement person1.sayInfo() where
    the method is called, a formal argument (the keyword self) does exist in the statement
    def sayInfo(self) where the method is defined. Obviously, it would be more correct
    if that call were made as person1.sayInfo(person1). Written this way, it would
    make better sense! This actual argument person1 would be passed (assigned) to
    the formal argument self! Yes, this is probably more correct, but always keep
    in mind that Python is a “write less, do more” language! So there is no need for
    you to pass the object itself. Python will do it for you!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在调用方法的语句 person1.sayInfo() 中没有实际的参数，但在定义方法的语句 def sayInfo(self) 中确实存在一个形式参数（关键字
    self）。显然，如果调用方式是 person1.sayInfo(person1)，那就更正确了！这样写，会更有意义！实际的参数 person1 将被传递（分配）给形式参数
    self！是的，这可能是更正确的做法，但请始终记住，Python 是一种“写得更少，做得更多”的语言！所以您不需要传递对象本身。Python 会为您做这件事！
- en: '![](img/notice.jpg)If you don''t remember what a formal or actual argument
    is, please re-read [Section 35.5](chapter35.html#toc_5).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)如果您不记得形式参数或实际参数是什么，请重新阅读[第 35.5 节](chapter35.html#toc_5)。'
- en: '![](img/notice.jpg)Note that when declaring the fields name and age outside
    of a method (but within the class), you need to write the field name without dot
    notation. To access the fields, however, from within a method, you must use dot
    notation (for example, self.name and self.age).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)请注意，在方法外部（但在类内部）声明字段时，您需要写出字段名称，而不使用点表示法。然而，从方法内部访问字段时，您必须使用点表示法（例如，self.name
    和 self.age）。'
- en: A question that is probably spinning around in your head right now is “Why is
    it necessary to refer to these fields name and age within the method sayInfo()
    as self.name and self.age? Is it really necessary to use the keyword self in front
    of them?” A simple answer is that there is always a possibility that you could
    have two extra local variables of the same name (name and age) within the method.
    So you need a way to distinguish among those local variables and the object's
    fields. If you are confused, try to understand the following example. There is
    a field b within the class MyClass and a local variable b within the method myMethod()
    of the class. The self keyword is used to differentiate between the local variable
    and the field.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能心中有一个问题：“为什么在方法sayInfo()中需要将字段name和age引用为self.name和self.age？在它们前面使用关键字self真的有必要吗？”一个简单的答案是，始终存在一种可能性，您在方法内部可能有两个额外的同名的局部变量（name和age）。因此，您需要一种方法来区分这些局部变量和对象的字段。如果您感到困惑，请尝试理解以下示例。在MyClass类中有一个字段b，在MyClass类的myMethod()方法中有一个局部变量b。self关键字用于区分局部变量和字段。
- en: '![](img/my_exercise_header.png) file_38.3c'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.3c'
- en: 'class FooClass:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'class FooClass:'
- en: 'b = None   #This is a field'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'b = None   #这是一个字段'
- en: 'def myMethod(self):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'def myMethod(self):'
- en: b = "***"    #This is a local variable
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b = "***"    #这是一个局部变量
- en: print(b, self.b, b)
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(b, self.b, b)
- en: '#Main code starts here'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: x = FooClass()    #Create object x
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: x = FooClass()    #创建对象x
- en: 'x.b = "Hello!"   #Assign a value to its field'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'x.b = "Hello!"   #为其字段赋值'
- en: 'x.myMethod()     #It displays: *** Hello! ***'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'x.myMethod()     #它显示：*** Hello! ***'
- en: '![](img/notice.jpg)The keyword self can be used to refer to any member (field
    or method) of a class from within a method of the class.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)关键字self可以用于在类的方法中引用类的任何成员（字段或方法）。'
- en: 38.4 Passing Initial Values to the Constructor
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.4 向构造函数传递初始值
- en: Any method, even the constructor method __init__(), can have formal arguments
    within its formal argument list. For example, in the constructor method you can
    use arguments to pass some initial values to the object during creation. The example
    that follows creates four objects, each of which represents a Titan^([[24]](footnotes.html#Endnote_24))
    from Greek mythology.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方法，即使是构造函数方法__init__()，都可以在其形式参数列表中有形式参数。例如，在构造函数方法中，您可以使用参数在创建对象时传递一些初始值。以下示例创建了四个对象，每个对象代表希腊神话中的泰坦^([[24]](footnotes.html#Endnote_24))。
- en: '![](img/my_exercise_header.png) file_38.4a'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.4a'
- en: 'class Titan:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Titan:'
- en: name = None
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: name = None
- en: gender  = None
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: gender  = None
- en: '#Define the constructor'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义构造函数'
- en: 'def __init__(self, n, g):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, n, g):'
- en: self.name = n
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.name = n
- en: self.gender = g
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.gender = g
- en: '#Main code starts here'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: 'titan1 = Titan("Cronus", "male")   #Create object titan1'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'titan1 = Titan("Cronus", "male")   #创建对象titan1'
- en: titan2 = Titan("Oceanus", "male")  #Create object titan2
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: titan2 = Titan("Oceanus", "male")  #创建对象titan2
- en: 'titan3 = Titan("Rhea", "female")   #Create object titan3'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'titan3 = Titan("Rhea", "female")   #创建对象titan3'
- en: 'titan4 = Titan("Phoebe", "female") #Create object titan4'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'titan4 = Titan("Phoebe", "female") #创建对象titan4'
- en: '![](img/notice.jpg)Note that, even though there are three formal arguments
    in the constructor, there are only two actual arguments in the statements that
    call the constructor. Since Python is a “do more, write less” computer language,
    there is no need to pass the object itself. Python will do it for you!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)请注意，尽管构造函数中有三个形式参数，但在调用构造函数的语句中只有两个实际参数。由于Python是一种“多做少写”的计算机语言，因此不需要传递对象本身。Python会为您完成这项工作！'
- en: In Python, it is legal to have one field and one local variable (or even a formal
    argument) with the same name. So, the class Titan can also be written as follows
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，一个字段和一个局部变量（甚至是一个形式参数）可以具有相同的名称是合法的。因此，Titan类也可以写成如下形式
- en: 'class Titan:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Titan:'
- en: name = None
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: name = None
- en: gender = None
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: gender = None
- en: '#Define the constructor'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义构造函数'
- en: 'def __init__(self, name, gender ):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, gender ):'
- en: self.name = name  #Fields and arguments can have the same name
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.name = name  #字段和参数可以具有相同的名称
- en: self.gender = gender
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.gender = gender
- en: The variables name and gender are arguments used to pass values to the constructor
    whereas self.name and self.gender are fields used to store values within the object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 变量name和gender是用于将值传递给构造函数的参数，而self.name和self.gender是用于在对象内部存储值的字段。
- en: Last but not least, in Python, you can simplify class Titan even more. The example
    that follows uses a simplified version of the class Titan.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，在Python中，您可以进一步简化Titan类。以下示例使用Titan类的简化版本。
- en: '![](img/my_exercise_header.png) file_38.4b'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.4b'
- en: 'class Titan:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Titan:'
- en: '#Define the constructor'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义构造函数'
- en: 'def __init__(self, name, gender):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, gender):'
- en: self.name = name
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.name = name
- en: self.gender = gender
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.gender = gender
- en: '#Main code starts here'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: 'titan1 = Titan("Cronus", "male")   #Create object titan1'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'titan1 = Titan("克洛诺斯", "male")   #创建对象 titan1'
- en: titan2 = Titan("Oceanus", "male")  #Create object titan2
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: titan2 = Titan("欧申纳斯", "male")  #创建对象 titan2
- en: 'titan3 = Titan("Rhea", "female")   #Create object titan3'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'titan3 = Titan("瑞亚", "female")   #创建对象 titan3'
- en: 'titan4 = Titan("Phoebe", "female") #Create object titan4'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'titan4 = Titan("波雅", "female") #创建对象 titan4'
- en: print(titan1.name, "-", titan1.gender)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: print(titan1.name, "-", titan1.gender)
- en: print(titan2.name, "-", titan2.gender)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: print(titan2.name, "-", titan2.gender)
- en: print(titan3.name, "-", titan3.gender)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: print(titan3.name, "-", titan3.gender)
- en: print(titan4.name, "-", titan4.gender)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: print(titan4.name, "-", titan4.gender)
- en: 38.5 Class Fields vs Instance Fields
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.5 类字段与实例字段
- en: Until this point, what you've learned is that it is not too bad to have fields
    declared outside of the constructor, as shown in the program that follows.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所学的知识是，将字段声明在构造函数外部并不太糟糕，就像下面的程序所示。
- en: 'class HistoryEvents:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'class HistoryEvents:'
- en: day = None  #This field is declared outside of the
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: day = None  #此字段在内部声明
- en: '#constructor. It is called "class field"'
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '#构造函数。它被称为“类字段”'
- en: '#Define the constructor'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义构造函数'
- en: 'def __init__(self):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: print("Object Instantiation")
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("对象实例化")
- en: '#Main code starts here'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: h1 = HistoryEvents()        #Create object h1
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: h1 = HistoryEvents()        #创建对象 h1
- en: h1.day = "4th of July"
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: h1.day = "4th of July"
- en: h2 = HistoryEvents()        #Create object h2
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: h2 = HistoryEvents()        #创建对象 h2
- en: h2.day = "28th of October"
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: h2.day = "28th of October"
- en: print(h1.day)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: print(h1.day)
- en: print(h2.day)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: print(h2.day)
- en: You have also learned that you can rewrite this code and declare the field day
    inside the constructor, as shown here.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了可以重写此代码，并将字段 day 声明在构造函数内部，就像这里所示。
- en: 'class HistoryEvents:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'class HistoryEvents:'
- en: '#Define the constructor'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义构造函数'
- en: 'def __init__(self, day):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, day):'
- en: print("Object Intantiation")
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("对象实例化")
- en: self.day = day  #This field is declared inside the
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.day = day  #此字段在内部声明
- en: '#constructor. It is called "instance field"'
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '#构造函数。它被称为“实例字段”'
- en: '#Main code starts here'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: 'h1 = HistoryEvents("4th of July")     #Create object h1'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'h1 = HistoryEvents("4th of July")     #创建对象 h1'
- en: 'h2 = HistoryEvents("28th of October") #Create object h2'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'h2 = HistoryEvents("28th of October") #创建对象 h2'
- en: print(h1.day)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: print(h1.day)
- en: print(h2.day)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: print(h2.day)
- en: '![](img/notice.jpg)When a field is declared outside of the constructor, it
    is called a “class field” but when it is declared inside the constructor, it is
    called an “instance field”.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)当字段在构造函数外部声明时，它被称为“类字段”，但当它在构造函数内部声明时，它被称为“实例字段”。'
- en: '![](img/notice.jpg)A class field is shared by all instances of the class whereas
    an instance field is unique to each instance.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)类字段由类的所有实例共享，而实例字段对每个实例都是唯一的。'
- en: So, which programming style is better? They both seem to be okay! Well, the
    second one is not just better—you can say that this is the right way to write
    a class! Why? Because, in some cases, when mutable data structures (such as lists
    and dictionaries) are used as class fields, they may produce undesirable results.
    Take a look at the following example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，哪种编程风格更好？它们似乎都还不错！嗯，第二个不仅更好——你可以说这是编写类的正确方式！为什么？因为，在某些情况下，当可变数据结构（如列表和字典）用作类字段时，可能会产生不希望的结果。看看下面的例子。
- en: 'class HistoryEvents:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'class HistoryEvents:'
- en: 'events = []         #Class field shared by all instances'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'events = []         #由所有实例共享的类字段'
- en: '#Define the constructor'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义构造函数'
- en: 'def __init__(self, day):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, day):'
- en: self.day = day  #Instance field unique to each instance
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.day = day  #每个实例唯一的实例字段
- en: '#Main code starts here'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: h1 = HistoryEvents("4th of July")  #Create object h1
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: h1 = HistoryEvents("4th of July")  #创建对象 h1
- en: '#Assign values to the fields of h1'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#为 h1 的字段赋值'
- en: 'h1.events.append("1776: Declaration of Independence in United States")'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'h1.events.append("1776: 美国独立宣言")'
- en: 'h1.events.append("1810: French troops occupy Amsterdam")'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'h1.events.append("1810: 法国军队占领阿姆斯特丹")'
- en: h2 = HistoryEvents("28th of October")  #Create object h2
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: h2 = HistoryEvents("28th of October")  #创建对象 h2
- en: '#Assign values to the fields of h2'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#为 h2 的字段赋值'
- en: 'h2.events.append("969: Byzantine troops occupy Antioch")'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'h2.events.append("969: 拜占庭军队占领安条克")'
- en: 'h2.events.append("1940: Ohi Day in Greece")'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'h2.events.append("1940: 希腊的国庆日")'
- en: 'for event in h1.events:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in h1.events:'
- en: print(event)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: print(event)
- en: You may expect that the last for-loop displays only the two events of the 4^(th)
    of July. Your thinking is correct, but the output result proves you wrong! The
    last for-loop displays four events, as shown in Figure 38-3.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能预期最后一个 for 循环只会显示 7 月 4 日的两个事件。你的想法是正确的，但输出结果证明你是错的！最后一个 for 循环显示了四个事件，如图
    38-3 所示。
- en: '![Image](img/chapter38-03.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter38-03.png)'
- en: Figure 38-3 When mutable data types are used as class fields, they may produce
    undesirable results
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 38-3 当可变数据类型用作类字段时，可能会产生不希望的结果
- en: '![](img/notice.jpg)List events is a mutable data structure. In Python, mutable
    data structures should never be used as a class field, since they produces undesirable
    results.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)列表事件是一个可变的数据结构。在 Python 中，可变数据结构不应用作类字段，因为这会产生不希望的结果。'
- en: '![](img/notice.jpg)It is advised to utilize as few class fields as possible!
    Use instance fields instead! The less the number of class fields the better.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)建议尽可能少地使用类字段！使用实例字段！类字段越少，越好。'
- en: The next example, is the correct version of the previous one.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例是上一个正确版本的。
- en: '![](img/my_exercise_header.png) file_38.5'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.5'
- en: 'class HistoryEvents:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'class HistoryEvents:'
- en: '#Define the constructor'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义构造函数'
- en: 'def __init__(self, day):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, day):'
- en: 'self.day = day   #Instance field unique to each instance'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'self.day = day   #每个实例独有的实例字段'
- en: 'self.events = [] #Instance field unique to each instance'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'self.events = [] #每个实例独有的实例字段'
- en: '#Main code starts here'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: 'h1 = HistoryEvents("4th of July")     #Create object h1'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'h1 = HistoryEvents("7月4日")     #创建对象 h1'
- en: '#Assign values to the fields of h1'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#将值分配给 h1 的字段'
- en: 'h1.events.append("1776: Declaration of Independence in United States")'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'h1.events.append("1776: 美利坚合众国独立宣言")'
- en: 'h1.events.append("1810: French troops occupy Amsterdam")'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'h1.events.append("1810: 法国军队占领阿姆斯特丹")'
- en: 'h2 = HistoryEvents("28th of October") #Create object h2'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'h2 = HistoryEvents("10月28日") #创建对象 h2'
- en: '#Assign values to the fields of h2'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '#将值分配给 h2 的字段'
- en: 'h2.events.append("969: Byzantine troops occupy Antioch")'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'h2.events.append("969: 东罗马军队占领安条克")'
- en: 'h2.events.append("1940: Ohi Day in Greece")'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'h2.events.append("1940: 希腊的国庆日")'
- en: 'for event in h1.events:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in h1.events:'
- en: print(event)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: print(event)
- en: 38.6 Getter and Setter Methods vs Properties
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.6 获取器和设置器方法与属性
- en: A field is a variable declared directly in a class. The principles of the object-oriented
    programming, though, state that the data of a class should be hidden and safe
    from accidental alteration. Think that one day you will probably be writing classes
    that other programmers will use in their programs. So, you don't want them to
    know what is inside your classes! The internal operation of your classes should
    be kept hidden from the outside world. By not exposing a field, you manage to
    hide the internal implementation of your class. Fields should be kept private
    to a class and accessed through get and set methods (or through properties).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 字段是在类中直接声明的变量。然而，面向对象编程的原则表明，类中的数据应该是隐藏的，并且免受意外更改。想象一下，有一天你可能会编写其他程序员将在他们的程序中使用的类。所以，你不想让他们知道你的类里面是什么！你的类的内部操作应该对外界保密。通过不暴露字段，你成功地隐藏了类的内部实现。字段应保持为类的私有，并通过获取和设置方法（或通过属性）访问。
- en: '![](img/notice.jpg)Generally speaking, programmers should use fields only for
    data that have private or protected accessibility. In Java, or C# you can set
    a field as private or protected using special keywords.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)一般来说，程序员应该只使用具有私有或受保护访问权限的数据字段。在 Java 或 C# 中，您可以使用特殊关键字将字段设置为私有或受保护。'
- en: Let's try to understand all of this new stuff through an example. Suppose you
    write the following class that converts a degrees Fahrenheit temperature into
    its degrees Celsius equivalent.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来尝试理解所有这些新内容。假设你编写了以下将华氏温度转换为摄氏温度等价的类的代码。
- en: '![](img/my_exercise_header.png) file_38.6a'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.6a'
- en: 'class FahrenheitToCelsius:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'class FahrenheitToCelsius:'
- en: 'def __init__(self, value):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, value):'
- en: self.temperature = value
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.temperature = value
- en: '#This method gets the temperature'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '#此方法获取温度'
- en: 'def getTemperature(self):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getTemperature(self):'
- en: return 5.0 / 9.0 * (self.temperature - 32.0)
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return 5.0 / 9.0 * (self.temperature - 32.0)
- en: '#Main code starts here'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: 'x = FahrenheitToCelsius(-68)   #Create object x'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = FahrenheitToCelsius(-68)   #创建对象 x'
- en: print(x.getTemperature())
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: print(x.getTemperature())
- en: This class is almost perfect but has a main disadvantage. It doesn't take into
    consideration that a temperature cannot go below −459.67 degrees Fahrenheit (−273.15
    degrees Celsius). This temperature is called absolute zero. So a novice programmer
    who uses your class and knows absolutely nothing about physics, might pass a value
    of −500 degrees Fahrenheit to the constructor, as shown in the code fragment that
    follows
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类几乎完美，但有一个主要缺点。它没有考虑到温度不能低于-459.67华氏度（-273.15摄氏度）。这个温度被称为绝对零度。因此，一个对物理一无所知的初学者程序员可能会像下面的代码片段所示，将-500华氏度的值传递给构造函数。
- en: 'x = FahrenheitToCelsius(-500)   #Create object x'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = FahrenheitToCelsius(-500)   #创建对象x'
- en: print(x.getTemperature())
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(x.getTemperature())
- en: Even though the program can run perfectly well and display a value of −295.55
    degrees Celsius, unfortunately this temperature cannot exist in the entire universe!
    So a slightly different version of this class might partially solve the problem.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管程序可以完美运行并显示-295.55摄氏度的值，但遗憾的是，这个温度在整个宇宙中根本不存在！所以这个类的略微不同的版本可能部分解决了这个问题。
- en: '![](img/my_exercise_header.png) file_38.6b'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_38.6b'
- en: 'class FahrenheitToCelsius:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'class FahrenheitToCelsius:'
- en: 'def __init__(self, value):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, value):'
- en: self.setTemperature(value)  #Use a method to set the value of the field temperature
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.setTemperature(value)  #使用方法设置字段temperature的值
- en: '#This method gets the temperature'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '#此方法获取温度'
- en: 'def getTemperature(self):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getTemperature(self):'
- en: return 5.0 / 9.0 * (self.temperature - 32.0)
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return 5.0 / 9.0 * (self.temperature - 32.0)
- en: '#This method sets the temperature'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '#此方法设置温度'
- en: 'def setTemperature(self, value):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setTemperature(self, value):'
- en: 'if value >= -459.67:'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if value >= -459.67:'
- en: self.temperature = value
  id: totrans-244
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.temperature = value
- en: 'else:'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise ValueError("There is no temperature below -459.67")
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: raise ValueError("没有低于-459.67的温度")
- en: '#Main code starts here'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: 'x = FahrenheitToCelsius(-50)   #Create object x. This calls the constructor
    which,'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = FahrenheitToCelsius(-50) #创建对象x。这会调用构造函数，它，'
- en: '#in turn, calls the setter.'
  id: totrans-249
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '#依次调用setter。'
- en: print(x.getTemperature())
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(x.getTemperature())
- en: '![](img/notice.jpg)The raise statement forces the program to throw an exception
    (a runtime error) causing the flow of execution to stop.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg) raise语句强制程序抛出异常（运行时错误），导致执行流程停止。'
- en: This time, a method named setTemperature() is used to set the value of the field
    temperature. This is better, but not exactly perfect, because the programmer must
    be careful and always remember to use this method each time they wish to change
    the value of the field temperature. The problem is that the value of the field
    temperature can still be directly changed using its name, as shown in the code
    fragment that follows.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，使用了一个名为setTemperature()的方法来设置字段temperature的值。这比之前好，但并不完全完美，因为程序员必须小心，并且每次想要更改字段temperature的值时都必须记住使用这个方法。问题是字段temperature的值仍然可以直接通过其名称直接更改，如下面的代码片段所示。
- en: 'x = FahrenheitToCelsius(-50) #Create object x'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = FahrenheitToCelsius(-50) #创建对象x'
- en: print(x.getTemperature())
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(x.getTemperature())
- en: x.setTemperature(-65)        #This is okay!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: x.setTemperature(-65)        #这是可以的！
- en: print(x.getTemperature())
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(x.getTemperature())
- en: 'x.temperature = -500         #Unfortunately, this is still permitted!'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'x.temperature = -500         #遗憾的是，这仍然被允许！'
- en: print(x.getTemperature())
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(x.getTemperature())
- en: This is where a property should be used! A property is a class member that provides
    a flexible mechanism to read, write, or compute the value of a field that you
    want to keep private. Properties expose fields, but hide implementation!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是应该使用属性的地方！属性是一个类成员，它提供了一个灵活的机制来读取、写入或计算你想要保持私有的字段的值。属性暴露字段，但隐藏实现！
- en: '![](img/my_exercise_header.png) file_38.6c'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_38.6c'
- en: 'class FahrenheitToCelsius:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'class FahrenheitToCelsius:'
- en: 'def __init__(self, value):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, value):'
- en: self.temperature = value  #Property is initialized. This calls the setter
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.temperature = value  #属性被初始化。这会调用setter
- en: 'def getTemperature(self):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getTemperature(self):'
- en: return 5.0 / 9 * (self._temperature - 32)
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return 5.0 / 9 * (self._temperature - 32)
- en: 'def setTemperature(self, value):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setTemperature(self, value):'
- en: 'if value >= -459.67:'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if value >= -459.67:'
- en: self._temperature = value
  id: totrans-268
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self._temperature = value
- en: 'else:'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise ValueError("There is no temperature below -459.67")
  id: totrans-270
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: raise ValueError("没有低于-459.67的温度")
- en: '#Define a property'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义一个属性'
- en: temperature = property(getTemperature, setTemperature)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: temperature = property(getTemperature, setTemperature)
- en: '#Main code starts here'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: 'x = FahrenheitToCelsius(-50)   #Create object x. This calls the constructor
    which,'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = FahrenheitToCelsius(-50)   #创建对象x。这会调用构造函数，它，'
- en: '#in turn, calls the setter.'
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '#依次调用setter。'
- en: 'print(x.temperature)     #This calls the getter'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(x.temperature)     #This calls the getter'
- en: x.temperature = -65      #This calls the setter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: x.temperature = -65      #This calls the setter.
- en: 'print(x.temperature)     #This calls the getter.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(x.temperature)     #This calls the getter.'
- en: 'x.temperature = -500     #This calls the setter and throws an error'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 'x.temperature = -500     #This calls the setter and throws an error'
- en: print(x.temperature)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: print(x.temperature)
- en: '![](img/notice.jpg)Note the underscore ( _ ) at the beginning of the field
    temperature. In Python, an underscore at the beginning of a variable name can
    be used to denote a “private field”.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)Note the underscore ( _ ) at the beginning of the field
    temperature. In Python, an underscore at the beginning of a variable name can
    be used to denote a “private field”.'
- en: So, what does the statement temperature = property(getTemperature, setTemperature)
    do anyway?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: So, what does the statement temperature = property(getTemperature, setTemperature)
    do anyway?
- en: When a statement tries to access the value of the field temperature, the getTemperature()
    method is called automatically and similarly, when a statement tries to assign
    a value to the field temperature the setTemperature() method is called automatically!
    So, everything seems to be okay now! But is it, really?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: When a statement tries to access the value of the field temperature, the getTemperature()
    method is called automatically and similarly, when a statement tries to assign
    a value to the field temperature the setTemperature() method is called automatically!
    So, everything seems to be okay now! But is it, really?
- en: One last thing can be done to make things even better! You can completely get
    rid of the methods getTemperature() and setTemperature() because you don't want
    to have two ways to access the value of the field temperature, as shown in the
    code fragment that follows
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: One last thing can be done to make things even better! You can completely get
    rid of the methods getTemperature() and setTemperature() because you don't want
    to have two ways to access the value of the field temperature, as shown in the
    code fragment that follows
- en: x = FahrenheitToCelsius(0)  #Create object x
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: x = FahrenheitToCelsius(0)  #Create object x
- en: '#There are still two ways to access the value of the field _temperature'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '#There are still two ways to access the value of the field _temperature'
- en: x.setTemperature(-100)  #Use the method
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: x.setTemperature(-100)  #Use the method
- en: x.temperature = -100    #Use the property
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: x.temperature = -100    #Use the property
- en: In order to completely get rid of the methods getTemperature() and setTemperature()
    you can use some of the decorators that Python supports.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: In order to completely get rid of the methods getTemperature() and setTemperature()
    you can use some of the decorators that Python supports.
- en: '![](img/my_exercise_header.png) file_38.6d'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_38.6d'
- en: 'class FahrenheitToCelsius:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'class FahrenheitToCelsius:'
- en: 'def __init__(self, value):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, value):'
- en: self.temperature = value    #Property is initialized. This calls the setter
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.temperature = value    #Property is initialized. This calls the setter
- en: '#Use the decorator @property to define the getter'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '#Use the decorator @property to define the getter'
- en: '@property'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def temperature(self):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 'def temperature(self):'
- en: return 5.0 / 9 * (self._temperature - 32)
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return 5.0 / 9 * (self._temperature - 32)
- en: '#Use the decorator @field_name.setter to define the setter'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '#Use the decorator @field_name.setter to define the setter'
- en: '@temperature.setter'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '@temperature.setter'
- en: 'def temperature(self, value):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'def temperature(self, value):'
- en: 'if value >= -459.67:'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if value >= -459.67:'
- en: self._temperature = value
  id: totrans-302
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self._temperature = value
- en: 'else:'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise ValueError("There is no temperature below -459.67")
  id: totrans-304
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: raise ValueError("There is no temperature below -459.67")
- en: '#Main code starts here'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: x = FahrenheitToCelsius(-50)  #Create object x. This calls the constructor which,
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: x = FahrenheitToCelsius(-50)  #Create object x. This calls the constructor which,
- en: '#in turn, calls the setter.'
  id: totrans-307
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '#in turn, calls the setter.'
- en: print(x.temperature)          #This calls the getter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: print(x.temperature)          #This calls the getter.
- en: 'x.temperature = -65           #This calls the setter.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 'x.temperature = -65           #This calls the setter.'
- en: print(x.temperature)          #This calls the getter.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: print(x.temperature)          #This calls the getter.
- en: x.temperature = -500          #This calls the setter and throws an error
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: x.temperature = -500          #This calls the setter and throws an error
- en: print(x.temperature)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: print(x.temperature)
- en: '![](img/notice.jpg)Please note that the two methods and the field share the
    same name, temperature.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)Please note that the two methods and the field share the
    same name, temperature.'
- en: '![](img/notice.jpg)A decorator is a function that takes another function as
    an argument and returns a new, prettier version of that function. Decorators allow
    you to change the behavior or extend the functionality of a function without changing
    the function''s body.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)A decorator is a function that takes another function
    as an argument and returns a new, prettier version of that function. Decorators
    allow you to change the behavior or extend the functionality of a function without
    changing the function''s body.'
- en: Exercise 38.6-1 The Roman Numerals
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 38.6-1 罗马数字
- en: Roman numerals are shown in the following table.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字如下表所示。
- en: '| Number | Roman Numeral |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | 罗马数字 |'
- en: '| 1 | I |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 1 | I |'
- en: '| 2 | II |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 2 | II |'
- en: '| 3 | III |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 3 | III |'
- en: '| 4 | IV |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 4 | IV |'
- en: '| 5 | V |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 5 | V |'
- en: 'Do the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'Do the following:'
- en: i)Write a class named Romans which includes
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: i)Write a class named Romans which includes
- en: a)a property named number. It will be used to get and set the value of a private
    field named _number in integer format. The setter must throw an error when the
    number is not recognized.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: a)定义一个名为number的属性。它将用于获取和设置名为_number的私有字段的整数值。设置器在数字未识别时必须抛出错误。
- en: b)a property named roman. It will be used to get and set the value of the private
    field _number in Roman numeral format. The setter must throw an error when the
    Roman numeral is not recognized.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: b)定义一个名为roman的属性。它将用于获取和设置名为_number的私有字段的罗马数字格式的值。设置器在罗马数字未识别时必须抛出错误。
- en: ii)Using the class cited above, write a Python program that displays the Roman
    numeral that corresponds to the value of 3 as well as the number that corresponds
    to the Roman numeral value of “V”.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ii)使用上述类，编写一个Python程序，显示与值3对应的罗马数字以及与罗马数字值“V”对应的数字。
- en: Solution
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: The getter and setter of the property number are very simple so there is nothing
    special to explain. The getter and setter of the property roman, however, need
    some explanation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 属性number的获取器和设置器非常简单，因此没有特别之处要解释。然而，属性roman的获取器和设置器需要一些解释。
- en: The getter of the property roman can be written as follows
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 属性roman的获取器可以编写如下
- en: '#Define the getter'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义获取器'
- en: '@property'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def roman(self):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 'def roman(self):'
- en: if self._number == 1
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: if self._number == 1
- en: return "I"
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return "I"
- en: elif self._number == 2
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: elif self._number == 2
- en: return "II"
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return "II"
- en: elif self._number == 3
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: elif self._number == 3
- en: return "III"
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return "III"
- en: elif self._number == 4
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: elif self._number == 4
- en: return "IV"
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return "IV"
- en: elif self._number == 5
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: elif self._number == 5
- en: return "V"
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return "V"
- en: However, since you now know many about dictionaries, you can use a better approach,
    as shown in the code fragment that follows.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于你现在对字典了解很多，你可以使用更好的方法，如下面的代码片段所示。
- en: '#Define the getter'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义获取器'
- en: '@property'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def roman(self):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'def roman(self):'
- en: 'number2roman = {1: "I", 2: "II", 3: "III", 4: "IV", 5: "V"}'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'number2roman = {1: "I", 2: "II", 3: "III", 4: "IV", 5: "V"}'
- en: return number2roman[self._number]
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: return number2roman[self._number]
- en: Accordingly, the setter can be as follows
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设置器可以如下所示
- en: '#Define the setter'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义设置器'
- en: '@roman.setter'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '@roman.setter'
- en: 'def roman(self, key):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'def roman(self, key):'
- en: 'roman2number = {"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5}'
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'roman2number = {"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5}'
- en: 'if key in roman2number:'
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if key in roman2number:'
- en: self._number = roman2number[key]
  id: totrans-356
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self._number = roman2number[key]
- en: 'else:'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise ValueError("Roman numeral not recognized")
  id: totrans-358
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: raise ValueError("罗马数字未识别")
- en: The final Python program is as follows
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的Python程序如下
- en: '![](img/my_exercise_header.png) file_38.6-1'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.6-1'
- en: 'class Romans:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Romans:'
- en: '#Define the getter'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义获取器'
- en: '@property'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def number(self):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 'def number(self):'
- en: return self._number
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return self._number
- en: '#Define the setter'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义设置器'
- en: '@number.setter'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '@number.setter'
- en: 'def number(self, value):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 'def number(self, value):'
- en: 'if value >= 1 and value <= 5:'
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if value >= 1 and value <= 5:'
- en: self._number = value
  id: totrans-370
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self._number = value
- en: 'else:'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise ValueError("Number not recognized")
  id: totrans-372
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: raise ValueError("数字未识别")
- en: '#Define the getter'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义获取器'
- en: '@property'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def roman(self):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'def roman(self):'
- en: 'number2roman = {1: "I", 2: "II", 3: "III", 4: "IV", 5: "V"}'
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'number2roman = {1: "I", 2: "II", 3: "III", 4: "IV", 5: "V"}'
- en: return number2roman[self._number]
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return number2roman[self._number]
- en: '#Define the setter'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义设置器'
- en: '@roman.setter'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '@roman.setter'
- en: 'def roman(self, key):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'def roman(self, key):'
- en: 'roman2number = {"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5}'
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'roman2number = {"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5}'
- en: 'if key in roman2number:'
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if key in roman2number:'
- en: self._number = roman2number[key]
  id: totrans-383
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self._number = roman2number[key]
- en: 'else:'
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise ValueError("Roman numeral not recognized")
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: raise ValueError("罗马数字未识别")
- en: '#Main code starts here'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: x = Romans()        #Create object x
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: x = Romans()        #创建对象x
- en: x.number = 3
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: x.number = 3
- en: 'print(x.number)     #It displays: 3'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(x.number)     #显示：3'
- en: 'print(x.roman)      #It displays: III'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: print(x.roman)      #显示：III
- en: x.roman = "V"
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: x.roman = "V"
- en: 'print(x.number)     #It displays: 5'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(x.number)     #显示：5'
- en: 'print(x.roman)      #It displays: V'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: print(x.roman)      #显示：V
- en: 38.7 Can a Method Call Another Method of the Same Class?
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.7 一个方法能否调用同一类中的另一个方法？
- en: In [Section 36.2](chapter36.html#toc_2) you learned that a subprogram can call
    another subprogram. Obviously, the same applies when it comes to methods—a method
    can call another method of the same class! Methods are nothing more than subprograms
    after all! So, if you want a method to call another method of the same class you
    should use the keyword self in front of the method that you want to call (using
    dot notation) as shown in the example that follows.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第36.2节](chapter36.html#toc_2)中，你学习了子程序可以调用另一个子程序。显然，当涉及到方法时，情况也是一样的——一个方法可以调用同一类中的另一个方法！毕竟，方法不过是子程序而已！所以，如果你想让一个方法调用同一类中的另一个方法，你应该在你想调用的方法前使用关键字self（使用点符号）如以下示例所示。
- en: '![](img/my_exercise_header.png) file_38.7'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.7'
- en: 'class JustAClass:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 'class JustAClass:'
- en: 'def foo1(self):'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 'def foo1(self):'
- en: print("foo1 was called")
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("foo1 was called")
- en: 'self.foo2()     #Call foo2() using dot notation'
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'self.foo2()     #Using dot notation to call foo2()'
- en: 'def foo2(self):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 'def foo2(self):'
- en: print("foo2 was called")
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("foo2 was called")
- en: '#Main code starts here'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: x = JustAClass()
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: x = JustAClass()
- en: x.foo1()    #Call foo1() which, in turn, will call foo2()
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: x.foo1()    #Call foo1() which, in turn, will call foo2()
- en: Exercise 38.7-1 Doing Math
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习38.7-1 做数学题
- en: 'Do the following:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 'Do the following:'
- en: i)Write a class named DoingMath which includes
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: i)Write a class named DoingMath which includes
- en: a)a void method named square that accepts a number through its formal argument
    list and then calculates its square and displays the message “The square of XX
    is YY”, where XX and YY must be replaced by actual values.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: a)a void method named square that accepts a number through its formal argument
    list and then calculates its square and displays the message “The square of XX
    is YY”, where XX and YY must be replaced by actual values.
- en: b)a void method named squareRoot that accepts a number through its formal argument
    list and then calculates its square root and displays the message “The square
    root of XX is YY” where XX and YY must be replaced by actual values. However,
    if the number is less than zero, the method must display an error message.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: b)a void method named squareRoot that accepts a number through its formal argument
    list and then calculates its square root and displays the message “The square
    root of XX is YY” where XX and YY must be replaced by actual values. However,
    if the number is less than zero, the method must display an error message.
- en: c)a void method named displayResults that accepts a number through its formal
    argument list and then calls the methods square() and squareRoot() to display
    the results.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: c)a void method named displayResults that accepts a number through its formal
    argument list and then calls the methods square() and squareRoot() to display
    the results.
- en: ii)Using the class cited above, write a Python program that prompts the user
    to enter a number. The program must then display the root and the square root
    of that number.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ii)使用上述类，编写一个Python程序，提示用户输入一个数字。然后程序必须显示该数字的根和平方根。
- en: Solution
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Solution
- en: This exercise is quite simple. The methods square(), squareRoot(), and displayResults()
    must have a formal argument within their formal argument list so as to accept
    a passed value. The solution is as follows.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习相当简单。方法square()、squareRoot()和displayResults()必须在它们的正式参数列表中有一个形式参数，以便接受传递的值。解决方案如下。
- en: '![](img/my_exercise_header.png) file_38.7-1'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.7-1'
- en: from math import sqrt
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: from math import sqrt
- en: 'class DoingMath:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 'class DoingMath:'
- en: 'def square(self, x):          #Argument x accepts passed value'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 'def square(self, x):          #Argument x accepts passed value'
- en: print("The square of", x, "is", x ** 2)
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("The square of", x, "is", x ** 2)
- en: 'def squareRoot(self, x):     #Argument x accepts passed value'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 'def squareRoot(self, x):     #Argument x accepts passed value'
- en: 'if x < 0:'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if x < 0:'
- en: print("Cannot calculate square root")
  id: totrans-422
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("Cannot calculate square root")
- en: 'else:'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Square root of", x, "is", sqrt(x))
  id: totrans-424
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("Square root of", x, "is", sqrt(x))
- en: 'def displayResults(self, x): #Argument x accepts passed value'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayResults(self, x): #Argument x accepts passed value'
- en: self.square(x)
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.square(x)
- en: self.squareRoot(x)
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.squareRoot(x)
- en: '#Main code starts here'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: dm = DoingMath()
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: dm = DoingMath()
- en: 'b = float(input("Enter a number: "))'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 'b = float(input("Enter a number: "))'
- en: dm.displayResults(b)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: dm.displayResults(b)
- en: 38.8 Class Inheritance
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.8 类继承
- en: Class inheritance is one of the main concepts of OOP. It lets you write a class
    using another class as a base. When a class is based on another class, the programmers
    use to say “it inherits the other class”. The class that is inherited is called
    the parent class, the base class, or the superclass. The class that does the inheriting
    is called the child class, the derived class, or the subclass.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 类继承是面向对象编程的主要概念之一。它允许你使用另一个类作为基础来编写一个类。当一个类基于另一个类时，程序员会说“它继承了另一个类”。被继承的类称为父类、基类或超类。执行继承的类称为子类、派生类或子类。
- en: A child class automatically inherits all the methods and fields of the parent
    class.  The best part, however, is that you can add additional characteristics
    (methods or fields) to the child class. Therefore, you use inheritance when you
    have to write several classes that share many common characteristics but aren't
    entirely identical. To do this, you work as follows. First, you write a parent
    class containing all the common characteristics. Next, you write child classes
    that inherit all those common characteristics from the parent class. Finally,
    you add any additional and unique characteristics, specific to each child class.
    Just as with humans, it's these additional and unique characteristics that set
    a child apart from its parent, right?
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 子类会自动继承父类的所有方法和字段。然而，最好的部分是，你可以在子类中添加额外的特征（方法或字段）。因此，当你需要编写多个具有许多共同特征但又不完全相同类的代码时，你会使用继承。为此，你需要这样做。首先，编写一个包含所有共同特征的父类。接下来，编写继承自父类所有这些共同特征的子类。最后，添加任何额外的和独特的特征，这些特征是针对每个子类的。就像人类一样，正是这些额外的和独特的特征将子类与其父类区分开来，对吧？
- en: Let's say that you want to write a program that keeps track of the teachers
    and students in a school. They have some characteristics in common, such as name
    and age, but they also have specific characteristics such as salary for teachers
    and final grade for students that are not in common. What you can do here is write
    a parent class named SchoolMember that contains all those characteristics that
    both teachers and students have in common. Then you can write two child classes
    named Teacher and Student, one for teachers and one for students. Both child classes
    can inherit the class SchoolMember but additional fields, named salary and finalGrade,
    must be added to the child classes Teacher and Student correspondingly.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编写一个程序来跟踪学校中的教师和学生。他们有一些共同的特征，例如姓名和年龄，但他们也有一些特定的特征，如教师的薪水和学生最后的成绩，这些特征不是共同的。你可以在这里做的是编写一个名为
    SchoolMember 的父类，它包含教师和学生共有的所有特征。然后你可以编写两个子类，分别命名为 Teacher 和 Student，一个用于教师，一个用于学生。这两个子类都可以继承自
    SchoolMember 类，但需要在子类 Teacher 和 Student 中相应地添加额外的字段，名为 salary 和 finalGrade。
- en: The parent class SchoolMember is shown here
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 父类 SchoolMember 如此展示
- en: 'class SchoolMember:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SchoolMember:'
- en: 'def __init__(self, name, age):'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, age):'
- en: self.name = name
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.name = name
- en: self.age = age
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.age = age
- en: print("A school member was initialized")
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("A school member was initialized")
- en: If you want a class to inherit the class SchoolMember, it must be defined as
    follows
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让一个类继承自类 SchoolMember，它必须按照以下方式定义
- en: 'class Name(SchoolMember):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Name(SchoolMember):'
- en: 'def __init__(self, name, age [, …]):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, age [, …]):'
- en: '#Call the constructor of the class SchoolMember'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '#Call the constructor of the class SchoolMember'
- en: super().__init__(name, age)
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: super().__init__(name, age)
- en: Define additional fields for this class
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为此类定义额外的字段
- en: Additional statement or block of statements
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Additional statement or block of statements
- en: Define additional methods and/or properties for this class
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 为此类定义额外的方法和/或属性
- en: where Name is the name of the child class.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Name 是子类的名称。
- en: So, the class Teacher can be as follows
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类 Teacher 可以如下定义
- en: 'class Teacher(SchoolMember):'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Teacher(SchoolMember):'
- en: 'def __init__(self, name, age, salary):'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, age, salary):'
- en: '#Call the constructor of the class SchoolMember'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '#Call the constructor of the class SchoolMember'
- en: super().__init__(name, age)
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: super().__init__(name, age)
- en: 'self.salary = salary   #This is an additional field for this class'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'self.salary = salary   #This is an additional field for this class'
- en: 'print("A teacher was initialized") #This is an additional statement for this
    constructor'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'print("A teacher was initialized") #This is an additional statement for this
    constructor'
- en: '#This is an additional method for this class'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '#This is an additional method for this class'
- en: 'def displayValues(self):'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValues(self):'
- en: print("Name:", self.name)
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("Name:", self.name)
- en: print("Age:", self.age)
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("Age:", self.age)
- en: print("Salary:", self.salary)
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("Salary:", self.salary)
- en: '![](img/notice.jpg)The statement super().__init__(name, age) calls the constructor
    of the class SchoolMember and initializes the fields name and age of the class
    Teacher.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)The statement super().__init__(name, age) 调用了 SchoolMember
    类的构造函数，并初始化了 Teacher 类的字段 name 和 age。'
- en: Similarly, the class Student can be as follows
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类 Student 可以如下定义
- en: 'class Student(SchoolMember):'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Student(SchoolMember):'
- en: 'def __init__(self, name, age, finalGrade):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, age, finalGrade):'
- en: '#Call the constructor of the class SchoolMember'
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '#Call the constructor of the class SchoolMember'
- en: super().__init__(name, age)
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: super().__init__(name, age)
- en: self.finalGrade = finalGrade  #This is an additional field for this class
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.finalGrade = finalGrade  #This is an additional field for this class
- en: 'print("A student was initialized") #This is an additional statement for this
    constructor'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'print("一个学生被初始化") #这是构造函数的附加语句'
- en: '#This is an additional method for this class'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '#这是类的附加方法'
- en: 'def displayValues(self):'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValues(self):'
- en: print("Name:", self.name)
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("姓名:", self.name)
- en: print("Age:", self.age)
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("年龄:", self.age)
- en: print("Final grade:", self.finalGrade)
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("最终成绩:", self.finalGrade)
- en: '![](img/notice.jpg)The statement super().__init__(name, age) calls the constructor
    of the class SchoolMember and initializes the fields name and age of the class
    Student.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)语句super().__init__(name, age)调用了SchoolMember类的构造函数，并初始化了Student类的name和age字段。'
- en: The complete Python program is as follows.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Python程序如下。
- en: '![](img/my_exercise_header.png) file_38.8'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_38.8'
- en: '#Define the class SchoolMember.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义SchoolMember类。'
- en: 'class SchoolMember:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SchoolMember:'
- en: 'def __init__(self, name, age):'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, age):'
- en: self.name = name
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.name = name
- en: self.age = age
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.age = age
- en: print("A school member was initialized")
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("一个学校成员被初始化")
- en: '#Define the class Teacher. It inherits the class SchoolMember.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义类Teacher。它继承自类SchoolMember。'
- en: 'class Teacher(SchoolMember):'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Teacher(SchoolMember):'
- en: 'def __init__(self, name, age, salary):'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, age, salary):'
- en: '#Call the constructor of the class SchoolMember'
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '#调用SchoolMember类的构造函数'
- en: super().__init__(name, age)
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: super().__init__(name, age)
- en: 'self.salary = salary   #This is an additional field for this class'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'self.salary = salary   #这是类的附加字段'
- en: 'print("A teacher was initialized") #This is an additional statement for this
    constructor'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'print("一个教师被初始化") #这是构造函数的附加语句'
- en: '#This is an additional method for this class'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '#这是类的附加方法'
- en: 'def displayValues(self):'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValues(self):'
- en: print("Name:", self.name)
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("姓名:", self.name)
- en: print("Age:", self.age)
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("年龄:", self.age)
- en: print("Salary:", self.salary)
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("薪水:", self.salary)
- en: '#Define the class Student. It inherits the class SchoolMember.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义类Student。它继承自类SchoolMember。'
- en: 'class Student(SchoolMember):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Student(SchoolMember):'
- en: 'def __init__(self, name, age, finalGrade):'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name, age, finalGrade):'
- en: '#Call the constructor of the class SchoolMember'
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '#调用SchoolMember类的构造函数'
- en: super().__init__(name, age)
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: super().__init__(name, age)
- en: self.finalGrade = finalGrade  #This is an additional field for this class
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: self.finalGrade = finalGrade  #这是类的附加字段
- en: 'print("A student was initialized") #This is an additional statement for this
    constructor'
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'print("一个学生被初始化") #这是构造函数的附加语句'
- en: '#This is an additional method for this class'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '#这是类的附加方法'
- en: 'def displayValues(self):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValues(self):'
- en: print("Name:", self.name)
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("姓名:", self.name)
- en: print("Age:", self.age)
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("年龄:", self.age)
- en: print("Final grade:", self.finalGrade)
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("最终成绩:", self.finalGrade)
- en: '#Main code starts here'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: teacher1 = Teacher("Mr. John Scott", 43, 35000)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: teacher1 = Teacher("Mr. John Scott", 43, 35000)
- en: teacher2 = Teacher("Mrs. Ann Carter", 5, 32000)
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: teacher2 = Teacher("Mrs. Ann Carter", 5, 32000)
- en: student1 = Student("Peter Nelson", 14, "A")
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: student1 = Student("Peter Nelson", 14, "A")
- en: student2 = Student("Helen Morgan", 13, "B")
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: student2 = Student("Helen Morgan", 13, "B")
- en: teacher1.displayValues()
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: teacher1.displayValues()
- en: teacher2.displayValues()
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: teacher2.displayValues()
- en: student1.displayValues()
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: student1.displayValues()
- en: student2.displayValues()
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: student2.displayValues()
- en: '38.9 Review Questions: True/False'
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.9 复习问题：对/错
- en: Choose true or false for each of the following statements.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 对以下每个陈述选择对或错。
- en: 1)Procedural programming is better than object-oriented programming when it
    comes to writing large programs.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 1)在编写大型程序时，过程式编程比面向对象编程更好。
- en: 2)Object-oriented programming focuses on objects.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 2)面向对象编程侧重于对象。
- en: 3)An object combines data and functionality.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 3)一个对象结合了数据和功能。
- en: 4)Object-oriented programming enables you to maintain your code more easily
    but your code cannot be used easily by others.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 4)面向对象编程使你更容易维护代码，但你的代码不容易被他人使用。
- en: 5)You can create an object without using a class.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 5)你可以不使用类来创建一个对象。
- en: 6)The process of creating a new instance of a class is called “installation”.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 6)创建类的新实例的过程被称为“安装”。
- en: 7)In OOP, you always have to create at least two instances of the same class.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 7)在OOP中，你总是必须创建至少两个同一类的实例。
- en: 8)The __init__() method is executed when an object is instantiated.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 8)当创建一个对象时，会执行__init__()方法。
- en: 9)When you create two instances of the same class, the __init__() method of
    the class will be executed twice.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 9)当你创建同一类的两个实例时，类的__init__()方法将执行两次。
- en: 10)When a field is declared outside of the constructor, it is called an “instance
    field”.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 10)当字段在构造函数外部声明时，它被称为“实例字段”。
- en: 11)A class field is shared by all instances of the class.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 11)类字段被类的所有实例共享。
- en: 12)The principles of the object-oriented programming state that the data of
    a class should be hidden and safe from accidental alteration.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 12)面向对象编程的原则规定，类的数据应该被隐藏并且防止意外修改。
- en: 13)A property is a class member that provides a flexible mechanism to read,
    write, or compute the value of a field.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 13)属性是一个类成员，它提供了一个灵活的机制来读取、写入或计算字段的值。
- en: 14)A property exposes the internal implementation of a class.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 14)属性暴露了类的内部实现。
- en: 15)Class inheritance is one of the main concepts of OOP.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 15)类继承是面向对象编程的主要概念之一。
- en: 16)When a class is inherited, it is called the “derived class”.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 16)当一个类被继承时，它被称为“派生类”。
- en: 17)A parent class automatically inherits all the methods and fields of the child
    class.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 17)父类会自动继承子类的所有方法和字段。
- en: 38.10 Review Exercises
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 38.10 复习练习
- en: Complete the following exercises.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下练习。
- en: 1)Do the following
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 1)执行以下操作
- en: i)Write a class named Geometry that includes
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为Geometry的类，它包括
- en: a)a method named rectangleArea that accepts the base and the height of a rectangle
    through its formal argument list and then calculates and returns its area.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个名为rectangleArea的方法，它通过其形式参数列表接受矩形的底边和高度，然后计算并返回其面积。
- en: b)a method named triangleArea that accepts the base and the height of a triangle
    through its formal argument list and then calculates and returns its area. It
    is given that
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: b)一个名为triangleArea的方法，它通过其形式参数列表接受三角形的底边和高度，然后计算并返回其面积。已知
- en: .![Image](img/chapter10-05.png)
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter10-05.png)
- en: ii)Using the class cited above, write a Python program that prompts the user
    to enter the side of a square, the base and the height of a rectangle, and the
    base and the height of a triangle, and then displays the area for each one of
    them.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: ii)使用上述类，编写一个Python程序，提示用户输入正方形的边长、矩形的底边和高度以及三角形的底边和高度，然后显示每个形状的面积。
- en: 2)Do the following
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 2)执行以下操作
- en: i)Write a class named Pet which includes
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为Pet的类，它包括
- en: a)a constructor
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个构造函数
- en: b)an instance field named kind
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: b)一个名为kind的实例字段
- en: c)an instance field named legsNumber
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: c)一个名为legsNumber的实例字段
- en: d)a void method named startRunning that displays the message “Pet is running”
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: d)一个名为startRunning的无返回值方法，它显示消息“Pet is running”。
- en: e)a void method named stopRunning that displays the message “Pet stopped”
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: e)一个名为stopRunning的无返回值方法，它显示消息“Pet stopped”。
- en: ii)Write a Python program that creates two instances of the class Pet (for example,
    a dog and a monkey) and then calls some of their methods.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: ii)编写一个Python程序，创建两个名为Pet的类的实例（例如，一只狗和一只猴子），然后调用它们的一些方法。
- en: 3)Do the following
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 3)执行以下操作
- en: i)In the class Pet of the previous exercise
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: i)在上一个练习的Pet类中
- en: a)alter the fields kind and legsNumber to private fields _kind and _legsNumber
    correspondingly.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: a)将字段kind和legsNumber更改为私有字段_kind和_legsNumber。
- en: b)add a property named kind. It will be used to get and set the value of the
    field _kind. The setter must throw an error when the field is set to an empty
    value.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: b)添加一个名为kind的属性。它将用于获取和设置字段_kind的值。当字段设置为空值时，setter必须抛出错误。
- en: c)add a property named legsNumber. It will be used to get and set the value
    of the field _legsNumber. The setter must throw an error when the field is set
    to a negative value.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: c)添加一个名为legsNumber的属性。它将用于获取和设置字段_legsNumber的值。当字段设置为负值时，setter必须抛出错误。
- en: d)alter the constructor to accept initial values for the properties kind and
    legsNumber through its formal argument list.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: d)将构造函数更改为通过其形式参数列表接受属性kind和legsNumber的初始值。
- en: ii)Write a Python program that creates one instance of the class Pets (for example,
    a dog) and then calls both of its methods. Then try to set erroneous values for
    properties kind and legsNumber and see what happens.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: ii)编写一个Python程序，创建一个名为Pets（例如，一只狗）的类的实例，然后调用它的两个方法。然后尝试为属性kind和legsNumber设置错误值，看看会发生什么。
- en: 4)Do the following
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 4)执行以下操作
- en: i)Write a class named Box that includes
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为Box的类，它包括
- en: a)a constructor that accepts initial values for three private fields named _width,
    _length, and _height through its formal argument list.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个构造函数，它通过其形式参数列表接受三个名为_width, _length和_height的私有字段的初始值。
- en: b)a void method named displayVolume that calculates and displays the volume
    of a box whose dimensions are _width, _length, and _height. It is given that
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: b)一个名为displayVolume的无返回值方法，它计算并显示一个长方体的体积，其尺寸为_width, _length和_height。已知
- en: volume = width × length × height
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 体积 = 宽度 × 长度 × 高度
- en: c)a void method named displayDimensions that displays box's dimensions.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: c)一个名为displayDimensions的无返回值方法，它显示长方体的尺寸。
- en: ii)Using the class cited above, write a Python program that prompts the user
    to enter the dimensions of 30 boxes, and then displays their dimensions and their
    volume.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ii)使用上述类，编写一个Python程序，提示用户输入30个盒子的尺寸，然后显示它们的尺寸和体积。
- en: 'Hint: Create a list of 30 objects of the class Box.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：创建一个包含30个Box类对象的列表。
- en: 5)In the class Box of the previous exercise add three properties named width,
    length, and height. They will be used to get and set the values of the fields
    _width, _length, and _height. The setters must throw an error when the corresponding
    field is set to a negative value or zero.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 5)在上一练习的Box类中添加三个属性：width、length和height。它们将用于获取和设置字段_width、_length和_height的值。当相应的字段设置为负值或零时，setter必须抛出错误。
- en: 6)Do the following
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 6)执行以下操作
- en: i)Write a class named Cube that includes
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为Cube的类，包括
- en: a)a constructor that accepts an initial value for a private field named _edge
    through its formal argument list.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: a)a构造函数，通过形式参数列表接受一个名为_edge的私有字段的初始值。
- en: b)a void method named displayVolume that calculates and displays the volume
    of a cube whose edge length is edge. It is given that
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: b)一个无返回值的方法名为displayVolume，用于计算并显示边长为_edge的立方体的体积。已知
- en: volume = edge³
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 体积 = 边长³
- en: c)a void method named displayOneSurface that calculates and displays the surface
    area of one side of a cube whose edge length is _edge.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: c)一个名为displayOneSurface的无返回值方法，用于计算并显示边长为_edge的立方体一个面的表面积。
- en: d)a void method named displayTotalSurface that calculates and displays the total
    surface area of a cube whose edge length is _edge. It is given that
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: d)一个名为displayTotalSurface的无返回值方法，用于计算并显示边长为_edge的立方体的总表面积。已知
- en: total surface = 6 × edge²
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 总表面积 = 6 × 边长²
- en: ii)Using the class cited above, write a Python program that prompts the user
    to enter the edge length of a cube, and then displays its volume, the surface
    area of one of its sides, and its total surface area.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: ii)使用上述类，编写一个Python程序，提示用户输入立方体的边长，然后显示其体积、其中一个面的表面积和总表面积。
- en: 7)In the class Cube of the previous exercise add a property named edge. It will
    be used to get and set the value of the private field _edge. The setter must throw
    an error when the field is set to a negative value or zero.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 7)在上一练习的Cube类中添加一个名为edge的属性。它将用于获取和设置私有字段_edge的值。当字段设置为负值或零时，setter必须抛出错误。
- en: 8)Do the following
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 8)执行以下操作
- en: i)Write a class named Circle that includes
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为Circle的类，包括
- en: a)a constructor and a private field named _radius with an initial value of −1.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: a)a构造函数和一个名为_radius的私有字段，初始值为-1。
- en: b)a property named radius. It will be used to get and set the value of the field
    _radius. The getter must throw an error when the field has not yet been set, and
    the setter must throw an error when the field is set to a negative value or zero.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: b)一个名为radius的属性。它将用于获取和设置字段_radius的值。当字段尚未设置时，getter必须抛出错误，而当字段设置为负值或零时，setter必须抛出错误。
- en: c)a method named getDiameter that calculates and returns the diameter of a circle
    whose radius is _radius. It is given that
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: c)一个名为getDiameter的方法，用于计算并返回半径为_radius的圆的直径。已知
- en: diameter = 2 × radius
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 直径 = 2 × 半径
- en: d)a method named getArea that calculates and returns the area of a circle whose
    radius is _radius. It is given that
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: d)一个名为getArea的方法，用于计算并返回半径为_radius的圆的面积。已知
- en: area = 3.14 × radius²
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 面积 = 3.14 × 半径²
- en: e)a method named getPerimeter that calculates and returns the perimeter of a
    circle whose radius is _radius. It is given that
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: e)一个名为getPerimeter的方法，用于计算并返回半径为_radius的圆的周长。已知
- en: perimeter = 2 × 3.14 × radius
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 周长 = 2 × 3.14 × 半径
- en: ii)Write a subprogram named displayMenu that displays the following menu.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: ii)编写一个名为displayMenu的子程序，显示以下菜单。
- en: 1)Enter radius
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 1)输入半径
- en: 2)Display radius
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 2)显示半径
- en: 3)Display diameter
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 3)显示直径
- en: 4)Display area
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 4)显示面积
- en: 5)Display perimeter
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 5)显示周长
- en: 6)Exit
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 6)退出
- en: iii)Using the subprogram and the class cited above, write a Python program that
    displays the previously mentioned menu and prompts the user to enter a choice
    (of 1 to 6). If choice 1 is selected, the program must prompt the user to enter
    a radius. If choice 2 is selected, the program must display the radius entered
    in choice 1\. If choices 3, 4, or 5 are selected, the program must display the
    diameter, the area, or the perimeter correspondingly of a circle whose radius
    is equal to the radius entered in choice 1\. The process must repeat as many times
    as the user wishes.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: iii)使用上述子程序和类，编写一个Python程序，显示之前提到的菜单并提示用户输入一个选择（1到6）。如果选择1，程序必须提示用户输入一个半径。如果选择2，程序必须显示在选择1中输入的半径。如果选择3、4或5，程序必须相应地显示半径等于选择1中输入的半径的圆的直径、面积或周长。该过程必须重复用户希望进行的次数。
- en: 9)Assume that you work in a computer software company that is going to create
    a word processor application. You are assigned to write a class that will be used
    to provide information to the user.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 9) 假设你在一个即将创建文字处理应用程序的计算机软件公司工作。你被分配编写一个类，该类将用于向用户提供信息。
- en: i)Write a class named Info that includes
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为Info的类，包括
- en: a)a property named userText. It will be used to get and set the value of a private
    field named _userText. The setter must throw an error when the field is set to
    an empty value.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个名为userText的属性。它将用于获取和设置名为_userText的私有字段的值。当字段设置为空值时，setter必须抛出一个错误。
- en: b)a  method named getSpacesCount that returns the total number of spaces that
    property userText contains.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: b)一个名为getSpacesCount的方法，它返回userText属性包含的总空格数。
- en: c)a  method named getWordsCount that returns the total number of words that
    property userText contains.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: c)一个名为getWordsCount的方法，它返回userText属性包含的总单词数。
- en: d)a method named getVowelsCount that returns the total number of vowels that
    property userText contains.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: d)一个名为getVowelsCount的方法，它返回userText属性包含的元音字母总数。
- en: e)a method named getLettersCount that returns the  total number of characters
     (excluding spaces) that property userText contains.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: e)一个名为getLettersCount的方法，它返回userText属性包含的总字符数（不包括空格）。
- en: ii)Using the class cited above, write a testing program that prompts the user
    to enter a text and then displays all available information. Assume that the user
    enters only space characters or letters (uppercase or lowercase) and the words
    are separated by a single space character.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: ii)使用上述类，编写一个测试程序，提示用户输入文本，然后显示所有可用信息。假设用户只输入空格字符或字母（大写或小写），单词由单个空格字符分隔。
- en: 'Hint: In a text of three words, there are two spaces, which means that the
    total number of words is one more than the total number of spaces. Count the total
    number of spaces, and then you can easily find the total number of words!'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在一个三个单词的文本中，有两个空格，这意味着单词总数比空格总数多一个。计算空格总数，然后你可以轻松地找到单词总数！
- en: '10)During the Cold War after World War II, messages were encrypted so that
    if the enemies intercepted them, they could not decrypt them without the decryption
    key. A very simple encryption algorithm is alphabetic rotation. The algorithm
    moves all letters N steps "up" in the alphabet, where N is the encryption key.
    For example, if the encryption key is 2, you can encrypt a message by replacing
    the letter A with the letter C, the letter B with the letter D, the letter C with
    the letter E, and so on.  Do the following:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 10) 在二战后的冷战期间，消息被加密，以便如果敌人截获它们，没有解密密钥就无法解密。一个非常简单的加密算法是字母旋转。该算法将所有字母向上移动N步，其中N是加密密钥。例如，如果加密密钥是2，你可以通过将字母A替换为字母C，将字母B替换为字母D，将字母C替换为字母E，以此类推来加密一条消息。 执行以下操作：
- en: i)Write a class named EncryptDecrypt that includes
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为EncryptDecrypt的类，包括
- en: a)a constructor and a private field named _encrDecrKey with an initial value
    of −1.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个构造函数和一个名为_encrDecrKey的私有字段，其初始值为-1。
- en: b)a property named encrDecrKey. It will be used to get and set the value of
    the field _encrDecrKey. The getter must throw an error when the field has not
    yet been set, and the setter must throw an error when the field is not set to
    a value between 1 and 26.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: b)一个名为encrDecrKey的属性。它将用于获取和设置名为_encrDecrKey的字段的值。当字段尚未设置时，getter必须抛出一个错误，当字段未设置为1到26之间的值时，setter必须抛出一个错误。
- en: c)a method named encrypt that accepts a message through its formal argument
    list and then returns the encrypted message.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: c)一个名为encrypt的方法，它通过其形式参数列表接受一条消息，然后返回加密后的消息。
- en: d)a method named decrypt that accepts an encrypted message through its formal
    argument list and then returns the decrypted message.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: d)一个名为decrypt的方法，它通过形式参数列表接受一个加密消息，然后返回解密后的消息。
- en: 'ii)Write a subprogram named displayMenu that displays the following menu:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: ii)编写一个名为displayMenu的子程序，显示以下菜单：
- en: 1)Enter encryption/decryption key
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 1)输入加密/解密密钥
- en: 2)Encrypt a message
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 2)加密消息
- en: 3)Decrypt a message
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 3)解密消息
- en: 4)Exit
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 4)退出
- en: iii)Using the subprogram and the class cited above, write a Python program that
    displays the menu previously mentioned and then prompts the user to enter a choice
    (of 1 to 4). If choice 1 is selected, the program must prompt the user to enter
    an encryption/decryption key. If choice 2 is selected, the program must prompt
    the user to enter a message and then display the encrypted message. If choice
    3 is selected, the program must prompt the user to enter an encrypted message
    and then display the decrypted message. The process must repeat as many times
    as the user wishes. Assume that the user enters only lowercase letters or a space
    for the message.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: iii)使用上述子程序和类，编写一个Python程序，显示之前提到的菜单，然后提示用户输入一个选择（1到4）。如果选择1，程序必须提示用户输入加密/解密密钥。如果选择2，程序必须提示用户输入一个消息，然后显示加密后的消息。如果选择3，程序必须提示用户输入一个加密消息，然后显示解密后的消息。此过程必须根据用户的意愿重复进行。假设用户只输入小写字母或空格作为消息。
- en: '11)Do the following:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 11)执行以下操作：
- en: i)Write a parent class named Vehicle that includes
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为Vehicle的父类，它包含
- en: a)a constructor that accepts initial values for three instance fields named
    numberOfWheels, color, length, width, and height through its formal argument list.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个构造函数，它通过形式参数列表接受三个实例字段名为numberOfWheels、color、length、width和height的初始值。
- en: b)two void methods named startEngine and stopEngine that display the messages
    “The engine started” and “The engine stopped”, correspondingly.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: b)两个名为startEngine和stopEngine的void方法，分别显示消息“引擎已启动”和“引擎已停止”。
- en: ii)Write a child class named Car that inherits the class Vehicle. Additionally,
    it includes
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: ii)编写一个名为Car的子类，它继承自Vehicle类。此外，它还包含
- en: a)a constructor with an additional instance field named bootCapacity and an
    initial value of zero.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个带有额外实例字段bootCapacity和初始值零的构造函数。
- en: b)a void method named turnWindshieldWipersOn that displays the message “The
    windshield wipers have been turned on!”.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: b)一个名为turnWindshieldWipersOn的void方法，显示消息“雨刷已被打开！”。
- en: iii)Write a child class named Motorcycle that inherits the class Vehicle. Additionally,
    it must include
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: iii)编写一个名为Motorcycle的子类，它继承自Vehicle类。此外，它还必须包含
- en: a)a constructor with an additional instance field named hasLuggage and an initial
    value of False.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个带有额外实例字段hasLuggage和初始值False的构造函数。
- en: b)a void method named doAWheelie that displays the message “I am doing a wheelie!!!”
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: b)一个名为doAWheelie的void方法，显示消息“我在做轮滑！！！”
- en: iv)Using the classes cited above, write a Python program that creates two instances
    of the class Car and one instance of the class Motorcycle, assigns some values
    to their fields, and then calls all of their methods.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: iv)使用上述类，编写一个Python程序，创建两个Car类的实例和一个Motorcycle类的实例，为它们的字段分配一些值，然后调用它们的所有方法。
- en: '12)Alter the Python program of [Section 38.8 - Class Inheritance](#toc_10)
    (file_38.8) as follows:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 12)按照以下方式修改[第38.8节 - 类继承](#toc_10)（文件_38.8）的Python程序：
- en: i)In the class SchoolMember, alter the fields name and age to private fields
    _name and _age correspondingly, and add getter and setter methods for both of
    them. The setter method of the field _name must throw an error when it is set
    to an empty value, whereas the setter method of the field _age must throw an error
    when it is set to a negative value or zero.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: i)在SchoolMember类中，将字段name和age更改为私有字段_name和_age，并为它们添加getter和setter方法。当_name字段的setter方法设置为空值时必须抛出错误，而_age字段的setter方法在设置为负值或零时必须抛出错误。
- en: ii)In the class Teacher, alter the field salary to private field _salary, and
    add getter and setter methods for it. The setter method must throw an error when
    the field is set to a negative value.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: ii)在Teacher类中，将字段salary更改为私有字段_salary，并为它添加getter和setter方法。当字段设置为负值时，setter方法必须抛出错误。
- en: iii)In the class Student, alter the field finalGrade to private field _finalGrade,
    and add getter and setter methods for it. The setter method must throw an error
    when the field is set to a value other than A, B, C, D, E, or F.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: iii)在Student类中，将字段finalGrade改为私有字段_finalGrade，并为它添加getter和setter方法。setter方法必须在字段被设置为A、B、C、D、E或F之外的值时抛出错误。
- en: 13)Alter the Python program of the previous exercise so that, instead of getter
    and setter methods, it uses properties.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 13)修改前一个练习中的Python程序，使其使用属性而不是getter和setter方法。
