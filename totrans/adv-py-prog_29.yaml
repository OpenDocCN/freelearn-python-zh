- en: '*Chapter 26*: The Observer Pattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the observer pattern when we want to be able to inform/notify all stakeholders
    (an object or a group of objects) when the state of an object changes. An important
    feature of the observer pattern is that the number of subscribers/observers, as
    well as who the subscribers are, may vary and can be changed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about this design pattern while comparing it
    to a similar one we have seen in the past, known as the MVC pattern, and use it
    to implement a data formatter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter26](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter26).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we need to update a group of objects when the state of another object changes,
    a popular solution is offered by the **Model-View-Controller** (**MVC**) pattern.
    Let's assume that we are using the data of the same *model* in two *views*; for
    instance, in a pie chart and a spreadsheet. Whenever the model is modified, both
    views need to be updated. That's the role of the observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern describes a publish-subscribe relationship between a single
    object – the publisher, which is also known as the **subject** or **observable**
    – and one or more objects – the subscribers, also known as **observers**.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of MVC, the publisher is the model, while the subscribers are the
    views. There are other examples that we will discuss throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The ideas behind the observer pattern are the same as those behind the separation
    of concerns principle; that is, to increase decoupling between the publisher and
    subscribers, and to make it easy to add/remove subscribers at runtime. Let's look
    at a couple of examples of this.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In reality, an auction resembles the observer pattern. Every auction bidder
    has a numbered paddle that is raised whenever they want to place a bid. Whenever
    the paddle is raised by a bidder, the auctioneer acts as the subject by updating
    the price of the bid and broadcasting the new price to all bidders (subscribers).
  prefs: []
  type: TYPE_NORMAL
- en: 'In software, we can cite at least two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Kivy, the Python framework for developing user interfaces, has a module called
    **Properties**, which implements the observer pattern. Using this technique, you
    can specify what should happen when a property's value changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RabbitMQ library can be used to add asynchronous messaging support to an
    application. Several messaging protocols are supported, such as HTTP and AMQP.
    RabbitMQ can be used in a Python application to implement a publish-subscribe
    pattern, which is nothing more than the observer design pattern ([j.mp/rabbitmqobs](http://j.mp/rabbitmqobs)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will discuss when this design pattern could and should
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We generally use the observer pattern when we want to inform/update *one or
    more objects* (observers/subscribers) about a change that happened on *a given
    object* (subject/publisher/observable). The number of observers, as well as who
    those observers are, may vary and can be changed dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of many cases where the observer pattern can be useful. One such
    use case is **newsfeeds**. With RSS, Atom, or other related formats, you follow
    a feed, and every time it is updated, you receive a notification about the update.
  prefs: []
  type: TYPE_NORMAL
- en: The same concept exists in social networking. If you are connected to another
    person using a social networking service, and your connection updates something,
    you are notified about it. It doesn't matter if the connection is a Twitter user
    that you follow, a real friend on Facebook, or a business colleague on LinkedIn.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event-driven systems** is another example where the observer pattern is usually
    used. In such systems, you have *listeners* that *listen* for specific events.
    The listeners are triggered when an event they are listening to is created. This
    can be typing a specific key (on the keyboard), moving the mouse, and more. The
    event plays the role of the publisher, and the listeners play the role of the
    observers. The key point, in this case, is that multiple listeners (observers)
    can be attached to a single event (publisher).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the next section, we will implement a data formatter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ideas described here are based on the ActiveState Python Observer code recipe
    ([https://code.activestate.com/](https://code.activestate.com/)). There is a default
    formatter that shows a value in decimal format. However, we can add/register more
    formatters. In this example, we will add a hex formatter and a binary formatter.
    Every time the value of the default formatter is updated, the registered formatters
    will be notified and take action. In this case, the action is to show the new
    value in the relevant format.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern is one of the patterns where inheritance makes sense. We
    can have a base `Publisher` class that contains the common functionality of adding,
    removing, and notifying observers. Our `DefaultFormatter` class derives from `Publisher`
    and adds the formatter-specific functionality. We can also dynamically add and
    remove observers on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with the `Publisher` class. The observers are kept in the observer''s
    list. The `add()` method registers a new observer or throws an error if it already
    exists. The `remove()` method unregisters an existing observer or throws an exception
    if it does not exist. Finally, the `notify()` method informs all observers about
    a change. This is shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's continue with the `DefaultFormatter` class. The first thing that `__init__()`
    does is call the `__init__()` method of the base class since this is not done
    automatically in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `DefaultFormatter` instance has a name to make it easier for us to track
    its status. We use `_data` variable to state that it should not be accessed directly.
    Note that this is always possible in Python but fellow developers have no excuse
    for doing so since the code already states that they shouldn''t. `DefaultFormatter`
    treats the `_data` variable as an integer, and the default value is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__str__()` method returns information about the name of the publisher
    and the value of the `_data` attribute. `type(self).__name__` is a handy trick
    to get the name of a class without hardcoding it. It is one of those tricks that
    makes your code easier to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two `data()` methods. The first one uses the `@property` decorator
    to give read access to the `_data` variable. Using this, we can just execute `object.data`
    instead of `object.data()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `data()` method is more interesting. It uses the `@setter` decorator,
    which is called every time the assignment (`=`) operator is used to assign a new
    value to the `_data` variable. This method also tries to cast a new value to an
    integer, and does exception handling in case this operation fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the observers. The functionality of `HexFormatter`
    and `BinaryFormatter` is very similar. The only difference between them is how
    they format the value of the data that''s received by the publisher – that is,
    in hexadecimal and binary, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To help us use those classes, the `main()` function initially creates a `DefaultFormatter`
    instance named `test1` and, afterward, attaches (and detaches) the two available
    observers. We also have some exception handling to ensure that the application
    doesn't crash when erroneous data is passed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, tasks such as trying to add the same observer twice or removing an
    observer that does not exist should cause no crashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we run this code and observe the output, let''s have a recap on the
    full code (the `observer.py` file):'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the `Publisher` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we define the `DefaultFormatter` class, along with its `special __init__`
    and `__str__` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the `data` property getter and setter methods to the `DefaultFormatter`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define our two observer classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we take care of the main part of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Executing the `python observer.py` command gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that as the extra observers are added, the more (and more
    relevant) output is shown, and when an observer is removed, it is not notified
    any longer. That''s exactly what we want: runtime notifications that we can enable/disable
    on demand.'
  prefs: []
  type: TYPE_NORMAL
- en: The defensive programming part of the application also seems to work fine. Trying
    to do funny things, such as removing an observer that does not exist or adding
    the same observer twice, is not allowed. The messages that are shown are not very
    user-friendly, but I leave it up to you to make them friendlier as an exercise.
    Runtime failures such as trying to pass a string when the API expects a number
    are also handled properly without causing the application to crash/terminate.
  prefs: []
  type: TYPE_NORMAL
- en: This example would be much more interesting if it were interactive. Even a simple
    menu that allows the user to attach/detach observers at runtime and modify the
    value of `DefaultFormatter` would be nice because the runtime aspect becomes much
    more visible. Feel free to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Another nice exercise is to add more observers. For example, you can add an
    octal formatter, a Roman numeral formatter, or any other observer that uses your
    favorite representation. Be creative! With this, we have completed our discussion
    on the observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the observer design pattern, including many examples,
    such as Kivy, the framework for developing innovative user interfaces, along with
    its **Properties** concept and module, and the Python bindings of RabbitMQ (we
    referred to a specific example of RabbitMQ that's used to implement the publish-subscribe,
    or the observer, pattern).
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to use the observer pattern to create data formatters that
    can be attached and detached at runtime to enrich the behavior of an object. Hopefully,
    you will find the recommended exercises interesting.
  prefs: []
  type: TYPE_NORMAL
- en: This also marks the end of this book. Congratulations on making it to the end,
    and I hope that the material that's been covered has been helpful for you in taking
    your Python skills to the next level!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the main motivation for the observer pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the observer pattern different from the MVC pattern when it comes to
    updating other components of an application when a target component changes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the observer pattern implemented in the Python example of value formatters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
