<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer088" class="_idGenObjectStyleOverride-1">&#13;
			<h1 id="_idParaDest-181" class="chapter-number" lang="en-GB"><a id="_idTextAnchor197"/>11</h1>&#13;
			<h1 id="_idParaDest-182" lang="en-GB"><a id="_idTextAnchor198"/>ARM Addressing Modes</h1>&#13;
			<p lang="en-GB">Addressing modes are a fundamental part of computer architecture and are concerned with how you express the location of an operand. We introduced addressing modes in earlier chapters. Now, we will examine the ARM’s rather sophisticated set of <span class="No-Break">addressing modes.</span></p>&#13;
			<p lang="en-GB">The topics to be discussed are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><span class="No-Break">Literal addressing</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">Scaled literals</span></li>&#13;
				<li lang="en-GB">Register <span class="No-Break">indirect addressing</span></li>&#13;
				<li lang="en-GB">The use of <span class="No-Break">two-pointer registers</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">Auto-incrementing pointers</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-183" lang="en-GB"><a id="_idTextAnchor199"/>Literal addressing</h1>&#13;
			<p lang="en-GB">The easiest addressing mode is <em class="italic">literal addressing</em>. Instead of saying where an operand is in memory, you provide the operand in an instruction (i.e., this is literally the value). Other addressing modes require you to specify where an operand is in memory. Consider the following Python expression, which has two literals, 30 <span class="No-Break">and 12:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">if A &gt; 30: B = </strong><span class="No-Break"><strong class="source-inline">12</strong></span></p>&#13;
			<p lang="en-GB">We can express this fragment of Python in ARM assembly language <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                         <span class="sc-comment">@ Register r0 is A and r1 is B</span></span>&#13;
<span>      cmp    r0,#30      <span class="sc-comment">@ Compare A with 30</span></span>&#13;
<span>      ble    Exit        <span class="sc-comment">@ If A ≤ 30, skip the next operation</span></span>&#13;
<span>      mov    r1,#12      <span class="sc-comment">@ else B = 12</span></span></pre>&#13;
			<pre class="source-code">Exit:</pre>&#13;
			<p lang="en-GB">We can simplify this code by using conditional execution, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      cmp    r0,#30      <span class="sc-comment">@ Compare A with 30</span></span>&#13;
<span>      movgt  r1,#12      <span class="sc-comment">@ If A &gt; 30, then B = 12</span></span></pre>&#13;
			<h2 id="_idParaDest-184" lang="en-GB"><a id="_idTextAnchor200"/>Scaled literals</h2>&#13;
			<p lang="en-GB">The ARM implements 12-bit literals in an unusual way, using a technique borrowed from the world of floating-point arithmetic. Four of the 12 bits of a literal are used to scale an 8-bit constant. That is, the 8-bit constant is rotated right by twice the number in the 4-bit scaling field. The four most-significant bits of the literal field specify the literal’s alignment within a 32-bit word. If the 8-bit immediate value is <strong class="source-inline">N</strong> and the 4-bit alignment is <strong class="source-inline">n</strong>, then the value of the literal is given by <strong class="source-inline">N</strong> rotated <em class="italic">right</em> by <em class="italic">2n</em> places. For example, if the 8-bit literal is <strong class="source-inline">0xAB</strong> and <strong class="source-inline">n</strong> is <strong class="source-inline">4</strong>, the resulting 32-bit literal is <strong class="source-inline">0xAB000000</strong> because of the eight-position right rotation (2 x 4). Remember that an eight rotate right position is equivalent to a 32 - 8 = 24 bit shift left. <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.1</em> demonstrates some 32-bit literals and the 12-bit literal codes that <span class="No-Break">generate them.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer078" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_11.01_B19624.jpg" alt="Figure 11.1 – ARM’s literal operand encoding" width="1746" height="729"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – ARM’s literal operand encoding</p>&#13;
			<p lang="en-GB">You might find this rather strange. Why didn’t ARM use the 12-bit literal field to provide a number in the range 0 to 4,095, rather than a number in the range 0 to 255 scaled by the power of 2? The answer is that ARM’s designers determined that the scaled literals were more useful in real-world applications than unscaled numbers. For example, suppose you wanted to clear all bits of a 32-bit word, except bits 8 to 15. You would need to <strong class="source-inline">AND</strong> it with the literal <strong class="source-inline">0b00000000000000001111111100000000</strong> or <strong class="source-inline">0x0000FF00</strong> in hexadecimal. Using the scaling mechanism, we can take 8 bits <strong class="source-inline">0x11111111</strong> and shift them left by 8 bits (i.e., right by 24 bits) to get the required constant. However, the scaling factor <strong class="source-inline">n</strong> needs twice the number of rotation rights to achieve this. That is (32 – 8)/2, which is 12. Consequently, the literal stored in the 12-bit instruction field is 12,255, or CFF <span class="No-Break">in hexadecimal.</span></p>&#13;
			<p lang="en-GB">Fortunately, calculating the scaling factor is something the programmer does not always have to worry about. ARM compilers take a constant and automatically generate the best instruction(s) necessary to <span class="No-Break">generate it.</span></p>&#13;
			<h1 id="_idParaDest-185" lang="en-GB"><a id="_idTextAnchor201"/>Register indirect addressing</h1>&#13;
			<p lang="en-GB">We have already encountered this addressing mode where the location of an operand is held in a register. It is called register <em class="italic">indirect addressing</em> because the instruction specifies the register where a pointer to the actual operand can be found. In ARM literature, this addressing mode is called <em class="italic">indexed addressing</em>. Some people call this <span class="No-Break"><em class="italic">base addressing</em></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Register indirect addressing mode requires three read operations to access <span class="No-Break">an operand:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Read the instruction to find the <span class="No-Break">pointer register</span></li>&#13;
				<li lang="en-GB">Read the pointer register to find the <span class="No-Break">operand address</span></li>&#13;
				<li lang="en-GB">Read memory at the operand address to find <span class="No-Break">the operand</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">Register indirect addressing is important because the contents of the register containing the pointer to the actual operand can be modified at runtime, and therefore, the address is a variable. Consequently, we can step through data structures such as tables by changing <span class="No-Break">the pointer.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer079" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_11.02_B19624.jpg" alt="Figure 11.2 – Register indirect addressing – executing ldr r1,[r0]" width="1229" height="546"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Register indirect addressing – executing ldr r1,[r0]</p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.2</em> illustrates the effect of <strong class="source-inline">ldr</strong> <span class="pcode-bold">r1</span>,<strong class="source-inline">[r0]</strong>, where <strong class="source-inline">r0</strong> is the pointer and contains the <span class="No-Break">value </span><span class="No-Break"><strong class="source-inline">n</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">ldr </strong><span class="pcode-bold">r1</span><strong class="source-inline">,[r0]</strong> loads the contents of the memory location pointed at by register <strong class="source-inline">r0</strong> into <span class="No-Break">register </span><span class="No-Break"><strong class="source-inline">r1</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Executing <strong class="source-inline">add </strong><span class="pcode-bold">r0</span><strong class="source-inline">,r0,#4</strong> increments the contents of the pointer register <strong class="source-inline">r0</strong> by 4 to point at the next word location (remember that consecutive word addresses differ <span class="No-Break">by 4).</span></p>&#13;
			<p lang="en-GB">Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>   ldr <strong class="bold">r1</strong>,[r0]                   <span class="sc-comment">@ Get data pointed at by r0</span></span>&#13;
<span>   add <strong class="bold">r0</strong>,r0,#4                  <span class="sc-comment">@ Advance pointer to next word location</span></span></pre>&#13;
			<p lang="en-GB">The first instruction loads <strong class="source-inline">r1</strong> with the 32-bit word pointed at by <strong class="source-inline">r0</strong>. The second instruction increments <strong class="source-inline">r0</strong> by 4 to point at the next byte in memory. Repeating this pair of instructions will allow you to step through a table of values, element by element. We will soon see that the ARM includes a mechanism to automatically increment or decrement <span class="No-Break">the pointer.</span></p>&#13;
			<p lang="en-GB">The next fragment of code demonstrates how you would add together the elements of a table. Suppose that you have a table of daily expenditures you have made over four weeks. Each item is stored consecutively in a table with 4 x 7 = <span class="No-Break">28 entries:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      adr <strong class="bold">r0</strong>,table               <span class="sc-comment">@ </span><span class="sc-comment">r0 points to the table of data (pseudo-instruction)</span></span>&#13;
<span>      add <strong class="bold">r3</strong>,r0,#28 * 4          <span class="sc-comment">@ r3 points to the end of the table (28 x 4 bytes)</span></span>&#13;
<span>      mov <strong class="bold">r1</strong>,#0                  <span class="sc-comment">@ Clear the sum in r1</span></span>&#13;
<span class="sc-grey" lang="en-GB">loop: <strong class="bold">ldr r2,[r0]</strong>                <span class="sc-comment-bold">@ REPEAT: Get the next value in r2</span></span>&#13;
<span class="sc-grey" lang="en-GB">      add r1,r1,r2               <span class="sc-comment">@ Add the new value to the running total</span></span>&#13;
<span class="sc-grey" lang="en-GB">      add r0,r0,#4               <span class="sc-comment">@ Point to the next location in the table (4 bytes increment)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">      cmp r0,r3                  <span class="sc-comment">@ Are we at the end of the table?</span></span>&#13;
<span class="sc-bottom" lang="en-GB">      bne loop                   <span class="sc-comment">@ UNTIL all elements added</span></span>&#13;
<span class="sc-bottom" lang="en-GB">table: .word 123                 <span class="sc-comment">@ Data for day 1</span></span>&#13;
<span class="sc-bottom" lang="en-GB">       .word 456                 <span class="sc-comment">@ Data for day 2</span></span>&#13;
<span class="sc-bottom" lang="en-GB">       .word 20                  <span class="sc-comment">@ Data for day 28</span></span></pre>&#13;
			<p lang="en-GB">In this simple example, we set up a loop and step through elements from the first to the last. On each cycle, we read an element and add it to the total. The shaded lines are where the action takes place – getting an element and pointing to the <span class="No-Break">next one.</span></p>&#13;
			<p lang="en-GB">The next example demonstrates both pointer-based indirect addressing and byte operations (i.e., operations on an 8-bit value rather than a full word). Suppose we want to find a given character within a string. The following code uses a <em class="italic">byte load instruction</em>, <strong class="source-inline">ldrb</strong>, which loads 8 bits into the destination register. We increment the pointer by 1 as we step through the string, not 4, because the values are on <span class="No-Break">one-byte boundaries:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      ldr<span class="subscript"> </span>      r0,=String       <span class="sc-comment"> @ r0 points at the string (using a pseudo-instruction)</span></span>&#13;
<span>loop: <strong class="bold">ldrb</strong>      <strong class="bold">r1</strong>,[r0]          <span class="sc-comment">@ REPEAT Read a byte character</span></span>&#13;
<span>      add<span class="subscript"> </span>      <strong class="bold">r0</strong>,r0,#1         <span class="sc-comment"> @ Update character pointer by 1 (not by 4)</span></span>&#13;
<span>      cmp<span class="subscript"> </span>      r1,#Term         <span class="sc-comment"> @ UNTIL terminator found</span></span></pre>&#13;
			<pre class="source-code">      bne      loop</pre>&#13;
			<h2 id="_idParaDest-186" lang="en-GB"><a id="_idTextAnchor202"/>Pointer-based addressing with an offset</h2>&#13;
			<p lang="en-GB">Suppose someone asks you, <em class="italic">“Where’s the pharmacy?”</em> You might reply, <em class="italic">“It’s two blocks to the left of the bank.”</em> That’s pointer-based offset addressing in everyday life. We point to the bank by giving its location in relation to <span class="No-Break">something else.</span></p>&#13;
			<p lang="en-GB">The ARM allows you to specify an address using a pointer register, plus a 12-bit literal that supplies the offset. Note that this is a true 12-bit literal rather than the 8-bit scaled value used as a literal operand. The literal can be positive or negative (indicating that it’s to be added to or subtracted from the base pointer). Consider <strong class="source-inline">ldr </strong><span class="pcode-bold">r5</span><strong class="source-inline">,[r2,#160]</strong>, where the address of the operand loaded into <strong class="source-inline">r5</strong> is the contents of <strong class="source-inline">r1</strong> <span class="No-Break">plus 160.</span></p>&#13;
			<p lang="en-GB">Suppose you wanted to move a block of 24 words to a location that is 128 bytes further on in memory. Assume that the address of the block to move is at <strong class="source-inline">0x400</strong>. We can write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      mov  <strong class="bold">r0</strong>,#0x400         <span class="sc-comment">@ r0 points to the block of data</span></span>&#13;
<span>      ldr  <strong class="bold">r1</strong>,#24            <span class="sc-comment">@ r1 contains the number of words to move</span></span>&#13;
<span class="sc-grey" lang="en-GB">next: ldr  <strong class="bold">r2</strong>,[r0]           <span class="sc-comment-bg">@ REPEAT: Read word and put in r2</span></span>&#13;
<span class="sc-grey" lang="en-GB">      add  <strong class="bold">r0</strong>,r0,#4          <span class="sc-comment">@ Point to next word</span></span>&#13;
<span class="sc-grey" lang="en-GB">      str  r2,<strong class="bold">[r0,#128]</strong>      <span class="sc-comment">@ Store the word 128 bytes on</span></span>&#13;
<span class="sc-grey" lang="en-GB">      subs <strong class="bold">r1</strong>,#1             <span class="sc-comment">@ Decrement the counter and set the status bits</span></span>&#13;
<span class="sc-grey" lang="en-GB">      bne  next              <span class="sc-comment">@ UNTIL all elements added</span></span></pre>&#13;
			<p lang="en-GB">Unfortunately, you cannot run this directly on an ARM-based Raspberry Pi as we described because you are not allowed to modify memory in a code segment. That is an operating system limitation. To avoid this problem, you have to use pointers, as we demonstrated in <a href="B19624_09.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>. We will return to <span class="No-Break">this point.</span></p>&#13;
			<h2 id="_idParaDest-187" lang="en-GB"><a id="_idTextAnchor203"/>Two pointers are better than one</h2>&#13;
			<p lang="en-GB">The register-indirect addressing mode lets you access elements in a linear data structure, such as a one-column table. Sometimes, you will have a more complex two-dimensional data structure, such as a matrix with rows and columns. In that case, two pointers can simplify programming – one pointer for the row and one for <span class="No-Break">the column.</span></p>&#13;
			<p lang="en-GB">ARM provides a pointer-based addressing mode that allows you to specify an address that is the sum of two pointer registers, such as <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>ldr <strong class="bold">r7</strong>,[r0,r1]               <span class="sc-comment">@ Load r7 with the contents of the location pointed at by r0 plus r1</span></span></pre>&#13;
			<p lang="en-GB">You can apply a shift to the second operand, such as <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>ldr <strong class="bold">r2</strong>,[r0,r1,<span class="sc-source-bold-bg">lsl</span> <span class="sc-source-bold-bg">#3]</span>        <span class="sc-comment">@ Load r7 with the contents of the location pointed at by r0 plus r1 x 8</span></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In this case, register <strong class="source-inline">r1</strong> is scaled by 8. The scaling factor must be a power of 2 (i.e., 2, 4, <span class="No-Break">8, 16…).</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.3</em> illustrates pointer-based addressing with two <span class="No-Break">index registers.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer080" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_11.03_B19624.jpg" alt="Figure 11.3 – Indexed addressing with a register offset – ldr r0,[r1,r2]" width="989" height="516"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Indexed addressing with a register offset – ldr r0,[r1,r2]</p>&#13;
			<p lang="en-GB">This is conceptual because we’ve shown one register pointing at memory (<strong class="source-inline">r1</strong>) and one register providing an offset from <strong class="source-inline">r1</strong> (i.e., <strong class="source-inline">r2</strong>). However, since the final address is <strong class="source-inline">r1</strong> plus <strong class="source-inline">r2</strong>, we could have drawn it the other <span class="No-Break">way around.</span></p>&#13;
			<h2 id="_idParaDest-188" lang="en-GB"><a id="_idTextAnchor204"/>Automatic indexing of pointer registers</h2>&#13;
			<p lang="en-GB">When pointer registers are used, they are frequently used to step through data structures and are often incremented or decremented after every memory access. It would, therefore, make sense to include this action as part of <span class="No-Break">the instruction.</span></p>&#13;
			<p lang="en-GB">Indeed, CISC processors invariably include automatic indexing. When RISC processors arrived with their <em class="italic">one instruction per clock cycle goal</em>, automatic indexing was dropped from the instruction set. However, this mechanism has been incorporated into <span class="No-Break">ARM architecture.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">ARM’s automatic indexing has four variations. You can do it before using a pointer or after using a pointer. You can index up toward higher addresses or down toward lower addresses. Consider the following operations involving an index register, <strong class="source-inline">r0</strong>, and an increment of 4 (for one word on a byte-addressed machine). Each option is composed of a memory access and a pointer adjust action; in the first two cases, the pointer is adjusted first (pre-indexing), and in the other two cases, memory is accessed first (post-indexing). Memory accesses are given <span class="No-Break">in bold:</span></p>&#13;
			<table id="table001-9" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Indexing type</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">First action</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Second action</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Pre-indexed up</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[r1] </strong><strong class="source-inline CharOverride-1" lang="ar-SA" xml:lang="ar-SA">←</strong><strong class="source-inline"> [r1] + 4</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">[r0] ← [[</span><span class="No-Break"><span class="pcode-bold">r1]]</span></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Pre-indexed down</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[r1] </strong><strong class="source-inline CharOverride-1" lang="ar-SA" xml:lang="ar-SA">←</strong><strong class="source-inline"> [r1] - 4</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">[r0] ← [[</span><span class="No-Break"><span class="pcode-bold">r1]]</span></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Post-indexed up</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">[r0] ← [[</span><span class="No-Break"><span class="pcode-bold">r1]]</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[r1] </strong><strong class="source-inline CharOverride-1" lang="ar-SA" xml:lang="ar-SA">←</strong><strong class="source-inline"> [r1] + 4</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Post-indexed down</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">[r0] ← [[</span><span class="No-Break"><span class="pcode-bold">r1]]</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[r1] </strong><strong class="source-inline CharOverride-1" lang="ar-SA" xml:lang="ar-SA">←</strong><strong class="source-inline"> [r1] – 4</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p lang="en-GB">ARM indicates pre-indexing by including the offset within square brackets and appending an exclamation mark, such as <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    str r4,<strong class="bold">[r0,#4]!</strong>   <span class="sc-comment">@ Store r4 at the address given by [r0] + 4 and then increment r0 by 4</span></span></pre>&#13;
			<p lang="en-GB">The value of the pointer <strong class="source-inline">r0</strong> changes <em class="italic">BEFORE</em> it is used as an offset. Let’s suppose we wish to use post-indexing and increment the pointer <em class="italic">AFTER</em> it is used. In this case, the format is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    str r4,<strong class="bold">[r0],#4</strong>    <span class="sc-comment">@ Store  r4 at the address given by [r0] and then increment r0 by 4</span>.</span></pre>&#13;
			<p lang="en-GB">Here, the value of the pointer <strong class="source-inline">r0</strong> changes <em class="italic">AFTER</em> it is used as <span class="No-Break">an offset.</span></p>&#13;
			<p lang="en-GB"><em class="italic">Figures 11.4</em> to<em class="italic"> 11.6</em> illustrate ARM’s variations on indexed addressing. In each case, the base register is <strong class="source-inline">r1</strong>, the offset is <strong class="source-inline">12</strong>, and the destination register is <strong class="source-inline">r0</strong>. These figures are <span class="No-Break">summarized here:</span></p>&#13;
			<table id="table002-7" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Figure</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Type</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Format</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Base </strong><span class="No-Break"><strong class="bold">reg before</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Base </strong><span class="No-Break"><strong class="bold">reg after</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Operand address</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">11.4</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Reg indirect</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">ldr </span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break">,[r1,#12]</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[<span class="No-Break">r1]</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[<span class="No-Break">r1]</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] + <span class="No-Break">12</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">11.5</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Pre-indexed</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">ldr </span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break">,[r1,#12]!</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[<span class="No-Break">r1]</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] + <span class="No-Break">12</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] + <span class="No-Break">12</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">11.6</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Post-indexing</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">ldr </span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break">,[r1],#12</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[<span class="No-Break">r1]</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] + <span class="No-Break">12</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[<span class="No-Break">r1]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer081" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_11.04_B19624.jpg" alt="Figure 11.4 – Register indirect addressing with an offset" width="896" height="361"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 11.4 – Register indirect addressing with an offset</p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer082" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_11.05_B19624.jpg" alt="Figure 11.5 – Register indirect addressing with pre-indexing" width="899" height="254"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Register indirect addressing with pre-indexing</p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer083" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_11.06_B19624.jpg" alt="Figure 11.6 – Register indirect addressing with post-indexing" width="1069" height="381"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Register indirect addressing with post-indexing</p>&#13;
			<p lang="en-GB">Consider the following example where we use post-indexing to move a block of data from one memory region to another. In this case, we use post-indexing by four because we move <span class="No-Break">4-byte words:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>       adr  <strong class="bold">r0</strong>,table1       <span class="sc-comment">@ Source array pointer in r0. Use pseudo instruction</span></span>&#13;
<span>       adr  <strong class="bold">r1</strong>,table2       <span class="sc-comment">@ Destination array pointer in r1</span></span>&#13;
<span>       mov  <strong class="bold">r2</strong>,#8           <span class="sc-comment">@ Eight elements (words) to move</span></span>&#13;
<span class="sc-grey" lang="en-GB">loop:  ldr  <strong class="bold">r3</strong>,[r0],#4      <span class="sc-comment">@ REPEAT: Get element from table 1 (post-indexing by 4)</span></span>&#13;
<span class="sc-grey" lang="en-GB">       str  r3,<strong class="bold">[r1]</strong>,<strong class="bold">#4</strong>      <span class="sc-comment">@ Store in table 2 (post-indexing 4)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">       subs <strong class="bold">r2</strong>,r2,#1        <span class="sc-comment">@ Decrement counter</span></span>&#13;
<span class="sc-bottom" lang="en-GB">       bne  loop            <span class="sc-comment">@ UNTIL all done</span></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The two key lines of this program are the load and store instructions (shaded), where data is read from the source and copied to the destination. As we have stated, you can’t run this code <em class="italic">directly</em> on Raspberry Pi without modification because of the way in which the memory space is allocated to variables. The following code demonstrates a runnable version for <span class="No-Break">Raspberry Pi.</span></p>&#13;
			<p lang="en-GB">This is, essentially, the same code. As well as dealing with the memory problem, we’ve added assembly directives and dummy data (complete with markers that allow you to observe data in memory more easily). There’s also a <strong class="source-inline">nop</strong> instruction. Note that some versions of ARM have a true <strong class="source-inline">nop</strong> and some use a pseudo-instruction. I added this as a dummy instruction to <em class="italic">“land on”</em> while testing. Remember that the address of the actual data is stored in the program area, and then a pointer is loaded with <span class="No-Break">that address:</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer084" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_11.07_B19624.jpg" alt="Figure 11.7 – The use of pointers when accessing read/write memory" width="1576" height="1508"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 11.7 – The use of pointers when accessing read/write memory</p>&#13;
			<p lang="en-GB">We ran the preceding program using <strong class="source-inline">gbd</strong> as a debugging tool, as the following output demonstrates. In order to condense the text, we’ve removed unnecessary data from the display – for example, registers that are not accessed <span class="No-Break">or modified.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer085" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_11.08_B19624.jpg" alt="Figure 11.8 – Using gdb to trace the program of Figure 11.7" width="1399" height="1415"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 11.8 – Using gdb to trace the program of Figure 11.7</p>&#13;
			<h2 id="_idParaDest-189" lang="en-GB"><a id="_idTextAnchor205"/>Example of string-copying</h2>&#13;
			<p lang="en-GB">The next example, <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.9</em>, uses post-indexing to copy a string from one place to another in reverse order by moving one pointer down and the other up. The destination pointer is incremented by <strong class="source-inline">len-1</strong> to point to the end of the string, initially. The following code includes assembly language directives, enabling it to run on <span class="No-Break">the RPi:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>         .equ    len,5            <span class="sc-comment">@ Length of string to reverse</span></span>&#13;
<span>         .text                    <span class="sc-comment">@ Program (code) area</span></span>&#13;
<span>         .global _start</span>&#13;
<span class="sc-grey" lang="en-GB">_<span class="sc-source-bg">start:  mov    r0,#len           </span><span class="sc-comment-bg">@ Number of characters to move</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">         adr    r1,adr_st1        </span><span class="sc-comment-bg">@ r1 points at source address 1</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">         adr    r2,adr_st2        </span><span class="sc-comment-bg">@ r2 points at source address 2</span></span>&#13;
<span class="sc-bottom" lang="en-GB">         ldr    r1,[r1]           <span class="sc-comment">@ Register r1 points to source</span></span>&#13;
<span class="sc-bottom" lang="en-GB">         ldr    r2,[r2]           <span class="sc-comment">@ Register r2 points to destination</span></span>&#13;
<span class="sc-bottom" lang="en-GB">         add    r2,r2,#len-1      <span class="sc-comment">@ r2 points to bottom of destination</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">Loop:    ldrb   r3,[r1],#1        </span><span class="sc-comment-bg">@ Get char from source, increment pointer (note ldbr)</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">         strb   r3,[r2],#-1       </span><span class="sc-comment-bg">@ Store char in destination, decrement pointer</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">         subs   r0,r0,#1          </span><span class="sc-comment-bg">@ Decrement char count</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">         bne    Loop              </span><span class="sc-comment-bg">@ REPEAT until all done</span></span>&#13;
<span class="sc-bottom" lang="en-GB">         nop                      <span class="sc-comment">@ Stop here</span></span>&#13;
<span class="sc-bottom" lang="en-GB">adr_st1: .word  str1</span>&#13;
<span class="sc-bottom" lang="en-GB">adr_st2: .word  str2</span>&#13;
<span class="sc-bottom" lang="en-GB">         .data</span>&#13;
<span class="sc-bottom" lang="en-GB">str1:    .ascii "Hello"           <span class="sc-comment">@ Source string</span></span>&#13;
<span class="sc-bottom" lang="en-GB">str2:    .byte  0,0,0,0,0         <span class="sc-comment">@ Destination string</span></span>&#13;
<span class="sc-bottom" lang="en-GB">         .end</span></pre>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer086" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_11.09_B19624.jpg" alt="Figure 11.9 – Reversing a string" width="1034" height="431"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Reversing a string</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The next section looks at a variation of pointer-based addressing where the pointer is the program counter itself. Consequently, all data and programs are referenced to the location of the <span class="No-Break">current program.</span></p>&#13;
			<h1 id="_idParaDest-190" lang="en-GB"><a id="_idTextAnchor206"/>Program counter-relative addressing</h1>&#13;
			<p lang="en-GB">The ARM is an unusual processor in so many ways. You can use any register (i.e., <strong class="source-inline">r0</strong> to <strong class="source-inline">r15</strong>) as a pointer register. However, <strong class="source-inline">r15</strong> is the ARM’s program counter. If you use <strong class="source-inline">r15</strong> as a pointer register with an index, you are saying, <em class="italic">“The operand is at this distance from where I am.”</em> Here the <em class="italic">“where I am”</em> refers to the instruction itself. <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.10</em> illustrates program <span class="No-Break">counter-relative addressing.</span></p>&#13;
			<p lang="en-GB">Think about it. You give the address of data with respect to the program that’s using it and not an absolute address in memory. If you move the program in memory, the data is still the same distance from the instructions that access it, using program counter-relative addressing. The introduction of program counter relative addressing was one of the major advances in computer architecture. By the way, most branch instructions use program counter relative addressing because the destination of a branch is specified with respect to the <span class="No-Break">current instruction.</span></p>&#13;
			<p lang="en-GB">The ARM uses program counter relative addressing to load 32-bit constants. Recall that you can load only 12-bit constants with the <strong class="source-inline">ldr</strong> instruction. However, the assembler can pre-load a 32-bit constant in memory and then use program counter relative addressing to access it. In other words, you dump a 32-value in memory near (or within) the program and then access it using program counter relative addressing. This is the reason for pseudo-instructions. Without pseudo-instructions, you’d have to calculate the relative address between the current <strong class="source-inline">pc</strong> and the desired operand. Pseudo-instructions do that and make the address invisible to <span class="No-Break">the programmer.</span></p>&#13;
			<p lang="en-GB">Executing <strong class="source-inline">ldr </strong><span class="pcode-bold">r0</span><strong class="source-inline">,[r15,#0x100]</strong> loads a 32-bit operand that is <strong class="source-inline">0x100</strong> bytes (0x40 or 64 words) from the contents of register <strong class="source-inline">r15</strong>, the program counter. The operand loaded into <strong class="source-inline">r0</strong> is <strong class="source-inline">0x108</strong> bytes from the pc. Why <strong class="source-inline">0x108</strong> and not <strong class="source-inline">0x100</strong>, as specified in the instruction? The additional 8 bytes are there because the program counter is incremented by 8 bytes after each instruction and, therefore, runs 8 bytes ahead of the <span class="No-Break">current address.</span></p>&#13;
			<p lang="en-GB">What about program counter relative store instructions? These cannot be used. Store operations using the program counter addressing mode are not supported in the ARM. This restriction is probably because (a) a lot of code is in read-only memory and can’t be changed, and (b) it would allow the modification of <span class="No-Break">runtime programs.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer087" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_11.10_B19624.jpg" alt="Figure 11.10 – Program counter relative addressing" width="1355" height="542"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 11.10 – Program counter relative addressing</p>&#13;
			<h2 id="_idParaDest-191" lang="en-GB"><a id="_idTextAnchor207"/>Demonstration of program counter relative addressing</h2>&#13;
			<p lang="en-GB">Consider the following text where we use two types of pseudo-instruction, both of which are designed to load a 32-bit value into a register. One is <strong class="source-inline">adr</strong> (load an address) and the other <strong class="source-inline">ldr</strong> (load a <span class="No-Break">32-bit literal):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        .text</span>&#13;
<span>        .global   _start</span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">_start: ldr r0,=pqr</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">        ldr r1,</span><strong class="bold">=abc</strong><span class="sc-source-bg">                </span><span class="sc-comment-bg">@ Note the special format of the pseudo ldr</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">        adr r2,pqr</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">        ldr r3,=0x11111111</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        nop</span>&#13;
<span class="sc-bottom" lang="en-GB">        mov r0,#0</span>&#13;
<span class="sc-bottom" lang="en-GB">        mov r7,#1</span>&#13;
<span class="sc-bottom" lang="en-GB">        svc 0</span>&#13;
<span class="sc-bottom" lang="en-GB"><strong class="bold">abc:</strong>   .word 0x22222222</span>&#13;
<span class="sc-bottom" lang="en-GB">pqr:   .word 0x33333333</span>&#13;
<span class="sc-bottom" lang="en-GB">       .end</span></pre>&#13;
			<p lang="en-GB">There are three <strong class="source-inline">ldr</strong> instructions. Two load addresses into registers and the third, <strong class="source-inline">ldr</strong>, loads a 32-bit literal <strong class="source-inline">0x11111111</strong>. There is an <strong class="source-inline">adr</strong> instruction that loads a 32-bit address into register <strong class="source-inline">r2</strong>. What happens when these codes <span class="No-Break">are executed?</span></p>&#13;
			<p lang="en-GB">First, let’s look at the source code when viewed <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">gdb</strong></span><span class="No-Break">:</span></p>&#13;
			<pre><span class="sc-top" lang="en-GB"><span class="sc-source-bg">0x10054 &lt;_start&gt;      ldr r0, [pc, #32]   ; 0x1007c &lt;pqr+4&gt;</span></span>&#13;
<span class="sc-top" lang="en-GB"><span class="sc-source-bg">0x10058 &lt;_start+4&gt;    ldr r1, [pc, #32]   ; 0x10080 &lt;pqr+8&gt;</span></span>&#13;
<span class="sc-top" lang="en-GB"><span class="sc-source-bg">0x1005c &lt;_start+8&gt;</span></span>&#13;
<span class="sc-top" lang="en-GB"><span class="sc-source-bg">0x10060 &lt;_start+12&gt;   ldr r3, [pc, #28]   ; 0x10084 &lt;pqr+12&gt;</span></span></pre>&#13;
			<p lang="en-GB">Note that these differ from the source code. That’s because the source code uses pseudo-instructions that are translated. For example, <strong class="source-inline">ldr r0,=pqr</strong> is translated into <strong class="source-inline">ldr r0,[pc,#32]</strong>. The source code cannot specify a 32-bit instruction. However, the translated version used a conventional load to specify the location of the actual operand 32 bits for the current value of the <span class="No-Break">program counter.</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">add r2,pc,#20</strong> is treated differently. Here, the 32-bit literal is generated by adding 20 to the value of the current pc, because the address to be located is 20 bytes from the current <span class="No-Break">PC value.</span></p>&#13;
			<p lang="en-GB">Let’s look at the registers when the code is executed up to <strong class="source-inline">nop</strong> using <strong class="source-inline">gdb</strong>. We will examine both the contents of the registers at the end of the program and then look at the memory locations. You can see the data stored in memory and the constants accessed by program counter <span class="No-Break">relative addressing:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>r0             0x00010078</span>&#13;
<span>r1             0x00010074</span>&#13;
<span>r2             0x00010078</span>&#13;
<span>r3             0x11111111</span>&#13;
<span>(gdb) x/8xw 0x10074</span>&#13;
<span>0x10074 &lt;abc&gt;:          0x22222222    0x33333333    0x00010078      0x00010074</span>&#13;
<span>0x10084 &lt;pqr+12&gt;:       0x11111111    0x00001141    0x61656100      0x00010069</span></pre>&#13;
			<p lang="en-GB">In the next chapter, we will continue the theme of addressing, looking at how the ARM implements subroutines and how you can use the stack to keep track of subroutine <span class="No-Break">return addresses.</span></p>&#13;
			<h1 id="_idParaDest-192" lang="en-GB"><a id="_idTextAnchor208"/>Summary</h1>&#13;
			<p lang="en-GB">Addressing modes comprise all the ways to express the location of an item in memory. Addressing modes are simultaneously the easiest and most difficult topic in assembly language programming. The concept is simple, but indirect addressing modes that use pointers may take some effort <span class="No-Break">to visualize.</span></p>&#13;
			<p lang="en-GB">In this chapter, we learned about literal or immediate addressing where an operand is an actual value (it’s the thing itself and not the location). Literal values are used to specify constants – for example, in x + 5, the number 5 is a literal. This is the simplest of addressing modes, and no memory location is accessed because the data is part of <span class="No-Break">the instruction.</span></p>&#13;
			<p lang="en-GB">We also looked at the ARM’s rather unusual way of specifying literals, by providing a value in the range of 0 to 255 and a multiplier that can multiply it by an even power of 2. You can specify 5 and store 5, 20, 80, and <span class="No-Break">so on.</span></p>&#13;
			<p lang="en-GB">Much of this chapter was taken up by register indirect addressing, which has a lot of other names (indexed and pointer-based). In this case, the address is given by the contents of a register. The instruction specifies not the actual address of an operand but the register that points to it. Because you can manipulate data in a register, you can manipulate addresses and access data structures such as arrays <span class="No-Break">and tables.</span></p>&#13;
			<p lang="en-GB">The ARM provides RISC-style auto-incrementing and decrementing. That means you can use a pointer and increment it or decrement it beforehand (or after it <span class="No-Break">is used).</span></p>&#13;
			<p lang="en-GB">We also looked at a special form of register indirect addressing, relative addressing, where the pointer is the program counter itself – that is, the address of an operand is specified with respect to the instruction that accesses it. This means that code using program counter relative addressing can be moved around in memory without any addresses <span class="No-Break">being recalculated.</span></p>&#13;
			<p lang="en-GB">In the next chapter, we will look at a topic that is fundamental to programming – the subroutine and the stack. This topic is also heavily related to <span class="No-Break">addressing modes.</span></p>&#13;
		</div>&#13;
	</div></body></html>