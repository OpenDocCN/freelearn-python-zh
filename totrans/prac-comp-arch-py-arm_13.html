<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-181" class="chapter-number" lang="en-GB"><a id="_idTextAnchor197"/>11</h1>&#13;
			<h1 id="_idParaDest-182" lang="en-GB"><a id="_idTextAnchor198"/>ARM Addressing Modes</h1>&#13;
			<p lang="en-GB">Addressing modes are a fundamental part of computer architecture and are concerned with how you express the location of an operand. We introduced addressing modes in earlier chapters. Now, we will examine the ARM’s rather sophisticated set of addressing modes.</p>&#13;
			<p lang="en-GB">The topics to be discussed are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Literal addressing</li>&#13;
				<li lang="en-GB">Scaled literals</li>&#13;
				<li lang="en-GB">Register indirect addressing</li>&#13;
				<li lang="en-GB">The use of two-pointer registers</li>&#13;
				<li lang="en-GB">Auto-incrementing pointers</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-183" lang="en-GB"><a id="_idTextAnchor199"/>Literal addressing</h1>&#13;
			<p lang="en-GB">The easiest addressing mode is <em class="italic">literal addressing</em>. Instead of saying where an operand is in memory, you provide the operand in an instruction (i.e., this is literally the value). Other addressing modes require you to specify where an operand is in memory. Consider the following Python expression, which has two literals, 30 and 12:</p>&#13;
			<p lang="en-GB"><code>if A &gt; 30: B = </code><code>12</code></p>&#13;
			<p lang="en-GB">We can express this fragment of Python in ARM assembly language as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                         @ Register r0 is A and r1 is B&#13;
      cmp    r0,#30      @ Compare A with 30&#13;
      ble    Exit        @ If A ≤ 30, skip the next operation&#13;
      mov    r1,#12      @ else B = 12</pre>&#13;
			<pre class="source-code">Exit:</pre>&#13;
			<p lang="en-GB">We can simplify this code by using conditional execution, as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      cmp    r0,#30      @ Compare A with 30&#13;
      movgt  r1,#12      @ If A &gt; 30, then B = 12</pre>&#13;
			<h2 id="_idParaDest-184" lang="en-GB"><a id="_idTextAnchor200"/>Scaled literals</h2>&#13;
			<p lang="en-GB">The ARM implements 12-bit literals in an unusual way, using a technique borrowed from the world of floating-point arithmetic. Four of the 12 bits of a literal are used to scale an 8-bit constant. That is, the 8-bit constant is rotated right by twice the number in the 4-bit scaling field. The four most-significant bits of the literal field specify the literal’s alignment within a 32-bit word. If the 8-bit immediate value is <code>N</code> and the 4-bit alignment is <code>n</code>, then the value of the literal is given by <code>N</code> rotated <em class="italic">right</em> by <em class="italic">2n</em> places. For example, if the 8-bit literal is <code>0xAB</code> and <code>n</code> is <code>4</code>, the resulting 32-bit literal is <code>0xAB000000</code> because of the eight-position right rotation (2 x 4). Remember that an eight rotate right position is equivalent to a 32 - 8 = 24 bit shift left. <em class="italic">Figure 11</em><em class="italic">.1</em> demonstrates some 32-bit literals and the 12-bit literal codes that generate them.</p>&#13;
			<div>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_11.01_B19624.jpg" alt="Figure 11.1 – ARM’s literal operand encoding" width="1746" height="729"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – ARM’s literal operand encoding</p>&#13;
			<p lang="en-GB">You might find this rather strange. Why didn’t ARM use the 12-bit literal field to provide a number in the range 0 to 4,095, rather than a number in the range 0 to 255 scaled by the power of 2? The answer is that ARM’s designers determined that the scaled literals were more useful in real-world applications than unscaled numbers. For example, suppose you wanted to clear all bits of a 32-bit word, except bits 8 to 15. You would need to <code>AND</code> it with the literal <code>0b00000000000000001111111100000000</code> or <code>0x0000FF00</code> in hexadecimal. Using the scaling mechanism, we can take 8 bits <code>0x11111111</code> and shift them left by 8 bits (i.e., right by 24 bits) to get the required constant. However, the scaling factor <code>n</code> needs twice the number of rotation rights to achieve this. That is (32 – 8)/2, which is 12. Consequently, the literal stored in the 12-bit instruction field is 12,255, or CFF in hexadecimal.</p>&#13;
			<p lang="en-GB">Fortunately, calculating the scaling factor is something the programmer does not always have to worry about. ARM compilers take a constant and automatically generate the best instruction(s) necessary to generate it.</p>&#13;
			<h1 id="_idParaDest-185" lang="en-GB"><a id="_idTextAnchor201"/>Register indirect addressing</h1>&#13;
			<p lang="en-GB">We have already encountered this addressing mode where the location of an operand is held in a register. It is called register <em class="italic">indirect addressing</em> because the instruction specifies the register where a pointer to the actual operand can be found. In ARM literature, this addressing mode is called <em class="italic">indexed addressing</em>. Some people call this <em class="italic">base addressing</em>.</p>&#13;
			<p lang="en-GB">Register indirect addressing mode requires three read operations to access an operand:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Read the instruction to find the pointer register</li>&#13;
				<li lang="en-GB">Read the pointer register to find the operand address</li>&#13;
				<li lang="en-GB">Read memory at the operand address to find the operand</li>&#13;
			</ul>&#13;
			<p lang="en-GB">Register indirect addressing is important because the contents of the register containing the pointer to the actual operand can be modified at runtime, and therefore, the address is a variable. Consequently, we can step through data structures such as tables by changing the pointer.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_11.02_B19624.jpg" alt="Figure 11.2 – Register indirect addressing – executing ldr r1,[r0]" width="1229" height="546"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Register indirect addressing – executing ldr r1,[r0]</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 11</em><em class="italic">.2</em> illustrates the effect of <code>ldr</code> r1,<code>[r0]</code>, where <code>r0</code> is the pointer and contains the value <code>n</code>.</p>&#13;
			<p lang="en-GB"><code>ldr </code>r1<code>,[r0]</code> loads the contents of the memory location pointed at by register <code>r0</code> into register <code>r1</code>.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Executing <code>add </code>r0<code>,r0,#4</code> increments the contents of the pointer register <code>r0</code> by 4 to point at the next word location (remember that consecutive word addresses differ by 4).</p>&#13;
			<p lang="en-GB">Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
   ldr <strong class="bold">r1</strong>,[r0]                   @ Get data pointed at by r0&#13;
   add <strong class="bold">r0</strong>,r0,#4                  @ Advance pointer to next word location</pre>&#13;
			<p lang="en-GB">The first instruction loads <code>r1</code> with the 32-bit word pointed at by <code>r0</code>. The second instruction increments <code>r0</code> by 4 to point at the next byte in memory. Repeating this pair of instructions will allow you to step through a table of values, element by element. We will soon see that the ARM includes a mechanism to automatically increment or decrement the pointer.</p>&#13;
			<p lang="en-GB">The next fragment of code demonstrates how you would add together the elements of a table. Suppose that you have a table of daily expenditures you have made over four weeks. Each item is stored consecutively in a table with 4 x 7 = 28 entries:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      adr <strong class="bold">r0</strong>,table               @ r0 points to the table of data (pseudo-instruction)&#13;
      add <strong class="bold">r3</strong>,r0,#28 * 4          @ r3 points to the end of the table (28 x 4 bytes)&#13;
      mov <strong class="bold">r1</strong>,#0                  @ Clear the sum in r1&#13;
loop: <strong class="bold">ldr r2,[r0]</strong>                @ REPEAT: Get the next value in r2&#13;
      add r1,r1,r2               @ Add the new value to the running total&#13;
      add r0,r0,#4               @ Point to the next location in the table (4 bytes increment)&#13;
      cmp r0,r3                  @ Are we at the end of the table?&#13;
      bne loop                   @ UNTIL all elements added&#13;
table: .word 123                 @ Data for day 1&#13;
       .word 456                 @ Data for day 2&#13;
       .word 20                  @ Data for day 28</pre>&#13;
			<p lang="en-GB">In this simple example, we set up a loop and step through elements from the first to the last. On each cycle, we read an element and add it to the total. The shaded lines are where the action takes place – getting an element and pointing to the next one.</p>&#13;
			<p lang="en-GB">The next example demonstrates both pointer-based indirect addressing and byte operations (i.e., operations on an 8-bit value rather than a full word). Suppose we want to find a given character within a string. The following code uses a <em class="italic">byte load instruction</em>, <code>ldrb</code>, which loads 8 bits into the destination register. We increment the pointer by 1 as we step through the string, not 4, because the values are on one-byte boundaries:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      ldr       r0,=String        @ r0 points at the string (using a pseudo-instruction)&#13;
loop: <strong class="bold">ldrb</strong>      <strong class="bold">r1</strong>,[r0]          @ REPEAT Read a byte character&#13;
      add       <strong class="bold">r0</strong>,r0,#1          @ Update character pointer by 1 (not by 4)&#13;
      cmp       r1,#Term          @ UNTIL terminator found</pre>&#13;
			<pre class="source-code">      bne      loop</pre>&#13;
			<h2 id="_idParaDest-186" lang="en-GB"><a id="_idTextAnchor202"/>Pointer-based addressing with an offset</h2>&#13;
			<p lang="en-GB">Suppose someone asks you, <em class="italic">“Where’s the pharmacy?”</em> You might reply, <em class="italic">“It’s two blocks to the left of the bank.”</em> That’s pointer-based offset addressing in everyday life. We point to the bank by giving its location in relation to something else.</p>&#13;
			<p lang="en-GB">The ARM allows you to specify an address using a pointer register, plus a 12-bit literal that supplies the offset. Note that this is a true 12-bit literal rather than the 8-bit scaled value used as a literal operand. The literal can be positive or negative (indicating that it’s to be added to or subtracted from the base pointer). Consider <code>ldr </code>r5<code>,[r2,#160]</code>, where the address of the operand loaded into <code>r5</code> is the contents of <code>r1</code> plus 160.</p>&#13;
			<p lang="en-GB">Suppose you wanted to move a block of 24 words to a location that is 128 bytes further on in memory. Assume that the address of the block to move is at <code>0x400</code>. We can write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      mov  <strong class="bold">r0</strong>,#0x400         @ r0 points to the block of data&#13;
      ldr  <strong class="bold">r1</strong>,#24            @ r1 contains the number of words to move&#13;
next: ldr  <strong class="bold">r2</strong>,[r0]           @ REPEAT: Read word and put in r2&#13;
      add  <strong class="bold">r0</strong>,r0,#4          @ Point to next word&#13;
      str  r2,<strong class="bold">[r0,#128]</strong>      @ Store the word 128 bytes on&#13;
      subs <strong class="bold">r1</strong>,#1             @ Decrement the counter and set the status bits&#13;
      bne  next              @ UNTIL all elements added</pre>&#13;
			<p lang="en-GB">Unfortunately, you cannot run this directly on an ARM-based Raspberry Pi as we described because you are not allowed to modify memory in a code segment. That is an operating system limitation. To avoid this problem, you have to use pointers, as we demonstrated in <a href="B19624_09.xhtml#_idTextAnchor159"><em class="italic">Chapter 9</em></a>. We will return to this point.</p>&#13;
			<h2 id="_idParaDest-187" lang="en-GB"><a id="_idTextAnchor203"/>Two pointers are better than one</h2>&#13;
			<p lang="en-GB">The register-indirect addressing mode lets you access elements in a linear data structure, such as a one-column table. Sometimes, you will have a more complex two-dimensional data structure, such as a matrix with rows and columns. In that case, two pointers can simplify programming – one pointer for the row and one for the column.</p>&#13;
			<p lang="en-GB">ARM provides a pointer-based addressing mode that allows you to specify an address that is the sum of two pointer registers, such as the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
ldr <strong class="bold">r7</strong>,[r0,r1]               @ Load r7 with the contents of the location pointed at by r0 plus r1</pre>&#13;
			<p lang="en-GB">You can apply a shift to the second operand, such as the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
ldr <strong class="bold">r2</strong>,[r0,r1,lsl #3]        @ Load r7 with the contents of the location pointed at by r0 plus r1 x 8</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In this case, register <code>r1</code> is scaled by 8. The scaling factor must be a power of 2 (i.e., 2, 4, 8, 16…).</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 11</em><em class="italic">.3</em> illustrates pointer-based addressing with two index registers.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_11.03_B19624.jpg" alt="Figure 11.3 – Indexed addressing with a register offset – ldr r0,[r1,r2]" width="989" height="516"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Indexed addressing with a register offset – ldr r0,[r1,r2]</p>&#13;
			<p lang="en-GB">This is conceptual because we’ve shown one register pointing at memory (<code>r1</code>) and one register providing an offset from <code>r1</code> (i.e., <code>r2</code>). However, since the final address is <code>r1</code> plus <code>r2</code>, we could have drawn it the other way around.</p>&#13;
			<h2 id="_idParaDest-188" lang="en-GB"><a id="_idTextAnchor204"/>Automatic indexing of pointer registers</h2>&#13;
			<p lang="en-GB">When pointer registers are used, they are frequently used to step through data structures and are often incremented or decremented after every memory access. It would, therefore, make sense to include this action as part of the instruction.</p>&#13;
			<p lang="en-GB">Indeed, CISC processors invariably include automatic indexing. When RISC processors arrived with their <em class="italic">one instruction per clock cycle goal</em>, automatic indexing was dropped from the instruction set. However, this mechanism has been incorporated into ARM architecture.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">ARM’s automatic indexing has four variations. You can do it before using a pointer or after using a pointer. You can index up toward higher addresses or down toward lower addresses. Consider the following operations involving an index register, <code>r0</code>, and an increment of 4 (for one word on a byte-addressed machine). Each option is composed of a memory access and a pointer adjust action; in the first two cases, the pointer is adjusted first (pre-indexing), and in the other two cases, memory is accessed first (post-indexing). Memory accesses are given in bold:</p>&#13;
			<table id="table001-9" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Indexing type</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">First action</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Second action</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Pre-indexed up</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[r1] </code><code>←</code><code> [r1] + 4</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r0] ← [[r1]]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Pre-indexed down</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[r1] </code><code>←</code><code> [r1] - 4</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r0] ← [[r1]]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Post-indexed up</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r0] ← [[r1]]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[r1] </code><code>←</code><code> [r1] + 4</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Post-indexed down</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r0] ← [[r1]]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[r1] </code><code>←</code><code> [r1] – 4</code></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p lang="en-GB">ARM indicates pre-indexing by including the offset within square brackets and appending an exclamation mark, such as the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    str r4,<strong class="bold">[r0,#4]!</strong>   @ Store r4 at the address given by [r0] + 4 and then increment r0 by 4</pre>&#13;
			<p lang="en-GB">The value of the pointer <code>r0</code> changes <em class="italic">BEFORE</em> it is used as an offset. Let’s suppose we wish to use post-indexing and increment the pointer <em class="italic">AFTER</em> it is used. In this case, the format is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    str r4,<strong class="bold">[r0],#4</strong>    @ Store  r4 at the address given by [r0] and then increment r0 by 4.</pre>&#13;
			<p lang="en-GB">Here, the value of the pointer <code>r0</code> changes <em class="italic">AFTER</em> it is used as an offset.</p>&#13;
			<p lang="en-GB"><em class="italic">Figures 11.4</em> to<em class="italic"> 11.6</em> illustrate ARM’s variations on indexed addressing. In each case, the base register is <code>r1</code>, the offset is <code>12</code>, and the destination register is <code>r0</code>. These figures are summarized here:</p>&#13;
			<table id="table002-7" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Figure</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Type</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Format</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Base </strong><strong class="bold">reg before</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Base </strong><strong class="bold">reg after</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Operand address</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">11.4</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Reg indirect</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">ldr r0,[r1,#12]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] + 12</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">11.5</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Pre-indexed</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">ldr r0,[r1,#12]!</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] + 12</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] + 12</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">11.6</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Post-indexing</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">ldr r0,[r1],#12</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] + 12</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1]</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_11.04_B19624.jpg" alt="Figure 11.4 – Register indirect addressing with an offset" width="896" height="361"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 11.4 – Register indirect addressing with an offset</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_11.05_B19624.jpg" alt="Figure 11.5 – Register indirect addressing with pre-indexing" width="899" height="254"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Register indirect addressing with pre-indexing</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_11.06_B19624.jpg" alt="Figure 11.6 – Register indirect addressing with post-indexing" width="1069" height="381"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Register indirect addressing with post-indexing</p>&#13;
			<p lang="en-GB">Consider the following example where we use post-indexing to move a block of data from one memory region to another. In this case, we use post-indexing by four because we move 4-byte words:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
       adr  <strong class="bold">r0</strong>,table1       @ Source array pointer in r0. Use pseudo instruction&#13;
       adr  <strong class="bold">r1</strong>,table2       @ Destination array pointer in r1&#13;
       mov  <strong class="bold">r2</strong>,#8           @ Eight elements (words) to move&#13;
loop:  ldr  <strong class="bold">r3</strong>,[r0],#4      @ REPEAT: Get element from table 1 (post-indexing by 4)&#13;
       str  r3,<strong class="bold">[r1]</strong>,<strong class="bold">#4</strong>      @ Store in table 2 (post-indexing 4)&#13;
       subs <strong class="bold">r2</strong>,r2,#1        @ Decrement counter&#13;
       bne  loop            @ UNTIL all done</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The two key lines of this program are the load and store instructions (shaded), where data is read from the source and copied to the destination. As we have stated, you can’t run this code <em class="italic">directly</em> on Raspberry Pi without modification because of the way in which the memory space is allocated to variables. The following code demonstrates a runnable version for Raspberry Pi.</p>&#13;
			<p lang="en-GB">This is, essentially, the same code. As well as dealing with the memory problem, we’ve added assembly directives and dummy data (complete with markers that allow you to observe data in memory more easily). There’s also a <code>nop</code> instruction. Note that some versions of ARM have a true <code>nop</code> and some use a pseudo-instruction. I added this as a dummy instruction to <em class="italic">“land on”</em> while testing. Remember that the address of the actual data is stored in the program area, and then a pointer is loaded with that address:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_11.07_B19624.jpg" alt="Figure 11.7 – The use of pointers when accessing read/write memory" width="1576" height="1508"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 11.7 – The use of pointers when accessing read/write memory</p>&#13;
			<p lang="en-GB">We ran the preceding program using <code>gbd</code> as a debugging tool, as the following output demonstrates. In order to condense the text, we’ve removed unnecessary data from the display – for example, registers that are not accessed or modified.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_11.08_B19624.jpg" alt="Figure 11.8 – Using gdb to trace the program of Figure 11.7" width="1399" height="1415"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 11.8 – Using gdb to trace the program of Figure 11.7</p>&#13;
			<h2 id="_idParaDest-189" lang="en-GB"><a id="_idTextAnchor205"/>Example of string-copying</h2>&#13;
			<p lang="en-GB">The next example, <em class="italic">Figure 11</em><em class="italic">.9</em>, uses post-indexing to copy a string from one place to another in reverse order by moving one pointer down and the other up. The destination pointer is incremented by <code>len-1</code> to point to the end of the string, initially. The following code includes assembly language directives, enabling it to run on the RPi:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
         .equ    len,5            @ Length of string to reverse&#13;
         .text                    @ Program (code) area&#13;
         .global _start&#13;
_start:  mov    r0,#len           @ Number of characters to move&#13;
         adr    r1,adr_st1        @ r1 points at source address 1&#13;
         adr    r2,adr_st2        @ r2 points at source address 2&#13;
         ldr    r1,[r1]           @ Register r1 points to source&#13;
         ldr    r2,[r2]           @ Register r2 points to destination&#13;
         add    r2,r2,#len-1      @ r2 points to bottom of destination&#13;
Loop:    ldrb   r3,[r1],#1        @ Get char from source, increment pointer (note ldbr)&#13;
         strb   r3,[r2],#-1       @ Store char in destination, decrement pointer&#13;
         subs   r0,r0,#1          @ Decrement char count&#13;
         bne    Loop              @ REPEAT until all done&#13;
         nop                      @ Stop here&#13;
adr_st1: .word  str1&#13;
adr_st2: .word  str2&#13;
         .data&#13;
str1:    .ascii "Hello"           @ Source string&#13;
str2:    .byte  0,0,0,0,0         @ Destination string&#13;
         .end</pre>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_11.09_B19624.jpg" alt="Figure 11.9 – Reversing a string" width="1034" height="431"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Reversing a string</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The next section looks at a variation of pointer-based addressing where the pointer is the program counter itself. Consequently, all data and programs are referenced to the location of the current program.</p>&#13;
			<h1 id="_idParaDest-190" lang="en-GB"><a id="_idTextAnchor206"/>Program counter-relative addressing</h1>&#13;
			<p lang="en-GB">The ARM is an unusual processor in so many ways. You can use any register (i.e., <code>r0</code> to <code>r15</code>) as a pointer register. However, <code>r15</code> is the ARM’s program counter. If you use <code>r15</code> as a pointer register with an index, you are saying, <em class="italic">“The operand is at this distance from where I am.”</em> Here the <em class="italic">“where I am”</em> refers to the instruction itself. <em class="italic">Figure 11</em><em class="italic">.10</em> illustrates program counter-relative addressing.</p>&#13;
			<p lang="en-GB">Think about it. You give the address of data with respect to the program that’s using it and not an absolute address in memory. If you move the program in memory, the data is still the same distance from the instructions that access it, using program counter-relative addressing. The introduction of program counter relative addressing was one of the major advances in computer architecture. By the way, most branch instructions use program counter relative addressing because the destination of a branch is specified with respect to the current instruction.</p>&#13;
			<p lang="en-GB">The ARM uses program counter relative addressing to load 32-bit constants. Recall that you can load only 12-bit constants with the <code>ldr</code> instruction. However, the assembler can pre-load a 32-bit constant in memory and then use program counter relative addressing to access it. In other words, you dump a 32-value in memory near (or within) the program and then access it using program counter relative addressing. This is the reason for pseudo-instructions. Without pseudo-instructions, you’d have to calculate the relative address between the current <code>pc</code> and the desired operand. Pseudo-instructions do that and make the address invisible to the programmer.</p>&#13;
			<p lang="en-GB">Executing <code>ldr </code>r0<code>,[r15,#0x100]</code> loads a 32-bit operand that is <code>0x100</code> bytes (0x40 or 64 words) from the contents of register <code>r15</code>, the program counter. The operand loaded into <code>r0</code> is <code>0x108</code> bytes from the pc. Why <code>0x108</code> and not <code>0x100</code>, as specified in the instruction? The additional 8 bytes are there because the program counter is incremented by 8 bytes after each instruction and, therefore, runs 8 bytes ahead of the current address.</p>&#13;
			<p lang="en-GB">What about program counter relative store instructions? These cannot be used. Store operations using the program counter addressing mode are not supported in the ARM. This restriction is probably because (a) a lot of code is in read-only memory and can’t be changed, and (b) it would allow the modification of runtime programs.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_11.10_B19624.jpg" alt="Figure 11.10 – Program counter relative addressing" width="1355" height="542"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 11.10 – Program counter relative addressing</p>&#13;
			<h2 id="_idParaDest-191" lang="en-GB"><a id="_idTextAnchor207"/>Demonstration of program counter relative addressing</h2>&#13;
			<p lang="en-GB">Consider the following text where we use two types of pseudo-instruction, both of which are designed to load a 32-bit value into a register. One is <code>adr</code> (load an address) and the other <code>ldr</code> (load a 32-bit literal):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        .text&#13;
        .global   _start&#13;
_start: ldr r0,=pqr&#13;
        ldr r1,<strong class="bold">=abc</strong>                @ Note the special format of the pseudo ldr&#13;
        adr r2,pqr&#13;
        ldr r3,=0x11111111&#13;
        nop&#13;
        mov r0,#0&#13;
        mov r7,#1&#13;
        svc 0&#13;
<strong class="bold">abc:</strong>   .word 0x22222222&#13;
pqr:   .word 0x33333333&#13;
       .end</pre>&#13;
			<p lang="en-GB">There are three <code>ldr</code> instructions. Two load addresses into registers and the third, <code>ldr</code>, loads a 32-bit literal <code>0x11111111</code>. There is an <code>adr</code> instruction that loads a 32-bit address into register <code>r2</code>. What happens when these codes are executed?</p>&#13;
			<p lang="en-GB">First, let’s look at the source code when viewed in <code>gdb</code>:</p>&#13;
			<pre>0x10054 &lt;_start&gt;      ldr r0, [pc, #32]   ; 0x1007c &lt;pqr+4&gt;&#13;
0x10058 &lt;_start+4&gt;    ldr r1, [pc, #32]   ; 0x10080 &lt;pqr+8&gt;&#13;
0x1005c &lt;_start+8&gt;&#13;
0x10060 &lt;_start+12&gt;   ldr r3, [pc, #28]   ; 0x10084 &lt;pqr+12&gt;</pre>&#13;
			<p lang="en-GB">Note that these differ from the source code. That’s because the source code uses pseudo-instructions that are translated. For example, <code>ldr r0,=pqr</code> is translated into <code>ldr r0,[pc,#32]</code>. The source code cannot specify a 32-bit instruction. However, the translated version used a conventional load to specify the location of the actual operand 32 bits for the current value of the program counter.</p>&#13;
			<p lang="en-GB"><code>add r2,pc,#20</code> is treated differently. Here, the 32-bit literal is generated by adding 20 to the value of the current pc, because the address to be located is 20 bytes from the current PC value.</p>&#13;
			<p lang="en-GB">Let’s look at the registers when the code is executed up to <code>nop</code> using <code>gdb</code>. We will examine both the contents of the registers at the end of the program and then look at the memory locations. You can see the data stored in memory and the constants accessed by program counter relative addressing:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
r0             0x00010078&#13;
r1             0x00010074&#13;
r2             0x00010078&#13;
r3             0x11111111&#13;
(gdb) x/8xw 0x10074&#13;
0x10074 &lt;abc&gt;:          0x22222222    0x33333333    0x00010078      0x00010074&#13;
0x10084 &lt;pqr+12&gt;:       0x11111111    0x00001141    0x61656100      0x00010069</pre>&#13;
			<p lang="en-GB">In the next chapter, we will continue the theme of addressing, looking at how the ARM implements subroutines and how you can use the stack to keep track of subroutine return addresses.</p>&#13;
			<h1 id="_idParaDest-192" lang="en-GB"><a id="_idTextAnchor208"/>Summary</h1>&#13;
			<p lang="en-GB">Addressing modes comprise all the ways to express the location of an item in memory. Addressing modes are simultaneously the easiest and most difficult topic in assembly language programming. The concept is simple, but indirect addressing modes that use pointers may take some effort to visualize.</p>&#13;
			<p lang="en-GB">In this chapter, we learned about literal or immediate addressing where an operand is an actual value (it’s the thing itself and not the location). Literal values are used to specify constants – for example, in x + 5, the number 5 is a literal. This is the simplest of addressing modes, and no memory location is accessed because the data is part of the instruction.</p>&#13;
			<p lang="en-GB">We also looked at the ARM’s rather unusual way of specifying literals, by providing a value in the range of 0 to 255 and a multiplier that can multiply it by an even power of 2. You can specify 5 and store 5, 20, 80, and so on.</p>&#13;
			<p lang="en-GB">Much of this chapter was taken up by register indirect addressing, which has a lot of other names (indexed and pointer-based). In this case, the address is given by the contents of a register. The instruction specifies not the actual address of an operand but the register that points to it. Because you can manipulate data in a register, you can manipulate addresses and access data structures such as arrays and tables.</p>&#13;
			<p lang="en-GB">The ARM provides RISC-style auto-incrementing and decrementing. That means you can use a pointer and increment it or decrement it beforehand (or after it is used).</p>&#13;
			<p lang="en-GB">We also looked at a special form of register indirect addressing, relative addressing, where the pointer is the program counter itself – that is, the address of an operand is specified with respect to the instruction that accesses it. This means that code using program counter relative addressing can be moved around in memory without any addresses being recalculated.</p>&#13;
			<p lang="en-GB">In the next chapter, we will look at a topic that is fundamental to programming – the subroutine and the stack. This topic is also heavily related to addressing modes.</p>&#13;
		</div>&#13;
	</div></body></html>