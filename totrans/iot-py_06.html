<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 6. Working with Analog Inputs and Local Storage"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Working with Analog Inputs and Local Storage</h1></div></div></div><p>In this chapter, we will work with analog inputs to transform quantitative values retrieved from the real environment into qualitative values that we will use to fire actions. We will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understand how analog inputs work</li><li class="listitem" style="list-style-type: disc">Learn about the impact of the resolution of analog to digital converters</li><li class="listitem" style="list-style-type: disc">Measure a voltage with an analog pin and the <code class="literal">mraa</code> library</li><li class="listitem" style="list-style-type: disc">Include a photoresistor in a voltage divider and wire an analog input pin with a voltage source</li><li class="listitem" style="list-style-type: disc">Transform a variable resistor into a voltage source</li><li class="listitem" style="list-style-type: disc">Determine the darkness level with analog input and the <code class="literal">mraa</code> library</li><li class="listitem" style="list-style-type: disc">Fire actions when the environment light changes</li><li class="listitem" style="list-style-type: disc">Control analog inputs with the wiring-x86 library</li><li class="listitem" style="list-style-type: disc">Work with different local storage options to log events</li></ul></div><div class="section" title="Understanding the analog inputs"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Understanding the analog inputs</h1></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Understanding and Setting up the Base IoT Hardware">Chapter 1</a>, <span class="emphasis"><em>Understanding and Setting up the Base IoT Hardware</em></span>, we learned that the Intel Galileo Gen 2 <a id="id276" class="indexterm"/>board provides six analog input pins numbered from <span class="strong"><strong>A0</strong></span> to <span class="strong"><strong>A5</strong></span> and located in the lower-right corner of the front-side of the board. It is possible to measure from 0V (ground) to the value configured with the <span class="strong"><strong>IOREF</strong></span> jumper position (5V by default) and the board provides 12 bits of resolution for the analog to digital converter. Thus, we can detect 4096 different values (212 = 4096), or 4096 units, with values ranging from zero to 4095 (inclusive), where 0 represents 0V and 4095 means 5V.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip41"/>Tip</h3><p>In case you have an experience with other Arduino boards, you must take into account that the Intel Galileo Gen 2 board does not use the pin labeled <span class="strong"><strong>AREF</strong></span>. In other Arduino boards, you can use this pin to set the analog reference voltage for the analog to digital conversion process. When we work with the Intel Galileo Gen 2 board, the maximum value for the analog pins is always going to be controlled by the <span class="strong"><strong>IOREF</strong></span> jumper position (5V or 3.3V) and it is not possible to use any external reference for an analog input. In all our examples, we will work with the default position for the <span class="strong"><strong>IOREF</strong></span> jumper, and therefore, the maximum value will be always 5V.</p></div></div><p>We just need<a id="id277" class="indexterm"/> to apply a linear function to convert the raw values read from the analog pin and map them to the input voltage values. If we use 12 bits of resolution, the detected values will have a minimum difference or step of 5V / 4095 = 0.001220012 V, approximately 1.22 mV (milliVolts) or 1.22E-03 V. We just need to multiply the raw value read from the analog pin by five and divide it by 4095.</p><p>The following graph shows the read values from an analog pin in the abscissa axis (<span class="emphasis"><em>x</em></span>-axis) and the corresponding floating-point voltage value that it represents in the ordinate axis (<span class="emphasis"><em>y</em></span>-axis).</p><div class="mediaobject"><img src="images/B05042_06_01.jpg" alt="Understanding the analog inputs"/></div><p>The equation for the previous graph is <code class="literal">y = x / 4095 * 5</code>, specifically <code class="literal">voltage_value = analog_pin_read_value / 4095 * 5</code>. We can run the following code in our Python interpreter to see the output with all the voltage values that can be generated with the formula for each raw value read from the analog pin from <code class="literal">0</code> to <code class="literal">4095</code> (inclusive).</p><div class="informalexample"><pre class="programlisting">for analog_pin_read_value in range(0, 4096):
    print(analog_pin_read_value / 4095.0 * 5.0)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip42"/>Tip</h3><p>We can also work with a lower resolution, such as 10 bits of resolution and we would be able to detect less different values, specifically 1024 different values (2<sup>10</sup> = 1024), or 1024 units, from 0 to 1023 (inclusive). In this case, the values will have a minimum difference or step of 5V / 1023 = 0.004887585V, approximately 4.89mV (milliVolts) or 4.89E-03 V. In case we decide to work with this lower resolution, we just need to multiply the raw value read from the analog pin by five and divide it by 1023.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Wiring an analog input pin with a voltage source"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Wiring an analog input pin with a voltage source</h1></div></div></div><p>The <a id="id278" class="indexterm"/>easiest way to understand how to read the values from analog pins and map these values back to voltage values is to work with a very simple example. We will connect a power source to one of the analog input pins, specifically a pack with two AA or AAA 1.25 V rechargeable batteries in series. It is also possible to use AA or AAA 1.5 V standard batteries in series. Note that the maximum voltage with the two rechargeable batteries in series will be 2.5 V (1.25 V * 2), while the maximum voltage with the two standard batteries in series will be 3 V (1.5 V * 2).</p><p>We will use the analog pin labeled <span class="strong"><strong>A0</strong></span> to connect to the positive side (+) of the battery pack. Don't forget that the positive side (+) of the batter pack is connected to the battery's nipple. After we finish the necessary wirings, we will write Python code to measure the batteries pack voltage. This way, we will read the result of converting an analog value to its digital representation and we will map it to the voltage value. We need the following parts to work with this example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Two AA or AAA 1.25 V rechargeable batteries or two AA or AAA 1.5 V standard batteries.</li><li class="listitem" style="list-style-type: disc">An appropriate battery holder to plug the two selected batteries in series and simplify wirings. For example, in case you use two AA 1.25 rechargeable batteries, you will need a 2 x AA battery holder.</li><li class="listitem" style="list-style-type: disc">A 2200Ω (2k2Ω) resistor with 5% tolerance (red red red gold).</li></ul></div><p>The<a id="id279" class="indexterm"/> following image shows the battery holder, the resistor connected to the breadboard, the necessary wirings, and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_06_01.fzz</code> and the following image is the breadboard view:</p><div class="mediaobject"><img src="images/B05042_06_02.jpg" alt="Wiring an analog input pin with a voltage source"/></div><p>The following <a id="id280" class="indexterm"/>schematic shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_06_03.jpg" alt="Wiring an analog input pin with a voltage source"/></div><p>As seen<a id="id281" class="indexterm"/> in the previous schematic, the analog input pin labeled <span class="strong"><strong>A0</strong></span> in the board's symbol, is connected to the positive terminal of the power source through the resistor. The negative terminal of the power source is connected to the ground.</p><p>Now, it's time to make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Measuring voltage with analog inputs and the mraa library"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Measuring voltage with analog inputs and the mraa library</h1></div></div></div><p>We<a id="id282" class="indexterm"/> will create a new <code class="literal">VoltageInput</code> class to represent a voltage source connected to our board, specifically, to an analog input pin. The following lines show the code for the new <code class="literal">VoltageInput</code> class that works with the <code class="literal">mraa</code> library. The code file for the sample is <code class="literal">iot_python_chapter_06_01.py</code>.</p><div class="informalexample"><pre class="programlisting">import mraa
import time


class VoltageInput:
    def __init__(self, analog_pin):
        self.analog_pin = analog_pin
        self.aio = mraa.Aio(analog_pin)
        # Configure ADC resolution to 12 bits (0 to 4095)
        self.aio.setBit(12)

    @property
    def voltage(self):
        raw_value = self.aio.read()
        return raw_value / 4095.0 * 5.0</pre></div><p>We have to specify the analog pin number to which the voltage source is connected when we create an instance of the <code class="literal">VoltageInput</code> class in the <code class="literal">analog_pin</code> required argument. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">mraa.Aio</code> instance with the received <code class="literal">analog_pin</code> as its <code class="literal">pin</code> argument, saves its reference in the <code class="literal">aio</code> attribute and calls its <code class="literal">setBit</code> method to configure the analog to digital converter resolution to be of 12 bits, that is, to provide 4096 possible values to represent from 0 to 5V.</p><p>The class defines a <code class="literal">voltage</code> property that calls the <code class="literal">read</code> method for the related <code class="literal">mraa.Aio</code> instance (<code class="literal">self.aio</code>) to retrieve the raw value from the analog pin and saves it in the <code class="literal">raw_value</code> variable. Then, the code returns the result of dividing <code class="literal">raw_value</code> by <code class="literal">4095</code> and multiplying it by <code class="literal">5</code>. This way, the property returns the voltage value, converted from the raw value returned by the read function.</p><p>Now, we can write code that uses the new <code class="literal">VoltageInput</code> class to create an instance for the battery pack and easily retrieve the voltage value. The new class makes the necessary calculations to map the read value into a voltage value, and therefore, we just need to check the value of the <code class="literal">voltage</code> property without worrying about the specific details about the analog to digital converter and its resolution.</p><p>Now, we <a id="id283" class="indexterm"/>will write a loop that will retrieve the voltage value every second. The code file for the sample is <code class="literal">iot_python_chapter_06_01.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    v0 = VoltageInput(0)
    while True:
        print("Voltage at pin A0: {0}".format(v0.voltage))
        # Sleep 1 second
        time.sleep(2)</pre></div><p>The first line creates an instance of the previously coded <code class="literal">VoltageInput</code> class with <code class="literal">0</code> as the value of the <code class="literal">analog_pin</code> argument. This way, the instance will read the analog values from the pin labeled <span class="strong"><strong>A0</strong></span>, that is connected to the positive terminal of the power source through the resistor.</p><p>Then, the code runs a loop forever, that is, until you interrupt the execution by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> or the button to stop the process in case you are using a Python IDE with remote development features to run the code in your board. The loop prints the voltage value at pin <span class="strong"><strong>A0</strong></span> every two seconds. The following lines show a sample output line generated when the code is executed with two rechargeable batteries that have lost a bit of their charge:</p><div class="informalexample"><pre class="programlisting">Voltage at pin A0: 2.47130647131</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Wiring a photoresistor to an analog input pin"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Wiring a photoresistor to an analog input pin</h1></div></div></div><p>Now, we <a id="id284" class="indexterm"/>will use a photoresistor, that is, a light sensor, specifically, an electronic component that provides a variable resistor that changes the resistor value based on the incident light intensity. As the incident light intensity increases, the resistance of the photoresistor decreases, and vice versa.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip43"/>Tip</h3><p>A photoresistor is also known as an<a id="id285" class="indexterm"/> <span class="strong"><strong>LDR</strong></span> (short for <span class="strong"><strong>Light-Dependent Resistor</strong></span>) or photocell. Bear in mind that pohotoresistors are not the best components to sense light with great accuracy. However, they are extremely useful to easily determine whether we are in a dark environment when we don't have problems with latencies that can reach one second.</p></div></div><p>We cannot measure a resistance value with our board. However, we can read voltage values, and therefore, we will use a voltage divider configuration that will include the photoresistor as one of its two resistors. The voltage divider will output a high voltage value when the photoresistor receives a high amount of light and it will output a low voltage value when the photoresistor is in a dark zone, that is, when it receives little or no light at all.</p><p>We learned <a id="id286" class="indexterm"/>how to read values from analog pins and map these values back to voltage values in the previous examples. We will use this knowledge to determine when it becomes dark using the photoresistor. Once we understand how the sensor works, we will react to the changes in the light conditions and we will log data about specific scenarios.</p><p>We will use the analog pin labeled <span class="strong"><strong>A0</strong></span> to connect the positive side (+) of the voltage divider that includes a photoresistor. After we finish the necessary wirings, we will write Python code to determine whether we are in a dark environment or not. This way, we will read the result of converting a resistance value into a voltage, and then converting this analog value into its digital representation. As we learned in our previous example, we will map the read digital value to a voltage value and then we will map this voltage value to a darkness measurement value. It sounds like a big mess, but it is really easier than it sounds. We need the following parts to work with this example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A photoresistor</li><li class="listitem" style="list-style-type: disc">A 10,000Ω (10kΩ) resistor with 5% tolerance (brown black orange gold)</li></ul></div><p>The following diagram shows the photoresistor and the resistor connected to the breadboard, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_06_02.fzz</code> and the following picture is the breadboard view:</p><div class="mediaobject"><img src="images/B05042_06_04.jpg" alt="Wiring a photoresistor to an analog input pin"/></div><p>The following <a id="id287" class="indexterm"/>picture shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_06_05.jpg" alt="Wiring a photoresistor to an analog input pin"/></div><p>As seen in the <a id="id288" class="indexterm"/>previous schematic, the GPIO pin labeled <span class="strong"><strong>A0</strong></span> in the board's symbol is connected to the voltage divider built with the photoresistor named <span class="strong"><strong>LDR1</strong></span> and a 10kΩ resistor with 5% tolerance named <span class="strong"><strong>R1</strong></span>. The <span class="strong"><strong>LDR1</strong></span> photoresistor is wired to the <span class="strong"><strong>IOREF</strong></span> pin. We already know that the pin labeled <span class="strong"><strong>IOREF</strong></span> provides us the IOREF voltage, that is, 5V in our actual configuration. The <span class="strong"><strong>R1</strong></span> resistor is wired to <span class="strong"><strong>GND</strong></span> (ground).</p><p>Now, it is time make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Determining the darkness level with analog inputs and the mraa library"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Determining the darkness level with analog inputs and the mraa library</h1></div></div></div><p>We will <a id="id289" class="indexterm"/>create a new <code class="literal">DarknessSensor</code> class to represent the photoresistor included in the voltage divider and connected to our board, specifically, to an analog input pin. As we already wrote code to read and transform an analog input, we will use the previously created <code class="literal">VoltageInput</code> class. The following lines show the code for the new <code class="literal">DarknessSensor</code> class that works with the <code class="literal">mraa</code> library. The code file for the sample is <code class="literal">iot_python_chapter_06_02.py</code>.</p><div class="informalexample"><pre class="programlisting">import mraa
import time

class DarknessSensor:
    # Light level descriptions
    light_extremely_dark = "extremely dark"
    light_very_dark = "very dark"
    light_dark = "just dark"
    light_no_need_for_a_flashlight = \
        "there is no need for a flashlight"
    # Maximum voltages that determine the light level
    extremely_dark_max_voltage = 2.0
    very_dark_max_voltage = 3.0
    dark_max_voltage = 4.0

    def __init__(self, analog_pin):
        self.voltage_input = VoltageInput(analog_pin)
        self.voltage = 0.0
        self.ambient_light = self.__class__.light_extremely_dark
        self.measure_light()

    def measure_light(self):
        self.voltage = self.voltage_input.voltage
        if self.voltage &lt; self.__class__.extremely_dark_max_voltage:
            self.ambient_light = self.__class__.light_extremely_dark
        elif self.voltage &lt; self.__class__.very_dark_max_voltage:
            self.ambient_light = self.__class__.light_very_dark
        elif self.voltage &lt; self.__class__.dark_max_voltage:
            self.ambient_light = self.__class__.light_dark
        else:
            self.ambient_light = self.__class__.light_no_need_for_a_flashlight</pre></div><p>We have to specify the analog pin number to which the voltage divider, which includes the photoresistor, is connected when we create an instance of the <code class="literal">DarknessSensor</code> class in the <code class="literal">analog_pin</code> required argument. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">VoltageInput</code> instance with the received <code class="literal">analog_pin</code> as its <code class="literal">analog_pin</code> argument and saves its reference in the <code class="literal">voltage_input</code> attribute. Then, the constructor creates and initializes two attributes: <code class="literal">voltage</code> and <code class="literal">ambient_light</code>. Finally, the constructor calls the <code class="literal">measure_light</code> method.</p><p>The class<a id="id290" class="indexterm"/> defines a <code class="literal">measure_light</code> method that saves the voltage value retrieved by checking the <code class="literal">self.voltage_input.voltage</code> property in the <code class="literal">voltage</code> attribute (<code class="literal">self.voltage</code>). This way, the code can check whether the value stored in the voltage attribute is lower than the three maximum voltage values that determine the light level and sets the appropriate value for the <code class="literal">ambient_light</code> attribute (<code class="literal">self.ambient_light</code>).</p><p>The class defines the following three class attributes that determine the maximum voltage values that determine each light level:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">extremely_dark_max_voltage</code>: If<a id="id291" class="indexterm"/> the retrieved voltage is lower than 2V, it means that the environment is extremely dark</li><li class="listitem" style="list-style-type: disc"><code class="literal">very_dark_max_voltage</code>: If the <a id="id292" class="indexterm"/>retrieved voltage is lower than 3V, it means that the environment is very dark</li><li class="listitem" style="list-style-type: disc"><code class="literal">dark_max_voltage</code>. If the <a id="id293" class="indexterm"/>retrieved voltage is lower than 4V, it means that the environment is just dark</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip44"/>Tip</h3><p>The values are configured for a specific photoresistor and environment conditions. You might need to set different values based on the voltage values retrieved with the photoresistor included in the voltage divider. Once you run the sample, you can check the voltage values and make the necessary adjustments to the voltage values stored in the previously explained class attributes. Remember that the voltage value will be higher, that is, closer to 5V, when the incident light increases. Thus, the darkest environment, the lower the measured voltage.</p></div></div><p>Our goal is to convert a quantitative value, specifically, a voltage value, into a qualitative value, that is, a value that explains the real situation in a real environment. The class defines the following four class attributes that specify the light level descriptions and determine one of the four light levels in which a voltage value will be converted after we call the <code class="literal">measure_light</code> method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">light_extremely_dark</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">light_very_dark</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">light_dark</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">light_no_need_for_a_flashlight</code></li></ul></div><p>Now, we can <a id="id294" class="indexterm"/>write the code that uses the new <code class="literal">DarkSensor</code> class to create an instance for the photoresistor included in the voltage divider and easily print a description of the light conditions. The new class uses the previously created <code class="literal">VoltageInput</code> class to make the necessary calculations to map the read value into a voltage value, and then, transforms it into a qualitative value that provides us with a description of the light conditions. Now, we will write a loop that will check whether the light conditions changed every two seconds. The code file for the sample is <code class="literal">iot_python_chapter_06_02.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    darkness_sensor = DarknessSensor(0)
    last_ambient_light = ""
    while True:
        darkness_sensor.measure_light()
        new_ambient_light = darkness_sensor.ambient_light
        if new_ambient_light != last_ambient_light:
            # The ambient light value changed
            last_ambient_light = new_ambient_light
            print("Darkness level: {0}".format(new_ambient_light))
        # Sleep 2 seconds
        time.sleep(2)</pre></div><p>The first line creates an instance of the previously coded <code class="literal">DarknessSensor</code> class with <code class="literal">0</code> as the value of the <code class="literal">analog_pin</code> argument and saves the instance in the <code class="literal">darkness_sensor</code> local variable. This way, the instance will use an instance of the <code class="literal">VoltageInput</code> class to read the analog values from the pin labeled <span class="strong"><strong>A0</strong></span>. Then, the code initializes the <code class="literal">last_ambient_light</code> local variable with an empty string.</p><p>Then, the code runs a loop forever, that is, until you interrupt the execution by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> or the button to stop the process in case you are using a Python IDE with remote development features to run the code in your board. The loop calls the <code class="literal">darkness_sensor.measure_light</code> method to retrieve the current light conditions and saves the updated <code class="literal">darkness_sensor.ambient_light</code> value in the <code class="literal">new_ambient_light</code> local variable. Then, the code checks whether the <code class="literal">new_ambient_light</code> value is different from <code class="literal">last_ambient_light</code>. In case they are different, it means that the ambient light has changed, and therefore, it sets the value for <code class="literal">last_ambient_light</code> equal to <code class="literal">new_ambient_light</code>, and prints the ambient light description stored in <code class="literal">new_ambient_light</code>.</p><p>The loop <a id="id295" class="indexterm"/>prints the ambient light description only when it changes from the last printed value, and checks the ambient light every two seconds. The following line will start the example. Don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_06_02.py</pre></div><p>After you run the example, perform the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use a smartphone or a flashlight to induce light over the photoresistor</li><li class="listitem" style="list-style-type: disc">Use your hand to generate a shadow over the photoresistor</li><li class="listitem" style="list-style-type: disc">Reduce the light in the environment, but not the minimum, just make it a bit dark</li><li class="listitem" style="list-style-type: disc">Reduce the light in the environment to the minimum, a complete dark environment with no light at all</li></ul></div><p>As a result of the previous actions, you should see the following output:</p><div class="informalexample"><pre class="programlisting">Darkness level: there is no need for a flashlight
Darkness level: just dark
Darkness level: very dark
Darkness level: extremely dark</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Firing actions when the environment light changes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Firing actions when the environment light changes</h1></div></div></div><p>In previous <a id="id296" class="indexterm"/>examples, we worked with PWM to set the brightness level for the red, green, and blue components of an RGB LED. Now, we will add an RGB LED and we will set the brightness level for its three components based on the ambient light detected with the photoresistor. We will wire the RGB LED as we did in the example in which we worked with this component in <a class="link" href="ch04.html" title="Chapter 4. Working with a RESTful API and Pulse Width Modulation">Chapter 4</a>, <span class="emphasis"><em>Working with a RESTful API and Pulse Width Modulation</em></span>. We will use the following PWM output pins:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pin <span class="strong"><strong>~6</strong></span> to connect the anode pin for red LED</li><li class="listitem" style="list-style-type: disc">Pin <span class="strong"><strong>~5 </strong></span>to connect the anode pin for green LED</li><li class="listitem" style="list-style-type: disc">Pin <span class="strong"><strong>~3</strong></span> to connect the anode pin for blue LED.</li></ul></div><p>We need the following additional parts to work with this example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One common cathode 5mm RGB LED</li><li class="listitem" style="list-style-type: disc">Three 270Ω resistors with 5% tolerance (red violet brown gold)</li></ul></div><p>The <a id="id297" class="indexterm"/>following diagram shows the components connected to the breadboard, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_06_03.fzz</code> and the following picture is the breadboard view:</p><div class="mediaobject"><img src="images/B05042_06_06.jpg" alt="Firing actions when the environment light changes"/></div><p>The following <a id="id298" class="indexterm"/>picture shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_06_07.jpg" alt="Firing actions when the environment light changes"/></div><p>As seen in the previous schematic, three PWM capable GPIO pins labeled <span class="strong"><strong>D3 PWM</strong></span>, <span class="strong"><strong>D5 PWM</strong></span>, and <span class="strong"><strong>D6 PWM</strong></span> in the board's symbol is connected to a 270Ω resistor, wired to an anode pin for each LED color, and the common cathode is connected to ground. </p><p>Now, it is<a id="id299" class="indexterm"/> time to insert the components in the breadboard and make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins.</p><p>We will add the code for the <code class="literal">AnalogLed</code> class that represent an LED connected to our board that can have a brightness level from 0 to 255 inclusive. We created this class in <a class="link" href="ch04.html" title="Chapter 4. Working with a RESTful API and Pulse Width Modulation">Chapter 4</a>, W<span class="emphasis"><em>orking with a RESTful API and Pulse Width Modulation</em></span> and the code file for the sample was <code class="literal">iot_python_chapter_04_02.py</code>.</p><p>We will create a new <code class="literal">BoardInteraction</code> class to create an instance of our <code class="literal">DarknessSensor</code> class and one instance for each component of the RGB LED and easily control their brightness levels. The following lines show the code for the <code class="literal">BoardInteraction</code> class. The<a id="id300" class="indexterm"/> code file for the sample is <code class="literal">iot_python_chapter_06_03.py</code>:</p><div class="informalexample"><pre class="programlisting">class BoardInteraction:
    # The photoresistor included in the voltage divider
    # is connected to analog PIN A0
    darkness_sensor = DarknessSensor(0)
    # The Red LED is connected to GPIO pin ~6
    red_led = AnalogLed(6, 'Red')
    # The Green LED is connected to GPIO Pin ~5
    green_led = AnalogLed(5, 'Green')
    # The Blue LED is connected to GPIO Pin ~3
    blue_led = AnalogLed(3, 'Blue')

    @classmethod
    def set_rgb_led_brightness(cls, brightness_level):
        cls.red_led.set_brightness(brightness_level)
        cls.green_led.set_brightness(brightness_level)
        cls.blue_led.set_brightness(brightness_level)

    @classmethod
    def update_leds_brightness(cls):
        if cls.darkness_sensor.ambient_light == DarknessSensor.light_extremely_dark:
            cls.set_rgb_led_brightness(255)
        elif cls.darkness_sensor.ambient_light == DarknessSensor.light_very_dark:
            cls.set_rgb_led_brightness(128)
        elif cls.darkness_sensor.ambient_light == DarknessSensor.light_dark:
            cls.set_rgb_led_brightness(64)
        else:
            cls.set_rgb_led_brightness(0)</pre></div><p>The <code class="literal">BoardInteraction</code> class declares four class attributes: <code class="literal">darkness_sensor</code>, <code class="literal">red_led</code>, <code class="literal">green_led</code> and <code class="literal">blue_led</code>. The first class attribute saves a new instance of the <code class="literal">DarknessSensor</code> class and the last three class attributes save new instances of the previously imported <code class="literal">AnalogLed</code> class and represent the red, green, and blue LEDs connected to pins <span class="strong"><strong>~6</strong></span>, <span class="strong"><strong>~5</strong></span>, and <span class="strong"><strong>~3</strong></span>. Then, the <code class="literal">BoardInteraction</code> class declares the following two class methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">set_rgb_led_brightness</code>: Sets <a id="id301" class="indexterm"/>the same brightness level received in the <code class="literal">brightness_level</code> argument to the three components of the RGB LED.</li><li class="listitem" style="list-style-type: disc"><code class="literal">update_leds_brightness</code>: Sets <a id="id302" class="indexterm"/>the brightness level for the three components of the RGB LED based on the <code class="literal">ambient_light</code> value of the DarknessSensor instance (<code class="literal">cls.darkness_sensor</code>). If it is extremely dark, the brightness level will be 255. If it is very dark, the brightness level will be 128. If it is dark, the brightness level will be 64. Otherwise, the RGB LED will be completely turned off.</li></ul></div><p>Now, we<a id="id303" class="indexterm"/> can write a code that uses the new <code class="literal">BoardInteraction</code> class to measure the ambient light and set the brightness for the RGB LED based on the retrieved value. As in our previous example, we will only make changes when the ambient light value changes from the current value. We will write a loop that will check whether the light conditions changed every two seconds. The code file for the sample is <code class="literal">iot_python_chapter_06_03.py</code>.</p><div class="informalexample"><pre class="programlisting">    last_ambient_light = ""
    while True:
        BoardInteraction.darkness_sensor.measure_light()
        new_ambient_light = BoardInteraction.darkness_sensor.ambient_light
        if new_ambient_light != last_ambient_light:
            # The ambient light value changed
            last_ambient_light = new_ambient_light
            print("Darkness level: {0}".format(new_ambient_light))
            BoardInteraction.update_leds_brightness()
        # Sleep 2 seconds
        time.sleep(2)</pre></div><p>The first line initializes the <code class="literal">last_ambient_light</code> local variable with an empty string. Then, the code runs a loop forever, that is, until you interrupt the execution. The loop calls the <code class="literal">BoardInteraction.darkness_sensor.measure_light</code> method to retrieve the current light conditions and saves the updated <code class="literal">BoardInteraction.darkness_sensor.ambient_light</code> value in the <code class="literal">new_ambient_light</code> local variable. Then, the code checks whether the <code class="literal">new_ambient_light</code> value is different from <code class="literal">last_ambient_light</code>. In case they are different, it means that the ambient light has changed, and therefore, it sets the value for <code class="literal">last_ambient_light</code> equal to <code class="literal">new_ambient_light</code>, prints the ambient light description stored in <code class="literal">new_ambient_light</code> and calls the <code class="literal">BoardInteraction.update_leds_brightness</code> method to set the brightness for the RGB LED based on the ambient light.</p><p>The following line will start the example. Don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_06_03.py</pre></div><p>After you <a id="id304" class="indexterm"/>run the example, perform the following actions, and you will see the RGB LED changing its brightness level as explained:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use a smartphone or a flashlight to induce light over the photoresistor. The RGB LED will stay turned off.</li><li class="listitem" style="list-style-type: disc">Use your hand to generate a shadow over the photoresistor. The RGB LED will turn on with a dimmed light.</li><li class="listitem" style="list-style-type: disc">Reduce the light in the environment, but not the minimum, just make it a bit dark. The RGB LED will increase its brightness.</li><li class="listitem" style="list-style-type: disc">Reduce the light in the environment to the minimum, a complete dark environment with no light at all. The RBG LED will increase its brightness to the maximum level.</li><li class="listitem" style="list-style-type: disc">Use a smartphone or a flashlight to induce light over the photoresistor, again. The RGB LED will turn off.</li></ul></div><p>As a result of the previous actions, you should see the following output:</p><div class="informalexample"><pre class="programlisting">Darkness level: there is no need for a flashlight
Red LED connected to PWM Pin #6 set to brightness 0.
Green LED connected to PWM Pin #5 set to brightness 0.
Blue LED connected to PWM Pin #3 set to brightness 0.
Darkness level: just dark
Red LED connected to PWM Pin #6 set to brightness 64.
Green LED connected to PWM Pin #5 set to brightness 64.
Blue LED connected to PWM Pin #3 set to brightness 64.
Darkness level: very dark
Red LED connected to PWM Pin #6 set to brightness 128.
Green LED connected to PWM Pin #5 set to brightness 128.
Blue LED connected to PWM Pin #3 set to brightness 128.
Darkness level: extremely dark
Red LED connected to PWM Pin #6 set to brightness 255.
Green LED connected to PWM Pin #5 set to brightness 255.
Blue LED connected to PWM Pin #3 set to brightness 255.
Darkness level: there is no need for a flashlight
Red LED connected to PWM Pin #6 set to brightness 0.
Green LED connected to PWM Pin #5 set to brightness 0.
Blue LED connected to PWM Pin #3 set to brightness 0.</pre></div><p>We wrote object-oriented Python code that is easy to read and understand. With the help of the <code class="literal">mraa</code> library, we <a id="id305" class="indexterm"/>could easily fire actions when the environment light changes. We could control the brightness for an RGB LED when the ambient light changed. We worked with an analog input to determine the ambient light level and we used PWM to generate an analog output and control the RGB LED brightness level.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Controlling analog inputs with the wiring-x86 library"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Controlling analog inputs with the wiring-x86 library</h1></div></div></div><p>So far, we<a id="id306" class="indexterm"/> have been using the <code class="literal">mraa</code> library to work with analog inputs and retrieve the ambient light level. However, we have also been working with the <code class="literal">wiring-x86</code> library in our previous examples. We can change just a few lines of our object-oriented code to replace the <code class="literal">mraa</code> library with the <code class="literal">wiring-x86</code> one to read analog values.</p><p>First, we have to replace the code for the <code class="literal">AnalogLed</code> class with the version that works with the <code class="literal">wiring-x86</code> library. We created this version in <a class="link" href="ch04.html" title="Chapter 4. Working with a RESTful API and Pulse Width Modulation">Chapter 4</a>, <span class="emphasis"><em>Working with a RESTful API and Pulse Width Modulation</em></span>, and the code file for the sample was <code class="literal">iot_python_chapter_04_04.py</code>. When we grab the code for the <code class="literal">AnalogLed</code> class, we will also have the <code class="literal">Board</code> class.</p><p>The following lines shows the new version of the <code class="literal">VoltageInput</code> class that works with the <code class="literal">wiring-x86</code> library instead of using <code class="literal">mraa</code>. The code file for the sample is <code class="literal">iot_python_chapter_06_04.py</code>.</p><div class="informalexample"><pre class="programlisting">from wiringx86 import GPIOGalileoGen2 as GPIO

class VoltageInput:
    initial_analog_pin_number = 14

    def __init__(self, analog_pin):
        self.analog_pin = analog_pin
        self.gpio = Board.gpio
        self.gpio.pinMode(
            analog_pin + self.__class__.initial_analog_pin_number,
            self.gpio.ANALOG_INPUT)

    @property
    def voltage(self):
        raw_value = self.gpio.analogRead(
            self.analog_pin + 
            self.__class__.initial_analog_pin_number)
        return raw_value / 1023.0 * 5.0</pre></div><p>We created a new version of the <code class="literal">VoltageInput</code> class that declares an <code class="literal">initial_analog_pin_number</code> class attribute set to <code class="literal">14</code>. The <code class="literal">wiring-x86</code> library uses Arduino compatible numbers to reference the analog input pins or ADC pins. Thus, analog input pin <code class="literal">0</code> is known as <code class="literal">14</code>, analog input pin <code class="literal">1</code> as <code class="literal">15</code>, and so on. As we don't want to make changes to the rest of our code, we use a class attribute to specify the number that we must sum to the received <code class="literal">analog_pin</code> value to convert it to a <code class="literal">wiring-x86</code> analog pin number.</p><p>The <a id="id307" class="indexterm"/>constructor, that is, the <code class="literal">__init__</code> method, saves a reference to the <code class="literal">Board.gpio</code> class attribute in <code class="literal">self.gpio</code> and calls its <code class="literal">pinMode</code> method with the received <code class="literal">analog_pin</code> and the value specified in <code class="literal">initial_analog_pin_number</code> class attribute as its <code class="literal">pin</code> argument, and <code class="literal">self.gpio.ANALOG_INPUT</code> as its <code class="literal">mode</code> argument. This way, we configure the pin to be an analog input pin converting the analog input pin number into a <code class="literal">wiring-x86</code> compatible analog input pin number. The <code class="literal">wiring-x86</code> library doesn't make a difference between GPIO and analog I/O pins, and we can manage all of them through the <code class="literal">Board.gpio</code> class attribute.</p><p>All the <code class="literal">VoltageInput</code> instances will save a reference to the same <code class="literal">Board.gpio</code> class attribute that created an instance of the <code class="literal">GPIO</code> class, specifically, the <code class="literal">wiringx86.GPIOGalileoGen2</code> class with its <code class="literal">debug</code> argument set to <code class="literal">False</code> to avoid unnecessary debug information for the low-level communications.</p><p>The class defines a <code class="literal">voltage</code> property that calls the <code class="literal">analogRead</code> method for the GPIO instance (<code class="literal">self.gpio</code>) to retrieve the raw value from the analog pin and saves it in the <code class="literal">raw_value</code> variable. The result of the <code class="literal">self.analog_pin</code> attribute plus the value specified in <code class="literal">initial_analog_pin_number</code> class attribute specifies the <code class="literal">pin</code> value for the <code class="literal">analogRead</code> method call. Then, the code returns the result of dividing <code class="literal">raw_value</code> by <code class="literal">1023</code> and multiplying it by <code class="literal">5</code>. This way, the property returns the voltage value, converted from the raw value returned by the <code class="literal">analogRead</code> function.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip45"/>Tip</h3><p>Unluckily, the <code class="literal">wiring-x86</code> library doesn't support 12 bit of resolution for the analog to digital converter. The library works with a fixed 10 bit of resolution, and therefore, we are only able to detect 1024 different values (2<sup>10</sup> = 1024), or 1024 units, with values ranging from 0 to 1023 (inclusive), where 0 represents 0V and 1023 means 5V. For this reason, we have to divide raw_value by <code class="literal">1023</code> instead of <code class="literal">4095</code> within the <code class="literal">voltage</code> property.</p></div></div><p>The rest of the code remains the same one that we have used for the previous example. There is no need to make changes to the <code class="literal">DarknessSensor</code> class, the <code class="literal">BoardInteraction</code> class or the main loop because they will automatically work with the new <code class="literal">VoltageInput</code> class and there were no changes in the arguments for its constructor or its <code class="literal">voltage</code> property.</p><p>The following <a id="id308" class="indexterm"/>line will start the new version of the example that works with the <code class="literal">wiring-x86</code> library:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_06_04.py</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip46"/>Tip</h3><p>We can make the same changes in the incident light over the photoresistor that we made in our previous example to check that we can achieve exactly the same results with the <code class="literal">wiring-x86</code> library. The only difference will be in the precision of the voltage values retrieved because we are working with 10 bits of resolution in the analog to digital converter in this case.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Logging to files in the local storage"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Logging to files in the local storage</h1></div></div></div><p>Python <a id="id309" class="indexterm"/>provides a powerful and flexible logging API provided by a standard library module. We can use the logging module to track events that happen when our IoT applications run on the board and save them on a log file by taking advantage of the local storage options.</p><p>Now, we will make changes to our last version of our previous example that worked with the <code class="literal">mraa</code> library to log the voltage values read from the ambient light sensor. We only want to log the new voltage value when the ambient light changes, that is, when the value for <code class="literal">BoardInteraction.darkness_sensor.ambient_light</code> mutates. We will use the previous code as a baseline to add the new logging features. The code file for the sample was <code class="literal">iot_python_chapter_06_03.py</code>.</p><p>We will replace the <code class="literal">__main__</code> method. The following lines show the new version that adds logging capabilities. The new lines of code are highlighted and the code file for the sample is <code class="literal">iot_python_chapter_06_05.py</code>.</p><div class="informalexample"><pre class="programlisting">import logging

if __name__ == "__main__":
<span class="strong"><strong>    logging.basicConfig(</strong></span>
<span class="strong"><strong>        filename="iot_python_chapter_06_05.log",</strong></span>
<span class="strong"><strong>        level=logging.INFO,</strong></span>
<span class="strong"><strong>        format="%(asctime)s %(message)s",</strong></span>
<span class="strong"><strong>        datefmt="%m/%d/%Y %I:%M:%S %p")</strong></span>
<span class="strong"><strong>    logging.info("Application started")</strong></span>
    last_ambient_light = ""
<span class="strong"><strong>    last_voltage = 0.0</strong></span>
    while True:
        BoardInteraction.darkness_sensor.measure_light()
        new_ambient_light = BoardInteraction.darkness_sensor.ambient_light
        if new_ambient_light != last_ambient_light:
            # The ambient light value changed
<span class="strong"><strong>            logging.info(</strong></span>
<span class="strong"><strong>                "Ambient light value changed from {0} to {1}".format(</strong></span>
<span class="strong"><strong>                    last_voltage, BoardInteraction.darkness_sensor.voltage))</strong></span>
            last_ambient_light = new_ambient_light
<span class="strong"><strong>            last_voltage = BoardInteraction.darkness_sensor.voltage</strong></span>
            print("Darkness level: {0}".format(new_ambient_light))
            BoardInteraction.update_leds_brightness()
        # Sleep 2 seconds
        time.sleep(2)</pre></div><p>The first <a id="id310" class="indexterm"/>line calls the <code class="literal">logging.basicConfig</code> method to do the basic configuration for the logging system. The <code class="literal">fileName</code> argument specifies <code class="literal">"iot_python_chapter_06_05.log"</code> as the file name we want to use for logging. As we don't specify a value for the <code class="literal">fileMode</code> argument, the default <code class="literal">'a'</code> mode is used and the messages from successive runs will be appended to the specified log file name, that is, the file will never be overwritten.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip47"/>Tip</h3><p>We didn't specify any path in the <code class="literal">fileName</code> argument, and therefore, the log file will be created in the same folder in which the Python script runs, that is, the <code class="literal">/home/root</code> folder. In this case, the log file will be using the storage space available in the microSD card that boots the Yocto Linux distribution.</p></div></div><p>The <code class="literal">format</code> argument specifies <code class="literal">"%(asctime)s %(message)s"</code> because we want to store the date and time followed by a message. The <code class="literal">datefmt</code> argument specifies <code class="literal">"%m/%d/%Y %I:%M:%S %p"</code> as the date and time format we want to use for the date and time that will be included as a prefix for all the lines appended to the log. We want a short date (month/date/year) followed by a short time (hours/minutes/seconds AM/PM). We just want to log the information logs to the file, and therefore, the <code class="literal">level</code> argument specifies <code class="literal">logging.INFO</code> to set the root logger level to this value.</p><p>The next line calls the <code class="literal">logging.info</code> method to log the first event: the application that has started its execution. Before entering into the loop, the code declared a new <code class="literal">last_voltage</code> local variable and initializes it to <code class="literal">0.0</code>. We want to log the previous voltage and the new voltage whenever the ambient light changes, and therefore, it is necessary to save the last voltage in a new variable. When the ambient light changes, a call to the <code class="literal">logging.info</code> method logs the transition from the previous voltage to the new voltage <a id="id311" class="indexterm"/>value. However, it is very important to notice that the first time this method is called, the previous voltage will be equal to <code class="literal">0.0</code>. The next line saves the value for the <code class="literal">BoardInteraction.darkness_sensor.voltage</code> in the <code class="literal">last_voltage</code> variable.</p><p>The following line will start the new version of the example that will create the <code class="literal">iot_python_chapter_06_05.log</code> file:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_06_05.py</pre></div><p>Keep the Python script running for a few minutes and make many changes in the incident light over the photoresistor. This way, you will generate many lines in the log file. Then, you can use your favorite SFTP client to download the log file from <code class="literal">/home/root</code> and read it.</p><p>The following lines show some sample lines generated in the log file after executing the application:</p><div class="informalexample"><pre class="programlisting">03/08/2016 04:54:46 PM Application started
03/08/2016 04:54:46 PM Ambient light value changed from 0.0 to 4.01953601954
03/08/2016 04:55:20 PM Ambient light value changed from 4.01953601954 to 3.91208791209
03/08/2016 04:55:26 PM Ambient light value changed from 3.91208791209 to 2.49572649573
03/08/2016 04:55:30 PM Ambient light value changed from 2.49572649573 to 3.40903540904
03/08/2016 04:55:34 PM Ambient light value changed from 3.40903540904 to 2.19291819292
03/08/2016 04:55:38 PM Ambient light value changed from 2.19291819292 to 3.83394383394
03/08/2016 04:55:42 PM Ambient light value changed from 3.83394383394 to 4.0
03/08/2016 04:55:48 PM Ambient light value changed from 4.0 to 3.40903540904
03/08/2016 04:55:50 PM Ambient light value changed from 3.40903540904 to 2.89133089133
03/08/2016 04:55:56 PM Ambient light value changed from 2.89133089133 to 3.88278388278
03/08/2016 04:55:58 PM Ambient light value changed from 3.88278388278 to 4.69841269841
03/08/2016 04:56:00 PM Ambient light value changed from 4.69841269841 to 3.93650793651</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Working with USB attached storage"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Working with USB attached storage</h1></div></div></div><p>Log files that <a id="id312" class="indexterm"/>record events related to sensors can grow really fast, and therefore, storing log files in the the microSD storage space might become a problem. We can work with microSD cards up to 32 GB. Thus, one option is to create the Yocto Linux image on a bigger microSD card and continue working with a single storage. This would require us to expand the partition from the default image. The other option is to take advantage of the cloud and just keep a constrained log in our local storage. However, we will work with this option later. Now, we want to explore the additional options we have to use local storage.</p><p>As we learned in <a class="link" href="ch01.html" title="Chapter 1. Understanding and Setting up the Base IoT Hardware">Chapter 1</a>, <span class="emphasis"><em>Understanding and Setting up the Base IoT Hardware</em></span>, The Intel Galileo Gen 2 board provides a USB 2.0 host connector, labeled <span class="strong"><strong>USB HOST</strong></span>. We can use this connector to plug a USB thumb drive for additional storage and save the log file in this new storage.</p><p>Before you plug any USB thumb drive, run the following command in the SSH terminal to list the partition tables:</p><div class="informalexample"><pre class="programlisting">fdisk -l</pre></div><p>The following lines show an example of the output generated by the previous command. Your output might be different because it depends on the microSD card that you are using to boot Yocto Linux. Notice that the <code class="literal">/dev/mmcblk0</code> disk identifies the microSD card and you have two partitions: <code class="literal">/dev/mmcblk0p1</code> and <code class="literal">/dev/mmcblk0p2</code>.</p><div class="informalexample"><pre class="programlisting">Disk /dev/mmcblk0: 7.2 GiB, 7746879488 bytes, 15130624 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x000a69e4

Device         Boot     Start       End  Blocks  Id System
/dev/mmcblk0p1 *         2048    106495   52224  83 Linux
/dev/mmcblk0p2         106496   2768895 1331200  83 Linux</pre></div><p>Now, we will plug a USB thumb drive to the board's USB 2.0 host connector, we will run the necessary commands to mount it, and then we will make change to the code to save the log in a folder within the USB thumb drive. You will need a preformatted USB thumb drive compatible with USB 2.0 to run this example.</p><p>The following picture<a id="id313" class="indexterm"/> shows a USB thumb drive plugged to the board's USB 2.0 host connector, labeled <span class="strong"><strong>USB HOST</strong></span>. Wait a few seconds after you plug the USB thumb drive.</p><div class="mediaobject"><img src="images/B05042_06_08.jpg" alt="Working with USB attached storage"/></div><p>Yocto Linux will add a new block device to the <code class="literal">/dev</code> folder. Run the following command in the SSH terminal to list the partition tables:</p><div class="informalexample"><pre class="programlisting">fdisk -l</pre></div><p>The following lines <a id="id314" class="indexterm"/>show an example of the output generated by the previous command. Your output might be different because it depends on the USB drive and also on the microSD card that you are using. Compare the output with the output generated when you executed the same command before you plugged the USB thumb drive. The additional lines provide information about the USB thumb drive, its disk name, and its partitions. The highlighted lines show the partition details for the USB thumb, identified as the <code class="literal">/dev/sda</code> disk and with a FAT32 partition <code class="literal">/dev/sda1</code>. We will use this partition name for one of our next steps.</p><div class="informalexample"><pre class="programlisting">Disk /dev/mmcblk0: 7.2 GiB, 7746879488 bytes, 15130624 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x000a69e4

Device         Boot     Start       End  Blocks  Id System
/dev/mmcblk0p1 *         2048    106495   52224  83 Linux
/dev/mmcblk0p2         106496   2768895 1331200  83 Linux


<span class="strong"><strong>Disk /dev/sda: 3.8 GiB, 4026531840 bytes, 7864320 sectors</strong></span>
<span class="strong"><strong>Units: sectors of 1 * 512 = 512 bytes</strong></span>
<span class="strong"><strong>Sector size (logical/physical): 512 bytes / 512 bytes</strong></span>
<span class="strong"><strong>I/O size (minimum/optimal): 512 bytes / 512 bytes</strong></span>
<span class="strong"><strong>Disklabel type: dos</strong></span>
<span class="strong"><strong>Disk identifier: 0x02bb0a1a</strong></span>

<span class="strong"><strong>Device    Boot Start       End  Blocks  Id System</strong></span>
<span class="strong"><strong>/dev/sda1 *       64   7864319 3932128   b W95 FAT32</strong></span>
</pre></div><p>Now, it is necessary to create a mount point. We have to create a new sub-folder in the <code class="literal">/media</code> folder. We will use <code class="literal">usb</code> as the name for the sub-folder, and therefore, the folder in which we will mount the drive will be <code class="literal">/media/usb</code>. Run the following command to create the folder:</p><div class="informalexample"><pre class="programlisting">mkdir /media/usb</pre></div><p>Run the following command to mount the partition in the recently created <code class="literal">/media/usb</code> folder. In the previous steps we retrieved the partition name and it was named <code class="literal">/dev/sda1</code>. Your partition name might be different, and therefore, you just need to replace <code class="literal">/dev/sda1</code> with your partition name listed when you executed the fdisk command that listed the disks and their partitions.</p><div class="informalexample"><pre class="programlisting">mount /dev/sda1 /media/usb</pre></div><p>Now, we can <a id="id315" class="indexterm"/>access the contents of the USB thumb drive through the <code class="literal">/media/usb</code> folder, that is, whenever we create a folder or file in this folder, we are writing to the USB thumb drive partition.</p><p>Run the following command to create a new <code class="literal">/media/usb/log</code> folder in which we will store the log for our IoT application:</p><div class="informalexample"><pre class="programlisting">mkdir /media/usb/log</pre></div><p>Now, we will change the value we pass to the filename argument when we call the <code class="literal">logging.basicConfig</code> method within the <code class="literal">__main__</code> method. We want to save the log file within the <code class="literal">/media/usb/log</code> folder. This way, we will store it in the USB thumb drive, in the <code class="literal">log</code> folder. We will use the previous code as a baseline to change the log file name and its path. The code file for the sample was <code class="literal">iot_python_chapter_06_05.py</code>.</p><p>The following lines show the new code that calls the <code class="literal">logging.basicConfig</code> method and the code file for the sample is <code class="literal">iot_python_chapter_06_06.py</code>. The rest of the code remains the same we have used in our previous example.</p><div class="informalexample"><pre class="programlisting">import logging


if __name__ == "__main__":
<span class="strong"><strong>    logging.basicConfig(</strong></span>
<span class="strong"><strong>        filename="/media/usb/log/iot_python_chapter_06_06.log",</strong></span>
<span class="strong"><strong>        level=logging.INFO,</strong></span>
<span class="strong"><strong>        format="%(asctime)s %(message)s",</strong></span>
<span class="strong"><strong>        datefmt="%m/%d/%Y %I:%M:%S %p")</strong></span>
</pre></div><p>The following line will start the new version of the example that will create the <code class="literal">iot_python_chapter_06_06.log</code> file in the <code class="literal">/media/usb/log</code> folder:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_06_06.py</pre></div><p>Keep the Python script running for a few minutes and make many changes in the incident light over the photoresistor. This way, you will generate many lines in the log file. Then, you can use your favorite SFTP client to download the log file from <code class="literal">/media/usb/log</code> and read it. However, don't forget to go back to the <code class="literal">home/root</code> folder in your SFTP client because this is the folder in which you upload the Python scripts.</p><p>If you need to <a id="id316" class="indexterm"/>unplug the USB thumb drive to plug it on another computer or device, first you must interrupt the execution of the Python script, and then, you must run the following command to unmount the partition. In the previous steps we retrieved the partition name and it was named <code class="literal">/dev/sda1</code>. Your partition name might be different, and therefore, you just need to replace <code class="literal">/dev/sda1</code> with your partition name listed when you executed the <code class="literal">fdisk</code> command that listed the disks and their partitions. Be careful and make sure you run this command on the terminal that is running the shell on the Yocto Linux. Make sure you see the <code class="literal">root@galileo:~#</code> prompt before you execute it. If you run the command in a computer that runs Linux or OS X, you might unmount one of your drives.</p><div class="informalexample"><pre class="programlisting">umount /dev/sda1</pre></div><p>Now, you can remove the USB thumb drive from the USB 2.0 host connector.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The Intel Galileo Gen 2 board provides the following resolution for the analog to digital converter:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">32 bits.</li><li class="listitem">64 bits.</li><li class="listitem">12 bits.</li></ol></div></li><li class="listitem">The analog pins allow us to detect a maximum of:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">4,096 different values, with values ranging from 0 to 4095 (inclusive).</li><li class="listitem">16,384 different values, with values ranging from 0 to 16,383 (inclusive).</li><li class="listitem">256 different values, with values ranging from 0 to 255 (inclusive).</li></ol></div></li><li class="listitem">We can configure the number of bits we want to use as the resolution by calling the following method of an <code class="literal">mraa.Aio</code> instance:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">setADCResolution</code>.</li><li class="listitem"><code class="literal">setBit</code>.</li><li class="listitem"><code class="literal">setResolutionBits</code>.</li></ol></div></li><li class="listitem">A call to the <code class="literal">read</code> method for a <code class="literal">mraa.Aio</code> instance returns:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A raw number of units based on the number of the resolution bits configured for the instance.</li><li class="listitem">A voltage value automatically converted from the raw number of units.</li><li class="listitem">A resistance value measured in Ohms (Ω).</li></ol></div></li><li class="listitem">We can use analog pins to read:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Resistance values.</li><li class="listitem">Current values.</li><li class="listitem">Voltage values.</li></ol></div></li></ol></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Summary</h1></div></div></div><p>In this chapter, we learned how to work with analog inputs to measure voltage values. We understood the impact of the different bits of resolution for the analog to digital converter and we wrote code that converted the raw units read into voltage values.</p><p>We measure voltages with an analog pin and both the mraa and the wiring-x86 library. We were able to transform a variable resistor into a voltage source and make it possible to measure the darkness level with an analog input, a photoresistor and a voltage divider.</p><p>As in the previous chapters, we continued taking advantage of Python's object-oriented features and created classes to encapsulate voltage inputs, darkness sensors, and the necessary configurations with the mraa and wiring-x86 libraries. Our code is easy to read and understand and we can easily switch the underlying low-level library.</p><p>We fired actions when the environment light changed and we were able to work with both analog inputs and analog outputs. Finally, we registered events by taking advantage of the logging features included in the Python standard library. We also learned to take advantage of the USB 2.0 host connector included in the Intel Galileo Gen 2 board to plug a USB thumb and use it as an additional storage.</p><p>Now that we were able to read the analog inputs in different ways and configurations that made it possible for our IoT device to read analog values generated by changed in the environment, we can work with a wider variety of sensors to retrieve data from the real world, which is the topic of the next chapter.</p></div></div>
</body></html>