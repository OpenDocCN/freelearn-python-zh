- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Backend with FastAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned the basic mechanics of authentication
    and authorization, and now you are ready to implement it and secure a web API,
    built with FastAPI. In this chapter, you will put this knowledge to good use and
    create a simple, yet fully functional REST API showcasing used cars and their
    pictures.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the following actions, which can be thought
    of as a loosely coupled blueprint when creating a REST API with FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the FastAPI instance to MongoDB Atlas by using the Python Motor driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the Pydantic models according to the specification and initial creation
    of the FastAPI application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the API router and implementing CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the API with a JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment to Render
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirements for this chapter are similar to those defined earlier. You
    will work with:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.11.7 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An account on MongoDB Atlas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later on, you will need to create an account on the image-hosting service **Cloudinary**
    (free) and the **Render** platform for hosting the API (also a free tier account).
    Again, you will use HTTPie for manually testing the API endpoints that you are
    going to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by understanding the application to be developed and what the backend
    will require.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is much easier to start working with a framework while having a specific
    problem that needs solving, even if the requirements are somewhat vague. The task
    at hand is rather simple: you need to create a REST API backend for storing and
    retrieving data about used cars for a fictional car sales company.'
  prefs: []
  type: TYPE_NORMAL
- en: The data structure that describes a vehicle is rather simple but can become
    more complicated as soon as you delve into the details such as engine models,
    interior colors, types of suspension, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your first simple **create**, **read**, **update**, **delete** (**CRUD**)
    application, you will keep the resource data limited. A car will be described
    by the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Brand`: The brand of the car (Ford, Renault, etc.), represented by a *string*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make or model: For example, Fiesta or Clio, represented by a *string*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Year`: The year of production, an *integer* limited to a reasonable range
    (1970–2024)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cm3`: The displacement of the engine, proportional to the power of the engine,
    a ranged *integer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kW`: Power of the engine in kW, an *integer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Km`: How many kilometers the car has travelled, an *integer* in the hundreds
    of thousands range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Price`: The price in euros'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An image URL: This is optional'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An essential feature of every car sales website is the presence of images, so
    you will implement an image-uploading pipeline with one of the leading services
    for image hosting and processing—**Cloudinary**. Later, you will aid the employees
    even more by generating compelling copy text for each car model, which will make
    the API richer while showcasing FastAPI’s simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Atlas instance and a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log in to your Atlas account, and create a new database called `carBackend`
    inside a collection named `cars`. You can refer to [*Chapter 2*](B22406_02.xhtml#_idTextAnchor026),
    *Setting Up the Database with MongoDB*. After creating the database and the collection,
    take note of the MongoDB connection string and save it in a text file for later,
    when you will be creating your secret environment keys.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Python environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating the MongoDB database on Atlas and connecting it, it is time
    for you to set up a brand new Python virtual environment and install the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a plain text file called `requirements.txt` and insert the following
    lines in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The package versioning is important if you want to be able to reproduce exactly
    the code used in this book and you can always refer to the `requirements.txt`
    file in the book’s repository. Run the `pip` installation command that reads the
    previously defined requirements file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your environment is ready. Now, armed with the knowledge of Python type hints
    and Pydantic from [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051), *Python Type
    Hints and Pydantic*, you will model this relatively simple car data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Pydantic models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin with the first Pydantic model, for a single car. Here, one of the
    main problems that need to be solved upfront is how to serialize and define the
    MongoDB `ObjectID` key in Pydantic. While there are different ways of representing
    the `ObjectID`, the simplest and the one currently recommended by MongoDB is to
    cast the `ObjectID` to a string. You can refer to the following documentation
    for further details: [https://www.mongodb.com/developer/languages/python/python-quickstart-fastapi/](https://www.mongodb.com/developer/languages/python/python-quickstart-fastapi/).'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB uses the field name `_id` for the identifier. In Python, since attributes
    that start with an underscore have a special meaning, you cannot use the original
    field name for model population.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic aliases provide a simple and elegant solution; you can name the field
    `id` but also give it an alias of `_id` and set the `populate_by_name` flag to
    `True`, as shown in [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051), *Python Type
    Hints* *and Pydantic*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will need to cast the `ObjectID` as a string. To do so, you will
    use a simple Python annotation, and the Pydantic `BeforeValidator` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder named `Chapter7` and a `models.py` file inside of it, and start
    with the imports and the `ObjectID` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the imports, and creating a new type, `PyObjectId`, which will be used
    to represent MongoDB’s original `ObjectID` as a string, continue populating the
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These fields should be very familiar if you read the chapter on Pydantic; you
    are simply declaring the car fields, marking all of them as required, and setting
    some reasonable limits on the numerical quantities (`cm3`, `km`, `price`, and
    `year`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Bear in mind that the number of car brands is limited, so it is possible and
    probably advisable to create an **enumerated** type for the brand name, but in
    this case, you will keep things simple.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add two convenient field validators that act as modifiers. You want to return
    the title of every car brand and model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete the model, finally, add a configuration dictionary that will allow
    it to be populated by name and allow arbitrary types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now test the model by adding the following (temporary) lines at the
    end of the file, outside of the class definition, and running it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `models.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, it’s time to define other models for updating a single instance and getting
    a list of cars. The `update` model will need to allow only specific fields to
    be changed. In theory, only the `price` should be updatable since cars are pretty
    immutable objects in their own right, but this system will allow for some ambiguity
    and situations in which the inserted data is just wrong and needs to be manually
    corrected via the API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After deleting or commenting out the testing lines from `models.py`, proceed
    with creating the `UpdateCarModel` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The remaining part of the class is identical to the `CarModel` class and will
    be omitted for brevity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, the `ListCarsModel` class will be very simple, as it only needs to
    handle a list of `CarModel` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the models now in place, you are ready to make a simple test and see how
    `ListCarsModel` works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new testing file called `test_models.py`, add the following lines
    in order to create two different car models and a list, and then print a model
    dump:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the `test_models.py` file with Python, the output should be the
    following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The models, at least an initial iteration of them (and MongoDB is excellent
    for iterative data modeling), are complete, so you can start scaffolding your
    FastAPI application structure in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding a FastAPI application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Motor` driver. Initially, you will only create a generic and minimal FastAPI
    application, and gradually add functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: You will begin by storing the secret environment data—in your case, just the
    MongoDB Atlas database URL—into a `.env` file. These values should be always kept
    outside the reach of the repositories. You want to be able to connect to your
    MongoDB database and verify whether the connection is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .env file to keep the secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For managing values that should be kept secret and out of the version control
    system, you will use an environment file (`.env`). Perform the following steps
    to set up the environment variables and exclude them from the version control:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `.env` file and, inside it, put your secret connection string
    in the following format, without quotes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `.env` file will later host other secret files for external services that
    you might need to use in your API development.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a `.gitignore` file, and populate it with the basic entries: directories
    and files that are not to be tracked by Git. Open a file, name it `.gitignore`,
    and insert the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are numerous examples of Python-related `.gitignore` files on the web,
    so feel free to look around, but this will be more than sufficient for our purposes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you can put the working directory under version control with the following
    Git commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a Pydantic configuration with pydantic_settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next steps, you will use the previously created environment variables
    and provide them to the `pydantic_settings`—the Pydantic class for managing application
    settings, covered in [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051)*, Python
    Type Hints and Pydantic*. This class will later be easily invoked wherever the
    environment variables will be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this preparatory work, create a `config.py` file that will leverage the
    `pydantic_settings` package for managing your settings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a configuration file, aptly named `config.py`, which you will use for
    reading the settings of the application. You will be able to change them easily
    later when you introduce some automated testing or make different settings for
    production, a different database, and so on. Paste the following code into `config.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you will use these configuration settings to get the environment data to
    connect to the MongoDB Atlas instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you can start scaffolding the actual application file by creating
    a new Python file, named `app.py`. In this file, first, instantiate a FastAPI
    instance and create a root route with a simple message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should be able to run this bare-bones application in the terminal with
    your server of choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The simple root message is available at `127.0.0.1:8000` and you have the application
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Atlas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it is time to connect it to Atlas. To do so, you will use the **Lifespan
    Events** of FastAPI, which is the newer way of handling events that need to occur
    only once before the application starts up and begins receiving requests. Lifespan
    Events also allow you to handle events that should fire only after the application
    finishes handling requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The FastAPI website has excellent documentation about the topic: [https://fastapi.tiangolo.com/advanced/events/](https://fastapi.tiangolo.com/advanced/events/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the use case in this chapter, you will use an **asynchronous context manager**
    that will allow you to yield the application instance, and fire events before
    and after the application starts. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To showcase how this works, edit the `app.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you start the application with the same command as shown previously and then
    shut it down with *Ctrl+C*, you will see that the `print` statements display messages
    in the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `lifespan` event async context is the mechanism you will use to connect
    to your Atlas instance, through the use of the settings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Again, open up the `app.py` file, add the configuration settings, change the
    `lifespan` function, and bring in the `Motor` driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you start the application now, you should receive a message similar to the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You have implemented quite a lot in this setup:'
  prefs: []
  type: TYPE_NORMAL
- en: You have created the FastAPI instance, the backbone of your API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have set the environment variables with `pydantic_settings` and they are,
    thus, manageable and maintainable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have connected to the Atlas cluster that you have set up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have also “attached“ the MongoDB database to the application, so you will
    be able to access it conveniently from the API routers through the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's start implementing the routes for the **CRUD** operations, starting
    from a solid and expansible setup.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The four basic operations at the heart of almost every web application are often
    referred by the acronym **CRUD** (**create**, **read**, **update**, and **delete**).
    These operations enable users to interact with data by creating new resources,
    retrieving one or more instances of existing resources, and modifying and deleting
    resources. Here, a more formal definition of APIs is used, but resources, in this
    case, are simply cars.
  prefs: []
  type: TYPE_NORMAL
- en: 'FastAPI is strongly tied to web standards, so these operations map to specific
    HTTP request methods: `POST` is used for creating new instances, `GET` is for
    reading one or more cars, `PUT` is for updating, and `DELETE` is for deleting
    resources. In your case, the resources are represented by `cars`, which map to
    MongoDB documents.'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the API router
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After having the application ready and serving a basic root endpoint, the environment
    variables set up, and the connection to the Atlas MongoDB database in place, you
    are now ready to start implementing the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, in the following sections, we will add a router for users; this will
    be needed to enable you to associate individual cars with particular users/salespersons,
    and to allow for some basic authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like most modern web frameworks (Express.js, Flask, etc.), FastAPI allows you
    to structure and group endpoints into API routers. `APIRouter` is a module designed
    to handle a group of operations related to a single type of object or resource:
    in your case, cars, and later, users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to create the API router for managing cars:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a dedicated folder inside your app directory and name it `/routers`.
    This directory will contain all the API routers . Inside it, create an empty `__init__.py`
    file to turn the folder into a Python package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a file named `/routers/cars.py`. This will be the first router in
    this app but, potentially, you could add more should the application grow. It
    is a convention to name the routers according to the resources they manage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `/routers/cars.py`, begin scaffolding the router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `APIRouter` instantiation is very similar to the creation of the main FastAPI
    instance—it can be thought of as a small FastAPI application that becomes an integral
    part of the main app, as well as its automated documentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`APIRouter` by itself doesn’t have any functionality—it needs to be plugged
    into the main application (`app.py`) in order to perform its tasks.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before proceeding, let’s modify the `app.py` file and plug the newly created
    `APIRouter` in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have created your first `APIRouter` that will be handling operations regarding
    cars and you have connected it, through the `app.py` file, to the main FastAPI
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will add functionality to the `APIRouter` by implementing handlers
    for various operations.
  prefs: []
  type: TYPE_NORMAL
- en: The POST handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, with the `APIRouter` connected, you can return to the `/routers/cars.py`
    file and create the first endpoint, a `POST` request handler for creating new
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code is rather simple and self-explanatory as it uses the previously defined
    Pydantic model (`CarModel`), which is flexible enough to be reused (through the
    alias) as the input and output model.
  prefs: []
  type: TYPE_NORMAL
- en: The line that creates the document to be inserted from the model uses a couple
    of Pydantic features, which are covered in [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051),
    *Python Type Hints and Pydantic*, namely, the *alias* and the *excluded* fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, launch the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In another terminal, still inside the working directory of your project and
    with the virtual environment activated, test the endpoint with **HTTPie**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Your terminal should output the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You have created the first endpoint—you can test it further with HTTPie, or
    with the interactive documentation at `http://127.0.0.1:8000/docs`, and try inserting
    some invalid data, such as a year greater than 2024 or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint should respond with informative JSON that will quickly direct you
    to the problem or provide feedback to the end user. Now, you will create the `GET`
    handlers for viewing the cars inside your database.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the GET requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For viewing resources—cars—in your system, you will use the HTTP `GET` method.
    FastAPI makes very good use of HTTP verb semantics and closely follows web standards
    and good practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, return the whole collection of cars—if you have played around with the
    `POST` endpoint, you might already have a couple of them inserted. Continuing
    the `/routers/cars.py` file, let’s add the `GET` handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test this endpoint with HTTPie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running the preceding command, you should get all the cars inserted up
    to this point, in a nice JSON structure. The function signature and the decorator
    are similar to the `POST` endpoint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instead of using `async` `for`, which can be a bit counterintuitive at first
    if you are not used to it, you could also swap the population of the empty results
    list with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you could use the `to_list()` method to get the results in a list. If
    you wish to dive deeper into the `Motor` documentation on handling cursors, their
    page is a bit dry but complete: [https://motor.readthedocs.io/en/stable/api-tornado/cursors.html](https://motor.readthedocs.io/en/stable/api-tornado/cursors.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Later, you will learn how to manually add pagination, since the collection will
    hopefully grow to hundreds of cars, as you will not want to send the user hundreds
    of results immediately. Now, create the `GET` endpoint for finding a single car
    by its ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same `/routers/cars.py` file, add the following `GET` handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The logic of the endpoint is contained in the line that checks whether the
    collection contains a car with the desired ID and the ID is supplied via a path
    parameter. The Python walrus operator (`:=`), also known as the assignment expression,
    makes your code more concise: if the car is found (it is not `None`), it is returned
    and the operand of the truthiness check—the car instance itself—is passed on;
    otherwise, the code proceeds to finish with an HTTP exception.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, for the HTTPie command for testing, you will need to look up an ID and
    provide it as a path parameter (your ID value will be different from the following):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You have implemented two of the most important result listing methods that
    map to a `GET` HTTP method: retrieving a list of all items and a specific single
    item. Other `GET` endpoints can retrieve queries based on MongoDB aggregations,
    simpler queries, and filtering, but these two cover the basics.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s complete the API with the `UPDATE` and `DELETE` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Updating and deleting records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you will tackle the most complex endpoint—the `PUT` method that will be
    used for updating the car instance. Again, in the same `/routers/cars.py` file,
    after the `GET` routes, continue editing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the endpoint function analyzes the provided user data and
    checks which fields should be updated, by merely acknowledging their presence
    in the provided `UpdateCarModel` Pydantic model. If the field is present in the
    request body, its value is passed to the `update` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, you get a transformed `car` object that, if not empty, will then be fed
    to the `find_one_and_update()` function of MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The update result simply performs the asynchronous update and returns the updated
    document by leveraging PyMongo’s `ReturnDocument.AFTER` to return the document
    after the update has been performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you must also take into account the case in which none of the fields
    is set for updating, and simply return the original document if it is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The endpoint provides two possibilities of a `404` exception in case the document
    is not found: when there are fields to be updated and when there are not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, finish the implementation of the basic CRUD functionality with the method
    for deleting cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is probably the simplest endpoint; if the car with the ID is found, it
    is deleted and the appropriate HTTP status is returned on an empty (`No` `Content`)
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes the basic CRUD functionality, but before going on, let’s tackle
    another aspect that, while not part of the basic functionality, will incur in
    every real-life project: result pagination.'
  prefs: []
  type: TYPE_NORMAL
- en: Result pagination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every application that works with data and users must have an appropriate way
    to enable and facilitate their communication. Slamming hundreds of results into
    the browser isn’t exactly the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: Results pagination with MongoDB, as well as other databases, is achieved with
    the help of the `skip` and `limit` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you will create a simple frontend-friendly pagination system
    with a custom Pydantic model that will provide two additional JSON properties:
    the current page and the `has_more` flag, to indicate whether there are more result
    pages.'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern matches the pagination UI with the arrows and page numbers that
    indicate the total number of results to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by commenting out the existing `GET` route. Open the `models.py` file
    and add the following model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This model inherits the `CarCollection` model and adds the two desired fields
    – this pattern is useful when dealing with large and complex models.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `cars.py` file, after instantiating `APIRouter`, add a hardcoded constant
    that will define the number of default results per page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you will update (or better, replace entirely) the `get all` method in the
    `routers/cars.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of the function is very similar to the previous version, but
    we have two new parameters: `page` and `limit` (the number of results per page).
    Now, create the actual pagination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The bulk of the work is handled directly by MongoDB, with the `limit` and `skip`
    parameters. The endpoint needs the total number of cars in the collection in order
    to provide information on the remaining results and their existence.
  prefs: []
  type: TYPE_NORMAL
- en: This endpoint will work just like the previous one so, to properly test it,
    open MongoDB Compass and import some data. The accompanying GitHub repository
    contains a file named `cars.csv` with 1,249 cars.
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing this data, you can perform a `GET` request like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should contain a list of cars, as in the previous case, but also
    the indication of the page and whether there are more results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Since you are already pulling the total document count from the database, you
    could extend this pagination model to include either the total number of cars
    in the database or the total number of pages given the current pagination. That
    would be a good exercise that showcases how easy it is to extend and modify the
    FastAPI setup.
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully created a fully functional REST API with FastAPI. Now,
    let’s further enhance the application by providing image-uploading functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading images to Cloudinary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While FastAPI is perfectly capable of serving static files – through the `StaticFiles`
    module ([https://fastapi.tiangolo.com/tutorial/static-files/](https://fastapi.tiangolo.com/tutorial/static-files/))
    – you will rarely want to use your server space and bandwidth to store images
    or videos.
  prefs: []
  type: TYPE_NORMAL
- en: Many specialized services can take care of digital asset media management and,
    in this section, you will learn how to work with one of the premier players in
    the area—**Cloudinary**.
  prefs: []
  type: TYPE_NORMAL
- en: Cloudinary, as its name suggests, is a cloud-based service that provides various
    solutions for digital media assets and web and mobile applications. These services
    include uploading and storing images and videos, and these are precisely the functions
    that we are going to use now.
  prefs: []
  type: TYPE_NORMAL
- en: However, Cloudinary and other similar specialized services offer much more (image
    and video manipulations, filters, automatic cropping and formatting, and real-time
    transformations) and they might be an excellent fit for many media workflows,
    especially very heavy ones.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use the service, you will first need to create a free account
    by following the instructions at [https://cloudinary.com/users/register_free](https://cloudinary.com/users/register_free).
  prefs: []
  type: TYPE_NORMAL
- en: After successfully signing up and logging in, you will automatically get assigned
    a product environment key, visible in the top-left corner. For your purposes,
    you will only interact through the Python API as you need to be able to upload
    images to your environment through FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with the Python API, or any other for that matter, in addition
    to this environment key, you will need two more pieces of information: the *API
    key* and the *API secret*. Both can be obtained from the **Settings** page ([console.cloudinary.com./settings](http://console.cloudinary.com./settings))
    and by selecting **API Keys** from the left menu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the API key and API secret, or create new ones and copy them into your
    existing `.``env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The environment name is mapped as `CLOUDINARY_CLOUD_NAME`, while the secret
    key and API key are prepended by `CLOUDINARY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to modify the `config.py` file to accommodate the new variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to install the `cloudinary` Python package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Another thing you can do is add it to your `requirements.txt` file, which,
    at this point, should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The Cloudinary documentation is much richer when it comes to JavaScript, and
    there seem to be a couple of quirks when setting up the upload client, but the
    essence is simple.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, you will update the `models.py` file to accommodate the new field –
    a string that will store the URL of the uploaded image from Cloudinary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `models.py` file and add just one line in the `CarModel` class, after
    the other fields and before the validators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, you should open `cars` collection, as you will create a new,
    empty one. Now, comment out the previous route for the `POST` handler in the `cars.py`
    file and create a new one taking into account the image uploading process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Cloudinary provides a simple utility module called `uploader` that needs to
    be imported, along with the `cloudinary` module itself. After the existing imports,
    add the following lines (`cars.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These lines import `cloudinary` and the `uploader` package, while the `# noqa`
    line prevents code linters from removing the line upon saving (as it is imported
    from a package that is already imported as a whole).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next step is configuring your Cloudinary instance, and you can do it in
    the `/routers/cars.py` file for convenience, although this could be made application-wide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To be able to read the environment variables, you will need to instantiate the
    `Settings` class again in the same file and pass the variables to the `cloudinary`
    configuration object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the cars router and modify it. The first part of the `/routers/cars.py`
    file should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you must treat the `POST` handler differently, since it will accept a
    form and a file (your car picture) and not JSON anymore. You will need to accept
    the form data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All the `CarModel` fields are now mapped to form fields with names, while the
    picture is defined as an `UploadFile` and expects a file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Continue with the same function, and add the uploading functionality:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code that handles the actual upload is very simple: just a call to `uploader`
    with the received file and there are numerous options, transformations, and filters
    that you could use.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The Cloudinary documentation covers in detail the available transformations:
    [https://cloudinary.com/documentation/transformations_intro](https://cloudinary.com/documentation/transformations_intro).'
  prefs: []
  type: TYPE_NORMAL
- en: In your case, you are just cropping the image and setting a maximum width. Cloudinary
    will return a URL once the picture is uploaded, and that URL will be part of the
    model, along with the data we used previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can construct a Pydantic model of the car and pass it to the MongoDB
    `cars` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can test the endpoint through the interactive documentation that FastAPI
    serves on `127.0.0.1:8000/docs`; just select an image and pass it to the file
    field that is present in the `POST` handler for the root route, and don’t forget
    to fill the remaining fields or there will be an error—just like dealing with
    JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also test the route with HTTPie, but first provide an image and name
    it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: After having the `Cars` API router ready, now you will create the second router
    for handling users.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the user model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have successfully created a REST API powered by the Cloudinary image hosting
    and processing power and, following a similar procedure, you could easily integrate
    other third-party services into your API, making your application more complex
    and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Without authentication, however, it would be very risky to deploy even the simplest
    API online. For instance, a malicious user (or even a kid willing to pull some
    pranks) could easily “bomb” your API with images that you wouldn’t want displayed
    and in quantities that would quickly fill your free quota. Therefore, before committing
    your API to GitHub and deploying it—in this case, to Render.com—you will add a
    user model and a JWT-based authentication scheme very similar to the one shown
    in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105), *Authentication* *and Authorization*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will create a simple user model and allow users
    to log in to the application, in order to perform some operations otherwise unavailable
    – namely, creating, updating, and deleting resources (cars). You will begin by
    abstracting the authentication logic into a class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the authentication functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you will implement an authentication class, similar to the
    one used in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105), *Authentication and
    Authorization*, that will abstract the functionalities needed for authentication
    and authorization—password encryption, JWT encoding and decoding, and the dependency
    that will be used for protecting routes. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a file called `authentication.py` in the root folder of your
    project and import the modules needed for authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, implement an `AuthHandler` class that will provide all the needed functionality
    for hashing and verifying passwords and encoding and decoding tokens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you will end the file with the `auth_wrapper` function, which will
    be injected as a dependency into the FastAPI endpoints that require an authenticated
    user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The authentication class is nearly identical to the one defined in [*Chapter
    6*](B22406_06.xhtml#_idTextAnchor105)*, Authentication and Authorization*—it provides
    methods for password hashing and verification, for JWT encoding and decoding,
    and a handy `auth_wrapper` method that is used as a dependency injection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the `authentication.py` file ready, add the user model, very similar to
    the one defined in the previous chapter, bearing in mind that this model could
    be much more complex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `models.py` file, edit the `CarModel` class and add another field—`user_id`.
    That way, you will be able to associate an inserted car with a particular user
    and require a valid user for every creation operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The model for updating the car will not need the `user_id` field as you do
    not want to make that field editable. Now, after all the car models, let’s add
    the user-related models in the same `models.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The three models correspond to the three ways you will be accessing the user
    data: the full model with all the data, the login and registration model, and
    the current user that should return `_id` and the username.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the User router
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the Pydantic models are set up, create a new router for users and allow
    some basic operations such as registration, logging in, and verifying the user
    based on the JWT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file named `users.py` inside the `routers` folder and add the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `authhandler` class encapsulates all of your authentication logic and you
    will see this functionality in the endpoint functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the registration route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The endpoint performs the same functionality as shown in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105),
    *Authentication and Authorization*, except, this time, you are working with a
    real MongoDB collection. The login functionality is also very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If a user is not found by `username` or the password doesn’t match, the endpoint
    responds with an HTTP `401` status and throws a generic message; otherwise, a
    username and a token are returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final endpoint consists of a `/me` route—a route that will be used periodically
    by the frontend (React) to check the existing JWT and its validity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `users` router finished, let’s plug it into the `app.py` file, just
    below the `cars` router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cars.py` file, which contains the `APIRouter` for managing the cars, will
    have to be updated to take into account the newly added user data. The creation
    endpoint will now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The user data is provided through dependency injection and `auth_wrapper`.
    The rest of the function is largely unaltered—you just need the `user_id` value
    from the logged-in user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The API is now quite complete; it handles data of varying complexity and can
    handle images using a top-quality cloud service. However, before deploying your
    API to an online cloud platform for the world to see, there is one more thing
    that needs to be done: setting up the **cross-origin resource sharing** (**CORS**)
    middleware.'
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI middleware and CORS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of middleware is common in almost every reputable web framework,
    and FastAPI is no exception. Middleware is just a function that accepts requests
    before they are handed over to the path operations for processing and also responds
    before they are returned.
  prefs: []
  type: TYPE_NORMAL
- en: This simple concept is quite powerful and has many uses—a middleware can check
    for specific headers that contain authentication data (such as a bearer token)
    and accept or deny requests accordingly, it can be used for rate limiting (often
    with the Redis key-value database), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating middleware in FastAPI is based on *Starlette’s* middleware, like most
    web-related concepts in FastAPI, and the documentation provides some nice examples:
    [https://fastapi.tiangolo.com/tutorial/middleware/](https://fastapi.tiangolo.com/tutorial/middleware/).'
  prefs: []
  type: TYPE_NORMAL
- en: In your application, you will use a ready-made middleware to enable the FastAPI-based
    backend—which will be running on one machine—to communicate with a frontend (in
    your case, React) running on a different origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'CORS refers to the policy that is applied when you incur situations when the
    backend and frontend reside on different origins and, by default, it is very restrictive—
    allowing only sharing data (such as calling JavaScript fetch functions) between
    systems using the same origin: the combination of a protocol (HTTP, for instance),
    domain (such as [www.packt.com](http://www.packt.com)) and a port (for example,
    `3000` or `80`).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the policy blocks all communication, so if you were to deploy your
    backend as it is currently, you couldn’t reach it from a React.js or Next.js application
    running even on the same machine but a different port.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI’s solution for this task is achieved through middleware, and it allows
    granular precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `app.py` file, import the following to import the CORS middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'After having imported the middleware, you need to configure it. After instantiating
    the FastAPI instance with the lifespan, add the middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This is a catch-all CORS setup that should be avoided in production, but it
    will be enough for our purposes and this example backend. The square brackets
    contain lists of allowed methods (such as `POST`, `GET`, and so on), origins,
    headers, and whether credentials should be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: You can restart the Uvicorn server and check that it works like before. Now,
    you will deploy the backend on a cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment to Render.com
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Render.com* is one of numerous modern cloud platforms that simplify deploying
    and managing web applications, APIs, static sites, and other types of software
    projects. It provides developers with an intuitive and simple interface and powerful
    automation tools and pipelines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to deploy a FastAPI instance: Vercel (known mainly as the
    company behind Next.js), Fly.io, Ralway, Heroku, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will choose Render.com as it provides a simple, fast, streamlined
    deployment procedure, and has a free tier and excellent documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deployment process can be broken into steps, and you will review each one
    of them briefly; it is also useful to visit their FastAPI-dedicated page if you
    wish to get up to speed: [https://docs.render.com/deploy-fastapi](https://docs.render.com/deploy-fastapi).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a GitHub repo for your backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, make sure that your `.gitignore` file contains entries for the `.env`
    file, as well as the `env/` directory for the Python environment—you do not want
    to accidentally commit the secrets and passwords to a public repository, nor do
    you want to upload the entire virtual environment content.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you haven’t committed the last changes to your backend, do it now with the
    following commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now head to [github.com](http://github.com), use your credentials to log in,
    and create a new repository. Name it however you see fit; in this example, we
    will use the name `FastAPIbackendCh7`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set up a Render.com account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, head over to [render.com](http://render.com) and create a free account.
    You can log in with your GitHub account and then navigate to the dashboard link:
    [dashboard.render.com](http://dashboard.render.com).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Locate the **New +** button and select **Web Service**. On the next prompt,
    select **Build and deploy from a Git repository** and click **Next**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the right-hand menu, select the **GitHub Configure** account and you will
    be taken to GitHub asking you to install Render. Choose your account, the one
    you used for the backend repository origin, and proceed to select the repo. This
    will allow Render to know which repository to pull.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Configure the web service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the most important and complex step of the process. Render is informed
    which repository is involved, and now it has to get all the data necessary for
    the web service to be deployed. We will examine them one by one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`main`, especially if it is the only branch, as in our case.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime**: You will be using Python 3; it should be picked up automatically
    by Render.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build command**: The command that sets up the environment – in your case,
    the Python 3 virtual environment, so it should be the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`80`), the command should be as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`.env` file, one by one: `DB_URL` and `DB_NAME` for MongoDB, and three Cloudinary
    variables.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After checking that you have entered all the settings and variables, you can
    finally click the blue **Create Web** **Service** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final settings page will look similar to the following images. The settings
    page is quite long and you will have to scroll a bit, but the first thing that
    has to be specified are the name of the service and the region:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22406_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The Render web service general settings page'
  prefs: []
  type: TYPE_NORMAL
- en: After setting the name and the region, you will see your selected repository
    and the branch to be deployed (**main**, in your case). You can leave the root
    directory empty by default.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22406_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The repository and the branch settings'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will specify the build and the start command. The build command is
    the one that installs your Python environment, while the start command starts
    the web service – your API.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22406_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The build and start commands'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step before starting the actual deployment command is to pass the
    environment variables to Render.com:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22406_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: The environment variables'
  prefs: []
  type: TYPE_NORMAL
- en: After initiating the deployment procedure, you will have to wait a bit—the service
    will have to create a new Python environment, install all the required dependencies,
    and start the service. After the process is complete, you can click on the URL
    on the page (in your case, it will be [https://farm2ch7.onrender.com](https://farm2ch7.onrender.com)
    you will have to use another address) and you can check your API online.
  prefs: []
  type: TYPE_NORMAL
- en: Your API is now live on the internet and ready to receive requests. It is worth
    mentioning that due to the recent rise of FastAPI’s popularity, more and more
    hosting and `.``env` files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have taken a simple business requirement and turned it
    into a fully functional API deployed on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: You have created the Pydantic models and applied some constraints on the data
    structure, learned how to connect to a MongoDB Atlas instance, and developed a
    basic, yet fully functional, CRUD functionality FASTAPI service.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to model entities (in your case, cars and users) through
    Pydantic and how to make the data flow seamlessly to and from your database of
    choice – MongoDB – through simple pythonic FastAPI endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: You have managed the secret keys – for connecting to MongoDB Atlas and Cloudinary
    – through `pydantic_settings` and you have crafted simple, yet flexible models
    that can easily accommodate more requirements, be expanded or include more functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The service is now ready to be used in the frontend – ultimately, giving life
    to a full-stack web application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will add a simple user model to this same API and build
    a React frontend that will consume the FastAPI backend.
  prefs: []
  type: TYPE_NORMAL
