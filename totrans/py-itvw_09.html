<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Barry Warsaw</h1></div></div></div><div><img src="img/B08180_05_01.jpg" alt="Barry Warsaw"/></div><p>Barry Warsaw<a id="id220" class="indexterm"/> is an American software engineer and a member of the Python Foundation team at LinkedIn. Barry worked for Canonical for 10 years, becoming an Ubuntu and Debian developer with responsibility for the Python ecosystem on those operating systems. He was the project leader of GNU Mailman, a popular open source mailing list manager written in Python. Barry's former roles include lead maintainer for Jython, Python release manager and member of PythonLabs. Today he is a core developer, the author of several successful Python Enhancement Proposals, and the maintainer of numerous Python libraries.</p><div><blockquote class="blockquote"><p>
<strong>Discussion themes: PythonLabs, Python's future, v2.7/v3.x.</strong>
</p><p>
<strong>Catch up with Barry Warsaw here: @pumpichank</strong>
</p></blockquote></div><p>
<strong>Mike Driscoll</strong>: How did you <a id="id221" class="indexterm"/>end up becoming a programmer?</p><p>
<strong>Barry Warsaw</strong>: I started programming when I was pretty young. Computers then were actually Teletype machines, that were connected to mainframes in the school and the main school district. So I got on the Teletypes.</p><p>I learned BASIC, which was really fun. I remember in the summer of that year, some of the kids in another school used those same Teletypes to break into the mainframes in the Board of Education. So the next year they pulled them all out of the schools and gave us 6502-based PCs. The teachers didn't know how to use them at all, so I taught the teachers.</p><p>The guidance counselors <a id="id222" class="indexterm"/>took notice of what I was doing. They hooked me up with summer internships at what was then called the National Bureau of Standards (NBS)<a id="id223" class="indexterm"/>, a federal research facility in Gaithersburg, Maryland. The NBS is where I learned to love sharing programs and collaborating with other people.</p><p>
<strong>Driscoll</strong>: So did you work with<a id="id224" class="indexterm"/> NBS all through high school?</p><p>
<strong>Warsaw</strong>: Yes, I interned with NBS through high school and through college. Then I got a full-time job at what is now called the National Institute of Standards and Technology (NIST) and I worked there until 1990.</p><p>My internships and then full-time job at NIST were eye-opening, because I didn't actually know what the real industry was like, or what it was like to be a professional programmer.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'I didn't actually know what the real industry was like, or what it was like to be a professional programmer.'</strong>
</p></blockquote></div><p>I worked with the robotics team at the time and although I wasn't doing much robotics, I did find myself working on the graphical user interfaces for industrial robots for factory automation. That work was just amazing. From there I got into system administration. A few years into that we got a lot of Sun-3s, so we learned SunOS, Unix, C programming, Emacs, and all kinds of things like that.</p><p>I was a computer science undergraduate and it was fine, but I really learned the trade by doing real programming at NIST. I've noticed that college classes don't exactly prepare you for what you actually end up doing.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'I really learned the trade by doing real programming at NIST.'</strong>
</p></blockquote></div><p>For example, I was talking to some current interns and they said that in college, at least as undergraduates, you don't even learn version control systems, such as using Git. That is just amazing to me. I can't believe how divorced from the reality of working programmers the college environment is. It is very shocking when you get out of college and it's completely different to what you were taught.</p><p>
<strong>Driscoll</strong>: Do you think that Python offers a pathway to real programming, as you call it, for new programmers?</p><p>
<strong>Warsaw</strong>: Yes, when I'm<a id="id225" class="indexterm"/> talking to kids today that use Python, these kids have often somehow hooked up with a project on GitHub. Sometimes they've even come to a Python conference and stayed for the sprints.</p><p>Kids learn so much more about modern software engineering best practices that way. You can really see it. They come in and they understand how to do pull requests and how to file good bugs. I tell all the young kids that I talk with to find a GitHub, GitLab, or even Bitbucket project that interests them and start getting involved.</p><p>Python, of course, is an amazing community for that. It's so welcoming to a diverse group of people. In the Python community we're friendly, we accept anybody, and we guide and mentor them. So I also tell students who really want to learn how to do it right to come to the Python community and get engaged, because they are going to learn so much by doing that.</p><p>
<strong>Driscoll</strong>: How did you end up <a id="id226" class="indexterm"/>getting into Python yourself?</p><p>
<strong>Warsaw</strong>: In 1994, I met Roger Masse. His girlfriend (and current wife) and my wife were very friendly, so we'd<a id="id227" class="indexterm"/> all get together for dinner. Rog and I really connected on a geek level.</p><p>Rog had just started a job at CNRI, which is the Corporation for National Research Initiatives in Virginia (CNRI<a id="id228" class="indexterm"/> was started by Bob Kahn<a id="id229" class="indexterm"/> and Vint Cerf, who are two of the <a id="id230" class="indexterm"/>fathers of TCP/IP.) So in the late summer of 1994, I started working for CNRI too.</p><p>I was working on a project called knowbots. These were <a id="id231" class="indexterm"/>little software agents that would bundle themselves up and move to a different host. The knowbots would do some work over at another host and then move around the internet to find information for you. Rog and I started working on that project in Objective-C on NeXT machines.</p><p>A little later, some friends who were still at NIST told me about a Dutch guy who was coming to give a little workshop on this language that he had invented. They asked whether I'd be interested, so we did a little bit of research. Of course, it was Guido van Rossum, and the language was Python, so we said, "Sure, we'd love to come."</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'A Dutch guy...was coming to give a little workshop on this language that he had invented. They asked whether I'd be interested, so we did a little bit of research. Of course, it was Guido van Rossum, and the language was Python.'</strong>
</p></blockquote></div><p>We wanted to talk to Guido about some of his ideas, because we thought that Python could be really cool for this Objective-C project. We thought we could script Objective-C in Python.</p><p>The workshop was in November of 1994. There were only 20 of us and we just fell in love with Python and Guido. He was just so open and cool and the workshop was really fantastic. I think both Guido and I were fans of Emacs, so we talked about how docstrings in Python could work a little bit syntactically, or at least syntactically like docstrings in Emacs Lisp.</p><p>After the workshop, we went back to CNRI and were just gushing about how we thought Python was going to work really well. One of our colleagues said, "Hey, why don't we try to hire Guido?" We didn't know if he wanted to come to the United States, or would be interested in working on this Objective-C Python thing, or the knowbot project. But he was, so in April of 1995 Guido started at CNRI.</p><p>We moved a lot of the infrastructure from the Netherlands to Virginia. I think at the time it was a CVS repository. So we pulled the CVS repository over, did a lot of the system administration stuff for Python, and of course got into developing Python as well.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'Python 1.2 was the first version that we released out of CNRI. So it was in some ways very much today's Python.'</strong>
</p></blockquote></div><p>I knew C pretty well at the time, so <a id="id232" class="indexterm"/>we did a lot of work on the C internals of Python and then also the Python standard library. I think Python 1.2 was the first version that we released out of CNRI. So it was in some ways very much today's Python. Even Python 3 has the same feel to it that Python did way back then. Although there are so many amazing new features, that I don't know whether you would recognize it.</p><p>I seem to remember that although Python had classes, it didn't even have keyword arguments. We were doing a lot of things with Tcl/Tk graphically. The signatures of functions got ridiculous, because even though most of the arguments were None, you had to pass them all in. So that was the motivation for doing keyword arguments. Anyway, CNRI was great and working with Guido on Python was fantastic. We did that until Guido moved on.</p><p>
<strong>Driscoll</strong>: Steve Holden said that you were part of PythonLabs<a id="id233" class="indexterm"/>. Were you one of the founders?</p><p>
<strong>Warsaw</strong>: Yes, in 2000 a bunch of <a id="id234" class="indexterm"/>us left CNRI to seek our fortunes with Python. It was the five of us: Tim Peters, Jeremy Hilton, Fred Drake, myself, and Guido. Roger stayed at CNRI. That group was what we called PythonLabs, but it was more of an inside joke. I mean, it wasn't really an official thing.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'In 2000 a bunch of us left CNRI to seek our fortunes with Python.'</strong>
</p></blockquote></div><p>We joined BeOpen, but that lasted for a few months and then went away. Then we all moved over to Zope Corporation. We just felt like we <a id="id235" class="indexterm"/>had a little club made up of the five of us who had come from CNRI and Tim Peters, of course. So that's really what PythonLabs was. I even made a joke at one time on the mailing list and asked Tim whether PythonLabs still exists. If you go to pythonlab.com, you'll find the very humorous response from Tim to my question.</p><p>
<strong>Driscoll</strong>: Did you guys have<a id="id236" class="indexterm"/> specific roles in PythonLabs?</p><p>
<strong>Warsaw</strong>: Not really, although Guido really led the work that we did on Python and the work that we did with Python.</p><p>I can't remember many of the details about what we did in the beginning, even with Zope Corporation. Of course, we all had tasks to do within Zope Corporation, but then we would get together and work on Python itself.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'We worked on what we found interesting, which was internals, new features, bug fixes or infrastructure.'</strong>
</p></blockquote></div><p>We worked on what we found interesting, which was internals, new features, bug fixes, or infrastructure. All of that stuff really needed to be done back then, because the Python community was so much smaller than it is now.</p><p>
<strong>Driscoll</strong>: So were there any <a id="id237" class="indexterm"/>goals at that time for the Python language that you guys were shooting for? </p><p>
<strong>Warsaw</strong>: You know, it's hard for me to remember the exact timeline, but I'm sure someone could do the archaeology and figure out what the features were. I do remember the big pushes.</p><p>One of the earliest things that I did at CNRI was work with Roger on what was called the grand renaming. The Python C source code back at that time didn't have the nice clean namespaces that the C API has now. They were all just named in a global namespace.</p><p>The problem with that was that people were trying to embed Python, but it wasn't going to work because those names were colliding with their own symbols. So we did the grand renaming, where we went through the entire internal C API and cleaned it up, so that you could embed Python in other C applications. So I remember that was one of the very first things that I did.</p><p>There was also a lot of work on new-style classes at the time, which of course in Python 3 is the only kind of class. There were a lot of discussions about how the type system would work in the new-style class infrastructure.</p><p>The other thing that I remember from the original workshop was that there was this guy named Don Beaudry. He was<a id="id238" class="indexterm"/> doing some crazy metaclass hacks. Of course, Jim Fulton<a id="id239" class="indexterm"/> was very interested in doing metaclass stuff as well. Jim was the CTO of Zope Corporation.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'By Python 2.2, we really wanted to do metaclasses right and fix some of the problems with the semantics of classic classes.'</strong>
</p></blockquote></div><p>I remember not really understanding much about metaclasses at the original Python workshop. It went over my head at the time. However, by Python 2.2, we really wanted to do metaclasses right and fix some of the problems with the semantics of classic classes.</p><p>I remember a lot of discussions about how the new-style class stuff could work so that you could inherit from a type and define new types, as well as new instances. There were just so many features, but we all pitched in on the things that were interesting to us.</p><p>
<strong>Driscoll</strong>: I seem to recall that you worked on the <a id="id240" class="indexterm"/>original email library in Python. Do you remember how that came about?</p><p>
<strong>Warsaw</strong>: Yeah, so one of the things that we did early on was to move the Python mailing list to CNRI. It was still being run at CWI, which was the Dutch institute where Guido worked before he came to the US.</p><p>The Python mailing list was r<a id="id241" class="indexterm"/>unning on Majordomo, which was the most popular mailing list software at the time, and was written all in Perl. When we moved it over, there were a lot of things that we wanted to improve. By the way, Ken Manheimer actually crops up here because he was very instrumental in the early days of Mailman.</p><p>So we pulled the Majordomo installation over to CNRI, but it was really inconvenient making the changes to it that we wanted to make, because we didn't enjoy developing in Perl. We're Pythonistas, right?</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'We didn't enjoy developing in Perl. We're Pythonistas, right?'</strong>
</p></blockquote></div><p>We had a friend by the name of<a id="id242" class="indexterm"/> John Viega, who was going to the University of Virginia. John was friends with the guys in the Dave Matthews Band<a id="id243" class="indexterm"/> before they were big. So John wanted to write a little mailing list manager in Python, that he could use to connect the fans with the band and send out announcements. He wrote the mailing list manager, and we caught wind of it.</p><p>We thought that maybe we could work on this thing for Python mailing lists, because it would be better to have a Python-based mailing list manager. So we got a copy of the mailing list manager, but John lost the disc and the original copy of what eventually became Mailman. Fortunately, Ken had a copy that he resurrected and we were able to start working on it to support the mailing list for the Python community.</p><p>We decided that we would call the mailing list manager Mailman. We then put it into the GNU Project and put the GPL on it. I personally got really involved with Mailman. It was interesting and I really loved the aspect of allowing people to communicate.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'I really loved the aspect of allowing people to communicate.'</strong>
</p></blockquote></div><p>The other really cool thing about the early Mailman software was that it had a web interface, which was something that Majordomo didn't have at the time. That was one of the defining factors, in my opinion, of Mailman.</p><p>One of the things that I realized was that there was no good RFC compliant email-parsing software. There really wasn't. There was the rfc822 module in the standard library, but it wasn't very advanced and new email standards were coming out for the format of email messages.</p><p>It became apparent that rfc822 <a id="id244" class="indexterm"/>wasn't going to cut it. So I worked on an offshoot<a id="id245" class="indexterm"/> called mimelib, that added support for MIME constructs: composing messages, having different MIME types and images. We had defined a model that described an email message, especially on MIME messages.</p><p>We wanted it to be possible to programmatically build up a tree of email messages. We had a parser so that you could feed it a bunch of Python 2 byte strings. You had this parser and it would give you a tree that represented the email message. Then you could manipulate that and pass that tree to a generator. The generator would flatten the tree back into the byte representation of an email message, along with the MIME boundaries and things like that.</p><p>We tried to be RFC compliant as best as we could. I think we were pretty successful, but they're very complicated standards. I think even now we're learning the deficiencies and the bugs in it. In any case, mimelib was a thing and I released mimelib as a separate third-party package. Then I started using mimelib in Mailman. It was a real benefit to have this third-party package that we could develop separately from Mailman<a id="id246" class="indexterm"/> and just pull in as a dependency.</p><p>I don't remember exactly when it happened, but there was a Python release when we felt that mimelib was pretty stable and the API was pretty good. So we pulled mimelib into the standard library and renamed it as the email package, which is a better name for it anyway, because there's a lot more to it than just MIME.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'We pulled mimelib into the standard library and renamed it as the email package.'</strong>
</p></blockquote></div><p>So that's the history of the email package. It came from mimelib, which came from the work in Mailman, on top of <a id="id247" class="indexterm"/>the rfc822 module in the old Python standard library. I was actually joking with the guys that we should have called the panel session at PyCon Grandpa's Python Time! We've all been around Python for so long. We should say, "Kids! Come on up and sit around the fire. Grandpa will tell you stories about Python in the old days."</p><p>
<strong>Driscoll</strong>: So we talked about Mailman. Have you learned any lessons that you would like to share from being the<a id="id248" class="indexterm"/> lead for that project?</p><p>
<strong>Warsaw</strong>: I'm not sure that I'm really <a id="id249" class="indexterm"/>the best project leader! I have so many interests and find it difficult to spend the right amount of time with a project.</p><p>I am fortunate to have core developers <a id="id250" class="indexterm"/>in the Mailman project who are fantastic developers, really amazing people and super friendly. The highlight of my PyCon is to get together with the core developers to hang out socially, work on the technology, and keep it current.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'The highlight of my PyCon is to get together with the core developers to hang out socially, work on the technology, and keep it current.'</strong>
</p></blockquote></div><p>Mailman's been around for forever now and it's still a viable project. I do think that you have to really open up, trust your core developers, and be willing to hand over parts of a project. Great web designers really understand the technology and can design a great interface that looks good and is fun to use. That's great for me because then I can concentrate on the bits that really interest and fire me up.</p><p>We've had some Google Summer of Code projects and one of our core developers came from there. He's just done an amazing amount of work on our Docker images and some of the glue layers. It's just really great to be able to have developers that you really like to work with, that you know are just really smart and friendly.</p><p>You need to have developers that will put forth that kind of community aspect that I like with Python. The Python community is welcoming and friendly, with a focus on mentoring people as they come in. So I think another lesson is to be open with what you do and give your time and your expertise, because it will come back tenfold.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'I think another lesson is to be open with what you do and give your time and your expertise.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: Have you had any challenges with the Mailman project <a id="id251" class="indexterm"/>that you didn't expect to have?</p><p>
<strong>Warsaw</strong>: Oh yeah. I don't get this too much these days but because Mailman is free and we give it away, we don't really even know all of the people who use it.</p><p>We don't control Mailman in any way and we don't tell people what they can and cannot do with it. Most people use it for very good things, such as for their biking club, or certainly in a lot of tech discussion lists. But some people do use Mailman for nefarious purposes, like spamming people. One of the challenges is that we get contacted when people have been spammed by unscrupulous developers and we get a lot of threatening emails at times, which is very <a id="id252" class="indexterm"/>disheartening.</p><p>One of the things that I've learned is that people reach out to you in those cases when they are frustrated. They're going through pain because they're getting spammed by somebody. They don't know who is spamming them and they're not getting any relief from that person, so they search around.</p><p>Now, we put very prominent notices that we do not condone spam and we do not approve of using <a id="id253" class="indexterm"/>Mailman for any kind of illegal purposes. We encourage people to use Mailman for opt-in, so that you know that you're signing up for something. But we can't really control it.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'One of the things that I have found helpful is to let people know that there is a human on the other side of Mailman.'</strong>
</p></blockquote></div><p>We don't have any kind of administrative access, but people reach out to us in moments of frustration. One of the things that I have found helpful is to let people know that there is a human on the other side of Mailman. Sometimes we'll do a little bit of research to see if we can find a contact, or find their hosting provider. Even the most frustrated person is normally very appreciative of that.</p><p>So that was really challenging back in the early days. People would send very nasty emails to my personal email address and that gets really frustrating. There are all kinds of people out there on the internet, right?</p><p>
<strong>Driscoll</strong>: So when we spoke for the PyDev of the Week series, you mentioned that you worked at Canonical. What was it like to work at a <a id="id254" class="indexterm"/>Linux distribution company?</p><p>
<strong>Warsaw</strong>: Well, it was really awesome. I stopped working there in April, but I'd been there for ten years. I really enjoyed it and it was a great position to be in, because I felt that I could really help the Python community for Ubuntu and Debian.</p><p>Working at Canonical was a great nexus for helping people who were consumers of a Linux distro, like Ubuntu or Debian, and users of Python on those platforms. I'm a core developer for Python, so when a problem would occur, I was able to see whether the fix needed to go in Debian or Ubuntu and ask whether it needed to go in upstream Python or go in some library.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'I'm a core developer for Python, so when a problem would occur, I was able to see whether the fix needed to go in Debian or Ubuntu and ask whether it needed to go in upstream Python or go in some library.'</strong>
</p></blockquote></div><p>So I really had the <a id="id255" class="indexterm"/>opportunity to work very closely with a wide range of Python projects. I was also able to interact with Python itself and work on areas of Python that I thought needed to be improved for distribution on the Linux distro. So it was really fun. It was a great experience and I'm really glad that I had the opportunity to do it.</p><p>
<strong>Driscoll</strong>: What exactly did you do in your role<a id="id256" class="indexterm"/> at Canonical? Could you explain that?</p><p>
<strong>Warsaw</strong>: Yes, so I was a member of the Foundations team, which was a small team that worked on this sort of plumbing layer of a Linux distro.</p><p>So imagine, at the bottommost part you have a kernel, right? We didn't do any kernel work because we had a separate kernel team. But above that you had things like the boot process, compilers, toolchains, and package building the archive health. So as things landed in the archive, you wanted to make sure that it was stable and robust. It's all this sort of random mix of things above the kernel, but below the desktop.</p><p>One of the things that the Foundation team was responsible for was language interpreters. Python is fairly popular for writing scripts that the operating system itself and the build processes use, so it is a pretty important language for Ubuntu and many Linux distributions.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'One of the things that I was responsible for was the general health of the Python ecosystem on Ubuntu.'</strong>
</p></blockquote></div><p>One of the things that I was responsible for was the general health of the Python ecosystem on Ubuntu. That included working on transitions, like trying to move everybody to Python 3. Then as new versions of Python would come out, while I didn't directly do the interpreter, I did work on all the packages that were involved.</p><p>There are a lot of steps that you have to go through in order to make Python 3.5 the default version on Ubuntu. It's a long process. A lot of packages won't build, or they have bugs in the new version of Python, so you have to fix those, prioritize and stuff like that. So one of the main things that I did on Ubuntu was really work on the Python ecosystem.</p><p>Again, I was looking at the tools and <a id="id257" class="indexterm"/>seeing what pain points Ubuntu developers were having with the Python tools. I was trying to figure out how to improve them and where to improve them. For example, if there was some friction with using pip and setuptools on Ubuntu, then the fixes might have to go into pip and setuptools. It was my responsibility to be aware of where people were having pains using Ubuntu.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'I was looking at the tools and seeing what pain points Ubuntu developers were having with the Python tools. I was trying to figure out how to improve them and where to improve them.'</strong>
</p></blockquote></div><p>In addition, I did a lot of consulting with people who were using Python on Ubuntu. If people had Python questions, I would work with them, answer their questions, and do code reviews.</p><p>I also worked with a lot of people in the community. If community people on Ubuntu had questions about how Python worked, or had problems, I was one of the people they could talk to and work with. A lot of it is community-driven, but I think if you really want to make a distribution a success, then you have to put resources into it. Every Linux distribution puts resources into its communities, because otherwise it's just going to fall apart.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'A lot of it is community-driven, but I think if you really want to make a distribution a success, then you have to put resources into it.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: Let's move on to a slightly different topic. What do you think makes Python such a good language for<a id="id258" class="indexterm"/> AI and machine learning right now?</p><p>
<strong>Warsaw</strong>: Python is a<a id="id259" class="indexterm"/> fantastic glue language. It's also very easy to learn and use, both for expert programmers and for researchers, for whom programming is not their primary vocation.</p><p>I think both of these aspects make Python a great language for domains like machine learning. The language is very malleable as you experiment, but robust as you build bigger systems. I think this is also a contributing factor to why we see Python becoming so popular in the data sciences. These are often technologies where programming isn't the central occupation, but kind of secondary to the core research being conducted.</p><p>
<strong>Driscoll</strong>: What could we do to make <a id="id260" class="indexterm"/>Python an even better language for AI and machine learning?</p><p>
<strong>Warsaw</strong>: I'm not sure that much <a id="id261" class="indexterm"/>needs to change with Python, but it's possible that the Python ecosystem could be improved to give more visibility to AI/machine learning libraries, and make it easier to integrate such libraries with other Python applications, frameworks, and libraries.</p><p>
<strong>Driscoll</strong>: So, just because I'm curious, what<a id="id262" class="indexterm"/> are you doing now?</p><p>
<strong>Warsaw</strong>: I just started working with LinkedIn a couple of weeks ago. I really like it. I think it's a great company and they use a lot of Python. So I'm still doing Python work. I'm working on Python within LinkedIn and I love the team.</p><p>I think LinkedIn has a great mission and I am psyched about what the company is trying to do. The mission is to connect people with economic opportunities, so it's kind of funny that LinkedIn helped me to find a job and that job happened to be with LinkedIn!</p><p>LinkedIn also has a lot of other stuff that it does. I really like the focus on helping people to find the right fit for whatever they want to do in their professional career.</p><p>
<strong>Driscoll</strong>: Since you have such a deep knowledge of Python, could you tell me where you see Python<a id="id263" class="indexterm"/> going as a language in the future?</p><p>
<strong>Warsaw</strong>: That's a really interesting question. I think in some ways it's hard to predict where Python is going. I've been involved in Python for 23 years, and there was no way I could have predicted in 1994 what the computing world was going to look like today.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'I've been involved in Python for 23 years, and there was no way I could have predicted in 1994 what the computing world was going to look like today.'</strong>
</p></blockquote></div><p>I look at phones, IoT (Internet of things) devices, and just the whole landscape of what computing looks like today, with the cloud and containers. It's just amazing to look around and see all of that stuff. So there's no real way to predict what Python is going to look like even five years from now, and certainly not ten or fifteen years from now.</p><p>I do think <a id="id264" class="indexterm"/>Python's future is still very bright, but I think Python, and especially CPython, which is the implementation of Python in C, has challenges. Any language that's been around for that long is going to have some challenges. Python was invented to solve problems in the 90s and the computing world is different now and is going to become different still.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'Python was invented to solve problems in the 90s and the computing world is different now and is going to become different still.'</strong>
</p></blockquote></div><p>I think the challenges for Python include things like performance and multi-core or multi-threading applications. There are definitely people who are working on that stuff and other implementations of Python may spring up like PyPy, Jython, or IronPython.</p><p>Aside from the challenges that the various implementations have, one thing that Python has as a language, and I think this is its real strength, is that it scales along with the human scale. For example, you can have one person write up some scripts on their laptop to solve a particular problem that they have. Python's great for that.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'One thing that Python has as a language, and I think this is its real strength, is that it scales along with the human scale.'</strong>
</p></blockquote></div><p>Python also scales to, let's say, a small open source project with maybe 10 or 15 people contributing. Python scales to hundreds of people working on a fairly large project, or thousands of people working on massive software projects.</p><p>Another amazing strength of Python as a language is that new developers can come in and learn it easily and be productive very quickly. They can pull down a completely new Python source code for a project that they've never seen before and dive in and learn it very easily and quickly. There are some challenges as Python scales on the human scale, but I feel like those are being solved by things like the type annotations, for example.</p><p>On very large Python projects, where you have a mix of junior and senior developers, it can be a lot of effort for junior developers to understand how to use an existing library or application, because they're coming from a more statically-typed language.</p><p>So a lot of organizations that are building very large Python codebases are adopting type annotations, maybe not so much to help with the performance of the applications, but to help with the onboarding of new developers. I think that's going a long way in helping Python to continue to scale on a human scale.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'I think if we address some of those technical limitations...then we're really setting Python up for another 20 years of success and growth.'</strong>
</p></blockquote></div><p>To me, the language's scaling<a id="id265" class="indexterm"/> capacity and the welcoming nature of the Python community are the two things that make Python still compelling even after 23 years, and will continue to make Python compelling in the future. I think if we address some of those technical limitations, which are completely doable, then we're really setting Python up for another 20 years of success and growth.</p><p>
<strong>Driscoll</strong>: Do you see any new features coming to Python, or is there anything else that you're excited about?</p><p>
<strong>Warsaw</strong>: Yeah, another<a id="id266" class="indexterm"/> friend of mine, Eric Smith, who's also a core developer, comes up with these great features that you don't know how you ever used Python without.</p><p>One new feature in Python 3.6 is the f-strings, the format strings. I have only used f-strings in a couple of projects, because they're a Python 3.6 feature, but I love f-strings. I also love contextlib.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'I say this with every release, but Python 3.7 is truly going to be the best ever.'</strong>
</p></blockquote></div><p>I'm also very excited about Python 3.7. I say this with every release, but Python 3.7 is truly going to be the best ever. We're going to see some great new libraries, improved support for <em>asyncio</em>, and better performance. Python development is as vibrant as ever and I believe that the improvements to our workflow (for example, the switch to Git and GitHub) has really opened up Python development to many more people.</p><p>I love that folks can experiment with crazy ideas, like the gilectomy, which even if they don't pan out, provide fodder for future development. C Python's implementation is easy to understand, navigate, and change, and this goes a long way to making it a friendly platform for experimentation and change.</p><p>All the while, we have Guido's continued stewardship and other long-time developers providing vision and coherence, so that while Python today looks very different to Python from 20+ years ago, it still feels like the same well-designed, consistent, easy to learn, yet scalable language.</p><p>
<strong>Driscoll</strong>: What do you think about the long life<a id="id267" class="indexterm"/> of Python 2.7?</p><p>
<strong>Warsaw</strong>: We all know that we've got to get on Python 3, so Python 2's life is limited. I made it a mission inside of Ubuntu to try to get people to get on Python 3. Similarly, within LinkedIn, I'm really psyched, because all of my projects are on Python 3 now. Python 3 is so much more compelling than Python 2.</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'We all know that we've got to get on Python 3, so Python 2's life is limited.'</strong>
</p></blockquote></div><p>You don't even realize all of the features that you have in Python 3. One of the features that I think is really awesome is the async I/O library. I'm using that in a lot of things and think it is a very compelling new feature, that started with Python 3.4. Even with Python 3.5, with the new async keywords for I/O-based applications, <em>asyncio</em> was just amazing.</p><p>There are tons of these features that once you start to use them, you just can't go back to Python 2. It feels so primitive. I love Python 3 and use it exclusively in all of my personal open source projects. I find that dropping back to Python 2.7 is often a chore, because so many of the cool things you depend on are just missing, although some libraries are available in Python 2 compatible back ports.</p><p>I firmly believe that it's well past the time to fully embrace Python 3. I wouldn't write a line of new code that doesn't support it, although there can be business reasons to continue to support existing Python 2 code.</p><p>It's almost never that difficult to convert to Python 3, although there are still a handful of dependencies that don't support it, often because those dependencies have been abandoned. It does require resources and careful planning though, but any organization that routinely addresses technical debt should have conversion to Python 3 in their plans.</p><p>That said, the long life of Python 2.7 has been great. It's provided two important benefits I think. The first is that it provided a very stable version of Python, almost a long-term support release, so folks didn't have to even think about changes in Python every 18 months (the typical length of time new versions are in development).</p><div><blockquote class="blockquote"><p>
<strong>Barry Warsaw: 'Python 2.7's long life also allowed the rest of the ecosystem to catch up with Python 3.'</strong>
</p></blockquote></div><p>Python 2.7's long life also <a id="id268" class="indexterm"/>allowed the rest of the ecosystem to catch up with Python 3. So the folks who were very motivated to support it could sand down the sharp edges and make it much easier for others to follow. I think we now have very good tools, experience, and expertise in how to switch to Python 3 with the greatest chance of success.</p><p>I think we reached the tipping point somewhere around the Python 3.5 release. Regardless of what the numbers say, we're well past the point where there's any debate about choosing Python 3, especially for new code. Python 2.7 will end its life in mid-2020 and that's about right, although not soon enough for me! At some point, it's just more fun to develop in and on Python 3. That's where you are seeing the most energy and enthusiasm from Python developers.</p><p>
<strong>Driscoll</strong>: What changes would you like<a id="id269" class="indexterm"/> to see in future Python releases?</p><p>
<strong>Warsaw</strong>: I've been thinking lately about significant changes to the way we develop C extension modules. I'd like to see us get out of that business, by adopting something like Cython as the higher-level language and tool for generating extension modules. By doing this, we'd lay the groundwork for improvements in the C API, uncoupled from all the existing extension modules out there.</p><p>We'd be able to experiment with more internal changes that break the C API, such as removing the Global Interpreter Lock (GIL) or adopting a traditional garbage collector. If you look at the gilectomy work for example (that is, an experimental branch to remove the GIL), it's very complex, because it has to maintain compatibility with the existing C API as much as possible. If we could break that, without breaking source-level compatibility with third-party modules, we'd be much more free to improve things internally.</p><p>
<strong>Driscoll</strong>: Thank you, Barry Warsaw.</p></div></body></html>