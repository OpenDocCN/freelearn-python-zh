- en: Chapter 8. Working with Web Services – XML-RPC, SOAP, and REST
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 与Web服务协作 – XML-RPC、SOAP和REST
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Querying a local XML-RPC server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询本地XML-RPC服务器
- en: Writing a multithreaded, multicall XML-RPC server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个多线程、多调用XML-RPC服务器
- en: Running an XML-RPC server with a basic HTTP authentication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本HTTP身份验证运行XML-RPC服务器
- en: Collecting some photo information from Flickr using REST
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST从Flickr收集一些照片信息
- en: Searching for SOAP methods from an Amazon S3 web service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Amazon S3 Web服务中搜索SOAP方法
- en: Searching Google for custom information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Google上搜索自定义信息
- en: Searching Amazon for books through product search API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过产品搜索API在Amazon上搜索书籍
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter presents some interesting Python recipes on web services using
    three different approaches, namely, **XML Remote Procedure Call** (**XML-RPC**),
    **Simple Object Access Protocol** (**SOAP**), and **Representational State Transfer**
    (**REST**). The idea behind the web services is to enable an interaction between
    two software components over the Web through a carefully designed protocol. The
    interface is machine readable. Various protocols are used to facilitate the web
    services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用三种不同方法（即**XML远程过程调用**（**XML-RPC**）、**简单对象访问协议**（**SOAP**）和**表征状态转移**（**REST**））在Web服务中的一些有趣的Python食谱。Web服务的理念是通过精心设计的协议在Web上使两个软件组件之间进行交互。接口是机器可读的。使用各种协议来促进Web服务。
- en: Here, we bring examples from three commonly used protocols. XML-RPC uses HTTP
    as the transport medium, and communication is done using XML contents. A server
    that implements XML-RPC waits for a call from a suitable client. The client calls
    that server to execute remote procedures with different parameters. XML-RPC is
    simpler and comes with a minimum security in mind. On the other hand, SOAP has
    a rich set of protocols for enhanced remote procedure calls. REST is an architectural
    style to facilitate web services. It operates with HTTP request methods, namely,
    `GET`, `POST`, `PUT`, and `DELETE`. This chapter presents the practical use of
    these web services protocols and styles to achieve some common tasks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了三个常用协议的示例。XML-RPC使用HTTP作为传输媒介，通信使用XML内容进行。实现XML-RPC的服务器等待来自合适客户端的调用。客户端调用该服务器以执行具有不同参数的远程过程。XML-RPC更简单，并考虑了最小安全性。另一方面，SOAP有一套丰富的协议，用于增强远程过程调用。REST是一种促进Web服务的架构风格。它使用HTTP请求方法操作，即`GET`、`POST`、`PUT`和`DELETE`。本章介绍了这些Web服务协议和风格的实际应用，以实现一些常见任务。
- en: Querying a local XML-RPC server
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询本地XML-RPC服务器
- en: 'If you do a lot of web programming, it''s most likely that you will come across
    this task: to get some information from a website that runs an XML-RPC service.
    Before we go into the depth of an XML-RPC service, let''s launch an XML-RPC server
    and talk to it first.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做很多Web编程，你很可能会遇到这个任务：从一个运行XML-RPC服务的网站上获取一些信息。在我们深入研究XML-RPC服务之前，让我们先启动一个XML-RPC服务器并与它进行通信。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use the Python Supervisor program that is widely used
    to launch and manage a bunch of executable programs. Supervisor can be run as
    a background daemon and can monitor child processes and restart if they die suddenly.
    We can install Supervisor by simply running the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用Python Supervisor程序，这是一个广泛用于启动和管理多个可执行程序的程序。Supervisor可以作为后台守护进程运行，可以监控子进程，并在它们意外死亡时重新启动。我们可以通过简单地运行以下命令来安装Supervisor：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We need to create a configuration file for Supervisor. A sample configuration
    is given in this recipe. In this example, we define the Unix HTTP server socket
    and a few other parameters. Note the `rpcinterface:supervisor` section where `rpcinterface_factory`
    is defined to communicate with clients.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为Supervisor创建一个配置文件。本食谱提供了一个示例配置。在这个例子中，我们定义了Unix HTTP服务器套接字和一些其他参数。注意`rpcinterface:supervisor`部分，其中`rpcinterface_factory`被定义为与客户端通信。
- en: Using Supervisor, we configure a simple server program in the `program:8_2_multithreaded_multicall_xmlrpc_server.py`
    section by specifying the command and some other parameters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`program:8_2_multithreaded_multicall_xmlrpc_server.py`部分，我们使用Supervisor配置一个简单的服务器程序，通过指定命令和一些其他参数。
- en: 'Listing 8.1a gives the code for a minimal Supervisor configuration, as shown:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1a给出了最小化Supervisor配置的代码，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you create the preceding Supervisor configuration file in your favorite editor,
    you can run Supervisor by simply calling it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用你喜欢的编辑器创建前面的管理员配置文件，你可以通过简单地调用它来运行管理员。
- en: Now, we can code an XML-RPC client that can act as a Supervisor proxy and give
    us the information about the running processes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个 XML-RPC 客户端，它可以充当管理员代理，并给我们提供有关正在运行进程的信息。
- en: 'Listing 8.1b gives the code for querying a local XML-RPC server, as shown:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1b 给出了查询本地 XML-RPC 服务器的代码，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run the Supervisor daemon, it will show the output similar to the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行管理员守护进程，它将显示类似于以下内容的输出：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that our child process, `8_2_multithreaded_multicall_xmlrpc_server.py`,
    has been launched.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的子进程 `8_2_multithreaded_multicall_xmlrpc_server.py` 已经启动。
- en: 'Now, if you run the client code, it will query the XML-RPC server interface
    of Supervisor and list the running processes, as shown:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行客户端代码，它将查询管理员服务器的 XML-RPC 服务器接口并列出正在运行的进程，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe relies on running the Supervisor daemon (configured with `rpcinterface`)
    in the background. Supervisor launches another XML-RPC server, as follows: `8_2_multithreaded_multicall_xmlrpc_server.py`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱依赖于在后台运行配置了 `rpcinterface` 的管理员守护进程。管理员启动了另一个 XML-RPC 服务器，如下所示：`8_2_multithreaded_multicall_xmlrpc_server.py`。
- en: The client code has a `query_supervisr()`method, which takes an argument for
    the Supervisor socket. In this method, an instance of `SupervisorTransport` is
    created with the Unix socket path. Then, an XML-RPC server proxy is created by
    instantiating the `ServerProxy()` class of `xmlrpclib` by passing the server address
    and previously created `transport`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码有一个 `query_supervisr()` 方法，该方法接受一个管理员套接字参数。在这个方法中，使用 Unix 套接字路径创建了一个 `SupervisorTransport`
    实例。然后，通过传递服务器地址和先前创建的 `transport`，通过实例化 `xmlrpclib` 的 `ServerProxy()` 类创建了一个 XML-RPC
    服务器代理。
- en: The XML-RPC server proxy then calls the Supervisor's `getAllProcessInfo()` method,
    which prints the process information of the child process. This process includes
    `pid`, `statename`, `description`, and so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: XML-RPC 服务器代理随后调用管理员的 `getAllProcessInfo()` 方法，该方法打印子进程的进程信息。这个过程包括 `pid`、`statename`、`description`
    等等。
- en: Writing a multithreaded multicall XML-RPC server
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写多线程多调用 XML-RPC 服务器
- en: You can make your XML-RPC server accept multiple calls simultaneously. This
    means that multiple function calls can return a single result. In addition to
    this, if your server is multithreaded, then you can execute more code after the
    server is launched in a single thread. The program's main thread will not be blocked
    in this manner.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让你的 XML-RPC 服务器同时接受多个调用。这意味着多个函数调用可以返回单个结果。除此之外，如果你的服务器是多线程的，那么你可以在单个线程中启动服务器后执行更多代码。程序的主线程将以这种方式不会被阻塞。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We can create a `ServerThread` class inheriting from the `threading.Thread`
    class and wrap a `SimpleXMLRPCServer` instance in an attribute of this class.
    This can be set up to accept multiple calls.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个继承自 `threading.Thread` 类的 `ServerThread` 类，并将一个 `SimpleXMLRPCServer`
    实例封装为该类的属性。这可以设置为接受多个调用。
- en: 'Then, we can create two functions: one launches the multithreaded, multicall
    XML-RPC server and the other creates a client to that server.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建两个函数：一个启动多线程、多调用的 XML-RPC 服务器，另一个创建对该服务器的客户端。
- en: 'Listing 8.2 gives the code for writing a multithreaded, multicall XML-RPC server,
    as shown:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 给出了编写多线程、多调用 XML-RPC 服务器的代码，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run this script, you will see the output similar to the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本，你将看到类似于以下内容的输出：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have created a `ServerThread` subclass inheriting from the
    Python threading library's `Thread` class. This subclass initializes a server
    attribute that creates an instance of the `SimpleXMLRPC` server. The XML-RPC server
    address can be given via the command-line input. In order to enable the multicall
    function, we called the `register_multicall_functions()` method on the server
    instance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个继承自 Python 线程库的 `Thread` 类的 `ServerThread` 子类。这个子类初始化一个服务器属性，该属性创建一个
    `SimpleXMLRPC` 服务器实例。XML-RPC 服务器地址可以通过命令行输入提供。为了启用多调用功能，我们在服务器实例上调用 `register_multicall_functions()`
    方法。
- en: 'Then, four trivial functions are registered with this XML-RPC server: `add()`,
    `subtract()`, `multiply()`, and `divide()`. These functions do exactly the same
    operation as their names suggest.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用此 XML-RPC 服务器注册了四个简单的函数：`add()`、`subtract()`、`multiply()` 和 `divide()`。这些函数的操作正好与它们的名称所暗示的相同。
- en: In order to launch the server, we pass a host and port to the `run_server()`
    function. A server instance is created using the `ServerThread` class discussed
    earlier. The `start()` method of this server instance launches the XML-RPC server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动服务器，我们将主机和端口传递给`run_server()`函数。使用之前讨论过的`ServerThread`类创建服务器实例。这个服务器实例的`start()`方法启动XML-RPC服务器。
- en: On the client side, the `run_client()` function accepts the same host and port
    arguments from the command line. It then creates a proxy instance of the XML-RPC
    server discussed earlier by calling the `ServerProxy()` class from `xmlrpclib`.
    This proxy instance is then passed onto the `MultiCall` class instance, `multicall`.
    Now, the preceding four trivial RPC methods can be run, for example, `add`, `subtract`,
    `multiply`, and `divide`. Finally, we can get the result via a single call, for
    example, `multicall()`. The result tuple is then printed in a single line.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，`run_client()`函数从命令行接受相同的host和port参数。然后通过调用`xmlrpclib`中的`ServerProxy()`类创建之前讨论过的XML-RPC服务器的代理实例。这个代理实例随后被传递给`MultiCall`类实例`multicall`。现在，前面提到的四个简单的RPC方法可以运行，例如`add`、`subtract`、`multiply`和`divide`。最后，我们可以通过单个调用获取结果，例如`multicall()`。结果元组随后在一行中打印出来。
- en: Running an XML-RPC server with a basic HTTP authentication
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本HTTP身份验证运行XML-RPC服务器
- en: Sometimes, you may need to implement authentication with an XML-RPC server.
    This recipe presents an example of a basic HTTP authentication with an XML-RPC
    server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要实现XML-RPC服务器的身份验证。这个配方提供了一个基本HTTP身份验证的XML-RPC服务器的示例。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We can create a subclass of `SimpleXMLRPCServer` and override its request handler
    so that when a request comes, it is verified against a given login credentials.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建`SimpleXMLRPCServer`的子类，并覆盖其请求处理器，以便当请求到来时，它将与给定的登录凭证进行验证。
- en: 'Listing 8.3a gives the code for running an XML-RPC server with a basic HTTP
    authentication, as shown:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3a给出了运行具有基本HTTP身份验证的XML-RPC服务器的代码，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If this server is run, then the following output can be seen by default:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行此服务器，则默认可以看到以下输出：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let us create a simple client proxy and use the same login credentials
    as used with the server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的客户端代理，并使用与服务器相同的登录凭证。
- en: 'Listing 8.3b gives the code for the XML-RPC Client, as shown:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3b给出了XML-RPC客户端的代码，如下所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you run the client, then it shows the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行客户端，那么它将显示以下输出：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the server script, the `SecureXMLRPCServer` subclass is created by inheriting
    from `SimpleXMLRPCServer`. In this subclass' initialization code, we created the
    `VerifyingRequestHandler` class that actually intercepts the request and does
    the basic authentication using the `authenticate()` method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器脚本中，通过从`SimpleXMLRPCServer`继承创建`SecureXMLRPCServer`子类。在这个子类的初始化代码中，我们创建了`VerifyingRequestHandler`类，该类实际上拦截请求并使用`authenticate()`方法进行基本身份验证。
- en: In the `authenticate()` method, the HTTP request is passed as an argument. This
    method checks the presence of the value of `Authorization`. If its value is set
    to `Basic`, it then decodes the encoded password with the `b64decode()` function
    from the `base64` standard module. After extracting the username and password,
    it then checks that with the server's given credentials set up initially.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`authenticate()`方法中，HTTP请求作为参数传递。该方法检查`Authorization`值的是否存在。如果其值设置为`Basic`，则使用`base64`标准模块中的`b64decode()`函数解码编码后的密码。在提取用户名和密码后，它随后与服务器最初设置的凭证进行验证。
- en: In the `run_server()` function, a simple `echo()` subfunction is defined and
    registered with the `SecureXMLRPCServer` instance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`run_server()`函数中，定义了一个简单的`echo()`子函数，并将其注册到`SecureXMLRPCServer`实例中。
- en: In the client script, `run_client()` simply takes the server address and login
    credentials and passes them to the `ServerProxy()` instance. It then sends a single
    line message via the `echo()` method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端脚本中，`run_client()`简单地获取服务器地址和登录凭证，并将它们传递给`ServerProxy()`实例。然后通过`echo()`方法发送单行消息。
- en: Collecting some photo information from Flickr using REST
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST从Flickr收集一些照片信息
- en: Many Internet websites provide a web services interface through their REST APIs.
    **Flickr**, a famous photo sharing website, has a REST interface. Let's try to
    gather some photo information to build a specialized database or other photo-related
    application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 许多互联网网站通过它们的REST API提供Web服务接口。**Flickr**，一个著名的照片分享网站，有一个REST接口。让我们尝试收集一些照片信息来构建一个专门的数据库或其他与照片相关的应用程序。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We need the REST URLs for making the HTTP requests. For simplicity's sake, the
    URLs are hard coded in this recipe. We can use the third-party `requests` module
    to make the REST requests. It has the convenient `get()`, `post()`, `put()`, and
    `delete()` methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要REST URL来执行HTTP请求。为了简化，这个菜谱中将URL硬编码。我们可以使用第三方`requests`模块来执行REST请求。它有方便的`get()`、`post()`、`put()`和`delete()`方法。
- en: In order to talk to Flickr web services, you need to register yourself and get
    a secret API key. This API key can be placed in a `local_settings.py` file or
    supplied via the command line.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Flickr Web服务通信，您需要注册并获取一个秘密API密钥。这个API密钥可以放在`local_settings.py`文件中，或者通过命令行提供。
- en: 'Listing 8.4 gives the code for collecting some photo information from Flickr
    using REST, as shown:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4展示了使用REST从Flickr收集一些照片信息的代码，如下所示：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can run this recipe with your Flickr API key either by placing it in a
    `local_settings.py` file or supplying it from the command line (via the `--api-key`
    argument). In addition to the API key, a search tag and maximum count of the result
    arguments can be supplied. By default, this recipe will search for the `Python`
    tag and restrict the result to three entries, as shown in the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将API密钥放入`local_settings.py`文件或从命令行（通过`--api-key`参数）提供它来运行这个菜谱。除了API密钥外，还可以提供搜索标签和结果的最大计数参数。默认情况下，这个菜谱将搜索`Python`标签，并将结果限制为三个条目，如下面的输出所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe demonstrates how to interact with Flickr using its REST APIs. In
    this example, the `collect_photo_info()` tag takes three parameters: Flickr API
    key, a search tag, and the desired number of search results.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何使用其REST API与Flickr进行交互。在这个例子中，`collect_photo_info()`标签接受三个参数：Flickr
    API密钥、搜索标签和期望的搜索结果数量。
- en: We construct the first URL to search for photos. Note that in this URL, the
    value of the method parameter is `flickr.photos.search` and the desired result
    format is JSON.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建第一个URL来搜索照片。请注意，在这个URL中，方法参数的值是`flickr.photos.search`，期望的结果格式是JSON。
- en: The results of the first `get()` call are stored in the `resp` variable and
    then converted to the JSON format by calling the `json()` method on `resp`. Now,
    the JSON data is read in a loop looking into the `['photos']['photo']` iterator.
    A `photo_collection` list is created to return the result after organizing the
    information. In this list, each photo information is represented by a dictionary.
    The keys of this dictionary are populated by extracting information from the earlier
    JSON response and another `GET` request to get the information regarding the specific
    photo.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次`get()`调用的结果存储在`resp`变量中，然后通过在`resp`上调用`json()`方法将其转换为JSON格式。现在，JSON数据通过循环读取`['photos']['photo']`迭代器。创建一个`photo_collection`列表来返回经过信息整理后的结果。在这个列表中，每张照片信息由一个字典表示。这个字典的键是通过从早期的JSON响应和另一个`GET`请求中提取信息来填充的。
- en: Note that to get the comments about a photo, we need to make another `get()`
    request and gather comment information from the `['comments']['comment']` elements
    of the returned JSON. Finally, these comments are appended to a list and attached
    to the photo dictionary entry.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了获取关于照片的评论，我们需要进行另一个`get()`请求，并从返回的JSON的`['comments']['comment']`元素中收集评论信息。最后，这些评论被附加到一个列表中，并附加到照片字典条目中。
- en: In the main function, we extract the `photo_collection` dictionary and print
    some useful information about each photo.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们提取`photo_collection`字典并打印有关每张照片的一些有用信息。
- en: Searching for SOAP methods from an Amazon S3 web service
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Amazon S3 Web服务搜索SOAP方法
- en: If you need to interact with a server that implements web services in Simple
    Object Access Procedure (SOAP), then this recipe can help to get a starting point.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要与实现简单对象访问过程（SOAP）的Web服务交互，那么这个菜谱可以帮助您找到一个起点。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We can use the third-party `SOAPpy` library for this task. This can be installed
    by running the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用第三方`SOAPpy`库来完成这个任务。可以通过运行以下命令来安装它：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We create a proxy instance and introspect the server methods before we can call
    them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以调用它们之前，我们创建一个代理实例并检查服务器方法。
- en: In this recipe, let's interact with an Amazon S3 storage service. We have got
    a test URL for the web services API. An API key is necessary to do this simple
    task.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将与Amazon S3存储服务进行交互。我们已获取了Web服务API的测试URL。执行这个简单任务需要一个API密钥。
- en: 'Listing 8.5 gives the code for searching for SOAP methods from an Amazon S3
    web service, as shown:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5给出了从Amazon S3网络服务中搜索SOAP方法的代码，如下所示：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you run this script, it will print the total number of available methods
    that support web services definition language (WSDL) and the details of one arbitrary
    method, as shown:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本，它将打印出支持Web服务定义语言（WSDL）的可用方法的总数以及一个任意方法的详细信息，如下所示：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This script defines a method called `list_soap_methods()` that takes a URL and
    constructs a SOAP proxy object by calling the `WSDL.Proxy()` method of `SOAPpy`.
    The available SOAP methods are available under this proxy's method attribute.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本定义了一个名为`list_soap_methods()`的方法，它接受一个URL并通过调用`SOAPpy`的`WSDL.Proxy()`方法来构建SOAP代理对象。可用的SOAP方法都位于此代理的方法属性下。
- en: An iteration over the proxy's method keys are done to introspect the method
    keys. A `for` loop just prints the details of a single SOAP method, that is, the
    name of the key and details about it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遍历代理的方法键来迭代，`for`循环仅打印单个SOAP方法的详细信息，即键的名称及其详细信息。
- en: Searching Google for custom information
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索谷歌以获取自定义信息
- en: Searching Google for getting information about something seems to be an everyday
    activity for many people. Let's try to search Google for some information.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在谷歌上搜索以获取关于某物的信息似乎对许多人来说是日常活动。让我们尝试使用谷歌搜索一些信息。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe uses a third-party Python library, `requests`, which can be installed
    via `pip`, as shown in the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱使用第三方Python库`requests`，可以通过以下命令安装：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Google has sophisticated APIs to conduct a search. However, they require you
    to register and get the API keys by following a specific way. For simplicity's
    sake, let us use Google's old plain **Asynchronous JavaScript** (**AJAX**) API
    to search for some information about Python books.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌有复杂的API来进行搜索。然而，它们要求你注册并按照特定方式获取API密钥。为了简单起见，让我们使用谷歌旧的普通**异步JavaScript**（**AJAX**）API来搜索有关Python书籍的一些信息。
- en: 'Listing 8.6 gives the code for searching Google for custom information, as
    shown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6给出了搜索谷歌自定义信息的代码，如下所示：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you run this script by specifying a search query in the `--tag` argument,
    then it will search Google and print a total results count and the top four hits
    pages, as shown:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过指定`--tag`参数中的搜索查询来运行此脚本，那么它将搜索谷歌并打印出总结果数和前四个命中页面，如下所示：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we defined a short function, `get_search_url()`, which constructs
    the search URL from a `BASE_URL` constant and the target query.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，我们定义了一个简短的功能`get_search_url()`，它从`BASE_URL`常量和目标查询中构建搜索URL。
- en: The main search function, `search_info()`, takes the search tag and constructs
    the query. The `requests` library is used to make the `get()` call. The returned
    response is then turned into JSON data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 主要搜索函数`search_info()`接受搜索标签并构建查询。使用`requests`库进行`get()`调用。然后，将返回的响应转换为JSON数据。
- en: The search results are extracted from the JSON data by accessing the value of
    the `'responseData'` key. The estimated results and hits are then extracted by
    accessing the relevant keys of the result data. The first four hit URLs are then
    printed on the screen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问`'responseData'`键的值从JSON数据中提取搜索结果。然后通过访问结果数据的相关键提取估计结果和命中数。然后将前四个命中URL打印到屏幕上。
- en: Searching Amazon for books through product search API
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过产品搜索API搜索亚马逊上的书籍
- en: If you like to search for products on Amazon and include some of them in your
    website or application, this recipe can help you to do that. We can see how to
    search Amazon for books.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢在亚马逊上搜索产品并将其中一些包含在你的网站或应用程序中，这个食谱可以帮助你做到这一点。我们可以看看如何搜索亚马逊上的书籍。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe depends on the third-party Python library, `bottlenose`. You can
    install this library using `pip`, as shown in the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱依赖于第三方Python库`bottlenose`。你可以使用以下命令安装此库：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, you need to place your Amazon account's access key, secret key, and affiliate
    ID into `local_settings.py`. A sample settings file is provided with the book
    code. You can also edit this script and place it here as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将你的亚马逊账户的访问密钥、秘密密钥和联盟ID放入`local_settings.py`。提供了一个带有书籍代码的示例设置文件。你也可以编辑此脚本并将其放置在此处。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We can use the `bottlenose` library that implements the Amazon's product search
    APIs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用实现了亚马逊产品搜索API的`bottlenose`库。
- en: 'Listing 8.7 gives the code for searching Amazon for books through product search
    APIs, as shown:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7给出了通过产品搜索API搜索亚马逊书籍的代码，如下所示：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you run this recipe with a search tag and index, you can see some results
    similar to the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用搜索标签和索引运行这个食谱，你可以看到一些类似以下输出的结果：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe uses the third-party `bottlenose` library's `Amazon()` class to
    create an object for searching Amazon through the product search API. This is
    done by the top-level `search_for_books()` function. The `ItemSearch()` method
    of this object is invoked with passing values to the `SearchIndex` and `Keywords`
    keys. It uses the `relevancerank` method to sort the search results.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱使用第三方`bottlenose`库的`Amazon()`类来创建一个对象，通过产品搜索API搜索亚马逊。这是通过顶级`search_for_books()`函数完成的。这个对象的`ItemSearch()`方法通过传递`SearchIndex`和`Keywords`键的值来调用。它使用`relevancerank`方法对搜索结果进行排序。
- en: The search results are processed using the `xml` module's `minidom` interface,
    which has a useful `parseString()` method. It returns the parsed XML tree-like
    data structure. The `getElementsByTagName()` method on this data structure helps
    to find the item's information. The item attributes are then looked up and placed
    in a dictionary of parsed items. Finally, all the parsed items are appended in
    a `all_items()`list and returned to the user.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索结果使用`xml`模块的`minidom`接口进行处理，该接口有一个有用的`parseString()`方法。它返回解析后的XML树形数据结构。这个数据结构上的`getElementsByTagName()`方法有助于找到物品的信息。然后查找物品属性，并将它们放置在解析物品的字典中。最后，所有解析的物品都附加到`all_items()`列表中，并返回给用户。
