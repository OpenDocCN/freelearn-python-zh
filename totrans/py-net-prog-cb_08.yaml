- en: Chapter 8. Working with Web Services – XML-RPC, SOAP, and REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Querying a local XML-RPC server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a multithreaded, multicall XML-RPC server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running an XML-RPC server with a basic HTTP authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting some photo information from Flickr using REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for SOAP methods from an Amazon S3 web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching Google for custom information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching Amazon for books through product search API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents some interesting Python recipes on web services using
    three different approaches, namely, **XML Remote Procedure Call** (**XML-RPC**),
    **Simple Object Access Protocol** (**SOAP**), and **Representational State Transfer**
    (**REST**). The idea behind the web services is to enable an interaction between
    two software components over the Web through a carefully designed protocol. The
    interface is machine readable. Various protocols are used to facilitate the web
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we bring examples from three commonly used protocols. XML-RPC uses HTTP
    as the transport medium, and communication is done using XML contents. A server
    that implements XML-RPC waits for a call from a suitable client. The client calls
    that server to execute remote procedures with different parameters. XML-RPC is
    simpler and comes with a minimum security in mind. On the other hand, SOAP has
    a rich set of protocols for enhanced remote procedure calls. REST is an architectural
    style to facilitate web services. It operates with HTTP request methods, namely,
    `GET`, `POST`, `PUT`, and `DELETE`. This chapter presents the practical use of
    these web services protocols and styles to achieve some common tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Querying a local XML-RPC server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do a lot of web programming, it''s most likely that you will come across
    this task: to get some information from a website that runs an XML-RPC service.
    Before we go into the depth of an XML-RPC service, let''s launch an XML-RPC server
    and talk to it first.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the Python Supervisor program that is widely used
    to launch and manage a bunch of executable programs. Supervisor can be run as
    a background daemon and can monitor child processes and restart if they die suddenly.
    We can install Supervisor by simply running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to create a configuration file for Supervisor. A sample configuration
    is given in this recipe. In this example, we define the Unix HTTP server socket
    and a few other parameters. Note the `rpcinterface:supervisor` section where `rpcinterface_factory`
    is defined to communicate with clients.
  prefs: []
  type: TYPE_NORMAL
- en: Using Supervisor, we configure a simple server program in the `program:8_2_multithreaded_multicall_xmlrpc_server.py`
    section by specifying the command and some other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.1a gives the code for a minimal Supervisor configuration, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you create the preceding Supervisor configuration file in your favorite editor,
    you can run Supervisor by simply calling it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can code an XML-RPC client that can act as a Supervisor proxy and give
    us the information about the running processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.1b gives the code for querying a local XML-RPC server, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the Supervisor daemon, it will show the output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that our child process, `8_2_multithreaded_multicall_xmlrpc_server.py`,
    has been launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run the client code, it will query the XML-RPC server interface
    of Supervisor and list the running processes, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe relies on running the Supervisor daemon (configured with `rpcinterface`)
    in the background. Supervisor launches another XML-RPC server, as follows: `8_2_multithreaded_multicall_xmlrpc_server.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: The client code has a `query_supervisr()`method, which takes an argument for
    the Supervisor socket. In this method, an instance of `SupervisorTransport` is
    created with the Unix socket path. Then, an XML-RPC server proxy is created by
    instantiating the `ServerProxy()` class of `xmlrpclib` by passing the server address
    and previously created `transport`.
  prefs: []
  type: TYPE_NORMAL
- en: The XML-RPC server proxy then calls the Supervisor's `getAllProcessInfo()` method,
    which prints the process information of the child process. This process includes
    `pid`, `statename`, `description`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a multithreaded multicall XML-RPC server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can make your XML-RPC server accept multiple calls simultaneously. This
    means that multiple function calls can return a single result. In addition to
    this, if your server is multithreaded, then you can execute more code after the
    server is launched in a single thread. The program's main thread will not be blocked
    in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create a `ServerThread` class inheriting from the `threading.Thread`
    class and wrap a `SimpleXMLRPCServer` instance in an attribute of this class.
    This can be set up to accept multiple calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can create two functions: one launches the multithreaded, multicall
    XML-RPC server and the other creates a client to that server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.2 gives the code for writing a multithreaded, multicall XML-RPC server,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, you will see the output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have created a `ServerThread` subclass inheriting from the
    Python threading library's `Thread` class. This subclass initializes a server
    attribute that creates an instance of the `SimpleXMLRPC` server. The XML-RPC server
    address can be given via the command-line input. In order to enable the multicall
    function, we called the `register_multicall_functions()` method on the server
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, four trivial functions are registered with this XML-RPC server: `add()`,
    `subtract()`, `multiply()`, and `divide()`. These functions do exactly the same
    operation as their names suggest.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to launch the server, we pass a host and port to the `run_server()`
    function. A server instance is created using the `ServerThread` class discussed
    earlier. The `start()` method of this server instance launches the XML-RPC server.
  prefs: []
  type: TYPE_NORMAL
- en: On the client side, the `run_client()` function accepts the same host and port
    arguments from the command line. It then creates a proxy instance of the XML-RPC
    server discussed earlier by calling the `ServerProxy()` class from `xmlrpclib`.
    This proxy instance is then passed onto the `MultiCall` class instance, `multicall`.
    Now, the preceding four trivial RPC methods can be run, for example, `add`, `subtract`,
    `multiply`, and `divide`. Finally, we can get the result via a single call, for
    example, `multicall()`. The result tuple is then printed in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Running an XML-RPC server with a basic HTTP authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may need to implement authentication with an XML-RPC server.
    This recipe presents an example of a basic HTTP authentication with an XML-RPC
    server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create a subclass of `SimpleXMLRPCServer` and override its request handler
    so that when a request comes, it is verified against a given login credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.3a gives the code for running an XML-RPC server with a basic HTTP
    authentication, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If this server is run, then the following output can be seen by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us create a simple client proxy and use the same login credentials
    as used with the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.3b gives the code for the XML-RPC Client, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the client, then it shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the server script, the `SecureXMLRPCServer` subclass is created by inheriting
    from `SimpleXMLRPCServer`. In this subclass' initialization code, we created the
    `VerifyingRequestHandler` class that actually intercepts the request and does
    the basic authentication using the `authenticate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `authenticate()` method, the HTTP request is passed as an argument. This
    method checks the presence of the value of `Authorization`. If its value is set
    to `Basic`, it then decodes the encoded password with the `b64decode()` function
    from the `base64` standard module. After extracting the username and password,
    it then checks that with the server's given credentials set up initially.
  prefs: []
  type: TYPE_NORMAL
- en: In the `run_server()` function, a simple `echo()` subfunction is defined and
    registered with the `SecureXMLRPCServer` instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the client script, `run_client()` simply takes the server address and login
    credentials and passes them to the `ServerProxy()` instance. It then sends a single
    line message via the `echo()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting some photo information from Flickr using REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Internet websites provide a web services interface through their REST APIs.
    **Flickr**, a famous photo sharing website, has a REST interface. Let's try to
    gather some photo information to build a specialized database or other photo-related
    application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need the REST URLs for making the HTTP requests. For simplicity's sake, the
    URLs are hard coded in this recipe. We can use the third-party `requests` module
    to make the REST requests. It has the convenient `get()`, `post()`, `put()`, and
    `delete()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: In order to talk to Flickr web services, you need to register yourself and get
    a secret API key. This API key can be placed in a `local_settings.py` file or
    supplied via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.4 gives the code for collecting some photo information from Flickr
    using REST, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this recipe with your Flickr API key either by placing it in a
    `local_settings.py` file or supplying it from the command line (via the `--api-key`
    argument). In addition to the API key, a search tag and maximum count of the result
    arguments can be supplied. By default, this recipe will search for the `Python`
    tag and restrict the result to three entries, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe demonstrates how to interact with Flickr using its REST APIs. In
    this example, the `collect_photo_info()` tag takes three parameters: Flickr API
    key, a search tag, and the desired number of search results.'
  prefs: []
  type: TYPE_NORMAL
- en: We construct the first URL to search for photos. Note that in this URL, the
    value of the method parameter is `flickr.photos.search` and the desired result
    format is JSON.
  prefs: []
  type: TYPE_NORMAL
- en: The results of the first `get()` call are stored in the `resp` variable and
    then converted to the JSON format by calling the `json()` method on `resp`. Now,
    the JSON data is read in a loop looking into the `['photos']['photo']` iterator.
    A `photo_collection` list is created to return the result after organizing the
    information. In this list, each photo information is represented by a dictionary.
    The keys of this dictionary are populated by extracting information from the earlier
    JSON response and another `GET` request to get the information regarding the specific
    photo.
  prefs: []
  type: TYPE_NORMAL
- en: Note that to get the comments about a photo, we need to make another `get()`
    request and gather comment information from the `['comments']['comment']` elements
    of the returned JSON. Finally, these comments are appended to a list and attached
    to the photo dictionary entry.
  prefs: []
  type: TYPE_NORMAL
- en: In the main function, we extract the `photo_collection` dictionary and print
    some useful information about each photo.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for SOAP methods from an Amazon S3 web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to interact with a server that implements web services in Simple
    Object Access Procedure (SOAP), then this recipe can help to get a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the third-party `SOAPpy` library for this task. This can be installed
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create a proxy instance and introspect the server methods before we can call
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, let's interact with an Amazon S3 storage service. We have got
    a test URL for the web services API. An API key is necessary to do this simple
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.5 gives the code for searching for SOAP methods from an Amazon S3
    web service, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, it will print the total number of available methods
    that support web services definition language (WSDL) and the details of one arbitrary
    method, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script defines a method called `list_soap_methods()` that takes a URL and
    constructs a SOAP proxy object by calling the `WSDL.Proxy()` method of `SOAPpy`.
    The available SOAP methods are available under this proxy's method attribute.
  prefs: []
  type: TYPE_NORMAL
- en: An iteration over the proxy's method keys are done to introspect the method
    keys. A `for` loop just prints the details of a single SOAP method, that is, the
    name of the key and details about it.
  prefs: []
  type: TYPE_NORMAL
- en: Searching Google for custom information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Searching Google for getting information about something seems to be an everyday
    activity for many people. Let's try to search Google for some information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses a third-party Python library, `requests`, which can be installed
    via `pip`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google has sophisticated APIs to conduct a search. However, they require you
    to register and get the API keys by following a specific way. For simplicity's
    sake, let us use Google's old plain **Asynchronous JavaScript** (**AJAX**) API
    to search for some information about Python books.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.6 gives the code for searching Google for custom information, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script by specifying a search query in the `--tag` argument,
    then it will search Google and print a total results count and the top four hits
    pages, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we defined a short function, `get_search_url()`, which constructs
    the search URL from a `BASE_URL` constant and the target query.
  prefs: []
  type: TYPE_NORMAL
- en: The main search function, `search_info()`, takes the search tag and constructs
    the query. The `requests` library is used to make the `get()` call. The returned
    response is then turned into JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: The search results are extracted from the JSON data by accessing the value of
    the `'responseData'` key. The estimated results and hits are then extracted by
    accessing the relevant keys of the result data. The first four hit URLs are then
    printed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Searching Amazon for books through product search API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you like to search for products on Amazon and include some of them in your
    website or application, this recipe can help you to do that. We can see how to
    search Amazon for books.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe depends on the third-party Python library, `bottlenose`. You can
    install this library using `pip`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, you need to place your Amazon account's access key, secret key, and affiliate
    ID into `local_settings.py`. A sample settings file is provided with the book
    code. You can also edit this script and place it here as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `bottlenose` library that implements the Amazon's product search
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.7 gives the code for searching Amazon for books through product search
    APIs, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this recipe with a search tag and index, you can see some results
    similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses the third-party `bottlenose` library's `Amazon()` class to
    create an object for searching Amazon through the product search API. This is
    done by the top-level `search_for_books()` function. The `ItemSearch()` method
    of this object is invoked with passing values to the `SearchIndex` and `Keywords`
    keys. It uses the `relevancerank` method to sort the search results.
  prefs: []
  type: TYPE_NORMAL
- en: The search results are processed using the `xml` module's `minidom` interface,
    which has a useful `parseString()` method. It returns the parsed XML tree-like
    data structure. The `getElementsByTagName()` method on this data structure helps
    to find the item's information. The item attributes are then looked up and placed
    in a dictionary of parsed items. Finally, all the parsed items are appended in
    a `all_items()`list and returned to the user.
  prefs: []
  type: TYPE_NORMAL
