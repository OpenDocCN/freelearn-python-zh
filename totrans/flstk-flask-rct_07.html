<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-111"><a id="_idTextAnchor142"/>7</h1>
<h1 id="_idParaDest-112"><a id="_idTextAnchor143"/>React Unit Testing</h1>
<p>We sufficiently discussed the fundamentals of React in the preceding chapters. You have been exposed to React tools and resources to master modern frontend techniques in your full stack development journey. We explored in-depth useful information required to build rich interactive interfaces with React. We discussed the topics of components, props and state, JSX, event handling, forms, and routing in React.</p>
<p>In this chapter, we will focus on unit testing in React applications, a type of software testing that focuses on isolated piece(s) of code. Also, we will explore <strong class="bold">Jest</strong>, a Node-based test<a id="_idIndexMarker391"/> runner. The test runner allows you to discover test files, run tests, and find out whether tests passed or failed automatically. You will then end with a report in a very clear, expressive, and human-readable format.</p>
<p>Jest is a popular testing framework developed with React in mind. The project was formally owned by <em class="italic">Meta</em>, the same company behind React. However, with the recent transfer of Jest from Meta to the <em class="italic">OpenJs Foundation</em>, Jest now has an independent core team working actively on it to ensure stability, security, and code bases that can stand the test of time.</p>
<p>In addition, we will briefly examine a useful testing tool in the React ecosystem – the <strong class="bold">React Testing Library</strong> (<strong class="bold">RTL</strong>). This library provides us with arrays of methods to virtually run tests on React components.</p>
<p>Finally, in this chapter, we will deep-dive into <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>), a software development paradigm<a id="_idIndexMarker392"/> that places priority on test implementation before actual coding. The coding and testing are interlaced. Testing always comes first, although it is obviously not a fun part of the software development process.</p>
<p>Most experienced developers still struggle with testing just as beginners do. Companies have different policies around testing, but in real-world development, you can’t have industrial-strength web applications without testing.</p>
<p>Testing ensures that you follow the best practice of the software development life cycle and that you and your application end users have confidence in your web application functionalities. With appropriate testing, the features of your web application will perform efficiently as expected.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>What is software testing?</li>
<li>Introducing Jest</li>
<li>Writing tests in Jest</li>
<li>Unit-testing React components</li>
<li>TDD</li>
</ul>
<h1 id="_idParaDest-113"><a id="_idTextAnchor144"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07</a></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor145"/>What is software testing?</h1>
<p><strong class="bold">Software testing</strong> is a process that ensures all the pieces of code<a id="_idIndexMarker393"/> in software or application development work as expected by all stakeholders. The process of testing is one of the key phases in software development life cycles that explains the standardized methodology of designing and developing an application.</p>
<p>Software testing ensures that web applications have fewer bugs, technical requirements are implemented as expected efficiently, development costs are reduced, and ultimately, business needs are met.</p>
<p>Interestingly, testing, if carried out effectively, usually gives software engineers the confidence to know full well that the product they ship to production is maintainable, readable, reliable, and well structured.</p>
<p>This creates less panic about possible costly bugs in an application, which may cost a company embarrassment or the erosion of customers’ confidence. There are various types of software testing worthy of note – unit testing, integration testing, performance testing, usability testing, acceptance testing, and regression testing.</p>
<p>Let’s briefly discuss the types of testing that we have in software development to refresh our minds and have a solid base to build on in the subsequent sections.</p>
<ul>
<li><strong class="bold">Unit testing</strong>: In this type of testing, the smallest piece<a id="_idIndexMarker394"/> of code or unit in software<a id="_idIndexMarker395"/> or application development is tested. In unit testing, you systematically go through three stages – planning, case scripting, and testing. You are primarily concerned with the functionality of the independent units of your application. In the <em class="italic">Unit-testing React components</em> section, we will deep-dive into unit testing and how you can implement unit tests in your React applications.</li>
<li><strong class="bold">Integration testing</strong>: In this type of testing, groups<a id="_idIndexMarker396"/> of individual units of codes<a id="_idIndexMarker397"/> are combined and tested for effective interaction with one another.</li>
<li><strong class="bold">Performance testing</strong>: In this type of testing, the speed<a id="_idIndexMarker398"/> and effectiveness of your application<a id="_idIndexMarker399"/> are tested against a given workload. This approach is used to identify early bottlenecks in the smooth running of a software application.</li>
<li><strong class="bold">Usability testing</strong>: In this type of testing, intended users<a id="_idIndexMarker400"/> of your application are allowed<a id="_idIndexMarker401"/> to get a feel for your product. The feedback from direct evaluations of your application design through usability testing ensures you are able to capture users’ frustration while interacting with your application so early. The report on usability testing can also provide other useful insights that might improve your product.</li>
<li><strong class="bold">Acceptance testing</strong>: In this type of testing, client satisfaction <a id="_idIndexMarker402"/>is gauged – customer requirements<a id="_idIndexMarker403"/> are evaluated against a developed software or application. The customer is able to check that those requirements are captured properly and work as expected.</li>
<li><strong class="bold">Regression testing</strong>: In this type of testing, we check<a id="_idIndexMarker404"/> whether code changes<a id="_idIndexMarker405"/> occasioned by the addition of new functionality into your software or application do not break down the previously tested working functionality. Regression prevents the introduction of errors or unintended side effects as a result of modifying the code base of your application. With regression testing, all test cases are rerun so that no new bugs are introduced.</li>
</ul>
<p>Next, we will explore one of the leading testing frameworks you can confidently work with when testing the functionality of your frontend applications.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor146"/>Introducing Jest</h1>
<p><strong class="bold">Jest</strong> is an open source, robust, well-documented, fast, and safe<a id="_idIndexMarker406"/> JavaScript testing framework. Jest provides the tools and resources that you need to have absolute confidence in your JavaScript code base. Testing is fundamental to quality code writing, and Jest with almost zero configuration delightfully handles test implementation.</p>
<p>Jest is very popular in the JavaScript community. You can write tests in Jest leveraging its feature-rich set of APIs, such as matchers, mocked functions, code coverage, and snapshot testing. Jest can be used to test React components, and the React team actually recommends Jest to test React projects.</p>
<p>Jest is a Node.js test runner, which means that the tests always run in a Node environment. Jest is built with performance in mind. You can run a suite of tests in parallel effectively. The Jest toolkit comes with code coverage that enables you to have information about tested and untested files in your project. And when your tests fail, you are provided with insightful information about why they failed.</p>
<p>Let’s set up a Jest environment for testing.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor147"/>Setting up the Jest environment</h2>
<p>Node.js is required<a id="_idIndexMarker407"/> for Jest to run. Jest comes with the <code>npx create-react-app</code> command we used to the <code>create-react-app</code> boilerplate code in <a href="B18554_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started </em><em class="italic">with React</em>.</p>
<p>In this section, we will create a new working folder named <code>bizza-test</code> to better explore how Jest works with JavaScript<a id="_idIndexMarker408"/> functions, before we move on to using it in the unit testing of React components:</p>
<ol>
<li>Inside <code>path/to/bizza-test/</code>, let’s execute the following commands in the terminal:<ol><li class="upper-roman">Run <code>npm init -y</code> in the command terminal.</li>
<li class="upper-roman">Install Jest as a dependency in the working folder (<code>bizza-test</code>) with <code>npm install --</code><code>save-dev jest</code>.</li>
</ol></li>
<li>Update the <code>package.json</code> to be able to run Jest via <code>npm test</code>:<pre class="source-code">"scripts": {              "test": "jest"}</pre><p class="list-inset">The complete <code>package.json</code> should look like this:</p><pre class="source-code">{  "name": "bizza-test",  "version": "1.0.0",  "description": "",  "main": "index.js",  "scripts": {    "test": "jest"  },  "keywords": [],  "author": "",  "license": "ISC",  "devDependencies": {    "jest": "^29.2.1"  }}</pre></li>
</ol>
<p>The following is a screenshot showing the installation of Jest in the terminal.</p>
<div><div><img alt="Figure 7.1 – A screenshot of the Jest library setup" src="img/Figure_7.1_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A screenshot of the Jest library setup</p>
<p>With this set, you are on the right path<a id="_idIndexMarker409"/> to run your test. Next, we will explore some key testing terminologies and write the actual tests.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor148"/>Writing tests in Jest</h2>
<p>Now that we have<a id="_idIndexMarker410"/> set up the test<a id="_idIndexMarker411"/> running environment, let’s briefly understand some of the keywords we will encounter in this section. In Jest, you have some test keywords and functions from the Jest API to structure your tests; let’s examine them:</p>
<ul>
<li><code>test()</code> or <code>it()</code>: This is a descriptive unit test or test case. It contains three parameters – a descriptive test case string, a function that contains the expectations to test, and an optional timeout argument, specifying how long to wait before aborting a test case. The default timeout is five seconds:<pre class="source-code">test(name, fn, timeout)test("&lt;test case name&gt;", ()=&gt;{              ...    })</pre></li>
<li><code>describe()</code>: This groups related test cases together. It is used to group several related tests and describe their behaviors. <code>describe()</code> takes two parameters – a string describing your test group and a callback function that holds test cases:<pre class="source-code">describe(name, fn)describe("&lt;your test group name&gt;", ()=&gt;{    test("&lt;test case name&gt;",()=&gt;{      ...    });    ...    test("&lt;test case name&gt;",()=&gt;{      ...    });})</pre></li>
<li><code>beforeAll()</code>: This function is run before any of the tests in the test file run. And when you have a promise or generator returned from a function, Jest waits for that promise to resolve before running tests:<pre class="source-code">beforeAll(fn, timeout)</pre></li>
<li><code>beforeEach()</code>: This function runs before each of the tests in the test file runs. When you have a promise or generator returned from a function, Jest waits for that promise to resolve before running tests as well.</li>
<li><code>expect()</code>: In writing a test, you will need to check that a value meets certain conditions at the very least. <code>expect()</code> allows you to conditionally check a value with the help of matchers, which we will talk about in a little while. It is noteworthy that there are situations whereby a single test case could have multiple <code>expect()</code> functions:<pre class="source-code">test("&lt;test case name&gt;",()=&gt;{    ...    expect(value);    ...})</pre></li>
<li><code>Matchers</code>: Jest uses matchers to test value validation. A matcher lets you test values in different ways to make the right assertion.</li>
<li><code>Assertion</code>: An assertion is defined as an expression that contains testable logic to verify assumptions made by programmers about a specific piece of code. This allows you to identify errors and other defects in your application.</li>
</ul>
<p>So, with all these functions<a id="_idIndexMarker412"/> and terms <a id="_idIndexMarker413"/>well defined, let’s write our first test suite:</p>
<ol>
<li>Inside the <code>bizza-test</code> working directory, create a <code>__tests__</code> folder. Jest searches your working directory for <code>__tests__</code> or a test suite file ending with <code>.test.js</code> or <code>.spec.js</code>, and then it runs the file or all the files in the <code>__tests__</code> folder. The <code>__tests__</code>, <code>.test.js</code>, and <code>.spec.js</code> trio are test naming conventions.<p class="list-inset">To name the test directory in this book, we will adopt the naming convention <code>__tests__</code> case; create a <code>__tests__</code> directory inside <code>path/to/bizza-test/</code>. This is the folder<a id="_idIndexMarker414"/> we will keep the testing<a id="_idIndexMarker415"/> files in.</p></li>
<li>Now, create <code>basicFunctions.js</code> inside the <code>bizza-test</code> directory and add the following snippet to <code>basicFunctions.js</code>:<pre class="source-code">const basicFunctions = {    multiply:(number1, number2) =&gt; number1 * number2}Module.exports = basicFunctions;</pre><p class="list-inset">This snippet depicts a small JS function that multiplies two numbers together.</p></li>
<li>Inside <code>__tests__</code>, create a test suite file, <code>basicFunctions.test.js</code>, and paste the following code snippet:<pre class="source-code">const basicFunctions = require ('../basicFunctions');test ('Multiply 9 * 5 to equal 45', () =&gt; {    expect (basicFunctions.multiply(9, 5)).toBe(45);});</pre><p class="list-inset">Let’s briefly explain the working of the preceding test file code:</p><ul><li>The first line imports the <code>basicFunctions.js</code> module we want to test into scope.</li>
<li><code>Test()</code> sets the test case description with its function to verify that the multiplication of <code>9</code> and <code>5</code> equals <code>45</code>.</li>
<li><code>toBe(45)</code> lets us know we expect to have <code>45</code> as the expected result. If it’s anything else, the test will fail.</li>
<li>Then, inside the Terminal, run the <code>npm </code><code>test</code> command.</li>
</ul><p class="list-inset">The following screenshot shows the output after running the <code>npm </code><code>test</code> command:</p></li>
</ol>
<div><div><img alt="Figure 7.2 – Showing the screenshot for the test case output" src="img/Figure_7.2_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Showing the screenshot for the test case output</p>
<p class="list-inset">The preceding demonstrates<a id="_idIndexMarker416"/> how testing works<a id="_idIndexMarker417"/> in Jest.</p>
<p>Now, with these solid fundamentals on how we test simple JS functions, let’s dive into unit-testing React components.</p>
<p class="callout-heading">Note</p>
<p class="callout">A list of Jest’s useful functions<a id="_idIndexMarker418"/> can be found here: <a href="https://jestjs.io/docs/api">https://jestjs.io/docs/api</a>.</p>
<p class="callout">A list of commonly<a id="_idIndexMarker419"/> used matchers can also be found at <a href="https://jestjs.io/docs/expect">https://jestjs.io/docs/expect</a>.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor149"/>Unit-testing React components</h1>
<p>React is hinged on the component-driven development<a id="_idIndexMarker420"/> philosophy, and testing<a id="_idIndexMarker421"/> a unit of a React component further takes us closer to the basic elements that make up a React component. The essence of unit testing is to test an individual chunk of code to ascertain that the functionality works as expected by the users.</p>
<p>As stated earlier, in unit testing, you systematically go through three stages – planning, case scripting, and testing. Writing a unit test should be thoroughly planned, descriptive test cases should be implemented, and assertions should be clear enough to be understood by everyone on the team.</p>
<p>However, before we delve into unit-testing a React component, how do we know what to test in a React application? It is simple. Every React application has one or more components with specific functions. So, what to test in a React application is subjective. Every project is different and so is the functionality of the applications. The application features to test in an e-commerce web application will be different from features of interest to test in a social media application.</p>
<p>However, there are general rules of thumb for selecting features to test. In application development, testing provides us with confidence and assurance that our software product still works as expected, even with code refactoring. It then boils down basically to the business values of those functions, in addition to those functionalities that significantly impact the end user experience with your application.</p>
<p>To test React components, there<a id="_idIndexMarker422"/> is another simple, useful testing tool called RTL. RTL can be used along with Jest to achieve React components testing objectives. RTL lets you test your component units just as a real user of your application would interact with your application UI.</p>
<p>Whereas Jest is a test runner to find tests in a testing environment, run the tests, and affirm whether the tests fail or pass, RTL provides utility functions on top of VDOM. You will come across methods such as <code>render()</code> to simulate the rendering of components, <code>fireEvent</code> to dispatch a desired event as if a user interacts with the browser, and a screen to query the rendered elements.</p>
<p>RTL also uses the <code>waitFor()</code> method to wait for asynchronous codes and <code>expect()</code>, which is a function used for making assertions, determining whether the expected outcomes match the actual outcomes, and indicating success or failure.With a React project set up using <code>npx create-react-app</code>, you don’t have to explicitly install RTL. In a real-world application development environment, you would want to test that your components work as expected. RTL facilitates a simulation of how users would interact with your component.</p>
<p>This is achievable with the in-built utility in RTL<a id="_idIndexMarker423"/> that allows you to write tests that interact with DOM<a id="_idIndexMarker424"/> nodes directly, without actually rendering React components. Shortly, we will dive into the implementation of how RTL closely mimics how humans can interact with a React application UI in both stateless and stateful components.</p>
<p>Let’s start by writing a simple unit test to check whether a component renders.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor150"/>Writing a unit test for a stateless component</h2>
<p>For testing purposes, let’s create<a id="_idIndexMarker425"/> a fresh React test project with <code>npx create-react-app bizzatest</code>. Delete some of the boilerplate files and let the directory structure appear as follows:</p>
<pre class="source-code">    /bizzatest        /.git
        /node_modules
        /public
        /src
        /App.js
        /index.js
        /setupTests.js
          .gitignore
            package.json
        package-lock.json
        README.md</pre>
<p>The <code>App.js</code> file should contain the following code:</p>
<pre class="source-code">function App() {    return (
        &lt;div&gt;
            &lt;h1&gt;Bizza Tests&lt;/h1&gt;
        &lt;/div&gt;
    );
}export default App;</pre>
<p>The <code>Index.js</code> file should contain<a id="_idIndexMarker426"/> the following code:</p>
<pre class="source-code">import React from 'react';import ReactDOM from 'react-dom/client';
import App from './App';
const root =
    ReactDOM.createRoot(document.getElementById('root'));
root.render(
    &lt;React.StrictMode&gt;
        &lt;App /&gt;
    &lt;/React.StrictMode&gt;
);</pre>
<p>Now that we have the testing environment set up, let’s create a stateless component and write a unit test to check whether <code>WelcomeScreen.js</code> renders the <code>WelcomeScreen.js</code> will render the intended text paragraph.</p>
<p>Follow the proceeding<a id="_idIndexMarker427"/> steps to create the component, and unit-test it for the presence of the specified paragraph text.</p>
<h3>Creating a WelcomeScreen.jsx component</h3>
<p>Let’s create a <code>src/WelcomeScreen.jsx</code> component<a id="_idIndexMarker428"/> and add the proceeding code snippet. This component displays the <code>&lt;</code><code>h1&gt;React&lt;/h1&gt;</code> element:</p>
<pre class="source-code">import React from "react";const WelcomeScreen = () =&gt; {
    return  &lt;h1&gt;React&lt;/h1&gt;
};
export default WelcomeScreen;</pre>
<h3>Creating a test case file</h3>
<p>Inside the <code>src/__tests__</code> folder, create a test case file<a id="_idIndexMarker429"/> and name it <code>WelcomeScreen.test.js</code>. Use it to store all your test cases. You can also write your test in each of your component’s folders. However, in this case, we will store it inside the <code>src/__tests__</code> folder. Add the following code snippet:</p>
<pre class="source-code">import {render,screen,cleanup} from    "@testing-library/react";
import WelcomeScreen from "../WelcomeScreen";
afterEach(() =&gt; {
    return cleanup();
});
test("should show Welcome text to screen", () =&gt; {
    render(&lt;WelcomeScreen /&gt;);
    const showText = screen.getByText(/Welcome to Bizza
        Conference Platform/i);
    expect(showText).toBeInTheDocument();
});</pre>
<p>Let’s briefly discuss what is happening in the preceding snippet.</p>
<ul>
<li>The <code>render</code>, <code>screen</code>, and <code>cleanup</code> utilities are imported from <code>@testing-library/react</code>. <code>render</code> helps you to virtually render a component in a container that is appended to the body of the HTML document (DOM).<p class="list-inset">The <code>screen</code> object from RTL provides you with methods to find the rendered DOM elements to make the necessary assertions. Essentially, <code>screen</code> is used to interact with rendered components, and the <code>cleanup</code> function is used to clean up the rendered component after each test.</p></li>
<li>The <code>WelcomeScreen</code> component is imported<a id="_idIndexMarker430"/> as a required file for the test. This is the component to be tested.</li>
<li>The <code>afterEach()</code> method is added to unmount every rendered component test before the next component is rendered to prevent memory leaks. The <code>afterEach()</code> block is a Jest life cycle method that runs after each test. In this case, it calls the <code>cleanup</code> function to clean up any rendered components after each test. Using this cleanup utility from TRL is regarded as a best practice in React component testing.</li>
<li>The <code>test()</code> function defines the actual test, named <code>"should show Welcome text to screen"</code>, and a callback function to hold the test case. The test first calls the <code>render</code> function to render the <code>WelcomeScreen</code> component. Then, it uses the <code>screen.getByText</code> function to get the DOM element that contains the text <code>expect()</code> function is then used to verify that the text is in the document, using the <code>toBeInTheDocument</code> matcher.</li>
<li>When the <code>WelcomeScreen</code> component is rendered, we expect it to contain <strong class="bold">Welcome to Bizza </strong><strong class="bold">Conference Platform</strong>.</li>
</ul>
<p>Now, run the test with <code>npm test</code>.</p>
<p>The following screenshot shows the output:</p>
<div><div><img alt="Figure 7.3 – A screenshot showing failed test case output" src="img/Figure_7.3_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – A screenshot showing failed test case output</p>
<p>As expected, the test failed. The paragraph<a id="_idIndexMarker431"/> text in the RTL-simulated rendered container in <code>WelcomeScreen.jsx</code> is <code>&lt;h1&gt;React&lt;/h1&gt;</code> and not <code>&lt;h1&gt;Welcome to Bizza </code><code>Conference Platform&lt;/h1&gt;</code>.</p>
<h3>Updating the WelcomeScreen component</h3>
<p>Let’s now update <code>WelcomeScreen.jsx</code> with the expected text<a id="_idIndexMarker432"/> to be rendered on the screen:</p>
<pre class="source-code">import React from "react";const WelcomeScreen = () =&gt; {
    return &lt;h1&gt;Welcome to Bizza Conference Platform&lt;/h1&gt;
};
export default WelcomeScreen;</pre>
<p>Awesome, the test passed! The updated test report now shows a passed test:</p>
<div><div><img alt="Figure 7.4 – A screenshot showing a passed test case output" src="img/Figure_7.4_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – A screenshot showing a passed test case output</p>
<p>You can write unit tests for the elements<a id="_idIndexMarker433"/> of your various components and use the appropriate queries from RTL. These RTL queries allow you to find elements in the same way that users of your application will interact with your UI:</p>
<ul>
<li><code>getByRole()</code>: This function is used to locate an element by its role attribute, such as button, link, checkbox, radio, and heading. The <code>getByRole()</code> function is useful for testing the accessibility of a component, as well as for general testing purposes.</li>
<li><code>getByLabelText()</code>: This function is used to locate a form element that is associated with a label element using the <code>for</code> attribute. <code>getByLabelText()</code> is useful for testing form components and their accessibility.</li>
<li><code>getByPlaceholderText()</code>: This function is used to locate an input element by its placeholder attribute. <code>getByPlaceholderText()</code> is useful for testing input fields and their behavior.</li>
<li><code>getByText()</code>: This function is used to locate an element by its text content. <code>getByText()</code> is useful for testing the rendering of specific text or locating buttons or links that are identified by their text.</li>
<li><code>getByDisplayValue()</code>: This function is used to locate a form element by its displayed value, such as an input or select element that has a pre-filled value. <code>getByDisplayValue()</code> is useful for testing form components and their behavior.</li>
<li><code>getByAltText()</code>: This function is used to locate an image element by its <code>alt</code> attribute, which provides a textual description of the image. <code>getByAltText()</code> is useful for testing the accessibility of images in a component.</li>
<li><code>getByTitle()</code>: This function is used to locate an element by its <code>title</code> attribute. The <code>getByTitle()</code> is useful for testing the accessibility and behavior of elements that have a <code>title</code> attribute.</li>
<li><code>getByTestId()</code>: This function is used to locate an element by its <code>data-testid</code> attribute. <code>getByTestId()</code> is useful for testing specific elements that are identified by a unique test ID, without relying<a id="_idIndexMarker434"/> on other attributes such as class or ID.</li>
</ul>
<p>Let’s now examine how you can write a unit test for a stateful component. We will make use of a speaker card and test its units to our satisfaction.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor151"/>Writing a unit test for a stateful component</h2>
<p>In the <code>components</code> folder, create a stateful<a id="_idIndexMarker435"/> component<a id="_idIndexMarker436"/> named <code>SpeakerCard</code>. The <code>SpeakerCard</code> component is a functional component that renders a card with information about a speaker. The component takes a <code>speaker</code> object as a prop, which contains properties such as the speaker’s name, occupation, company, phone number, and email address.</p>
<p>Now, the following snippet shows the test snippet for the <code>SpeakerCard</code> component:</p>
<pre class="source-code">import {useState} from 'react'const SpeakerCard=speaker=&gt;{
const {name, occupation, company, phone, email}= speaker;
const [showDetails, setShowDetails]= useState(false);
const toggleDetails = () =&gt; setShowDetails(!showDetails);
return(
&lt;div className="card" data-testid="card"&gt;
&lt;span&gt;&lt;h2&gt;Name:{name}&lt;/h2&gt;&lt;/span&gt;
&lt;span&gt;&lt;h2&gt;Occupation:{occupation}&lt;/h2&gt;&lt;/span&gt;
&lt;span&gt;&lt;h2&gt;Company:{company}&lt;/h2&gt;&lt;/span&gt;
&lt;button data-testid="toggle-test" onClick={toggleDetails}&gt;
{showDetails? "Hide Details":"Show Details"}
&lt;/button&gt;
{showDetails &amp;&amp; (&lt;div data-testid="test-details"&gt;
&lt;h2&gt;Email:{email}&lt;/h2&gt;
&lt;h2&gt;Phone:{phone}&lt;/h2&gt;
&lt;/div&gt;
)}
&lt;/div&gt;
)
}
export default SpeakerCard;</pre>
<p>The preceding<a id="_idIndexMarker437"/> code snippet presented<a id="_idIndexMarker438"/> is explained here:</p>
<ul>
<li>The component takes a <code>speaker</code> object as a prop, which contains properties such as the speaker’s <code>name</code>, <code>occupation</code>, <code>company</code>, <code>phone number</code>, and <code>email address</code>.</li>
<li>The component uses the <code>useState</code> hook to manage a Boolean state variable called <code>showDetails</code>, which controls whether additional details about the speaker are shown or hidden. The <code>toggleDetails</code> function toggles the value of the <code>showDetails</code> variable when the toggle button is clicked.<p class="list-inset">If the <code>showDetails</code> variable is <code>true</code>, the component renders additional details about the speaker, including their email and phone number, within a nested <code>div</code> element with a <code>data-testid</code> attribute of <code>test-details</code>.</p></li>
<li>The <code>toggleDetails()</code> function’s initial state is <code>false</code>; when the toggle button is clicked, the state changes to <code>true</code>. The <code>data-testid</code> attribute in <code>&lt;div data-testid="card"&gt;</code> is used to identify the DOM node that you test. The <code>data-testid</code> attribute has <code>card</code> as its value. This value allows <code>expect()</code>, a Jest utility, to make assertions about whether the test fails or passes.</li>
<li>With the toggle button, we set the <code>data-testid</code> attribute to <code>toggle-test</code> to assert that no button has been clicked yet.</li>
<li>The <code>data-testid="test-details"</code> is used to assert that the toggle button is clicked and details are displayed on the screen.</li>
<li>Conditionally, when <code>showDetails</code> is set to <code>true</code>, email and phone details are displayed on the screen; otherwise, they would be hidden.</li>
</ul>
<p>Now, let’s write the unit test to show that <code>&lt;SpeakerCard/&gt;</code> can render on screen and when the toggle button is clicked, we can see more details about the <code>speaker</code> object.</p>
<p>Inside <code>/src/__tests__/</code>, create a test file, <code>SpeakerCard.test.js</code>:</p>
<pre class="source-code">import {render,screen, fireEvent,cleanup} from    "@testing-library/react";
import SpeakerCard from
    '../components/SpeakerCard/SpeakerCard'
const speaker= {
    name: "Olatunde Adedeji",
    occupation: "Software Engineer",
    company: "Mowebsite",
    email:"admin@admin.com",
    phone: "01-333333",
}
afterEach(() =&gt; {
    return cleanup();
});
test("should render the SpeakerCard component", ()=&gt;{
    render(&lt;SpeakerCard/&gt;);
    const card = screen.getByTestId("card");
    expect(card).toBeDefined()
});
test("should make sure the toggle button shows or hides
    details", ()=&gt;{
    render(&lt;SpeakerCard speaker={speaker}/&gt;);
    const toggleButton = screen.getByTestId("toggle-test");
    expect(screen.queryByTestId(
        "test-details")).toBeNull();
    fireEvent.click(toggleButton);
    expect(screen.getByTestId(
        "test-details")).toBeInTheDocument();
});</pre>
<p>Let’s go over<a id="_idIndexMarker439"/> the preceding code<a id="_idIndexMarker440"/> snippet:</p>
<ul>
<li><code>SpeakerCard</code> component.<ol><li class="upper-roman">Import <code>SpeakerCard.jsx</code> as a required file for the test.</li>
<li class="upper-roman">Define the <code>test()</code> function from the <code>@testing-library/react</code> library with a <code>test</code> string describing what the test should do, which in this test case is <code>"should render the SpeakerCard component"</code>, and a function that contains the test code.</li>
<li class="upper-roman">Then, import and use the <code>render</code> and <code>screen</code> utilities to simulate the rendering of the <code>&lt;</code><code>SpeakerCard/&gt;</code> component.</li>
<li class="upper-roman">The <code>SpeakerCard</code> component accepts the props defined <code>speaker</code> object.</li>
<li class="upper-roman">Query the node with <code>.getByTestId("card")</code> and assign its value to <code>card</code>. This allows you to access the DOM node needed to make an assertion. You can then use <code>expect()</code> from the Jest utility to ascertain that <code>&lt;SpeakerCard/&gt;</code> is rendered. Expect it to be defined!</li>
</ol><p class="list-inset">The following screenshot shows a passed test for the rendering React component:</p></li>
</ul>
<div><div><img alt="Figure 7.5 – A screenshot showing a passed rendering component test" src="img/Figure_7.5_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – A screenshot showing a passed rendering component test</p>
<ul>
<li><code>test()</code>function from the <code>@testing-library/react</code> library with a <code>test</code> string describing what the test should do, which in this test case is <code>"should make sure the toggle button shows or hides details"</code>, and a function that contains the test code.</li>
<li class="upper-roman">Render the <code>SpeakerCard</code> component.</li>
<li class="upper-roman">When no button is clicked, we expect the <code>data-testid</code> attribute value <code>toggle-test</code> to be <em class="italic">n</em>. The first assertion checks that the details section is not initially displayed, by checking that the element with <code>test-details data-testid</code> is not in the document. This is done using the <code>screen.queryByTestId()</code> function, which returns <code>null</code> if the element is not found.</li>
<li class="upper-roman">Then, import and use the <code>fireEvent</code> function. The <code>fireEvent.click(toggleButton)</code> simulates a user clicking on a toggle button in the <code>SpeakerCard</code> component. The <code>fireEvent</code> utility is a part of the <code>@testing-library/react</code> package, which provides a way of simulating user interactions in a test environment. The <code>fireEvent.click()</code> function is used to simulate a click on the toggle button. This will trigger the <code>toggleDetails</code> function in the component, which should show or hide the details section based on the <code>showDetails</code> state.</li>
<li class="upper-roman">Query the node with <code>getByTestId</code> and assign its value to <code>toggleButton</code>. The <code>data-testid</code> attribute in the <code>SpeakerCard</code> component checks whether the details are displayed or not by searching for the <code>test-details</code> element using <code>screen.getByTestId</code>.</li>
<li class="upper-roman">We expect <code>test-details</code> from <code>data-testid</code> to display on the screen. If <code>test-details</code> is present in the document, the test passes; otherwise, the test fails.</li>
</ol><p class="list-inset">The following screenshot<a id="_idIndexMarker443"/> shows the testing of the toggle<a id="_idIndexMarker444"/> button:</p></li>
</ul>
<div><div><img alt="Figure 7.6 – Screenshot showing the passed toggle button test" src="img/Figure_7.6_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Screenshot showing the passed toggle button test</p>
<p>Next, we will discuss TDD. This is a software development practice that encourages the testing of every functional unit of an application first before coding it.</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor152"/>TDD</h1>
<p>TDD is a development paradigm<a id="_idIndexMarker445"/> that puts writing tests first. You write the test first and then write code to validate. The main purpose of TDD is rapid feedback. You write a test, run it, and it fails. You then write minimal code to pass the test. Once the test passes, you then refactor your code appropriately.</p>
<p>These processes are iteratively repeated. Focusing on writing tests before code implementation allows developers to see the product from the users’ point of view, thus ensuring a working functionality that meets the users’ needs.</p>
<p>TDD enables software developers to come up with units of code base with a single responsibility – allowing code to do just one thing that works properly. However, the traditional approach is to code and then test. The idea of testing a code base at the end of the development process has been proven to be flawed and comes with a high cost of code maintenance.</p>
<p>Most software developers are more agile than test-driven. The urgent need to get a product to market with often unrealistic deadlines places less priority on the quality of the units of code powering such software products. With the traditional approach to development, you have errors sneaking into production.</p>
<p>As we all know, web applications in production do have additional features added from time to time based on business demands. However, without quality tests, you can have a situation where new feature addition or fixes create more problems.</p>
<p>Another problem with the traditional approach is having a software development team for a product different from the testing team. This separation of teams can make the long-time maintenance of the code base difficult and may result in a terrible decline in code quality, owing to a chaotic clash of intents.</p>
<p>With TDD, you and other stakeholders have proof that your code does work and is of high quality. Right now, we will wear the hat and shoes of a web developer who is agile and simultaneously test-driven. We will examine a case study where we build a login component as part of our <em class="italic">Bizza</em> project using a TDD methodology.</p>
<p>The component development will comply with a TDD principle:</p>
<ol>
<li>Write a single test case. This test will be expected to fail.</li>
<li>Write minimal code that satisfies the test and makes it pass.</li>
<li>Then, refactor your code and run it to pass/fail.</li>
</ol>
<p>These steps are repeated.</p>
<p>So, now let’s write our initial tests. We expect them to fail anyway. This is the essence of TDD.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor153"/>Writing a single test case</h2>
<p>In the <code>bizzatest</code> directory<a id="_idIndexMarker446"/> for testing, create the <code>bizzatest/src/components/Auth/SignInForm/SignInForm.jsx</code> component and update the file as follows. This is a <code>SignInForm</code> component with no labels and functionalities:</p>
<pre class="source-code">import React from 'react';const SignInForm = () =&gt; {
    return (
        &lt;div className="signInContainer"&gt;
            &lt;form&gt;
                &lt;div className="signInForm"&gt;
                    &lt;label htmlFor="email"&gt;&lt;/label&gt;
                    &lt;input
                        type="email"
                    /&gt;
                    &lt;label htmlFor="password"&gt;&lt;/label&gt;
                    &lt;input
                        type="password"
                    /&gt;
                    &lt;button&gt;&lt;/button&gt;
                &lt;/div&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    );
};
export default SignInForm;</pre>
<p>Inside <code>App.js</code>, add the following<a id="_idIndexMarker447"/> code snippet:</p>
<pre class="source-code">import React from "react";import "./App.css";
import SignInForm from
    "./pages/Auth/SignInForm/SignInForm";
const App = () =&gt; {
    return &lt;SignInForm /&gt;;
};
export default App;</pre>
<p>Then, run <code>npm s</code> to render the following component:</p>
<div><div><img alt="Figure 7.7 – A screenshot showing a rendered SignInForm component" src="img/Figure_7.7_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – A screenshot showing a rendered SignInForm component</p>
<p>In TDD, you want to start with a unit test<a id="_idIndexMarker448"/> of a component that will fail, and then work around to make it pass after the actual development of the component features.</p>
<p class="callout-heading">Note</p>
<p class="callout">Check the <em class="italic">Technical requirements</em> section for this chapter to get the styles for this form component (<a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07/05">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07/05</a>).</p>
<p>Now, let’s write and run the test for the <code>SignInForm</code> component.</p>
<p>Create the <code>test</code> file inside <code>bizzatest/src/__tests__/ SignInForm.test.js</code>.</p>
<p>Update the file as follows:</p>
<pre class="source-code">import { render, screen,cleanup } from    '@testing-library/react';
import  SignInForm from
    '../components/Auth/SignInForm/SignInForm';
afterEach(() =&gt; {
    return cleanup();
  });
test("Email Address should be rendered to screen", () =&gt; {
    render(&lt;SignInForm /&gt;);
    const linkElEmailInput =
        screen.getByText(/Email Address/i);
    expect(linkElEmailInput).toBeInTheDocument();
});
test("Password should be rendered to screen", () =&gt; {
    render(&lt;SignInForm /&gt;);
    const linkElPasswordInput =
        screen.getByText(/Password/i);
    expect(linkElPasswordInput).toBeInTheDocument();  });
test("Sign In should be rendered to screen", () =&gt; {
    render(&lt;SignInForm /&gt;);
    const linkElSignInBtn = screen.getByTest(/SignIn/i);
    expect(linkElSignInBtn).toBeInTheDocument();
});</pre>
<p>Let’s explain the workings of the preceding snippet:</p>
<p><code>Import { render, screen } from '@testing-library/react'</code> brings to scope the <code>render</code> and <code>screen</code> functions in RTL. This allows us to render components with VDOM<a id="_idIndexMarker449"/> in the testing environment.</p>
<p>The required <code>SignInForm</code> component file under test is then imported.</p>
<p><code>test("Email Address should be rendered to screen", () =&gt; {render(&lt;SignInForm /&gt;)</code> defines a test case with a description and renders <code>SignInForm-component</code>. The <code>render()</code> method comes from the RTL. The same thing is repeated for the <code>Password</code> and <code>Sign In</code> buttons with the individual test case descriptions.</p>
<p>In the first test, the test checks that the <code>Email Address</code> label is rendered on the screen by using the <code>getByText()</code> method from <code>@testing-library/react</code>. The test passes if the label is found on the screen.</p>
<p>In the second test, the test<a id="_idIndexMarker450"/> checks that the <code>Password</code> label is rendered on the screen by using the <code>getByText()</code> method. The test passes if the label is found on the screen.</p>
<p>The third test checks that the button with the text <code>SignIn</code> is rendered on the screen by using the <code>getByTestId()</code> method. The test passes if the button is found on the screen.</p>
<p><code>expect(linkElEmailInput).toBeInTheDocument()</code> is for the assertion. This is to verify that the values of the declared variables are present in the <code>SignInForm</code> component.</p>
<p>Now, in the Terminal, run the <code>npm test</code> command. The test case descriptions are shown here with failed statuses.</p>
<div><div><img alt="Figure 7.8 – A screenshot of a failed SignInForm test" src="img/Figure_7.8_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – A screenshot of a failed SignInForm test</p>
<p>The following screenshot shows a detailed report of the Jest test runner. It shows one test suite and three failed tests.</p>
<div><div><img alt="Figure 7.9 – A screenshot of the failed SignInForm component test" src="img/Figure_7.9_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – A screenshot of the failed SignInForm component test</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor154"/>Writing minimal code that satisfies the test and making it pass</h2>
<p>Now, update the <code>SignInForm</code> component to meet the expectations<a id="_idIndexMarker451"/> of the test cases in the test suite:</p>
<pre class="source-code">import React from 'react';const SignInForm = () =&gt; {
    return (
        &lt;&gt;
            &lt;div className="signInContainer"&gt;
                &lt;form&gt;
                    &lt;div className="signInForm"&gt;
                        &lt;label htmlFor="email"&gt;
                            Email Address&lt;/label&gt;
                        &lt;input
                            type="email"
                        /&gt;
                        &lt;label htmlFor="password"&gt;
                            Password&lt;/label&gt;
                        &lt;input
                            type="password"
                        /&gt;
                        &lt;button&gt;Sign In&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
};
export default SignInForm;</pre>
<p>In the preceding snippet, we refactored<a id="_idIndexMarker452"/> the code to pass the test as expected and complete the principle of TDD. The Jest test runner runs automatically and passes the test based on the refactoring of the <code>SignInForm</code> component.</p>
<p>In the following figure, we have the detailed Jest success report of our test-driven component development.</p>
<div><div><img alt="Figure 7.10 – A screenshot of a successful pass of the SignInForm component test" src="img/Figure_7.10_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – A screenshot of a successful pass of the SignInForm component test</p>
<p>The <code>SignInForm</code> component<a id="_idIndexMarker453"/> now appears, as shown in <em class="italic">Figure 7</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 7.11 – A screenshot of a rendered SignInForm component after passing the test" src="img/Figure_7.11_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – A screenshot of a rendered SignInForm component after passing the test</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor155"/>Code refactoring</h2>
<p><strong class="bold">Code refactoring</strong> is the process of modifying<a id="_idIndexMarker454"/> existing code<a id="_idIndexMarker455"/> to improve its quality, maintainability, and efficiency without changing its behavior. Code refactoring involves analyzing and improving the code structure, design, and implementation to make it easier to understand, modify, and maintain. Refactoring is typically done to improve code readability, remove code duplication, and increase performance.</p>
<p>During code refactoring, it is important to test your code to ensure that any changes made do not affect the behavior of the system. The code is run multiple times after each refactoring step to ensure that it still passes all the positive tests or fails all the negative tests.</p>
<p>If a test fails when you expect<a id="_idIndexMarker456"/> it to pass, that means that the refactoring<a id="_idIndexMarker457"/> step introduced a bug and the code needs to be reverted to its previous state, or additional changes need to be made to fix the issue. Refactoring can be done manually, but there are also automated tools such as Jest, RTL, Enzyme, and React testing utilities that can help identify areas of the code that need refactoring.</p>
<p>Refactoring as a part of TDD methodology allows you to refactor your code and run it to pass/fail until you are confident in the test results. These code refactoring steps can be repeated as many times as desired.</p>
<p>Let’s refactor <code>SignForm.test.js</code> and examine one of the ways you can refactor your test code.</p>
<p>Create the <code>test</code> file inside <code>bizzatest/src/__tests__/ RefactorSignInForm.test.js</code>:</p>
<p>Update the file as follows:</p>
<pre class="source-code">import { render, screen, cleanup } from    '@testing-library/react';
import SignInForm from
    '../components/Auth/SignInForm/SignInForm';
describe('SignInForm component', () =&gt; {
    afterEach(() =&gt; {
        cleanup();
    });
    it('should render the email address input', () =&gt; {
        render(&lt;SignInForm /&gt;);
        const emailInput =
            screen.getByLabelText(/Email Address/i);
        expect(emailInput).toBeInTheDocument();
    });
    it('should render the password input', () =&gt; {
        render(&lt;SignInForm /&gt;);
        const passwordInput =
            screen.getByLabelText(/Password/i);
        expect(passwordInput).toBeInTheDocument();
    });
    it('should render the sign in button', () =&gt; {
        render(&lt;SignInForm /&gt;);
        const signInButton =
            screen.getByRole('button', { name: /Sign In/i
            });
        expect(signInButton).toBeInTheDocument();
    });
});</pre>
<p>Here are some of the changes<a id="_idIndexMarker458"/> that were made<a id="_idIndexMarker459"/> in the refactored test code:</p>
<ul>
<li>The tests were wrapped in a <code>describe</code> block to group them under the same heading</li>
<li><code>test()</code> was replaced with <code>it()</code> for consistency</li>
<li>The text matching was changed from <code>getByText</code> to <code>getByLabelText</code> for the email and password inputs, as this is a more appropriate way to target form inputs</li>
<li>The <code>getByTest</code> query for the <code>Signin</code> button was replaced<a id="_idIndexMarker460"/> with <code>getByRole</code> and a name<a id="_idIndexMarker461"/> option</li>
</ul>
<h1 id="_idParaDest-125"><a id="_idTextAnchor156"/>Summary</h1>
<p>Testing is crucial to the successful deployment of an application product into production. In this chapter, we examined various testing types available, especially unit testing for code base quality and ease of maintainability. This ensures a lower cost of producing software with confidence.</p>
<p>We also explored Jest, a Node test runner that delightfully tests JavaScript code and, by extension, React applications. The Jest testing framework ensures that you work in an integrated testing environment, with virtually all your testing tools in one place and only a stone’s throw away.</p>
<p>We discussed RTL with its implementation and then, in depth, the unit testing of React components using Jest and RTL, which comes with the <strong class="bold">Create React App</strong> (<strong class="bold">CRA</strong>) boilerplate code.</p>
<p>We wrote useful component tests to showcase the ability of the combined tools of Jest and TLR. Finally, we discussed a testing methodology, TDD, in software development and how it can be used in React-based applications with examples.</p>
<p>Next, we will temporarily shift the focus of this book and delve into the backend development aspect of full stack web development, which is what this book is all about. We will begin a backend application in the next chapter, discussing SQL and data modeling.</p>
</div>


<div><h1 id="_idParaDest-126" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor157"/>Part 2 – Backend Development with Flask</h1>
<p>Welcome to <em class="italic">Part 2</em> of our book, where we will delve into the dynamics of backend development with Flask. In this section, we will explore the fundamental concepts and techniques used in modern web development using the Flask framework.</p>
<p>You will gain the knowledge and tools necessary to tackle the complexities of backend development. From setting up your Flask environment to designing efficient RESTful APIs, implementing database integration, and integrating React frontends with Flask, we will cover it all.</p>
<p>By the end of this part, you will have a solid grasp of Flask’s core concepts and be well on your way to becoming a proficient full stack web developer. Let’s embark on this exciting journey together! </p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B18554_08.xhtml#_idTextAnchor158"><em class="italic">Chapter 8</em></a>, <em class="italic">SQL and Data Modeling</em></li>
<li><a href="B18554_09.xhtml#_idTextAnchor186"><em class="italic">Chapter 9</em></a>, <em class="italic">API Development and Documentation</em></li>
<li><a href="B18554_10.xhtml#_idTextAnchor221"><em class="italic">Chapter 10</em></a>, <em class="italic">Integrating React Frontend with the Flask Backend</em></li>
<li><a href="B18554_11.xhtml#_idTextAnchor232"><em class="italic">Chapter 11</em></a>, <em class="italic">Fetching and Displaying Data in a React-Flask Application</em></li>
<li><a href="B18554_12.xhtml#_idTextAnchor252"><em class="italic">Chapter 12</em></a>, <em class="italic">Authentication and Authorization</em></li>
<li><a href="B18554_13.xhtml#_idTextAnchor273"><em class="italic">Chapter 13</em></a>, <em class="italic">Error Handling</em></li>
<li><a href="B18554_14.xhtml#_idTextAnchor285"><em class="italic">Chapter 14</em></a>, <em class="italic">Modular Architecture – The Power of Blueprints</em></li>
<li><a href="B18554_15.xhtml#_idTextAnchor298"><em class="italic">Chapter 15</em></a>, <em class="italic">Flask Unit Testing</em></li>
<li><a href="B18554_16.xhtml#_idTextAnchor328"><em class="italic">Chapter 16</em></a>, <em class="italic">Containerization and Flask Application Deployment</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>