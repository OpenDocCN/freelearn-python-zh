- en: Chapter 3. The Factory Pattern – Building Factories to Create Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about Singleton design patterns—what they
    are and how they are used in the real world along with the Python implementation.
    The Singleton design pattern is one of the Creational design patterns. In this
    chapter, we move ahead and learn about another creational pattern, the Factory
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory pattern is arguably the most used design pattern. In this chapter,
    we will understand the concept of Factory and go through the Simple Factory pattern.
    You will then learn about the Factory method pattern and Abstract Factory pattern
    with a UML diagram, real-world scenarios, and Python v3.5 implementations. We'll
    also compare the Factory method and Abstract Factory method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics in brief:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Simple Factory design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the Factory method and Abstract Factory method and their differences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing real-world scenarios with the Python code implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the advantages and disadvantages of the patterns and their comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented programming, the term factory means a class that is responsible
    for creating objects of other types. Typically, the class that acts as a factory
    has an object and methods associated with it. The client calls this method with
    certain parameters; objects of desired types are created in turn and returned
    to the client by the factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the question here really is, why do we need a factory when the client can
    directly create an object? The answer is, a factory provides certain advantages
    that are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The first advantage is loose coupling in which object creation can be independent
    of the class implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client need not be aware of the class that creates the object which, in
    turn, is utilized by the client. It is only necessary to know the interface, methods,
    and parameters that need to be passed to create objects of the desired type. This
    simplifies implementations for the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding another class to the factory to create objects of another type can be
    easily done without the client changing the code. At a minimum, the client needs
    to pass just another parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factory can also reuse the existing objects. However, when the client does
    direct object creation, this always creates a new object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider the situation of a manufacturing company that manufactures toys—cars
    or dolls. Let's say that a machine in the company is currently manufacturing toy
    cars. Then, the CEO of the company feels that there is an urgent need to manufacture
    dolls based on the demand in the market. This situation calls for the Factory
    pattern. In this case, the machine becomes the interface and the CEO is the client.
    The CEO is only bothered about the object (or the toy) to be manufactured and
    knows the interface—the machine—that can create the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three variants of the Factory pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Factory pattern**: This allows interfaces to create objects without
    exposing the object creation logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factory method pattern**: This allows interfaces to create objects, but defers
    the decision to the subclasses to determine the class for object creation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract Factory pattern**: An Abstract Factory is an interface to create
    related objects without specifying/exposing their classes. The pattern provides
    objects of another factory, which internally creates other objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Simple Factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Factory Method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following points help us understand the factory method pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: We define an interface to create objects, but instead of the factory being responsible
    for the object creation, the responsibility is deferred to the subclass that decides
    the class to be instantiated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory method creation is through inheritance and not through instantiation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory method makes the design more customizable. It can return the same
    instance or subclass rather than an object of a certain type (as in the simple
    factory method).![The Factory Method pattern](img/00011.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A UML diagram for the Factory method
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding UML diagram, we have an abstract class, `Creator`, that contains
    `factoryMethod()`. The `factoryMethod()` method has the responsibility of creating
    objects of a certain type. The `ConcreteCreator` class has `factoryMethod()` that
    implements the `Creator` abstract class, and this method can change the created
    object at runtime. `ConcreteCreator` creates `ConcreteProduct` and makes sure
    that the object it creates implements the `Product` class and provides implementation
    for all the methods in the `Product` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In brief, `factoryMethod()` of the `Creator` interface and the `ConcreteCreator`
    class decides which subclass of Product to create. Thus, the Factory method pattern
    defines an interface to create an object, but defers the decision ON which class
    to instantiate to its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Factory Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a real-world scenario to understand the Factory method implementation.
    Consider that we would like to create profiles of different types on social networks
    such as LinkedIn and Facebook for a person or company. Now, each of these profiles
    would have certain sections. In LinkedIn, you would have a section on patents
    that an individual has filed or publications s/he has written. On Facebook, you'll
    see sections in an album of pictures of your recent visit to a holiday place.
    Additionally, in both these profiles, there'd be a common section on personal
    information. So, in brief, we want to create profiles of different types with
    the right sections being added to the profile.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the implementation. In the following code example,
    we will start by defining the `Product` interface. We will create a `Section`
    abstract class that defines how a section will be. We will keep it very simple
    and provide an abstract method, `describe()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now create multiple `ConcreteProduct` classes, `PersonalSection`, `AlbumSection`,
    `PatentSection`, and `PublicationSection`. These classes implement the `describe()`
    abstract method and print their respective section names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We create a `Creator` abstract class that is named `Profile`. The `Profile [Creator]`
    abstract class provides a factory method, `createProfile()`. The `createProfile()`
    method should be implemented by `ConcreteClass` to actually create the profiles
    with appropriate sections. The `Profile` abstract class is not aware of the sections
    that each profile should have. For example, a Facebook profile should have personal
    information and album sections. So we will let the subclass decide this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two `ConcreteCreator` classes, `linkedin` and `facebook`. Each of
    these classes implement the `createProfile()` abstract method that actually creates
    (instantiates) multiple sections (`ConcreteProducts`) at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We finally write client code that determines which `Creator` class to instantiate
    in order to create a profile of the desired choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Advantages of the Factory method pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have now learned the Factory method pattern and how to implement Factory
    methods, let''s see the advantages of the Factory method pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: It brings in a lot of flexibility and makes the code generic, not being tied
    to a certain class for instantiation. This way, we're dependent on the interface
    (Product) and not on the `ConcreteProduct` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's loose coupling, as the code that creates the object is separate from
    the code that uses it. The client need not bother about what argument to pass
    and which class to instantiate. The addition of new classes is easy and involves
    low maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Abstract Factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main objective of the Abstract Factory pattern is to provide an interface
    to create families of related objects without specifying the concrete class. While
    the factory method defers the creation of the instance to the subclasses, the
    goal of Abstract Factory method is to create families of related objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Abstract Factory pattern](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A UML Diagram for the Abstract Factory pattern
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the diagram, `ConcreteFactory1` and `ConcreteFactory2` are created
    from the `AbstractFactory` interface. This interface has methods to create multiple
    products.
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcreteFactory1` and `ConcreteFactory2` implement AbstractFactory and create
    instances of `ConcreteProduct1`, `ConcreteProduct2`, `AnotherConcreteProduct1`,
    and `AnotherConcreteProduct2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcreteProduct1` and `ConcreteProduct2` are in turn created from the `AbstractProduct`
    interface, and `AnotherConcreteProduct1` and `AnotherConcreteProduct2` are created
    from the `AnotherAbstractProduct` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: In effect, Abstract Factory patterns make sure that the client is isolated from
    the creation of objects but allowed to use the objects created. The client has
    the ability to access objects only through an interface. If products of one family
    are to be used, Abstract Factory pattern helps the client use the objects from
    one/ family at a time. For example, if an application under development is supposed
    to be platform-independent, then it needs to abstract dependencies such as OS,
    file system calls, among others. Abstract Factory pattern takes care of creating
    the required services for the entire platform so that the client doesn't have
    to create platform objects directly.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Abstract Factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the case of your favorite pizza place. It serves multiple types of
    pizzas, right? Wait, hold on, I know you want to order one right away, but let's
    just get back to the example for now!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that we create a pizza store where you are served with delicious
    Indian and American pizzas. For this, we first create an abstract base class,
    `PizzaFactory` (`AbstractFactory` in the preceding UML diagram). The `PizzaFactory`
    class has two abstract methods, `createVegPizza()` and `createNonVegPizza()`,
    that need to be implemented by `ConcreteFactory`. In this example, we create two
    concrete factories, namely, `IndianPizzaFactory` and `USPizzaFactory`. Look at
    the following code implementation for the concrete factories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's move ahead and define `AbstractProducts`. In the following code,
    we create two abstract classes, `VegPizza` and `NonVegPizza` (`AbstractProduct`
    and `AnotherAbstractProduct` in the preceding UML diagram]. They individually
    have a method defined, `prepare()` and `serve()`.
  prefs: []
  type: TYPE_NORMAL
- en: The thought process here is that vegetarian pizzas are prepared with an appropriate
    crust, vegetables, and seasoning, and nonvegetarian pizzas are served with nonvegetarian
    toppings on top of vegetarian pizzas.
  prefs: []
  type: TYPE_NORMAL
- en: We then define `ConcreteProducts` for each of the `AbstractProducts`. Now, in
    this case, we create `DeluxVeggiePizza` and `MexicanVegPizza` and implement the
    `prepare()` method. `ConcreteProducts1` and `ConcreteProducts2` would represent
    these classes from the UML diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we define `ChickenPizza` and `HamPizza` and implement the `serve()`
    method—these represent `AnotherConcreteProducts1` and `AnotherConcreteProducts2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When an end user approaches `PizzaStore` and asks for an American nonvegetarian
    pizza, `USPizzaFactory` is responsible for preparing the vegetarian pizza as the
    base and serving the nonvegetarian pizza with ham on top!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the Abstract Factory pattern](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Factory method versus Abstract Factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have learned the Factory method and Abstract Factory method, let''s
    see the comparison of the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Factory method | Abstract Factory method |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| This exposes a method to the client to create the objects | Abstract Factory
    method contains one or more factory methods to create a family of related objects
    |'
  prefs: []
  type: TYPE_TB
- en: '| This uses inheritance and subclasses to decide which object to create | This
    uses composition to delegate responsibility to create objects of another class
    |'
  prefs: []
  type: TYPE_TB
- en: '| The factory method is used to create one product | Abstract Factory method
    is about creating families of related products |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the Factory design pattern and the context
    in which it's used. We understood the basics of the Factory, and how it is effectively
    used in software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at Simple Factory, where an appropriate instance is created at runtime
    based on the type of the argument passed by the client.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the Factory method pattern, which is a variation of Simple
    Factory. In this pattern, we defined an interface to create objects, but the creation
    of objects is deferred to the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: We went on to explore the Abstract Factory method, which provides an interface
    to create families of related objects without specifying the concrete class.
  prefs: []
  type: TYPE_NORMAL
- en: We also worked out a real-world Python implementation for all the three patterns,
    and compared the Factory method with Abstract Factory method.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we're now ready to take the next step and study
    other types of patterns, so stay tuned.
  prefs: []
  type: TYPE_NORMAL
