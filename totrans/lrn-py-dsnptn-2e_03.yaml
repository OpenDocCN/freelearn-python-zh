- en: Chapter 3. The Factory Pattern – Building Factories to Create Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about Singleton design patterns—what they
    are and how they are used in the real world along with the Python implementation.
    The Singleton design pattern is one of the Creational design patterns. In this
    chapter, we move ahead and learn about another creational pattern, the Factory
    pattern.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The Factory pattern is arguably the most used design pattern. In this chapter,
    we will understand the concept of Factory and go through the Simple Factory pattern.
    You will then learn about the Factory method pattern and Abstract Factory pattern
    with a UML diagram, real-world scenarios, and Python v3.5 implementations. We'll
    also compare the Factory method and Abstract Factory method.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics in brief:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Simple Factory design pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the Factory method and Abstract Factory method and their differences
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing real-world scenarios with the Python code implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the advantages and disadvantages of the patterns and their comparisons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Factory pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented programming, the term factory means a class that is responsible
    for creating objects of other types. Typically, the class that acts as a factory
    has an object and methods associated with it. The client calls this method with
    certain parameters; objects of desired types are created in turn and returned
    to the client by the factory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'So the question here really is, why do we need a factory when the client can
    directly create an object? The answer is, a factory provides certain advantages
    that are listed here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The first advantage is loose coupling in which object creation can be independent
    of the class implementation.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client need not be aware of the class that creates the object which, in
    turn, is utilized by the client. It is only necessary to know the interface, methods,
    and parameters that need to be passed to create objects of the desired type. This
    simplifies implementations for the client.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding another class to the factory to create objects of another type can be
    easily done without the client changing the code. At a minimum, the client needs
    to pass just another parameter.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factory can also reuse the existing objects. However, when the client does
    direct object creation, this always creates a new object.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider the situation of a manufacturing company that manufactures toys—cars
    or dolls. Let's say that a machine in the company is currently manufacturing toy
    cars. Then, the CEO of the company feels that there is an urgent need to manufacture
    dolls based on the demand in the market. This situation calls for the Factory
    pattern. In this case, the machine becomes the interface and the CEO is the client.
    The CEO is only bothered about the object (or the toy) to be manufactured and
    knows the interface—the machine—that can create the object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three variants of the Factory pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Factory pattern**: This allows interfaces to create objects without
    exposing the object creation logic.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factory method pattern**: This allows interfaces to create objects, but defers
    the decision to the subclasses to determine the class for object creation.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract Factory pattern**: An Abstract Factory is an interface to create
    related objects without specifying/exposing their classes. The pattern provides
    objects of another factory, which internally creates other objects.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Simple Factory pattern
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Factory Method pattern
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following points help us understand the factory method pattern:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: We define an interface to create objects, but instead of the factory being responsible
    for the object creation, the responsibility is deferred to the subclass that decides
    the class to be instantiated.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory method creation is through inheritance and not through instantiation.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory method makes the design more customizable. It can return the same
    instance or subclass rather than an object of a certain type (as in the simple
    factory method).![The Factory Method pattern](img/00011.jpeg)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A UML diagram for the Factory method
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding UML diagram, we have an abstract class, `Creator`, that contains
    `factoryMethod()`. The `factoryMethod()` method has the responsibility of creating
    objects of a certain type. The `ConcreteCreator` class has `factoryMethod()` that
    implements the `Creator` abstract class, and this method can change the created
    object at runtime. `ConcreteCreator` creates `ConcreteProduct` and makes sure
    that the object it creates implements the `Product` class and provides implementation
    for all the methods in the `Product` interface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In brief, `factoryMethod()` of the `Creator` interface and the `ConcreteCreator`
    class decides which subclass of Product to create. Thus, the Factory method pattern
    defines an interface to create an object, but defers the decision ON which class
    to instantiate to its subclasses.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Factory Method
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a real-world scenario to understand the Factory method implementation.
    Consider that we would like to create profiles of different types on social networks
    such as LinkedIn and Facebook for a person or company. Now, each of these profiles
    would have certain sections. In LinkedIn, you would have a section on patents
    that an individual has filed or publications s/he has written. On Facebook, you'll
    see sections in an album of pictures of your recent visit to a holiday place.
    Additionally, in both these profiles, there'd be a common section on personal
    information. So, in brief, we want to create profiles of different types with
    the right sections being added to the profile.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the implementation. In the following code example,
    we will start by defining the `Product` interface. We will create a `Section`
    abstract class that defines how a section will be. We will keep it very simple
    and provide an abstract method, `describe()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'We now create multiple `ConcreteProduct` classes, `PersonalSection`, `AlbumSection`,
    `PatentSection`, and `PublicationSection`. These classes implement the `describe()`
    abstract method and print their respective section names:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create a `Creator` abstract class that is named `Profile`. The `Profile [Creator]`
    abstract class provides a factory method, `createProfile()`. The `createProfile()`
    method should be implemented by `ConcreteClass` to actually create the profiles
    with appropriate sections. The `Profile` abstract class is not aware of the sections
    that each profile should have. For example, a Facebook profile should have personal
    information and album sections. So we will let the subclass decide this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two `ConcreteCreator` classes, `linkedin` and `facebook`. Each of
    these classes implement the `createProfile()` abstract method that actually creates
    (instantiates) multiple sections (`ConcreteProducts`) at runtime:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We finally write client code that determines which `Creator` class to instantiate
    in order to create a profile of the desired choice:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Advantages of the Factory method pattern
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have now learned the Factory method pattern and how to implement Factory
    methods, let''s see the advantages of the Factory method pattern:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: It brings in a lot of flexibility and makes the code generic, not being tied
    to a certain class for instantiation. This way, we're dependent on the interface
    (Product) and not on the `ConcreteProduct` class.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's loose coupling, as the code that creates the object is separate from
    the code that uses it. The client need not bother about what argument to pass
    and which class to instantiate. The addition of new classes is easy and involves
    low maintenance.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Abstract Factory pattern
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main objective of the Abstract Factory pattern is to provide an interface
    to create families of related objects without specifying the concrete class. While
    the factory method defers the creation of the instance to the subclasses, the
    goal of Abstract Factory method is to create families of related objects:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![The Abstract Factory pattern](img/00013.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: A UML Diagram for the Abstract Factory pattern
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the diagram, `ConcreteFactory1` and `ConcreteFactory2` are created
    from the `AbstractFactory` interface. This interface has methods to create multiple
    products.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcreteFactory1` and `ConcreteFactory2` implement AbstractFactory and create
    instances of `ConcreteProduct1`, `ConcreteProduct2`, `AnotherConcreteProduct1`,
    and `AnotherConcreteProduct2`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcreteProduct1` and `ConcreteProduct2` are in turn created from the `AbstractProduct`
    interface, and `AnotherConcreteProduct1` and `AnotherConcreteProduct2` are created
    from the `AnotherAbstractProduct` interface.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In effect, Abstract Factory patterns make sure that the client is isolated from
    the creation of objects but allowed to use the objects created. The client has
    the ability to access objects only through an interface. If products of one family
    are to be used, Abstract Factory pattern helps the client use the objects from
    one/ family at a time. For example, if an application under development is supposed
    to be platform-independent, then it needs to abstract dependencies such as OS,
    file system calls, among others. Abstract Factory pattern takes care of creating
    the required services for the entire platform so that the client doesn't have
    to create platform objects directly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Abstract Factory pattern
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the case of your favorite pizza place. It serves multiple types of
    pizzas, right? Wait, hold on, I know you want to order one right away, but let's
    just get back to the example for now!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that we create a pizza store where you are served with delicious
    Indian and American pizzas. For this, we first create an abstract base class,
    `PizzaFactory` (`AbstractFactory` in the preceding UML diagram). The `PizzaFactory`
    class has two abstract methods, `createVegPizza()` and `createNonVegPizza()`,
    that need to be implemented by `ConcreteFactory`. In this example, we create two
    concrete factories, namely, `IndianPizzaFactory` and `USPizzaFactory`. Look at
    the following code implementation for the concrete factories:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's move ahead and define `AbstractProducts`. In the following code,
    we create two abstract classes, `VegPizza` and `NonVegPizza` (`AbstractProduct`
    and `AnotherAbstractProduct` in the preceding UML diagram]. They individually
    have a method defined, `prepare()` and `serve()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The thought process here is that vegetarian pizzas are prepared with an appropriate
    crust, vegetables, and seasoning, and nonvegetarian pizzas are served with nonvegetarian
    toppings on top of vegetarian pizzas.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: We then define `ConcreteProducts` for each of the `AbstractProducts`. Now, in
    this case, we create `DeluxVeggiePizza` and `MexicanVegPizza` and implement the
    `prepare()` method. `ConcreteProducts1` and `ConcreteProducts2` would represent
    these classes from the UML diagram.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we define `ChickenPizza` and `HamPizza` and implement the `serve()`
    method—these represent `AnotherConcreteProducts1` and `AnotherConcreteProducts2`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When an end user approaches `PizzaStore` and asks for an American nonvegetarian
    pizza, `USPizzaFactory` is responsible for preparing the vegetarian pizza as the
    base and serving the nonvegetarian pizza with ham on top!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is the output of the preceding code example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the Abstract Factory pattern](img/00014.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: The Factory method versus Abstract Factory method
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have learned the Factory method and Abstract Factory method, let''s
    see the comparison of the two:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了工厂方法和抽象工厂方法，让我们看看这两种方法的比较：
- en: '| Factory method | Abstract Factory method |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 工厂方法 | 抽象工厂方法 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| This exposes a method to the client to create the objects | Abstract Factory
    method contains one or more factory methods to create a family of related objects
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 这向客户端公开了一个创建对象的方法 | 抽象工厂方法包含一个或多个工厂方法来创建一个相关对象系列 |'
- en: '| This uses inheritance and subclasses to decide which object to create | This
    uses composition to delegate responsibility to create objects of another class
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 这使用继承和子类来决定创建哪个对象 | 这使用组合来委托创建另一个类的对象的责任 |'
- en: '| The factory method is used to create one product | Abstract Factory method
    is about creating families of related products |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 工厂方法用于创建一个产品 | 抽象工厂方法关于创建相关产品系列 |'
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the Factory design pattern and the context
    in which it's used. We understood the basics of the Factory, and how it is effectively
    used in software architecture.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了工厂设计模式及其使用场景。我们了解了工厂的基本原理，以及它在软件架构中的有效应用。
- en: We looked at Simple Factory, where an appropriate instance is created at runtime
    based on the type of the argument passed by the client.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了简单工厂模式，其中根据客户端传递的参数类型在运行时创建一个适当的实例。
- en: We also discussed the Factory method pattern, which is a variation of Simple
    Factory. In this pattern, we defined an interface to create objects, but the creation
    of objects is deferred to the subclass.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了工厂方法模式，这是简单工厂模式的一种变体。在这个模式中，我们定义了一个接口来创建对象，但对象的创建被延迟到子类中。
- en: We went on to explore the Abstract Factory method, which provides an interface
    to create families of related objects without specifying the concrete class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续探索抽象工厂方法，它提供了一个创建相关对象系列的接口，而不指定具体的类。
- en: We also worked out a real-world Python implementation for all the three patterns,
    and compared the Factory method with Abstract Factory method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为所有三种模式实现了实际的Python实现，并比较了工厂方法和抽象工厂方法。
- en: At the end of this chapter, we're now ready to take the next step and study
    other types of patterns, so stay tuned.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们现在准备迈出下一步，研究其他类型的模式，所以请保持关注。
