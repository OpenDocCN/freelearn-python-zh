- en: Chapter 3. The Factory Pattern – Building Factories to Create Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：工厂模式——构建工厂以创建对象
- en: In the previous chapter, you learned about Singleton design patterns—what they
    are and how they are used in the real world along with the Python implementation.
    The Singleton design pattern is one of the Creational design patterns. In this
    chapter, we move ahead and learn about another creational pattern, the Factory
    pattern.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了单例设计模式——它们是什么以及如何在现实世界中使用，包括Python实现。单例设计模式是创建型设计模式之一。在本章中，我们将继续学习另一个创建型模式，即工厂模式。
- en: The Factory pattern is arguably the most used design pattern. In this chapter,
    we will understand the concept of Factory and go through the Simple Factory pattern.
    You will then learn about the Factory method pattern and Abstract Factory pattern
    with a UML diagram, real-world scenarios, and Python v3.5 implementations. We'll
    also compare the Factory method and Abstract Factory method.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式可以说是最常用的设计模式。在本章中，我们将了解工厂的概念，并学习简单工厂模式。然后，您将学习工厂方法模式和抽象工厂模式，包括UML图、现实世界场景和Python
    3.5实现。我们还将比较工厂方法和抽象工厂方法。
- en: 'In this chapter, we will cover the following topics in brief:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍以下内容：
- en: Understanding the Simple Factory design pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解简单工厂设计模式
- en: Discussing the Factory method and Abstract Factory method and their differences
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论工厂方法和抽象工厂方法及其区别
- en: Implementing real-world scenarios with the Python code implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python代码实现来模拟现实世界场景
- en: Discussing the advantages and disadvantages of the patterns and their comparisons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论模式的优缺点及其比较
- en: Understanding the Factory pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解工厂模式
- en: In object-oriented programming, the term factory means a class that is responsible
    for creating objects of other types. Typically, the class that acts as a factory
    has an object and methods associated with it. The client calls this method with
    certain parameters; objects of desired types are created in turn and returned
    to the client by the factory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，工厂这个术语指的是一个负责创建其他类型对象的类。通常，充当工厂的类有一个与之关联的对象和方法。客户端使用某些参数调用此方法；然后依次创建所需类型的对象，并由工厂返回给客户端。
- en: 'So the question here really is, why do we need a factory when the client can
    directly create an object? The answer is, a factory provides certain advantages
    that are listed here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里真正的问题是，当客户端可以直接创建对象时，我们为什么还需要工厂？答案是，工厂提供了一些优势，如下列所示：
- en: The first advantage is loose coupling in which object creation can be independent
    of the class implementation.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个优势是松散耦合，其中对象的创建可以独立于类实现。
- en: The client need not be aware of the class that creates the object which, in
    turn, is utilized by the client. It is only necessary to know the interface, methods,
    and parameters that need to be passed to create objects of the desired type. This
    simplifies implementations for the client.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端不需要知道创建对象的类，而该类反过来被客户端使用。只需知道接口、方法和需要传递的参数，以便创建所需类型的对象。这简化了客户端的实现。
- en: Adding another class to the factory to create objects of another type can be
    easily done without the client changing the code. At a minimum, the client needs
    to pass just another parameter.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向工厂添加另一个类以创建另一种类型的对象可以很容易地完成，而无需客户端更改代码。至少，客户端需要传递另一个参数。
- en: The factory can also reuse the existing objects. However, when the client does
    direct object creation, this always creates a new object.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂还可以重用现有对象。然而，当客户端直接创建对象时，这总是创建一个新的对象。
- en: Let's consider the situation of a manufacturing company that manufactures toys—cars
    or dolls. Let's say that a machine in the company is currently manufacturing toy
    cars. Then, the CEO of the company feels that there is an urgent need to manufacture
    dolls based on the demand in the market. This situation calls for the Factory
    pattern. In this case, the machine becomes the interface and the CEO is the client.
    The CEO is only bothered about the object (or the toy) to be manufactured and
    knows the interface—the machine—that can create the object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个制造玩具的公司的情况，该公司制造玩具车或娃娃。假设公司中的一台机器目前正在制造玩具车。然后，公司的CEO觉得根据市场需求，迫切需要制造娃娃。这种情况需要工厂模式。在这种情况下，机器成为接口，CEO是客户端。CEO只关心要制造的物体（或玩具），并且知道可以创建该对象的接口——机器。
- en: 'There are three variants of the Factory pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式有三个变体：
- en: '**Simple Factory pattern**: This allows interfaces to create objects without
    exposing the object creation logic.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单工厂模式**：这允许接口创建对象而不暴露对象创建逻辑。'
- en: '**Factory method pattern**: This allows interfaces to create objects, but defers
    the decision to the subclasses to determine the class for object creation.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂方法模式**：这允许接口创建对象，但将决定创建哪个类的决策推迟到子类。'
- en: '**Abstract Factory pattern**: An Abstract Factory is an interface to create
    related objects without specifying/exposing their classes. The pattern provides
    objects of another factory, which internally creates other objects.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂模式**：抽象工厂是一个创建相关对象的接口，而不指定/暴露它们的类。该模式提供另一个工厂的对象，该工厂内部创建其他对象。'
- en: The Simple Factory pattern
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单工厂模式
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Factory Method pattern
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: 'The following points help us understand the factory method pattern:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点有助于我们理解工厂方法模式：
- en: We define an interface to create objects, but instead of the factory being responsible
    for the object creation, the responsibility is deferred to the subclass that decides
    the class to be instantiated.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个创建对象的接口，但工厂不负责对象创建，而是将责任推迟到决定要实例化哪个类的子类。
- en: The Factory method creation is through inheritance and not through instantiation.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法的创建是通过继承而不是通过实例化。
- en: The Factory method makes the design more customizable. It can return the same
    instance or subclass rather than an object of a certain type (as in the simple
    factory method).![The Factory Method pattern](img/00011.jpeg)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法使设计更具可定制性。它可以返回相同的实例或子类，而不是特定类型的对象（如简单工厂方法）。![工厂方法模式](img/00011.jpeg)
- en: A UML diagram for the Factory method
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 工厂方法的 UML 图
- en: In the preceding UML diagram, we have an abstract class, `Creator`, that contains
    `factoryMethod()`. The `factoryMethod()` method has the responsibility of creating
    objects of a certain type. The `ConcreteCreator` class has `factoryMethod()` that
    implements the `Creator` abstract class, and this method can change the created
    object at runtime. `ConcreteCreator` creates `ConcreteProduct` and makes sure
    that the object it creates implements the `Product` class and provides implementation
    for all the methods in the `Product` interface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 UML 图中，我们有一个包含 `factoryMethod()` 的抽象类 `Creator`。`factoryMethod()` 方法负责创建特定类型的对象。`ConcreteCreator`
    类实现了 `Creator` 抽象类的 `factoryMethod()`，并且这个方法可以在运行时改变创建的对象。`ConcreteCreator` 创建
    `ConcreteProduct` 并确保它创建的对象实现了 `Product` 类，并为 `Product` 接口中的所有方法提供了实现。
- en: In brief, `factoryMethod()` of the `Creator` interface and the `ConcreteCreator`
    class decides which subclass of Product to create. Thus, the Factory method pattern
    defines an interface to create an object, but defers the decision ON which class
    to instantiate to its subclasses.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`Creator` 接口和 `ConcreteCreator` 类的 `factoryMethod()` 决定了要创建哪个 `Product`
    子类。因此，工厂方法模式定义了一个创建对象的接口，但将决定实例化哪个类的决策推迟到其子类。
- en: Implementing the Factory Method
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现工厂方法
- en: Let's take a real-world scenario to understand the Factory method implementation.
    Consider that we would like to create profiles of different types on social networks
    such as LinkedIn and Facebook for a person or company. Now, each of these profiles
    would have certain sections. In LinkedIn, you would have a section on patents
    that an individual has filed or publications s/he has written. On Facebook, you'll
    see sections in an album of pictures of your recent visit to a holiday place.
    Additionally, in both these profiles, there'd be a common section on personal
    information. So, in brief, we want to create profiles of different types with
    the right sections being added to the profile.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个现实世界的场景来理解工厂方法实现。假设我们想要为个人或公司创建不同类型的社交网络配置文件，如 LinkedIn 和 Facebook。现在，每个配置文件都会有某些部分。在
    LinkedIn 上，你会看到一个关于个人已申请的专利或已发表的出版物部分。在 Facebook 上，你会在相册中看到你最近访问度假地的照片部分。此外，在这两个配置文件中，都会有关于个人信息的公共部分。简而言之，我们想要创建具有正确部分添加的不同类型的配置文件。
- en: Let's now take a look at the implementation. In the following code example,
    we will start by defining the `Product` interface. We will create a `Section`
    abstract class that defines how a section will be. We will keep it very simple
    and provide an abstract method, `describe()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下实现方式。在下面的代码示例中，我们首先定义 `Product` 接口。我们将创建一个 `Section` 抽象类，它定义了如何定义一个部分。我们将保持它非常简单，并提供一个抽象方法，`describe()`。
- en: 'We now create multiple `ConcreteProduct` classes, `PersonalSection`, `AlbumSection`,
    `PatentSection`, and `PublicationSection`. These classes implement the `describe()`
    abstract method and print their respective section names:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建了多个 `ConcreteProduct` 类，`PersonalSection`、`AlbumSection`、`PatentSection`
    和 `PublicationSection`。这些类实现了 `describe()` 抽象方法，并打印它们各自的分区名称：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create a `Creator` abstract class that is named `Profile`. The `Profile [Creator]`
    abstract class provides a factory method, `createProfile()`. The `createProfile()`
    method should be implemented by `ConcreteClass` to actually create the profiles
    with appropriate sections. The `Profile` abstract class is not aware of the sections
    that each profile should have. For example, a Facebook profile should have personal
    information and album sections. So we will let the subclass decide this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为 `Profile` 的 `Creator` 抽象类。`Profile [Creator]` 抽象类提供了一个工厂方法，`createProfile()`。`createProfile()`
    方法应由 `ConcreteClass` 实现，以实际创建具有适当部分的配置文件。`Profile` 抽象类不知道每个配置文件应该有哪些部分。例如，Facebook
    配置文件应该有个人信息和相册部分。因此，我们将让子类来决定这一点。
- en: 'We create two `ConcreteCreator` classes, `linkedin` and `facebook`. Each of
    these classes implement the `createProfile()` abstract method that actually creates
    (instantiates) multiple sections (`ConcreteProducts`) at runtime:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个 `ConcreteCreator` 类，`linkedin` 和 `facebook`。这些类中的每一个都实现了 `createProfile()`
    抽象方法，该方法在运行时实际创建（实例化）多个部分（`ConcreteProducts`）：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We finally write client code that determines which `Creator` class to instantiate
    in order to create a profile of the desired choice:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编写客户端代码，以确定要实例化哪个 `Creator` 类来创建所需选择的配置文件：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Advantages of the Factory method pattern
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂方法模式的优点
- en: 'As you have now learned the Factory method pattern and how to implement Factory
    methods, let''s see the advantages of the Factory method pattern:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经学习了工厂方法模式及其实现方法，让我们来看看工厂方法模式的优点：
- en: It brings in a lot of flexibility and makes the code generic, not being tied
    to a certain class for instantiation. This way, we're dependent on the interface
    (Product) and not on the `ConcreteProduct` class.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它带来了很多灵活性，并使代码通用，不受特定类实例化的限制。这样，我们依赖于接口（Product），而不是 `ConcreteProduct` 类。
- en: There's loose coupling, as the code that creates the object is separate from
    the code that uses it. The client need not bother about what argument to pass
    and which class to instantiate. The addition of new classes is easy and involves
    low maintenance.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于创建对象的代码与使用它的代码是分离的，因此存在松散耦合。客户端无需担心传递什么参数以及实例化哪个类。添加新类很容易，并且维护成本低。
- en: The Abstract Factory pattern
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: 'The main objective of the Abstract Factory pattern is to provide an interface
    to create families of related objects without specifying the concrete class. While
    the factory method defers the creation of the instance to the subclasses, the
    goal of Abstract Factory method is to create families of related objects:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式的主要目标是提供一个接口来创建一系列相关的对象，而不指定具体的类。虽然工厂方法将实例的创建推迟到子类中，但抽象工厂方法的目标是创建一系列相关的对象：
- en: '![The Abstract Factory pattern](img/00013.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![抽象工厂模式](img/00013.jpeg)'
- en: A UML Diagram for the Abstract Factory pattern
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式的 UML 图
- en: As shown in the diagram, `ConcreteFactory1` and `ConcreteFactory2` are created
    from the `AbstractFactory` interface. This interface has methods to create multiple
    products.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，`ConcreteFactory1` 和 `ConcreteFactory2` 是从 `AbstractFactory` 接口创建的。该接口有创建多个产品的方法。
- en: '`ConcreteFactory1` and `ConcreteFactory2` implement AbstractFactory and create
    instances of `ConcreteProduct1`, `ConcreteProduct2`, `AnotherConcreteProduct1`,
    and `AnotherConcreteProduct2`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteFactory1` 和 `ConcreteFactory2` 实现了抽象工厂，并创建了 `ConcreteProduct1`、`ConcreteProduct2`、`AnotherConcreteProduct1`
    和 `AnotherConcreteProduct2` 的实例。'
- en: '`ConcreteProduct1` and `ConcreteProduct2` are in turn created from the `AbstractProduct`
    interface, and `AnotherConcreteProduct1` and `AnotherConcreteProduct2` are created
    from the `AnotherAbstractProduct` interface.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteProduct1`和`ConcreteProduct2`是从`AbstractProduct`接口创建的，而`AnotherConcreteProduct1`和`AnotherConcreteProduct2`是从`AnotherAbstractProduct`接口创建的。'
- en: In effect, Abstract Factory patterns make sure that the client is isolated from
    the creation of objects but allowed to use the objects created. The client has
    the ability to access objects only through an interface. If products of one family
    are to be used, Abstract Factory pattern helps the client use the objects from
    one/ family at a time. For example, if an application under development is supposed
    to be platform-independent, then it needs to abstract dependencies such as OS,
    file system calls, among others. Abstract Factory pattern takes care of creating
    the required services for the entire platform so that the client doesn't have
    to create platform objects directly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，抽象工厂模式确保客户端与对象的创建相隔离，但允许使用创建的对象。客户端只能通过接口访问对象。如果需要使用同一家族的产品，抽象工厂模式帮助客户端一次使用一个家族的对象。例如，如果一个正在开发的应用程序应该是平台无关的，那么它需要抽象出依赖项，如操作系统、文件系统调用等。抽象工厂模式负责创建整个平台所需的服务，以便客户端不必直接创建平台对象。
- en: Implementing the Abstract Factory pattern
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现抽象工厂模式
- en: Consider the case of your favorite pizza place. It serves multiple types of
    pizzas, right? Wait, hold on, I know you want to order one right away, but let's
    just get back to the example for now!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你最喜欢的披萨店的例子。它提供多种类型的披萨，对吧？等等，我知道你马上就想点一个，但现在让我们先回到例子上！
- en: 'Now, imagine that we create a pizza store where you are served with delicious
    Indian and American pizzas. For this, we first create an abstract base class,
    `PizzaFactory` (`AbstractFactory` in the preceding UML diagram). The `PizzaFactory`
    class has two abstract methods, `createVegPizza()` and `createNonVegPizza()`,
    that need to be implemented by `ConcreteFactory`. In this example, we create two
    concrete factories, namely, `IndianPizzaFactory` and `USPizzaFactory`. Look at
    the following code implementation for the concrete factories:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下我们创建了一个披萨店，你可以品尝到美味的印度和美国披萨。为此，我们首先创建了一个抽象基类，`PizzaFactory`（在先前的UML图中为`AbstractFactory`）。`PizzaFactory`类有两个抽象方法，`createVegPizza()`和`createNonVegPizza()`，需要由`ConcreteFactory`实现。在这个例子中，我们创建了两个具体工厂，即`IndianPizzaFactory`和`USPizzaFactory`。请看以下具体工厂的代码实现：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's move ahead and define `AbstractProducts`. In the following code,
    we create two abstract classes, `VegPizza` and `NonVegPizza` (`AbstractProduct`
    and `AnotherAbstractProduct` in the preceding UML diagram]. They individually
    have a method defined, `prepare()` and `serve()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进并定义`AbstractProducts`。在下面的代码中，我们创建了两个抽象类，`VegPizza`和`NonVegPizza`（在先前的UML图中为`AbstractProduct`和`AnotherAbstractProduct`）。它们各自定义了一个方法，`prepare()`和`serve()`。
- en: The thought process here is that vegetarian pizzas are prepared with an appropriate
    crust, vegetables, and seasoning, and nonvegetarian pizzas are served with nonvegetarian
    toppings on top of vegetarian pizzas.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的思路是，素食披萨使用适当的饼底、蔬菜和调味料制作，而非素食披萨则在素食披萨上加上非素食配料。
- en: We then define `ConcreteProducts` for each of the `AbstractProducts`. Now, in
    this case, we create `DeluxVeggiePizza` and `MexicanVegPizza` and implement the
    `prepare()` method. `ConcreteProducts1` and `ConcreteProducts2` would represent
    these classes from the UML diagram.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每个`AbstractProducts`定义`ConcreteProducts`。现在，在这种情况下，我们创建了`DeluxVeggiePizza`和`MexicanVegPizza`并实现了`prepare()`方法。`ConcreteProducts1`和`ConcreteProducts2`将代表UML图中的这些类。
- en: 'Later, we define `ChickenPizza` and `HamPizza` and implement the `serve()`
    method—these represent `AnotherConcreteProducts1` and `AnotherConcreteProducts2`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们定义了`ChickenPizza`和`HamPizza`并实现了`serve()`方法——这些代表`AnotherConcreteProducts1`和`AnotherConcreteProducts2`：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When an end user approaches `PizzaStore` and asks for an American nonvegetarian
    pizza, `USPizzaFactory` is responsible for preparing the vegetarian pizza as the
    base and serving the nonvegetarian pizza with ham on top!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当最终用户接近`PizzaStore`并要求一份美国非素食披萨时，`USPizzaFactory`负责准备素食披萨作为底料，并在上面加上火腿来提供非素食披萨！
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is the output of the preceding code example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在先前的代码示例中的输出：
- en: '![Implementing the Abstract Factory pattern](img/00014.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![实现抽象工厂模式](img/00014.jpeg)'
- en: The Factory method versus Abstract Factory method
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法与抽象工厂方法
- en: 'Now that you have learned the Factory method and Abstract Factory method, let''s
    see the comparison of the two:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了工厂方法和抽象工厂方法，让我们看看这两种方法的比较：
- en: '| Factory method | Abstract Factory method |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 工厂方法 | 抽象工厂方法 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| This exposes a method to the client to create the objects | Abstract Factory
    method contains one or more factory methods to create a family of related objects
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 这向客户端公开了一个创建对象的方法 | 抽象工厂方法包含一个或多个工厂方法来创建一个相关对象系列 |'
- en: '| This uses inheritance and subclasses to decide which object to create | This
    uses composition to delegate responsibility to create objects of another class
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 这使用继承和子类来决定创建哪个对象 | 这使用组合来委托创建另一个类的对象的责任 |'
- en: '| The factory method is used to create one product | Abstract Factory method
    is about creating families of related products |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 工厂方法用于创建一个产品 | 抽象工厂方法关于创建相关产品系列 |'
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the Factory design pattern and the context
    in which it's used. We understood the basics of the Factory, and how it is effectively
    used in software architecture.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了工厂设计模式及其使用场景。我们了解了工厂的基本原理，以及它在软件架构中的有效应用。
- en: We looked at Simple Factory, where an appropriate instance is created at runtime
    based on the type of the argument passed by the client.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了简单工厂模式，其中根据客户端传递的参数类型在运行时创建一个适当的实例。
- en: We also discussed the Factory method pattern, which is a variation of Simple
    Factory. In this pattern, we defined an interface to create objects, but the creation
    of objects is deferred to the subclass.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了工厂方法模式，这是简单工厂模式的一种变体。在这个模式中，我们定义了一个接口来创建对象，但对象的创建被延迟到子类中。
- en: We went on to explore the Abstract Factory method, which provides an interface
    to create families of related objects without specifying the concrete class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续探索抽象工厂方法，它提供了一个创建相关对象系列的接口，而不指定具体的类。
- en: We also worked out a real-world Python implementation for all the three patterns,
    and compared the Factory method with Abstract Factory method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为所有三种模式实现了实际的Python实现，并比较了工厂方法和抽象工厂方法。
- en: At the end of this chapter, we're now ready to take the next step and study
    other types of patterns, so stay tuned.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们现在准备迈出下一步，研究其他类型的模式，所以请保持关注。
