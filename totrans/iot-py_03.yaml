- en: Chapter 3. Interacting with Digital Outputs with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用Python与数字输出交互
- en: 'In this chapter, we will work with digital inputs with Python and two libraries:
    `mraa` and `wiring-x86`. We shall:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python和两个库：`mraa`和`wiring-x86`来处理数字输入。我们将：
- en: Wire our first connections between an Intel Galileo Gen 2 and a breadboard with
    electronic components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将英特尔Galileo Gen 2和带有电子组件的面包板之间的第一个连接线焊接好
- en: Write a first version of a Python script that turns on and off electronic components
    connected to the board
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个Python脚本的第一个版本，用于控制连接到板上的电子组件的开关
- en: Transfer Python code to the Yocto Linux running on the board
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Python代码传输到板上的Yocto Linux操作系统
- en: Execute Python scripts that interact with the board
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行与板交互的Python脚本
- en: Learn to take advantage of Python's object-oriented features to improve the
    code and make it easier to understand
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习利用Python的面向对象特性来改进代码并使其更容易理解
- en: Prepare the code to make it easy to build an API that will allow us to interact
    with the IoT device
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备代码，使其易于构建一个API，允许我们与物联网设备交互
- en: Turning on and off an onboard component
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开和关闭板载组件
- en: First, we will take advantage of an onboard LED (Light Emitting Diode) to write
    our first Python lines that interact with the digital output capabilities included
    in the Intel Galileo Gen 2 board. The simple example will allow us to understand
    how the `mraa` library allows us to easily turn on and off one of the onboard
    components with Python code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将利用板载LED（发光二极管）来编写我们的第一条Python代码，这些代码将与我们包含在英特尔Galileo Gen 2板中的数字输出功能进行交互。这个简单的例子将帮助我们理解`mraa`库如何使我们能够通过Python代码轻松地打开和关闭板载组件之一。
- en: In the previous chapter, we recognized the different elements included in the
    Intel Galileo Gen 2 board. We know that there are three rectangular LEDs located
    at the right hand side of the USB 2.0 host connector. The first LED, labeled **L**
    is connected to pin 13 of the digital I/O pins, and therefore, a high level sent
    to pin 13 will turn on this LED and a low level will turn it off.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们识别了英特尔Galileo Gen 2板中包含的不同元素。我们知道有三个矩形LED位于USB 2.0主机连接器的右侧。第一个LED，标记为**L**，连接到数字I/O引脚的13号引脚，因此，向13号引脚发送高电平将打开此LED，而低电平将关闭它。
- en: 'We will write a few lines of Python code that will use the `mraa` library to
    make the onboard LED labeled **L** to repeat the following loop until the Python
    program is interrupted:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写几行Python代码，使用`mraa`库使标记为**L**的板载LED重复以下循环，直到Python程序被中断：
- en: Turn on
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开
- en: Stay turned on for 3 seconds
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持打开3秒钟
- en: Turn off
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭
- en: Stay turned off for 2 seconds.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭2秒钟。
- en: The following lines show the Python code that performs the previously explained
    actions. The code file for the sample is `iot_python_chapter_03_01.py`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行先前解释的操作的Python代码。示例代码文件为`iot_python_chapter_03_01.py`。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book. Please have a look.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有关下载代码包的详细步骤，请参阅本书的序言。请查看。
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Internet-of-Things-with-Python](https://github.com/PacktPublishing/Internet-of-Things-with-Python).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的代码包也托管在GitHub上，网址为[https://github.com/PacktPublishing/Internet-of-Things-with-Python](https://github.com/PacktPublishing/Internet-of-Things-with-Python)。我们还有其他丰富的书籍和视频的代码包，可在[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)找到。请查看它们！
- en: In the previous chapter, we learned that the Yocto Linux running on the board
    provided both **SSH** and **SFTP** (short for **SSH File Transfer Protocol** or
    **Secure File Transfer Protocol**) services by running a Bonjour browser. We can
    use any SFTP client to connect to the board and transfer the file that we created
    in any computer or mobile device. Of course, we can also use any Linux editor,
    such as `vi`, in the SSH terminal, or just enter the code in the Python interpreter.
    However, it is usually more convenient to use our favorite editor or IDE in our
    computer or mobile device and then transfer the file to the board with any SFTP
    client.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解到在板上运行的Yocto Linux通过运行Bonjour浏览器提供了**SSH**和**SFTP**（简称**SSH文件传输协议**或**安全文件传输协议**）服务。我们可以使用任何SFTP客户端连接到板并传输我们在任何计算机或移动设备上创建的文件。当然，我们也可以在SSH终端中使用任何Linux编辑器，如`vi`，或者在Python解释器中直接输入代码。然而，通常在计算机或移动设备上使用我们喜欢的编辑器或IDE然后使用任何SFTP客户端将文件传输到板会更方便。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some Python IDEs have remote development capabilities and allow us to easily
    transfer the necessary files and launch their execution on the board. An example
    is the paid Professional Edition of JetBrains PyCharm. Unluckily, the Community
    Edition doesn't include this feature.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python IDE具有远程开发功能，并允许我们轻松传输必要的文件并在板上启动它们的执行。一个例子是JetBrains PyCharm的付费专业版。不幸的是，社区版不包括此功能。
- en: 'We don''t want the process to be linked to a specific IDE, and therefore, we
    will transfer the file with an SFTP client. FileZilla Client is a free, open source
    and multiplatform FTP client that supports SFTP. You can download and install
    it here: [http://filezilla-project.org](http://filezilla-project.org).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望此过程与特定的IDE相关联，因此我们将使用SFTP客户端传输文件。FileZilla客户端是一个免费、开源的多平台FTP客户端，支持SFTP。您可以从这里下载和安装它：[http://filezilla-project.org](http://filezilla-project.org)。
- en: 'Once you have installed and executed FileZilla Client, you must follow the
    next steps to add the SFTP server running on the board in with the application''s
    Site Manager:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装并执行了FileZilla客户端，您必须按照以下步骤在应用程序的站点管理器中添加板上运行的SFTP服务器：
- en: Select **File** | **Site Manager**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件** | **站点管理器**。
- en: Click **New Site** on the **Site Manager** dialog box. Enter the desired name,
    such as **IntelGalileo2** to easily identify the board's SFTP service.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**站点管理器**对话框中点击**新建站点**。输入所需名称，例如**IntelGalileo2**，以便轻松识别板的SFTP服务。
- en: 'Enter the board''s IP address in **Host**. You don''t need to enter any value
    in **Port** because the SFTP server uses the default SFTP port, that is, the same
    port in which the SSH daemon listens: port 22.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**主机**中输入板的IP地址。您不需要在**端口**中输入任何值，因为SFTP服务器使用默认的SFTP端口，即SSH守护进程监听的相同端口：端口22。
- en: Select **SFTP - SSH File Transfer Protocol** in the Protocol dropdown.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在协议下拉菜单中选择**SFTP - SSH文件传输协议**。
- en: Select **Normal** in the **Logon Type** dropdown.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**登录类型**下拉菜单中选择**正常**。
- en: Enter **root** in **User**. The next screenshots shows the configuration values
    for a board that has **192.168.1.107** as its assigned IP address.![Turning on
    and off an onboard component](img/B05042_03_01.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**用户**中输入**root**。下一张截图显示了IP地址分配为**192.168.1.107**的板的配置值。![开启和关闭板载组件](img/B05042_03_01.jpg)
- en: Click **Connect**. FileZilla will display an Unknown host key dialog box, indicating
    that the server's host key is unknown. It is similar to the information provided
    when you established the first connection to the board with an SSH client. The
    details include the host and the fingerprint. Activate the **Always trust this
    host, add this key to the cache** checkbox and click **OK**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**连接**。FileZilla将显示一个未知主机密钥对话框，表明服务器的宿主密钥是未知的。这类似于您使用SSH客户端首次连接到板时提供的信息。详细信息包括宿主和指纹。激活**始终信任此主机，将此密钥添加到缓存**复选框，然后点击**确定**。
- en: FileZilla will display the `/home/root` folder for the Yocto Linux running on
    the board at the right-hand side of the window, under **Remote Site**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FileZilla将在窗口右侧的**远程站点**下显示Yocto Linux运行的`/home/root`文件夹。
- en: Navigate to the folder in which you saved the Python files you want to transfer
    in your local computer under **Local site**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**本地站点**下导航到您在本地计算机中保存要传输的Python文件的文件夹。
- en: Select the file you want to transfer and press *Enter* to transfer the file
    to the `/home/root` folder on the board. Another way is to right-click on the
    desired file and select **Upload**. FileZilla will display the uploaded file in
    the `/home/root` folder under **Remote Site**. This way, you will be able to access
    the Python file in the default location that Yocto Linux uses when you login with
    an SSH terminal, that is, in your home folder for your `root` user. The following
    picture shows many Python files uploaded to the `/home/root` folder with FileZilla
    and listed in the contents of the `/home/root` folder.![Turning on and off an
    onboard component](img/B05042_03_02.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要传输的文件，然后按*Enter*键将文件传输到板上的`/home/root`文件夹。另一种方法是右键单击所需的文件并选择**上传**。FileZilla将在**远程站点**下的`/home/root`文件夹中显示上传的文件。这样，您将能够访问使用SSH终端登录时Yocto
    Linux默认位置中的Python文件，即您的`root`用户的家目录。以下图片显示了使用FileZilla上传到`/home/root`文件夹的许多Python文件，并列在`/home/root`文件夹的内容中。![开启和关闭板载组件](img/B05042_03_02.jpg)
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As you work with additional projects, you will want to create new folders under
    `/home/root` to provide a better organization for your Python code in the Yocto
    Linux filesystem.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您处理更多项目，您可能需要在`/home/root`下创建新的文件夹，以在Yocto Linux文件系统中为您的Python代码提供更好的组织。
- en: The next time you have to upload a file to the board, you don't need to setup
    a new site in the **Site Manager** dialog box in order to establish an SFTP connection.
    You just need to select **File** | **Site Manager**, select the site name under
    **Select Entry** and click **Connect**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下次您需要将文件上传到板上时，您不需要在**站点管理器**对话框中设置新的站点以建立SFTP连接。您只需选择**文件** | **站点管理器**，在**选择条目**下选择站点名称，然后点击**连接**。
- en: 'If you run the following command in the SSH terminal after you login, Linux
    will print your current folder or directory:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在登录后SSH终端中运行以下命令，Linux将打印您的当前文件夹或目录：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result of the previous command will be the same folder in which we uploaded
    the Python code file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之前命令的结果将是上传Python代码文件的同一路径文件夹。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we transfer the file to the board, we can run the previous code with the
    following command on the board''s SSH terminal:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将文件传输到板上，我们可以在板上的SSH终端使用以下命令运行之前的代码：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous code is extremely simple. We have used many print statements to
    make it easy for us to understand what is going on with messages on the console.
    The following lines show the generated output after we run the code for a few
    seconds:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码非常简单。我们使用了多个打印语句来使它更容易理解控制台上的消息。以下几行显示了运行几秒钟后的生成输出：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first lines print the `mraa` library version and the detected platform
    name. This way, we have information about the `mraa` library version that Python
    is using and we make sure that the `mraa` library has been able to initialize
    itself and detect the right platform: Intel Galileo Gen 2\. In case we have a
    specific issue, we can use this information to check about specific problems related
    to the `mraa` library and the detected platform.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行打印了`mraa`库版本和检测到的平台名称。这样，我们就有了Python正在使用的`mraa`库版本的信息，并确保`mraa`库已经能够初始化自身并检测到正确的平台：Intel
    Galileo Gen 2。如果我们遇到特定问题，我们可以使用这些信息来检查与`mraa`库和检测到的平台相关的特定问题。
- en: The next line creates an instance of the `mraa.Gpio` class. **GPIO** stands
    for **General Purpose Input/Output** and an instance of the `mraa.Gpio` class
    represents a general purpose Input/Output pin on the board. In this case, we pass
    `13` as an argument for the `pin` parameter, and therefore, we are creating an
    instance of the `mraa.Gpio` class that represents the pin number 13 of the GPIO
    pins in the board. We named the instance `onboard_led` to make it easy to understand
    that the instance allows us to control the status of the onboard LED.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行创建了一个`mraa.Gpio`类的实例。**GPIO**代表**通用输入/输出**，`mraa.Gpio`类的实例代表板上的一个通用输入/输出引脚。在这种情况下，我们将`13`作为`pin`参数的参数，因此我们创建了一个代表板上GPIO引脚编号13的`mraa.Gpio`类的实例。我们将其命名为`onboard_led`，以便更容易理解该实例允许我们控制板载LED的状态。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We just need to specify the value for the pin parameter to initialize an instance
    of the `mraa.Gpio` class. There are two additional optional parameters (`owner`
    and `raw`), but we should leave them with the default values. By default, whenever
    we create an instance of the `mraa.Gpio` class, we own the pin and the `mraa`
    library will close it on destruct.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需指定引脚参数的值来初始化 `mraa.Gpio` 类的一个实例。还有两个额外的可选参数（`owner` 和 `raw`），但我们应该将它们保留为默认值。默认情况下，每次我们创建
    `mraa.Gpio` 类的实例时，我们拥有该引脚，并且 `mraa` 库将在析构时关闭它。
- en: As we might guess from its name, an instance of the `mraa.Gpio` class allows
    us to work with pins as either Input or Output. Thus, it is necessary to specify
    the desired direction for our `mraa.Gpio` instance. In this case, we want to use
    pin 13 as an output pin. The following line calls the `dir` method to configure
    the pin to be an output pin, that is, to set is direction to the `mraa.DIR_OUT`
    value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`mraa.Gpio` 类的一个实例允许我们以输入或输出方式工作于引脚。因此，为我们的 `mraa.Gpio` 实例指定所需的方向是必要的。在这种情况下，我们希望将引脚
    13 用作输出引脚。以下行调用 `dir` 方法来配置引脚为输出引脚，即将其方向设置为 `mraa.DIR_OUT` 值。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, the code runs a loop forever, that is, until you interrupt the execution
    by pressing *Ctrl* + *C* or the button to stop the process in case you are using
    a Python IDE with remote development features to run the code in your board.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码无限循环运行，即直到你通过按 *Ctrl* + *C* 或在具有远程开发功能的 Python IDE 中使用停止按钮来中断执行为止。
- en: The first line within the `while` loop calls the `write` method for the `mraa.Gpio`
    instance, `onboard_led`, with `1` as an argument for the `value` required parameter.
    This way, we send a high value (`1`) to the pin 13 configured for digital output.
    Because the pin 13 has the onboard LED connected to it, the result of a high value
    in pin 13 is that the onboard LED turns on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环内的第一行调用 `mraa.Gpio` 实例 `onboard_led` 的 `write` 方法，并将 `1` 作为 `value`
    必需参数的参数。这样，我们向配置为数字输出的引脚 13 发送高值（`1`）。因为引脚 13 连有板上 LED，所以在引脚 13 中的高值会导致板上 LED
    点亮。'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After we turn on the LED, a line of code uses the `print` statement to print
    a message to the console output, so that we know the LED should be turned on.
    A call to `time.sleep` with `3` as the value for the `seconds` argument delays
    the execution for three seconds. Because we didn't change the status of pin 13,
    the LED will stay turned on during this delay.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们点亮 LED 后，一行代码使用 `print` 语句将消息打印到控制台输出，这样我们知道 LED 应该被点亮。使用 `time.sleep` 并将
    `3` 作为 `seconds` 参数的值来延迟执行三秒钟。因为我们没有改变引脚 13 的状态，所以在这段延迟期间 LED 将保持点亮状态。
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next line calls the `write` method for the `mraa.Gpio` instance, `onboard_led`,
    but this time with `0` as an argument for the `value` required parameter. This
    way, we send a low value (`0`) to the pin 13 configured for digital output. Because
    the pin 13 has the onboard LED connected to it, the result of a low value in pin
    13 is that the onboard LED turns off.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个行调用 `mraa.Gpio` 实例 `onboard_led` 的 `write` 方法，但这次将 `0` 作为 `value` 必需参数的参数。这样，我们向配置为数字输出的引脚
    13 发送低值（`0`）。因为引脚 13 连有板上 LED，所以在引脚 13 中的低值会导致板上 LED 关闭。
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After we turn off the LED, a line of code uses the `print` statement to print
    a message to the console output, so that we know the LED should be turned off.
    A call to `time.sleep` with `2` as the value for the seconds argument delays the
    execution for 2 seconds. Because we didn't change the status of pin 13, the LED
    will stay turned off during this delay. Then, the loop starts over again.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关闭 LED 后，一行代码使用 `print` 语句将消息打印到控制台输出，这样我们知道 LED 应该被关闭。使用 `time.sleep` 并将
    `2` 作为 `seconds` 参数的值来延迟执行 2 秒钟。因为我们没有改变引脚 13 的状态，所以在这段延迟期间 LED 将保持关闭状态。然后，循环重新开始。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As we can use any `ssh` client to run the Python code, we can see the results
    of the `print` statements in the console output and they are extremely useful
    for us to understand what should be happening with the digital outputs. We will
    take advantage of more advanced logging features included in Python for more complex
    scenarios later.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以使用任何 `ssh` 客户端来运行 Python 代码，因此我们可以看到控制台输出中的 `print` 语句的结果，这对我们理解数字输出应该发生什么非常有用。我们将在稍后利用
    Python 中包含的更高级的日志功能来处理更复杂的情况。
- en: As we could learn from the previous example, the `mraa` library encapsulates
    all the necessary methods to work with the GPIO pins in the `mraa.Gpio` class.
    The previous code didn't take advantage of Python's object-oriented features,
    it just interacted with one of the classes included in the `mraa` library. We
    will take advatange of many Python features in the forthcoming examples. In addition,
    once we start working with more complex examples, we will make the board interact
    through the network.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从上一个例子中学到的，`mraa`库封装了在`mraa.Gpio`类中与GPIO引脚一起工作的所有必要方法。之前的代码没有利用Python的面向对象特性，它只是与`mraa`库中包含的一个类进行了交互。在接下来的例子中，我们将利用许多Python特性。此外，一旦我们开始处理更复杂的例子，我们将使板通过网络进行交互。
- en: Prototyping with breadboards
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用面包板进行原型设计
- en: In the previous example, we interacted with the onboard LED, and therefore,
    we didn't wire any additional electronic component to the board. Now, it is time
    to move to more complex samples in which we will have to start working with additional
    components and tools.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们与板载LED进行了交互，因此我们没有将任何额外的电子元件焊接在板上。现在，是时候转向更复杂的样本了，在这些样本中，我们将不得不开始使用额外的组件和工具。
- en: We don't want to create a new printed circuit board (PCB) and solder electronic
    components to the board each time we want to wire some electronic components to
    the board. We will be prototyping many electronics projects throught the book
    and we will also continue prototyping after we learn each lesson towards our IoT
    adventure. Thus, we will use a solderless breadboard as our construction base
    for our electronic prototypes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望每次想要在板上焊接一些电子元件时都创建一个新的印刷电路板（PCB）并将电子元件焊接在板上。我们将通过这本书进行许多电子项目的原型设计，我们也会在每学完一课后继续进行原型设计，以迈向我们的物联网冒险。因此，我们将使用无焊面包板作为我们电子原型的构建基础。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Solderless breadboards are also known as breadboards, solderless plug-in breadboards
    or prototype boards. We will call them with their shortests name: breadboards.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无焊面包板也被称为面包板、无焊插拔面包板或原型板。我们将用它们最简短的名字：面包板。
- en: We will use an 830 tie points (holes for connections) with 2 power lanes breadboard
    for all our prototypes that require electronic components wired to the board.
    The following picture shows this kind of breadboard that consists of a chunk of
    plastic of approximately 6.5" x 2.1" with a bunch number of holes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用带有2条电源线的830个接点（连接孔）的面包板来制作所有需要将电子元件焊接在板上的原型。以下图片展示了这种面包板，它由一块大约6.5" x 2.1"的塑料块组成，上面有许多孔。
- en: '![Prototyping with breadboards](img/B05042_03_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![使用面包板进行原型设计](img/B05042_03_03.jpg)'
- en: The next picture shows the internal connections for an 830 tie points with 2
    power lanes breadboard. There are metal strips inside the breadboard that connect
    the holes as shown in this picture.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了带有2条电源线的830个接点面包板的内部连接。面包板内部有金属条，它们将孔连接起来，如图片所示。
- en: '![Prototyping with breadboards](img/B05042_03_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![使用面包板进行原型设计](img/B05042_03_04.jpg)'
- en: The breadboard provides two power lanes, bus strips or horizontal buses at the
    top and at the bottom of the board. These power lanes connect all the holes within
    the row. Each column has five row holes connected.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板在板子的顶部和底部提供了两条电源线，总线条或水平总线。这些电源线连接了同一行内的所有孔。每一列有五个行孔相连。
- en: However, we must be careful because there are similar breadboards that break
    the power lanes or horizontal buses in the middle, and therefore, the power lanes
    don't connect all the holes within the row. The following picture shows the connections
    for these kinds of breadboards.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须小心，因为有一些类似的面包板会在中间打断电源线或水平总线，因此，电源线并没有连接同一行内的所有孔。以下图片展示了这类面包板的连接方式。
- en: '![Prototyping with breadboards](img/B05042_03_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用面包板进行原型设计](img/B05042_03_05.jpg)'
- en: In case you decide to work with this kind of breadboard, you have to make the
    following connections to the buses. This way, you will mimic the wires shown for
    the first breadboard.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用这种面包板，你必须将以下连接做到总线上。这样，你将模仿第一个面包板中展示的电线。
- en: '![Prototyping with breadboards](img/B05042_03_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![使用面包板进行原型设计](img/B05042_03_06.jpg)'
- en: We can stick wire ends without insulation into the breadboard holes in order
    to wire elements. It is convenient to prepare jumper wires with different lengths
    and using cables with diverse colors. The following picture shows many cables
    of different lengths without their insulation that will work as jumper wires.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将没有绝缘层的线端插入面包板的孔中，以便接线元件。准备不同长度的跳线和使用不同颜色的电缆都很方便。以下图片显示了多种不同长度的电缆，它们将作为跳线使用。
- en: '![Prototyping with breadboards](img/B05042_03_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![使用面包板进行原型制作](img/B05042_03_07.jpg)'
- en: In case we don't want to spend time building our own jumper wires, we can buy
    prebuilt male to male solderless flexible breadboard jumper wires with tiny plugs
    attached to the wire ends.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望花费时间制作自己的跳线，我们可以购买预先制作好的公对公无焊锡柔性面包板跳线，线端带有小插头。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use any of the previously explained options to make the necessary connections
    for each of the examples in which we will be working throught this book. In case
    you decide to use male to male breadboard jumper wires, make sure they are high
    quality ones.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用之前解释过的任何选项来制作本书中我们将要工作的每个示例所需的连接。如果您决定使用公对公面包板跳线，请确保它们是高质量的。
- en: Working with schematics to wire digital outputs
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原理图进行数字输出接线
- en: Now, it is time to take advantage of the prototyping capabilities of the breadboard
    and start working on a more complex example. We will turn on and off 9 LEDs by
    using 9 digital outputs of the Intel Galileo Gen 2 board. Each digital output
    is going to control whether an LED is turned on or turned off.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候利用面包板的原型制作能力，开始制作一个更复杂的示例了。我们将通过使用英特尔Galileo Gen 2板的9个数字输出，来点亮和熄灭9个LED灯。每个数字输出将控制一个LED灯的点亮或熄灭。
- en: After we finish the necessary wirings, we will write Python code that counts
    from 1 to 9 by controlling the digital output to turn on the necessary number
    of LEDs. In this case, our first approach won't be the best one. However, after
    we learn many things, we will create new versions and we will improve both the
    initial prototype and the Python code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成必要的接线后，我们将编写Python代码，通过控制数字输出以点亮必要的LED灯来从1计数到9。在这种情况下，我们的第一个方法可能不是最好的。然而，在学到了很多东西之后，我们将创建新的版本，并将对初始原型和Python代码进行改进。
- en: 'We need the following parts to work with this example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下部件来完成这个示例：
- en: Three red ultrabright 5mm LEDs
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个红色超亮5mm LED灯
- en: Three white ultrabright 5mm LEDs
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个白色超亮5mm LED灯
- en: Three green ultrabright 5mm LEDs
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个绿色超亮5mm LED灯
- en: Nine 270Ω resistors with 5% tolerance (red violet brown gold)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 九个5%容差的270Ω电阻（红紫棕金）
- en: The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_03_02.fzz` and the following
    picture is the breadboard view.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了连接到面包板上的组件、必要的接线以及从英特尔Galileo Gen 2板到面包板的接线。该示例的Fritzing文件为`iot_fritzing_chapter_03_02.fzz`，以下图片是面包板视图。
- en: '![Working with schematics to wire digital outputs](img/B05042_03_08.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![使用原理图进行数字输出接线](img/B05042_03_08.jpg)'
- en: In this case, we decided to match the GPIO pin number with the LED number. This
    way, whenever we want to turn on LED 1, we write a high (1) value to GPIO pin
    number 1, whenever we want to turn on LED 2, we write a high (1) value to GPIO
    pin number 2, and so on. Later, we will realize it is not the best decision because
    the wiring becomes a bit more complex than expected due to the positions of the
    pins in the board. However, we will analyze this situation later and we will create
    a new version of this example with improvements based on everything we learned
    from the first version.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们决定将GPIO引脚号与LED号相匹配。这样，无论何时我们想要点亮LED 1，我们就在GPIO引脚号1写入高（1）值，无论何时我们想要点亮LED
    2，我们就在GPIO引脚号2写入高（1）值，以此类推。稍后，我们会意识到这并不是最佳决定，因为由于板上引脚的位置，接线变得比预期的要复杂一些。然而，我们将在稍后分析这种情况，并基于从第一版学到的一切来创建这个示例的新版本。
- en: The following picture shows the schematic with the electronic components represented
    as symbols. The schematic makes it easier to understand the connections between
    the Intel Galileo Gen 2 board GPIO pins and the electronic components. Clearly,
    the schematic benefits from the fact that the GPIO pin number matches the LED
    number and it will be easy to write our first version of the code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了带有电子元件表示为符号的原理图。原理图使得理解Intel Galileo Gen 2板GPIO引脚和电子元件之间的连接变得更容易。显然，原理图得益于GPIO引脚号与LED号相匹配的事实，这将使得编写我们的第一个版本的代码变得容易。
- en: '![Working with schematics to wire digital outputs](img/B05042_03_09.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![使用原理图布线数字输出](img/B05042_03_09.jpg)'
- en: As seen in the previous schematic, each GPIO pin labeled from **D1** to **D9**
    in the board's symbol is connected to a **270Ω** resistor, wired to an LED's anode,
    and each LED's cathode is connected to ground. This way, whenever we write a high
    (1) value to any of the GPIO pins, the board will put 5V on the pin and the LED
    will turn on. Whenever we write a low (0) value to any of the GPIO pins, the board
    will put 0V on the pin and the LED will turn off.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个原理图所示，板上标记为**D1**到**D9**的每个GPIO引脚都连接到一个**270Ω**电阻，该电阻连接到LED的正极，每个LED的负极连接到地。这样，无论我们向哪个GPIO引脚写入高（1）值，板都会在该引脚上施加5V，LED将点亮。无论我们向哪个GPIO引脚写入低（0）值，板都会在该引脚上施加0V，LED将熄灭。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As we left the jumper labeled **IOREF** in its default 5V position, the board
    will be operating with 5V for its GPIO pins. Thus, a GPIO pin will have 5V when
    we write a high value to it. If we change the position of this jumper to 3.3V,
    a GPIO pin will have 3.3V when we write a high value to it. Unless specified otherwise,
    we are using the default position for this jumper in all the examples.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将标记为**IOREF**的跳线留在了默认的5V位置，因此该板将以5V为其GPIO引脚供电。因此，当我们向其写入高值时，GPIO引脚将具有5V。如果我们将此跳线的位置更改为3.3V，当我们向其写入高值时，GPIO引脚将具有3.3V。除非另有说明，否则我们在所有示例中都使用此跳线的默认位置。
- en: Now, it is time to insert the components in the breadboard and make all the
    necessary wirings.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将组件插入面包板并完成所有必要的布线了。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always shutdown the Yocto Linux, wait for all the onboard LEDs to turn off,
    and unplug the power supply from the Intel Galileo Gen 2 board before adding or
    removing any wire from the board's pins. Do the same before plugging or unplugging
    any shield.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总是关闭Yocto Linux，等待所有板载LED熄灭，然后从Intel Galileo Gen 2板上拔掉电源供应，在添加或从板上的引脚移除任何电线之前。在插入或拔除任何屏蔽之前也这样做。
- en: In order to shutdown the Yocto Linux, enter the following command in your `ssh`
    terminal. Make sure you have exited the Python interpreter when you enter the
    command.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了关闭Yocto Linux，请在您的`ssh`终端中输入以下命令。确保在输入命令时已经退出了Python解释器。
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As a result of the previous command, you will see the time at which the shutdown
    process is going to begin. The message will be similar to the following output
    but with different dates and times.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的结果将显示关闭过程将要开始的时间。消息将与以下输出类似，但日期和时间不同。
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, wait around 1 minute until the operating system closes down and all the
    onboard LEDs turn off. At this time, you can safely remove the power supply from
    the board.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，等待大约1分钟，直到操作系统关闭并且所有板载LED熄灭。此时，您可以安全地从板上拔掉电源供应。
- en: We have to pay special attention when inserting the LEDs in the breadboard.
    As we can notice in the schematic, the resistor is wired to an LED's anode, and
    each LED's cathode is connected to ground.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入LED到面包板时，我们必须特别注意。正如我们可以在原理图中看到的那样，电阻连接到LED的正极，每个LED的负极连接到地。
- en: We can easily identify the LED's anode, that is, its positive lead, because
    its lead is slightly longer than the other lead. The LED's cathode, that is, its
    negative lead is shorter than the other lead. In the following picture, the LED's
    cathode, that is, its negative lead is the lead located at the left-hand side
    (the shorter lead). The LED's anode, that is, its positive lead, is the lead located
    at the right-hand side (the slightly longer lead). You can also notice that the
    metal piece inside the LED connected to the LED's anode, that is, its positive
    lead, is smaller than the metail piece inside the LED connected to the LED's cathode,
    that is, its negative lead.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地识别LED的阳极，即其正极引脚，因为其引脚比另一个引脚稍长。LED的阴极，即其负极引脚，比另一个引脚短。在以下图片中，LED的阴极，即其负极引脚是位于左侧（较短的引脚）的引脚。LED的阳极，即其正极引脚，是位于右侧（稍长的引脚）的引脚。你也可以注意到，连接到LED阳极，即其正极引脚的LED内部的金属部件比连接到LED阴极，即其负极引脚的金属部件小。
- en: '![Working with schematics to wire digital outputs](img/B05042_03_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![使用原理图布线数字输出](img/B05042_03_10.jpg)'
- en: The LED in the picture is located in the same position than the LEDs are connected
    in the previously shown breadboard picture. Thus, we have to connect the shorter
    lead at the left and the larger lead at the right in the breadboard. The next
    picture shows the LED representation in the breadboard picture with its cathode
    and anode.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图片中的LED位于与之前显示的面包板图片中LED连接相同的位置。因此，我们必须在面包板上将较短的引脚连接在左侧，较长的引脚连接在右侧。下一张图片显示了面包板图片中的LED表示，包括其阴极和阳极。
- en: '![Working with schematics to wire digital outputs](img/B05042_03_11.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![使用原理图布线数字输出](img/B05042_03_11.jpg)'
- en: The following picture shows the schematic electronic symbol for the LED with
    the same positions for the cathode and anode than in the previous picture that
    showed the breadboard picture.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了LED的原理图电子符号，其阴极和阳极的位置与之前显示面包板图片中的位置相同。
- en: '![Working with schematics to wire digital outputs](img/B05042_03_12.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![使用原理图布线数字输出](img/B05042_03_12.jpg)'
- en: The following picture shows all the LEDs connected to the breadboard. You can
    check the cathode and the anode based on the metal parts that you can see through
    the LED's plastic.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了所有连接到面包板的LED。你可以根据通过LED塑料看到的金属部件来检查阴极和阳极。
- en: '![Working with schematics to wire digital outputs](img/B05042_03_13.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用原理图布线数字输出](img/B05042_03_13.jpg)'
- en: The following picture shows all the LEDs connected to the breadboard where you
    can check that the LEDs are connected as we have seen in the breadboard view for
    the Fritzing diagram.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了所有连接到面包板的LED，你可以检查LED的连接方式与我们之前在Fritzing图中的面包板视图看到的一样。
- en: '![Working with schematics to wire digital outputs](img/B05042_03_14.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用原理图布线数字输出](img/B05042_03_14.jpg)'
- en: Resistors are the same forward and backwards, and therefore, it doesn't matter
    which way you use them in the breadboard. The following picture shows a 270Ω axial-lead
    resistor with 5% tolerance. Notice that the color bands from left to right are
    red, violet, brown and gold. The color bands allow us to know the resistance in
    ohms and their tolerance value without having to measure the resistor.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻正反方向相同，因此，在面包板上使用它们的方向无关紧要。以下图片显示了一个270Ω轴向引脚电阻，公差为5%。请注意，从左到右的颜色带是红色、紫色、棕色和金色。颜色带使我们能够知道电阻的欧姆值和它们的公差值，而无需测量电阻。
- en: '![Working with schematics to wire digital outputs](img/B05042_03_15.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![使用原理图布线数字输出](img/B05042_03_15.jpg)'
- en: The following picture shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了连接到面包板的组件、必要的布线和从英特尔Galileo Gen 2板到面包板的布线。
- en: '![Working with schematics to wire digital outputs](img/B05042_03_16.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用原理图布线数字输出](img/B05042_03_16.jpg)'
- en: Counting from 1 to 9 with LEDs, Python code and the mraa library
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LED、Python代码和mraa库从1计数到9
- en: Once we finish the wirings and we make sure that all the components and the
    wires are in the right place, we can write our first version of the Python code
    to count from 1 to 9 with the LEDs, transfer it to the board via SFTP and execute
    it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成布线并确保所有组件和电线都放置正确，我们就可以编写我们的第一个Python代码版本，用LED从1计数到9，通过SFTP将其传输到板子上并执行它。
- en: 'We will write a few lines of Python code that will use the `mraa` library to
    run the following steps to count from 1 to 9, with a 3 seconds pause between each
    step:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写几行Python代码，使用`mraa`库执行以下步骤从1计数到9，每一步之间有3秒的暂停：
- en: Turn on LED1
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮LED1
- en: Turn on LED1 and LED2
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮LED1和LED2
- en: Turn on LED1, LED2 and LED3
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮LED1、LED2和LED3
- en: Turn on LED1, LED2, LED3 and LED4
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮LED1、LED2、LED3和LED4
- en: Turn on LED1, LED2, LED3, LED4 and LED5
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮LED1、LED2、LED3、LED4和LED5
- en: Turn on LED1, LED2, LED3, LED4, LED5 and LED6
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮LED1、LED2、LED3、LED4、LED5和LED6
- en: Turn on LED1, LED2, LED3, LED4, LED5, LED6 and LED7
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮LED1、LED2、LED3、LED4、LED5、LED6和LED7
- en: Turn on LED1, LED2, LED3, LED4, LED5, LED6, LED7 and LED8
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮LED1、LED2、LED3、LED4、LED5、LED6、LED7和LED8
- en: Turn on LED1, LED2, LED3, LED4, LED5, LED6, LED7, LED8 and LED9
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮LED1、LED2、LED3、LED4、LED5、LED6、LED7、LED8和LED9
- en: The following lines show the Python code that performs the previously explained
    actions. The code file for the sample is `iot_python_chapter_03_02.py`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行之前解释的操作的Python代码。示例的代码文件为`iot_python_chapter_03_02.py`。
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we transfer the file to the board, we can run the previous code with the
    following command on the board''s SSH terminal:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将文件传输到板上，我们就可以在板上的SSH终端使用以下命令运行之前的代码：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have used many `print` statements to make it easy for us to understand what
    is going on with messages on the console. The following lines show the generated
    output after we run the code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了多个`print`语句，以便通过控制台上的消息使我们更容易理解正在发生的事情。以下行显示了运行代码后生成的输出：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The following nine pictures show the sequence of LEDs that are turned on in
    the breadboard by executing the Python code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下九张图片展示了通过执行Python代码在面包板上依次点亮LED灯的序列。
- en: '![Counting from 1 to 9 with LEDs, Python code and the mraa library](img/B05042_03_17.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![使用LED灯从1计数到9的Python代码和mraa库](img/B05042_03_17.jpg)'
- en: 'First, the code declares an empty list named `output`. Then, a `for` loop creates
    nine instances of the `mraa.Gpio` class and each of them represent a general purpose
    Input/Output pin on the board. We pass `i` as an argument for the `pin` parameter,
    and therefore, each instance represents the pin number equal to `i` of the GPIO
    pins in the board. After we create the instance, we call the `dir` method to configure
    the pin to be an output pin, that is, to set is direction to the `mraa.DIR_OUT`
    value. Then we call the `append` method for the `output` list to add the `mraa.Gpio`
    instance (`gpio`) to the output list. It is important to understand that `range(1,
    10)` generates the following list: `[1, 2, 3, 4, 5, 6, 7, 8, 9]`. Thus, our `for`
    loop will start with `i` equal to 1 and its last iteration will be with `i` equal
    to 9.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码声明了一个名为`output`的空列表。然后，一个`for`循环创建了九个`mraa.Gpio`类的实例，每个实例代表板上的一个通用输入/输出引脚。我们将`i`作为`pin`参数的参数传递，因此每个实例代表GPIO引脚的编号等于`i`。创建实例后，我们调用`dir`方法将引脚配置为输出引脚，即将其方向设置为`mraa.DIR_OUT`值。然后我们调用`append`方法将`mraa.Gpio`实例（`gpio`）添加到输出列表中。重要的是要理解`range(1,
    10)`生成以下列表：`[1, 2, 3, 4, 5, 6, 7, 8, 9]`。因此，我们的`for`循环将从`i`等于1开始，其最后一次迭代将是`i`等于9。
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Another `for` loop determines the number of LEDs to be turned on. We use `range(1,
    10)` to generate the same list than in the previous loop. The first line within
    the `for` loop calls a `print` method to display the number of LEDs that we are
    going to turn on in the iteration. A loop within the loop uses `range(0, i)` to
    generate the list of indexes of the elements in the `output` list that we have
    to turn on for the iteration of the main `for` loop (`i`).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`for`循环确定要点亮的LED灯数量。我们使用`range(1, 10)`生成与上一个循环相同的列表。`for`循环内的第一行调用`print`方法来显示在迭代中将要点亮的LED灯的数量。循环内的循环使用`range(0,
    i)`生成`output`列表中要点亮的元素的索引列表，这是主`for`循环迭代(`i`)的一部分。
- en: The inner loop uses `j` as its variable and the code within this inner loop
    just calls the `write` method for each `mraa.Gpio` instance, `output[j]`, with
    `1` as an argument for the `value` required parameter. This way, we send a high
    value (`1`) to the pin that is equal to `j + 1`, configured for digital output.
    If `j` is equal to 0, the first element of the output list is the `mraa.Gpio`
    instance that is configured for pin 1 (`j + 1`). Because each pin from 1 to 9
    has an LED connected to it, the result of a high value in one or more pins are
    LEDs turned on. Then, the code prints a message indicating the LED number that
    has been turned on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 内层循环使用`j`作为其变量，内层循环中的代码只是为每个`mraa.Gpio`实例，`output[j]`，调用`write`方法，并将`1`作为`value`必需参数的参数。这样，我们向等于`j
    + 1`的引脚发送高值（`1`），该引脚配置为数字输出。如果`j`等于0，输出列表的第一个元素是配置为引脚1（`j + 1`）的`mraa.Gpio`实例。因为从1到9的每个引脚都连接了一个LED，所以一个或多个引脚上的高值将导致LED打开。然后，代码打印一条消息，指示已打开的LED编号。
- en: Once the inner loop finishes, a call to `time.sleep` with `3` as the value for
    the `seconds` argument delays the execution for three seconds. This way, the LED
    or LEDs stay turned on during this delay before the outer loop performs another
    iteration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 内层循环完成后，调用`time.sleep`并使用`3`作为`seconds`参数的值，将执行延迟三秒钟。这样，LED或LEDs在延迟期间保持打开状态，然后外层循环执行另一个迭代。
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The following picture shows the console output printed on an SSH terminal in
    a laptop, the 9 LEDs turned on in the protoboard connected to the board that is
    running Python code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了在笔记本电脑的SSH终端上打印的控制台输出，连接到运行Python代码的板的电路板上9个LED打开。
- en: '![Counting from 1 to 9 with LEDs, Python code and the mraa library](img/B05042_03_26.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![使用LED从1计数到9，Python代码和mraa库](img/B05042_03_26.jpg)'
- en: Taking advantage of object-oriented code to control digital outputs
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用面向对象代码控制数字输出
- en: The previous example just turns on the LEDs. Thus, in case we want to count
    in a reverse order, that is, from 9 to 1, the results are not going to be as expected.
    After the code turns on 9 LEDs, the code will turn on 8 LEDs but there are still
    going to be 9 LEDs turned. The problem is that we never turn off the LEDs that
    we don't need to be turned on, and therefore the 9 LEDs will stay on until the
    edited loop finishes its execution.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例只是打开了LED。因此，如果我们想按逆序计数，即从9到1，结果将不会如预期。代码打开9个LED后，代码将打开8个LED，但仍然会有9个LED打开。问题是我们从未关闭不需要打开的LED，因此9个LED将保持打开状态，直到编辑的循环执行完毕。
- en: We are always talking about LEDs turning on and turning off LEDs. However, we
    have been using just instanced of the `mraa.Gpio` class and called the `write`
    method. Python is an object-oriented programming language, and therefore, we can
    definitely take advantage of its object-oriented features to write reusable, easier
    to understand and simpler to maintain code. For example, in this case, it makes
    a lot of sense to create an `Led` class to represent an LED connected to our board.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在谈论打开LED和关闭LED。然而，我们一直在使用`mraa.Gpio`类的实例并调用`write`方法。Python是一种面向对象的编程语言，因此我们可以充分利用其面向对象的功能来编写可重用、易于理解和易于维护的代码。例如，在这种情况下，创建一个`Led`类来表示连接到我们的板上的LED非常有意义。
- en: The following lines show the code for the new `Led` class. The code file for
    the sample is `iot_python_chapter_03_03.py`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了新`Led`类的代码。示例的代码文件为`iot_python_chapter_03_03.py`。
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have to specify the pin number to which the LED is connected when we create
    an instance of the `Led` class in the `pin` required argument. The constructor,
    that is, the `__init__` method, creates a new `mraa.Gpio` instance with the received
    `pin` as its `pin` argument, saves its reference in the `gpio` attribute and calls
    its `dir` method to configure the pin to be an output pin.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`pin`必需参数中创建`Led`类的实例时，我们必须指定LED连接的引脚号。构造函数，即`__init__`方法，使用接收到的`pin`作为其`pin`参数创建一个新的`mraa.Gpio`实例，将其引用保存在`gpio`属性中，并调用其`dir`方法来配置引脚为输出引脚。
- en: 'The class defines the following two methods:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了以下两个方法：
- en: '`turn_on`: Calls the `write` method for the related `mraa.Gpio` instance to
    send a high value (1) to the pin and turn on the LED connected to this pin. Then,
    it prints a message with details about the performed action.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`turn_on`：调用相关`mraa.Gpio`实例的`write`方法，向引脚发送高值（1）并打开连接到此引脚的LED。然后，它打印一条包含执行动作详细信息的消息。'
- en: '`turn_off`: Calls the `write` method for the related `mraa.Gpio` instance to
    send a low value (0) to the pin and turn off the LED connected to this pin. Then,
    it prints a message with details about the performed action.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`turn_off`：调用相关`mraa.Gpio`实例的`write`方法，向引脚发送低值（0）并关闭连接到该引脚的LED灯。然后，它打印一条包含执行动作详细信息的消息。'
- en: Now, we can write code that uses the new `Led` class to create the necessary
    instances based on the number of LEDs we want to control and the pins to which
    they are connected. The following lines show an improved version of the code that
    uses the new `Led` class to count from 1 to 9 with the LEDs. The code file for
    the sample is `iot_python_chapter_03_03.py`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写使用新`Led`类的代码，根据我们想要控制的LED灯数量和它们连接的引脚来创建必要的实例。以下行显示了使用新`Led`类从1到9计数并使用LED灯的改进代码版本。示例代码文件为`iot_python_chapter_03_03.py`。
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, the code declares an empty list named `leds`. Then, a `for` loop creates
    nine instances of the `Led` class and each of them represent an LED connected
    to a GPIO pin on the board. We pass `i` as an argument for the `pin` parameter.
    Then, we call the `append` method for the `leds` list to add the `Led` instance
    (`led`) to the `leds` list. Our `for` loop will start with `i` equal to 1 and
    its last iteration will be with `i` equal to 9.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码声明了一个名为`leds`的空列表。然后，一个`for`循环创建了9个`Led`类的实例，每个实例代表连接到板上GPIO引脚的一个LED灯。我们将`i`作为`pin`参数的参数传递。然后，我们调用`leds`列表的`append`方法将`Led`实例（`led`）添加到`leds`列表中。我们的`for`循环将从`i`等于1开始，其最后一次迭代将是`i`等于9。
- en: Another `for` loop determines the number of LEDs to be turned on. We use `range(1,
    10)` to generate the same list than in the previous loop. The first line within
    the `for` loop calls a `print` method to display the number of LEDs that we are
    going to be turned on in the iteration.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`for`循环确定要开启的LED灯数量。我们使用`range(1, 10)`来生成与上一个循环相同的列表。`for`循环中的第一行调用`print`方法来显示在迭代中将要开启的LED灯数量。
- en: An inner loop within the loop uses `range(0, i)` to generate the list of indexes
    of the elements in the `leds` list that we have to turn on for the iteration of
    the main `for` loop (`i`). The inner loop uses `j` as its variable and the code
    within this inner loop just calls the `turn_on` method for each `Led` instance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 循环内的内循环使用`range(0, i)`来生成`leds`列表中要开启的元素的索引列表，以便在主`for`循环的迭代中（`i`）。内循环使用`j`作为其变量，并且这个内循环中的代码只是调用每个`Led`实例的`turn_on`方法。
- en: Another inner loop wihin the loop uses `range(i, 9)` to generate the list of
    indexes of the elements in the `leds` list that we have to turn off for the iteration
    of the main `for` loop (`i`). The inner loop uses `k` as its variable and the
    code within this inner loop just calls the `turn_off` method for each `Led` instance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 循环内的另一个内循环使用`range(i, 9)`来生成`leds`列表中要关闭的元素的索引列表，以便在主`for`循环的迭代中（`i`）。内循环使用`k`作为其变量，并且这个内循环中的代码只是调用每个`Led`实例的`turn_off`方法。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The code is easier to understand than the previous version and the `Led` class
    handles everything related to an LED. We can easily understand that the line that
    calls the `turn_on` method for `leds[j]` is turning on an LED. We definitely know
    that an LED is being turned off in the line that calls the `turn_off` method for
    `leds[k]`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个版本相比，代码更容易理解，`Led`类处理与LED灯相关的所有事情。我们可以轻松理解调用`leds[j]`的`turn_on`方法的行是在开启一个LED灯。我们肯定知道在调用`leds[k]`的`turn_off`方法的行中，一个LED灯正在关闭。
- en: As the new code turns off the LEDs that don't have be turned on, we can easily
    create a new version that counts from 9 to 1 by changing one line. The following
    lines show the new version of the code that works with the `Led` class to count
    from 9 to 1 with the LEDs. The only line that had to be edited is the highlighted
    one. The code file for the sample is `iot_python_chapter_03_04.py`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新代码关闭了不需要开启的LED灯，我们可以轻松地通过更改一行来创建一个从9倒数到1的新版本。以下行显示了使用`Led`类从9倒数到1并使用LED灯的新代码版本。需要编辑的唯一一行是高亮显示的那一行。示例代码文件为`iot_python_chapter_03_04.py`。
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Improving our object-oriented code to provide new features
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们的面向对象代码以提供新功能
- en: Now that we have our counter working with the LEDs connected to the board, we
    want to add new features. We want to be able to easily transform a number between
    1 and 9 into its representation in LEDs connected to the board.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让计数器与连接到板上的LED灯正常工作，我们想要添加新功能。我们希望能够轻松地将1到9之间的数字转换为其连接到板上的LED灯的表示形式。
- en: The following lines show the code for the new `NumberInLeds` class. The code
    file for the sample is `iot_python_chapter_03_05.py`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了新`NumberInLeds`类的代码。示例的代码文件为`iot_python_chapter_03_05.py`。
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The constructor, that is, the `__init__` method, declares an empty list attribute
    named `leds` (`self.leds`). Then, a `for` loop creates nine instances of the `Led`
    class and each of them represent an LED connected to a GPIO pin on the board.
    We pass `i` as an argument for the `pin` parameter. Then, we call the `append`
    method for the `self.leds` list to add the `Led` instance (`led`) to the `self.leds`
    list. Our `for` loop will start with `i` equal to 1 and its last iteration will
    be with `i` equal to 9.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数，即`__init__`方法，声明了一个名为`leds`的空列表属性（`self.leds`）。然后，一个`for`循环创建了九个`Led`类的实例，每个实例代表连接到板上GPIO引脚的一个LED。我们将`i`作为`pin`参数的参数传递。然后，我们调用`self.leds`列表的`append`方法将`Led`实例（`led`）添加到`self.leds`列表中。我们的`for`循环将从`i`等于1开始，其最后一次迭代将是`i`等于9。
- en: The class defines a `print_number` method that requires the number that we want
    to represent with LEDs turned on in the `number` argument. The method uses a `for`
    loop with `j` as its variable to turn on the necessary LEDs by accesing the appropriate
    members of the `self.leds` list and calling the `turn_on` method. Then, the method
    uses another `for` loop with `k` as its variable to turn off the remaining LEDs
    by accesing the appropriate members of the `self.leds` list and calling the `turn_off`
    method. This way, the method makes sure that only the LEDs that have to be turned
    on are really turned on and the rest of them are turned off.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了一个`print_number`方法，该方法需要一个数字作为`number`参数，我们希望用LED点亮来表示这个数字。该方法使用一个`for`循环，其中`j`作为其变量，通过访问`self.leds`列表的适当成员并调用`turn_on`方法来点亮必要的LED。然后，该方法使用另一个`for`循环，其中`k`作为其变量，通过访问`self.leds`列表的适当成员并调用`turn_off`方法来关闭剩余的LED。这样，该方法确保只有需要点亮的LED真正点亮，其余的LED都关闭。
- en: Now, we can write code that uses the new `NumberInLeds` class to count from
    0 to 9 with the LEDs. In this case, we start with 0 because the new class is able
    to turn off all the LEDs that shouldn't be turned on to represent a specific number.
    The code file for the sample is `iot_python_chapter_03_05.py`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写使用新`NumberInLeds`类来使用LED从0到9计数的代码。在这种情况下，我们从0开始，因为新类能够关闭所有不应该点亮的LED来表示特定的数字。示例的代码文件为`iot_python_chapter_03_05.py`。
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code is very easy to understand, we just create an instance of the `NumberInLeds`
    class, named `number_in_leds`, and then we call its `print_number` method with
    `i` as its argument within the `for` loop.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常容易理解，我们只需创建一个名为`number_in_leds`的`NumberInLeds`类实例，然后在`for`循环中将其`print_number`方法作为参数调用`i`。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We took advantage of Python's object-oriented features to create classes that
    represent the LEDs and the generation of numbers with LEDs. This way, we wrote
    higher level code that is easier to understand because we don't just read code
    that writes 0s and 1s to specific pin numbers, we can read code that prints numbers
    in LEDs, turns on and turns off LEDs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用Python的面向对象特性来创建代表LED和LED生成数字的类。这样，我们编写了更高级别的代码，更容易理解，因为我们不仅读取将0和1写入特定引脚号的代码，我们还可以读取打印LED上数字的代码，以及打开和关闭LED的代码。
- en: Isolating the pin numbers to improve wirings
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将引脚号隔离以改善布线
- en: Obviously, it is easy to turn on the LED that represents number 1 when it is
    connected to GPIO pin number 1\. In our previous wiring, the LED that represented
    each number was connected to the same GPIO pin number. The schema was also very
    easy to understand with the connections where the LED number matched the pin number.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当连接到GPIO引脚1时，点亮表示数字1的LED很容易。在我们之前的布线中，代表每个数字的LED都连接到相同的GPIO引脚号。该电路图也很容易理解，因为LED编号与引脚编号相匹配。
- en: However, the wirings between the board and the breadboard were a bit complicated
    because the GPIO pins in the board go from 13 down to 1, from left to right. The
    breadboard has the LEDs in the opposite direction, that is, from 1 to 9, left
    to right. Thus, the wire that connect the GPIO pin number 1 with LED number 1
    has to go from right to left and crosses the other jumper wires. We will change
    the jumper wires to improve our wiring and then we will make the necessary changes
    to our object-oriented Python code to isolate the pin numbers and make it possible
    to have a nicer wiring. Don't forget to shutdown the operating system and unplug
    the power supply from the board before you make changes to the wirings.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，板子和面包板之间的连接有点复杂，因为板上的GPIO引脚从13向下到1，从左到右。面包板上的LED方向相反，即从1到9，从左到右。因此，连接GPIO引脚编号1和LED编号1的线必须从右到左，并穿过其他跳线。我们将更改跳线以改进我们的布线，然后我们将对我们的面向对象的Python代码进行必要的更改，以隔离引脚编号，使其布线更美观。在更改布线之前，不要忘记关闭操作系统并从板上拔掉电源。
- en: The following diagram shows the components connected to the breadboard and the
    new wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing
    file for the sample is `iot_fritzing_chapter_03_06.fzz` and the following picture
    is the breadboard view.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了连接到面包板和从Intel Galileo Gen 2板到面包板的新布线的组件。示例的Fritzing文件是`iot_fritzing_chapter_03_06.fzz`，以下图片是面包板视图。
- en: '![Isolating the pin numbers to improve wirings](img/B05042_03_27.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![隔离引脚编号以改进布线](img/B05042_03_27.jpg)'
- en: Now, whenever we want to turn on LED 1, we must write a high (1) value to GPIO
    pin number 9, whenever we want to turn on LED 2, we write a high (1) value to
    GPIO pin number 8, and so on. Because we changed the wirings, the schematic with
    the electronic components represented as symbols also changed. The following picture
    shows the new version of the schematic.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论何时我们想要打开LED 1，我们必须将GPIO引脚编号9写入高（1）值，无论何时我们想要打开LED 2，我们写入GPIO引脚编号8的高（1）值，依此类推。由于我们更改了布线，表示电子组件为符号的原理图也发生了变化。以下图片显示了新版本的原理图。
- en: '![Isolating the pin numbers to improve wirings](img/B05042_03_28.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![隔离引脚编号以改进布线](img/B05042_03_28.jpg)'
- en: The following lines show the new code for the `Led` class. The code file for
    the sample is `iot_python_chapter_03_06.py`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`Led`类的新代码。示例的代码文件是`iot_python_chapter_03_06.py`。
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we have to specify an additional parameter when we create an instance
    of the `Led` class: the `position` in the breadboard, that is the LED number in
    the breadboard. The constructor, that is, the `__init__` method, saves the `position`
    value in an attribute with the same name. Both the `turn_on` and `turn_off` methods
    use the `self.position` attribute value to print a message indicating the position
    of the LED that has been turned on or off. As the position doesn''t match the
    pin anymore, the message had to be improved to specify the position.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们创建`Led`类的实例时，必须指定一个额外的参数：面包板上的`position`，即面包板上的LED编号。构造函数，即`__init__`方法，将`position`值保存在具有相同名称的属性中。`turn_on`和`turn_off`方法都使用`self.position`属性值来打印一条消息，指示已打开或关闭的LED的位置。由于位置不再与引脚匹配，因此必须改进消息以指定位置。
- en: The following lines show the code for the new version of the `NumberInLeds`
    class. The code file for the sample is `iot_python_chapter_03_06.py`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了新版本的`NumberInLeds`类的代码。示例的代码文件是`iot_python_chapter_03_06.py`。
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It was necessary to make changes to the highlighted lines in the constructor,
    that is, the `__init__` method. The `for` loop that creates the nine instances
    of the `Led` class now starts with `i` equal to 9 and its last itearation will
    be with `i` equal to 1\. We pass `i` as an argument for the `pin` parameter and
    `10 – i` as an argument for the position `parameter`. This way, the first `Led`
    instance in the `self.leds` list will be the one with pin equal to 9 and position
    equal to 1.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，即`__init__`方法中，有必要对高亮显示的行进行修改。现在创建`Led`类九个实例的`for`循环从`i`等于9开始，其最后一次迭代将是`i`等于1。我们将`i`作为`pin`参数的参数传递，将`10
    – i`作为位置参数的参数传递。这样，`self.leds`列表中的第一个`Led`实例将是引脚等于9且位置等于1的实例。
- en: The code that uses the new version of the `NumberInLeds` class to count from
    0 to 9 with the LEDs is the same than the previous code. The code file for the
    sample is `iot_python_chapter_03_06.py`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新版本的`NumberInLeds`类从0到9计数并使用LED的代码与之前的代码相同。示例的代码文件是`iot_python_chapter_03_06.py`。
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We just needed to make a few changes in the class that encapsulates a LED (`Led`)
    and in the class that encapsulates a number represented with LEDs (`NumberInLeds`).
    The following picture shows the 9 LEDs turned on in the breadboard with the new
    wirings connected between the breadboard and the board that is running the new
    Python code running.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在封装 LED 的类（`Led`）和封装用 LED 表示的数字的类（`NumberInLeds`）中进行一些更改。以下图片显示了面包板上的 9
    个 LED 在新布线连接到运行新 Python 代码的板之间打开的情况。
- en: '![Isolating the pin numbers to improve wirings](img/B05042_03_29.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![隔离引脚编号以改善布线](img/B05042_03_29.jpg)'
- en: We can easily build an API and provide a REST API to allow any client that has
    connection to the board to be able to print numbers through HTTP. Our REST API
    just needs to create an instance of the `NumberInLeds` class and call the `print_number`
    method with the specified number to be printed with LEDs. We will build this REST
    API in the next chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松构建一个 API 并提供一个 REST API，允许任何连接到板的客户端能够通过 HTTP 打印数字。我们的 REST API 只需要创建一个
    `NumberInLeds` 类的实例，并使用指定的数字调用 `print_number` 方法来通过 LED 打印。我们将在下一章构建这个 REST API。
- en: Controlling digital outputs with the wiring-x86 library
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 wiring-x86 库控制数字输出
- en: One of the great advantages of working with Python as our programming language
    to interact with the board is that we have plenty of packages available for Python.
    We have been using the `mraa` library to interact with the digital outputs. However,
    in the previous chapter, we also installed the `wiring-x86` library. We can change
    just a few lines of our object-oriented code to replace the `mraa` library with
    the `wiring-x86` one to turn on and off the LEDs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 作为我们的编程语言与板交互的一个巨大优势是我们有大量的 Python 包可用。我们一直在使用 `mraa` 库与数字输出交互。然而，在上一章中，我们也安装了
    `wiring-x86` 库。我们只需更改几行面向对象的代码，用 `wiring-x86` 库替换 `mraa` 库来打开和关闭 LED。
- en: The following lines shows the code for a `Board` class followed by the new version
    of the `Led` class that works with the `wiring-x86` library instead of using `mraa`.
    The code file for the sample is `iot_python_chapter_03_07.py`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了 `Board` 类的代码，以及与 `wiring-x86` 库一起工作的 `Led` 类的新版本，而不是使用 `mraa`。示例代码文件为
    `iot_python_chapter_03_07.py`。
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `wiring-x86` library doesn't include automatic detection of the board, and
    therefore, it is necessary to use the class that represents our board. The GPIOGalileoGen2
    represents the Intel Galileo Gen 2 board, and therefore, the first line of code
    uses an `import` statement to import it as `GPIO` from `wiringx86`. This way,
    whenever we reference `GPIO`, we will be really using `wiringx86.GPIOGalileoGen2`.
    Notice that the library name is `wiring-x86` but the module name is `wiringx86`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`wiring-x86` 库不包括自动检测板的功能，因此，有必要使用代表我们板的类。`GPIOGalileoGen2` 代表英特尔 Galileo Gen
    2 板，因此，代码的第一行使用一个 `import` 语句将其导入为 `GPIO` 从 `wiringx86`。这样，每次我们引用 `GPIO` 时，我们实际上是在使用
    `wiringx86.GPIOGalileoGen2`。请注意，库的名称是 `wiring-x86`，但模块的名称是 `wiringx86`。'
- en: When we create an instance of the `Led` class, we have to specify the GPIO digital
    `pin` to which the LED is connected and the `position` in the breadboard, that
    is the LED number in the breadboard. The constructor, that is, the `__init__`
    method, saves a reference to the `Board.gpio` class attribute in `self.gpio` and
    calls its `pinMode` method with the received pin as its `pin` argument and `self.gpio.OUTPUT`
    as its `mode` argument. This way, we configure the pin to be an output pin. All
    the `Led` instances will save a reference to the same `Board.gpio` class attribute
    that created an instance of the `GPIO` class, specifically, the `wiringx86.GPIOGalileoGen2`
    class with its `debug` argument set to `False` to avoid unnecessary debug information
    for the low-level communications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `Led` 类的实例时，我们必须指定 LED 连接的 GPIO 数字 `pin` 和在面包板上的 `position`，即面包板上的 LED
    号码。构造函数，即 `__init__` 方法，将 `Board.gpio` 类属性引用保存到 `self.gpio` 中，并调用其 `pinMode` 方法，将接收到的引脚作为其
    `pin` 参数，将 `self.gpio.OUTPUT` 作为其 `mode` 参数。这样，我们配置引脚为输出引脚。所有的 `Led` 实例都将保存对创建
    `GPIO` 类实例的同一 `Board.gpio` 类属性的引用，特别是具有 `debug` 参数设置为 `False` 的 `wiringx86.GPIOGalileoGen2`
    类，以避免低级通信中的不必要调试信息。
- en: The `turn_on` method calls the `digitalWrite` method for the GPIO instance to
    send a high value (`self.GPIO.HIGH`) to the pin specified by the `self.pin` attribute
    value and prints a message about the performed action.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`turn_on`方法调用GPIO实例的`digitalWrite`方法，将高值（`self.GPIO.HIGH`）发送到由`self.pin`属性值指定的针脚，并打印关于执行动作的消息。'
- en: The `turn_off` method calls the `digitalWrite` method for the GPIO instance
    to send a low value (`self.GPIO.LOW`) to the pin specified by the `self.pin` attribute
    value and prints a message about the performed action.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`turn_off`方法调用GPIO实例的`digitalWrite`方法，将低值（`self.GPIO.LOW`）发送到由`self.pin`属性值指定的针脚，并打印关于执行动作的消息。'
- en: The code for the `NumberInLeds` class remains the same one that we have used
    for the previous example. There is no need to make changes to this class because
    it will automatically work with the new `Led` class and there were no changes
    in the arguments for its constructor or its two methods. We just need to replace
    the lines that printed information about the `mraa` library in the `__main__`
    method because we aren't using the `mraa` library anymore.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberInLeds`类的代码与之前示例中使用的相同。无需对此类进行更改，因为它将自动与新`Led`类一起工作，并且其构造函数或两个方法的参数没有发生变化。我们只需替换`__main__`方法中打印有关`mraa`库信息的行，因为我们不再使用`mraa`库。'
- en: The following lines shows the code for the `NumberInLeds` class and the `__main__`
    method. The code file for the sample is `iot_python_chapter_03_07.py`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`NumberInLeds`类和`__main__`方法的代码。示例的代码文件为`iot_python_chapter_03_07.py`。
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We just needed to change a few lines of code and we can see how the Python code
    makes LEDs in the breadboard count from 0 to 9 using the `wiring-x86` library.
    The way in which we work with the GPIO pins for digital output with this library
    is a bit different from the mechanism used in the `mraa` library. However, we
    could easily encapsulate the changes by taking advantage of Python's object-oriented
    features. We can decide which library is more convenient for our projects based
    on our preferences and needs. It is always a nice idea to have more than just
    one option.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需更改几行代码，就可以看到Python代码如何使用`wiring-x86`库在面包板上使LED从0计数到9。我们使用此库与GPIO针脚进行数字输出的方式与`mraa`库中使用的机制略有不同。然而，我们可以通过利用Python的面向对象特性轻松封装这些更改。我们可以根据自己的喜好和需求决定哪个库更适合我们的项目。拥有不止一个选项总是一个好主意。
- en: Test your knowledge
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'When we send a high value (1) to a GPIO pin configured as output, the GPIO
    pin will have:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将高值（1）发送到配置为输出的GPIO针脚时，该GPIO针脚将具有：
- en: 0 V.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0 V。
- en: 6 V.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6 V。
- en: The voltage specified in the position in which the IOREF jumper is located.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: IOREF跳线所在位置的电压值。
- en: 'An instance of the `mraa.Gpio` class represents:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mraa.Gpio`类的实例表示：'
- en: A single GPIO pin in the board.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 板上单个GPIO针脚。
- en: All the I/O pins in the board.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 板上的所有I/O针脚。
- en: Two GPIO pins in the board.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 板上的两个GPIO针脚。
- en: 'When we create an instance of the `mraa.Gpio` class, we must specify:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建`mraa.Gpio`类的实例时，我们必须指定：
- en: The pin number as an argument.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 针脚号作为参数。
- en: The specific board and a pin number as arguments.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具体的板和针脚号作为参数。
- en: 'The pin number and the desired direction: `mraa.DIR_OUT` or `mraa.DIR_IN`.'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 针脚号和期望的方向：`mraa.DIR_OUT` 或 `mraa.DIR_IN`。
- en: 'Which of the following lines write a high value to the GPIO pin configured
    as output with the instance of `mraa.Gpio` named `gpio10`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行将高值写入配置为输出的GPIO针脚的`mraa.Gpio`实例名为`gpio10`：
- en: '`gpio10.write(0)`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gpio10.write(0)`'
- en: '`gpio10.write(1)`'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gpio10.write(1)`'
- en: '`gpio10.write(mraa.HIGH_VALUE)`'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gpio10.write(mraa.HIGH_VALUE)`'
- en: 'Which of the following lines configure the instance of `mraa.Gpio` named `gpio10`
    for digital output:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行配置了名为`gpio10`的`mraa.Gpio`实例以进行数字输出：
- en: '`gpio10.dir(mraa.DIR_DIGITAL).out()`'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gpio10.dir(mraa.DIR_DIGITAL).out()`'
- en: '`gpio10.dir(mraa.DIR_OUT)`'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gpio10.dir(mraa.DIR_OUT)`'
- en: '`gpio10.dir(mraa.DIR_OUT, mraa.DIGITAL)`'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gpio10.dir(mraa.DIR_OUT, mraa.DIGITAL)`'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we worked with Python with two different libraries: `mraa`
    and `wiring-x86`. We connected LEDs and resistors to a breadboard and we wrote
    code to turn on from 0 to 9 LEDs. We improved our Python code to take advantage
    of Python''s object-oriented features and we prepared the code to make it easy
    to build an API that will allow us to print numbers with LEDs with a REST API.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Python与两个不同的库：`mraa`和`wiring-x86`。我们将LED和电阻连接到面包板上，并编写了代码来从0到9点亮LED。我们改进了Python代码，以利用Python的面向对象特性，并准备了代码，使其易于构建一个REST
    API，允许我们使用LED打印数字。
- en: Now that we finished our first wirings and we started controlling the board
    with Python, we can start working with additional outputs and combine them with
    a REST API, which is the topic of the next chapter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了第一次布线，并开始用Python控制板，我们可以开始使用额外的输出，并将它们与REST API结合，这是下一章的主题。
