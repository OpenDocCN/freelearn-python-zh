- en: Chapter 3. Interacting with Digital Outputs with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with digital inputs with Python and two libraries:
    `mraa` and `wiring-x86`. We shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Wire our first connections between an Intel Galileo Gen 2 and a breadboard with
    electronic components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a first version of a Python script that turns on and off electronic components
    connected to the board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfer Python code to the Yocto Linux running on the board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute Python scripts that interact with the board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to take advantage of Python's object-oriented features to improve the
    code and make it easier to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare the code to make it easy to build an API that will allow us to interact
    with the IoT device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning on and off an onboard component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will take advantage of an onboard LED (Light Emitting Diode) to write
    our first Python lines that interact with the digital output capabilities included
    in the Intel Galileo Gen 2 board. The simple example will allow us to understand
    how the `mraa` library allows us to easily turn on and off one of the onboard
    components with Python code.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we recognized the different elements included in the
    Intel Galileo Gen 2 board. We know that there are three rectangular LEDs located
    at the right hand side of the USB 2.0 host connector. The first LED, labeled **L**
    is connected to pin 13 of the digital I/O pins, and therefore, a high level sent
    to pin 13 will turn on this LED and a low level will turn it off.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a few lines of Python code that will use the `mraa` library to
    make the onboard LED labeled **L** to repeat the following loop until the Python
    program is interrupted:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stay turned on for 3 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stay turned off for 2 seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lines show the Python code that performs the previously explained
    actions. The code file for the sample is `iot_python_chapter_03_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book. Please have a look.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Internet-of-Things-with-Python](https://github.com/PacktPublishing/Internet-of-Things-with-Python).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned that the Yocto Linux running on the board
    provided both **SSH** and **SFTP** (short for **SSH File Transfer Protocol** or
    **Secure File Transfer Protocol**) services by running a Bonjour browser. We can
    use any SFTP client to connect to the board and transfer the file that we created
    in any computer or mobile device. Of course, we can also use any Linux editor,
    such as `vi`, in the SSH terminal, or just enter the code in the Python interpreter.
    However, it is usually more convenient to use our favorite editor or IDE in our
    computer or mobile device and then transfer the file to the board with any SFTP
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some Python IDEs have remote development capabilities and allow us to easily
    transfer the necessary files and launch their execution on the board. An example
    is the paid Professional Edition of JetBrains PyCharm. Unluckily, the Community
    Edition doesn't include this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t want the process to be linked to a specific IDE, and therefore, we
    will transfer the file with an SFTP client. FileZilla Client is a free, open source
    and multiplatform FTP client that supports SFTP. You can download and install
    it here: [http://filezilla-project.org](http://filezilla-project.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed and executed FileZilla Client, you must follow the
    next steps to add the SFTP server running on the board in with the application''s
    Site Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File** | **Site Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **New Site** on the **Site Manager** dialog box. Enter the desired name,
    such as **IntelGalileo2** to easily identify the board's SFTP service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the board''s IP address in **Host**. You don''t need to enter any value
    in **Port** because the SFTP server uses the default SFTP port, that is, the same
    port in which the SSH daemon listens: port 22.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **SFTP - SSH File Transfer Protocol** in the Protocol dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Normal** in the **Logon Type** dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **root** in **User**. The next screenshots shows the configuration values
    for a board that has **192.168.1.107** as its assigned IP address.![Turning on
    and off an onboard component](img/B05042_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Connect**. FileZilla will display an Unknown host key dialog box, indicating
    that the server's host key is unknown. It is similar to the information provided
    when you established the first connection to the board with an SSH client. The
    details include the host and the fingerprint. Activate the **Always trust this
    host, add this key to the cache** checkbox and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FileZilla will display the `/home/root` folder for the Yocto Linux running on
    the board at the right-hand side of the window, under **Remote Site**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the folder in which you saved the Python files you want to transfer
    in your local computer under **Local site**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the file you want to transfer and press *Enter* to transfer the file
    to the `/home/root` folder on the board. Another way is to right-click on the
    desired file and select **Upload**. FileZilla will display the uploaded file in
    the `/home/root` folder under **Remote Site**. This way, you will be able to access
    the Python file in the default location that Yocto Linux uses when you login with
    an SSH terminal, that is, in your home folder for your `root` user. The following
    picture shows many Python files uploaded to the `/home/root` folder with FileZilla
    and listed in the contents of the `/home/root` folder.![Turning on and off an
    onboard component](img/B05042_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you work with additional projects, you will want to create new folders under
    `/home/root` to provide a better organization for your Python code in the Yocto
    Linux filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The next time you have to upload a file to the board, you don't need to setup
    a new site in the **Site Manager** dialog box in order to establish an SFTP connection.
    You just need to select **File** | **Site Manager**, select the site name under
    **Select Entry** and click **Connect**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the following command in the SSH terminal after you login, Linux
    will print your current folder or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result of the previous command will be the same folder in which we uploaded
    the Python code file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we transfer the file to the board, we can run the previous code with the
    following command on the board''s SSH terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is extremely simple. We have used many print statements to
    make it easy for us to understand what is going on with messages on the console.
    The following lines show the generated output after we run the code for a few
    seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first lines print the `mraa` library version and the detected platform
    name. This way, we have information about the `mraa` library version that Python
    is using and we make sure that the `mraa` library has been able to initialize
    itself and detect the right platform: Intel Galileo Gen 2\. In case we have a
    specific issue, we can use this information to check about specific problems related
    to the `mraa` library and the detected platform.'
  prefs: []
  type: TYPE_NORMAL
- en: The next line creates an instance of the `mraa.Gpio` class. **GPIO** stands
    for **General Purpose Input/Output** and an instance of the `mraa.Gpio` class
    represents a general purpose Input/Output pin on the board. In this case, we pass
    `13` as an argument for the `pin` parameter, and therefore, we are creating an
    instance of the `mraa.Gpio` class that represents the pin number 13 of the GPIO
    pins in the board. We named the instance `onboard_led` to make it easy to understand
    that the instance allows us to control the status of the onboard LED.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We just need to specify the value for the pin parameter to initialize an instance
    of the `mraa.Gpio` class. There are two additional optional parameters (`owner`
    and `raw`), but we should leave them with the default values. By default, whenever
    we create an instance of the `mraa.Gpio` class, we own the pin and the `mraa`
    library will close it on destruct.
  prefs: []
  type: TYPE_NORMAL
- en: As we might guess from its name, an instance of the `mraa.Gpio` class allows
    us to work with pins as either Input or Output. Thus, it is necessary to specify
    the desired direction for our `mraa.Gpio` instance. In this case, we want to use
    pin 13 as an output pin. The following line calls the `dir` method to configure
    the pin to be an output pin, that is, to set is direction to the `mraa.DIR_OUT`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, the code runs a loop forever, that is, until you interrupt the execution
    by pressing *Ctrl* + *C* or the button to stop the process in case you are using
    a Python IDE with remote development features to run the code in your board.
  prefs: []
  type: TYPE_NORMAL
- en: The first line within the `while` loop calls the `write` method for the `mraa.Gpio`
    instance, `onboard_led`, with `1` as an argument for the `value` required parameter.
    This way, we send a high value (`1`) to the pin 13 configured for digital output.
    Because the pin 13 has the onboard LED connected to it, the result of a high value
    in pin 13 is that the onboard LED turns on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After we turn on the LED, a line of code uses the `print` statement to print
    a message to the console output, so that we know the LED should be turned on.
    A call to `time.sleep` with `3` as the value for the `seconds` argument delays
    the execution for three seconds. Because we didn't change the status of pin 13,
    the LED will stay turned on during this delay.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The next line calls the `write` method for the `mraa.Gpio` instance, `onboard_led`,
    but this time with `0` as an argument for the `value` required parameter. This
    way, we send a low value (`0`) to the pin 13 configured for digital output. Because
    the pin 13 has the onboard LED connected to it, the result of a low value in pin
    13 is that the onboard LED turns off.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After we turn off the LED, a line of code uses the `print` statement to print
    a message to the console output, so that we know the LED should be turned off.
    A call to `time.sleep` with `2` as the value for the seconds argument delays the
    execution for 2 seconds. Because we didn't change the status of pin 13, the LED
    will stay turned off during this delay. Then, the loop starts over again.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we can use any `ssh` client to run the Python code, we can see the results
    of the `print` statements in the console output and they are extremely useful
    for us to understand what should be happening with the digital outputs. We will
    take advantage of more advanced logging features included in Python for more complex
    scenarios later.
  prefs: []
  type: TYPE_NORMAL
- en: As we could learn from the previous example, the `mraa` library encapsulates
    all the necessary methods to work with the GPIO pins in the `mraa.Gpio` class.
    The previous code didn't take advantage of Python's object-oriented features,
    it just interacted with one of the classes included in the `mraa` library. We
    will take advatange of many Python features in the forthcoming examples. In addition,
    once we start working with more complex examples, we will make the board interact
    through the network.
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping with breadboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we interacted with the onboard LED, and therefore,
    we didn't wire any additional electronic component to the board. Now, it is time
    to move to more complex samples in which we will have to start working with additional
    components and tools.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to create a new printed circuit board (PCB) and solder electronic
    components to the board each time we want to wire some electronic components to
    the board. We will be prototyping many electronics projects throught the book
    and we will also continue prototyping after we learn each lesson towards our IoT
    adventure. Thus, we will use a solderless breadboard as our construction base
    for our electronic prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Solderless breadboards are also known as breadboards, solderless plug-in breadboards
    or prototype boards. We will call them with their shortests name: breadboards.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use an 830 tie points (holes for connections) with 2 power lanes breadboard
    for all our prototypes that require electronic components wired to the board.
    The following picture shows this kind of breadboard that consists of a chunk of
    plastic of approximately 6.5" x 2.1" with a bunch number of holes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototyping with breadboards](img/B05042_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next picture shows the internal connections for an 830 tie points with 2
    power lanes breadboard. There are metal strips inside the breadboard that connect
    the holes as shown in this picture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototyping with breadboards](img/B05042_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The breadboard provides two power lanes, bus strips or horizontal buses at the
    top and at the bottom of the board. These power lanes connect all the holes within
    the row. Each column has five row holes connected.
  prefs: []
  type: TYPE_NORMAL
- en: However, we must be careful because there are similar breadboards that break
    the power lanes or horizontal buses in the middle, and therefore, the power lanes
    don't connect all the holes within the row. The following picture shows the connections
    for these kinds of breadboards.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototyping with breadboards](img/B05042_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In case you decide to work with this kind of breadboard, you have to make the
    following connections to the buses. This way, you will mimic the wires shown for
    the first breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototyping with breadboards](img/B05042_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can stick wire ends without insulation into the breadboard holes in order
    to wire elements. It is convenient to prepare jumper wires with different lengths
    and using cables with diverse colors. The following picture shows many cables
    of different lengths without their insulation that will work as jumper wires.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototyping with breadboards](img/B05042_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In case we don't want to spend time building our own jumper wires, we can buy
    prebuilt male to male solderless flexible breadboard jumper wires with tiny plugs
    attached to the wire ends.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use any of the previously explained options to make the necessary connections
    for each of the examples in which we will be working throught this book. In case
    you decide to use male to male breadboard jumper wires, make sure they are high
    quality ones.
  prefs: []
  type: TYPE_NORMAL
- en: Working with schematics to wire digital outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is time to take advantage of the prototyping capabilities of the breadboard
    and start working on a more complex example. We will turn on and off 9 LEDs by
    using 9 digital outputs of the Intel Galileo Gen 2 board. Each digital output
    is going to control whether an LED is turned on or turned off.
  prefs: []
  type: TYPE_NORMAL
- en: After we finish the necessary wirings, we will write Python code that counts
    from 1 to 9 by controlling the digital output to turn on the necessary number
    of LEDs. In this case, our first approach won't be the best one. However, after
    we learn many things, we will create new versions and we will improve both the
    initial prototype and the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the following parts to work with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: Three red ultrabright 5mm LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three white ultrabright 5mm LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three green ultrabright 5mm LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nine 270Ω resistors with 5% tolerance (red violet brown gold)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_03_02.fzz` and the following
    picture is the breadboard view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with schematics to wire digital outputs](img/B05042_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we decided to match the GPIO pin number with the LED number. This
    way, whenever we want to turn on LED 1, we write a high (1) value to GPIO pin
    number 1, whenever we want to turn on LED 2, we write a high (1) value to GPIO
    pin number 2, and so on. Later, we will realize it is not the best decision because
    the wiring becomes a bit more complex than expected due to the positions of the
    pins in the board. However, we will analyze this situation later and we will create
    a new version of this example with improvements based on everything we learned
    from the first version.
  prefs: []
  type: TYPE_NORMAL
- en: The following picture shows the schematic with the electronic components represented
    as symbols. The schematic makes it easier to understand the connections between
    the Intel Galileo Gen 2 board GPIO pins and the electronic components. Clearly,
    the schematic benefits from the fact that the GPIO pin number matches the LED
    number and it will be easy to write our first version of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with schematics to wire digital outputs](img/B05042_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the previous schematic, each GPIO pin labeled from **D1** to **D9**
    in the board's symbol is connected to a **270Ω** resistor, wired to an LED's anode,
    and each LED's cathode is connected to ground. This way, whenever we write a high
    (1) value to any of the GPIO pins, the board will put 5V on the pin and the LED
    will turn on. Whenever we write a low (0) value to any of the GPIO pins, the board
    will put 0V on the pin and the LED will turn off.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we left the jumper labeled **IOREF** in its default 5V position, the board
    will be operating with 5V for its GPIO pins. Thus, a GPIO pin will have 5V when
    we write a high value to it. If we change the position of this jumper to 3.3V,
    a GPIO pin will have 3.3V when we write a high value to it. Unless specified otherwise,
    we are using the default position for this jumper in all the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to insert the components in the breadboard and make all the
    necessary wirings.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always shutdown the Yocto Linux, wait for all the onboard LEDs to turn off,
    and unplug the power supply from the Intel Galileo Gen 2 board before adding or
    removing any wire from the board's pins. Do the same before plugging or unplugging
    any shield.
  prefs: []
  type: TYPE_NORMAL
- en: In order to shutdown the Yocto Linux, enter the following command in your `ssh`
    terminal. Make sure you have exited the Python interpreter when you enter the
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As a result of the previous command, you will see the time at which the shutdown
    process is going to begin. The message will be similar to the following output
    but with different dates and times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then, wait around 1 minute until the operating system closes down and all the
    onboard LEDs turn off. At this time, you can safely remove the power supply from
    the board.
  prefs: []
  type: TYPE_NORMAL
- en: We have to pay special attention when inserting the LEDs in the breadboard.
    As we can notice in the schematic, the resistor is wired to an LED's anode, and
    each LED's cathode is connected to ground.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily identify the LED's anode, that is, its positive lead, because
    its lead is slightly longer than the other lead. The LED's cathode, that is, its
    negative lead is shorter than the other lead. In the following picture, the LED's
    cathode, that is, its negative lead is the lead located at the left-hand side
    (the shorter lead). The LED's anode, that is, its positive lead, is the lead located
    at the right-hand side (the slightly longer lead). You can also notice that the
    metal piece inside the LED connected to the LED's anode, that is, its positive
    lead, is smaller than the metail piece inside the LED connected to the LED's cathode,
    that is, its negative lead.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with schematics to wire digital outputs](img/B05042_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The LED in the picture is located in the same position than the LEDs are connected
    in the previously shown breadboard picture. Thus, we have to connect the shorter
    lead at the left and the larger lead at the right in the breadboard. The next
    picture shows the LED representation in the breadboard picture with its cathode
    and anode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with schematics to wire digital outputs](img/B05042_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following picture shows the schematic electronic symbol for the LED with
    the same positions for the cathode and anode than in the previous picture that
    showed the breadboard picture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with schematics to wire digital outputs](img/B05042_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following picture shows all the LEDs connected to the breadboard. You can
    check the cathode and the anode based on the metal parts that you can see through
    the LED's plastic.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with schematics to wire digital outputs](img/B05042_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following picture shows all the LEDs connected to the breadboard where you
    can check that the LEDs are connected as we have seen in the breadboard view for
    the Fritzing diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with schematics to wire digital outputs](img/B05042_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Resistors are the same forward and backwards, and therefore, it doesn't matter
    which way you use them in the breadboard. The following picture shows a 270Ω axial-lead
    resistor with 5% tolerance. Notice that the color bands from left to right are
    red, violet, brown and gold. The color bands allow us to know the resistance in
    ohms and their tolerance value without having to measure the resistor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with schematics to wire digital outputs](img/B05042_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following picture shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with schematics to wire digital outputs](img/B05042_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Counting from 1 to 9 with LEDs, Python code and the mraa library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we finish the wirings and we make sure that all the components and the
    wires are in the right place, we can write our first version of the Python code
    to count from 1 to 9 with the LEDs, transfer it to the board via SFTP and execute
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a few lines of Python code that will use the `mraa` library to
    run the following steps to count from 1 to 9, with a 3 seconds pause between each
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn on LED1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on LED1 and LED2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on LED1, LED2 and LED3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on LED1, LED2, LED3 and LED4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on LED1, LED2, LED3, LED4 and LED5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on LED1, LED2, LED3, LED4, LED5 and LED6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on LED1, LED2, LED3, LED4, LED5, LED6 and LED7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on LED1, LED2, LED3, LED4, LED5, LED6, LED7 and LED8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on LED1, LED2, LED3, LED4, LED5, LED6, LED7, LED8 and LED9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lines show the Python code that performs the previously explained
    actions. The code file for the sample is `iot_python_chapter_03_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we transfer the file to the board, we can run the previous code with the
    following command on the board''s SSH terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used many `print` statements to make it easy for us to understand what
    is going on with messages on the console. The following lines show the generated
    output after we run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The following nine pictures show the sequence of LEDs that are turned on in
    the breadboard by executing the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Counting from 1 to 9 with LEDs, Python code and the mraa library](img/B05042_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, the code declares an empty list named `output`. Then, a `for` loop creates
    nine instances of the `mraa.Gpio` class and each of them represent a general purpose
    Input/Output pin on the board. We pass `i` as an argument for the `pin` parameter,
    and therefore, each instance represents the pin number equal to `i` of the GPIO
    pins in the board. After we create the instance, we call the `dir` method to configure
    the pin to be an output pin, that is, to set is direction to the `mraa.DIR_OUT`
    value. Then we call the `append` method for the `output` list to add the `mraa.Gpio`
    instance (`gpio`) to the output list. It is important to understand that `range(1,
    10)` generates the following list: `[1, 2, 3, 4, 5, 6, 7, 8, 9]`. Thus, our `for`
    loop will start with `i` equal to 1 and its last iteration will be with `i` equal
    to 9.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Another `for` loop determines the number of LEDs to be turned on. We use `range(1,
    10)` to generate the same list than in the previous loop. The first line within
    the `for` loop calls a `print` method to display the number of LEDs that we are
    going to turn on in the iteration. A loop within the loop uses `range(0, i)` to
    generate the list of indexes of the elements in the `output` list that we have
    to turn on for the iteration of the main `for` loop (`i`).
  prefs: []
  type: TYPE_NORMAL
- en: The inner loop uses `j` as its variable and the code within this inner loop
    just calls the `write` method for each `mraa.Gpio` instance, `output[j]`, with
    `1` as an argument for the `value` required parameter. This way, we send a high
    value (`1`) to the pin that is equal to `j + 1`, configured for digital output.
    If `j` is equal to 0, the first element of the output list is the `mraa.Gpio`
    instance that is configured for pin 1 (`j + 1`). Because each pin from 1 to 9
    has an LED connected to it, the result of a high value in one or more pins are
    LEDs turned on. Then, the code prints a message indicating the LED number that
    has been turned on.
  prefs: []
  type: TYPE_NORMAL
- en: Once the inner loop finishes, a call to `time.sleep` with `3` as the value for
    the `seconds` argument delays the execution for three seconds. This way, the LED
    or LEDs stay turned on during this delay before the outer loop performs another
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The following picture shows the console output printed on an SSH terminal in
    a laptop, the 9 LEDs turned on in the protoboard connected to the board that is
    running Python code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Counting from 1 to 9 with LEDs, Python code and the mraa library](img/B05042_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Taking advantage of object-oriented code to control digital outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example just turns on the LEDs. Thus, in case we want to count
    in a reverse order, that is, from 9 to 1, the results are not going to be as expected.
    After the code turns on 9 LEDs, the code will turn on 8 LEDs but there are still
    going to be 9 LEDs turned. The problem is that we never turn off the LEDs that
    we don't need to be turned on, and therefore the 9 LEDs will stay on until the
    edited loop finishes its execution.
  prefs: []
  type: TYPE_NORMAL
- en: We are always talking about LEDs turning on and turning off LEDs. However, we
    have been using just instanced of the `mraa.Gpio` class and called the `write`
    method. Python is an object-oriented programming language, and therefore, we can
    definitely take advantage of its object-oriented features to write reusable, easier
    to understand and simpler to maintain code. For example, in this case, it makes
    a lot of sense to create an `Led` class to represent an LED connected to our board.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for the new `Led` class. The code file for
    the sample is `iot_python_chapter_03_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify the pin number to which the LED is connected when we create
    an instance of the `Led` class in the `pin` required argument. The constructor,
    that is, the `__init__` method, creates a new `mraa.Gpio` instance with the received
    `pin` as its `pin` argument, saves its reference in the `gpio` attribute and calls
    its `dir` method to configure the pin to be an output pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class defines the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`turn_on`: Calls the `write` method for the related `mraa.Gpio` instance to
    send a high value (1) to the pin and turn on the LED connected to this pin. Then,
    it prints a message with details about the performed action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`turn_off`: Calls the `write` method for the related `mraa.Gpio` instance to
    send a low value (0) to the pin and turn off the LED connected to this pin. Then,
    it prints a message with details about the performed action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can write code that uses the new `Led` class to create the necessary
    instances based on the number of LEDs we want to control and the pins to which
    they are connected. The following lines show an improved version of the code that
    uses the new `Led` class to count from 1 to 9 with the LEDs. The code file for
    the sample is `iot_python_chapter_03_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, the code declares an empty list named `leds`. Then, a `for` loop creates
    nine instances of the `Led` class and each of them represent an LED connected
    to a GPIO pin on the board. We pass `i` as an argument for the `pin` parameter.
    Then, we call the `append` method for the `leds` list to add the `Led` instance
    (`led`) to the `leds` list. Our `for` loop will start with `i` equal to 1 and
    its last iteration will be with `i` equal to 9.
  prefs: []
  type: TYPE_NORMAL
- en: Another `for` loop determines the number of LEDs to be turned on. We use `range(1,
    10)` to generate the same list than in the previous loop. The first line within
    the `for` loop calls a `print` method to display the number of LEDs that we are
    going to be turned on in the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: An inner loop within the loop uses `range(0, i)` to generate the list of indexes
    of the elements in the `leds` list that we have to turn on for the iteration of
    the main `for` loop (`i`). The inner loop uses `j` as its variable and the code
    within this inner loop just calls the `turn_on` method for each `Led` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Another inner loop wihin the loop uses `range(i, 9)` to generate the list of
    indexes of the elements in the `leds` list that we have to turn off for the iteration
    of the main `for` loop (`i`). The inner loop uses `k` as its variable and the
    code within this inner loop just calls the `turn_off` method for each `Led` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code is easier to understand than the previous version and the `Led` class
    handles everything related to an LED. We can easily understand that the line that
    calls the `turn_on` method for `leds[j]` is turning on an LED. We definitely know
    that an LED is being turned off in the line that calls the `turn_off` method for
    `leds[k]`.
  prefs: []
  type: TYPE_NORMAL
- en: As the new code turns off the LEDs that don't have be turned on, we can easily
    create a new version that counts from 9 to 1 by changing one line. The following
    lines show the new version of the code that works with the `Led` class to count
    from 9 to 1 with the LEDs. The only line that had to be edited is the highlighted
    one. The code file for the sample is `iot_python_chapter_03_04.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Improving our object-oriented code to provide new features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our counter working with the LEDs connected to the board, we
    want to add new features. We want to be able to easily transform a number between
    1 and 9 into its representation in LEDs connected to the board.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for the new `NumberInLeds` class. The code
    file for the sample is `iot_python_chapter_03_05.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The constructor, that is, the `__init__` method, declares an empty list attribute
    named `leds` (`self.leds`). Then, a `for` loop creates nine instances of the `Led`
    class and each of them represent an LED connected to a GPIO pin on the board.
    We pass `i` as an argument for the `pin` parameter. Then, we call the `append`
    method for the `self.leds` list to add the `Led` instance (`led`) to the `self.leds`
    list. Our `for` loop will start with `i` equal to 1 and its last iteration will
    be with `i` equal to 9.
  prefs: []
  type: TYPE_NORMAL
- en: The class defines a `print_number` method that requires the number that we want
    to represent with LEDs turned on in the `number` argument. The method uses a `for`
    loop with `j` as its variable to turn on the necessary LEDs by accesing the appropriate
    members of the `self.leds` list and calling the `turn_on` method. Then, the method
    uses another `for` loop with `k` as its variable to turn off the remaining LEDs
    by accesing the appropriate members of the `self.leds` list and calling the `turn_off`
    method. This way, the method makes sure that only the LEDs that have to be turned
    on are really turned on and the rest of them are turned off.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can write code that uses the new `NumberInLeds` class to count from
    0 to 9 with the LEDs. In this case, we start with 0 because the new class is able
    to turn off all the LEDs that shouldn't be turned on to represent a specific number.
    The code file for the sample is `iot_python_chapter_03_05.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code is very easy to understand, we just create an instance of the `NumberInLeds`
    class, named `number_in_leds`, and then we call its `print_number` method with
    `i` as its argument within the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We took advantage of Python's object-oriented features to create classes that
    represent the LEDs and the generation of numbers with LEDs. This way, we wrote
    higher level code that is easier to understand because we don't just read code
    that writes 0s and 1s to specific pin numbers, we can read code that prints numbers
    in LEDs, turns on and turns off LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating the pin numbers to improve wirings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, it is easy to turn on the LED that represents number 1 when it is
    connected to GPIO pin number 1\. In our previous wiring, the LED that represented
    each number was connected to the same GPIO pin number. The schema was also very
    easy to understand with the connections where the LED number matched the pin number.
  prefs: []
  type: TYPE_NORMAL
- en: However, the wirings between the board and the breadboard were a bit complicated
    because the GPIO pins in the board go from 13 down to 1, from left to right. The
    breadboard has the LEDs in the opposite direction, that is, from 1 to 9, left
    to right. Thus, the wire that connect the GPIO pin number 1 with LED number 1
    has to go from right to left and crosses the other jumper wires. We will change
    the jumper wires to improve our wiring and then we will make the necessary changes
    to our object-oriented Python code to isolate the pin numbers and make it possible
    to have a nicer wiring. Don't forget to shutdown the operating system and unplug
    the power supply from the board before you make changes to the wirings.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the components connected to the breadboard and the
    new wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing
    file for the sample is `iot_fritzing_chapter_03_06.fzz` and the following picture
    is the breadboard view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolating the pin numbers to improve wirings](img/B05042_03_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, whenever we want to turn on LED 1, we must write a high (1) value to GPIO
    pin number 9, whenever we want to turn on LED 2, we write a high (1) value to
    GPIO pin number 8, and so on. Because we changed the wirings, the schematic with
    the electronic components represented as symbols also changed. The following picture
    shows the new version of the schematic.
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolating the pin numbers to improve wirings](img/B05042_03_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following lines show the new code for the `Led` class. The code file for
    the sample is `iot_python_chapter_03_06.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to specify an additional parameter when we create an instance
    of the `Led` class: the `position` in the breadboard, that is the LED number in
    the breadboard. The constructor, that is, the `__init__` method, saves the `position`
    value in an attribute with the same name. Both the `turn_on` and `turn_off` methods
    use the `self.position` attribute value to print a message indicating the position
    of the LED that has been turned on or off. As the position doesn''t match the
    pin anymore, the message had to be improved to specify the position.'
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for the new version of the `NumberInLeds`
    class. The code file for the sample is `iot_python_chapter_03_06.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It was necessary to make changes to the highlighted lines in the constructor,
    that is, the `__init__` method. The `for` loop that creates the nine instances
    of the `Led` class now starts with `i` equal to 9 and its last itearation will
    be with `i` equal to 1\. We pass `i` as an argument for the `pin` parameter and
    `10 – i` as an argument for the position `parameter`. This way, the first `Led`
    instance in the `self.leds` list will be the one with pin equal to 9 and position
    equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: The code that uses the new version of the `NumberInLeds` class to count from
    0 to 9 with the LEDs is the same than the previous code. The code file for the
    sample is `iot_python_chapter_03_06.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We just needed to make a few changes in the class that encapsulates a LED (`Led`)
    and in the class that encapsulates a number represented with LEDs (`NumberInLeds`).
    The following picture shows the 9 LEDs turned on in the breadboard with the new
    wirings connected between the breadboard and the board that is running the new
    Python code running.
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolating the pin numbers to improve wirings](img/B05042_03_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can easily build an API and provide a REST API to allow any client that has
    connection to the board to be able to print numbers through HTTP. Our REST API
    just needs to create an instance of the `NumberInLeds` class and call the `print_number`
    method with the specified number to be printed with LEDs. We will build this REST
    API in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling digital outputs with the wiring-x86 library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great advantages of working with Python as our programming language
    to interact with the board is that we have plenty of packages available for Python.
    We have been using the `mraa` library to interact with the digital outputs. However,
    in the previous chapter, we also installed the `wiring-x86` library. We can change
    just a few lines of our object-oriented code to replace the `mraa` library with
    the `wiring-x86` one to turn on and off the LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines shows the code for a `Board` class followed by the new version
    of the `Led` class that works with the `wiring-x86` library instead of using `mraa`.
    The code file for the sample is `iot_python_chapter_03_07.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `wiring-x86` library doesn't include automatic detection of the board, and
    therefore, it is necessary to use the class that represents our board. The GPIOGalileoGen2
    represents the Intel Galileo Gen 2 board, and therefore, the first line of code
    uses an `import` statement to import it as `GPIO` from `wiringx86`. This way,
    whenever we reference `GPIO`, we will be really using `wiringx86.GPIOGalileoGen2`.
    Notice that the library name is `wiring-x86` but the module name is `wiringx86`.
  prefs: []
  type: TYPE_NORMAL
- en: When we create an instance of the `Led` class, we have to specify the GPIO digital
    `pin` to which the LED is connected and the `position` in the breadboard, that
    is the LED number in the breadboard. The constructor, that is, the `__init__`
    method, saves a reference to the `Board.gpio` class attribute in `self.gpio` and
    calls its `pinMode` method with the received pin as its `pin` argument and `self.gpio.OUTPUT`
    as its `mode` argument. This way, we configure the pin to be an output pin. All
    the `Led` instances will save a reference to the same `Board.gpio` class attribute
    that created an instance of the `GPIO` class, specifically, the `wiringx86.GPIOGalileoGen2`
    class with its `debug` argument set to `False` to avoid unnecessary debug information
    for the low-level communications.
  prefs: []
  type: TYPE_NORMAL
- en: The `turn_on` method calls the `digitalWrite` method for the GPIO instance to
    send a high value (`self.GPIO.HIGH`) to the pin specified by the `self.pin` attribute
    value and prints a message about the performed action.
  prefs: []
  type: TYPE_NORMAL
- en: The `turn_off` method calls the `digitalWrite` method for the GPIO instance
    to send a low value (`self.GPIO.LOW`) to the pin specified by the `self.pin` attribute
    value and prints a message about the performed action.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the `NumberInLeds` class remains the same one that we have used
    for the previous example. There is no need to make changes to this class because
    it will automatically work with the new `Led` class and there were no changes
    in the arguments for its constructor or its two methods. We just need to replace
    the lines that printed information about the `mraa` library in the `__main__`
    method because we aren't using the `mraa` library anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines shows the code for the `NumberInLeds` class and the `__main__`
    method. The code file for the sample is `iot_python_chapter_03_07.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We just needed to change a few lines of code and we can see how the Python code
    makes LEDs in the breadboard count from 0 to 9 using the `wiring-x86` library.
    The way in which we work with the GPIO pins for digital output with this library
    is a bit different from the mechanism used in the `mraa` library. However, we
    could easily encapsulate the changes by taking advantage of Python's object-oriented
    features. We can decide which library is more convenient for our projects based
    on our preferences and needs. It is always a nice idea to have more than just
    one option.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we send a high value (1) to a GPIO pin configured as output, the GPIO
    pin will have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 0 V.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 6 V.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The voltage specified in the position in which the IOREF jumper is located.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An instance of the `mraa.Gpio` class represents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A single GPIO pin in the board.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All the I/O pins in the board.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Two GPIO pins in the board.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we create an instance of the `mraa.Gpio` class, we must specify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pin number as an argument.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The specific board and a pin number as arguments.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The pin number and the desired direction: `mraa.DIR_OUT` or `mraa.DIR_IN`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following lines write a high value to the GPIO pin configured
    as output with the instance of `mraa.Gpio` named `gpio10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpio10.write(0)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpio10.write(1)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpio10.write(mraa.HIGH_VALUE)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following lines configure the instance of `mraa.Gpio` named `gpio10`
    for digital output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpio10.dir(mraa.DIR_DIGITAL).out()`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpio10.dir(mraa.DIR_OUT)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpio10.dir(mraa.DIR_OUT, mraa.DIGITAL)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we worked with Python with two different libraries: `mraa`
    and `wiring-x86`. We connected LEDs and resistors to a breadboard and we wrote
    code to turn on from 0 to 9 LEDs. We improved our Python code to take advantage
    of Python''s object-oriented features and we prepared the code to make it easy
    to build an API that will allow us to print numbers with LEDs with a REST API.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we finished our first wirings and we started controlling the board
    with Python, we can start working with additional outputs and combine them with
    a REST API, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
