- en: Chapter 2. Built-in Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Data! Data! Data!" he cried impatiently. "I can''t make bricks without
    clay."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Sherlock Holmes - The Adventure of the Copper Beeches* |'
  prefs: []
  type: TYPE_TB
- en: Everything you do with a computer is managing data. Data comes in many different
    shapes and flavors. It's the music you listen, the movie you stream, the PDFs
    you open. Even the chapter you're reading at this very moment is just a file,
    which is data.
  prefs: []
  type: TYPE_NORMAL
- en: Data can be simple, an integer number to represent an age, or complex, like
    an order placed on a website. It can be about a single object or about a collection
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Data can even be about data, that is, metadata. Data that describes the design
    of other data structures or data that describes application data or its context.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, *objects are abstraction for data*, and Python has an amazing variety
    of data structures that you can use to represent data, or combine them to create
    your own custom data. Before we delve into the specifics, I want you to be very
    clear about objects in Python, so let's talk a little bit more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already said, everything in Python is an object. But what really happens
    when you type an instruction like `age = 42` in a Python module?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you go to [http://pythontutor.com/](http://pythontutor.com/), you can type
    that instruction into a text box and get its visual representation. Keep this
    website in mind, it's very useful to consolidate your understanding of what goes
    on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens is that an object is created. It gets an `id`, the `type`
    is set to `int` (integer number), and the `value` to `42`. A name `age` is placed
    in the global namespace, pointing to that object. Therefore, whenever we are in
    the global namespace, after the execution of that line, we can retrieve that object
    by simply accessing it through its name: `age`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to move house, you would put all the knives, forks, and spoons
    in a box and label it cutlery. Can you see it''s exactly the same concept? Here''s
    a screenshot of how it may look like (you may have to tweak the settings to get
    to the same view):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Everything is an object](img/4715_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, for the rest of this chapter, whenever you read something such as `name
    = some_value`, think of a name placed in the namespace that is tied to the scope
    in which the instruction was written, with a nice arrow pointing to an object
    that has an `id`, a `type`, and a `value`. There is a little bit more to say about
    this mechanism, but it's much easier to talk about it over an example, so we'll
    get back to this later.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable or immutable? That is the question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A first fundamental distinction that Python makes on data is about whether or
    not the value of an object changes. If the value can change, the object is called
    **mutable**, while if the value cannot change, the object is called **immutable**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very important that you understand the distinction between mutable and
    immutable because it affects the code you write, so here''s a question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, on the line `#A`, have I changed the value of age? Well,
    no. But now it''s 43 (I hear you say...). Yes, it''s 43, but 42 was an integer
    number, of the type `int`, which is immutable. So, what happened is really that
    on the first line, `age` is a name that is set to point to an `int` object, whose
    value is 42\. When we type `age = 43`, what happens is that another object is
    created, of the type `int` and value 43 (also, the `id` will be different), and
    the name `age` is set to point to it. So, we didn''t change that 42 to 43\. We
    actually just pointed `age` to a different location: the new `int` object whose
    value is 43\. Let''s see the same code also printing the IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we print the IDs by calling the built-in `id` function. As you
    can see, they are different, as expected. Bear in mind that `age` points to one
    object at a time: 42 first, then 43\. Never together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the same example using a mutable object. For this example,
    let''s just use a `Person` object, that has a property `age`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I set up an object `fab` whose `type` is `Person` (a custom class).
    On creation, the object is given the `age` of 39\. I'm printing it, along with
    the object `id`, right afterwards. Notice that, even after I change `age` to be
    29, the ID of `fab` stays the same (while the ID of `age` has changed, of course).
    Custom objects in Python are mutable (unless you code them not to be). Keep this
    concept in mind, it's very important. I'll remind you about it through the rest
    of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by exploring Python's built-in data types for numbers. Python was
    designed by a man with a master's degree in mathematics and computer science,
    so it's only logical that it has amazing support for numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers are immutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python integers have unlimited range, subject only to the available virtual
    memory. This means that it doesn''t really matter how big a number you want to
    store: as long as it can fit in your computer''s memory, Python will take care
    of it. Integer numbers can be positive, negative, and 0 (zero). They support all
    the basic mathematical operations, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should be easy to understand. Just notice one important
    thing: Python has two division operators, one performs the so-called **true division**
    (`/`), which returns the quotient of the operands, and the other one, the so-called
    **integer division** (`//`), which returns the *floored* quotient of the operands.
    See how that is different for positive and negative numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an interesting example. If you were expecting a `-1` on the last line,
    don''t feel bad, it''s just the way Python works. The result of an integer division
    in Python is always rounded towards minus infinity. If instead of flooring you
    want to truncate a number to an integer, you can use the built-in `int` function,
    like shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that truncation is done towards 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an operator to calculate the remainder of a division. It''s called
    modulo operator, and it''s represented by a percent (`%`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boolean algebra is that subset of algebra in which the values of the variables
    are the truth values: true and false. In Python, `True` and `False` are two keywords
    that are used to represent truth values. Booleans are a subclass of integers,
    and behave respectively like 1 and 0\. The equivalent of the `int` class for Booleans
    is the `bool` class, which returns either `True` or `False`. Every built-in Python
    object has a value in the Boolean context, which means they basically evaluate
    to either `True` or `False` when fed to the `bool` function. We''ll see all about
    this in [Chapter 3](ch03.html "Chapter 3. Iterating and Making Decisions"), *Iterating
    and Making Decisions*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean values can be combined in Boolean expressions using the logical operators
    `and`, `or`, and `not`. Again, we''ll see them in full in the next chapter, so
    for now let''s just see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that `True` and `False` are subclasses of integers when you try
    to add them. Python upcasts them to integers and performs addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Upcasting** is a type conversion operation that goes from a subclass to its
    parent. In the example presented here, `True` and `False`, which belong to a class
    derived from the integer class, are converted back to integers when needed. This
    topic is about inheritance and will be explained in detail in [Chapter 6](ch06.html
    "Chapter 6. Advanced Concepts – OOP, Decorators, and Iterators"), *Advanced Concepts
    – OOP, Decorators, and Iterators*.'
  prefs: []
  type: TYPE_NORMAL
- en: Reals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Real numbers, or floating point numbers, are represented in Python according
    to the IEEE 754 double-precision binary floating-point format, which is stored
    in 64 bits of information divided into three sections: sign, exponent, and mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Quench your thirst for knowledge about this format on Wikipedia: [http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually programming languages give coders two different formats: single and
    double precision. The former taking up 32 bits of memory, and the latter 64\.
    Python supports only the double format. Let''s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the calculation of the area, I wrapped the `radius ** 2` within braces. Even
    though that wasn't necessary because the power operator has higher precedence
    than the multiplication one, I think the formula reads more easily like that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sys.float_info` struct sequence holds information about how floating point
    numbers will behave on your system. This is what I see on my box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make a few considerations here: we have 64 bits to represent float numbers.
    This means we can represent at most `2 ** 64 == 18,446,744,073,709,551,616` numbers
    with that amount of bits. Take a look at the `max` and `epsilon` value for the
    float numbers, and you''ll realize it''s impossible to represent them all. There
    is just not enough space so they are approximated to the closest representable
    number. You probably think that only extremely big or extremely small numbers
    suffer from this issue. Well, think again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What does this tell you? It tells you that double precision numbers suffer from
    approximation issues even when it comes to simple numbers like 0.1 or 0.3\. Why
    is this important? It can be a big problem if you're handling prices, or financial
    calculations, or any kind of data that needs not to be approximated. Don't worry,
    Python gives you the **Decimal** type, which doesn't suffer from these issues,
    we'll see them in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python gives you complex numbers support out of the box. If you don't know what
    complex numbers are, you can look them up on the Web. They are numbers that can
    be expressed in the form *a + ib* where *a* and *b* are real numbers, and *i*
    (or *j* if you're an engineer) is the imaginary unit, that is, the square root
    of -1\. *a* and *b* are called respectively the *real* and *imaginary* part of
    the number.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s actually unlikely you''ll be using them, unless you''re coding something
    scientific. Let''s see a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Fractions and decimals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s finish the tour of the number department with a look at fractions and
    decimals. Fractions hold a rational numerator and denominator in their lowest
    forms. Let''s see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Although they can be very useful at times, it's not that common to spot them
    in commercial software. Much easier instead, is to see decimal numbers being used
    in all those contexts where precision is everything, for example, scientific and
    financial calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to remember that arbitrary precision decimal numbers come at
    a price in performance, of course. The amount of data to be stored for each number
    is far greater than it is for fractions or floats as well as the way they are
    handled, which requires the Python interpreter much more work behind the scenes.
    Another interesting thing to know is that you can get and set the precision by
    accessing `decimal.getcontext().prec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a quick example with `Decimal` numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we construct a `Decimal` number from a `float`, it takes on
    all the approximation issues the `float` may come from. On the other hand, when
    the `Decimal` has no approximation issues, for example, when we feed an `int`
    or a `string` representation to the constructor, then the calculation has no quirky
    behavior. When it comes to money, use decimals.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our introduction to built-in numeric types, let's now see sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with immutable sequences: strings, tuples, and bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings and bytes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Textual data in Python is handled with **str** objects, more commonly known
    as strings. They are immutable sequences of **unicode code points**. Unicode code
    points can represent a character, but can also have other meanings, such as formatting
    data for example. Python, unlike other languages, doesn''t have a `char` type,
    so a single character is rendered simply by a string of length 1\. Unicode is
    an excellent way to handle data, and should be used for the internals of any application.
    When it comes to store textual data though, or send it on the network, you may
    want to encode it, using an appropriate encoding for the medium you''re using.
    String literals are written in Python using single, double or triple quotes (both
    single or double). If built with triple quotes, a string can span on multiple
    lines. An example will clarify the picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In `#A` and `#B`, we print `str4`, first implicitly, then explicitly using the
    `print` function. A nice exercise would be to find out why they are different.
    Are you up to the challenge? (hint, look up the `str` function)
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings, like any sequence, have a length. You can get this by calling the
    `len` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Encoding and decoding strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `encode`/`decode` methods, we can encode unicode strings and decode
    bytes objects. **Utf-8** is a variable length character encoding, capable of encoding
    all possible unicode code points. It is the dominant encoding for the Web (and
    not only). Notice also that by adding a literal `b` in front of a string declaration,
    we're creating a *bytes* object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and slicing strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When manipulating sequences, it's very common to have to access them at one
    precise position (indexing), or to get a subsequence out of them (slicing). When
    dealing with immutable sequences, both operations are read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'While indexing comes in one form, a zero-based access to any position within
    the sequence, slicing comes in different forms. When you get a slice of a sequence,
    you can specify the `start` and `stop` positions, and the `step`. They are separated
    with a colon (`:`) like this: `my_sequence[start:stop:step]`. All the arguments
    are optional, `start` is inclusive, `stop` is exclusive. It''s much easier to
    show an example, rather than explain them further in words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Of all the lines, the last one is probably the most interesting. If you don't
    specify a parameter, Python will fill in the default for you. In this case, `start`
    will be the start of the string, `stop` will be the end of the sting, and `step`
    will be the default 1\. This is an easy and quick way of obtaining a copy of the
    string `s` (same value, but different object). Can you find a way to get the reversed
    copy of a string using slicing? (don't look it up, find it for yourself)
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last immutable sequence type we''re going to see is the tuple. A **tuple**
    is a sequence of arbitrary Python objects. In a tuple, items are separated by
    commas. They are used everywhere in Python, because they allow for patterns that
    are hard to reproduce in other languages. Sometimes tuples are used implicitly,
    for example to set up multiple variables on one line, or to allow a function to
    return multiple different objects (usually a function returns one object only,
    in many other languages), and even in the Python console, you can use tuples implicitly
    to print multiple elements with one single instruction. We''ll see examples for
    all these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the membership operator `in` can also be used with lists, strings,
    dictionaries, and in general with collection and sequence objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that to create a tuple with one item, we need to put that comma after
    the item. The reason is that without the comma that item is just itself wrapped
    in braces, kind of in a redundant mathematical expression. Notice also that on
    assignment, braces are optional so `my_tuple = 1, 2, 3` is the same as `my_tuple
    = (1, 2, 3)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that tuple assignment allows us to do, is *one-line swaps*, with
    no need for a third temporary variable. Let''s see first a more traditional way
    of doing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s see how we would do it in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the line that shows you the Pythonic way of swapping two values:
    do you remember what I wrote in [Chapter 1](ch01.html "Chapter 1. Introduction
    and First Steps – Take a Deep Breath"), *Introduction and First Steps – Take a
    Deep Breath*. A Python program is typically one-fifth to one-third the size of
    equivalent Java or C++ code, and features like one-line swaps contribute to this.
    Python is elegant, where elegance in this context means also economy.'
  prefs: []
  type: TYPE_NORMAL
- en: Because they are immutable, tuples can be used as keys for dictionaries (we'll
    see this shortly). The `dict` objects need keys to be immutable because if they
    could change, then the value they reference wouldn't be found any more (because
    the path to it depends on the key). If you are into data structures, you know
    how nice a feature this one is to have. To me, tuples are Python's built-in data
    that most closely represent a mathematical vector. This doesn't mean that this
    was the reason for which they were created though. Tuples usually contain an heterogeneous
    sequence of elements, while on the other hand lists are most of the times homogeneous.
    Moreover, tuples are normally accessed via unpacking or indexing, while lists
    are usually iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mutable sequences differ from their immutable sisters in that they can be changed
    after creation. There are two mutable sequence types in Python: lists and byte
    arrays. I said before that the dictionary is the king of data structures in Python.
    I guess this makes the list its rightful queen.'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python lists are mutable sequences. They are very similar to tuples, but they
    don''t have the restrictions due to immutability. Lists are commonly used to store
    collections of homogeneous objects, but there is nothing preventing you to store
    heterogeneous collections as well. Lists can be created in many different ways,
    let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, I showed you how to create a list using different techniques.
    I would like you to take a good look at the line that says `Python is magic`,
    which I am not expecting you to fully understand at this point (unless you cheated
    and you're not a novice!). That is called a **list** **comprehension**, a very
    powerful functional feature of Python, which we'll see in detail in [Chapter 5](ch05.html
    "Chapter 5. Saving Time and Memory"), *Saving Time and Memory*. I just wanted
    to make your mouth water at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating lists is good, but the real fun comes when we use them, so let''s
    see the main methods they gift us with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives you a roundup of list''s main methods. I want to show
    you how powerful they are, using `extend` as an example. You can extend lists
    using any sequence type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what are the most common operations you can do with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two lines in the preceding code are quite interesting because they
    introduce us to a concept called **operator** **overloading**. In short, it means
    that operators such as `+`, `-`. `*`, `%`, and so on, may represent different
    operations according to the context they are used in. It doesn''t make any sense
    to sum two lists, right? Therefore, the `+` sign is used to concatenate them.
    Hence, the `*` sign is used to concatenate the list to itself according to the
    right operand. Now, let''s take a step further down the rabbit hole and see something
    a little more interesting. I want to show you how powerful the sort method can
    be and how easy it is in Python to achieve results that require a great deal of
    effort in other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code deserves a little explanation. First of all, `a` is a list
    of tuples. This means each element in `a` is a tuple (a *2-tuple*, to be picky).
    When we call `sorted(some_list)`, we get a sorted version of `some_list`. In this
    case, the sorting on a 2-tuple works by sorting them on the first item in the
    tuple, and on the second when the first one is the same. You can see this behavior
    in the result of `sorted(a)`, which yields `[(1, 2), (1, 3), ...]`. Python also
    gives us the ability to control on which element(s) of the tuple the sorting must
    be run against. Notice that when we instruct the `sorted` function to work on
    the first element of each tuple (by `key=itemgetter(0)`), the result is different:
    `[(1, 3), (1, 2), ...]`. The sorting is done only on the first element of each
    tuple (which is the one at position 0). If we want to replicate the default behavior
    of a simple `sorted(a)` call, we need to use `key=itemgetter(0, 1)`, which tells
    Python to sort first on the elements at position 0 within the tuples, and then
    on those at position 1\. Compare the results and you''ll see they match.'
  prefs: []
  type: TYPE_NORMAL
- en: For completeness, I included an example of sorting only on the elements at position
    1, and the same but in reverse order. If you have ever seen sorting in Java, I
    expect you to be on your knees crying with joy at this very moment.
  prefs: []
  type: TYPE_NORMAL
- en: The Python sorting algorithm is very powerful, and it was written by Tim Peters
    (we've already seen this name, can you recall when?). It is aptly named **Timsort**,
    and it is a blend between **merge** and **insertion** **sort** and has better
    time performances than most other algorithms used for mainstream programming languages.
    Timsort is a stable sorting algorithm, which means that when multiple records
    have the same key, their original order is preserved. We've seen this in the result
    of `sorted(a, key=itemgetter(0))` which has yielded `[(1, 3), (1, 2), ...]` in
    which the order of those two tuples has been preserved because they have the same
    value at position 0.
  prefs: []
  type: TYPE_NORMAL
- en: Byte arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To conclude our overview of mutable sequence types, let's spend a couple of
    minutes on the `bytearray` type. Basically, they represent the mutable version
    of `bytes` objects. They expose most of the usual methods of mutable sequences
    as well as most of the methods of the `bytes` type. Items are integers in the
    range [0, 256).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it comes to intervals, I''m going to use the standard notation for open/closed
    ranges. A square bracket on one end means that the value is included, while a
    round brace means it''s excluded. The granularity is usually inferred by the type
    of the edge elements so, for example, the interval [3, 7] means all integers between
    3 and 7, inclusive. On the other hand, (3, 7) means all integers between 3 and
    7 exclusive (hence 4, 5, and 6). Items in a `bytearray` type are integers between
    0 and 256, 0 is included, 256 is not. One reason intervals are often expressed
    like this is to ease coding. If we break a range [a, b) into *N* consecutive ranges,
    we can easily represent the original one as a concatenation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Byte arrays](img/4715_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The middle points (*k* *[i]*) being excluded on one end, and included on the
    other end, allow for easy concatenation and splitting when intervals are handled
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a quick example with the type `bytearray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, there are a few ways to create a `bytearray`
    object. They can be useful in many situations, for example, when receiving data
    through a **socket**, they eliminate the need to concatenate data while polling,
    hence they prove very handy. On the line `#A`, I created the `name` `bytearray`
    from the string `b'Lina'` to show you how the `bytearray` object exposes methods
    from both sequences and strings, which is extremely handy. If you think about
    it, they can be considered as mutable strings.
  prefs: []
  type: TYPE_NORMAL
- en: Set types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python also provides two set types, `set` and `frozenset`. The `set` type is
    mutable, while `frozenset` is immutable. They are unordered collections of immutable
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hashability** is a characteristic that allows an object to be used as a set
    member as well as a key for a dictionary, as we''ll see very soon.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An object is hashable if it has a hash value which never changes during its
    lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects that compare equally must have the same hash value. Sets are very commonly
    used to test for membership, so let''s introduce the `in` operator in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see two different ways to create a set. One creates
    an empty set and then adds elements one at a time. The other creates the set using
    a list of numbers as argument to the constructor, which does all the work for
    us. Of course, you can create a set from a list or tuple (or any iterable) and
    then you can add and remove members from the set as you please.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of creating a set is by simply using the curly braces notation,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice I added some duplication to emphasize that the result set won't have
    any.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll see iterable objects and iteration in the next chapter. For now, just
    know that iterable objects are objects you can iterate on in a direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example about the immutable counterpart of the set type: `frozenset`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `frozenset` objects are quite limited in respect of their mutable
    counterpart. They still prove very effective for membership test, union, intersection
    and difference operations, and for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping types – dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of all the built-in Python data types, the dictionary is probably the most interesting
    one. It's the only standard mapping type, and it is the backbone of every Python
    object.
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary maps keys to values. Keys need to be hashable objects, while values
    can be of any arbitrary type. Dictionaries are mutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few different ways to create a dictionary, so let me give
    you a simple example of how to create a dictionary equal to `{''A'': 1, ''Z'':
    -1}` in five different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Have you noticed those double equals? Assignment is done with one equal, while
    to check whether an object is the same as another one (or 5 in one go, in this
    case), we use double equals. There is also another way to compare objects, which
    involves the **is** operator, and checks whether the two objects are the same
    (if they have the same ID, not just the value), but unless you have a good reason
    to use it, you should use the double equal instead. In the preceding code, I also
    used one nice function: `zip`. It is named after the real-life zip, which glues
    together two things taking one element from each at a time. Let me show you an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, I have created the same list in two different ways,
    one more explicit, and the other a little bit more Pythonic. Forget for a moment
    that I had to wrap the `list` constructor around the `zip` call (the reason is
    because `zip` returns an iterator, not a `list`), and concentrate on the result.
    See how `zip` has coupled the first elements of its two arguments together, then
    the second ones, then the third ones, and so on and so forth? Take a look at your
    pants (or at your purse if you''re a lady) and you''ll see the same behavior in
    your actual zip. But let''s go back to dictionaries and see how many wonderful
    methods they expose for allowing us to manipulate them as we want. Let''s start
    with the basic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice how accessing keys of a dictionary, regardless of the type of operation
    we're performing, is done through square brackets. Do you remember strings, list,
    and tuples? We were accessing elements at some position through square brackets
    as well. Yet another example of Python's consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see now three special objects called dictionary views: `keys`, `values`,
    and `items`. These objects provide a dynamic view of the dictionary entries and
    they change when the dictionary changes. `keys()` returns all the keys in the
    dictionary, `values()` returns all the values in the dictionary, and `items()`
    returns all the *(key, value)* pairs in the dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s very important to know that, even if a dictionary is not intrinsically
    ordered, according to the Python documentation: "*Keys and values are iterated
    over in an arbitrary order which is non-random, varies across Python implementations,
    and depends on the dictionary''s history of insertions and deletions. If keys,
    values and items views are iterated over with no intervening modifications to
    the dictionary, the order of items will directly correspond.*"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough with this chatter, let''s put all this down into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A few things to notice in the preceding code. First, notice how we're creating
    a dictionary by iterating over the zipped version of the string `'hello'` and
    the list `[0, 1, 2, 3, 4]`. The string `'hello'` has two `'l'` characters inside,
    and they are paired up with the values 2 and 3 by the zip function. Notice how
    in the dictionary, the second occurrence of the `'l'` key (the one with value
    3), overwrites the first one (the one with value 2). Another thing to notice is
    that when asking for any view, the original order is lost, but is consistent within
    the views, as expected. Notice also that you may have different results when you
    try this code on your machine. Python doesn't guarantee that, it only guarantees
    the consistency of the order in which the views are presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see how these views are fundamental tools when we talk about iterating
    over collections. Let''s take a look now at some other methods exposed by Python''s
    dictionaries, there''s plenty of them and they are very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'All these methods are quite simple to understand, but it''s worth talking about
    that `None`, for a moment. Every function in Python returns `None`, unless the
    `return` statement is explicitly used, but we''ll see this when we explore functions.
    `None` is frequently used to represent the absence of a value, as when default
    arguments are not passed to a function. Some inexperienced coders sometimes write
    code that returns either `False` or `None`. Both `False` and `None` evaluate to
    `False` so it may seem there is not much difference between them. But actually,
    I would argue there is quite an important difference: `False` means that we have
    information, and the information we have is `False`. `None` means *no information*.
    And no information is very different from an information, which is `False`. In
    layman''s terms, if you ask your mechanic "is my car ready?" there is a big difference
    between the answer "No, it''s not" (*False*) and "I have no idea" (*None*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last method I really like of dictionaries is `setdefault`. It behaves like
    `get`, but also sets the key with the given value if it is not there. Let''s see
    and example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, we're now at the end of this tour. Test your knowledge about dictionaries
    trying to foresee how `d` looks like after this line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It's not that complicated, but don't worry if you don't get it immediately.
    I just wanted to spur you to experiment with dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our tour of built-in data types. Before I make some considerations
    about what we've seen in this chapter, I want to briefly take a peek at the `collections`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The collections module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Python general purpose built-in containers (`tuple`, `list`, `set`, and
    `dict`) aren''t enough, we can find specialized container data types in the `collections`
    module. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `namedtuple()` | A factory function for creating tuple subclasses with named
    fields |'
  prefs: []
  type: TYPE_TB
- en: '| `deque` | A `list`-like container with fast appends and pops on either end
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ChainMap` | A `dict`-like class for creating a single view of multiple mappings
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Counter` | A `dict` subclass for counting hashable objects |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderedDict` | A `dict` subclass that remembers the order entries were added
    |'
  prefs: []
  type: TYPE_TB
- en: '| `defaultdict` | A `dict` subclass that calls a factory function to supply
    missing values |'
  prefs: []
  type: TYPE_TB
- en: '| `UserDict` | A wrapper around dictionary objects for easier dict subclassing
    |'
  prefs: []
  type: TYPE_TB
- en: '| `UserList` | A wrapper around list objects for easier list subclassing |'
  prefs: []
  type: TYPE_TB
- en: '| `UserString` | A wrapper around string objects for easier string subclassing
    |'
  prefs: []
  type: TYPE_TB
- en: We don't have the room to cover all of them, but you can find plenty of examples
    in the official documentation, so here I'll just give a small example to show
    you `namedtuple`, `defaultdict`, and `ChainMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Named tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `namedtuple` is a `tuple`-like object that has fields accessible by attribute
    lookup as well as being indexable and iterable (it''s actually a subclass of `tuple`).
    This is sort of a compromise between a full-fledged object and a tuple, and it
    can be useful in those cases where you don''t need the full power of a custom
    object, but you want your code to be more readable by avoiding weird indexing.
    Another use case is when there is a chance that items in the tuple need to change
    their position after refactoring, forcing the coder to refactor also all the logic
    involved, which can be very tricky. As usual, an example is better than a thousand
    words (or was it a picture?). Say we are handling data about the left and right
    eye of a patient. We save one value for the left eye (position 0) and one for
    the right eye (position 1) in a regular tuple. Here''s how that might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s pretend we handle `vision` object all the time, and at some point
    the designer decides to enhance them by adding information for the combined vision,
    so that a `vision` object stores data in this format: *(left eye, combined, right
    eye)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you see the trouble we''re in now? We may have a lot of code that depends
    on `vision[0]` being the left eye information (which still is) and `vision[1]`
    being the right eye information (which is no longer the case). We have to refactor
    our code wherever we handle these objects, changing `vision[1]` to `vision[2]`,
    and it can be painful. We could have probably approached this a bit better from
    the beginning, by using a `namedtuple`. Let me show you what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If within our code we refer to left and right eye using `vision.left` and `vision.right`,
    all we need to do to fix the new design issue is to change our factory and the
    way we create instances. The rest of the code won't need to change.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can see how convenient it is to refer to those values by name rather than
    by position. After all, a wise man once wrote "*Explicit is better than implicit*"
    (can you recall where? Think *zen* if you don't...). This example may be a little
    extreme, of course it's not likely that our code designer will go for a change
    like this, but you'd be amazed to see how frequently issues similar to this one
    happen in a professional environment, and how painful it is to refactor them.
  prefs: []
  type: TYPE_NORMAL
- en: Defaultdict
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `defaultdict` data type is one of my favorites. It allows you to avoid
    checking if a key is in a dictionary by simply inserting it for you on your first
    access attempt, with a default value whose type you pass on creation. In some
    cases, this tool can be very handy and shorten your code a little. Let''s see
    a quick example: say we are updating the value of `age`, by adding one year. If
    `age` is not there, we assume it was `0` and we update it to `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now let's see how it would work with a `defaultdict` data type. The second line
    is actually the short version of a 4-lines long `if` clause that we would have
    to write if dictionaries didn't have the `get` method. We'll see all about `if`
    clauses in [Chapter 3](ch03.html "Chapter 3. Iterating and Making Decisions"),
    *Iterating and Making Decisions*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we just need to instruct the `defaultdict` factory that we want an
    `int` number to be used in case the key is missing (we'll get `0`, which is the
    default for the `int` type). Also, notice that even though in this example there
    is no gain on the number of lines, there is definitely a gain in readability,
    which is very important. You can also use a different technique to instantiate
    a `defaultdict` data type, which involves creating a factory object. For digging
    deeper, please refer to the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: ChainMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ChainMap` is an extremely nice data type which was introduced in Python
    3.3\. It behaves like a normal dictionary but according to the Python documentation:
    *is provided for quickly linking a number of mappings so they can be treated as
    a single unit.* This is usually much faster than creating one dictionary and running
    multiple update calls on it. `ChainMap` can be used to simulate nested scopes
    and is useful in templating. The underlying mappings are stored in a list. That
    list is public and can be accessed or updated using the maps attribute. Lookups
    search the underlying mappings successively until a key is found. In contrast,
    writes, updates, and deletions only operate on the first mapping.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common use case is providing defaults, so let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: I just love how Python makes your life easy. You work on a `ChainMap` object,
    configure the first mapping as you want, and when you need a complete dictionary
    with all the defaults as well as the customized items, you just feed the `ChainMap`
    object to a `dict` constructor. If you have never coded in other languages, such
    as Java or C++, you probably won't be able to fully appreciate how precious this
    is, how Python makes your life so much easier. I do, I feel claustrophobic every
    time I have to code in some other language.
  prefs: []
  type: TYPE_NORMAL
- en: Final considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it. Now you have seen a very good portion of the data structures that
    you will use in Python. I encourage you to take a dive into the Python documentation
    and experiment further with each and every data type we've seen in this chapter.
    It's worth it, believe me. Everything you'll write will be about handling data,
    so make sure your knowledge about it is rock solid.
  prefs: []
  type: TYPE_NORMAL
- en: Before we leap into the next chapter, I'd like to make some final considerations
    about different aspects that to my mind are important and not to be neglected.
  prefs: []
  type: TYPE_NORMAL
- en: Small values caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we discussed objects at the beginning of this chapter, we saw that when
    we assigned a name to an object, Python creates the object, sets its value, and
    then points the name to it. We can assign different names to the same value and
    we expect different objects to be created, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `a` and `b` are assigned to two `int` objects, which
    have the same value but they are not the same object, as you can see, their `id`
    is not the same. So let''s do it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Oh oh! Is Python broken? Why are the two objects the same now? We didn't do
    `a = b = 5`, we set them up separately. Well, the answer is performances. Python
    caches short strings and small numbers, to avoid having many copies of them clogging
    up the system memory. Everything is handled properly under the hood so you don't
    need to worry a bit, but make sure that you remember this behavior should your
    code ever need to fiddle with IDs.
  prefs: []
  type: TYPE_NORMAL
- en: How to choose data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we''ve seen, Python provides you with several built-in data types and sometimes,
    if you''re not that experienced, choosing the one that serves you best can be
    tricky, especially when it comes to collections. For example, say you have many
    dictionaries to store, each of which represents a customer. Within each customer
    dictionary there''s an `''id'': ''code''` unique identification code. In what
    kind of collection would you place them? Well, unless I know more about these
    customers, it''s very hard to answer. What kind of access will I need? What sort
    of operations will I have to perform on each of them, and how many times? Will
    the collection change over time? Will I need to modify the customer dictionaries
    in any way? What is going to be the most frequent operation I will have to perform
    on the collection?'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can answer the preceding questions, then you will know what to choose.
    If the collection never shrinks or grows (in other words, it won''t need to add/delete
    any customer object after creation) or shuffles, then tuples are a possible choice.
    Otherwise lists are a good candidate. Every customer dictionary has a unique identifier
    though, so even a dictionary could work. Let me draft these options for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Some customers we have there, right? I probably wouldn't go with the tuple option,
    unless I wanted to highlight that the collection is not going to change. I'd say
    usually a list is better, it allows for more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Another factor to keep in mind is that tuples and lists are ordered collections,
    while if you use a dictionary or a set you lose the ordering, so you need to know
    if ordering is important in your application.
  prefs: []
  type: TYPE_NORMAL
- en: What about performances? For example in a list, operations such as insertion
    and membership can take *O(n)*, while they are *O(1)* for a dictionary. It's not
    always possible to use dictionaries though, if we don't have the guarantee that
    we can uniquely identify each item of the collection by means of one of its properties,
    and that the property in question is hashable (so it can be a key in `dict`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're wondering what *O(n)* and *O(1)* mean, please Google "*big O notation*"
    and get a gist of it from anywhere. In this context, let's just say that if performing
    an operation *Op* on a data structure takes *O(f(n))*, it would mean that *Op*
    takes at most a time ![How to choose data structures](img/4715_02_03.jpg) to complete,
    where *c* is some positive constant, *n* is the size of the input, and *f* is
    some function. So, think of *O(...)* as an upper bound for the running time of
    an operation (it can be used also to size other measurable quantities, of course).
  prefs: []
  type: TYPE_NORMAL
- en: Another way of understanding if you have chosen the right data structure is
    by looking at the code you have to write in order to manipulate it. If everything
    comes easily and flows naturally, then you probably have chosen correctly, but
    if you find yourself thinking your code is getting unnecessarily complicated,
    then you probably should try and decide whether you need to reconsider your choices.
    It's quite hard to give advice without a practical case though, so when you choose
    a data structure for your data, try to keep ease of use and performance in mind
    and give precedence to what matters most in the context you are.
  prefs: []
  type: TYPE_NORMAL
- en: About indexing and slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we saw slicing applied on strings. Slicing
    in general applies to a sequence, so tuples, lists, strings, etc. With lists,
    slicing can also be used for assignment. I've almost never seen this used in professional
    code, but still, you know you can. Could you slice dictionaries or sets? I hear
    you scream "*Of course not! They are not ordered!*". Excellent, I see we're on
    the same page here, so let's talk about indexing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one characteristic about Python indexing I haven''t mentioned before.
    I''ll show you by example. How do you address the last element of a collection?
    Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If the list `a` has 10 elements, because of the *0-index* positioning system
    of Python, the first one is at position 0 and the last one is at position 9\.
    In the preceding example, the elements are conveniently placed in a position equal
    to their value: 0 is at position 0, 1 at position 1, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to fetch the last element, we need to know the length of the whole
    list (or tuple, or string, and so on) and then subtract 1\. Hence: `len(a) – 1`.
    This is so common an operation that Python provides you with a way to retrieve
    elements using **negative** **indexing**. This proves very useful when you do
    some serious data manipulation. Here''s a nice diagram about how indexing works
    on the string `"HelloThere"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About indexing and slicing](img/4715_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Trying to address indexes greater than 9 or smaller than -10 will raise an `IndexError`,
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: About the names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that, in order to keep the example as short as possible,
    I have called many objects using simple letters, like `a`, `b`, `c`, `d`, and
    so on. This is perfectly ok when you debug on the console or when you show that
    `a + b == 7`, but it's bad practice when it comes to professional coding (or any
    type of coding, for all that matter). I hope you will indulge me if I sometimes
    do it, the reason is to present the code in a more compact way.
  prefs: []
  type: TYPE_NORMAL
- en: In a real environment though, when you choose names for your data, you should
    choose them carefully and they should reflect what the data is about. So, if you
    have a collection of `Customer` objects, `customers` is a perfectly good name
    for it. Would `customers_list`, `customers_tuple`, or `customers_collection` work
    as well? Think about it for a second. Is it good to tie the name of the collection
    to the data type? I don't think so, at least in most cases. So I'd say if you
    have an excellent reason to do so go ahead, otherwise don't. The reason is, once
    that `customers_tuple` starts being used in different places of your code, and
    you realize you actually want to use a list instead of a tuple, you're up for
    some fun refactoring (also known as **wasted time**). Names for data should be
    nouns, and names for functions should be verbs. Names should be as expressive
    as possible. Python is actually a very good example when it comes to names. Most
    of the time you can just guess what a function is called if you know what it does.
    Crazy, huh?
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. Built-in Data Types"), *Meaningful Names*
    of *Clean Code*, *Robert C. Martin*, *Prentice Hall* is entirely dedicated to
    names. It''s an amazing book that helped me improve my coding style in many different
    ways, a must read if you want to take your coding to the next level.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've explored the built-in data types of Python. We've seen
    how many they are and how much can be achieved by just using them in different
    combinations.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen number types, sequences, sets, mappings, collections, we've seen
    that everything is an object, we've learned the difference between mutable and
    immutable, and we've also learned about slicing and indexing (and, proudly, negative
    indexing as well).
  prefs: []
  type: TYPE_NORMAL
- en: We've presented simple examples, but there's much more that you can learn about
    this subject, so stick your nose into the official documentation and explore.
  prefs: []
  type: TYPE_NORMAL
- en: Most of all, I encourage you to try out all the exercises by yourself, get your
    fingers using that code, build some muscle memory, and experiment, experiment,
    experiment. Learn what happens when you divide by zero, when you combine different
    number types into a single expression, when you manage strings. Play with all
    data types. Exercise them, break them, discover all their methods, enjoy them
    and learn them well, damn well.
  prefs: []
  type: TYPE_NORMAL
- en: If your foundation is not rock solid, how good can your code be? And data is
    the foundation for everything. Data shapes what dances around it.
  prefs: []
  type: TYPE_NORMAL
- en: The more you progress with the book, the more it's likely that you will find
    some discrepancies or maybe a small typo here and there in my code (or yours).
    You will get an error message, something will break. That's wonderful! When you
    code, things break all the time, you debug and fix all the time, so consider errors
    as useful exercises to learn something new about the language you're using, and
    not as failures or problems. Errors will keep coming up until your very last line
    of code, that's for sure, so you may as well start making your peace with them
    now.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about iterating and making decisions. We'll see how to actually
    put those collections in use, and take decisions based on the data we're presented
    with. We'll start to go a little faster now that your knowledge is building up,
    so make sure you're comfortable with the contents of this chapter before you move
    to the next one. Once more, have fun, explore, break things. It's a very good
    way to learn.
  prefs: []
  type: TYPE_NORMAL
