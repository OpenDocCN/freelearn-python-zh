- en: Chapter 2. Built-in Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 内置数据类型
- en: '|   | *"Data! Data! Data!" he cried impatiently. "I can''t make bricks without
    clay."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"数据！数据！数据！"他焦急地喊道。“没有粘土，我无法制作砖块。"* |   |'
- en: '|   | --*Sherlock Holmes - The Adventure of the Copper Beeches* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*夏洛克·福尔摩斯 - 铜 Beeches冒险* |'
- en: Everything you do with a computer is managing data. Data comes in many different
    shapes and flavors. It's the music you listen, the movie you stream, the PDFs
    you open. Even the chapter you're reading at this very moment is just a file,
    which is data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你用计算机做的每一件事都是管理数据。数据有多种不同的形状和风味。它是你听的音乐，你流媒体播放的电影，你打开的PDF文件。甚至你此刻正在阅读的章节也只是一个文件，也就是数据。
- en: Data can be simple, an integer number to represent an age, or complex, like
    an order placed on a website. It can be about a single object or about a collection
    of them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是简单的，比如一个整数来表示年龄，或者复杂的，比如在网站上下的订单。它可以关于单个对象，也可以关于它们的集合。
- en: Data can even be about data, that is, metadata. Data that describes the design
    of other data structures or data that describes application data or its context.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数据甚至可以关于数据，即元数据。描述其他数据结构设计的数据或描述应用程序数据及其上下文的数据。
- en: In Python, *objects are abstraction for data*, and Python has an amazing variety
    of data structures that you can use to represent data, or combine them to create
    your own custom data. Before we delve into the specifics, I want you to be very
    clear about objects in Python, so let's talk a little bit more about them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*对象是数据的抽象表示*，Python有各种各样的数据结构，你可以使用它们来表示数据，或者将它们组合起来创建你自己的自定义数据。在我们深入具体细节之前，我希望你对Python中的对象有非常清晰的认识，所以让我们再谈谈它们。
- en: Everything is an object
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 万物皆对象
- en: As we already said, everything in Python is an object. But what really happens
    when you type an instruction like `age = 42` in a Python module?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，Python中的万物都是对象。但当你输入像`age = 42`这样的指令时，实际上会发生什么呢？
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you go to [http://pythontutor.com/](http://pythontutor.com/), you can type
    that instruction into a text box and get its visual representation. Keep this
    website in mind, it's very useful to consolidate your understanding of what goes
    on behind the scenes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问[http://pythontutor.com/](http://pythontutor.com/)，你可以在文本框中输入该指令并获取其视觉表示。记住这个网站，它对于巩固你对幕后发生的事情的理解非常有用。
- en: 'So, what happens is that an object is created. It gets an `id`, the `type`
    is set to `int` (integer number), and the `value` to `42`. A name `age` is placed
    in the global namespace, pointing to that object. Therefore, whenever we are in
    the global namespace, after the execution of that line, we can retrieve that object
    by simply accessing it through its name: `age`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生的事情是一个对象被创建。它获得一个`id`，`type`被设置为`int`（整数），`value`被设置为`42`。名称`age`被放置在全局命名空间中，指向那个对象。因此，每次我们在全局命名空间中，在执行该行之后，我们都可以通过简单地通过其名称访问它来检索该对象：`age`。
- en: 'If you were to move house, you would put all the knives, forks, and spoons
    in a box and label it cutlery. Can you see it''s exactly the same concept? Here''s
    a screenshot of how it may look like (you may have to tweak the settings to get
    to the same view):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你搬家，你会把所有的刀叉和勺子放在一个盒子里，并给它贴上“餐具”的标签。你能看到这和概念完全一样吗？下面是一个截图，展示它可能的样子（你可能需要调整设置才能达到相同的视图）：
- en: '![Everything is an object](img/4715_02_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![万物皆对象](img/4715_02_01.jpg)'
- en: So, for the rest of this chapter, whenever you read something such as `name
    = some_value`, think of a name placed in the namespace that is tied to the scope
    in which the instruction was written, with a nice arrow pointing to an object
    that has an `id`, a `type`, and a `value`. There is a little bit more to say about
    this mechanism, but it's much easier to talk about it over an example, so we'll
    get back to this later.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章的剩余部分，每当你读到像`name = some_value`这样的内容时，请想象一个名称被放置在命名空间中，它与指令编写的范围相关联，并且有一个指向具有`id`、`type`和`value`的对象的箭头。关于这个机制还有更多要说的，但通过例子来说明它要容易得多，所以我们稍后再回到这个话题。
- en: Mutable or immutable? That is the question
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变或不可变？这是一个问题
- en: A first fundamental distinction that Python makes on data is about whether or
    not the value of an object changes. If the value can change, the object is called
    **mutable**, while if the value cannot change, the object is called **immutable**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python在数据上做出的第一个基本区分是关于一个对象的值是否可以改变。如果值可以改变，则该对象被称为**可变**，而如果值不能改变，则该对象被称为**不可变**。
- en: 'It is very important that you understand the distinction between mutable and
    immutable because it affects the code you write, so here''s a question:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 理解可变和不可变之间的区别非常重要，因为它会影响你编写的代码，所以这里有一个问题：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, on the line `#A`, have I changed the value of age? Well,
    no. But now it''s 43 (I hear you say...). Yes, it''s 43, but 42 was an integer
    number, of the type `int`, which is immutable. So, what happened is really that
    on the first line, `age` is a name that is set to point to an `int` object, whose
    value is 42\. When we type `age = 43`, what happens is that another object is
    created, of the type `int` and value 43 (also, the `id` will be different), and
    the name `age` is set to point to it. So, we didn''t change that 42 to 43\. We
    actually just pointed `age` to a different location: the new `int` object whose
    value is 43\. Let''s see the same code also printing the IDs:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在行 `#A` 上，我改变了 `age` 的值吗？嗯，没有。但现在它是43（我听到你说...）。是的，它是43，但42是一个整数，类型为
    `int`，它是不可变的。所以，实际上发生的事情是在第一行，`age` 是一个指向值为42的 `int` 对象的名称。当我们输入 `age = 43` 时，实际上发生的是创建了一个新的对象，类型为
    `int`，值为43（同时，`id` 也会不同），并且名称 `age` 被设置为指向它。所以，我们并没有将42改为43。我们实际上只是将 `age` 指向了另一个位置：值为43的新
    `int` 对象。让我们看看同样的代码也打印了ID：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that we print the IDs by calling the built-in `id` function. As you
    can see, they are different, as expected. Bear in mind that `age` points to one
    object at a time: 42 first, then 43\. Never together.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过调用内置的 `id` 函数来打印ID。正如你所见，它们是不同的，正如预期的那样。请记住，`age` 每次只指向一个对象：首先是42，然后是43。它们永远不会同时指向。
- en: 'Now, let''s see the same example using a mutable object. For this example,
    let''s just use a `Person` object, that has a property `age`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用可变对象来查看相同的例子。为此，我们可以使用一个具有 `age` 属性的 `Person` 对象：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, I set up an object `fab` whose `type` is `Person` (a custom class).
    On creation, the object is given the `age` of 39\. I'm printing it, along with
    the object `id`, right afterwards. Notice that, even after I change `age` to be
    29, the ID of `fab` stays the same (while the ID of `age` has changed, of course).
    Custom objects in Python are mutable (unless you code them not to be). Keep this
    concept in mind, it's very important. I'll remind you about it through the rest
    of the chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我创建了一个名为 `fab` 的对象，其 `type` 为 `Person`（一个自定义类）。在创建时，该对象被赋予了39岁的 `age`。紧接着，我将打印它以及对象的
    `id`。请注意，即使我将 `age` 改为29，`fab` 的ID仍然保持不变（当然，`age` 的ID已经改变）。Python中的自定义对象是可变的（除非你编写代码使其不可变）。请记住这个概念，它非常重要。我将在本章的其余部分提醒你。
- en: Numbers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: Let's start by exploring Python's built-in data types for numbers. Python was
    designed by a man with a master's degree in mathematics and computer science,
    so it's only logical that it has amazing support for numbers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索Python的内置数字数据类型开始。Python是由一个拥有数学和计算机科学硕士学位的人设计的，所以它对数字有惊人的支持是合乎逻辑的。
- en: Numbers are immutable objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是不可变对象。
- en: Integers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: 'Python integers have unlimited range, subject only to the available virtual
    memory. This means that it doesn''t really matter how big a number you want to
    store: as long as it can fit in your computer''s memory, Python will take care
    of it. Integer numbers can be positive, negative, and 0 (zero). They support all
    the basic mathematical operations, as shown in the following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Python整数具有无限的范围，仅受可用虚拟内存的限制。这意味着你想要存储的数字有多大并不重要：只要它能适应你的计算机内存，Python就会处理它。整数可以是正数、负数和0（零）。它们支持所有基本数学运算，如下面的示例所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code should be easy to understand. Just notice one important
    thing: Python has two division operators, one performs the so-called **true division**
    (`/`), which returns the quotient of the operands, and the other one, the so-called
    **integer division** (`//`), which returns the *floored* quotient of the operands.
    See how that is different for positive and negative numbers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该很容易理解。只需注意一点重要的事情：Python有两个除法运算符，一个执行所谓的**真除法**（`/`），它返回操作数的商，另一个执行所谓的**整数除法**（`//`），它返回操作数的**向下取整**商。看看这是如何对正数和负数不同的：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is an interesting example. If you were expecting a `-1` on the last line,
    don''t feel bad, it''s just the way Python works. The result of an integer division
    in Python is always rounded towards minus infinity. If instead of flooring you
    want to truncate a number to an integer, you can use the built-in `int` function,
    like shown in the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的例子。如果你在最后一行期待一个`-1`，请不要感到难过，这只是Python的工作方式。Python中整数除法的结果总是四舍五入到负无穷。如果你想要截断一个数字到整数，而不是向下取整，你可以使用内置的`int`函数，如下面的例子所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that truncation is done towards 0.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 截断操作是向0进行的。
- en: 'There is also an operator to calculate the remainder of a division. It''s called
    modulo operator, and it''s represented by a percent (`%`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个用于计算除法余数的运算符。它被称为取模运算符，用百分号(`%`)表示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Booleans
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'Boolean algebra is that subset of algebra in which the values of the variables
    are the truth values: true and false. In Python, `True` and `False` are two keywords
    that are used to represent truth values. Booleans are a subclass of integers,
    and behave respectively like 1 and 0\. The equivalent of the `int` class for Booleans
    is the `bool` class, which returns either `True` or `False`. Every built-in Python
    object has a value in the Boolean context, which means they basically evaluate
    to either `True` or `False` when fed to the `bool` function. We''ll see all about
    this in [Chapter 3](ch03.html "Chapter 3. Iterating and Making Decisions"), *Iterating
    and Making Decisions*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数是代数的一个子集，其中变量的值是真理值：真和假。在Python中，`True`和`False`是两个用于表示真理值的保留字。布尔值是整数的一个子类，分别对应于1和0。布尔值的`int`类等价于`bool`类，它返回`True`或`False`。每个内置的Python对象在布尔上下文都有一个值，这意味着当它们被`bool`函数处理时，基本上会评估为`True`或`False`。我们将在[第3章](ch03.html
    "第3章。迭代和决策")中详细了解这一点，*迭代和决策*。
- en: 'Boolean values can be combined in Boolean expressions using the logical operators
    `and`, `or`, and `not`. Again, we''ll see them in full in the next chapter, so
    for now let''s just see a simple example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值可以通过逻辑运算符`and`、`or`和`not`在布尔表达式中组合。同样，我们将在下一章中完整地看到它们，所以现在让我们先看看一个简单的例子：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see that `True` and `False` are subclasses of integers when you try
    to add them. Python upcasts them to integers and performs addition:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试将它们相加时，你可以看到`True`和`False`是整数的一个子类。Python将它们向上转型为整数并执行加法：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Upcasting** is a type conversion operation that goes from a subclass to its
    parent. In the example presented here, `True` and `False`, which belong to a class
    derived from the integer class, are converted back to integers when needed. This
    topic is about inheritance and will be explained in detail in [Chapter 6](ch06.html
    "Chapter 6. Advanced Concepts – OOP, Decorators, and Iterators"), *Advanced Concepts
    – OOP, Decorators, and Iterators*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**向上转型**是一种类型转换操作，它从子类转换为其父类。在下面给出的例子中，`True`和`False`，它们属于从整数类派生出的一个类，当需要时会被转换回整数。这个话题涉及到继承，将在[第6章](ch06.html
    "第6章。高级概念 – 面向对象编程、装饰器和迭代器")中详细解释，*高级概念 – 面向对象编程、装饰器和迭代器*。'
- en: Reals
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实数
- en: 'Real numbers, or floating point numbers, are represented in Python according
    to the IEEE 754 double-precision binary floating-point format, which is stored
    in 64 bits of information divided into three sections: sign, exponent, and mantissa.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实数或浮点数在Python中按照IEEE 754双精度二进制浮点格式表示，该格式存储在64位信息中，分为三个部分：符号、指数和尾数。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Quench your thirst for knowledge about this format on Wikipedia: [http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在维基百科上了解有关此格式的知识：[http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format)
- en: 'Usually programming languages give coders two different formats: single and
    double precision. The former taking up 32 bits of memory, and the latter 64\.
    Python supports only the double format. Let''s see a simple example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编程语言为程序员提供两种不同的格式：单精度和双精度。前者占用32位内存，后者占用64位。Python只支持双精度格式。让我们看看一个简单的例子：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the calculation of the area, I wrapped the `radius ** 2` within braces. Even
    though that wasn't necessary because the power operator has higher precedence
    than the multiplication one, I think the formula reads more easily like that.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算面积的计算中，我将`radius ** 2`用括号括起来。尽管这并不是必要的，因为幂运算符的优先级高于乘法运算符，但我认为这样公式读起来更清晰。
- en: 'The `sys.float_info` struct sequence holds information about how floating point
    numbers will behave on your system. This is what I see on my box:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.float_info` 结构序列包含了关于浮点数在你的系统上如何表现的信息。这是我在我机器上看到的内容：'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s make a few considerations here: we have 64 bits to represent float numbers.
    This means we can represent at most `2 ** 64 == 18,446,744,073,709,551,616` numbers
    with that amount of bits. Take a look at the `max` and `epsilon` value for the
    float numbers, and you''ll realize it''s impossible to represent them all. There
    is just not enough space so they are approximated to the closest representable
    number. You probably think that only extremely big or extremely small numbers
    suffer from this issue. Well, think again:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里让我们做一些考虑：我们有 64 位来表示浮点数。这意味着我们最多可以用这么多位表示 `2 ** 64 == 18,446,744,073,709,551,616`
    个数字。看看浮点数的 `max` 和 `epsilon` 值，你就会意识到无法表示它们全部。空间不足，所以它们被近似到最接近的可表示的数字。你可能认为只有极大或极小的数字会受到影响。但再想想：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What does this tell you? It tells you that double precision numbers suffer from
    approximation issues even when it comes to simple numbers like 0.1 or 0.3\. Why
    is this important? It can be a big problem if you're handling prices, or financial
    calculations, or any kind of data that needs not to be approximated. Don't worry,
    Python gives you the **Decimal** type, which doesn't suffer from these issues,
    we'll see them in a bit.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你什么？它告诉你，即使是像 0.1 或 0.3 这样简单的数字，双精度数也会出现近似问题。为什么这很重要？如果你处理的是价格、金融计算或任何需要精确表示的数据，这可能会成为一个大问题。别担心，Python
    给你提供了 **Decimal** 类型，它不会出现这些问题，我们稍后会看到。
- en: Complex numbers
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数
- en: Python gives you complex numbers support out of the box. If you don't know what
    complex numbers are, you can look them up on the Web. They are numbers that can
    be expressed in the form *a + ib* where *a* and *b* are real numbers, and *i*
    (or *j* if you're an engineer) is the imaginary unit, that is, the square root
    of -1\. *a* and *b* are called respectively the *real* and *imaginary* part of
    the number.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python 默认支持复数。如果你不知道什么是复数，你可以在网上查找。它们是可以表示为 *a + ib* 形式的数字，其中 *a* 和 *b* 是实数，而
    *i*（或者如果你是工程师，是 *j*）是虚数单位，即 -1 的平方根。*a* 和 *b* 分别称为数字的 *实部* 和 *虚部*。
- en: 'It''s actually unlikely you''ll be using them, unless you''re coding something
    scientific. Let''s see a small example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，除非你在编写科学相关的代码，否则你不太可能使用它们。让我们看一个小例子：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Fractions and decimals
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分数和小数
- en: 'Let''s finish the tour of the number department with a look at fractions and
    decimals. Fractions hold a rational numerator and denominator in their lowest
    forms. Let''s see a quick example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看分数和小数来结束对数字部门的巡礼。分数以它们的最简形式持有有理的分子和分母。让我们看一个快速示例：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although they can be very useful at times, it's not that common to spot them
    in commercial software. Much easier instead, is to see decimal numbers being used
    in all those contexts where precision is everything, for example, scientific and
    financial calculations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们有时非常有用，但在商业软件中并不常见。相反，更容易看到在所有那些精度至关重要的环境中使用小数，例如科学和金融计算。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to remember that arbitrary precision decimal numbers come at
    a price in performance, of course. The amount of data to be stored for each number
    is far greater than it is for fractions or floats as well as the way they are
    handled, which requires the Python interpreter much more work behind the scenes.
    Another interesting thing to know is that you can get and set the precision by
    accessing `decimal.getcontext().prec`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，任意精度小数在性能上是有代价的，当然。每个数字要存储的数据量远远大于分数或浮点数，以及它们被处理的方式，这需要 Python 解释器在幕后做更多的工作。另一个有趣的事实是，你可以通过访问
    `decimal.getcontext().prec` 来获取和设置精度。
- en: 'Let''s see a quick example with `Decimal` numbers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个 `Decimal` 数字来快速看一下示例：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that when we construct a `Decimal` number from a `float`, it takes on
    all the approximation issues the `float` may come from. On the other hand, when
    the `Decimal` has no approximation issues, for example, when we feed an `int`
    or a `string` representation to the constructor, then the calculation has no quirky
    behavior. When it comes to money, use decimals.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到当我们从一个 `float` 构造一个 `Decimal` 数字时，它会继承 `float` 可能带来的所有近似问题。另一方面，当 `Decimal`
    没有近似问题时，例如，当我们向构造函数提供 `int` 或 `string` 表示时，计算就没有奇怪的行为。当涉及到金钱时，使用小数。
- en: This concludes our introduction to built-in numeric types, let's now see sequences.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对内置数字类型的介绍，现在让我们看看序列。
- en: Immutable sequences
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变序列
- en: 'Let''s start with immutable sequences: strings, tuples, and bytes.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从不可变序列开始：字符串、元组和字节。
- en: Strings and bytes
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串和字节
- en: 'Textual data in Python is handled with **str** objects, more commonly known
    as strings. They are immutable sequences of **unicode code points**. Unicode code
    points can represent a character, but can also have other meanings, such as formatting
    data for example. Python, unlike other languages, doesn''t have a `char` type,
    so a single character is rendered simply by a string of length 1\. Unicode is
    an excellent way to handle data, and should be used for the internals of any application.
    When it comes to store textual data though, or send it on the network, you may
    want to encode it, using an appropriate encoding for the medium you''re using.
    String literals are written in Python using single, double or triple quotes (both
    single or double). If built with triple quotes, a string can span on multiple
    lines. An example will clarify the picture:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的文本数据通过 **str** 对象处理，更常见的是字符串。它们是不可变的 **unicode 代码点** 序列。Unicode 代码点可以表示一个字符，但也可以有其他含义，例如格式化数据等。Python
    与其他语言不同，没有 `char` 类型，所以一个字符简单地通过长度为 1 的字符串来表示。Unicode 是处理数据的一种优秀方式，应该用于任何应用程序的内部。当涉及到存储文本数据或通过网络发送数据时，你可能想要使用适当的编码对其进行编码。Python
    中的字符串字面量使用单引号、双引号或三引号（单或双）编写。如果使用三引号构建，字符串可以跨越多行。以下是一个示例，以阐明情况：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In `#A` and `#B`, we print `str4`, first implicitly, then explicitly using the
    `print` function. A nice exercise would be to find out why they are different.
    Are you up to the challenge? (hint, look up the `str` function)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `#A` 和 `#B` 中，我们打印 `str4`，首先隐式地，然后显式地使用 `print` 函数。一个不错的练习是找出为什么它们不同。你能接受这个挑战吗？（提示：查看
    `str` 函数）
- en: 'Strings, like any sequence, have a length. You can get this by calling the
    `len` function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串，像任何序列一样，都有长度。你可以通过调用 `len` 函数来获取它：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Encoding and decoding strings
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串的编码和解码
- en: Using the `encode`/`decode` methods, we can encode unicode strings and decode
    bytes objects. **Utf-8** is a variable length character encoding, capable of encoding
    all possible unicode code points. It is the dominant encoding for the Web (and
    not only). Notice also that by adding a literal `b` in front of a string declaration,
    we're creating a *bytes* object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `encode`/`decode` 方法，我们可以对 unicode 字符串进行编码，对字节对象进行解码。**Utf-8** 是一种可变长度的字符编码，能够编码所有可能的
    unicode 代码点。它是网络（以及不仅仅是网络）中的主流编码。注意，通过在字符串声明前添加一个字面量 `b`，我们正在创建一个 *bytes* 对象。
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Indexing and slicing strings
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串的索引和切片
- en: When manipulating sequences, it's very common to have to access them at one
    precise position (indexing), or to get a subsequence out of them (slicing). When
    dealing with immutable sequences, both operations are read-only.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作序列时，经常需要在一个精确的位置（索引）访问它们，或者从它们中获取子序列（切片）。当处理不可变序列时，这两种操作都是只读的。
- en: 'While indexing comes in one form, a zero-based access to any position within
    the sequence, slicing comes in different forms. When you get a slice of a sequence,
    you can specify the `start` and `stop` positions, and the `step`. They are separated
    with a colon (`:`) like this: `my_sequence[start:stop:step]`. All the arguments
    are optional, `start` is inclusive, `stop` is exclusive. It''s much easier to
    show an example, rather than explain them further in words:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然索引只有一种形式，即对序列中任何位置的零基访问，但切片有多种形式。当你从序列中获取一个切片时，你可以指定 `start` 和 `stop` 位置以及
    `step`。它们用冒号（`:`）分隔，如下所示：`my_sequence[start:stop:step]`。所有参数都是可选的，`start` 是包含的，`stop`
    是排除的。通过一个例子来展示，比用文字进一步解释它们要容易得多：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of all the lines, the last one is probably the most interesting. If you don't
    specify a parameter, Python will fill in the default for you. In this case, `start`
    will be the start of the string, `stop` will be the end of the sting, and `step`
    will be the default 1\. This is an easy and quick way of obtaining a copy of the
    string `s` (same value, but different object). Can you find a way to get the reversed
    copy of a string using slicing? (don't look it up, find it for yourself)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有行中，最后一行可能是最有趣的。如果你没有指定参数，Python 会为你填充默认值。在这种情况下，`start` 将是字符串的开始，`stop` 将是字符串的结束，而
    `step` 将是默认的 1。这是一种简单快捷的方法来获取字符串 `s` 的副本（相同的值，但不同的对象）。你能找到一种使用切片获取字符串反转副本的方法吗？（不要查找，自己找到它）
- en: Tuples
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'The last immutable sequence type we''re going to see is the tuple. A **tuple**
    is a sequence of arbitrary Python objects. In a tuple, items are separated by
    commas. They are used everywhere in Python, because they allow for patterns that
    are hard to reproduce in other languages. Sometimes tuples are used implicitly,
    for example to set up multiple variables on one line, or to allow a function to
    return multiple different objects (usually a function returns one object only,
    in many other languages), and even in the Python console, you can use tuples implicitly
    to print multiple elements with one single instruction. We''ll see examples for
    all these cases:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看到的最后一个不可变序列类型是元组。**元组**是任意Python对象的序列。在元组中，元素由逗号分隔。它们在Python中到处使用，因为它们允许其他语言难以复制的模式。有时元组是隐式使用的，例如在一行中设置多个变量，或者允许函数返回多个不同的对象（在许多其他语言中，函数通常只返回一个对象），甚至在Python控制台中，你可以隐式地使用元组来使用一条指令打印多个元素。我们将看到所有这些情况的示例：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that the membership operator `in` can also be used with lists, strings,
    dictionaries, and in general with collection and sequence objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，成员运算符`in`也可以与列表、字符串、字典以及一般与集合和序列对象一起使用。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that to create a tuple with one item, we need to put that comma after
    the item. The reason is that without the comma that item is just itself wrapped
    in braces, kind of in a redundant mathematical expression. Notice also that on
    assignment, braces are optional so `my_tuple = 1, 2, 3` is the same as `my_tuple
    = (1, 2, 3)`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要创建一个只有一个元素的元组，我们需要在该元素后放置逗号。原因是如果没有逗号，该元素只是被大括号包裹，有点像冗余的数学表达式。注意，在赋值时，大括号是可选的，所以`my_tuple
    = 1, 2, 3`与`my_tuple = (1, 2, 3)`是相同的。
- en: 'One thing that tuple assignment allows us to do, is *one-line swaps*, with
    no need for a third temporary variable. Let''s see first a more traditional way
    of doing it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 元组赋值允许我们做的一件事是*一行交换*，无需第三个临时变量。我们先看看一种更传统的方法：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And now let''s see how we would do it in Python:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在Python中实现：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Take a look at the line that shows you the Pythonic way of swapping two values:
    do you remember what I wrote in [Chapter 1](ch01.html "Chapter 1. Introduction
    and First Steps – Take a Deep Breath"), *Introduction and First Steps – Take a
    Deep Breath*. A Python program is typically one-fifth to one-third the size of
    equivalent Java or C++ code, and features like one-line swaps contribute to this.
    Python is elegant, where elegance in this context means also economy.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 看看显示Python交换两个值方式的行：你还记得我在[第1章](ch01.html "第1章。简介和第一步 – 深呼吸")，“简介和第一步 – 深呼吸”中写了什么吗？Python程序通常比等价的Java或C++代码小五分之一到三分之一，而像一行交换这样的特性也对此有所贡献。Python是优雅的，这里的优雅也意味着经济。
- en: Because they are immutable, tuples can be used as keys for dictionaries (we'll
    see this shortly). The `dict` objects need keys to be immutable because if they
    could change, then the value they reference wouldn't be found any more (because
    the path to it depends on the key). If you are into data structures, you know
    how nice a feature this one is to have. To me, tuples are Python's built-in data
    that most closely represent a mathematical vector. This doesn't mean that this
    was the reason for which they were created though. Tuples usually contain an heterogeneous
    sequence of elements, while on the other hand lists are most of the times homogeneous.
    Moreover, tuples are normally accessed via unpacking or indexing, while lists
    are usually iterated over.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是不可变的，元组可以用作字典的键（我们很快就会看到这一点）。`dict`对象需要键是不可变的，因为如果它们可以改变，那么它们引用的值就找不到（因为到达它的路径依赖于键）。如果你对数据结构感兴趣，你知道这个特性是多么好。对我来说，元组是Python内置的数据，最接近数学向量。但这并不意味着这就是它们被创建的原因。元组通常包含异构元素序列，而另一方面，列表大多数时候是同质的。此外，元组通常通过解包或索引访问，而列表通常通过迭代访问。
- en: Mutable sequences
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变序列
- en: 'Mutable sequences differ from their immutable sisters in that they can be changed
    after creation. There are two mutable sequence types in Python: lists and byte
    arrays. I said before that the dictionary is the king of data structures in Python.
    I guess this makes the list its rightful queen.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可变序列与它们的不可变姐妹不同，因为它们在创建后可以更改。Python中有两种可变序列类型：列表和字节数组。我之前说过，字典是Python中数据结构的王者。我想这使列表成为它的合法王后。
- en: Lists
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'Python lists are mutable sequences. They are very similar to tuples, but they
    don''t have the restrictions due to immutability. Lists are commonly used to store
    collections of homogeneous objects, but there is nothing preventing you to store
    heterogeneous collections as well. Lists can be created in many different ways,
    let''s see an example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表是可变的序列。它们与元组非常相似，但它们没有由于不可变性而导致的限制。列表通常用于存储同质对象的集合，但没有任何东西阻止您存储异质集合。列表可以通过许多不同的方式创建，让我们看一个例子：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous example, I showed you how to create a list using different techniques.
    I would like you to take a good look at the line that says `Python is magic`,
    which I am not expecting you to fully understand at this point (unless you cheated
    and you're not a novice!). That is called a **list** **comprehension**, a very
    powerful functional feature of Python, which we'll see in detail in [Chapter 5](ch05.html
    "Chapter 5. Saving Time and Memory"), *Saving Time and Memory*. I just wanted
    to make your mouth water at this point.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我向您展示了如何使用不同的技术创建列表。我希望您仔细看看写着`Python is magic`的那一行，我现在并不期望您完全理解这一点（除非您作弊了，而且您不是新手！）。这被称为**列表**
    **推导式**，这是Python一个非常强大的功能特性，我们将在[第5章](ch05.html "第5章。节省时间和内存")“节省时间和内存”中详细探讨。我只想让您在这个阶段对它产生兴趣。
- en: 'Creating lists is good, but the real fun comes when we use them, so let''s
    see the main methods they gift us with:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表固然不错，但真正的乐趣在于使用它们，所以让我们看看它们赋予我们的主要方法：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code gives you a roundup of list''s main methods. I want to show
    you how powerful they are, using `extend` as an example. You can extend lists
    using any sequence type:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为您概述了列表的主要方法。我想向您展示它们有多么强大，以`extend`方法为例。您可以使用任何序列类型来扩展列表：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s see what are the most common operations you can do with lists:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看您可以使用列表执行的最常见操作：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last two lines in the preceding code are quite interesting because they
    introduce us to a concept called **operator** **overloading**. In short, it means
    that operators such as `+`, `-`. `*`, `%`, and so on, may represent different
    operations according to the context they are used in. It doesn''t make any sense
    to sum two lists, right? Therefore, the `+` sign is used to concatenate them.
    Hence, the `*` sign is used to concatenate the list to itself according to the
    right operand. Now, let''s take a step further down the rabbit hole and see something
    a little more interesting. I want to show you how powerful the sort method can
    be and how easy it is in Python to achieve results that require a great deal of
    effort in other languages:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的最后两行非常有趣，因为它们向我们介绍了一个称为**操作符** **重载**的概念。简而言之，这意味着像`+`、`-`、`*`、`%`等操作符可以根据它们使用的上下文表示不同的操作。将两个列表相加没有意义，对吧？因此，`+`符号用于连接它们。因此，`*`符号用于根据右操作数将列表连接到自身。现在，让我们进一步深入这个兔子洞，看看一些更有趣的东西。我想向您展示排序方法有多么强大，以及Python如何轻松实现其他语言中需要大量努力才能实现的结果：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code deserves a little explanation. First of all, `a` is a list
    of tuples. This means each element in `a` is a tuple (a *2-tuple*, to be picky).
    When we call `sorted(some_list)`, we get a sorted version of `some_list`. In this
    case, the sorting on a 2-tuple works by sorting them on the first item in the
    tuple, and on the second when the first one is the same. You can see this behavior
    in the result of `sorted(a)`, which yields `[(1, 2), (1, 3), ...]`. Python also
    gives us the ability to control on which element(s) of the tuple the sorting must
    be run against. Notice that when we instruct the `sorted` function to work on
    the first element of each tuple (by `key=itemgetter(0)`), the result is different:
    `[(1, 3), (1, 2), ...]`. The sorting is done only on the first element of each
    tuple (which is the one at position 0). If we want to replicate the default behavior
    of a simple `sorted(a)` call, we need to use `key=itemgetter(0, 1)`, which tells
    Python to sort first on the elements at position 0 within the tuples, and then
    on those at position 1\. Compare the results and you''ll see they match.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码需要一点解释。首先，`a` 是一个元组列表。这意味着 `a` 中的每个元素都是一个元组（严格来说，是一个 *2-元组*）。当我们调用 `sorted(some_list)`
    时，我们得到 `some_list` 的排序版本。在这种情况下，对 2-元组的排序是通过在元组的第一个元素上进行排序，当第一个元素相同时，则在第二个元素上进行排序。您可以在
    `sorted(a)` 的结果中看到这种行为，它产生 `[(1, 2), (1, 3), ...]`。Python 还赋予我们控制元组中哪个元素（哪些元素）必须进行排序的能力。请注意，当我们指示
    `sorted` 函数对每个元组的第一个元素进行操作（通过 `key=itemgetter(0)`）时，结果就不同了：`[(1, 3), (1, 2), ...]`。排序仅在每个元组的第一个元素上进行（即位置
    0 的元素）。如果我们想复制简单的 `sorted(a)` 调用的默认行为，我们需要使用 `key=itemgetter(0, 1)`，这告诉 Python
    首先在元组内的位置 0 的元素上进行排序，然后是在位置 1 的元素上。比较结果，您会发现它们是一致的。
- en: For completeness, I included an example of sorting only on the elements at position
    1, and the same but in reverse order. If you have ever seen sorting in Java, I
    expect you to be on your knees crying with joy at this very moment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我包括了一个仅对位置 1 的元素进行排序的例子，以及相同但顺序相反的例子。如果您曾经见过 Java 中的排序，我预计您此刻会跪在地上欣喜若狂。
- en: The Python sorting algorithm is very powerful, and it was written by Tim Peters
    (we've already seen this name, can you recall when?). It is aptly named **Timsort**,
    and it is a blend between **merge** and **insertion** **sort** and has better
    time performances than most other algorithms used for mainstream programming languages.
    Timsort is a stable sorting algorithm, which means that when multiple records
    have the same key, their original order is preserved. We've seen this in the result
    of `sorted(a, key=itemgetter(0))` which has yielded `[(1, 3), (1, 2), ...]` in
    which the order of those two tuples has been preserved because they have the same
    value at position 0.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的排序算法非常强大，它是由 Tim Peters 编写的（我们之前已经见过这个名字，你能回忆起是在什么时候吗？）。它恰当地命名为 **Timsort**，它是
    **归并** 和 **插入** 排序的结合，并且比大多数用于主流编程语言的算法具有更好的时间性能。Timsort 是一个稳定的排序算法，这意味着当多个记录具有相同的键时，它们的原始顺序被保留。我们在
    `sorted(a, key=itemgetter(0))` 的结果中已经看到了这一点，它产生了 `[(1, 3), (1, 2), ...]`，其中这两个元组的顺序被保留，因为它们在位置
    0 的值是相同的。
- en: Byte arrays
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节数组
- en: To conclude our overview of mutable sequence types, let's spend a couple of
    minutes on the `bytearray` type. Basically, they represent the mutable version
    of `bytes` objects. They expose most of the usual methods of mutable sequences
    as well as most of the methods of the `bytes` type. Items are integers in the
    range [0, 256).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们对可变序列类型的概述，让我们花几分钟时间来谈谈 `bytearray` 类型。基本上，它们是 `bytes` 对象的可变版本。它们公开了大多数可变序列的常用方法以及
    `bytes` 类型的大多数方法。元素是范围在 [0, 256) 内的整数。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When it comes to intervals, I''m going to use the standard notation for open/closed
    ranges. A square bracket on one end means that the value is included, while a
    round brace means it''s excluded. The granularity is usually inferred by the type
    of the edge elements so, for example, the interval [3, 7] means all integers between
    3 and 7, inclusive. On the other hand, (3, 7) means all integers between 3 and
    7 exclusive (hence 4, 5, and 6). Items in a `bytearray` type are integers between
    0 and 256, 0 is included, 256 is not. One reason intervals are often expressed
    like this is to ease coding. If we break a range [a, b) into *N* consecutive ranges,
    we can easily represent the original one as a concatenation like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到区间时，我将使用标准的开/闭范围表示法。一端上的方括号表示值被包含，而圆括号表示被排除。粒度通常由边缘元素的类型推断，例如，区间 [3, 7]
    表示介于 3 和 7 之间的所有整数，包括 3 和 7。另一方面，(3, 7) 表示介于 3 和 7 之间的所有整数，不包括 4、5 和 6。`bytearray`
    类型的项是介于 0 和 256 之间的整数，包括 0，不包括 256。区间通常以这种方式表达的一个原因是便于编码。如果我们把范围 [a, b) 分成 *N*
    个连续的范围，我们可以很容易地将其表示为这样的连接：
- en: '![Byte arrays](img/4715_02_04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![字节数组](img/4715_02_04.jpg)'
- en: The middle points (*k* *[i]*) being excluded on one end, and included on the
    other end, allow for easy concatenation and splitting when intervals are handled
    in the code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中处理区间时，排除了中间点 (*k* *[i]*) 的一端，并包含另一端，这使得在处理区间时易于连接和分割。
- en: 'Let''s see a quick example with the type `bytearray`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个快速例子来看看 `bytearray` 类型：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see in the preceding code, there are a few ways to create a `bytearray`
    object. They can be useful in many situations, for example, when receiving data
    through a **socket**, they eliminate the need to concatenate data while polling,
    hence they prove very handy. On the line `#A`, I created the `name` `bytearray`
    from the string `b'Lina'` to show you how the `bytearray` object exposes methods
    from both sequences and strings, which is extremely handy. If you think about
    it, they can be considered as mutable strings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，创建 `bytearray` 对象有几种方法。它们在许多情况下可能很有用，例如，在通过 **套接字** 接收数据时，它们消除了在轮询时需要连接数据的需求，因此它们非常方便。在行
    `#A` 中，我从字符串 `b'Lina'` 创建了 `name` `bytearray` 来向您展示 `bytearray` 对象如何公开序列和字符串的方法，这非常方便。如果你这么想，它们可以被认为是可变字符串。
- en: Set types
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合类型
- en: Python also provides two set types, `set` and `frozenset`. The `set` type is
    mutable, while `frozenset` is immutable. They are unordered collections of immutable
    objects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还提供了两种集合类型，`set` 和 `frozenset`。`set` 类型是可变的，而 `frozenset` 是不可变的。它们是无序的不变对象集合。
- en: '**Hashability** is a characteristic that allows an object to be used as a set
    member as well as a key for a dictionary, as we''ll see very soon.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**可哈希性** 是一个特性，它允许一个对象既可以作为集合的成员，也可以作为字典的键，正如我们很快就会看到的。'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: An object is hashable if it has a hash value which never changes during its
    lifetime.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象如果是可哈希的，那么它在其生命周期内具有一个永远不会改变的哈希值。
- en: 'Objects that compare equally must have the same hash value. Sets are very commonly
    used to test for membership, so let''s introduce the `in` operator in the following
    example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 比较相等的对象必须具有相同的哈希值。集合通常用于测试成员资格，所以让我们在以下示例中介绍 `in` 操作符：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, you can see two different ways to create a set. One creates
    an empty set and then adds elements one at a time. The other creates the set using
    a list of numbers as argument to the constructor, which does all the work for
    us. Of course, you can create a set from a list or tuple (or any iterable) and
    then you can add and remove members from the set as you please.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到创建集合的两种不同方式。一种是一次创建一个空集合，然后逐个添加元素。另一种是使用构造函数的参数作为数字列表来创建集合，这为我们做了所有的工作。当然，你可以从列表、元组（或任何可迭代对象）中创建一个集合，然后你可以按需添加和删除集合成员。
- en: 'Another way of creating a set is by simply using the curly braces notation,
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集合的另一种方法是简单地使用花括号表示法，如下所示：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice I added some duplication to emphasize that the result set won't have
    any.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我添加了一些重复内容来强调结果集合将不会有任何重复。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: We'll see iterable objects and iteration in the next chapter. For now, just
    know that iterable objects are objects you can iterate on in a direction.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章看到可迭代对象和迭代。现在，只需知道可迭代对象是可以按一定方向迭代的对象。
- en: 'Let''s see an example about the immutable counterpart of the set type: `frozenset`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看关于集合类型不可变对应物的例子：`frozenset`。
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, `frozenset` objects are quite limited in respect of their mutable
    counterpart. They still prove very effective for membership test, union, intersection
    and difference operations, and for performance reasons.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`frozenset`对象在其可变对应物方面相当有限。它们在成员测试、并集、交集和差集操作中仍然非常有效，并且出于性能考虑。
- en: Mapping types – dictionaries
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类型 – 字典
- en: Of all the built-in Python data types, the dictionary is probably the most interesting
    one. It's the only standard mapping type, and it is the backbone of every Python
    object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有内置的Python数据类型中，字典可能是最有趣的一个。它是唯一的标准映射类型，并且是每个Python对象的骨架。
- en: A dictionary maps keys to values. Keys need to be hashable objects, while values
    can be of any arbitrary type. Dictionaries are mutable objects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 字典将键映射到值。键需要是可哈希的对象，而值可以是任何任意类型。字典是可变对象。
- en: 'There are quite a few different ways to create a dictionary, so let me give
    you a simple example of how to create a dictionary equal to `{''A'': 1, ''Z'':
    -1}` in five different ways:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '创建字典有相当多的不同方法，所以让我给你一个简单的例子，展示如何以五种不同的方式创建一个等于`{''A'': 1, ''Z'': -1}`的字典：'
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Have you noticed those double equals? Assignment is done with one equal, while
    to check whether an object is the same as another one (or 5 in one go, in this
    case), we use double equals. There is also another way to compare objects, which
    involves the **is** operator, and checks whether the two objects are the same
    (if they have the same ID, not just the value), but unless you have a good reason
    to use it, you should use the double equal instead. In the preceding code, I also
    used one nice function: `zip`. It is named after the real-life zip, which glues
    together two things taking one element from each at a time. Let me show you an
    example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到那些双等号吗？赋值使用一个等号，而要检查一个对象是否与另一个对象相同（或者在这种情况下一次性检查5个），我们使用双等号。还有另一种比较对象的方法，它涉及到**is**运算符，并检查两个对象是否相同（如果它们有相同的ID，而不仅仅是值），但除非你有很好的理由使用它，否则你应该使用双等号。在前面的代码中，我还使用了一个很棒的功能：`zip`。这个名字来源于现实生活中的zip，它一次取两个东西中的一个元素来粘合。让我给你举一个例子：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding example, I have created the same list in two different ways,
    one more explicit, and the other a little bit more Pythonic. Forget for a moment
    that I had to wrap the `list` constructor around the `zip` call (the reason is
    because `zip` returns an iterator, not a `list`), and concentrate on the result.
    See how `zip` has coupled the first elements of its two arguments together, then
    the second ones, then the third ones, and so on and so forth? Take a look at your
    pants (or at your purse if you''re a lady) and you''ll see the same behavior in
    your actual zip. But let''s go back to dictionaries and see how many wonderful
    methods they expose for allowing us to manipulate them as we want. Let''s start
    with the basic operations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我以两种不同的方式创建了相同的列表，一种更为明确，另一种则更符合Python风格。暂时忘记我必须将`list`构造函数包裹在`zip`调用中（原因是因为`zip`返回的是一个迭代器，而不是一个`list`），让我们专注于结果。看看`zip`是如何将其两个参数的第一个元素配对在一起，然后是第二个元素，然后是第三个元素，以此类推？看看你的裤子（如果你是女士，看看你的钱包）你就会在你的实际zip中看到同样的行为。但让我们回到字典，看看它们为我们提供了多少奇妙的方法来按我们的意愿操作它们。让我们从基本操作开始：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice how accessing keys of a dictionary, regardless of the type of operation
    we're performing, is done through square brackets. Do you remember strings, list,
    and tuples? We were accessing elements at some position through square brackets
    as well. Yet another example of Python's consistency.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意观察访问字典键的方式，无论我们执行的操作类型如何，都是通过方括号来完成的。你还记得字符串、列表和元组吗？我们也是通过方括号来访问某些位置的元素。这又是Python一致性的另一个例子。
- en: 'Let''s see now three special objects called dictionary views: `keys`, `values`,
    and `items`. These objects provide a dynamic view of the dictionary entries and
    they change when the dictionary changes. `keys()` returns all the keys in the
    dictionary, `values()` returns all the values in the dictionary, and `items()`
    returns all the *(key, value)* pairs in the dictionary.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看三个称为字典视图的特殊对象：`keys`、`values`和`items`。这些对象提供了对字典条目的动态视图，并且当字典发生变化时它们也会变化。`keys()`返回字典中的所有键，`values()`返回字典中的所有值，而`items()`返回字典中的所有*(键，值)*对。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It''s very important to know that, even if a dictionary is not intrinsically
    ordered, according to the Python documentation: "*Keys and values are iterated
    over in an arbitrary order which is non-random, varies across Python implementations,
    and depends on the dictionary''s history of insertions and deletions. If keys,
    values and items views are iterated over with no intervening modifications to
    the dictionary, the order of items will directly correspond.*"'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要知道，即使字典本身不是有序的，根据Python文档：“*键和值以任意顺序迭代，这种顺序是非随机的，因Python实现而异，并取决于字典的插入和删除历史。如果没有对字典进行任何中间修改，则迭代键、值和项目视图时，项目顺序将直接对应。*”
- en: 'Enough with this chatter, let''s put all this down into code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的闲聊了，让我们把这些都写进代码中：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A few things to notice in the preceding code. First, notice how we're creating
    a dictionary by iterating over the zipped version of the string `'hello'` and
    the list `[0, 1, 2, 3, 4]`. The string `'hello'` has two `'l'` characters inside,
    and they are paired up with the values 2 and 3 by the zip function. Notice how
    in the dictionary, the second occurrence of the `'l'` key (the one with value
    3), overwrites the first one (the one with value 2). Another thing to notice is
    that when asking for any view, the original order is lost, but is consistent within
    the views, as expected. Notice also that you may have different results when you
    try this code on your machine. Python doesn't guarantee that, it only guarantees
    the consistency of the order in which the views are presented.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有几个需要注意的地方。首先，注意我们是如何通过迭代字符串`'hello'`和列表`[0, 1, 2, 3, 4]`的压缩版本来创建字典的。字符串`'hello'`中有两个`'l'`字符，它们通过`zip`函数与值2和3配对。注意在字典中，`'l'`键的第二次出现（值为3）会覆盖第一次出现（值为2）。另一件要注意的事情是，当请求任何视图时，原始顺序会丢失，但在视图内部是一致的，正如预期的那样。还要注意，当你在自己的机器上尝试这段代码时，可能会得到不同的结果。Python不保证这一点，它只保证视图呈现顺序的一致性。
- en: 'We''ll see how these views are fundamental tools when we talk about iterating
    over collections. Let''s take a look now at some other methods exposed by Python''s
    dictionaries, there''s plenty of them and they are very useful:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到遍历集合时，我们会看到这些视图是如何成为基本工具的。现在让我们看看Python字典暴露的其它一些方法，它们很多并且非常有用：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'All these methods are quite simple to understand, but it''s worth talking about
    that `None`, for a moment. Every function in Python returns `None`, unless the
    `return` statement is explicitly used, but we''ll see this when we explore functions.
    `None` is frequently used to represent the absence of a value, as when default
    arguments are not passed to a function. Some inexperienced coders sometimes write
    code that returns either `False` or `None`. Both `False` and `None` evaluate to
    `False` so it may seem there is not much difference between them. But actually,
    I would argue there is quite an important difference: `False` means that we have
    information, and the information we have is `False`. `None` means *no information*.
    And no information is very different from an information, which is `False`. In
    layman''s terms, if you ask your mechanic "is my car ready?" there is a big difference
    between the answer "No, it''s not" (*False*) and "I have no idea" (*None*).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都相当简单易懂，但值得讨论一下`None`，稍作停留。Python中的每个函数都会返回`None`，除非显式地使用了`return`语句，但我们会探索函数时再讨论这个问题。`None`经常用来表示没有值，例如当没有将默认参数传递给函数时。一些经验不足的程序员有时会编写返回`False`或`None`的代码。`False`和`None`都评估为`False`，所以它们之间可能看起来没有太大区别。但实际上，我会说它们之间有一个相当重要的区别：`False`意味着我们有信息，而我们拥有的信息是`False`。`None`意味着没有信息。没有信息与信息`False`是非常不同的。用通俗易懂的话说，如果你问你的机械师“我的车准备好了吗？”那么回答“没有，还没有”(*False*)和“我不知道”(*None*)之间有很大的区别。
- en: 'One last method I really like of dictionaries is `setdefault`. It behaves like
    `get`, but also sets the key with the given value if it is not there. Let''s see
    and example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢字典的一个方法是`setdefault`。它的行为类似于`get`，但如果键不存在，它也会设置具有给定值的键。让我们看一个例子：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, we're now at the end of this tour. Test your knowledge about dictionaries
    trying to foresee how `d` looks like after this line.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经结束了这次游览。测试你对字典的了解，尝试预测在这行代码之后`d`看起来会是什么样子。
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It's not that complicated, but don't worry if you don't get it immediately.
    I just wanted to spur you to experiment with dictionaries.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不复杂，但如果你一开始不理解也不要担心。我只是想激励你尝试使用字典。
- en: This concludes our tour of built-in data types. Before I make some considerations
    about what we've seen in this chapter, I want to briefly take a peek at the `collections`
    module.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对内置数据类型的游览。在我对这一章中我们所看到的内容进行一些思考之前，我想简要地看一下`collections`模块。
- en: The collections module
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`collections`模块'
- en: 'When Python general purpose built-in containers (`tuple`, `list`, `set`, and
    `dict`) aren''t enough, we can find specialized container data types in the `collections`
    module. They are:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python的通用内置容器（`tuple`、`list`、`set`和`dict`）不足以满足需求时，我们可以在`collections`模块中找到专门的容器数据类型。它们是：
- en: '| Data type | Description |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `namedtuple()` | A factory function for creating tuple subclasses with named
    fields |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `namedtuple()` | 创建具有命名字段的元组子类的工厂函数 |'
- en: '| `deque` | A `list`-like container with fast appends and pops on either end
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `deque` | 一个类似于`list`的容器，两端快速追加和弹出 |'
- en: '| `ChainMap` | A `dict`-like class for creating a single view of multiple mappings
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `ChainMap` | 创建多个映射的单个视图的`dict`类似类 |'
- en: '| `Counter` | A `dict` subclass for counting hashable objects |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `Counter` | 一个用于计数可哈希对象的`dict`子类 |'
- en: '| `OrderedDict` | A `dict` subclass that remembers the order entries were added
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `OrderedDict` | 一个记住添加条目顺序的`dict`子类 |'
- en: '| `defaultdict` | A `dict` subclass that calls a factory function to supply
    missing values |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `defaultdict` | 一个调用工厂函数以提供缺失值的`dict`子类 |'
- en: '| `UserDict` | A wrapper around dictionary objects for easier dict subclassing
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `UserDict` | 一个围绕字典对象的包装器，以便更容易地子类化字典 |'
- en: '| `UserList` | A wrapper around list objects for easier list subclassing |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `UserList` | 一个围绕列表对象的包装器，以便更容易地子类化列表 |'
- en: '| `UserString` | A wrapper around string objects for easier string subclassing
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `UserString` | 一个围绕字符串对象的包装器，以便更容易地子类化字符串 |'
- en: We don't have the room to cover all of them, but you can find plenty of examples
    in the official documentation, so here I'll just give a small example to show
    you `namedtuple`, `defaultdict`, and `ChainMap`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有足够的空间涵盖所有这些，但你可以在官方文档中找到大量的示例，所以在这里，我将只给出一个小例子来展示`namedtuple`、`defaultdict`和`ChainMap`。
- en: Named tuples
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名元组
- en: 'A `namedtuple` is a `tuple`-like object that has fields accessible by attribute
    lookup as well as being indexable and iterable (it''s actually a subclass of `tuple`).
    This is sort of a compromise between a full-fledged object and a tuple, and it
    can be useful in those cases where you don''t need the full power of a custom
    object, but you want your code to be more readable by avoiding weird indexing.
    Another use case is when there is a chance that items in the tuple need to change
    their position after refactoring, forcing the coder to refactor also all the logic
    involved, which can be very tricky. As usual, an example is better than a thousand
    words (or was it a picture?). Say we are handling data about the left and right
    eye of a patient. We save one value for the left eye (position 0) and one for
    the right eye (position 1) in a regular tuple. Here''s how that might be:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple`是一个类似`tuple`的对象，它可以通过属性查找访问字段，同时又是可索引和可迭代的（实际上它是`tuple`的子类）。这有点像是完整对象和元组之间的折中，在那些你不需要自定义对象的全功能，但希望你的代码通过避免奇怪的索引而更易读的情况下很有用。另一个用例是，在元组中的项在重构后需要改变它们的位置的情况下，这迫使编码者也要重构所有相关的逻辑，这可能非常棘手。像往常一样，一个例子胜过千言万语（或者是一个图片？）。比如说我们正在处理有关患者左右眼的数据。我们在一个常规元组中为左眼（位置0）保存一个值，为右眼（位置1）保存一个值。以下是可能的情况：'
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s pretend we handle `vision` object all the time, and at some point
    the designer decides to enhance them by adding information for the combined vision,
    so that a `vision` object stores data in this format: *(left eye, combined, right
    eye)*.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们假设我们一直在处理`vision`对象，在某个时候，设计者决定通过添加关于综合视觉的信息来增强它们，因此`vision`对象以以下格式存储数据：（左眼，综合，右眼）。
- en: 'Do you see the trouble we''re in now? We may have a lot of code that depends
    on `vision[0]` being the left eye information (which still is) and `vision[1]`
    being the right eye information (which is no longer the case). We have to refactor
    our code wherever we handle these objects, changing `vision[1]` to `vision[2]`,
    and it can be painful. We could have probably approached this a bit better from
    the beginning, by using a `namedtuple`. Let me show you what I mean:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在看到我们遇到的麻烦了吗？我们可能有很多代码依赖于`vision[0]`是左眼信息（目前仍然是）和`vision[1]`是右眼信息（这已经不再是事实）。我们必须在处理这些对象的任何地方重构我们的代码，将`vision[1]`改为`vision[2]`，这可能会很痛苦。我们可能从一开始就能更好地处理这个问题，通过使用`namedtuple`。让我给你展示一下我的意思：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If within our code we refer to left and right eye using `vision.left` and `vision.right`,
    all we need to do to fix the new design issue is to change our factory and the
    way we create instances. The rest of the code won't need to change.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的代码中我们使用 `vision.left` 和 `vision.right` 来引用左右眼，要修复新的设计问题，我们只需更改我们的工厂和创建实例的方式。其余的代码不需要更改。
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can see how convenient it is to refer to those values by name rather than
    by position. After all, a wise man once wrote "*Explicit is better than implicit*"
    (can you recall where? Think *zen* if you don't...). This example may be a little
    extreme, of course it's not likely that our code designer will go for a change
    like this, but you'd be amazed to see how frequently issues similar to this one
    happen in a professional environment, and how painful it is to refactor them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到通过名称而不是位置来引用这些值是多么方便。毕竟，一位智者曾经说过 "*明确优于隐晦*"（你能想起在哪里吗？如果你不记得，想想 *禅*）。当然，这个例子可能有点极端，当然我们的代码设计者不太可能选择这样的改变，但您会惊讶地看到在专业环境中类似这种情况发生的频率，以及重构它们的痛苦。
- en: Defaultdict
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Defaultdict
- en: 'The `defaultdict` data type is one of my favorites. It allows you to avoid
    checking if a key is in a dictionary by simply inserting it for you on your first
    access attempt, with a default value whose type you pass on creation. In some
    cases, this tool can be very handy and shorten your code a little. Let''s see
    a quick example: say we are updating the value of `age`, by adding one year. If
    `age` is not there, we assume it was `0` and we update it to `1`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict` 数据类型是我最喜欢的之一。它允许您通过在第一次访问尝试时简单地为您插入键来避免检查键是否在字典中，并传递在创建时指定的默认值类型。在某些情况下，这个工具可以非常方便，并稍微缩短您的代码。让我们看看一个快速示例：假设我们正在更新
    `age` 的值，通过增加一年。如果 `age` 不存在，我们假设它是 `0`，并将其更新为 `1`。'
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now let's see how it would work with a `defaultdict` data type. The second line
    is actually the short version of a 4-lines long `if` clause that we would have
    to write if dictionaries didn't have the `get` method. We'll see all about `if`
    clauses in [Chapter 3](ch03.html "Chapter 3. Iterating and Making Decisions"),
    *Iterating and Making Decisions*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看它如何与 `defaultdict` 数据类型一起工作。第二行实际上是4行长的 `if` 子句的简写版本，如果我们没有 `get` 方法，我们就必须编写这个
    `if` 子句。我们将在 [第3章](ch03.html "第3章。迭代和决策") 中看到所有关于 `if` 子句的内容，*迭代和决策*。
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice how we just need to instruct the `defaultdict` factory that we want an
    `int` number to be used in case the key is missing (we'll get `0`, which is the
    default for the `int` type). Also, notice that even though in this example there
    is no gain on the number of lines, there is definitely a gain in readability,
    which is very important. You can also use a different technique to instantiate
    a `defaultdict` data type, which involves creating a factory object. For digging
    deeper, please refer to the official documentation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们只需指示 `defaultdict` 工厂，当键缺失时我们希望使用一个 `int` 类型的数字（我们将得到 `0`，这是 `int` 类型的默认值）。此外，请注意，尽管在这个例子中行数没有增加，但可读性的提升是非常明显的，这非常重要。您还可以使用不同的技术来实例化
    `defaultdict` 数据类型，这涉及到创建一个工厂对象。要深入了解，请参阅官方文档。
- en: ChainMap
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ChainMap
- en: 'The `ChainMap` is an extremely nice data type which was introduced in Python
    3.3\. It behaves like a normal dictionary but according to the Python documentation:
    *is provided for quickly linking a number of mappings so they can be treated as
    a single unit.* This is usually much faster than creating one dictionary and running
    multiple update calls on it. `ChainMap` can be used to simulate nested scopes
    and is useful in templating. The underlying mappings are stored in a list. That
    list is public and can be accessed or updated using the maps attribute. Lookups
    search the underlying mappings successively until a key is found. In contrast,
    writes, updates, and deletions only operate on the first mapping.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMap` 是一个在 Python 3.3 中引入的非常棒的数据类型。它表现得像一个普通的字典，但根据 Python 文档的说明：*提供了一种快速链接多个映射的方法，以便它们可以作为一个单一单元来处理。*
    这通常比创建一个字典并在其上运行多个更新调用要快得多。`ChainMap` 可以用来模拟嵌套作用域，在模板中非常有用。底层映射存储在一个列表中。该列表是公开的，可以通过
    maps 属性来访问或更新。查找会依次搜索底层映射，直到找到一个键。相比之下，写入、更新和删除操作只作用于第一个映射。'
- en: 'A very common use case is providing defaults, so let''s see an example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的用例是提供默认值，所以让我们看看一个例子：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: I just love how Python makes your life easy. You work on a `ChainMap` object,
    configure the first mapping as you want, and when you need a complete dictionary
    with all the defaults as well as the customized items, you just feed the `ChainMap`
    object to a `dict` constructor. If you have never coded in other languages, such
    as Java or C++, you probably won't be able to fully appreciate how precious this
    is, how Python makes your life so much easier. I do, I feel claustrophobic every
    time I have to code in some other language.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢Python使你的生活变得如此简单。你在一个`ChainMap`对象上工作，按照你的意愿配置第一个映射，当你需要一个包含所有默认值以及自定义项的完整字典时，你只需将`ChainMap`对象传递给`dict`构造函数。如果你从未在其他语言中编码过，比如Java或C++，你可能无法完全欣赏这一点，Python是如何使你的生活变得如此轻松的。我确实如此，每次我不得不在其他语言中编码时，我都会感到压抑。
- en: Final considerations
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的考虑
- en: That's it. Now you have seen a very good portion of the data structures that
    you will use in Python. I encourage you to take a dive into the Python documentation
    and experiment further with each and every data type we've seen in this chapter.
    It's worth it, believe me. Everything you'll write will be about handling data,
    so make sure your knowledge about it is rock solid.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在你已经看到了你将在Python中使用的大部分数据结构。我鼓励你深入研究Python文档，并进一步实验本章中我们看到的每一个数据类型。相信我，这是值得的。你将写下的每一行代码都将关于处理数据，所以确保你对它的了解是牢固的。
- en: Before we leap into the next chapter, I'd like to make some final considerations
    about different aspects that to my mind are important and not to be neglected.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳到下一章之前，我想就一些我认为重要且不应被忽视的不同方面做一些最后的考虑。
- en: Small values caching
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小值缓存
- en: 'When we discussed objects at the beginning of this chapter, we saw that when
    we assigned a name to an object, Python creates the object, sets its value, and
    then points the name to it. We can assign different names to the same value and
    we expect different objects to be created, like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章开头讨论对象时，我们看到了当我们给一个对象命名时，Python会创建该对象，设置其值，然后将名称指向它。我们可以给相同的值分配不同的名称，并期望创建不同的对象，如下所示：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding example, `a` and `b` are assigned to two `int` objects, which
    have the same value but they are not the same object, as you can see, their `id`
    is not the same. So let''s do it again:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`a`和`b`被分配给两个`int`对象，它们具有相同的值，但它们不是同一个对象，正如你所看到的，它们的`id`不相同。所以让我们再试一次：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Oh oh! Is Python broken? Why are the two objects the same now? We didn't do
    `a = b = 5`, we set them up separately. Well, the answer is performances. Python
    caches short strings and small numbers, to avoid having many copies of them clogging
    up the system memory. Everything is handled properly under the hood so you don't
    need to worry a bit, but make sure that you remember this behavior should your
    code ever need to fiddle with IDs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 哦哦！Python出问题了？为什么这两个对象现在相同了？我们并没有做`a = b = 5`，我们是分别设置的。嗯，答案是性能。Python缓存短字符串和小数字，以避免在系统内存中产生许多副本。所有的事情都在幕后得到妥善处理，所以你不需要担心，但如果你需要在代码中处理ID，请确保你记得这种行为。
- en: How to choose data structures
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何选择数据结构
- en: 'As we''ve seen, Python provides you with several built-in data types and sometimes,
    if you''re not that experienced, choosing the one that serves you best can be
    tricky, especially when it comes to collections. For example, say you have many
    dictionaries to store, each of which represents a customer. Within each customer
    dictionary there''s an `''id'': ''code''` unique identification code. In what
    kind of collection would you place them? Well, unless I know more about these
    customers, it''s very hard to answer. What kind of access will I need? What sort
    of operations will I have to perform on each of them, and how many times? Will
    the collection change over time? Will I need to modify the customer dictionaries
    in any way? What is going to be the most frequent operation I will have to perform
    on the collection?'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们所看到的，Python为你提供了几个内置的数据类型，有时，如果你不是那么有经验，选择最适合你的类型可能会很棘手，尤其是在集合方面。例如，假设你有很多字典要存储，每个字典代表一个客户。在客户字典中有一个唯一的标识码`''id'':
    ''code''`。你会在哪种集合中放置它们？好吧，除非我了解更多关于这些客户的信息，否则很难回答。我需要什么样的访问？我将对每个客户执行什么样的操作，以及需要执行多少次？集合会随时间变化吗？我需要以某种方式修改客户字典吗？我将要在集合上执行的最频繁的操作是什么？'
- en: 'If you can answer the preceding questions, then you will know what to choose.
    If the collection never shrinks or grows (in other words, it won''t need to add/delete
    any customer object after creation) or shuffles, then tuples are a possible choice.
    Otherwise lists are a good candidate. Every customer dictionary has a unique identifier
    though, so even a dictionary could work. Let me draft these options for you:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够回答前面的问题，那么你就会知道该选择什么。如果集合永远不会缩小或增长（换句话说，在创建后不需要添加/删除任何客户对象或打乱顺序），那么元组是一个可能的选择。否则，列表是一个不错的选择。不过，每个客户字典都有一个唯一的标识符，所以即使字典也可以工作。让我为你草拟这些选项：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Some customers we have there, right? I probably wouldn't go with the tuple option,
    unless I wanted to highlight that the collection is not going to change. I'd say
    usually a list is better, it allows for more flexibility.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们那里有一些客户，对吧？我可能不会选择元组选项，除非我想强调集合不会改变。我会说通常列表更好，它提供了更多的灵活性。
- en: Another factor to keep in mind is that tuples and lists are ordered collections,
    while if you use a dictionary or a set you lose the ordering, so you need to know
    if ordering is important in your application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是，元组和列表是有序集合，而如果你使用字典或集合，你会失去排序，因此你需要知道排序在你的应用中是否重要。
- en: What about performances? For example in a list, operations such as insertion
    and membership can take *O(n)*, while they are *O(1)* for a dictionary. It's not
    always possible to use dictionaries though, if we don't have the guarantee that
    we can uniquely identify each item of the collection by means of one of its properties,
    and that the property in question is hashable (so it can be a key in `dict`).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 关于性能如何？例如，在一个列表中，插入和成员资格等操作可能需要 *O(n)* 时间，而对于字典来说，这些操作只需要 *O(1)*。然而，如果我们不能保证可以通过集合的一个属性唯一地识别每个项目，并且该属性是可哈希的（因此它可以作为
    `dict` 的键），那么使用字典并不总是可能的。
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're wondering what *O(n)* and *O(1)* mean, please Google "*big O notation*"
    and get a gist of it from anywhere. In this context, let's just say that if performing
    an operation *Op* on a data structure takes *O(f(n))*, it would mean that *Op*
    takes at most a time ![How to choose data structures](img/4715_02_03.jpg) to complete,
    where *c* is some positive constant, *n* is the size of the input, and *f* is
    some function. So, think of *O(...)* as an upper bound for the running time of
    an operation (it can be used also to size other measurable quantities, of course).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道 *O(n)* 和 *O(1)* 是什么意思，请谷歌搜索“*大O符号*”并从任何地方了解其概要。在这个上下文中，我们只需说，如果对一个数据结构执行操作
    *Op* 需要 *O(f(n))* 时间，这意味着 *Op* 完成所需的时间最多为 ![如何选择数据结构](img/4715_02_03.jpg)，其中 *c*
    是某个正常数，*n* 是输入的大小，*f* 是某个函数。所以，将 *O(...)* 视为操作运行时间的上界（当然，它也可以用来衡量其他可测量的数量）。
- en: Another way of understanding if you have chosen the right data structure is
    by looking at the code you have to write in order to manipulate it. If everything
    comes easily and flows naturally, then you probably have chosen correctly, but
    if you find yourself thinking your code is getting unnecessarily complicated,
    then you probably should try and decide whether you need to reconsider your choices.
    It's quite hard to give advice without a practical case though, so when you choose
    a data structure for your data, try to keep ease of use and performance in mind
    and give precedence to what matters most in the context you are.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 判断你是否选择了正确的数据结构的一种方法是通过查看你为了操作它而必须编写的代码。如果一切都很顺利且自然流畅，那么你可能选择了正确的选项，但如果你发现自己觉得代码变得过于复杂，那么你可能应该尝试决定是否需要重新考虑你的选择。不过，没有实际案例很难给出建议，所以当你为你的数据选择数据结构时，请记住考虑易用性和性能，并优先考虑你所在环境中最重要的因素。
- en: About indexing and slicing
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于索引和切片
- en: At the beginning of this chapter, we saw slicing applied on strings. Slicing
    in general applies to a sequence, so tuples, lists, strings, etc. With lists,
    slicing can also be used for assignment. I've almost never seen this used in professional
    code, but still, you know you can. Could you slice dictionaries or sets? I hear
    you scream "*Of course not! They are not ordered!*". Excellent, I see we're on
    the same page here, so let's talk about indexing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到了字符串上的切片操作。一般来说，切片适用于序列，例如元组、列表、字符串等。对于列表，切片也可以用于赋值。我几乎从未在专业代码中看到过这种用法，但仍然，你知道你可以这样做。你能对字典或集合进行切片吗？我听到你在尖叫“*当然不能！它们是无序的!*”。太好了，我看到我们在这里意见一致，那么让我们来谈谈索引。
- en: 'There is one characteristic about Python indexing I haven''t mentioned before.
    I''ll show you by example. How do you address the last element of a collection?
    Let''s see:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 索引的一个特点，我之前还没有提到。我将通过例子来展示。如何定位集合的最后一个元素？让我们看看：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the list `a` has 10 elements, because of the *0-index* positioning system
    of Python, the first one is at position 0 and the last one is at position 9\.
    In the preceding example, the elements are conveniently placed in a position equal
    to their value: 0 is at position 0, 1 at position 1, and so on.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表 `a` 有 10 个元素，由于 Python 的 *0 索引* 系统定位，第一个元素位于位置 0，最后一个元素位于位置 9。在上一个例子中，元素被方便地放置在其值相等的位置：0
    位于位置 0，1 位于位置 1，以此类推。
- en: 'So, in order to fetch the last element, we need to know the length of the whole
    list (or tuple, or string, and so on) and then subtract 1\. Hence: `len(a) – 1`.
    This is so common an operation that Python provides you with a way to retrieve
    elements using **negative** **indexing**. This proves very useful when you do
    some serious data manipulation. Here''s a nice diagram about how indexing works
    on the string `"HelloThere"`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获取最后一个元素，我们需要知道整个列表（或元组、字符串等）的长度，然后减去 1。因此：`len(a) – 1`。这是一个非常常见的操作，Python
    提供了一种使用 **负** **索引** 来检索元素的方法。这在进行一些严肃的数据操作时非常有用。以下是一个关于字符串 `"HelloThere"` 上索引如何工作的好图解：
- en: '![About indexing and slicing](img/4715_02_02.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![关于索引和切片](img/4715_02_02.jpg)'
- en: Trying to address indexes greater than 9 or smaller than -10 will raise an `IndexError`,
    as expected.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问大于 9 或小于 -10 的索引将引发一个 `IndexError`，正如预期的那样。
- en: About the names
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于命名
- en: You may have noticed that, in order to keep the example as short as possible,
    I have called many objects using simple letters, like `a`, `b`, `c`, `d`, and
    so on. This is perfectly ok when you debug on the console or when you show that
    `a + b == 7`, but it's bad practice when it comes to professional coding (or any
    type of coding, for all that matter). I hope you will indulge me if I sometimes
    do it, the reason is to present the code in a more compact way.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，为了尽可能缩短示例，我使用了简单的字母来调用许多对象，如 `a`、`b`、`c`、`d` 等。当你需要在控制台调试或展示 `a + b
    == 7` 时，这是完全可以接受的，但在专业编码（或任何类型的编码，无论如何）中，这是一种不好的做法。我希望你能够容忍我有时这样做，原因是为了以更紧凑的方式展示代码。
- en: In a real environment though, when you choose names for your data, you should
    choose them carefully and they should reflect what the data is about. So, if you
    have a collection of `Customer` objects, `customers` is a perfectly good name
    for it. Would `customers_list`, `customers_tuple`, or `customers_collection` work
    as well? Think about it for a second. Is it good to tie the name of the collection
    to the data type? I don't think so, at least in most cases. So I'd say if you
    have an excellent reason to do so go ahead, otherwise don't. The reason is, once
    that `customers_tuple` starts being used in different places of your code, and
    you realize you actually want to use a list instead of a tuple, you're up for
    some fun refactoring (also known as **wasted time**). Names for data should be
    nouns, and names for functions should be verbs. Names should be as expressive
    as possible. Python is actually a very good example when it comes to names. Most
    of the time you can just guess what a function is called if you know what it does.
    Crazy, huh?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际环境中，当你为你的数据选择名称时，你应该仔细选择，并且它们应该反映数据的内容。所以，如果你有一组 `Customer` 对象，`customers`
    是它的一个非常好的名称。`customers_list`、`customers_tuple` 或 `customers_collection` 也能行得通吗？思考一下。将集合的名称与数据类型绑定是否好？我不这么认为，至少在大多数情况下不是。所以我会说，如果你有很好的理由这么做，那就去做吧，否则不要。原因是，一旦
    `customers_tuple` 开始在你的代码的不同地方使用，你意识到你实际上想使用列表而不是元组，你将面临一些有趣的重构（也称为 **浪费时间**）。数据名称应该是名词，函数名称应该是动词。名称应该尽可能表达清晰。Python
    在名称方面实际上是一个非常好的例子。大多数时候，如果你知道一个函数的作用，你就可以猜出它的名称。疯狂，对吧？
- en: '[Chapter 2](ch02.html "Chapter 2. Built-in Data Types"), *Meaningful Names*
    of *Clean Code*, *Robert C. Martin*, *Prentice Hall* is entirely dedicated to
    names. It''s an amazing book that helped me improve my coding style in many different
    ways, a must read if you want to take your coding to the next level.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章。内置数据类型")，*《代码整洁之道》*，*罗伯特·C·马丁*，*普伦蒂斯·霍尔*，完全致力于命名。这是一本令人惊叹的书，它帮助我在许多不同的方面改进了我的编码风格，如果你想要将你的编码提升到下一个层次，这是一本必读的书。'
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've explored the built-in data types of Python. We've seen
    how many they are and how much can be achieved by just using them in different
    combinations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Python的内置数据类型。我们看到了它们的数量，以及仅通过不同组合使用它们所能实现的事情。
- en: We've seen number types, sequences, sets, mappings, collections, we've seen
    that everything is an object, we've learned the difference between mutable and
    immutable, and we've also learned about slicing and indexing (and, proudly, negative
    indexing as well).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了数字类型、序列、集合、映射、集合，我们了解到一切皆对象，我们学习了可变和不可变之间的区别，我们还学习了切片和索引（以及，自豪地说，负索引）。
- en: We've presented simple examples, but there's much more that you can learn about
    this subject, so stick your nose into the official documentation and explore.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了简单的例子，但关于这个主题，你还可以学到更多，所以请深入官方文档去探索。
- en: Most of all, I encourage you to try out all the exercises by yourself, get your
    fingers using that code, build some muscle memory, and experiment, experiment,
    experiment. Learn what happens when you divide by zero, when you combine different
    number types into a single expression, when you manage strings. Play with all
    data types. Exercise them, break them, discover all their methods, enjoy them
    and learn them well, damn well.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我鼓励你自己尝试所有练习，让你的手指使用这些代码，建立一些肌肉记忆，并实验，实验，再实验。学习当你除以零时会发生什么，当你将不同的数字类型组合成一个单一表达式时会发生什么，当你处理字符串时会发生什么。玩转所有数据类型。练习它们，破坏它们，发现它们的所有方法，享受它们并学好它们，真的学好。
- en: If your foundation is not rock solid, how good can your code be? And data is
    the foundation for everything. Data shapes what dances around it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的基础不是坚如磐石，你的代码能有多好？数据是一切的基础。数据塑造了围绕它的东西。
- en: The more you progress with the book, the more it's likely that you will find
    some discrepancies or maybe a small typo here and there in my code (or yours).
    You will get an error message, something will break. That's wonderful! When you
    code, things break all the time, you debug and fix all the time, so consider errors
    as useful exercises to learn something new about the language you're using, and
    not as failures or problems. Errors will keep coming up until your very last line
    of code, that's for sure, so you may as well start making your peace with them
    now.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对这本书的进步，你很可能会发现我的代码（或你的）中存在一些差异，或者这里那里可能有一些小错误。你会收到一个错误信息，某些东西会出错。那太好了！当你编码时，事情总是出错，你总是调试和修复，所以请把错误视为学习关于你所使用语言的新知识的有用练习，而不是失败或问题。错误会一直出现，直到你代码的最后一行，这是肯定的，所以你现在就开始与它们和解吧。
- en: The next chapter is about iterating and making decisions. We'll see how to actually
    put those collections in use, and take decisions based on the data we're presented
    with. We'll start to go a little faster now that your knowledge is building up,
    so make sure you're comfortable with the contents of this chapter before you move
    to the next one. Once more, have fun, explore, break things. It's a very good
    way to learn.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是关于迭代和做决策的。我们将看到如何实际使用这些集合，并基于我们呈现的数据做出决策。现在你的知识正在积累，我们将开始稍微快一点，所以确保你在转到下一章之前对这一章的内容感到舒适。再次提醒，要开心，探索，破坏事物。这是一种非常好的学习方法。
