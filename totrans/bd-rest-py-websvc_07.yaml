- en: Chapter 7.  Improving and Adding Authentication to an API with Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will improve the RESTful API that we started in the previous
    chapter and we will add authentication related security to it. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Improve unique constraints in the models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update fields for a resource with the `PATCH` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code a generic pagination class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add pagination features to the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the steps to add authentication and permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a user model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a schema to validate, serialize and deserialize users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add authentication to resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create resource classes to handle users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run migrations to generate the user table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compose requests with the necessary authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving unique constraints in the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we created the `Category` model, we specified the `True` value for the
    unique argument when we created the `db.Column` instance named `name`. As a result,
    the migrations generated the necessary unique constraint to make sure that the
    `name` field has unique values in the `category` table. This way, the database
    won't allow us to insert duplicate values for `category.name`. However, the error
    message generated when we try to do so is not clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a category with a duplicate name. There
    is already an existing category with the name equal to `''Information''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send a `POST` HTTP request with the specified
    JSON key-value pair. The unique constraint in the `category.name` field won''t
    allow the database table to persist the new category. Thus, the request will return
    an HTTP `400 Bad Request` status code with an integrity error message. The following
    lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the error message is extremely technical and provides too many details
    about the database and the query that failed. We might parse the error message
    to automatically generate a more user friendly error message. However, instead
    of doing so, we want to avoid trying to insert a row that we know will fail. We
    will add code to make sure that a category is unique before we try to persist
    it. Of course, there is still a chance to receive the previously shown error if
    somebody inserts a category with the same name between the time we run our code,
    indicating that a category name is unique, and persist the changes in the database.
    However, the chances are lower and we can reduce the changes of the previously
    shown error message to be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a production-ready REST API we should never return the error messages returned
    by SQLAlchemy or any other database-related data, as it might include sensitive
    data that we don't want the users of our API to be able to retrieve. In this case,
    we are returning all the errors for debugging purposes and to be able to improve
    our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add a new class method to the `Category` class to allow us to
    determine whether a name is unique or not. Open the `api/models.py` file and add
    the following lines within the declaration of the `Category` class. The code file
    for the sample is included in the `restful_python_chapter_07_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The new `Category.is_unique` class method receives the `id` and the `name` for
    the category that we want to make sure that has a unique name. If the category
    is a new one that hasn't been saved yet, we will receive a 0 for the `id` value.
    Otherwise, we will receive the category id in the argument.
  prefs: []
  type: TYPE_NORMAL
- en: The method calls the `query.filter_by` method for the current class to retrieve
    a category whose name matches the other category name. In case there is a category
    that matches the criteria, the method will return `True` only if the id is the
    same one than the one received in the argument. In case no category matches the
    criteria, the method will return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the previously created class method to check whether a category
    is unique or not before creating and persisting it in the `CategoryListResource.post`
    method. Open the `api/views.py` file and replace the existing `post` method declared
    in the `CategoryListResource` class with the following lines. The lines that have
    been added or modified are highlighted. The code file for the sample is included
    in the `restful_python_chapter_07_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will perform the same validation in the `CategoryResource.patch` method.
    Open the `api/views.py` file and replace the existing `patch` method declared
    in the `CategoryResource` class with the following lines. The lines that have
    been added or modified are highlighted. The code file for the sample is included
    in the `restful_python_chapter_07_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to again create a category with a duplicate name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send a `POST` HTTP request with the specified
    JSON key-value pair. The changes we made will generate a response with a user
    friendly error message and will avoid trying to persist the changes. The request
    will return an HTTP `400 Bad Request` status code with the error message in the
    JSON body. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will add a new `class` method to the `Message` class to allow us to
    determine whether a message is unique or not. Open the `api/models.py` file and
    add the following lines within the declaration of the `Message` class. The code
    file for the sample is included in the `restful_python_chapter_07_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The new `Message.is_unique` class method receives the `id` and the `message`
    for the message that we want to make sure that has a unique value for the message
    field. If the message is a new one that hasn't been saved yet, we will receive
    a `0` for the `id` value. Otherwise, we will receive the message id in the argument.
  prefs: []
  type: TYPE_NORMAL
- en: The method calls the `query.filter_by` method for the current class to retrieve
    a message whose message field matches the other message's message. In case there
    is a message that matches the criteria, the method will return `True` only if
    the id is the same one than the one received in the argument. In case no message
    matches the criteria, the method will return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the previously created class method to check whether a message
    is unique or not before creating and persisting it in the `MessageListResource.post`
    method. Open the `api/views.py` file and replace the existing `post` method declared
    in the `MessageListResource` class with the following lines. The lines that have
    been added or modified are highlighted. The code file for the sample is included
    in the `restful_python_chapter_07_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will perform the same validation in the `MessageResource.patch` method.
    Open the `api/views.py` file and replace the existing `patch` method declared
    in the `MessageResource` class with the following lines. The lines that have been
    added or modified are highlighted. The code file for the sample is included in
    the `restful_python_chapter_07_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create a message with a duplicate value for the
    message field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send a `POST` HTTP request with the specified
    JSON key-value pair. The changes we made will generate a response with a user
    friendly error message and will avoid trying to persist the changes in the message.
    The request will return an HTTP `400 Bad Request` status code with the error message
    in the JSON body. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Updating fields for a resource with the PATCH method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained in [Chapter 6](ch06.html "Chapter 6.  Working with Models, SQLAlchemy,
    and Hyperlinked APIs in Flask") *, Working with Models, SQLAlchemy, and Hyperlinked
    APIs in Flask*, our API is able to update a single field for an existing resource,
    and therefore, we provide an implementation for the `PATCH` method. For example,
    we can use the `PATCH` method to update an existing message and set the value
    for its `printed_once` and `printed_times` fields to `true` and `1`. We don't
    want to use the `PUT` method because this method is meant to replace an entire
    message. The `PATCH` method is meant to apply a delta to an existing message,
    and therefore, it is the appropriate method to just change the value of those
    two fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to update an existing message,
    specifically, to update the value of the `printed_once` and `printed_times` fields.
    Because we just want to update two fields, we will use the `PATCH` method instead
    of `PUT`. Make sure you replace `1` with the id or primary key of an existing
    message in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send a `PATCH` HTTP request with the
    following specified JSON key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The request has a number after `/api/messages/`, and therefore, it will match
    `'/messages/<int:id>'` and run the `MessageResource.patch` method, that is, the
    `patch` method for the `MessageResource` class. If a `Message` instance with the
    specified id exists, the code will retrieve the values for the `printed_times`
    and `printed_once` keys in the request dictionary update the `Message` instance
    and validate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the updated `Message` instance is valid, the code will persist the changes
    in the database and the call to the method will return an HTTP `200 OK` status
    code and the recently updated `Message` instance serialized to JSON in the response
    body. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the commands explained in [Chapter 6](ch06.html "Chapter 6.  Working
    with Models, SQLAlchemy, and Hyperlinked APIs in Flask") *,* *Working with Models,
    SQLAlchemy, and Hyperlinked APIs in Flask*, to check the contents of the tables
    that the migrations created in the PostgreSQL database. We will notice that the
    `printed_times` and `printed_once` values have been updated for the row in the
    message table. The following screenshot shows the contents for the updated row
    of the `message` table in a PostgreSQL database after running the HTTP request.
    The screenshot shows the results of executing the following SQL query: `SELECT
    * FROM message WHERE id = 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating fields for a resource with the PATCH method](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Coding a generic pagination class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our database has a few rows for each of the tables that persist the models we
    have defined. However, after we start working with our API in a real-life production
    environment, we will have hundreds of messages, and therefore, we will have to
    deal with large result sets. Thus, we will create a generic pagination class and
    we will use it to easily specify how we want large results sets to be split into
    individual pages of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will compose and send HTTP requests to create `9` messages that belong
    to one of the categories we have created: `Information`. This way, we will have
    a total of 12 messages persisted in the database. We had 3 messages and we add
    9 more.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent `curl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands will compose and send nine `POST` HTTP requests with the
    specified JSON key-value pairs. The request specifies `/api/messages/`, and therefore,
    it will match `'/messages/'` and run the `MessageListResource.post` method, that
    is, the `post` method for the `MessageListResource` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have 12 messages in our database. However, we don't want to retrieve
    the 12 messages when we compose and send a `GET` HTTP request to `/api/messages/`.
    We will create a customizable generic pagination class to include a maximum of
    5 resources in each individual page of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `api/config.py` file and add the following lines that declare two
    variables that configure the global pagination settings. The code file for the
    sample is included in the `restful_python_chapter_07_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The value for the `PAGINATION_PAGE_SIZE` variable specifies a global setting
    with the default value for the page size, also known as limit. The value for the
    `PAGINATION_PAGE_ARGUMENT_NAME` specifies a global setting with the default value
    for the argument name that we will use in our requests to specify the page number
    we want to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `helpers.py` file within the `api` folder. The following lines
    show the code that creates a new `PaginationHelper` class. The code file for the
    sample is included in the `restful_python_chapter_07_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PaginationHelper` class declares a constructor, that is, the `__init__`
    method that received many arguments and uses them to initialize the attributes
    with the same names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request`: The Flask request object that will allow the `paginate_query` method
    to retrieve the page number value specified with the HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query`: The SQLAlchemy query that the `paginate_query` method has to paginate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource_for_url`: A string with the resource name that the `paginate_query`
    method will use to generate the full URLs for the previous page and the next page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key_name`: A string with the key name that the `paginate_query` method will
    use to return the serialized objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema`: The Flask-Marshmallow `Schema` subclass that the `paginate_query`
    method must use to serialize the objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the constructor reads and saves the values for the configuration
    variables we added to the `config.py` file in the `results_per_page` and `page_argument_name`
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The class declares the `paginate_query` method. First, the code retrieves the
    page number specified in the request and saves it in the `page_number` variable.
    In case no page number is specified, the code assumes that request requires the
    first page. Then, the code calls the `self.query.paginate` method to retrieve
    the page number specified by `page_number` of the paginated result of objects
    from the database, with a number of results per page indicated by the value of
    the `self.results_per_page` attribute. The next line saves the paginated items
    from the `paginated_object.items` attribute in the `objects` variable.
  prefs: []
  type: TYPE_NORMAL
- en: If the value for the `paginated_objects.has_prev` attribute is `True`, it means
    that there is a previous page available. In this case, the code calls the `flask.url_for`
    function to generate the full URL for the previous page with the value of the
    `self.resource_for_url` attribute. The `_external` argument is set to `True` because
    we want to provide the full URL.
  prefs: []
  type: TYPE_NORMAL
- en: If the value for the `paginated_objects.has_next` attribute is `True`, it means
    that there is a next page available. In this case, the code calls the `flask.url_for`
    function to generate the full URL for the next page with the value of the `self.resource_for_url`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code calls the `self.schema.dump` method to serialize the partial
    results previously saved in the `object` variable, with the `many` argument set
    to `True`. The `dumped_objects` variable saves the reference to the `data` attribute
    of the results returned by the call to the `dump` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the method returns a dictionary with the following key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.key_name`: The serialized partial results saved in the `dumped_objects`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''previous''`: The full URL for the previous page saved in the `previous_page_url`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''previous''`: The full URL for the next page saved in the `next_page_url`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''count''`: The total number of objects available in the complete resultset
    retrieved from the `paginated_objects.total` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding pagination features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `api/views.py` file and replace the code for the `MessageListResource.get`
    method with the highlighted lines in the next listing. In addition, make sure
    that you add the import statement. The code file for the sample is included in
    the `restful_python_chapter_07_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The new code for the `get` method creates an instance of the previously explained
    `PaginationHelper` class named `pagination_helper` with the `request` object as
    the first argument. The named arguments specify the `query`, `resource_for_url`,
    `key_name`, and `schema` that the `PaginationHelper` instance has to use to provide
    a paginated query result.
  prefs: []
  type: TYPE_NORMAL
- en: The next line calls the `pagination_helper.paginate_query` method that will
    return the results of the paginated query with the page number specified in the
    request. Finally, the method returns the results of the call to this method that
    include the previously explained dictionary. In this case, the paginated resultset
    with the messages will be rendered as a value of the `'results'` key, specified
    in the `key_name` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will compose and send an HTTP request to retrieve all the messages,
    specifically an HTTP `GET` method to `/api/messages/`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The new code for the `MessageListResource.get` method will work with pagination
    and the result will provide us the first 5 messages (`results` key), the total
    number of messages for the query (`count` key) and a link to the next (`next`
    key) and previous (`previous` key) pages. In this case, the resultset is the first
    page, and therefore, the link to the previous page (previous `key`) is `null`.
    We will receive a `200 OK` status code in the response header and the 5 messages
    in the `results` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous HTTP request, we didn''t specify any value for the `page` parameter,
    and therefore the `paginate_query` method in the `PaginationHelper` class requests
    the first page to the paginated query. If we compose and send the following HTTP
    request to retrieve the first page of all the messages by specifying 1 for the
    `page` value, the API will provide the same results shown before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code in the `PaginationHelper` class considers that first page is page number
    1\. Thus, we don't work with zero-based numbering for pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to retrieve the next page, that
    is, the second page for the messages, specifically an HTTP `GET` method to `/api/messages/`
    with the `page` value set to `2`. Remember that the value for the `next` key returned
    in the JSON body of the previous result provides us with the full URL to the next
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The result will provide us the second set of the five message resource (`results`
    key), the total number of messages for the query (`count` key), a link to the
    next (`next` key), and previous (`previous` key) pages. In this case, the resultset
    is the second page, and therefore, the link to the previous page (previous `key`)
    is `http://localhost:5000/api/messages/?page=1`. We will receive a `200 OK` status
    code in the response header and the 5 messages in the `results` array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will compose and send an HTTP request to retrieve the last page,
    that is, the third page for the messages, specifically an HTTP `GET` method to
    `/api/messages/` with the `page` value set to `3`. Remember that the value for
    the next key returned in the JSON body of the previous result provides us with
    the URL to the next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will provide us the last set with two message resources (`results`
    key), the total number of messages for the query (`count` key), a link to the
    next (`next` key), and previous (`previous` key) pages. In this case, the resultset
    is the last page, and therefore, the link to the next page (`next` key) is `null`.
    We will receive a `200 OK` status code in the response header and the 2 messages
    in the `results` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the steps to add authentication and permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current version of the API processes all the incoming requests without requiring
    any kind of authentication. We will use a Flask extension and other packages to
    use an HTTP authentication scheme to identify the user that originated the request
    or the token that signed the request. Then, we will use these credentials to apply
    the permissions that will determine whether the request must be permitted or not.
    Unluckily, neither Flask nor Flask-RESTful provides an authentication framework
    that we can easily plug and configure. Thus, we will have to write code to perform
    many tasks related to authentication and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to create a new user without any authentication. However,
    all the other API calls are only going to be available for authenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will install a Flask extension to make it easier for us to work with
    HTTP authentication, `Flask-HTTPAuth`, and a package to allow us to hash a password
    and check whether a provided password is valid or not, `passlib`.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new `User` model that will represent a user. The model will
    provide methods to allow us to hash a password and verify whether a password provided
    for a user is valid or not. We will create a `UserSchema` class to specify how
    we want to serialize and deserialize a user.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will configure the Flask extension to work with our `User` model to
    verify passwords and set the authenticated user associated with a request. We
    will make changes to the existing resources to require authentication and we will
    new resources to allow us to retrieve existing users and create a new one. Finally,
    we will configure the routes for the resources related to users.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have completed the previously mentioned tasks, we will run migrations
    to generate the new table that persists the users in the database. Then, we will
    compose and send HTTP requests to understand how the authentication and permissions
    work with our new version of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you quit the Flask development server. Remember that you just need
    to press ***Ctrl*** + ***C*** in the terminal or a Command Prompt window in which
    it is running. It is time to run many commands that will be the same for either
    macOS, Linux, or Windows. We can install all the necessary packages with pip with
    a single command. However, we will run two independent commands to make it easier
    to detect any problems in case a specific installation fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must run the following command to install Flask-HTTPAuth with pip.
    This package makes it easy to add basic HTTP authentication to any Flask application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate the `Flask-HTTPAuth` package has
    been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to install passlib with pip. This package is a popular
    one that provides a comprehensive password hashing framework that supports more
    than 30 schemes. We definitely don''t want to write our own error-prone and probably
    highly insecure password hashing code, and therefore, we will take advantage of
    a library that provides these services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate the `passlib` package has been
    successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Adding a user model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create the model that we will use to represent and persist the
    user. Open the `api/models.py` file and add the following lines after the declaration
    of the `AddUpdateDelete` class. Make sure that you add the import statements.
    The code file for the sample is included in the `restful_python_chapter_07_02`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The code declares the `User` model, specifically a subclasses of both the `db.Model`
    and the `AddUpdateDelete` classes. We specified the field types, maximum lengths
    and defaults for the following three attributes-`id`, `name`, `hashed_password`
    and `creation_date`. These attributes represent fields without any relationship,
    and therefore, they are instances of the `db.Column` class. The model declares
    an `id` attribute and specifies the `True` value for the `primary_key` argument
    to indicate it is the primary key. SQLAlchemy will use the data to generate the
    necessary table in the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `User` class declares the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`check_password_strength_and_hash_if_ok`: This method uses the `re` module
    that provides regular expression matching operations to check whether the `password`
    received as an argument fulfils many qualitative requirements. The code requires
    the password to be longer than eight characters, with a maximum of 32 characters.
    The password must include at least one uppercase letter, one lowercase letter,
    one number, and one symbol. The code checks the results of many calls to the `re.search`
    method to determine whether the received password fulfils each requirement. In
    case any of the requirements isn''t fulfilled, the code returns a tuple with an
    error message and `False`. Otherwise, the code calls the `encrypt` method for
    the `passlib.apps.custom_app_context` instance imported as `password_context`,
    with the received `password` as an argument. The `encrypt` method chooses a reasonably
    strong scheme based on the platform, with the default settings for rounds selection
    and the code saves the hashed password in the `hash_password` attribute. Finally,
    the code returns a tuple with an empty string and `True`, indicating that the
    password fulfilled the qualitative requirements and it was hashed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the `passlib` library will use the SHA-512 scheme for 64-bit platforms
    and SHA-256 for 32-bit platforms. In addition, the minimum number of rounds will
    be set to 535,000\. We will use the default configuration values for this example.
    However, you must take into account that these values might require too much processing
    time for each request that has to validate the password. You should definitely
    select the most appropriate algorithm and number of rounds based on your security
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '`verify_password`: This method calls the `verify` method for the `passlib.apps.custom_app_context`
    instance imported as `password_context`, with the received `password` and the
    stored hashed password for the user, `self.hashed_password`, as the arguments.
    The `verify` method hashes the received password and returns `True` only if the
    hashed received password matches the stored hashed password. We never restore
    the saved password to its original state. We just compare hashed values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model declares a constructor, that is, the `__init__` method. This constructor
    receives the user name in the `name` argument and saves it in an attribute with
    the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a schemas to validate, serialize, and deserialize users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create the Flask-Marshmallow schema that we will use to validate,
    serialize and deserialize the previously declared `User` model. Open the `api/models.py`
    file and add the following code after the existing lines. The code file for the
    sample is included in the `restful_python_chapter_07_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The code declares the `UserSchema` schema, specifically a subclass of the `ma.Schema`
    class. Remember that the previous code we wrote for the `api/models.py` file created
    a `flask_marshmallow.Mashmallow` instance named `ma`.
  prefs: []
  type: TYPE_NORMAL
- en: We declare the attributes that represent fields as instances of the appropriate
    class declared in the `marshmallow.fields` module. The `UserSchema` class declares
    the `name` attribute as an instance of `fields.String`. The `required` argument
    is set to `True` to specify that the field cannot be an empty string. The `validate`
    argument is set to `validate.Length(3)` to specify that the field must have a
    minimum length of 3 characters.
  prefs: []
  type: TYPE_NORMAL
- en: The validation for the password isn't included in the schema. We will use the
    `check_password_strength_and_hash_if_ok` method defined in the `User` class to
    validate the password.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication to resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will configure the `Flask-HTTPAuth` extension to work with our `User` model
    to verify passwords and set the authenticated user associated with a request.
    We will declare a custom function that this extension will use as a callback to
    verify a password. We will create a new base class for our resources that will
    require authentication. Open the `api/views.py` file and add the following code
    after the last line that uses the `import` statement and before the lines that
    declares the `Blueprint` instance . The code file for the sample is included in
    the `restful_python_chapter_07_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First, we create an instance of the `flask_httpauth.HTTPBasicAuth` class named
    `auth`. Then, we declare the `verify_user_password` function that receives a name
    and a password as arguments. The function uses the `@auth.verify_password` decorator
    to make this function become the callback that `Flask-HTTPAuth` will use to verify
    the password for a specific user. The function retrieves the user whose name matches
    the `name` specified in the argument and saves its reference in the `user` variable.
    If a user is found, the code checks the results of the `user.verify_password`
    method with the received password as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: If either a user isn't found or the call to `user.verify_password` returns `False`,
    the function returns `False` and the authentication will fail. If the call to
    `user.verify_password` returns `True`, the function stores the authenticated `User`
    instance in the user attribute for the `flask.g` object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `flask.g` object is a proxy that allows us to store on this whatever we
    want to share for one request only. The `user` attribute we added to the `flask.g`
    object will be only valid for the active request and it will return different
    values for each different request. This way, it is possible to use `flask.g.user`
    in another function or method called during a request to access details about
    the authenticated user for the request.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we declared the `AuthRequiredResource` class as a subclass of `flask_restful.Resource`.
    We just specified `auth.login_required` as one of the members of the list that
    we assign to the `method_decorators` property inherited from the base class. This
    way, all the methods declared in a resource that uses the new `AuthRequiredResource`
    class as its superclass will have the `auth.login_required` decorator applied
    to them, and therefore, any method that is called to the resource will require
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will replace the base class for the existing resource classes to make
    them inherit from `AuthRequiredResource` instead of `Resource`. We want any of
    the requests that retrieve or modify categories and messages to be authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the declarations for the four resource classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `api/views.py` file and replace `Resource` by `AuthRequiredResource`
    in the previously shown four lines that declare the resource classes. The following
    lines show the new code for each resource class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Creating resource classes to handle users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just want to be able to create users and use them to authenticate requests.
    Thus, we will just focus on creating resource classes with just a few methods.
    We won't create a complete user management system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the resource classes that represent the user and the collection
    of users. First, we will create a `UserResource` class that we will use to represent
    a user resource. Open the `api/views.py` file and add the following lines after
    the line that creates the `Api` instance. The code file for the sample is included
    in the `restful_python_chapter_07_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `UserResource` class is a subclass of the previously coded `AuthRequiredResource`
    and declares a `get` methods that will be called when the `HTTP` method with the
    same name arrives as a request on the represented resource. The method receives
    the id of the user that has to be retrieved in the `id` argument. The code calls
    the `User.query.get_or_404` method to return an HTTP `404 Not Found` status in
    case there is no user with the requested id in the underlying database. In case
    the user exists, the code calls the `user_schema.dump` method with the retrieved
    user as an argument to use the `UserSchema` instance to serialize the `User` instance
    whose `id` matches the specified `id`. The `dump` method takes the `User` instance
    and applies the field filtering and output formatting specified in the `UserSchema`
    class. The field filtering specifies that we don't want the hashed password to
    be serialized. The code returns the `data` attribute of the result returned by
    the `dump` method, that is, the serialized message in JSON format as the body,
    with the default HTTP `200 OK` status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a `UserListResource` class that we will use to represent
    the collection of users. Open the `api/views.py` file and add the following lines
    after the code that creates the `UserResource` class. The code file for the sample
    is included in the `restful_python_chapter_07_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserListResource` class is a subclass of `flask_restful.Resource` because
    we don''t want all the methods to require authentication. We want to be able to
    create a new user without being authenticated, and therefore, we apply the `@auth.login_required`
    decorator only for the `get` method. The `post` method doesn''t require authentication.
    The class declares the following two methods that will be called when the `HTTP`
    method with the same name arrives as a request on the represented resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method returns a list with all the `User` instances saved in the
    database. First, the code calls the `User.query.all` method to retrieve all the
    `User` instances persisted in the database. Then, the code calls the `user_schema.dump`
    method with the retrieved messages and the `many` argument set to `True` to serialize
    the iterable collection of objects. The `dump` method will take each `User` instance
    retrieved from the database and apply the field filtering and output formatting
    specified the `CategorySchema` class. The code returns the `data` attribute of
    the result returned by the dump method, that is, the serialized messages in JSON
    format as the body, with the default HTTP `200 OK` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post`: This method retrieves the key-value pairs received in the JSON body,
    creates a new `User` instance and persists it in the database. First, the code
    calls the `request.get_json` method to retrieve the key-value pairs received as
    arguments with the request. Then, the code calls the `user_schema.validate` method
    to validate the new user built with the retrieved key-value pairs. In this case,
    the call to this method will just validate the `name` field for the user. In case
    there were validation errors, the code returns the validation errors and an HTTP
    `400 Bad Request` status. If the validation is successful, the code checks whether
    an user with the same name already exists in the database or not to return an
    appropriate error for the field that must be unique. If the user name is unique,
    the code creates a new user with the specified `name` and calls its `check_password_strength_and_hash_if_ok`
    method. If the provided password fulfils all the quality requirements, the code
    persists the user with its hashed password in the database. Finally, the code
    returns the serialized saved user in JSON format as the body, with the HTTP `201
    Created` status code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table shows the method of our previously created classes related
    to usres that we want to be executed for each combination of `HTTP` verb and scope.
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Scope** | **Class and method** | **Requires authentication**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of users | UserListResource.get | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | User | UserResource.get | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of users | UserListResource.post | No |'
  prefs: []
  type: TYPE_TB
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines configure the resource routing for the user related resources to the api.
    Open the `api/views.py` file and add the following lines at the end of the code.
    The code file for the sample is included in the `restful_python_chapter_07_02`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Each call to the `api.add_resource` method routes a URL to one of the previously
    coded user related resources. When there is a request to the API and the URL matches
    one of the URLs specified in the `api.add_resource` method, Flask will call the
    method that matches the `HTTP` verb in the request for the specified class.
  prefs: []
  type: TYPE_NORMAL
- en: Running migrations to generate the user table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will run many scripts to run migrations and generate the necessary table
    in the PostgreSQL database. Make sure you run the scripts in the terminal or the
    Command Prompt window in which you have activated the virtual environment and
    that you are located in the `api` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the first script that populates the migration script with the detected
    changes in the models. In this case, it is the second time we populate the migration
    script, and therefore, the migration script will generate the new table that will
    persist our new `User` model: `model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the sample output generated after running the previous
    script. Your output will be different according to the base folder in which you
    have created the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that the `api/migrations/versions/c8c45e615f6d_.py` file
    includes the code to create the `user` tables. The following lines show the code
    for this file that was automatically generated based on the models. Notice that
    the file name will be different in your configuration. The code file for the sample
    is included in the `restful_python_chapter_06_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The code defines two functions: `upgrade` and `downgrade`. The `upgrade` function
    runs the necessary code to create the `user` table by making calls to `alembic.op.create_table`.
    The `downgrade` function runs the necessary code to go back to the previous version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the second script to upgrade the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output generated after running the previous
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The previous script called the `upgrade` function defined in the automatically
    generated `api/migrations/versions/c8c45e615f6d_.py` script. Don't forget that
    the file name will be different in your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we run the previous scripts, we can use the PostgreSQL command line or
    any other application that allows us to easily verify the contents of the PostreSQL
    database to check the new table that the migration generated. Run the following
    command to list the generated tables. In case the database name you are using
    is not named `messages`, make sure you use the appropriate database name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the output with all the generated table names. The
    migrations upgrade generate a new table named `user`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy generated the user table with its primary key, its unique constraint
    on the name field and the password field based on the information included in
    our `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will allow you to check the contents of the user table
    after we compose and send HTTP requests to the RESTful API and create new users.
    The commands assume that you are running PostgreSQL on the same computer in which
    you are running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the `api/run.py` script that launches Flask''s development.
    Execute the following command in the `api` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: After we execute the previous command, the development server will start listening
    at port `5000`.
  prefs: []
  type: TYPE_NORMAL
- en: Composing requests with the necessary authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to retrieve the first page of
    the messages without authentication credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive a `401 Unauthorized` status code in the response header. The
    following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If we want to retrieve messages, that is, to make a `GET` request to `/api/messages/`,
    we need to provide authentication credentials using HTTP authentication. However,
    before we can do this, it is necessary to create a new user. We will use the new
    user to test our new resource classes related to users and our changes in the
    permissions policies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, the creation of a user and the execution of the methods that require
    authentication should only be possible under HTTPS. This way, the username and
    the password would be encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: The previous command will compose and send a `POST` HTTP request with the specified
    JSON key-value pairs. The requests specify `/api/user/`, and therefore, it will
    match the `'/users/'` URL route for the `UserList` resource and run the `UserList.post`
    method that doesn't require authentication. The method doesn't receive arguments
    because the URL route doesn't include any parameters. As the HTTP verb for the
    request is `POST`, Flask calls the `post` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previously specified password only includes lowercase letters, and therefore,
    it doesn''t fulfil all the qualitative requirements we have specified for the
    passwords in the `User.check_password_strength_and_hash_if_ok` method. Thus, We
    will receive a `400 Bad Request` status code in the response header and the error
    message indicating the requirement that the password didn''t fulfil in the JSON
    body. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will create a user with a valid password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If the new `User` instance is successfully persisted in the database, the call
    will return an `HTTP 201 Created` status code and the recently persisted `User`
    serialized to JSON in the response body. The following lines show an example response
    for the HTTP requests, with the new `User` object in the JSON responses. Note
    that the response includes the URL, `url`, for the created user and doesn't include
    any information related to the password.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the previously explained command to check the contents of the `user`
    table that the migrations created in the PostgreSQL database. We will notice that
    the `hashed_password` field contents are hashed for the new row in the `user`
    table. The following screenshot shows the contents for the new row of the `user`
    table in a PostgreSQL database after running the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing requests with the necessary authentication](img/image_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to retrieve the first page of messages, that is, to make a `GET`
    request to `/api/messages/`, we need to provide authentication credentials using
    HTTP authentication. Now, we will compose and send an HTTP request to retrieve
    the first page of messages with authentication credentials, that is, with the
    user name and the password we have recently created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The user will be successfully authenticated and we will be able to process the
    request to retrieve the first page of messages. With all the changes we have made
    to our API, unauthenticated requests can only create a new user.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `flask.g` object is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A proxy that provides access to the current request.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An instance of the `flask_httpauth.HTTPBasicAuth` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A proxy that allows us to store on this whatever we want to share for one request
    only.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `passlib` package provides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A password hashing framework that supports more than 30 schemes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An authentication framework that automatically adds models for users and permissios
    to a Flask application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight web framework that replaces Flask.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `auth.verify_password` decorator applied to a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Makes this function become the callback that `Flask-HTTPAuth` will use to hash
    the password for a specific user.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Makes this function become the callback that `SQLAlchmey` will use to verify
    the password for a specific user.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Makes this function become the callback that `Flask-HTTPAuth` will use to verify
    the password for a specific user.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you assign a list that includes `auth.login_required` to the `method_decorators`
    property of any subclass of `flask_restful.Resource`, considering that auth is
    an instance of the `flask_httpauth.HTTPBasicAuth()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the methods declared in the resource will have the `auth.login_required`
    decorator applied to them.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `post` method declared in the resource will have `auth.login_required` decorator
    applied to it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any of the following methods declared in the resource will have `auth.login_required`
    decorator applied to them: `delete`, `patch`, `post` and `put`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following lines retrieves the integer value for the `'page'` argument
    from the request object, considering that the code would be running within a method
    defined in a subclass of `flask_restful.Resource` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`page_number = request.get_argument(''page'', 1, type=int)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`page_number = request.args.get(''page'', 1, type=int)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`page_number = request.arguments.get(''page'', 1, type=int)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we improved the RESTful API in many ways. We added user friendly
    error messages when resources aren't unique. We tested how to update single or
    multiple fields with the `PATCH` method and we created our own generic pagination
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we started working with authentication and permissions. We added a user
    model and we updated the database. We made many changes in the different pieces
    of code to achieve a specific security goal and we took advantage of Flask-HTTPAuth
    and passlib to use HTTP authentication in our API.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built an improved a complex API that uses pagination and authentication,
    we will use additional abstractions included in the framework and we will code,
    execute, and improve unit test, which is what we are going to discuss in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
