- en: Chapter 7.  Improving and Adding Authentication to an API with Flask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用Flask改进和添加认证到API
- en: 'In this chapter, we will improve the RESTful API that we started in the previous
    chapter and we will add authentication related security to it. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将改进上一章中开始构建的RESTful API，并将与之相关的认证安全添加到其中。我们将：
- en: Improve unique constraints in the models
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进模型中的唯一约束
- en: Update fields for a resource with the `PATCH` method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PATCH`方法更新资源的字段
- en: Code a generic pagination class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个通用的分页类
- en: Add pagination features to the API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为API添加分页功能
- en: Understand the steps to add authentication and permissions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解添加认证和权限的步骤
- en: Add a user model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用户模型
- en: Create a schema to validate, serialize and deserialize users
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模式来验证、序列化和反序列化用户
- en: Add authentication to resources
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为资源添加认证
- en: Create resource classes to handle users
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于处理用户的资源类
- en: Run migrations to generate the user table
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行迁移以生成用户表
- en: Compose requests with the necessary authentication
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用必要的认证组合请求
- en: Improving unique constraints in the models
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进模型中的唯一约束
- en: When we created the `Category` model, we specified the `True` value for the
    unique argument when we created the `db.Column` instance named `name`. As a result,
    the migrations generated the necessary unique constraint to make sure that the
    `name` field has unique values in the `category` table. This way, the database
    won't allow us to insert duplicate values for `category.name`. However, the error
    message generated when we try to do so is not clear.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`Category`模型时，我们在创建名为`name`的`db.Column`实例时指定了唯一参数的`True`值。因此，迁移生成了必要的唯一约束，以确保`name`字段在`category`表中具有唯一值。这样，数据库将不允许我们为`category.name`插入重复值。然而，当我们尝试这样做时生成的错误信息并不清晰。
- en: 'Run the following command to create a category with a duplicate name. There
    is already an existing category with the name equal to `''Information''`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个具有重复名称的类别。已经存在一个名为`'Information'`的现有类别：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous command will compose and send a `POST` HTTP request with the specified
    JSON key-value pair. The unique constraint in the `category.name` field won''t
    allow the database table to persist the new category. Thus, the request will return
    an HTTP `400 Bad Request` status code with an integrity error message. The following
    lines show a sample response:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送一个带有指定JSON键值对的`POST` HTTP请求。`category.name`字段中的唯一约束将不允许数据库表持久化新的类别。因此，请求将返回一个带有完整性错误信息的HTTP
    `400 Bad Request`状态码。以下行显示了示例响应：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Obviously, the error message is extremely technical and provides too many details
    about the database and the query that failed. We might parse the error message
    to automatically generate a more user friendly error message. However, instead
    of doing so, we want to avoid trying to insert a row that we know will fail. We
    will add code to make sure that a category is unique before we try to persist
    it. Of course, there is still a chance to receive the previously shown error if
    somebody inserts a category with the same name between the time we run our code,
    indicating that a category name is unique, and persist the changes in the database.
    However, the chances are lower and we can reduce the changes of the previously
    shown error message to be shown.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，错误信息非常技术化，提供了太多关于数据库和失败查询的细节。我们可能会解析错误信息以自动生成一个更用户友好的错误信息。然而，我们不想尝试插入一个我们知道会失败的行。我们将在尝试持久化之前添加代码以确保类别是唯一的。当然，仍然有可能在我们运行代码和将更改持久化到数据库之间，有人插入了一个具有相同名称的类别，这表明类别名称是唯一的。然而，这种情况的可能性较低，我们可以降低之前显示的错误信息被显示的可能性。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In a production-ready REST API we should never return the error messages returned
    by SQLAlchemy or any other database-related data, as it might include sensitive
    data that we don't want the users of our API to be able to retrieve. In this case,
    we are returning all the errors for debugging purposes and to be able to improve
    our API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个生产就绪的REST API中，我们永远不应该返回由SQLAlchemy或其他数据库相关数据返回的错误信息，因为这可能包括我们不希望API用户能够检索的敏感数据。在这种情况下，我们返回所有错误是为了调试目的，并能够改进我们的API。
- en: 'Now, we will add a new class method to the `Category` class to allow us to
    determine whether a name is unique or not. Open the `api/models.py` file and add
    the following lines within the declaration of the `Category` class. The code file
    for the sample is included in the `restful_python_chapter_07_01` folder:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `Category` 类中添加一个新的类方法，以便我们能够确定名称是否唯一。打开 `api/models.py` 文件，在 `Category`
    类的声明中添加以下行。示例代码文件包含在 `restful_python_chapter_07_01` 文件夹中：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The new `Category.is_unique` class method receives the `id` and the `name` for
    the category that we want to make sure that has a unique name. If the category
    is a new one that hasn't been saved yet, we will receive a 0 for the `id` value.
    Otherwise, we will receive the category id in the argument.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `Category.is_unique` 类方法接收我们想要确保具有唯一名称的类别的 `id` 和 `name`。如果类别是新的且尚未保存，我们将收到
    `id` 值为 `0`。否则，我们将收到作为参数传递的类别 `id`。
- en: The method calls the `query.filter_by` method for the current class to retrieve
    a category whose name matches the other category name. In case there is a category
    that matches the criteria, the method will return `True` only if the id is the
    same one than the one received in the argument. In case no category matches the
    criteria, the method will return `True`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法调用当前类的 `query.filter_by` 方法来检索一个名称与另一个类别名称匹配的类别。如果存在匹配条件的类别，则方法将仅在 `id` 与参数中接收的
    `id` 相同时返回 `True`。如果没有类别匹配条件，则方法将返回 `True`。
- en: 'We will use the previously created class method to check whether a category
    is unique or not before creating and persisting it in the `CategoryListResource.post`
    method. Open the `api/views.py` file and replace the existing `post` method declared
    in the `CategoryListResource` class with the following lines. The lines that have
    been added or modified are highlighted. The code file for the sample is included
    in the `restful_python_chapter_07_01` folder:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在创建并持久化之前使用之前创建的类方法来检查类别是否唯一。打开 `api/views.py` 文件，并用以下行替换 `CategoryListResource`
    类中声明的现有 `post` 方法。已添加或修改的行已突出显示。示例代码文件包含在 `restful_python_chapter_07_01` 文件夹中：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we will perform the same validation in the `CategoryResource.patch` method.
    Open the `api/views.py` file and replace the existing `patch` method declared
    in the `CategoryResource` class with the following lines. The lines that have
    been added or modified are highlighted. The code file for the sample is included
    in the `restful_python_chapter_07_01` folder:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `CategoryResource.patch` 方法中执行相同的验证。打开 `api/views.py` 文件，并用以下行替换 `CategoryResource`
    类中声明的现有 `patch` 方法。已添加或修改的行已突出显示。示例代码文件包含在 `restful_python_chapter_07_01` 文件夹中：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the following command to again create a category with a duplicate name:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令再次创建一个具有重复名称的类别：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous command will compose and send a `POST` HTTP request with the specified
    JSON key-value pair. The changes we made will generate a response with a user
    friendly error message and will avoid trying to persist the changes. The request
    will return an HTTP `400 Bad Request` status code with the error message in the
    JSON body. The following lines show a sample response:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送一个带有指定 JSON 键值对的 `POST` HTTP 请求。我们所做的更改将生成一个带有用户友好错误消息的响应，并避免尝试持久化更改。请求将返回一个带有
    JSON 主体中错误消息的 HTTP `400 Bad Request` 状态码。以下行显示了一个示例响应：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we will add a new `class` method to the `Message` class to allow us to
    determine whether a message is unique or not. Open the `api/models.py` file and
    add the following lines within the declaration of the `Message` class. The code
    file for the sample is included in the `restful_python_chapter_07_01` folder:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `Message` 类中添加一个新的 `class` 方法，以便我们能够确定消息是否唯一。打开 `api/models.py` 文件，在
    `Message` 类的声明中添加以下行。示例代码文件包含在 `restful_python_chapter_07_01` 文件夹中：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The new `Message.is_unique` class method receives the `id` and the `message`
    for the message that we want to make sure that has a unique value for the message
    field. If the message is a new one that hasn't been saved yet, we will receive
    a `0` for the `id` value. Otherwise, we will receive the message id in the argument.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `Message.is_unique` 类方法接收我们想要确保消息字段具有唯一值的消息的 `id` 和 `message`。如果消息是新的且尚未保存，我们将收到
    `id` 值为 `0`。否则，我们将收到作为参数传递的消息 `id`。
- en: The method calls the `query.filter_by` method for the current class to retrieve
    a message whose message field matches the other message's message. In case there
    is a message that matches the criteria, the method will return `True` only if
    the id is the same one than the one received in the argument. In case no message
    matches the criteria, the method will return `True`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法调用当前类的`query.filter_by`方法来检索一个消息字段与另一个消息的消息字段匹配的消息。如果存在符合条件的信息，则方法将仅在id与参数中接收到的id相同时返回`True`。如果没有消息符合条件，则方法将返回`True`。
- en: 'We will use the previously created class method to check whether a message
    is unique or not before creating and persisting it in the `MessageListResource.post`
    method. Open the `api/views.py` file and replace the existing `post` method declared
    in the `MessageListResource` class with the following lines. The lines that have
    been added or modified are highlighted. The code file for the sample is included
    in the `restful_python_chapter_07_01` folder:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在创建并持久化到`MessageListResource.post`方法之前，使用之前创建的类方法来检查消息是否唯一。打开`api/views.py`文件，将`MessageListResource`类中声明的现有`post`方法替换为以下行。已添加或修改的行已突出显示。示例的代码文件包含在`restful_python_chapter_07_01`文件夹中：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we will perform the same validation in the `MessageResource.patch` method.
    Open the `api/views.py` file and replace the existing `patch` method declared
    in the `MessageResource` class with the following lines. The lines that have been
    added or modified are highlighted. The code file for the sample is included in
    the `restful_python_chapter_07_01` folder:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`MessageResource.patch`方法中执行相同的验证。打开`api/views.py`文件，将`MessageResource`类中声明的现有`patch`方法替换为以下行。已添加或修改的行已突出显示。示例的代码文件包含在`restful_python_chapter_07_01`文件夹中：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the following command to create a message with a duplicate value for the
    message field:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个消息字段值为重复的消息：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The previous command will compose and send a `POST` HTTP request with the specified
    JSON key-value pair. The changes we made will generate a response with a user
    friendly error message and will avoid trying to persist the changes in the message.
    The request will return an HTTP `400 Bad Request` status code with the error message
    in the JSON body. The following lines show a sample response:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送一个带有指定JSON键值对的`POST` HTTP请求。我们所做的更改将生成一个带有用户友好错误消息的响应，并避免尝试在消息中持久化更改。请求将返回带有JSON正文中的错误消息的HTTP
    `400 Bad Request`状态码。以下行显示了示例响应：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Updating fields for a resource with the PATCH method
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`PATCH`方法更新资源的字段
- en: As we explained in [Chapter 6](ch06.html "Chapter 6.  Working with Models, SQLAlchemy,
    and Hyperlinked APIs in Flask") *, Working with Models, SQLAlchemy, and Hyperlinked
    APIs in Flask*, our API is able to update a single field for an existing resource,
    and therefore, we provide an implementation for the `PATCH` method. For example,
    we can use the `PATCH` method to update an existing message and set the value
    for its `printed_once` and `printed_times` fields to `true` and `1`. We don't
    want to use the `PUT` method because this method is meant to replace an entire
    message. The `PATCH` method is meant to apply a delta to an existing message,
    and therefore, it is the appropriate method to just change the value of those
    two fields.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](ch06.html "第6章。在Flask中使用模型、SQLAlchemy和超链接API")中解释的，*在Flask中使用模型、SQLAlchemy和超链接API*，我们的API能够更新现有资源的单个字段，因此，我们提供了一个`PATCH`方法的实现。例如，我们可以使用`PATCH`方法来更新现有的消息，并将其`printed_once`和`printed_times`字段的值设置为`true`和`1`。我们不希望使用`PUT`方法，因为这个方法旨在替换整个消息。`PATCH`方法旨在将增量应用于现有消息，因此，它是仅更改这两个字段值的适当方法。
- en: 'Now, we will compose and send an HTTP request to update an existing message,
    specifically, to update the value of the `printed_once` and `printed_times` fields.
    Because we just want to update two fields, we will use the `PATCH` method instead
    of `PUT`. Make sure you replace `1` with the id or primary key of an existing
    message in your configuration:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求来更新现有的消息，具体来说，是更新`printed_once`和`printed_times`字段的值。因为我们只想更新两个字段，所以我们将使用`PATCH`方法而不是`PUT`。确保将`1`替换为您配置中现有消息的id或主键：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The previous command will compose and send a `PATCH` HTTP request with the
    following specified JSON key-value pairs:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送一个包含以下指定 JSON 键值对的 `PATCH` HTTP 请求：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The request has a number after `/api/messages/`, and therefore, it will match
    `'/messages/<int:id>'` and run the `MessageResource.patch` method, that is, the
    `patch` method for the `MessageResource` class. If a `Message` instance with the
    specified id exists, the code will retrieve the values for the `printed_times`
    and `printed_once` keys in the request dictionary update the `Message` instance
    and validate it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请求在 `/api/messages/` 后面有一个数字，因此，它将匹配 `'/messages/<int:id>'` 并运行 `MessageResource.patch`
    方法，即 `MessageResource` 类的 `patch` 方法。如果存在具有指定 id 的 `Message` 实例，代码将检索请求字典中 `printed_times`
    和 `printed_once` 键的值，更新 `Message` 实例并验证它。
- en: 'If the updated `Message` instance is valid, the code will persist the changes
    in the database and the call to the method will return an HTTP `200 OK` status
    code and the recently updated `Message` instance serialized to JSON in the response
    body. The following lines show a sample response:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新的 `Message` 实例有效，代码将在数据库中持久化更改，并且对方法的调用将返回 HTTP `200 OK` 状态码，以及最近更新的 `Message`
    实例序列化为 JSON 的响应体。以下行显示了示例响应：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can run the commands explained in [Chapter 6](ch06.html "Chapter 6.  Working
    with Models, SQLAlchemy, and Hyperlinked APIs in Flask") *,* *Working with Models,
    SQLAlchemy, and Hyperlinked APIs in Flask*, to check the contents of the tables
    that the migrations created in the PostgreSQL database. We will notice that the
    `printed_times` and `printed_once` values have been updated for the row in the
    message table. The following screenshot shows the contents for the updated row
    of the `message` table in a PostgreSQL database after running the HTTP request.
    The screenshot shows the results of executing the following SQL query: `SELECT
    * FROM message WHERE id = 1`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行第 6 章[“使用 Flask 中的模型、SQLAlchemy 和超链接 API”](ch06.html "第 6 章。使用 Flask 中的模型、SQLAlchemy
    和超链接 API")中解释的命令，*“使用 Flask 中的模型、SQLAlchemy 和超链接 API”*，以检查在 PostgreSQL 数据库中创建的迁移创建的表的内容。我们会注意到消息表中的
    `printed_times` 和 `printed_once` 值已被更新。以下屏幕截图显示了在运行 HTTP 请求后 PostgreSQL 数据库中更新后的
    `message` 表的行内容。屏幕截图显示了执行以下 SQL 查询的结果：`SELECT * FROM message WHERE id = 1`：
- en: '![Updating fields for a resource with the PATCH method](img/image_07_001.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![使用 PATCH 方法更新资源的字段](img/image_07_001.jpg)'
- en: Coding a generic pagination class
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个通用的分页类
- en: Our database has a few rows for each of the tables that persist the models we
    have defined. However, after we start working with our API in a real-life production
    environment, we will have hundreds of messages, and therefore, we will have to
    deal with large result sets. Thus, we will create a generic pagination class and
    we will use it to easily specify how we want large results sets to be split into
    individual pages of data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库为每个持久化我们定义的模型的表都保留了几行。然而，在我们开始在现实生活中的生产环境中使用我们的 API 之后，我们将有数百条消息，因此，我们将不得不处理大量结果集。因此，我们将创建一个通用的分页类，并使用它来轻松指定我们希望如何将大量结果集分割成单独的数据页。
- en: 'First, we will compose and send HTTP requests to create `9` messages that belong
    to one of the categories we have created: `Information`. This way, we will have
    a total of 12 messages persisted in the database. We had 3 messages and we add
    9 more.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写并发送 HTTP 请求来创建属于我们创建的某个类别（`Information`）的 `9` 条消息。这样，我们将有总共 12 条消息持久化在数据库中。我们原本有
    3 条消息，然后又增加了 9 条。
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following are the equivalent `curl` commands:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous commands will compose and send nine `POST` HTTP requests with the
    specified JSON key-value pairs. The request specifies `/api/messages/`, and therefore,
    it will match `'/messages/'` and run the `MessageListResource.post` method, that
    is, the `post` method for the `MessageListResource` class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送九个包含指定 JSON 键值对的 `POST` HTTP 请求。请求指定 `/api/messages/`，因此，它将匹配 `'/messages/'`
    并运行 `MessageListResource.post` 方法，即 `MessageListResource` 类的 `post` 方法。
- en: Now, we have 12 messages in our database. However, we don't want to retrieve
    the 12 messages when we compose and send a `GET` HTTP request to `/api/messages/`.
    We will create a customizable generic pagination class to include a maximum of
    5 resources in each individual page of data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们数据库中有 12 条消息。然而，当我们编写并发送一个 `GET` HTTP 请求到 `/api/messages/` 时，我们不想检索这 12
    条消息。我们将创建一个可定制的通用分页类，以在每个单独的数据页中包含最多 5 个资源。
- en: 'Open the `api/config.py` file and add the following lines that declare two
    variables that configure the global pagination settings. The code file for the
    sample is included in the `restful_python_chapter_07_01` folder:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`api/config.py`文件，并添加以下行，声明两个变量以配置全局分页设置。示例代码文件包含在`restful_python_chapter_07_01`文件夹中：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The value for the `PAGINATION_PAGE_SIZE` variable specifies a global setting
    with the default value for the page size, also known as limit. The value for the
    `PAGINATION_PAGE_ARGUMENT_NAME` specifies a global setting with the default value
    for the argument name that we will use in our requests to specify the page number
    we want to retrieve.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`PAGINATION_PAGE_SIZE`变量的值指定了一个全局设置，其默认值为页面大小，也称为限制。`PAGINATION_PAGE_ARGUMENT_NAME`变量的值指定了一个全局设置，其默认值为我们将用于请求中指定要检索的页码的参数名称。'
- en: 'Create a new `helpers.py` file within the `api` folder. The following lines
    show the code that creates a new `PaginationHelper` class. The code file for the
    sample is included in the `restful_python_chapter_07_01` folder:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`api`文件夹中创建一个新的`helpers.py`文件。以下行显示了创建新的`PaginationHelper`类的代码。示例代码文件包含在`restful_python_chapter_07_01`文件夹中：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `PaginationHelper` class declares a constructor, that is, the `__init__`
    method that received many arguments and uses them to initialize the attributes
    with the same names:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`PaginationHelper`类声明了一个构造函数，即`__init__`方法，它接收许多参数并使用它们来初始化具有相同名称的属性：'
- en: '`request`: The Flask request object that will allow the `paginate_query` method
    to retrieve the page number value specified with the HTTP request.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`：Flask请求对象，它将允许`paginate_query`方法检索通过HTTP请求指定的页码值。'
- en: '`query`: The SQLAlchemy query that the `paginate_query` method has to paginate.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query`：`paginate_query`方法必须分页的SQLAlchemy查询。'
- en: '`resource_for_url`: A string with the resource name that the `paginate_query`
    method will use to generate the full URLs for the previous page and the next page.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource_for_url`：一个字符串，包含`paginate_query`方法将用于生成上一页和下一页的完整URL的资源名称。'
- en: '`key_name`: A string with the key name that the `paginate_query` method will
    use to return the serialized objects.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key_name`：一个字符串，包含`paginate_query`方法将使用的关键名称来返回序列化的对象。'
- en: '`schema`: The Flask-Marshmallow `Schema` subclass that the `paginate_query`
    method must use to serialize the objects.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schema`：`paginate_query`方法必须使用的Flask-Marshmallow `Schema`子类，用于序列化对象。'
- en: In addition, the constructor reads and saves the values for the configuration
    variables we added to the `config.py` file in the `results_per_page` and `page_argument_name`
    attributes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，构造函数读取并保存了我们添加到`config.py`文件中的配置变量的值，并将其保存到`results_per_page`和`page_argument_name`属性中。
- en: The class declares the `paginate_query` method. First, the code retrieves the
    page number specified in the request and saves it in the `page_number` variable.
    In case no page number is specified, the code assumes that request requires the
    first page. Then, the code calls the `self.query.paginate` method to retrieve
    the page number specified by `page_number` of the paginated result of objects
    from the database, with a number of results per page indicated by the value of
    the `self.results_per_page` attribute. The next line saves the paginated items
    from the `paginated_object.items` attribute in the `objects` variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明了`paginate_query`方法。首先，代码检索请求中指定的页码并将其保存到`page_number`变量中。如果没有指定页码，代码假定请求需要第一页。然后，代码调用`self.query.paginate`方法，根据`self.results_per_page`属性的值检索数据库中对象的分页结果中指定的`page_number`页码，每页的结果数量由`self.results_per_page`属性的值指示。下一行将`paginated_object.items`属性中的分页项保存到`objects`变量中。
- en: If the value for the `paginated_objects.has_prev` attribute is `True`, it means
    that there is a previous page available. In this case, the code calls the `flask.url_for`
    function to generate the full URL for the previous page with the value of the
    `self.resource_for_url` attribute. The `_external` argument is set to `True` because
    we want to provide the full URL.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`paginated_objects.has_prev`属性的值为`True`，则表示有上一页可用。在这种情况下，代码调用`flask.url_for`函数，使用`self.resource_for_url`属性的值生成上一页的完整URL。`_external`参数设置为`True`，因为我们想提供完整的URL。
- en: If the value for the `paginated_objects.has_next` attribute is `True`, it means
    that there is a next page available. In this case, the code calls the `flask.url_for`
    function to generate the full URL for the next page with the value of the `self.resource_for_url`
    attribute.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`paginated_objects.has_next`属性的值为`True`，则表示存在下一页。在这种情况下，代码会调用`flask.url_for`函数，生成包含`self.resource_for_url`属性值的下一页的完整URL。
- en: Then, the code calls the `self.schema.dump` method to serialize the partial
    results previously saved in the `object` variable, with the `many` argument set
    to `True`. The `dumped_objects` variable saves the reference to the `data` attribute
    of the results returned by the call to the `dump` method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码调用`self.schema.dump`方法，将之前保存在`object`变量中的部分结果序列化，将`many`参数设置为`True`。`dumped_objects`变量保存了对`dump`方法返回的结果的`data`属性的引用。
- en: 'Finally, the method returns a dictionary with the following key-value pairs:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该方法返回一个包含以下键值对的字典：
- en: '`self.key_name`: The serialized partial results saved in the `dumped_objects`
    variable.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.key_name`：保存于`dumped_objects`变量中的序列化部分结果。'
- en: '`''previous''`: The full URL for the previous page saved in the `previous_page_url`
    variable.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''previous''`：保存于`previous_page_url`变量中的上一页的完整URL。'
- en: '`''previous''`: The full URL for the next page saved in the `next_page_url`
    variable.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''previous''`：保存于`next_page_url`变量中的下一页的完整URL。'
- en: '`''count''`: The total number of objects available in the complete resultset
    retrieved from the `paginated_objects.total` attribute.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''count''`：从`paginated_objects.total`属性检索到的完整结果集中可用的对象总数。'
- en: Adding pagination features
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分页功能
- en: 'Open the `api/views.py` file and replace the code for the `MessageListResource.get`
    method with the highlighted lines in the next listing. In addition, make sure
    that you add the import statement. The code file for the sample is included in
    the `restful_python_chapter_07_01` folder:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`api/views.py`文件，将`MessageListResource.get`方法的代码替换为下一列表中突出显示的行。此外，请确保添加导入语句。示例代码文件包含在`restful_python_chapter_07_01`文件夹中：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The new code for the `get` method creates an instance of the previously explained
    `PaginationHelper` class named `pagination_helper` with the `request` object as
    the first argument. The named arguments specify the `query`, `resource_for_url`,
    `key_name`, and `schema` that the `PaginationHelper` instance has to use to provide
    a paginated query result.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法的新代码创建了一个名为`pagination_helper`的之前解释过的`PaginationHelper`类实例，将`request`对象作为第一个参数。命名参数指定了`PaginationHelper`实例必须使用的`query`、`resource_for_url`、`key_name`和`schema`，以提供分页查询结果。'
- en: The next line calls the `pagination_helper.paginate_query` method that will
    return the results of the paginated query with the page number specified in the
    request. Finally, the method returns the results of the call to this method that
    include the previously explained dictionary. In this case, the paginated resultset
    with the messages will be rendered as a value of the `'results'` key, specified
    in the `key_name` argument.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行调用`pagination_helper.paginate_query`方法，该方法将返回指定请求中页码的分页查询结果。最后，该方法返回包含之前解释过的字典的调用结果。在这种情况下，包含消息的分页结果集将作为`'results'`键的值渲染，该键由`key_name`参数指定。
- en: Now, we will compose and send an HTTP request to retrieve all the messages,
    specifically an HTTP `GET` method to `/api/messages/`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求来检索所有消息，具体是一个针对`/api/messages/`的HTTP `GET`方法。
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is the equivalent curl command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The new code for the `MessageListResource.get` method will work with pagination
    and the result will provide us the first 5 messages (`results` key), the total
    number of messages for the query (`count` key) and a link to the next (`next`
    key) and previous (`previous` key) pages. In this case, the resultset is the first
    page, and therefore, the link to the previous page (previous `key`) is `null`.
    We will receive a `200 OK` status code in the response header and the 5 messages
    in the `results` array:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageListResource.get`方法的新代码将支持分页，并提供的结果将包括前5条消息（`results`键）、查询的总消息数（`count`键）以及指向下一页（`next`键）和上一页（`previous`键）的链接。在这种情况下，结果集是第一页，因此，指向上一页的链接（`previous`键）是`null`。我们将在响应头中收到`200
    OK`状态码，并在`results`数组中收到5条消息：'
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the previous HTTP request, we didn''t specify any value for the `page` parameter,
    and therefore the `paginate_query` method in the `PaginationHelper` class requests
    the first page to the paginated query. If we compose and send the following HTTP
    request to retrieve the first page of all the messages by specifying 1 for the
    `page` value, the API will provide the same results shown before:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的HTTP请求中，我们没有指定`page`参数的任何值，因此`PaginationHelper`类中的`paginate_query`方法请求分页查询的第一页。如果我们构建并发送以下HTTP请求以通过将`page`值指定为1来检索所有消息的第一页，API将提供之前显示的相同结果：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the equivalent curl command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The code in the `PaginationHelper` class considers that first page is page number
    1\. Thus, we don't work with zero-based numbering for pages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`PaginationHelper`类中的代码认为第一页是页码1。因此，我们不对页码使用基于0的编号。'
- en: 'Now, we will compose and send an HTTP request to retrieve the next page, that
    is, the second page for the messages, specifically an HTTP `GET` method to `/api/messages/`
    with the `page` value set to `2`. Remember that the value for the `next` key returned
    in the JSON body of the previous result provides us with the full URL to the next
    page:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建并发送一个HTTP请求来检索下一页，即消息的第二页，具体是一个到`/api/messages/`的HTTP `GET`方法，将`page`值设置为`2`。请记住，前一个结果JSON体中返回的`next`键的值为我们提供了到下一页的完整URL：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The result will provide us the second set of the five message resource (`results`
    key), the total number of messages for the query (`count` key), a link to the
    next (`next` key), and previous (`previous` key) pages. In this case, the resultset
    is the second page, and therefore, the link to the previous page (previous `key`)
    is `http://localhost:5000/api/messages/?page=1`. We will receive a `200 OK` status
    code in the response header and the 5 messages in the `results` array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将为我们提供五条消息资源的第二批（`results`键），查询的消息总数（`count`键），到下一页（`next`键）和上一页（`previous`键）的链接。在这种情况下，结果集是第二页，因此，到上一页的链接（`previous`键）是`http://localhost:5000/api/messages/?page=1`。我们将在响应头中收到`200
    OK`状态码，并在`results`数组中收到5条消息。
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we will compose and send an HTTP request to retrieve the last page,
    that is, the third page for the messages, specifically an HTTP `GET` method to
    `/api/messages/` with the `page` value set to `3`. Remember that the value for
    the next key returned in the JSON body of the previous result provides us with
    the URL to the next page:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将构建并发送一个HTTP请求来检索最后一页，即消息的第三页，具体是一个到`/api/messages/`的HTTP `GET`方法，将`page`值设置为`3`。请记住，前一个结果JSON体中返回的`next`键的值为我们提供了到下一页的URL：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is the equivalent curl command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result will provide us the last set with two message resources (`results`
    key), the total number of messages for the query (`count` key), a link to the
    next (`next` key), and previous (`previous` key) pages. In this case, the resultset
    is the last page, and therefore, the link to the next page (`next` key) is `null`.
    We will receive a `200 OK` status code in the response header and the 2 messages
    in the `results` array:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将为我们提供最后一批包含两个消息资源（`results`键），查询的消息总数（`count`键），到下一页（`next`键）和上一页（`previous`键）的链接。在这种情况下，结果集是最后一页，因此，下一页的链接（`next`键）是`null`。我们将在响应头中收到`200
    OK`状态码，并在`results`数组中收到2条消息：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Understanding the steps to add authentication and permissions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解添加身份验证和权限的步骤
- en: Our current version of the API processes all the incoming requests without requiring
    any kind of authentication. We will use a Flask extension and other packages to
    use an HTTP authentication scheme to identify the user that originated the request
    or the token that signed the request. Then, we will use these credentials to apply
    the permissions that will determine whether the request must be permitted or not.
    Unluckily, neither Flask nor Flask-RESTful provides an authentication framework
    that we can easily plug and configure. Thus, we will have to write code to perform
    many tasks related to authentication and permissions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前版本的API处理所有传入的请求，无需任何类型的身份验证。我们将使用Flask扩展和其他包来使用HTTP身份验证方案来识别发起请求的用户或签名请求的令牌。然后，我们将使用这些凭据来应用权限，这将决定请求是否必须被允许。不幸的是，Flask和Flask-RESTful都没有提供我们可以轻松插入和配置的身份验证框架。因此，我们将不得不编写代码来执行与身份验证和权限相关的许多任务。
- en: We want to be able to create a new user without any authentication. However,
    all the other API calls are only going to be available for authenticated users.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在没有任何身份验证的情况下创建新用户。然而，所有其他API调用都只为已认证的用户提供。
- en: First, we will install a Flask extension to make it easier for us to work with
    HTTP authentication, `Flask-HTTPAuth`, and a package to allow us to hash a password
    and check whether a provided password is valid or not, `passlib`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装一个Flask扩展以使我们更容易处理HTTP身份验证，`Flask-HTTPAuth`，以及一个允许我们对密码进行散列并检查提供的密码是否有效的包，`passlib`。
- en: We will create a new `User` model that will represent a user. The model will
    provide methods to allow us to hash a password and verify whether a password provided
    for a user is valid or not. We will create a `UserSchema` class to specify how
    we want to serialize and deserialize a user.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`User`模型来表示用户。该模型将提供方法，使我们能够对密码进行散列并验证提供给用户的密码是否有效。我们将创建一个`UserSchema`类来指定我们想要如何序列化和反序列化用户。
- en: Then, we will configure the Flask extension to work with our `User` model to
    verify passwords and set the authenticated user associated with a request. We
    will make changes to the existing resources to require authentication and we will
    new resources to allow us to retrieve existing users and create a new one. Finally,
    we will configure the routes for the resources related to users.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将配置Flask扩展以与我们的`User`模型一起工作，以验证密码并设置与请求关联的已认证用户。我们将对现有资源进行更改以要求身份验证，并将新资源添加以允许我们检索现有用户并创建一个新的用户。最后，我们将配置与用户相关的资源路由。
- en: Once we have completed the previously mentioned tasks, we will run migrations
    to generate the new table that persists the users in the database. Then, we will
    compose and send HTTP requests to understand how the authentication and permissions
    work with our new version of the API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了之前提到的任务，我们将运行迁移来生成新的表，该表将持久化数据库中的用户。然后，我们将编写并发送HTTP请求以了解我们的新版本API中的身份验证和权限是如何工作的。
- en: Make sure you quit the Flask development server. Remember that you just need
    to press ***Ctrl*** + ***C*** in the terminal or a Command Prompt window in which
    it is running. It is time to run many commands that will be the same for either
    macOS, Linux, or Windows. We can install all the necessary packages with pip with
    a single command. However, we will run two independent commands to make it easier
    to detect any problems in case a specific installation fails.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已退出Flask开发服务器。请记住，您只需在终端或正在运行的命令提示符窗口中按***Ctrl*** + ***C***即可。现在是运行许多命令的时候了，这些命令对macOS、Linux或Windows都适用。我们可以使用单个命令使用pip安装所有必要的包。然而，我们将运行两个独立的命令，以便在特定安装失败时更容易检测到任何问题。
- en: 'Now, we must run the following command to install Flask-HTTPAuth with pip.
    This package makes it easy to add basic HTTP authentication to any Flask application:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须运行以下命令来使用pip安装Flask-HTTPAuth。这个包使得向任何Flask应用程序添加基本HTTP身份验证变得简单：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last lines for the output will indicate the `Flask-HTTPAuth` package has
    been successfully installed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`Flask-HTTPAuth`包已成功安装：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the following command to install passlib with pip. This package is a popular
    one that provides a comprehensive password hashing framework that supports more
    than 30 schemes. We definitely don''t want to write our own error-prone and probably
    highly insecure password hashing code, and therefore, we will take advantage of
    a library that provides these services:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令使用pip安装passlib。这个包是一个流行的包，它提供了一个支持30多种方案的全面密码散列框架。我们绝对不想编写我们自己的容易出错且可能非常不安全的密码散列代码，因此，我们将利用一个提供这些服务的库：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last lines for the output will indicate the `passlib` package has been
    successfully installed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`passlib`包已成功安装：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Adding a user model
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户模型
- en: 'Now, we will create the model that we will use to represent and persist the
    user. Open the `api/models.py` file and add the following lines after the declaration
    of the `AddUpdateDelete` class. Make sure that you add the import statements.
    The code file for the sample is included in the `restful_python_chapter_07_02`
    folder:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们将用来表示和持久化用户的模型。打开`api/models.py`文件，在`AddUpdateDelete`类的声明之后添加以下行。确保添加导入语句。示例代码文件包含在`restful_python_chapter_07_02`文件夹中：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The code declares the `User` model, specifically a subclasses of both the `db.Model`
    and the `AddUpdateDelete` classes. We specified the field types, maximum lengths
    and defaults for the following three attributes-`id`, `name`, `hashed_password`
    and `creation_date`. These attributes represent fields without any relationship,
    and therefore, they are instances of the `db.Column` class. The model declares
    an `id` attribute and specifies the `True` value for the `primary_key` argument
    to indicate it is the primary key. SQLAlchemy will use the data to generate the
    necessary table in the PostgreSQL database.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了`User`模型，具体是`db.Model`和`AddUpdateDelete`类的子类。我们指定了以下三个属性的字段类型、最大长度和默认值-`id`、`name`、`hashed_password`和`creation_date`。这些属性代表没有关系的字段，因此它们是`db.Column`类的实例。模型声明了一个`id`属性，并指定了`primary_key`参数的`True`值，以指示它是主键。SQLAlchemy将使用这些数据在PostgreSQL数据库中生成必要的表。
- en: 'The `User` class declares the following methods:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类声明了以下方法：'
- en: '`check_password_strength_and_hash_if_ok`: This method uses the `re` module
    that provides regular expression matching operations to check whether the `password`
    received as an argument fulfils many qualitative requirements. The code requires
    the password to be longer than eight characters, with a maximum of 32 characters.
    The password must include at least one uppercase letter, one lowercase letter,
    one number, and one symbol. The code checks the results of many calls to the `re.search`
    method to determine whether the received password fulfils each requirement. In
    case any of the requirements isn''t fulfilled, the code returns a tuple with an
    error message and `False`. Otherwise, the code calls the `encrypt` method for
    the `passlib.apps.custom_app_context` instance imported as `password_context`,
    with the received `password` as an argument. The `encrypt` method chooses a reasonably
    strong scheme based on the platform, with the default settings for rounds selection
    and the code saves the hashed password in the `hash_password` attribute. Finally,
    the code returns a tuple with an empty string and `True`, indicating that the
    password fulfilled the qualitative requirements and it was hashed.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_password_strength_and_hash_if_ok`: 此方法使用`re`模块提供的正则表达式匹配操作来检查作为参数接收的`password`是否满足许多定性要求。代码要求密码长度超过八个字符，最大为32个字符。密码必须包含至少一个大写字母、一个小写字母、一个数字和一个符号。代码通过多次调用`re.search`方法来检查接收到的密码是否满足每个要求。如果任何要求未满足，代码将返回一个包含错误消息和`False`的元组。否则，代码将调用导入为`password_context`的`passlib.apps.custom_app_context`实例的`encrypt`方法，并将接收到的`password`作为参数。`encrypt`方法根据平台选择一个合理的强加密方案，默认设置轮数选择，并将加密后的密码保存在`hash_password`属性中。最后，代码返回一个包含空字符串和`True`的元组，表示密码满足了定性要求并且已被加密。'
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By default, the `passlib` library will use the SHA-512 scheme for 64-bit platforms
    and SHA-256 for 32-bit platforms. In addition, the minimum number of rounds will
    be set to 535,000\. We will use the default configuration values for this example.
    However, you must take into account that these values might require too much processing
    time for each request that has to validate the password. You should definitely
    select the most appropriate algorithm and number of rounds based on your security
    requirements.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`passlib`库将为64位平台使用SHA-512方案，为32位平台使用SHA-256方案。此外，最小轮数将设置为535,000。我们将使用此示例的默认配置值。然而，你必须考虑到这些值可能需要太多的处理时间来验证每个请求的密码。你应该根据你的安全要求选择最合适的算法和轮数。
- en: '`verify_password`: This method calls the `verify` method for the `passlib.apps.custom_app_context`
    instance imported as `password_context`, with the received `password` and the
    stored hashed password for the user, `self.hashed_password`, as the arguments.
    The `verify` method hashes the received password and returns `True` only if the
    hashed received password matches the stored hashed password. We never restore
    the saved password to its original state. We just compare hashed values.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verify_password`: 此方法调用导入为`password_context`的`passlib.apps.custom_app_context`实例的`verify`方法，将接收到的`password`和存储的用户哈希密码`self.hashed_password`作为参数。`verify`方法对接收到的密码进行哈希处理，只有当接收到的哈希密码与存储的哈希密码匹配时才返回`True`。我们永远不会恢复保存的密码到其原始状态。我们只是比较哈希值。'
- en: The model declares a constructor, that is, the `__init__` method. This constructor
    receives the user name in the `name` argument and saves it in an attribute with
    the same name.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模型声明了一个构造函数，即`__init__`方法。这个构造函数接收`name`参数中的用户名并将其保存为具有相同名称的属性。
- en: Creating a schemas to validate, serialize, and deserialize users
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于验证、序列化和反序列化用户的模式
- en: 'Now, we will create the Flask-Marshmallow schema that we will use to validate,
    serialize and deserialize the previously declared `User` model. Open the `api/models.py`
    file and add the following code after the existing lines. The code file for the
    sample is included in the `restful_python_chapter_07_02` folder:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建Flask-Marshmallow模式，我们将使用它来验证、序列化和反序列化之前声明的`User`模型。打开`api/models.py`文件，在现有行之后添加以下代码。示例的代码文件包含在`restful_python_chapter_07_02`文件夹中：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The code declares the `UserSchema` schema, specifically a subclass of the `ma.Schema`
    class. Remember that the previous code we wrote for the `api/models.py` file created
    a `flask_marshmallow.Mashmallow` instance named `ma`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了`UserSchema`模式，具体是`ma.Schema`类的子类。记住，我们之前为`api/models.py`文件编写的代码创建了一个名为`ma`的`flask_marshmallow.Mashmallow`实例。
- en: We declare the attributes that represent fields as instances of the appropriate
    class declared in the `marshmallow.fields` module. The `UserSchema` class declares
    the `name` attribute as an instance of `fields.String`. The `required` argument
    is set to `True` to specify that the field cannot be an empty string. The `validate`
    argument is set to `validate.Length(3)` to specify that the field must have a
    minimum length of 3 characters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将表示字段的属性声明为`marshmallow.fields`模块中声明的适当类的实例。`UserSchema`类将`name`属性声明为`fields.String`的实例。`required`参数设置为`True`，以指定该字段不能为空字符串。`validate`参数设置为`validate.Length(3)`，以指定该字段必须至少有3个字符长。
- en: The validation for the password isn't included in the schema. We will use the
    `check_password_strength_and_hash_if_ok` method defined in the `User` class to
    validate the password.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 密码验证未包含在模式中。我们将使用在`User`类中定义的`check_password_strength_and_hash_if_ok`方法来验证密码。
- en: Adding authentication to resources
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为资源添加身份验证
- en: 'We will configure the `Flask-HTTPAuth` extension to work with our `User` model
    to verify passwords and set the authenticated user associated with a request.
    We will declare a custom function that this extension will use as a callback to
    verify a password. We will create a new base class for our resources that will
    require authentication. Open the `api/views.py` file and add the following code
    after the last line that uses the `import` statement and before the lines that
    declares the `Blueprint` instance . The code file for the sample is included in
    the `restful_python_chapter_07_02` folder:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置`Flask-HTTPAuth`扩展与我们的`User`模型一起工作，以验证密码并设置与请求关联的已验证用户。我们将声明一个自定义函数，该扩展将使用该函数作为回调来验证密码。我们将为需要身份验证的资源创建一个新的基类。打开`api/views.py`文件，在最后一个使用`import`语句的行之后和声明`Blueprint`实例的行之前添加以下代码。示例的代码文件包含在`restful_python_chapter_07_02`文件夹中：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, we create an instance of the `flask_httpauth.HTTPBasicAuth` class named
    `auth`. Then, we declare the `verify_user_password` function that receives a name
    and a password as arguments. The function uses the `@auth.verify_password` decorator
    to make this function become the callback that `Flask-HTTPAuth` will use to verify
    the password for a specific user. The function retrieves the user whose name matches
    the `name` specified in the argument and saves its reference in the `user` variable.
    If a user is found, the code checks the results of the `user.verify_password`
    method with the received password as an argument.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`auth`的`flask_httpauth.HTTPBasicAuth`类的实例。然后，我们声明了一个接收名称和密码作为参数的`verify_user_password`函数。该函数使用`@auth.verify_password`装饰器使该函数成为`Flask-HTTPAuth`将用于验证特定用户密码的回调函数。该函数检索与参数中指定的`name`匹配的用户，并将它的引用保存到`user`变量中。如果找到用户，代码将检查`user.verify_password`方法的结果与接收到的密码作为参数。
- en: If either a user isn't found or the call to `user.verify_password` returns `False`,
    the function returns `False` and the authentication will fail. If the call to
    `user.verify_password` returns `True`, the function stores the authenticated `User`
    instance in the user attribute for the `flask.g` object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到用户或`user.verify_password`的调用返回`False`，则该函数返回`False`，身份验证将失败。如果`user.verify_password`的调用返回`True`，则该函数将已验证的`User`实例存储在`flask.g`对象的`user`属性中。
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `flask.g` object is a proxy that allows us to store on this whatever we
    want to share for one request only. The `user` attribute we added to the `flask.g`
    object will be only valid for the active request and it will return different
    values for each different request. This way, it is possible to use `flask.g.user`
    in another function or method called during a request to access details about
    the authenticated user for the request.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask.g` 对象是一个代理，它允许我们在这个对象上存储我们只想在单个请求中共享的任何内容。我们添加到 `flask.g` 对象中的 `user`
    属性将只对活动请求有效，并且它将为每个不同的请求返回不同的值。这样，就可以在请求期间调用的另一个函数或方法中使用 `flask.g.user` 来访问有关已验证用户的详细信息。'
- en: Finally, we declared the `AuthRequiredResource` class as a subclass of `flask_restful.Resource`.
    We just specified `auth.login_required` as one of the members of the list that
    we assign to the `method_decorators` property inherited from the base class. This
    way, all the methods declared in a resource that uses the new `AuthRequiredResource`
    class as its superclass will have the `auth.login_required` decorator applied
    to them, and therefore, any method that is called to the resource will require
    authentication.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `AuthRequiredResource` 类声明为 `flask_restful.Resource` 的子类。我们只需将 `auth.login_required`
    指定为从基类继承的 `method_decorators` 属性所分配的列表中的一个成员。这样，使用新的 `AuthRequiredResource` 类作为其超类的资源中声明的所有方法都将应用
    `auth.login_required` 装饰器，因此，调用资源的任何方法都需要进行身份验证。
- en: Now, we will replace the base class for the existing resource classes to make
    them inherit from `AuthRequiredResource` instead of `Resource`. We want any of
    the requests that retrieve or modify categories and messages to be authenticated.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将替换现有资源类的基类，使它们从 `AuthRequiredResource` 继承而不是从 `Resource` 继承。我们希望任何检索或修改类别和消息的请求都需要进行身份验证。
- en: 'The following lines show the declarations for the four resource classes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了四个资源类的声明：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open the `api/views.py` file and replace `Resource` by `AuthRequiredResource`
    in the previously shown four lines that declare the resource classes. The following
    lines show the new code for each resource class declaration:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `api/views.py` 文件，将之前显示的四个声明资源类的行中的 `Resource` 替换为 `AuthRequiredResource`。以下行显示了每个资源类声明的新的代码：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Creating resource classes to handle users
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建资源类来处理用户
- en: We just want to be able to create users and use them to authenticate requests.
    Thus, we will just focus on creating resource classes with just a few methods.
    We won't create a complete user management system.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想能够创建用户并使用他们来验证请求。因此，我们只需关注创建只有少数方法的资源类。我们不会创建一个完整的用户管理系统。
- en: 'We will create the resource classes that represent the user and the collection
    of users. First, we will create a `UserResource` class that we will use to represent
    a user resource. Open the `api/views.py` file and add the following lines after
    the line that creates the `Api` instance. The code file for the sample is included
    in the `restful_python_chapter_07_02` folder:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建表示用户和用户集合的资源类。首先，我们将创建一个 `UserResource` 类，我们将使用它来表示用户资源。打开 `api/views.py`
    文件，在创建 `Api` 实例的行之后添加以下行。示例的代码文件包含在 `restful_python_chapter_07_02` 文件夹中：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `UserResource` class is a subclass of the previously coded `AuthRequiredResource`
    and declares a `get` methods that will be called when the `HTTP` method with the
    same name arrives as a request on the represented resource. The method receives
    the id of the user that has to be retrieved in the `id` argument. The code calls
    the `User.query.get_or_404` method to return an HTTP `404 Not Found` status in
    case there is no user with the requested id in the underlying database. In case
    the user exists, the code calls the `user_schema.dump` method with the retrieved
    user as an argument to use the `UserSchema` instance to serialize the `User` instance
    whose `id` matches the specified `id`. The `dump` method takes the `User` instance
    and applies the field filtering and output formatting specified in the `UserSchema`
    class. The field filtering specifies that we don't want the hashed password to
    be serialized. The code returns the `data` attribute of the result returned by
    the `dump` method, that is, the serialized message in JSON format as the body,
    with the default HTTP `200 OK` status code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserResource` 类是之前编写的 `AuthRequiredResource` 类的子类，并声明了一个 `get` 方法，当具有相同名称的
    `HTTP` 方法作为对表示的资源请求到达时，将调用此方法。该方法接收一个 `id` 参数，其中包含要检索的用户 id。代码调用 `User.query.get_or_404`
    方法，如果底层数据库中没有具有请求 id 的用户，则返回 HTTP `404 Not Found` 状态。如果用户存在，代码将调用 `user_schema.dump`
    方法，并将检索到的用户作为参数传递，以使用 `UserSchema` 实例序列化与指定 `id` 匹配的 `User` 实例。`dump` 方法接收 `User`
    实例，并应用在 `UserSchema` 类中指定的字段过滤和输出格式。字段过滤指定我们不想序列化散列密码。代码返回 `dump` 方法返回结果的 `data`
    属性，即作为主体的 JSON 格式序列化消息，带有默认的 HTTP `200 OK` 状态码。'
- en: 'Now, we will create a `UserListResource` class that we will use to represent
    the collection of users. Open the `api/views.py` file and add the following lines
    after the code that creates the `UserResource` class. The code file for the sample
    is included in the `restful_python_chapter_07_02` folder:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 `UserListResource` 类，我们将使用它来表示用户集合。打开 `api/views.py` 文件，并在创建 `UserResource`
    类的代码之后添加以下行。示例代码文件包含在 `restful_python_chapter_07_02` 文件夹中：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `UserListResource` class is a subclass of `flask_restful.Resource` because
    we don''t want all the methods to require authentication. We want to be able to
    create a new user without being authenticated, and therefore, we apply the `@auth.login_required`
    decorator only for the `get` method. The `post` method doesn''t require authentication.
    The class declares the following two methods that will be called when the `HTTP`
    method with the same name arrives as a request on the represented resource:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserListResource` 类是 `flask_restful.Resource` 的子类，因为我们不希望所有方法都需要身份验证。我们希望能够在未经身份验证的情况下创建新用户，因此，我们只为
    `get` 方法应用 `@auth.login_required` 装饰器。`post` 方法不需要身份验证。该类声明了以下两个方法，当具有相同名称的 `HTTP`
    方法作为对表示的资源请求到达时，将调用这些方法：'
- en: '`get`: This method returns a list with all the `User` instances saved in the
    database. First, the code calls the `User.query.all` method to retrieve all the
    `User` instances persisted in the database. Then, the code calls the `user_schema.dump`
    method with the retrieved messages and the `many` argument set to `True` to serialize
    the iterable collection of objects. The `dump` method will take each `User` instance
    retrieved from the database and apply the field filtering and output formatting
    specified the `CategorySchema` class. The code returns the `data` attribute of
    the result returned by the dump method, that is, the serialized messages in JSON
    format as the body, with the default HTTP `200 OK` status code.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`：此方法返回一个包含数据库中保存的所有 `User` 实例的列表。首先，代码调用 `User.query.all` 方法检索数据库中持久化的所有
    `User` 实例。然后，代码调用 `user_schema.dump` 方法，并将检索到的消息和 `many` 参数设置为 `True` 以序列化可迭代的对象集合。`dump`
    方法将应用从数据库检索到的每个 `User` 实例，并应用在 `CategorySchema` 类中指定的字段过滤和输出格式。代码返回 `dump` 方法返回结果的
    `data` 属性，即作为主体的 JSON 格式序列化消息，带有默认的 HTTP `200 OK` 状态码。'
- en: '`post`: This method retrieves the key-value pairs received in the JSON body,
    creates a new `User` instance and persists it in the database. First, the code
    calls the `request.get_json` method to retrieve the key-value pairs received as
    arguments with the request. Then, the code calls the `user_schema.validate` method
    to validate the new user built with the retrieved key-value pairs. In this case,
    the call to this method will just validate the `name` field for the user. In case
    there were validation errors, the code returns the validation errors and an HTTP
    `400 Bad Request` status. If the validation is successful, the code checks whether
    an user with the same name already exists in the database or not to return an
    appropriate error for the field that must be unique. If the user name is unique,
    the code creates a new user with the specified `name` and calls its `check_password_strength_and_hash_if_ok`
    method. If the provided password fulfils all the quality requirements, the code
    persists the user with its hashed password in the database. Finally, the code
    returns the serialized saved user in JSON format as the body, with the HTTP `201
    Created` status code:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`：此方法检索JSON主体中接收到的键值对，创建一个新的`User`实例并将其持久化到数据库中。首先，代码调用`request.get_json`方法来检索作为请求参数接收到的键值对。然后，代码调用`user_schema.validate`方法来验证使用检索到的键值对构建的新用户。在这种情况下，对这个方法的调用将仅验证用户的`name`字段。如果有验证错误，代码将返回验证错误和HTTP
    `400 Bad Request`状态。如果验证成功，代码将检查数据库中是否已存在具有相同名称的用户，以返回适当的错误，该字段必须是唯一的。如果用户名是唯一的，代码将创建一个新的用户，并调用其`check_password_strength_and_hash_if_ok`方法。如果提供的密码满足所有质量要求，代码将使用其散列密码在数据库中持久化用户。最后，代码以JSON格式返回序列化的已保存用户作为主体，并带有HTTP
    `201 Created`状态码：'
- en: The following table shows the method of our previously created classes related
    to usres that we want to be executed for each combination of `HTTP` verb and scope.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了与我们之前创建的与用户相关的类相关的方法，我们希望在每个`HTTP`动词和作用域的组合中执行。
- en: '| **HTTP verb** | **Scope** | **Class and method** | **Requires authentication**
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **作用域** | **类和方法** | **需要认证** |'
- en: '| `GET` | Collection of users | UserListResource.get | Yes |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 用户集合 | UserListResource.get | 是 |'
- en: '| `GET` | User | UserResource.get | Yes |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 用户 | UserResource.get | 是 |'
- en: '| `POST` | Collection of users | UserListResource.post | No |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 用户集合 | UserListResource.post | 否 |'
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines configure the resource routing for the user related resources to the api.
    Open the `api/views.py` file and add the following lines at the end of the code.
    The code file for the sample is included in the `restful_python_chapter_07_02`
    folder:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须进行必要的资源路由配置，通过定义URL规则来调用适当的方法，并通过传递所有必要的参数。以下行配置了与API相关的用户相关资源的资源路由。打开`api/views.py`文件，并在代码末尾添加以下行。示例代码文件包含在`restful_python_chapter_07_02`文件夹中：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Each call to the `api.add_resource` method routes a URL to one of the previously
    coded user related resources. When there is a request to the API and the URL matches
    one of the URLs specified in the `api.add_resource` method, Flask will call the
    method that matches the `HTTP` verb in the request for the specified class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`api.add_resource`方法都会将一个URL路由到之前编写的用户相关资源之一。当有API请求，并且URL与`api.add_resource`方法中指定的URL之一匹配时，Flask将调用与请求中指定的类匹配的`HTTP`动词的方法。
- en: Running migrations to generate the user table
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在运行迁移以生成用户表
- en: Now, we will run many scripts to run migrations and generate the necessary table
    in the PostgreSQL database. Make sure you run the scripts in the terminal or the
    Command Prompt window in which you have activated the virtual environment and
    that you are located in the `api` folder.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行多个脚本来运行迁移并生成PostgreSQL数据库中必要的表。确保你在激活了虚拟环境并位于`api`文件夹的终端或命令提示符窗口中运行这些脚本。
- en: 'Run the first script that populates the migration script with the detected
    changes in the models. In this case, it is the second time we populate the migration
    script, and therefore, the migration script will generate the new table that will
    persist our new `User` model: `model`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第一个脚本，将模型中检测到的更改填充到迁移脚本中。在这种情况下，这是我们第二次填充迁移脚本，因此迁移脚本将生成新的表，以持久化我们的新`User`模型：`model`：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The following lines show the sample output generated after running the previous
    script. Your output will be different according to the base folder in which you
    have created the virtual environment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一条脚本后生成的示例输出。您的输出将根据您创建虚拟环境的基准文件夹而有所不同。
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output indicates that the `api/migrations/versions/c8c45e615f6d_.py` file
    includes the code to create the `user` tables. The following lines show the code
    for this file that was automatically generated based on the models. Notice that
    the file name will be different in your configuration. The code file for the sample
    is included in the `restful_python_chapter_06_01` folder:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 输出指示 `api/migrations/versions/c8c45e615f6d_.py` 文件包含了创建 `user` 表的代码。以下行显示了基于模型自动生成的此文件的代码。请注意，在您的配置中文件名可能会有所不同。示例的代码文件包含在
    `restful_python_chapter_06_01` 文件夹中：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The code defines two functions: `upgrade` and `downgrade`. The `upgrade` function
    runs the necessary code to create the `user` table by making calls to `alembic.op.create_table`.
    The `downgrade` function runs the necessary code to go back to the previous version.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了两个函数：`upgrade` 和 `downgrade`。`upgrade` 函数通过调用 `alembic.op.create_table`
    来执行必要的代码以创建 `user` 表。`downgrade` 函数运行必要的代码以回到上一个版本。
- en: 'Run the second script to upgrade the database:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第二个脚本以升级数据库：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following lines show the sample output generated after running the previous
    script:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一条脚本后生成的示例输出：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The previous script called the `upgrade` function defined in the automatically
    generated `api/migrations/versions/c8c45e615f6d_.py` script. Don't forget that
    the file name will be different in your configuration.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条脚本调用了自动生成的 `api/migrations/versions/c8c45e615f6d_.py` 脚本中定义的 `upgrade` 函数。别忘了，在您的配置中文件名可能会有所不同。
- en: 'After we run the previous scripts, we can use the PostgreSQL command line or
    any other application that allows us to easily verify the contents of the PostreSQL
    database to check the new table that the migration generated. Run the following
    command to list the generated tables. In case the database name you are using
    is not named `messages`, make sure you use the appropriate database name:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行上一条脚本后，我们可以使用 PostgreSQL 命令行或任何允许我们轻松验证 PostgreSQL 数据库内容的其他应用程序来检查迁移生成的新的表。运行以下命令以列出生成的表。如果您使用的数据库名称不是
    `messages`，请确保您使用适当的数据库名称：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The following lines show the output with all the generated table names. The
    migrations upgrade generate a new table named `user`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了包含所有生成表名的输出。迁移升级生成了一个名为 `user` 的新表。
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: SQLAlchemy generated the user table with its primary key, its unique constraint
    on the name field and the password field based on the information included in
    our `User` model.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 根据我们 `User` 模型中包含的信息生成了用户表，其中包含主键、对名称字段和密码字段的唯一约束。
- en: 'The following command will allow you to check the contents of the user table
    after we compose and send HTTP requests to the RESTful API and create new users.
    The commands assume that you are running PostgreSQL on the same computer in which
    you are running the command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在我们向 RESTful API 发送 HTTP 请求并创建新用户后，允许您检查用户表的内容。这些命令假设您正在同一台计算机上运行 PostgreSQL
    和命令：
- en: '[PRE54]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we can run the `api/run.py` script that launches Flask''s development.
    Execute the following command in the `api` folder:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `api/run.py` 脚本以启动 Flask 的开发。在 `api` 文件夹中执行以下命令：
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After we execute the previous command, the development server will start listening
    at port `5000`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上一条命令后，开发服务器将在端口 `5000` 上开始监听。
- en: Composing requests with the necessary authentication
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写带有必要身份验证的请求
- en: 'Now, we will compose and send an HTTP request to retrieve the first page of
    the messages without authentication credentials:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个不包含身份验证凭据的 HTTP 请求以检索消息的第一页：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will receive a `401 Unauthorized` status code in the response header. The
    following lines show a sample response:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在响应头中收到 `401 未授权` 状态码。以下行显示了示例响应：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If we want to retrieve messages, that is, to make a `GET` request to `/api/messages/`,
    we need to provide authentication credentials using HTTP authentication. However,
    before we can do this, it is necessary to create a new user. We will use the new
    user to test our new resource classes related to users and our changes in the
    permissions policies.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想检索消息，即对 `/api/messages/` 进行 `GET` 请求，我们需要使用 HTTP 身份验证提供身份验证凭据。然而，在我们能够这样做之前，有必要创建一个新的用户。我们将使用这个新用户来测试我们与用户相关的新的资源类以及我们在权限策略中的更改。
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Tip
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Of course, the creation of a user and the execution of the methods that require
    authentication should only be possible under HTTPS. This way, the username and
    the password would be encrypted.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，创建用户和执行需要身份验证的方法只能在 HTTPS 下进行。这样，用户名和密码就会被加密。
- en: The previous command will compose and send a `POST` HTTP request with the specified
    JSON key-value pairs. The requests specify `/api/user/`, and therefore, it will
    match the `'/users/'` URL route for the `UserList` resource and run the `UserList.post`
    method that doesn't require authentication. The method doesn't receive arguments
    because the URL route doesn't include any parameters. As the HTTP verb for the
    request is `POST`, Flask calls the `post` method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送一个带有指定 JSON 键值对的 `POST` HTTP 请求。请求指定 `/api/user/`，因此它将匹配 `'/users/'`
    URL 路由的 `UserList` 资源，并运行不需要身份验证的 `UserList.post` 方法。由于 URL 路由不包含任何参数，该方法不接收任何参数。由于请求的
    HTTP 动词是 `POST`，Flask 调用 `post` 方法。
- en: 'The previously specified password only includes lowercase letters, and therefore,
    it doesn''t fulfil all the qualitative requirements we have specified for the
    passwords in the `User.check_password_strength_and_hash_if_ok` method. Thus, We
    will receive a `400 Bad Request` status code in the response header and the error
    message indicating the requirement that the password didn''t fulfil in the JSON
    body. The following lines show a sample response:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 之前指定的密码仅包含小写字母，因此它不符合我们在 `User.check_password_strength_and_hash_if_ok` 方法中指定的密码的所有质量要求。因此，我们将在响应头中收到
    `400 Bad Request` 状态码，并在 JSON 主体中显示未满足要求的错误消息。以下行显示了示例响应：
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following command will create a user with a valid password:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将创建一个具有有效密码的用户：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If the new `User` instance is successfully persisted in the database, the call
    will return an `HTTP 201 Created` status code and the recently persisted `User`
    serialized to JSON in the response body. The following lines show an example response
    for the HTTP requests, with the new `User` object in the JSON responses. Note
    that the response includes the URL, `url`, for the created user and doesn't include
    any information related to the password.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新的 `User` 实例成功持久化到数据库中，调用将返回 `HTTP 201 Created` 状态码，并在响应体中将最近持久化的 `User` 序列化为
    JSON。以下行显示了 HTTP 请求的示例响应，其中包含 JSON 响应中的新 `User` 对象。请注意，响应包括创建用户的 URL，即 `url`，并且不包含任何与密码相关的信息。
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can run the previously explained command to check the contents of the `user`
    table that the migrations created in the PostgreSQL database. We will notice that
    the `hashed_password` field contents are hashed for the new row in the `user`
    table. The following screenshot shows the contents for the new row of the `user`
    table in a PostgreSQL database after running the HTTP request:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行之前解释的命令来检查在 PostgreSQL 数据库中由迁移创建的 `user` 表的内容。我们会注意到 `hashed_password`
    字段的内容为新行在 `user` 表中进行了哈希处理。以下截图显示了在运行 HTTP 请求后 PostgreSQL 数据库中 `user` 表新行的内容：
- en: '![Composing requests with the necessary authentication](img/image_07_002.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![使用必要的身份验证编写请求](img/image_07_002.jpg)'
- en: 'If we want to retrieve the first page of messages, that is, to make a `GET`
    request to `/api/messages/`, we need to provide authentication credentials using
    HTTP authentication. Now, we will compose and send an HTTP request to retrieve
    the first page of messages with authentication credentials, that is, with the
    user name and the password we have recently created:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想检索第一页的消息，即对 `/api/messages/` 进行 `GET` 请求，我们需要使用 HTTP 身份验证提供身份验证凭据。现在，我们将编写并发送一个带有身份验证凭据的
    HTTP 请求来检索第一页的消息，即使用我们最近创建的用户名和密码：
- en: '[PRE65]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE66]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The user will be successfully authenticated and we will be able to process the
    request to retrieve the first page of messages. With all the changes we have made
    to our API, unauthenticated requests can only create a new user.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将成功认证，我们将能够处理请求以检索消息的第一页。在我们对API所做的所有更改中，未认证的请求只能创建新用户。
- en: Test your knowledge
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'The `flask.g` object is:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flask.g`对象是：'
- en: A proxy that provides access to the current request.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个提供对当前请求访问的代理。
- en: An instance of the `flask_httpauth.HTTPBasicAuth` class.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flask_httpauth.HTTPBasicAuth`类的一个实例。'
- en: A proxy that allows us to store on this whatever we want to share for one request
    only.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个代理，允许我们仅存储一次请求中想要共享的内容。
- en: 'The `passlib` package provides:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`passlib`包提供：'
- en: A password hashing framework that supports more than 30 schemes.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个支持超过30种方案的密码哈希框架。
- en: An authentication framework that automatically adds models for users and permissios
    to a Flask application.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个认证框架，它自动将用户和权限模型添加到Flask应用程序中。
- en: A lightweight web framework that replaces Flask.
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个轻量级Web框架，用于替代Flask。
- en: 'The `auth.verify_password` decorator applied to a function:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用到函数上的`auth.verify_password`装饰器：
- en: Makes this function become the callback that `Flask-HTTPAuth` will use to hash
    the password for a specific user.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使此函数成为`Flask-HTTPAuth`将用于为特定用户哈希密码的回调函数。
- en: Makes this function become the callback that `SQLAlchmey` will use to verify
    the password for a specific user.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使此函数成为`SQLAlchemy`将用于验证特定用户密码的回调函数。
- en: Makes this function become the callback that `Flask-HTTPAuth` will use to verify
    the password for a specific user.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使此函数成为`Flask-HTTPAuth`将用于验证特定用户密码的回调函数。
- en: 'When you assign a list that includes `auth.login_required` to the `method_decorators`
    property of any subclass of `flask_restful.Resource`, considering that auth is
    an instance of the `flask_httpauth.HTTPBasicAuth()`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将包含`auth.login_required`的列表分配给`flask_restful.Resource`任何子类的`method_decorators`属性时，考虑到auth是`flask_httpauth.HTTPBasicAuth()`的一个实例：
- en: All the methods declared in the resource will have the `auth.login_required`
    decorator applied to them.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源中声明的所有方法都将应用`auth.login_required`装饰器。
- en: The `post` method declared in the resource will have `auth.login_required` decorator
    applied to it.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源中声明的`post`方法将应用`auth.login_required`装饰器。
- en: 'Any of the following methods declared in the resource will have `auth.login_required`
    decorator applied to them: `delete`, `patch`, `post` and `put`.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源中声明的以下任何方法都将应用`auth.login_required`装饰器：`delete`、`patch`、`post`和`put`。
- en: Which of the following lines retrieves the integer value for the `'page'` argument
    from the request object, considering that the code would be running within a method
    defined in a subclass of `flask_restful.Resource` class?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码行中，考虑到代码将在`flask_restful.Resource`类子类的定义方法中运行，以下哪一行从请求对象中检索`'page'`参数的整数值？
- en: '`page_number = request.get_argument(''page'', 1, type=int)`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`page_number = request.get_argument(''page'', 1, type=int)`'
- en: '`page_number = request.args.get(''page'', 1, type=int)`'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`page_number = request.args.get(''page'', 1, type=int)`'
- en: '`page_number = request.arguments.get(''page'', 1, type=int)`'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`page_number = request.arguments.get(''page'', 1, type=int)`'
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we improved the RESTful API in many ways. We added user friendly
    error messages when resources aren't unique. We tested how to update single or
    multiple fields with the `PATCH` method and we created our own generic pagination
    class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从许多方面改进了RESTful API。当资源不唯一时，我们添加了用户友好的错误消息。我们测试了如何使用`PATCH`方法更新单个或多个字段，并创建了我们自己的通用分页类。
- en: Then, we started working with authentication and permissions. We added a user
    model and we updated the database. We made many changes in the different pieces
    of code to achieve a specific security goal and we took advantage of Flask-HTTPAuth
    and passlib to use HTTP authentication in our API.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始处理认证和权限。我们添加了用户模型并更新了数据库。我们在不同的代码片段中进行了许多更改，以实现特定的安全目标，并利用Flask-HTTPAuth和passlib在我们的API中使用HTTP认证。
- en: Now that we have built an improved a complex API that uses pagination and authentication,
    we will use additional abstractions included in the framework and we will code,
    execute, and improve unit test, which is what we are going to discuss in the next
    chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个改进的复杂API，该API使用分页和认证，我们将使用框架中包含的额外抽象，我们将编写、执行和改进单元测试，这是我们将在下一章讨论的内容。
