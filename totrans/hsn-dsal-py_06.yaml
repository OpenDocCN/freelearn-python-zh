- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Trees
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: A **tree** is a hierarchical form of data structure. Data structures such as
    lists, queues, and stacks are linear in that the items are stored in a sequential
    way. However, a tree is a non-linear data structure, as there is a **parent-child
    relationship** between the items. The top of the tree’s data structure is known
    as a **root node**. This is the ancestor of all other nodes in the tree.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**树**是一种层次化的数据结构。如列表、队列和栈这样的数据结构是线性的，因为项目以顺序方式存储。然而，树是一种非线性数据结构，因为项目之间存在**父子关系**。树的顶端称为**根节点**。这是树中所有其他节点的祖先。'
- en: Tree data structures are very important, owing to their use in various applications,
    such as parsing expressions, efficient searches, and priority queues. Certain
    document types, such as `XML` and `HTML`, can also be represented in a tree.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 树数据结构非常重要，因为它们在各种应用中使用，例如解析表达式、高效搜索和优先队列。某些文档类型，如`XML`和`HTML`，也可以以树的形式表示。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Terms and definitions of trees
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的术语和定义
- en: Binary trees and binary search trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树和二叉搜索树
- en: Tree traversal
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树遍历
- en: Binary search trees
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: Terminology
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: Let’s consider some of the terminology associated with tree data structures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些与树数据结构相关的术语。
- en: To understand trees, we need to first understand the basic concepts related
    to them. A tree is a data structure in which data is organized in a hierarchical
    form.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解树，我们首先需要了解与它们相关的概念。树是一种数据结构，其中数据以层次化的形式组织。
- en: '*Figure 6.1* contains a typical tree consisting of character nodes lettered
    `A` through to `M`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1*包含一个典型的树，由字母`A`到`M`的字符节点组成：'
- en: '![](img/B17217_06_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_01.png)'
- en: 'Figure 6.1: Example tree data structure'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：示例树数据结构
- en: 'Here is a list of terms associated with a tree:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个与树相关的术语列表：
- en: '**Node**: Each circled letter in the preceding diagram represents a node. A
    node is any data structure that stores data.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**: 前图中每个圆圈中的字母代表一个节点。节点是任何存储数据的结构。'
- en: '**Root node**: The root node is the first node from which all other nodes in
    the tree descend from. In other words, a root node is a node that does not have
    a parent node. In every tree, there is always one unique root node. The root node
    is node `A` in the above example tree.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根节点**: 根节点是从其派生出树中所有其他节点的第一个节点。换句话说，根节点是一个没有父节点的节点。在每一棵树中，总有一个唯一的根节点。在上述示例树中，根节点是节点`A`。'
- en: '**Subtree**: A subtree is a tree whose nodes descend from some other tree.
    For example, nodes `F`, `K`, and `L` form a subtree of the original tree.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子树**: 子树是节点从某个其他树派生出来的树。例如，节点`F`、`K`和`L`构成了原始树的子树。'
- en: '**Degree**: The total number of children of a given node is called the **degree
    of the node**. A tree consisting of only one node has a degree of 0\. The degree
    of node `A` in the preceding diagram is 2, the degree of node `B` is 3, the degree
    of node `C` is 3, and, the degree of node `G` is 1.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度**: 指给定节点的所有子节点的总数，称为该**节点的度**。仅由一个节点组成的树具有度0。前图中节点`A`的度是2，节点`B`的度是3，节点`C`的度是3，节点`G`的度是1。'
- en: '**Leaf node**: The leaf node does not have any children and is the terminal
    node of the given tree. The degree of the leaf node is always 0\. In the preceding
    diagram, the nodes `J`, `E`, `K`, `L`, `H`, `M`, and `I` are all leaf nodes.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶节点**: 叶节点没有任何子节点，是给定树的终端节点。叶节点的度始终为0。在前图中，节点`J`、`E`、`K`、`L`、`H`、`M`和`I`都是叶节点。'
- en: '**Edge**: The connection among any given two nodes in the tree is called an
    edge. The total number of edges in a given tree will be a maximum of one less
    than the total nodes in the tree. An example edge is shown in *Figure 6.1*.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**: 树中任意两个节点之间的连接称为边。给定树中的边总数将最多比树中的节点总数少一个。*图6.1*中显示了一个示例边。'
- en: '**Parent**: A node that has a subtree is the parent node of that subtree. For
    example, node `B` is the parent of nodes `D`, `E`, and `F`, and node `F` is the
    parent of nodes `K` and `L`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点**: 拥有子树的节点是该子树的父节点。例如，节点`B`是节点`D`、`E`和`F`的父节点，节点`F`是节点`K`和`L`的父节点。'
- en: '**Child**: This is a node that is descendant from a parent node. For example,
    nodes `B` and `C` are children of parent node `A`, while nodes `H`, `G`, and `I`
    are the children of parent node `C`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点**: 这是从父节点派生出来的节点。例如，节点`B`和`C`是父节点`A`的子节点，而节点`H`、`G`和`I`是父节点`C`的子节点。'
- en: '**Sibling**: All nodes with the same parent node are siblings. For example,
    node `B` is the sibling of node `C`, and, similarly, nodes `D`, `E`, and `F` are
    also siblings.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兄弟节点**：所有具有相同父节点的节点都是兄弟节点。例如，节点`B`是节点`C`的兄弟节点，同样地，节点`D`、`E`和`F`也是兄弟节点。'
- en: '**Level**: The root node of the tree is considered to be at level 0\. The children
    of the root node are considered to be at level 1, and the children of the nodes
    at level 1 are considered to be at level 2, and so on. For example, in *Figure
    6.1*, root node `A` is at level 0, nodes `B` and `C` are at level 1, and nodes
    `D`, `E`, `F`, `H`, `G`, and `I` are at level 2.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次**：树根节点被认为是处于层次0。根节点的孩子被认为是处于层次1，层次1的节点的孩子被认为是处于层次2，依此类推。例如，在*图6.1*中，根节点`A`处于层次0，节点`B`和`C`处于层次1，节点`D`、`E`、`F`、`H`、`G`和`I`处于层次2。'
- en: '**Height of a tree**: The total number of nodes in the longest path of the
    tree is the height of the tree. For example, in *Figure 6.1*, the height of the
    tree is 4, as the longest paths, `A`-`B`-`D`-`J`, `A`-`C`-`G`-`M`, and `A`-`B`-`F`-`K`,
    all have a total number of four nodes each.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树的高度**：树中最长路径上的节点总数是树的高度。例如，在*图6.1*中，树的高度是4，因为最长路径`A`-`B`-`D`-`J`、`A`-`C`-`G`-`M`和`A`-`B`-`F`-`K`都各有四个节点。'
- en: '**Depth**: The depth of a node is the number of edges from the root of the
    tree to that node. In the preceding tree example, the depth of node `H` is 2.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：一个节点的深度是从树根到该节点的边的数量。在先前的树示例中，节点`H`的深度是2。'
- en: In linear data structures, data items are stored in sequential order, whereas
    non-linear data structures store data items in a non-linear order, where a data
    item can be connected to more than one other data item. All of the data items
    in linear data structures, such as *arrays*, *lists*, *stacks*, and *queues*,
    can be traversed in one pass, whereas this is not possible in the case of non-linear
    data structures such as trees; they store the data differently from other linear
    data structures.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性数据结构中，数据项以顺序存储，而非线性数据结构则以非线性顺序存储数据项，其中数据项可以连接到多个其他数据项。线性数据结构中的所有数据项，如*数组*、*列表*、*栈*和*队列*，都可以在一次遍历中访问，而在非线性数据结构（如树）的情况下则不可能；它们以与其他线性数据结构不同的方式存储数据。
- en: In a tree data structure, the nodes are arranged in a parent-child relationship.
    There should not be any cycle among the nodes in trees. The tree structure has
    nodes to form a hierarchy, and a tree that has no nodes is called an **empty tree**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在树数据结构中，节点以父子关系排列。在树中不应有任何节点循环。树结构通过节点形成层次结构，没有节点的树被称为**空树**。
- en: First, we’ll discuss one of the most important kind of trees, that is, the **binary
    tree**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论最重要的一种树，那就是**二叉树**。
- en: Binary trees
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树
- en: A binary tree is a collection of nodes, where the nodes in the tree can have
    zero, one, or two child nodes. A simple binary tree has a maximum of two children,
    that is, the left child and the right child.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是由节点组成的集合，其中树中的节点可以有零个、一个或两个子节点。一个简单的二叉树最多有两个孩子，即左孩子和右孩子。
- en: 'For example, in the binary tree shown in *Figure 6.2*, there is a root node
    that has two children (a left child, a right child):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在*图6.2*中展示的二叉树中，有一个根节点，它有两个孩子（一个左孩子，一个右孩子）：
- en: '![](img/B17217_06_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_02.png)'
- en: 'Figure 6.2: Example of a binary tree'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：二叉树的例子
- en: 'The nodes in the binary tree are organized in the form of the left subtree
    and right subtree. For example, a tree of five nodes is shown in *Figure 6.3*
    that has a root node, `R`, and two subtrees, i.e. left subtree, `T1`, and right
    subtree, `T2`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树中的节点以左子树和右子树的形式组织。例如，*图6.3*中展示了具有五个节点的树，它有一个根节点`R`和两个子树，即左子树`T1`和右子树`T2`：
- en: '![](img/B17217_06_03.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_03.png)'
- en: 'Figure 6.3: An example binary tree of five nodes'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：五个节点的二叉树例子
- en: A regular binary tree has no other rules as to how elements are arranged in
    the tree. It should only satisfy the condition that each node should have a maximum
    of two children.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正规的二叉树没有其他关于元素在树中如何排列的规则。它只需满足每个节点最多有两个孩子的条件。
- en: 'A tree is called a **full binary** tree if all the nodes of a binary tree have
    either zero or two children, and if there is no node that has one child. An example
    of a full binary tree is shown in *Figure 6.4*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个二叉树的所有节点要么有零个孩子，要么有两个孩子，并且没有节点只有一个孩子，那么这个树被称为**满二叉树**。*图6.4*展示了满二叉树的例子：
- en: '![](img/B17217_06_04.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_04.png)'
- en: 'Figure 6.4: An example of a full binary tree'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：满二叉树的示例
- en: 'A perfect binary tree has all the nodes in the binary tree filled, and it doesn’t
    have space vacant for any new nodes; if we add new nodes, they can only be added
    by increasing the tree’s height. A sample perfect binary tree is shown in *Figure
    6.5*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 完美二叉树填充了二叉树中的所有节点，且没有为新节点留出空位；如果我们添加新节点，它们只能通过增加树的高度来添加。一个示例完美二叉树在*图6.5*中展示：
- en: '![](img/B17217_06_05.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_05.png)'
- en: 'Figure 6.5: An example of a perfect binary tree'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：完美二叉树的示例
- en: 'A **complete binary tree** is filled with all possible nodes except with a
    possible exception at the lowest level of the tree. All nodes are also filled
    on the left side. A complete binary tree is shown in *Figure 6.6*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**完全二叉树**填充了除了树的最底层可能有一个例外之外的所有可能的节点。所有节点也都在左侧填充。完全二叉树在*图6.6*中展示：'
- en: '![](img/B17217_06_06.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_06.png)'
- en: 'Figure 6.6: An example of a complete binary tree'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：完全二叉树的示例
- en: 'A binary tree can be balanced or unbalanced. In a balanced binary tree, the
    difference in height of the left and right subtrees for every node in the tree
    is no more than 1\. A balanced tree is shown in *Figure 6.7*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树可以是平衡的或不平衡的。在平衡二叉树中，树中每个节点的左右子树高度之差不超过1。平衡树在*图6.7*中展示：
- en: '![](img/B17217_06_07.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_07.png)'
- en: 'Figure 6.7: An example of a balanced tree'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：平衡树的示例
- en: 'An unbalanced binary tree is a binary tree that has a difference of more than
    1 between the right subtree and left subtree. An example of an unbalanced tree
    is shown in *Figure 6.8*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不平衡的二叉树是指左右子树之间的差异超过1的二叉树。不平衡树的示例在*图6.8*中展示：
- en: '![](img/B17217_06_08.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_08.png)'
- en: 'Figure 6.8: An example of an unbalanced tree'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：不平衡树的示例
- en: Next, we’ll discuss the details of the implementation of a simple binary tree.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论简单二叉树实现的细节。
- en: Implementation of tree nodes
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树节点的实现
- en: As we have already discussed in previous chapters, a node consists of data items
    and references to other nodes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中已经讨论过的，一个节点由数据项和其他节点的引用组成。
- en: 'In a binary tree node, each node will contain data items and two references
    that will point to their left and right children, respectively. Let’s look at
    the following code for building a binary tree `Node` class in Python:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉树节点中，每个节点将包含数据项和两个引用，分别指向它们的左子树和右子树。让我们看看以下Python中构建二叉树`Node`类的代码：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To better understand the working of this class, let’s first create a binary
    tree of four nodes—`n1`, `n2`, `n3`, and `n4`—as shown in *Figure 6.9*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个类的工作原理，我们首先创建一个包含四个节点——`n1`、`n2`、`n3`和`n4`——的二叉树，如图*图6.9*所示：
- en: '![](img/B17217_06_09.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_09.png)'
- en: 'Figure 6.9: An example binary tree of four nodes'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：四个节点的示例二叉树
- en: 'For this, we firstly create four nodes—`n1`, `n2`, `n3`, and `n4`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先创建四个节点——`n1`、`n2`、`n3`和`n4`：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have created a very simple tree structure of four nodes. After creating
    a tree, one of the most important operations that is to be applied to trees is
    **traversal**. Next, we’ll understand how we can traverse the tree.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个由四个节点组成的非常简单的树结构。创建树后，要对树应用的最重要操作之一是**遍历**。接下来，我们将了解如何遍历树。
- en: Tree traversal
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树遍历
- en: 'The method to visit all the nodes in a tree is called **tree traversal**. In
    the case of a linear data structure, data element traversal is straightforward
    since all the items are stored in a sequential manner, so each data item is visited
    only once. However, in the case of non-linear data structures, such as trees and
    graphs, traversal algorithms are important. To understand traversing, let’s traverse
    the left subtree of the binary tree we created in the previous section. For this,
    we start from the root node, print out the node, and move down the tree to the
    next left node. We keep doing this until we have reached the end of the left subtree,
    like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 访问树中所有节点的方法称为**树遍历**。在线性数据结构的情况下，数据元素遍历很简单，因为所有项目都是按顺序存储的，所以每个数据项只被访问一次。然而，在非线性数据结构的情况下，如树和图，遍历算法很重要。为了理解遍历，让我们遍历上一节创建的二叉树的左子树。为此，我们从根节点开始，打印出节点，然后沿着树向下移动到下一个左节点。我们一直这样做，直到我们到达左子树的末尾，如下所示：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of traversing the preceding code block is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块遍历的输出如下：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are multiple ways to process and traverse the tree that depend upon the
    sequence of visiting the root node, left subtree, or right subtree. Mainly, there
    are two kinds of approaches, firstly, one in which we start from a node and traverse
    every available child node, and then continue to traverse to the next sibling.
    There are three possible variations of this method, namely, **in-order**, **pre-order**,
    and **post-order**. Another approach to traverse the tree is to start from the
    root node and then visit all the nodes on each level, and process the nodes level
    by level. We will discuss each approach in the following sections.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据访问根节点、左子树或右子树的顺序，有多种处理和遍历树的方法。主要有两种方法，首先，从节点开始，遍历所有可用的子节点，然后继续遍历到下一个兄弟节点。此方法有三种可能的变体，即**中序**、**先序**和**后序**。另一种遍历树的方法是从根节点开始，然后访问每一层的所有节点，并逐层处理节点。我们将在以下各节中讨论每种方法。
- en: In-order traversal
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中序遍历
- en: 'In-order tree traversal works as follows: we start traversing the left subtree
    recursively, and once the left subtree is visited, the root node is visited, and
    then finally the right subtree is visited recursively. It has the following three
    steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 中序树遍历的工作原理如下：我们开始递归遍历左子树，一旦左子树被访问，就访问根节点，然后最终递归访问右子树。它有以下三个步骤：
- en: We start traversing the left subtree and call an ordering function recursively
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们开始遍历左子树，并递归调用排序函数
- en: Next, we visit the root node
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们访问根节点
- en: Finally, we traverse the right subtree and call an ordering function recursively
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们遍历右子树，并递归调用排序函数
- en: So, in a nutshell, for in-order tree traversal, we visit the nodes in the tree
    in the order of left subtree, root, then the right subtree.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，对于中序树遍历，我们按照左子树、根、然后右子树的顺序访问树中的节点。
- en: 'Let’s consider an example tree shown in *Figure 6.10* to understand in-order
    tree traversal:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个在*图6.10*中显示的示例树，以理解中序树遍历：
- en: '![](img/B17217_06_10.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_10.png)'
- en: 'Figure 6.10: An example binary tree for in-order tree traversal'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：用于中序树遍历的示例二叉树
- en: 'In the binary tree shown in *Figure 6.10*, the working of the in-order traversal
    is as follows: first, we recursively visit the left subtree of the root node `A`.
    The left subtree of node `A` has node `B` as the root node, so we again go to
    the left subtree of root node `B`, that is, node `D`. We recursively go to the
    left subtree of root node `D` so that we get the left child of root node `D`.
    We visit the left child, `G`, then visit the root node, `D`, and then visit the
    right child, `H`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图6.10*所示的二叉树中，中序遍历的工作原理如下：首先，我们递归访问根节点`A`的左子树。节点`A`的左子树的根节点是`B`，因此我们再次访问根节点`B`的左子树，即节点`D`。我们递归访问根节点`D`的左子树，以便我们得到根节点`D`的左子节点。我们访问左子节点`G`，然后访问根节点`D`，然后访问右子节点`H`。
- en: Next, we visit node `B` and then visit node `E`. In this manner, we have visited
    the left subtree of root node `A`. Next, we visit root node `A`. After that, we
    visit the right subtree of root node `A`. Here, we first go to the left subtree
    of root node `C`, which is null, so next, we visit node `C`, and then we visit
    the right child of node `C`, that is, node `F`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们访问节点`B`，然后访问节点`E`。这样，我们就访问了根节点`A`的左子树。接下来，我们访问根节点`A`。之后，我们访问根节点`A`的右子树。在这里，我们首先访问根节点`C`的左子树，它是空的，所以接下来我们访问节点`C`，然后我们访问节点`C`的右子节点，即节点`F`。
- en: Therefore, the in-order traversal for this example tree is `G`-`D`-`H`-`B`-`E`-`A`-`C`-`F`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此示例树的中序遍历为`G`-`D`-`H`-`B`-`E`-`A`-`C`-`F`。
- en: 'The Python implementation of a recursive function to return an in-order listing
    of nodes in a tree is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个递归函数的Python实现，用于返回树中节点的中序列表：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Firstly, we check if the current node is null or empty. If it is not empty,
    we traverse the tree. We visit the node by printing the visited node. In this
    case, we first recursively call the `inorder` function with `current.left_child`,
    then we visit the root node, and finally, we recursively call the `inorder` function
    with `current.right_child`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查当前节点是否为空或为空。如果不为空，我们遍历树。我们通过打印访问的节点来访问节点。在这种情况下，我们首先递归调用`inorder`函数，传入`current.left_child`，然后访问根节点，最后递归调用`inorder`函数，传入`current.right_child`。
- en: 'Finally, when we apply the above in-order traversal algorithm on the above
    sample tree of four nodes. With `n1` as the root node, we get the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们将上述中序遍历算法应用于上述四个节点的示例树时。以`n1`作为根节点，我们得到以下输出：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we will discuss pre-order traversal.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论前序遍历。
- en: Pre-order traversal
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前序遍历
- en: 'Pre-order tree traversal traverses the tree in the order of the root node,
    the left subtree, and then the right subtree. It works as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前序树遍历按根节点、左子树然后右子树的顺序遍历树。它的工作原理如下：
- en: We start traversing with the root node
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从根节点开始遍历
- en: Next, we traverse the left subtree and call an ordering function with the left
    subtree recursively
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历左子树并递归调用带有左子树的排序函数
- en: Next, we visit the right subtree and call an ordering function with the right
    subtree recursively
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们访问右子树并递归调用带有右子树的排序函数
- en: 'Consider the example tree shown in *Figure 6.11* to understand pre-order traversal:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例树，如图*图6.11*所示，以理解前序遍历：
- en: '![](img/B17217_06_11.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_11.png)'
- en: 'Figure 6.11: An example tree to understand pre-order traversal'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：一个示例树，用于理解前序遍历
- en: 'The pre-order traversal for the example binary tree shown in *Figure 6.11*
    works as follows: first, we visit root node `A`. Next, we go to the left subtree
    of root node `A`. The left subtree of node `A` has node `B` as the root, so we
    visit this root node, and then go to the left subtree of root node `B`, node `D`.
    We visit node `D` and then the left subtree of root node `D`, and then we visit
    the left child, `G`, which is the subtree of root node `D`. Since there is no
    child of node `G`, we visit the right subtree. We visit the right child of the
    subtree of root node `D`, node `H`. Next, we visit the right child of the subtree
    of root node `B`, node `E`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图6.11*所示的示例二叉树的前序遍历如下：首先，我们访问根节点`A`。接下来，我们访问根节点`A`的左子树。节点`A`的左子树以节点`B`为根，因此我们访问这个根节点，然后访问根节点`B`的左子树，节点`D`。我们访问节点`D`及其根节点`D`的左子树，然后访问左子节点，`G`，它是根节点`D`的子树。由于节点`G`没有子节点，我们访问右子树。我们访问根节点`D`的子树的右子节点，节点`H`。接下来，我们访问根节点`B`的子树的右子节点，节点`E`。
- en: In this manner, we have visited root node `A` and the left subtree of root node
    `A`. Next, we visit the right subtree of root node `A`. Here, we visit root node
    `C`, and then we go to the left subtree of root node `C`, which is null, so we
    visit the right child of node `C`, node `F`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们已经访问了根节点`A`和根节点`A`的左子树。接下来，我们访问根节点`A`的右子树。在这里，我们访问根节点`C`，然后访问根节点`C`的左子树，它是空的，因此我们访问节点`C`的右子节点，节点`F`。
- en: The pre-order traversal for this example tree would be `A`-`B`-`D`-`G`-`H`-`E`-`C`-`F`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例树的前序遍历将是`A`-`B`-`D`-`G`-`H`-`E`-`C`-`F`。
- en: 'The recursive function for the pre-order tree traversal is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前序树遍历的递归函数如下：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we check if the current node is null or empty. If it is empty, it means
    the tree is an empty tree, and if the current node is not empty, then we traverse
    the tree using the pre-order algorithm. The pre-order traversal algorithm traverses
    the tree in the order of root, left subtree, and right subtree recursively, as
    shown in the above code. Finally, when we apply the above pre-order traversal
    algorithm on the above sample tree of four nodes with `n1` node as the root node,
    we get the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查当前节点是否为空或为空。如果它是空的，这意味着树是空树；如果当前节点不为空，那么我们使用前序算法遍历树。前序遍历算法按根、左子树和右子树的顺序递归遍历树，如上述代码所示。最后，当我们将上述前序遍历算法应用于上述以`n1`节点作为根节点的四个节点的示例树时，我们得到以下输出：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we will discuss post-order traversal.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论后序遍历。
- en: Post-order traversal
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后序遍历
- en: 'Post-order tree traversal works as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 后序树遍历的工作原理如下：
- en: We start traversing the left subtree and call an ordering function recursively
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从遍历左子树并递归调用排序函数开始
- en: Next, we traverse the right subtree and call an ordering function recursively
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历右子树并递归调用排序函数
- en: Finally, we visit the root node
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们访问根节点
- en: So, in a nutshell, for post-order tree traversal, we visit the nodes in the
    tree in the order of the left subtree, the right subtree, and finally the root
    node.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，对于后序树遍历，我们按照左子树、右子树和最后根节点的顺序访问树中的节点。
- en: 'Consider the following example tree shown in *Figure 6.12* to understand post-order
    tree traversal:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例树，如图*图6.12*所示，以理解后序树遍历：
- en: '![](img/B17217_06_12.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_12.png)'
- en: 'Figure 6.12: An example tree to understand pre-order traversal'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：一个示例树，用于理解前序遍历
- en: In the preceding figure, *Figure 6.12*, we first visit the left subtree of root
    node `A` recursively. We get to the last left subtree, that is, root node `D`,
    and then we visit the node to the left of it, which is node `G`. We visit the
    right child, `H`, after this, and then we visit root node `D`. Following the same
    rule, we next visit the right child of node `B`, node `E`. Then, we visit node
    `B`. Following on from this, we traverse the right subtree of node `A`. Here,
    we first reach the last right subtree and visit node `F`, and then we visit node
    `C`. Finally, we visit root node `A`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，*图6.12*，我们首先递归地访问根节点 `A` 的左子树。我们到达最后一个左子树，即根节点 `D`，然后我们访问它的左侧节点，即节点 `G`。在这之后，我们访问右子节点
    `H`，然后访问根节点 `D`。遵循相同的规则，我们接下来访问节点 `B` 的右子节点，即节点 `E`。然后，我们访问节点 `B`。在此基础上，我们遍历节点
    `A` 的右子树。在这里，我们首先到达最后一个右子树并访问节点 `F`，然后访问节点 `C`。最后，我们访问根节点 `A`。
- en: The post-order traversal for this example tree would be `G`-`H`-`D`-`E`-`B`-`F`-`C`-`A`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例树的后序遍历顺序将是 `G`-`H`-`D`-`E`-`B`-`F`-`C`-`A`。
- en: 'The implementation of the post-order method for tree traversal is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 树遍历的后序方法实现如下：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we check if the current node is null or empty. If it is not empty, we
    traverse the tree using the post-order algorithm as discussed, and finally, when
    we apply the above post-order traversal algorithm on the above sample tree of
    four nodes with `n1` as the root node. We get the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查当前节点是否为空或为空。如果不为空，我们使用前面讨论的后序算法遍历树，并在最后，当我们对上面具有 `n1` 作为根节点的四个节点的示例树应用上述后序遍历算法时，我们得到以下输出：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we will discuss level-order traversal.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论按层遍历。
- en: Level-order traversal
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按层遍历
- en: In this traversal method, we start by visiting the root of the tree before visiting
    every node on the next level of the tree. Then, we move on to the next level in
    the tree, and so on. This kind of tree traversal is how breadth-first traversal
    in a graph works, as it broadens the tree by traversing all the nodes in a level
    before going deeper into the tree.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种遍历方法中，我们首先访问树的根节点，然后再访问下一层的每个节点。然后，我们继续访问树的下一层，依此类推。这种树遍历方式是图中的广度优先遍历，因为它通过在深入树之前遍历同一层的所有节点来扩展树。
- en: 'Let’s consider the following example tree and traverse it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例树并遍历它：
- en: '![](img/B17217_06_13.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_13.png)'
- en: 'Figure 6.13: An example tree to understand level-order traversal'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：一个示例树，用于理解按层遍历
- en: 'In *Figure 6.13*, we start by visiting the root node at level 0, which is the
    node with a value of `4`. We visit this node by printing out its value. Next,
    we move to level 1 and visit all the nodes at this level, which are the nodes
    with the values `2` and `8`. Finally, we move to the next level in the tree, that
    is, level 3, and we visit all the nodes at this level, which are `1`, `3`, `5`,
    and `10`. Thus, the level-order tree traversal for this tree is as follows: `4`,
    `2`, `8`, `1`, `3`, `5`, and `10`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图6.13* 中，我们首先访问第0层的根节点，其值为 `4` 的节点。我们通过打印其值来访问此节点。接下来，我们移动到第1层并访问该层的所有节点，这些节点的值分别为
    `2` 和 `8`。最后，我们移动到树的下一层，即第3层，并访问该层的所有节点，这些节点的值分别为 `1`、`3`、`5` 和 `10`。因此，该树的按层遍历顺序如下：`4`、`2`、`8`、`1`、`3`、`5`
    和 `10`。
- en: This level-order tree traversal is implemented using a queue data structure.
    We start by visiting the root node, and we push it into a queue. The node at the
    front of the queue is accessed (dequeued), which can then be either printed or
    stored for later use. After adding the root node, the left child node is added
    to the queue, followed by the right node. Thus, when traversing at any given level
    of the tree, all the data items of that level are firstly inserted in the queue
    from left to right. After that, all the nodes are visited from the queue one by
    one. This process is repeated for all the levels of the tree.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种按层遍历树的方法是使用队列数据结构实现的。我们首先访问根节点，并将其推入队列。队列前面的节点被访问（出队），然后可以打印或存储以供以后使用。在添加根节点后，将左子节点添加到队列中，然后是右节点。因此，在遍历树的任何给定层时，该层的所有数据项首先从左到右插入队列。之后，逐个访问队列中的所有节点。这个过程重复应用于树的每一层。
- en: The traversal of the preceeding tree using this algorithm will enqueue root
    node `4`, dequeue it, and visit the node. Next, nodes `2` and `8` are enqueued,
    as they are the left and right nodes at the next level. Node `2` is dequeued so
    that it can be visited. Next, its left and right nodes, nodes `1` and `3`, are
    enqueued. At this point, the node at the front of the queue is node `8`. We dequeue
    and visit node `8`, after which we enqueue its left and right nodes. This process
    continues until the queue is empty.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此算法遍历前面的树将队列根节点 `4` 入队，出队并访问该节点。接下来，节点 `2` 和 `8` 入队，因为它们是下一级的左节点和右节点。节点 `2`
    出队以便访问。接下来，它的左右节点，节点 `1` 和 `3`，入队。此时，队列前面的节点是节点 `8`。我们出队并访问节点 `8`，之后将其左右节点入队。这个过程一直持续到队列为空。
- en: 'The Python implementation of breadth-first traversal is as follows. We enqueue
    the root node and keep a list of the visited nodes in the `list_of_nodes` list.
    The `dequeue` class is used to maintain a queue:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python 实现广度优先遍历如下。我们将根节点入队，并在 `list_of_nodes` 列表中保持已访问节点的列表。使用 `dequeue` 类来维护队列：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the number of elements in `traversal_queue` is greater than zero, the body
    of the loop is executed. The node at the front of the queue is popped off and
    added to the `list_of_nodes` list. The first `if` statement will `enqueue` the
    left child node if the `node` provided with a left node exists. The second `if`
    statement does the same for the right child node. Further, the `list_of_nodes`
    list is returned in the last statement.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `traversal_queue` 中的元素数量大于零，则执行循环体。队列前面的节点被弹出并添加到 `list_of_nodes` 列表中。第一个
    `if` 语句将左子节点入队，如果提供的 `node` 存在左节点。第二个 `if` 语句对右子节点做同样的操作。进一步地，在最后一条语句中返回 `list_of_nodes`
    列表。
- en: 'The output of the above code is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have discussed different tree traversal algorithms; we can use any of these
    algorithms depending upon the application. In-order traversal is very useful when
    we need sorted contents from a tree. This also applies if we need items in descending
    order, which we can do by reversing the order, such as right subtree, root, and
    then left subtree. This is known as reverse in-order traversal. And, if we need
    to inspect the root before any leaves, we use pre-order traversal. Likewise, if
    we need to inspect the leaf nodes before the root nodes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了不同的树遍历算法；我们可以根据应用选择使用这些算法中的任何一个。当我们需要从树中获取排序内容时，中序遍历非常有用。这也适用于我们需要降序排列的项目，我们可以通过反转顺序来实现，例如右子树、根节点，然后是左子树。这被称为逆中序遍历。而且，如果我们需要在任何叶子节点之前检查根节点，我们使用前序遍历。同样地，如果我们需要在根节点之前检查叶子节点。
- en: 'The following are some important applications of binary trees:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些二叉树的重要应用：
- en: Binary trees as expression trees are used in compilers
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二叉树作为表达式树在编译器中使用
- en: It is also used in Huffman coding in data compression
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它也用于数据压缩中的霍夫曼编码
- en: Binary search trees are used for efficient searching, insertion, and deletion
    of a list of items
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二叉搜索树用于高效地搜索、插入和删除项目列表
- en: '**Priority Queue** (**PQ**), which is used for finding and deleting minimum
    or maximum items in a collection of elements in logarithm time in the worst case'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**优先队列**（**PQ**），用于在元素集合中以对数时间复杂度（在最坏情况下）查找和删除最小或最大项'
- en: Next, let us discuss expression trees.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论表达式树。
- en: Expression trees
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式树
- en: An expression tree is a special kind of binary tree that can be used to represent
    arithmetic expressions. An arithmetic expression is represented by a combination
    of operators and operands, where the operators can be unary or binary. Here, the
    operator shows which operation we want to perform, and the operator tells us what
    data items we want to apply those operations to. If the operator is applied to
    one operand, then it is called a unary operator, and if it is applied to two operands,
    it is called a binary operator.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式树是一种特殊的二叉树，可以用来表示算术表达式。算术表达式由运算符和操作数组合而成，其中运算符可以是单目或双目。在这里，运算符显示我们想要执行的操作，而运算符告诉我们想要应用这些操作的数据项。如果运算符应用于一个操作数，则称为单目运算符；如果应用于两个操作数，则称为双目运算符。
- en: An arithmetic expression can also be represented using a binary tree, which
    is also known as an expression tree. The **infix** notation is a commonly used
    notation to express arithmetic expressions where the operators are placed in between
    the operands. It is a commonly used method of representing an arithmetic expression.
    In an expression tree, all the leaf nodes contain operands and non-leaf nodes
    contain the operators. It is also worth noting that an expression tree will have
    one of its subtrees (right or left) empty in the case of a unary operator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 算术表达式也可以使用二叉树来表示，这也被称为表达式树。**中缀**表示法是一种常用的表示算术表达式的记法，其中操作符位于操作数之间。这是一种常用的表示算术表达式的方法。在表达式树中，所有叶节点包含操作数，非叶节点包含操作符。还值得注意的是，在单目操作符的情况下，表达式树将有一个其子树（右或左）为空。
- en: 'The arithmetic expression is shown using three notations: **infix**, **postfix**,
    or **prefix**. The in-order traversal of an expression tree produces the infix
    notation. For example, the expression tree for `3 + 4` would look as shown in
    *Figure 6.14*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 算术表达式可以使用三种表示法来表示：**中缀**、**后缀**或**前缀**。表达式树的中序遍历产生中缀表示法。例如，`3 + 4` 的表达式树如图*6.14*所示：
- en: '![](img/B17217_06_14.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_14.png)'
- en: 'Figure 6.14: An expression tree for the expression 3 + 4'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：表达式 `3 + 4` 的表达式树
- en: 'In this example, the operator is inserted (infixed) between the operands, as
    `3 + 4`. When necessary, parentheses can be used to build a more complex expression.
    For example, for `(4 + 5) * (5 - 3)`, we would get the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，操作符被插入（内嵌）在操作数之间，例如 `3 + 4`。当需要时，可以使用括号来构建更复杂的表达式。例如，对于 `(4 + 5) * (5
    - 3)`，我们会得到以下结果：
- en: '![](img/B17217_06_15.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_15.png)'
- en: 'Figure 6.15: An expression tree for the expression (4 + 5) * (5-3)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：表达式 `(4 + 5) * (5-3)` 的表达式树
- en: 'Prefix notation is commonly referred to as *Polish* notation. In this notation,
    the operator comes before its operands. For example, the arithmetic expression
    to add two numbers, 3 and 4, would be shown as `+ 3 4`. Let’s consider another
    example, `(3 + 4) * 5`. This can also be represented as `* (+ 3 4) 5` in prefix
    notation. The pre-order traversal of an expression tree results in the prefix
    notation of the arithmetic expression. For example, consider the expression tree
    shown in *Figure 6.16*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀表示法通常被称为*波兰*表示法。在这种表示法中，操作符位于其操作数之前。例如，将两个数字3和4相加的算术表达式将表示为 `+ 3 4`。让我们考虑另一个例子，`(3
    + 4) * 5`。这也可以用前缀表示法表示为 `* (+ 3 4) 5`。表达式树的前序遍历产生算术表达式的前缀表示法。例如，考虑*图6.16*中所示的表达式树：
- en: '![](img/B17217_06_16.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_16.png)'
- en: 'Figure 6.16: An example expression tree to understand pre-order traversal'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：用于理解前序遍历的示例表达式树
- en: The pre-order traversal of the expression tree shown in *Figure 6.16* will give
    the expression in prefix notation as `+- 8 3 3`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图6.16*所示的表达式树的前序遍历将给出前缀表示法表达式 `+- 8 3 3`。
- en: Postfix, or **reverse Polish notation** (**RPN**), places the operator after
    its operands, such as `3 4 +`. The post-order traversal of the expression tree
    shown in *Figure 6.17* gives the postfix notation of the arithmetic expression.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 逆波兰表示法，或称为**逆波兰记法**（**RPN**），将操作符放在其操作数之后，例如 `3 4 +`。如*图6.17*所示的表达式树的后续遍历给出了算术表达式的逆波兰表示法。
- en: '![](img/B17217_06_17.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_17.png)'
- en: 'Figure 6.17: An example expression tree to understand post-order traversal'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：用于理解后序遍历的示例表达式树
- en: The postfix notation for the preceding expression tree is `8 3 -3 +`. We have
    now discussed expression trees. It is easy to evaluate an expression tree for
    the given arithmetic expression using the reverse Polish notation since it provides
    faster calculations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式树的逆波兰表示法为 `8 3 -3 +`。我们目前已经讨论了表达式树。由于它提供了更快的计算，使用逆波兰表示法来评估给定算术表达式的表达式树是很容易的。
- en: Parsing a reverse Polish expression
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析逆波兰表达式
- en: To create an expression tree from the postfix notation, a stack is used. In
    this, we process one symbol at a time; if the symbol is an operand, then its references
    are pushed in to the stack, and if the symbol is an operator, then we pop two
    pointers from the stack and form a new subtree, whose root is the operator. The
    first reference popped from the stack is the right child of the subtree, and the
    second reference becomes the left child of the subtree. Further, a reference to
    this new subtree is pushed into the stack. In this manner, all the symbols of
    the postfix notation are processed to create the expression tree.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要从后缀表示法创建表达式树，使用栈。在这里，我们一次处理一个符号；如果符号是操作数，则将其引用推入栈中，如果符号是运算符，则从栈中弹出两个指针并形成一个新子树，其根是运算符。从栈中弹出的第一个引用是子树的右子节点，第二个弹出的引用成为子树的左子节点。进一步，将这个新子树的引用推入栈中。以此类推，处理所有后缀表示法的符号以创建表达式树。
- en: Let’s take an example of `4 5 + 5 3 - *`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`4 5 + 5 3 - *`为例。
- en: 'Firstly, we push symbols `4` and `5` onto the stack, and then we process the
    next symbol `+` as shown in *Figure 6.18*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将符号`4`和`5`推入栈中，然后我们按照*图6.18*所示处理下一个符号`+`：
- en: '![](img/B17217_06_18.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_18.png)'
- en: 'Figure 6.18: Operands 4 and 5 are pushed onto the stack'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：操作数4和5被推入栈中
- en: 'When the new symbol `+` is read, it is made into a root node of a new subtree,
    and then two references are popped from the stack, and the topmost reference is
    added as the right of the root node, and the next popped reference is added as
    the left child of the subtree, as shown in *Figure 6.19*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取到新的符号`+`时，它被制作成新子树的根节点，然后从栈中弹出两个引用，最上面的引用被添加到根节点的右侧，下一个弹出的引用被添加到子树的左侧，如图*图6.19*所示：
- en: '![](img/B17217_06_19.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_19.png)'
- en: 'Figure 6.19: Operator + is processed in creating an expression tree'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19：在创建表达式树时处理运算符+
- en: 'The next symbols are `5` and `3`, and they are pushed into the stack. Next,
    when a new symbol is an operator (`-`), it is created as the root of the new subtree,
    and two top references are popped and added to the right and left child of this
    root respectively, as shown in *Figure 6.20*. Then, the reference to this subtree
    is pushed to the stack:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个符号是`5`和`3`，它们被推入栈中。接下来，当新的符号是一个运算符（`-`）时，它被创建为新的子树的根，然后从栈中弹出两个引用，分别添加到这个根的左右子节点，如图*图6.20*所示。然后，这个子树的引用被推入栈中：
- en: '![](img/B17217_06_20.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_20.png)'
- en: 'Figure 6.20: Operator (-) is processed in creating an expression tree'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：在创建表达式树时处理运算符（-）
- en: 'The next symbol is the operator `*`; as we have done so far, this will be created
    as the root, and then two references will be popped from the stack, as shown in
    *Figure 6.21*. The final tree is then shown in *Figure 6.21*:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个符号是运算符`*`；如我们所做的那样，这将作为根创建，然后从栈中弹出两个引用，如图*图6.21*所示。最终的树在*图6.21*中显示：
- en: '![](img/B17217_06_21.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_21.png)'
- en: 'Figure 6.21: Operator (*) is processed in creating an expression tree'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21：在创建表达式树时处理运算符*
- en: 'To learn how to implement this algorithm in Python, we will look at building
    a tree for an expression written in postfix notation. For this, we need a tree
    node implementation; it can be defined as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在Python中实现此算法，我们将查看后缀表示法编写的表达式树的构建。为此，我们需要一个树节点实现；它可以定义为如下：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the code for the implementation of the stack class that we
    will be using:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要使用的栈类实现的代码：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to build the tree, we are going to enlist the items with the help
    of a stack. Let’s take an example of an arithmetic expression and set up our stack:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建树，我们将借助栈来列出项目。让我们以一个算术表达式为例，并设置我们的栈：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first statement, the `split()` method splits on whitespace by default.
    The `expr` is a list with the values `4`, `5`, `+`, `5`, `3`, `-`, and `*`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个语句中，`split()`方法默认按空白符分割。`expr`是一个包含值`4`、`5`、`+`、`5`、`3`、`-`和`*`的列表。
- en: Each element of the `expr` list is going to be either an operator or an operand.
    If we get an operand, then we embed it in a tree node and push it onto the stack.
    If we get an operator, we embed the operator into a tree node and pop its two
    operands into the node’s right and left children. Here, we have to take care to
    ensure that the first `pop` reference goes into the right child.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr` 列表中的每个元素都将是一个运算符或操作数。如果我们得到一个操作数，那么我们将其嵌入到一个树节点中并将其推入栈中。如果我们得到一个运算符，我们将运算符嵌入到一个树节点中，并将其两个操作数弹出并放入节点的左右子节点中。在这里，我们必须注意确保第一次
    `pop` 引用进入右子节点。'
- en: 'In continuation of the previous code snippet, the below code is a loop to build
    the tree:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码片段的延续中，下面的代码是一个循环来构建树：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that we perform a conversion from `string` to `int` in the case of an
    operand. You could use `float()` instead, if you wish to support floating-point
    operands.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在操作数的情况下，我们执行了从 `string` 到 `int` 的转换。如果你希望支持浮点操作数，可以使用 `float()`。
- en: At the end of this operation, we should have one single element in the stack,
    and that holds the full tree.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在此操作结束时，我们应该在栈中有一个单独的元素，它包含整个树。
- en: 'If we want to evaluate the expression, we can use the following function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要评估表达式，我们可以使用以下函数：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we pass a node to the function. If the node contains
    an operand, then we simply return that value. If we get an operator, then we perform
    the operation that the operator represents on the node’s two children. However,
    since one or more of the children could also contain either operators or operands,
    we call the `calc()` function recursively on the two child nodes (bearing in mind
    that all the children of every node are also nodes).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们向函数传递一个节点。如果节点包含一个操作数，那么我们只需返回该值。如果我们得到一个运算符，那么我们在节点的两个子节点上执行该运算符所表示的操作。然而，由于一个或多个子节点也可能包含运算符或操作数，我们递归地在两个子节点上调用
    `calc()` 函数（记住，每个节点的所有子节点也都是节点）。
- en: 'Now, we just need to pop the root node off the stack and pass it onto the `calc()`
    function. Then, we should have the result of the calculation:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将根节点从栈中弹出并传递给 `calc()` 函数。然后，我们应该得到计算结果：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running this program should yield the result `18`, which is the result of `(4
    + 5) * (5 - 3)`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序应该得到结果 `18`，这是 `(4 + 5) * (5 - 3)` 的结果。
- en: Expression trees are very useful in representing and evaluating complex expressions
    easily. It is also useful to evaluate the postfix, prefix, and infix expression.
    It can be used to find out the associativity of the operators in the given expression.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式树在轻松表示和评估复杂表达式方面非常有用。它也用于评估后缀、前缀和中缀表达式。它可以用来找出给定表达式中运算符的结合性。
- en: In the next section, we will discuss the binary search tree, which is a special
    kind of binary tree.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论二叉搜索树，它是一种特殊的二叉树。
- en: Binary search trees
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: A **binary search tree** (**BST**) is a special kind of binary tree. It is one
    of the most important and commonly used data structures in computer science applications.
    A binary search tree is a tree that is structurally a binary tree, and stores
    data in its nodes very efficiently. It provides very fast search, insertion, and
    deletion operations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**二叉搜索树**（BST）是一种特殊的二叉树。它是计算机科学应用中最重要且最常用的数据结构之一。二叉搜索树是一种结构上为二叉树的树，并且在其节点中非常有效地存储数据。它提供了非常快的搜索、插入和删除操作。'
- en: 'A binary tree is called a binary search tree if the value at any node in the
    tree is greater than the values in all the nodes of its left subtree, and less
    than (or equal to) the values of all the nodes of the right subtree. For example,
    if `K1`, `K2`, and `K3` are key values in a tree of three nodes (as shown in *Figure
    6.22*), then it should satisfy the following conditions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树中任何节点的值都大于其左子树中所有节点的值，并且小于（或等于）其右子树中所有节点的值，则称为二叉搜索树。例如，如果 `K1`、`K2` 和 `K3`
    是三个节点树中的键值（如图 *6.22* 所示），那么它应该满足以下条件：
- en: The key values *K2<=K1*
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键值 *K2<=K1*
- en: The key values *K3>K1*
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键值 *K3>K1*
- en: 'The following figure depicts the above condition of the binary search tree:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图描述了上述二叉搜索树的条件：
- en: '![](img/B17217_06_22.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_22.png)'
- en: 'Figure 6.22: An example of a binary search tree'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22：二叉搜索树的示例
- en: 'Let’s consider another example so that we have a better understanding of binary
    search trees. Consider the binary search tree shown in *Figure 6.23*:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，以便我们更好地理解二叉搜索树。考虑图 *6.23* 中所示的二叉搜索树：
- en: '![](img/B17217_06_23.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_23.png)'
- en: 'Figure 6.23: Binary search tree of six nodes'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23：六个节点的二叉搜索树
- en: In this tree, all the nodes in the left subtree are less than (or equal to)
    the value of the parent node. All the nodes in the right subtree of this node
    are also greater than that of the parent node.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个树中，左子树中的所有节点值都小于（或等于）父节点的值。这个节点的右子树中的所有节点值都大于父节点的值。
- en: To see if the above example tree fulfills the properties of a binary search
    tree, we see that all the nodes in the left subtree of the root node have a value
    less than `5`. Likewise, all the nodes in the right subtree have a value that
    is greater than `5`. This property applies to all the nodes in the tree with no
    exceptions. For example, if we take another node with the value `3`, we can see
    that the values for all the left subtree nodes are less than the value `3` and
    the values for all the right subtree nodes are greater than `3`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看上述示例树是否满足二叉搜索树的性质，我们看到根节点的左子树中所有节点的值都小于`5`。同样，根节点的右子树中所有节点的值都大于`5`。这个性质适用于树中的所有节点，没有任何例外。例如，如果我们取另一个值为`3`的节点，我们可以看到所有左子树节点的值都小于`3`，而所有右子树节点的值都大于`3`。
- en: 'Considering another example of a binary tree. Let’s check to see if it is a
    binary search tree. Despite the fact that the following diagram, *Figure 6.24*,
    looks similar to the previous diagram, it does not qualify as a binary search
    tree, as node `7` is greater than the root node `5`; even though it is located
    in the left subtree of the root node. Node `4` is to the right subtree of its
    parent node `7`, which is also violating a rule of binary search trees. Thus,
    the following figure, *Figure 6.24*, is not a binary search tree:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个二叉树的例子。让我们检查它是否是一个二叉搜索树。尽管以下图，*图6.24*，看起来与之前的图相似，但它不符合二叉搜索树的资格，因为节点`7`的值大于根节点`5`；即使它位于根节点的左子树中。节点`4`位于其父节点`7`的右子树中，这也违反了二叉搜索树的规则。因此，以下图，*图6.24*，不是一个二叉搜索树：
- en: '![](img/B17217_06_24.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_24.png)'
- en: 'Figure 6.24: An example of a binary tree that is not a binary search tree'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：一个不是二叉搜索树的二叉树示例
- en: 'Let’s begin the implementation of a binary search tree in Python. Since we
    need to keep track of the root node of the tree, we start by creating a `Tree`
    class that holds a reference to the root node:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始用Python实现一个二叉搜索树。由于我们需要跟踪树的根节点，我们首先创建一个`Tree`类，它包含对根节点的引用：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s all it takes to maintain the state of a tree. Now, let’s examine the
    main operations used within the binary seach tree.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 维护一棵树的状态只需这些。现在，让我们来检查在二叉搜索树中使用的所有主要操作。
- en: Binary search tree operations
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉搜索树操作
- en: The operations that can be performed on a binary search tree are `insert`, `delete`,
    `finding min`, `finding max`, and `searching`. We discuss them in detail one by
    one in the following sections.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在二叉搜索树上执行的操作有`插入`、`删除`、`查找最小值`、`查找最大值`和`搜索`。我们将在以下各节中逐一详细讨论它们。
- en: Inserting nodes
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入节点
- en: One of the most important operations to implement on a binary search tree is
    to insert data items in the tree. In order to insert a new element into a binary
    search tree, we have to ensure that the properties of the binary search tree are
    not violated after adding the new element.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉搜索树上要实现的最重要操作之一是将数据项插入树中。为了将新元素插入到二叉搜索树中，我们必须确保在添加新元素后，二叉搜索树的性质没有被违反。
- en: 'In order to insert a new element, we start by comparing the value of the new
    node with the root node: if the value is less than the root value, then the new
    element will be inserted into the left subtree; otherwise, it will be inserted
    into the right subtree. In this manner, we go to the end of the tree to insert
    the new element.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了插入一个新元素，我们首先比较新节点的值与根节点的值：如果新元素的值小于根节点的值，则新元素将被插入到左子树中；否则，它将被插入到右子树中。以这种方式，我们走到树的末端来插入新元素。
- en: 'Let’s create a binary search tree by inserting data items `5`, `3`, `7`, and
    `1` in the tree. Consider the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在树中插入数据项`5`、`3`、`7`和`1`来创建一个二叉搜索树。考虑以下情况：
- en: '**Insert 5**: We start with the first data item, `5`. To do this, we will create
    a node with its data attribute set to `5`, since it is the first node.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**插入5**：我们从第一个数据项`5`开始。为此，我们将创建一个节点，其数据属性设置为`5`，因为它是最初的节点。'
- en: '**Insert 3**: Now, we want to add the second node with a value of `3` so that
    the data value of `3` is compared with the existing node value, `5`, of the root
    node. Since the node value `3` is less than `5`, it will be placed in the left
    subtree of node `5`. The binary search tree will look as shown in *Figure 6.25*:![](img/B17217_06_25.png)'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**插入3**：现在，我们想要添加第二个值为`3`的节点，以便将数据值`3`与根节点的现有节点值`5`进行比较。由于节点值`3`小于`5`，它将被放置在节点`5`的左子树中。二叉搜索树将看起来如图*图6.25*所示：![图片](img/B17217_06_25.png)'
- en: 'Figure 6.25: Step 2 of the insertion operation in an example binary search
    tree'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.25：示例二叉搜索树插入操作的第二步
- en: Here, the tree satisfies the binary search tree rule, where all the nodes in
    the left subtree are less than the parent.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，树满足二叉搜索树的规则，即左子树中的所有节点都小于父节点。
- en: '**Insert 7**: To add another node with a value of `7` to the tree, we start
    from the root node with value `5` and make a comparison, as shown in *Figure 6.26*.
    Since `7` is greater than `5`, the node with a value of `7` is placed to the right
    of this root:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**插入7**：要将另一个值为`7`的节点添加到树中，我们从值为`5`的根节点开始进行比较，如图*图6.26*所示。由于`7`大于`5`，值为`7`的节点被放置在这个根的右侧：'
- en: '![](img/B17217_06_26.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_26.png)'
- en: 'Figure 6.26: Step 3 of the insertion operation in an example binary search
    tree'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26：示例二叉搜索树插入操作的第三步
- en: '**Insert 1**: Next, we add another node with the value `1`. Starting from the
    root of the tree, we make a comparison between `1` and `5`, as shown in *Figure
    6.27*:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**插入1**：接下来，我们添加另一个值为`1`的节点。从树的根开始，我们将`1`与`5`进行比较，如图*图6.27*所示：'
- en: '![](img/B17217_06_27.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_27.png)'
- en: 'Figure 6.27: Step 4 of the insertion operation in an example binary search
    tree'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27：示例二叉搜索树插入操作的第四步
- en: 'This comparison shows that `1` is less than `5`, so we go to the left subtree
    of `5`, which has a node with a value of `3`, as shown in *Figure 6.28*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较表明`1`小于`5`，因此我们进入`5`的左子树，该子树有一个值为`3`的节点，如图*图6.28*所示：
- en: '![](img/B17217_06_28.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_28.png)'
- en: 'Figure 6.28: Comparison of node 1 and node 3 in an example binary search tree'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28：示例二叉搜索树中节点1和节点3的比较
- en: 'When we compare `1` against `3`, `1` is less than `3`, so we move a level below
    node `3` and to its left, as shown in *Figure 6.28*. However, there is no node
    there. Therefore, we create a node with a value of `1` and associate it with the
    left pointer of node `3` to obtain the final tree. Here, we have the final binary
    search tree of `4` nodes, as shown in *Figure 6.29*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`1`与`3`进行比较时，`1`小于`3`，因此我们移动到节点`3`的下一级并位于其左侧，如图*图6.28*所示。然而，那里没有节点。因此，我们创建一个值为`1`的节点并将其与节点`3`的左指针关联以获得最终的树。在这里，我们有了包含`4`个节点的最终二叉搜索树，如图*图6.29*所示：
- en: '![](img/B17217_06_29.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_29.png)'
- en: 'Figure 6.29: Final step of the insertion operation in an example binary search
    tree'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.29：示例二叉搜索树插入操作的最终步骤
- en: We can see that this example contains only integers or numbers. So, if we need
    to store string data in a binary search tree, the strings would be compared alphabetically.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个例子只包含整数或数字。因此，如果我们需要在二叉搜索树中存储字符串数据，字符串将按字母顺序进行比较。
- en: If we wanted to store any custom data types inside a binary search tree, we
    would have to make sure that the binary search tree class supports ordering.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在二叉搜索树内部存储任何自定义数据类型，我们必须确保二叉搜索树类支持排序。
- en: 'The Python implementation of the `insert` method to add the nodes in the binary
    search tree is given as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是二叉搜索树中添加节点的方法`insert`的Python实现：
- en: '[PRE20]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the above code, we first declare the `Node` class with the `Tree` class.
    All the operations that can be applied to the tree are defined in the `Tree` class.
    Let’s understand the steps of the `insert` method. We begin with a function declaration:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们首先声明`Node`类，然后是`Tree`类。可以应用于树的所有操作都在`Tree`类中定义。让我们了解`insert`方法的步骤。我们从函数声明开始：
- en: '[PRE21]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we encapsulate the data in a node using the `Node` class. We check whether
    we have a root node or not. If we don’t have a root node in the tree, the new
    node becomes the root node and then root node is returned:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Node`类封装数据。我们检查是否有一个根节点。如果没有树中的根节点，新节点成为根节点，然后返回根节点：
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Further, in order to insert a new element, we have to traverse the tree and
    reach the correct position where we can insert the new element in a way that the
    properties of the binary search tree are not violated. For this, we keep track
    of the current node while traversing the tree as well as its parent. The `current`
    variable is always used to track where a new node will be inserted:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了插入一个新元素，我们必须遍历树并到达可以插入新元素的正确位置，同时不违反二叉搜索树的性质。为此，我们在遍历树的同时跟踪当前节点及其父节点。`current`
    变量始终用于跟踪新节点将被插入的位置：
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we must perform a comparison. If the data held in the new node is less
    than the data held in the current node, then we check whether the current node
    has a left child node. If it doesn’t, this is where we insert the new node. Otherwise,
    we keep traversing:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们必须进行比较。如果新节点中的数据小于当前节点中的数据，那么我们检查当前节点是否有左子节点。如果没有，这就是我们插入新节点的地方。否则，我们继续遍历：
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After this, we need to take care of the greater than (or equal to) case. If
    the current node doesn’t have a right child node, then the new node is inserted
    as the right child node. Otherwise, we move down and continue looking for an insertion
    point:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要注意大于（或等于）的情况。如果当前节点没有右子节点，则新节点作为右子节点插入。否则，我们向下移动并继续寻找插入点：
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, in order to see what we have inserted in the binary search tree, we can
    use any of the existing tree traversal algorithms. Let’s implement the in-order
    traversal, which should be defined in the `Tree` class. The code is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了查看我们在二叉搜索树中插入了什么，我们可以使用任何现有的树遍历算法。让我们实现中序遍历，它应该在 `Tree` 类中定义。代码如下：
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let us take an example to insert a few elements (e.g. elements `5`, `2`,
    `7`, `9`, and `1`) in a binary search tree, as shown in *Figure 6.24*, and then
    we can use the in-order traversal algorithm to see what we have inserted in the
    tree:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们举一个例子，在二叉搜索树中插入几个元素（例如元素 `5`、`2`、`7`、`9` 和 `1`），如图 *图6.24* 所示，然后我们可以使用中序遍历算法来查看我们在树中插入了什么：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the above code is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Insertion of a node in a binary search tree takes `O(h)`, where `h` is the height
    of the tree.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉搜索树中插入一个节点的时间复杂度为 `O(h)`，其中 `h` 是树的高度。
- en: Searching the tree
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索树
- en: 'A binary search tree is a tree data structure in which all the nodes in the
    left subtree of a node have lower key values and the right subtree has greater
    key values. Thus, searching for an element with a given key value is quite easy.
    Let’s consider an example binary search tree that has nodes `1`, `2`, `3`, `4`,
    `8`, `5`, and `10`, as shown in *Figure 6.30*:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树是一种树形数据结构，其中节点的左子树的所有节点都具有比节点本身更低的键值，而右子树具有更高的键值。因此，搜索具有给定键值的元素相当容易。让我们考虑一个具有节点
    `1`、`2`、`3`、`4`、`8`、`5` 和 `10` 的示例二叉搜索树，如图 *图6.30* 所示：
- en: '![](img/B17217_06_30.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_30.png)'
- en: 'Figure 6.30: An example binary search tree with seven nodes'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.30：具有七个节点的示例二叉搜索树
- en: In the preceding tree shown in *Figure 6.30*, if we wish to search for a node
    with a value of `5`, for example, then we start from the root node and compare
    the root with our desired value. As node `5` is a greater value than the root
    node’s value of `4`, we move to the right subtree. In the right subtree, we have
    node `8` as the root node, so we compare node `5` with node `8`. As the node to
    be searched has a smaller value than node `8`, we move it to the left subtree.
    When we move to the left subtree, we compare the left subtree node `5` with the
    required node value of `5`. This is a match, so we return `"item found"`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面显示的 *图6.30* 中的树中，如果我们想搜索一个值为 `5` 的节点，例如，那么我们从根节点开始，将根节点与我们的目标值进行比较。由于节点 `5`
    的值大于根节点的值 `4`，我们移动到右子树。在右子树中，节点 `8` 是根节点，因此我们将节点 `5` 与节点 `8` 进行比较。由于要搜索的节点值小于节点
    `8` 的值，我们将其移动到左子树。当我们移动到左子树时，我们将左子树节点 `5` 与所需的节点值 `5` 进行比较。这是一个匹配，因此我们返回 `"item
    found"`。
- en: 'Here is the implementation of the searching method in a binary search tree,
    which is being defined in the `Tree` class:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是二叉搜索树中搜索方法的实现，该方法正在 `Tree` 类中定义：
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we return the data if it was found, or `None` if the
    data wasn’t found. We start searching from the root node. Next, if the data item
    to be searched for doesn’t exist in the tree, we return `None`. If we find the
    data, it is returned.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果找到了数据，我们返回数据，如果没有找到，则返回 `None`。我们从根节点开始搜索。接下来，如果要搜索的数据项不在树中，我们返回 `None`。如果我们找到了数据，则返回。
- en: If the data that we are searching for is less than that of the current node,
    we go down the tree to the left. Furthermore, in the `else` part of the code,
    we check if the data we are looking for is greater than the data held in the current
    node, which means that we go down the tree to the right.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要搜索的数据小于当前节点的数据，我们就沿着树向下到左边。此外，在代码的`else`部分，我们检查我们要找的数据是否大于当前节点持有的数据，这意味着我们沿着树向下到右边。
- en: 'Finally, the below code can be used to create an example binary search tree
    with some values between 1 and 10\. Then, we search for a data item with the value
    `9`, and also all the numbers in that range. The ones that exist in the tree get
    printed:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码可以用来创建一个包含1到10之间一些值的示例二叉搜索树。然后，我们搜索具有值`9`的数据项，以及该范围内的所有数字。存在于树中的那些数字将被打印出来：
- en: '[PRE30]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of the above code is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the above code, we see the items that were present in the tree have been
    correctly found; the rest of the items could not be found in the range 1 to 10\.
    In the next section, we discuss the deletion of a node in binary search tree.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们看到树中存在的项目已被正确找到；其余的项目在1到10的范围内找不到。在下一节中，我们将讨论二叉搜索树中节点的删除。
- en: Deleting nodes
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除节点
- en: 'Another important operation on a binary search tree is the deletion or removal
    of nodes. There are three possible scenarios that we need to take care of during
    this process. The node that we want to remove might have the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉搜索树上的另一个重要操作是删除或移除节点。在这个过程中，我们需要注意三种可能的情况。我们想要删除的节点可能有以下几种情况：
- en: '**No children**: If there is no leaf node, directly remove the node'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有孩子**：如果没有叶子节点，直接删除该节点'
- en: '**One child**: In this case, we swap the value of that node with its child,
    and then delete the node'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个孩子**：在这种情况下，我们将那个节点的值与其子节点交换，然后删除该节点'
- en: '**Two children**: In this case, we first find the in-order successor or predecessor,
    swap their values, and then delete that node'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两个孩子**：在这种情况下，我们首先找到中序后继或前驱，交换它们的值，然后删除那个节点'
- en: 'The first scenario is the easiest to handle. If the node about to be removed
    has no children, we can simply remove it from its parent. In *Figure 6.31*, suppose
    we want to delete node `A`, which has no children. In this case, we can simply
    delete it from its parent (node `Z`):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是最容易处理的。如果即将被删除的节点没有孩子，我们可以简单地从其父节点中删除它。在*图6.31*中，假设我们想要删除没有孩子的节点`A`。在这种情况下，我们可以简单地从其父节点（节点`Z`）中删除它：
- en: '![](img/B17217_06_31.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_31.png)'
- en: 'Figure 6.31: Deletion operation when deleting a node with no children'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.31：删除没有孩子的节点时的删除操作
- en: 'In the second scenario, when the node we want to remove has one child, the
    parent of that node is made to point to the child of that particular node. Let’s
    take a look at the following diagram, where we want to delete node `6`, which
    has one child, node `5`, as shown in *Figure 6.32*:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，当我们要删除的节点有一个孩子时，那个节点的父节点被设置为指向那个特定节点的子节点。让我们看看以下图表，我们想要删除具有一个孩子节点`5`的节点`6`，如*图6.32*所示：
- en: '![](img/B17217_06_32.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_32.png)'
- en: 'Figure 6.32: Deletion operation when deleting a node with one child'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.32：删除具有一个孩子的节点时的删除操作
- en: In order to delete node `6`, which has node `5` as its only child, we point
    the left pointer of node `9` to node `5`. Here, we need to ensure that the child
    and parent relationship follows the properties of a binary search tree.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除具有节点`5`作为唯一孩子的节点`6`，我们将节点`9`的左指针指向节点`5`。在这里，我们需要确保子节点和父节点关系遵循二叉搜索树的属性。
- en: In the third scenario, when the node we want to delete has two children, in
    order to delete it, we first find a successor node, then move the content of the
    successor node into the node to be deleted. The successor node is the node that
    has the minimum value in the right subtree of the node to be deleted; it will
    be the first element when we apply the in-order traversal on the right subtree
    of the node to be deleted.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三种情况下，当我们要删除的节点有两个孩子时，为了删除它，我们首先找到后继节点，然后将后继节点的内容移动到要删除的节点中。后继节点是要删除节点的右子树中具有最小值的节点；它将是当我们对要删除节点的右子树进行中序遍历时第一个元素。
- en: 'Let’s understand it with the example tree shown in *Figure 6.33*, where we
    want to delete node `9`, which has two children:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过*图6.33*中显示的示例树来理解它，我们想要删除具有两个孩子节点`9`：
- en: '![](img/B17217_06_33.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_33.png)'
- en: 'Figure 6.33: Deletion operation when deleting a node with two children'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.33：删除具有两个孩子的节点时的删除操作
- en: In the example tree shown in *Figure 6.33*, we find the smallest element in
    the right subtree of the node (i.e. the first element in the in-order traversal
    in the right subtree) which is node `12`. After that, we replace the value of
    node `9` with the value `12` and remove node `12`. Node `12` has no children,
    so we apply the rule for removing nodes without children accordingly.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 6.33 所示的示例树中，我们找到节点右子树中的最小元素（即右子树中中序遍历的第一个元素），即节点 `12`。之后，我们将节点 `9` 的值替换为
    `12` 并删除节点 `12`。节点 `12` 没有子节点，因此我们相应地应用删除没有子节点的规则。
- en: 'To implement the above algorithm using Python, we need to write a helper method
    to get the node that we want to delete along with the reference to its parent
    node. We have to write a separate method because we do not have any reference
    to the parent in the `Node` class. This helper method `get_node_with_parent` is
    similar to the `search` method, which finds the node to be deleted, and returns
    that node with its parent node:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Python 实现上述算法，我们需要编写一个辅助方法来获取要删除的节点及其父节点的引用。我们必须编写一个单独的方法，因为我们没有在 `Node`
    类中找到任何父节点的引用。这个辅助方法 `get_node_with_parent` 与 `search` 方法类似，它找到要删除的节点，并返回该节点及其父节点：
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The only difference is that before we update the current variable inside the
    loop, we store its parent with `parent = current`. The method to do the actual
    removal of a node begins with this search:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是在更新循环中的当前变量之前，我们使用 `parent = current` 存储其父节点。删除节点的实际方法从这次搜索开始：
- en: '[PRE33]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We pass the parent and the found nodes to `parent` and `node`, respectively,
    with the `parent`, `node = self.get_node_with_parent(data)` line. It is important
    to know the number of children that the node has that we want to delete, and we
    do so in the `if` statement.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `parent`, `node = self.get_node_with_parent(data)` 行将父节点和找到的节点分别传递给 `parent`
    和 `node`。了解要删除的节点有多少个子节点非常重要，我们在 `if` 语句中这样做。
- en: 'Once we know the number of children a node has that we want to delete, we need
    to handle various conditions in which a node can be deleted. The first part of
    the `if` statement handles the case where the node has no children:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道要删除的节点有多少个子节点，我们需要处理各种可能删除节点的情况。`if` 语句的第一部分处理的是节点没有子节点的情况：
- en: '[PRE34]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In cases where the node to be deleted has only one child, the `elif` part of
    the `if` statement does the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在要删除的节点只有一个子节点的情况下，`if` 语句的 `elif` 部分执行以下操作：
- en: '[PRE35]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`next_node` is used to keep track of that single node, which is the child of
    the node that is to be deleted. We then connect `parent.left_child` or `parent.right_child`
    to `next_node`.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_node` 用于跟踪要删除的节点所对应的单个节点，即要删除的节点的子节点。然后我们将 `parent.left_child` 或 `parent.right_child`
    连接到 `next_node`。'
- en: 'Lastly, we handle the condition where the node we want to delete has two children:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们处理要删除的节点有两个子节点的情况：
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In finding the in-order successor, we move to the right node with `leftmost_node
    = node.right_child`. As long as a left node exists, `leftmost_node.left_child`
    will be `True` and the `while` loop will run. When we get to the leftmost node,
    it will either be a leaf node (meaning that it will have no child node) or have
    a right child.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找中序后继时，我们通过 `leftmost_node = node.right_child` 移动到右节点。只要存在左节点，`leftmost_node.left_child`
    将为 `True`，`while` 循环将继续运行。当我们到达最左节点时，它要么是一个叶子节点（意味着它将没有子节点）或者有一个右子节点。
- en: 'We update the node that’s about to be removed with the value of the in-order
    successor with `node.data = leftmost_node.data`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `node.data = leftmost_node.data` 将即将删除的节点的值更新为中序后继的值：
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding statement allows us to properly attach the parent of the leftmost
    node with any child node. Observe how the right-hand side of the equals sign stays
    unchanged. This is because the in-order successor can only have a right child
    as its only child.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句允许我们正确地将最左节点的父节点与任何子节点连接起来。观察等号右侧保持不变。这是因为中序后继节点只能有一个右子节点作为其唯一的子节点。
- en: 'The following code demonstrates how to use the remove method in the `Tree`
    class:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何在 `Tree` 类中使用 `remove` 方法：
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the above code is:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是：
- en: '[PRE39]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the above code, when we search for item `9`, it is available in the tree,
    and after the remove method, item `9` is not present in the tree. In the worst-case
    scenario, the `remove` operation takes `O(h)`, where `h` is the height of the
    tree.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，当我们搜索项目 `9` 时，它在树中可用，在删除方法之后，项目 `9` 不再存在于树中。在最坏的情况下，`remove` 操作的时间复杂度为
    `O(h)`，其中 `h` 是树的高度。
- en: Finding the minimum and maximum nodes
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找最小和最大节点
- en: The structure of the binary search tree makes searching a node that has a maximum
    or a minimum value very easy. To find a node that has the smallest value in the
    tree, we start traversal from the root of the tree and visit the left node each
    time until we reach the end of the tree. Similarly, we traverse the right subtree
    recursively until we reach the end to find the node with the biggest value in
    the tree.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的结构使得搜索具有最大或最小值的节点非常容易。为了找到树中最小的节点，我们从树的根节点开始遍历，每次都访问左节点，直到我们到达树的末尾。同样，我们递归地遍历右子树，直到我们到达末尾以找到树中最大的节点。
- en: For example, consider *Figure 6.34*, in order to search for the minimum and
    maximum elements.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑*图6.34*，为了搜索最小和最大元素。
- en: '![](img/B17217_06_34.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_34.png)'
- en: 'Figure 6.34: Finding the minimum and maximum nodes in a binary search tree'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.34：在二叉搜索树中查找最小和最大节点
- en: Here, we start by moving down the tree from root node `6` to `3`, and then from
    node `3` to `1` to find the node with the smallest value. Similarly, to find the
    maximum value node from the tree, we go down from the root along the right-hand
    side of the tree, so we go from node `6` to node `8` and then node `8` to node
    `10` to find the node with the largest value.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先从根节点`6`向下移动到`3`，然后从节点`3`到`1`以找到最小值的节点。同样，为了从树中找到最大值节点，我们沿着树的右侧向下移动，所以我们从节点`6`到节点`8`，然后从节点`8`到节点`10`以找到最大值的节点。
- en: 'The Python implementation of the method that returns the minimum value of any
    node is as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 返回任何节点最小值的Python方法实现如下：
- en: '[PRE40]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `while` loop continues to get the left node and visits it until the last
    left node points to `None`. It is a very simple method.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环持续获取左节点并访问它，直到最后一个左节点指向`None`。这是一个非常简单的方法。'
- en: 'Similarly, the following is the code of the method that returns the maximum
    node:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下是为返回最大节点的代码：
- en: '[PRE41]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following code demonstrates how to use the `find_min` and `find_max` methods
    in the `Tree` class:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何在`Tree`类中使用`find_min`和`find_max`方法：
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of the above code is as shown below:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示：
- en: '[PRE43]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The output of the above code, `1` and `9`, are the minimum and maximum values.
    The minimum value in the tree is `1` and the maximum is `9`. The running time
    complexity to find the minimum or maximum value in a binary search tree is `O(h)`,
    where `h` is the height of the tree.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出`1`和`9`分别是最小值和最大值。树中的最小值是`1`，最大值是`9`。在二叉搜索树中查找最小或最大值的运行时间复杂度是`O(h)`，其中`h`是树的高度。
- en: Benefits of a binary search tree
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉搜索树的优点
- en: A binary search tree is, in general, a better choice compared to arrays and
    linked lists when we are mostly interested in accessing the elements frequently
    in any application. A binary search tree is fast for most operations, such as
    searching, insertion, and deletion, whereas arrays provide fast searching, but
    are comparatively slow regarding insertion and deletion operations. In a similar
    fashion, linked lists are efficient in performing insertion and deletion operations,
    but are slower when performing the search operation. The best-case running time
    complexity for searching an element from a binary search tree is `O(log n)`, and
    the worst-case time complexity is `O(n)`, whereas both best-case and worst-case
    time complexity for searching in lists is `O(n)`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当我们主要关注在应用程序中频繁访问元素时，与数组和链表相比，二叉搜索树是一个更好的选择。二叉搜索树在大多数操作中都很快速，如搜索、插入和删除，而数组提供快速的搜索，但在插入和删除操作上相对较慢。同样，链表在执行插入和删除操作时效率较高，但在执行搜索操作时较慢。从二叉搜索树中搜索元素的最好情况运行时间复杂度是`O(log
    n)`，最坏情况时间复杂度是`O(n)`，而列表中搜索的最好和最坏情况时间复杂度都是`O(n)`。
- en: 'The following table provides a comparison of the array, linked list, and binary
    search tree data structures:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了数组、链表和二叉搜索树数据结构的比较：
- en: '| **Properties** | **Array** | **Linked list** | **BST** |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **数组** | **链表** | **BST** |'
- en: '| Data structure | Linear. | Linear. | Non-linear. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 数据结构 | 线性. | 线性. | 非线性. |'
- en: '| Ease of use | Easy to create and use. Average-case complexity for search,
    insert, and delete is `O(n)`. | Insertion and deletion are fast, especially with
    the doubly linked list. | Access of elements, insertion, and deletion is fast
    with the average-case complexity of `O(log n)`. |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 使用便捷性 | 创建和使用简单。搜索、插入和删除的平均情况复杂度是 `O(n)`。 | 插入和删除速度快，尤其是在双链表中。 | 元素访问、插入和删除速度快，平均情况复杂度为
    `O(log n)`。 |'
- en: '| Access complexity | Easy to access elements. Complexity is `O(1)`. | Only
    sequential access is possible, so slow. Average- and worst-case complexity are
    `O(n)`. | Access is fast, but slow when the tree is unbalanced, with a worst-case
    complexity of `O(n)`. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 访问复杂度 | 元素访问简单。复杂度为 `O(1)`。 | 只能进行顺序访问，因此较慢。平均和最坏情况复杂度是 `O(n)`。 | 访问速度快，但树不平衡时较慢，最坏情况复杂度为
    `O(n)`。 |'
- en: '| Search complexity | Average- and worst-case complexity are `O(n)`. | It is
    slow due to sequential searching. Average- and worst-case complexity are `O(n)`.
    | Worst-case complexity for searching is `O(n)`. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 搜索复杂度 | 平均和最坏情况复杂度是 `O(n)`。 | 由于顺序搜索，速度较慢。平均和最坏情况复杂度是 `O(n)`。 | 搜索的最坏情况复杂度是
    `O(n)`。 |'
- en: '| Insertion complexity | Insertion is slow. Average- and worst-case complexity
    are `O(n)`. | Average- and worst-case complexity are `O(1)`. | The worst-case
    complexity for insertion is `O(n)`. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 插入复杂度 | 插入速度较慢。平均和最坏情况复杂度是 `O(n)`。 | 平均和最坏情况复杂度是 `O(1)`。 | 插入的最坏情况复杂度是 `O(n)`。
    |'
- en: '| Deletion complexity | Deletion is slow. Average- and worst-case complexity
    are `O(n)`. | Average- and worst-case complexity are `O(1)`. | The worst-case
    complexity for deletion is `O(n)`. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 删除复杂度 | 删除速度较慢。平均和最坏情况复杂度是 `O(n)`。 | 平均和最坏情况复杂度是 `O(1)`。 | 删除的最坏情况复杂度是 `O(n)`。
    |'
- en: 'Let’s consider an example to understand when the binary search tree is a good
    choice to store the data. Let’s assume that we have the following data nodes—`5`,
    `3`, `7`, `1`, `4`, `6`, and `9`, as shown in *Figure 6.35*. If we use a list
    to store this data, the worst-case scenario will require us to search through
    the entire list of seven elements to find the item. So, it will require six comparisons
    to search for item `9` in this data node, as shown in *Figure 6.35*:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解何时二叉搜索树是存储数据的良好选择。假设我们有以下数据节点—`5`, `3`, `7`, `1`, `4`, `6`, 和 `9`，如图
    *图6.35* 所示。如果我们使用列表来存储这些数据，最坏的情况将需要我们搜索整个包含七个元素的列表来找到项目。因此，在图 *图6.35* 中，搜索数据节点中的项目
    `9` 将需要六次比较：
- en: '![](img/B17217_06_35.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_35.png)'
- en: 'Figure 6.35: An example list of seven elements requires six comparisons if
    stored in a list'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.35：如果存储在列表中，包含七个元素的列表需要六次比较
- en: 'However, if we use a binary search tree to store these values, as shown in
    the following diagram, in the worst-case scenario, we will require two comparisons
    to search for item `9`, as shown in *Figure 6.36*:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用二叉搜索树来存储这些值，如图中所示，在最坏的情况下，我们将需要两次比较来搜索项目 `9`，如图 *图6.36* 所示：
- en: '![](img/B17217_06_36.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_36.png)'
- en: 'Figure 6.36: An example list of seven elements requires three comparisons if
    stored in a binary search tree'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.36：如果存储在二叉搜索树中，包含七个元素的列表需要三次比较
- en: 'However, it is important to note that the efficiency of searching also depends
    on how we built the binary search tree. If the tree hasn’t been constructed properly,
    it can be slow. For example, if we had inserted the elements into the tree in
    the order `1`, `3`, `4`, `5`, `6`, `7`, `9`, as shown in *Figure 6.37*, then the
    tree would not be more efficient than the list:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意搜索效率也取决于我们如何构建二叉搜索树。如果树没有正确构建，它可能会很慢。例如，如果我们按照 `1`, `3`, `4`, `5`,
    `6`, `7`, `9` 的顺序将元素插入到树中，如图 *图6.37* 所示，那么树将不会比列表更有效率：
- en: '![](img/B17217_06_37.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_06_37.png)'
- en: 'Figure 6.37: A binary search tree constructed with elements in the order 1,
    3, 4, 5, 6, 7,9'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.37：使用顺序1, 3, 4, 5, 6, 7, 9构建的二叉搜索树
- en: Depending upon the sequence of the nodes added to the tree, it is possible that
    we may have a binary tree that is unbalanced. Thus, it is important to use a method
    that can make the tree a self-balancing tree, which in turn will improve the `search`
    operation. Therefore, we should note that a binary search tree is a good choice
    if the binary tree is balanced.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 根据添加到树中的节点的顺序，我们可能得到一个不平衡的二叉树。因此，使用一种可以使树成为自平衡树的方法是很重要的，这反过来又会提高 `搜索` 操作。因此，我们应该注意，如果二叉树是平衡的，二叉搜索树是一个很好的选择。
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we discussed an important data structure, i.e. tree data structures.
    Tree data structures in general provide better performance compared to linear
    data structures in `search`, `insert`, and `deletion` operations. We have also
    discussed how to apply various operations to tree data structures. We studied
    binary trees, which can have a maximum of two children for each node. Further,
    we learned about binary search trees and discussed how we can apply different
    operations to them. Binary search trees are very useful when we want to develop
    a real-world application in which the retrieval or searching of data elements
    is an important operation. We need to ensure that the tree is balanced for the
    good performance of binary search tree. We will discuss priority queues and heaps
    in the next chapter.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一个重要的数据结构，即树数据结构。一般来说，与线性数据结构相比，树数据结构在`搜索`、`插入`和`删除`操作中提供更好的性能。我们还讨论了如何对树数据结构应用各种操作。我们研究了二叉树，每个节点最多有两个子节点。此外，我们还学习了二叉搜索树，并讨论了如何对它们应用不同的操作。当我们想要开发一个现实世界应用，其中数据元素的检索或搜索是一个重要操作时，二叉搜索树非常有用。我们需要确保树是平衡的，以获得二叉搜索树的良好性能。我们将在下一章讨论优先队列和堆。
- en: Exercises
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Which of the following is a true about binary trees:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于二叉树的哪个说法是正确的：
- en: Every binary tree is either complete or full
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个二叉树要么是完整的，要么是满的
- en: Every complete binary tree is also a full binary tree
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个完整的二叉树也是满的二叉树
- en: Every full binary tree is also a complete binary tree
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个满二叉树也是完整的二叉树
- en: No binary tree is both complete and full
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有二叉树既是完整的又是满的
- en: None of the above
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非
- en: Which of the tree traversal algorithms visit the root node last?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个树遍历算法最后访问根节点？
- en: 'Consider this binary search tree:'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑这个二叉搜索树：
- en: '![](img/B17217_06_38.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_38.png)'
- en: 'Figure 6.38: Sample binary search tree'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.38：样本二叉搜索树
- en: Suppose we remove the root node `8`, and we wish to replace it with any node
    from the left subtree, then what will be the new root?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们移除根节点`8`，并希望用左子树中的任何节点来替换它，那么新的根节点将是什么？
- en: What will be the `inorder`, `postorder` and `preorder` traversal of the following
    tree?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下树的`中序`、`后序`和`前序`遍历是什么？
- en: '![](img/B17217_06_39.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_06_39.png)'
- en: 'Figure 6.39: Example tree'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.39：示例树
- en: How do you find out if two trees are identical?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何判断两棵树是否相同？
- en: How many leaves are there in the tree mentioned in *question number 4*?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第4个问题中提到的树中有多少个叶子节点？
- en: What is the relation between a perfect binary tree’s height and the number of
    nodes in that tree?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完美二叉树的高度与该树中的节点数之间有什么关系？
- en: Join our community on Discord
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1421249772551223062.png)'
