<html><head></head><body><div><h1 class="header-title">Making a Pet Feeding Robot</h1>
                
            
            
                
<p>In this chapter, we will take a step further in terms of integrating the sensors to make a robot that feeds your pet whenever you have programmed it to. It is fairly simple to build; you might need some DIY skills and a few old cardboards to prepare this project. Keep scissors and adhesives handy, as they might be needed here. </p>
<p>There are times when you are not at home throughout the day and your pet keeps waiting for you to feed him. For such a situation, this robot would be of great help; it will feed your pet at specific times and also make sure that your pet gets the right quantity of food every single time. This can even be helpful on a daily basis. As it will never forget to feed your pet, no matter what.</p>


            

            
        
    </div>
<div><h1 class="header-title">Force measurement</h1>
                
            
            
                
<p>Force is one of the fundamental units that is applied to objects, either due to gravity or some external factors. Force measurements can give us a lot of insight about the environment or the object. If you have an electronic weight scale, then every time you step on to the weight scale, the weight being told to you happens because of a force sensor. This happens because your body has a mass. Due to the mass, the gravity pulls the object toward the center of the earth. The force being applied by the gravity to any physical object is referred to as the weight of the object. Hence, with the force sensor, we are basically sensing how much force gravity is applying to a body. </p>
<p>Now when we talk about force measurements, it can be done using multiple ways. There are various types of complex load cells that can precisely tell us how many milligrams of weight have changed. There are also much simpler sensors that can simply give us a rough estimate of how much force is being applied. From this data, we can calculate the relative weight of the object. You must be asking why are we not using the load cell. The reason is that it can be slightly complicated for the present scenario, and it's always good to start with basics. </p>
<p>So, let's see what we have. The load sensor we are talking about is a resistive force sensor. The way it works is very simple. It consists of polymer whose resistance changes with the change of force applied to it. In general, the more force you apply, the lower would be the resistance. Hence, due to change in this resistance, we can simply calculate the resultant voltage. This resultant voltage would be directly proportional to the weight being put on the force sensor. </p>


            

            
        
    </div>
<div><h1 class="header-title">Constructing the robot </h1>
                
            
            
                
<p>Now, to make this robot, we would need a few cardboard cartons. We need to make two parts of it:</p>
<ul>
<li>A food dispenser</li>
<li>A collecting bowl with a force sensor</li>
</ul>
<p>First, let's see how the dispenser has to be made. You need to follow these steps:</p>
<ol>
<li>Take a medium-sized carton that can carry up to about four and a half pounds of pet food.</li>
<li>Then, go ahead and make a small cutout.</li>
<li>This cutout should be big enough to dispense food but not so big that a lot of food comes out of it at once.</li>
<li>Now, once that is done, you need to make a lid that covers that through-hole.</li>
<li>This lid should be slightly bigger than the through-hole itself. </li>
<li>Install the lid over the shaft of the motor.</li>
</ol>
<ol start="7">
<li>Fix the motor on to the cardboard, as shown in the following diagram. Make sure that the position of the motor should be such that the lid covers the entire through-hole on the cardboard. </li>
<li>Finally, install ends-stops. These are simple pieces of cardboard that will restrict the movement of the lid in either direction.</li>
<li>The first end-stop should be at a position that it should stop the lid exactly where it covers the entire through-hole. </li>
<li>The second should be at a position where the lid is entirely opened, and there is no obstruction when the food comes down from the container. </li>
</ol>
<p>To help you with the construction, refer to the following diagram; you can devise other ways to control the opening or closing as well if you want:</p>
<div><img src="img/4d8071ec-b20a-4e4f-93df-a7f245c651f0.png" style="width:36.17em;height:20.33em;"/></div>
<p>Now, the second part is the bowl. This part is pretty straightforward. You simply need to paste the force sensor using a mild adhesive onto the bottom of the bowl, where it makes contact with the ground. Once this is done, add another layer of adhesive and attach it exactly below the dispenser.</p>
<p>Once this constitution is done, go ahead and wire it up, as shown here:</p>
<div><img src="img/8a4a6b59-6c83-411c-921b-4dcf1c997f21.png"/></div>
<div><p>Perfect! Now we are ready to upload our code and make this thing work. So, go ahead and upload the following code; then I will tell you what exactly is happening: </p>
<pre>import Adafruit_ADS1x15<br/>import RPi.GPIO as GPIO<br/><br/>adc = Adafruit_ADS1x15.ADS1015()<br/><br/>GAIN = 1<br/>channel = 0<br/><br/>adc.start_adc(channel, gain=GAIN)<br/><br/>while True:<br/>   <br/>    print(adc.get_last_result())<br/></pre>
<p>Now, once you upload this code, you will start to get the raw reading of the force sensors. How? Let's see:</p>
<pre>import Adafruit_ADS1x15</pre>
<p>Here, we are sporting the library for <kbd>ADS1x15</kbd> using the command <kbd>import Adafruit_ADS1x115</kbd>; this will help us read the value from the ADC:</p>
<pre>adc = Adafruit_ADS1x15.ADS1015()<br/><br/>GAIN = 1<br/>channel = 0<br/><br/>adc.start_adc(channel, gain=GAIN) </pre>
<p>You should know what this line does; however if you are not sure, refer to <a href="ef81f30f-708e-4228-a92d-0f343f5928d3.xhtml">Chapter 2</a>, <em>Using GPIOs as Input</em>:</p>
<pre>    print(adc.get_last_result())</pre>
<p>In this line, the raw reading that has been received by the ADC will be shown to you.</p>
<p>You must be wondering why we are doing this. Till now, you must have been feeding your pet based on visual quantity, instead of a specific weight. Hence, what we are doing here is printing the value of the force sensor. Once this value is printed, then you can correct quantity of the food in the container and measure the reading. This reading will act as a threshold. That is, this is the quantity that would be dispensed. </p>
<p>Now, once you have noted this reading, we will change the code slightly. Let's see what it is:</p>
<pre>import time<br/>import Adafruit_ADS1x15<br/>import RPi.GPIO as GPIO<br/>Motor1a = 21<br/>Motor1b = 20<br/>Buzzer = 14<br/>FSR = 16<br/>THRESHOLD = 1000<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(Motor1a,GPIO.OUT)<br/>GPIO.setup(Motor1b,GPIO.OUT)<br/>GPIO.setup(Buzzer,GPIO.OUT)<br/>GPIO.setup(FSR,GPIO.IN)<br/>adc = Adafruit_ADS1x15.ADS1015()<br/>GAIN = 1<br/>channel = 0<br/>adc.start_adc(channel, gain=GAIN)<br/>while True:<br/> M = datetime.datetime.now().strftime('%M')<br/> if (H == 12 or H==16 or H==20) &amp;&amp; M == 00 :<br/> value = adc.get_last_result()<br/> while value &lt; THRESHOLD:<br/> GPIO.output(BUZZER,1)<br/> GPIO.output(MOTOR1a,1)<br/> GPIO.output(MOTOR1b,0)<br/> GPIO.output(MOTOR1a,0)<br/> GPIO.output(MOTOR1b,1)<br/> GPIO.output(Buzzer,0)<br/> time.sleep(5)<br/> GPIO.output(MOTOR1b,0)<br/>adc.stop_adc()</pre>
<p>Now let's see what we have done!</p>
<pre>Motor1a =  21<br/>Motor1b = 20<br/>Buzzer = 14<br/>FSR = 16<br/>THRESHOLD = 1000</pre>
<p>Here, we are declaring the pins connected for the motor, buzzer, and <strong>Force Sensitive Resistor</strong> (<strong>FSR</strong>). Also, we are assigning the value to a variable named <kbd>THRESHOLD</kbd>; this will determine the amount of food that will be dispensed. Here, we have kept an arbitrary value as <kbd>1000</kbd>. In your code, you must put the value that you have calculated in the previous code. </p>
<p>Now that most of the code is easily understandable, let's jump to the part where the main show is happening:</p>
<pre>'  H = datetime.datetime.now().strftime('%H')<br/>   M = datetime.datetime.now().strftime('%M')<br/><br/> if (H == 12 or H==20) &amp;&amp; M == 00 :<br/><br/>     value = adc.get_last_result()<br/><br/>     while value &lt; THRESHOLD:<br/>         GPIO.output(BUZZER,1)<br/>         GPIO.output(MOTOR1a,1)<br/>         GPIO.output(MOTOR1b,0)</pre>
<p>In the first line using the function <kbd>datetime.dateime.now().strftime('%H')</kbd>,we are deriving the value of hours at that moment, and using the function <kbd>M = datetime.datetime.now().strftime('%M')</kbd>, we are deriving the minutes. Once this is done, then using the condition <kbd>if (H == 12 or H ==20) &amp;&amp; M == 00</kbd>, we are checking whether the time is  12 noon or 20:00 hours in the evening. Once any of these condition are true, then the value of <kbd>M</kbd> is also getting checked. If <kbd>M == 00</kbd>, then the value of ADC would be checked using the function <kbd>adc.get_last_result()</kbd>. The function stores the value in a variable named <kbd>value</kbd>. Once the value is checked, it is checked by <kbd>while value&lt; THRESHOLD:</kbd>. If the condition is true, then <kbd>BUZZER</kbd> and <kbd>MOTOR1a</kbd> are set to high. This means that the buzzer will ring and the motor will turn in one direction. As we have an end-stop at both directions, the motor will stop whenever it reaches that position:</p>
<pre> GPIO.output(MOTOR1a,0)<br/> GPIO.output(MOTOR1b,1)<br/> GPIO.output(Buzzer,0) <br/><br/> time.sleep(5)<br/><br/> GPIO.output(MOTOR1b,0)</pre>
<p>Once the preceding condition is false, then the rest of code will come into action, which basically will turn the motor to the closing side and it will stop the buzzer from buzzing. The motor will try to retract to its closed position for <kbd>5</kbd> seconds, as after the condition <kbd>time.sleep(5)</kbd>, the motor will get a command <kbd>GPIO.output(MOTOR1b,0)</kbd>, which will stop the motor from turning.</p>
<p>Hence, in summary, the robot will dispense the food at certain times and in a very specific quantity that you decide. </p>


            

            
        
    </div>
<div><h1 class="header-title">Making the robot detect pets</h1>
                
            
            
                
<p>The preceding code is good, and I'm sure it would be dispensing the food at set times. However, there can be a problem, as the robot would not be effective if the pet does not know whether the food had been fetched. Hence, we need to have an alarm that should inform the pets that the food is ready to be eaten. </p>
<p>Even in the previous program, we have used a buzzer that will inform the pet when the food is being dispensed, but, that was only for a very short period of time. However, what we are talking about here is an alarm system that will keep on ringing till the time the pet does not come and eat the food. To do this, connect the system as follows and mount the ultrasonic sensor in such a way that it notes the distance of the pet while he is eating the food.</p>
<div><img src="img/9a02b251-9ebb-4f6d-9a99-8a6017acc744.png" style="width:38.17em;height:44.50em;"/></div>
<p>Now, to do that, you will need to upload the following code:</p>
<pre>import time<br/>import Adafruit_ADS1x15<br/>import RPi.GPIO as GPIO<br/><br/>Motor1a =  21<br/>Motor1b = 20<br/>Buzzer = 14<br/>FSR = 16<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(Motor1a,GPIO.OUT)<br/>GPIO.setup(Motor1b,GPIO.OUT)<br/>GPIO.setup(Buzzer,GPIO.OUT)<br/>GPIO.setup(FSR,GPIO.IN)<br/><br/>adc = Adafruit_ADS1x15.ADS1015()<br/><br/>GAIN = 1<br/>channel = 0<br/><br/>adc.start_adc(channel, gain=GAIN)<br/> <br/> <br/>def Distance():<br/>    GPIO.output(23,GPIO.LOW)<br/><br/>    time.sleep(0.2)<br/><br/>    GPIO.output(23,GPIO.HIGH)<br/><br/>    time.sleep(0.000010)<br/><br/>    GPIO.output(23,GPIO.LOW)<br/><br/>    while GPIO.input(24)==0:<br/>        pulse_start = time.time()<br/><br/>    while GPIO.input(24)==1:<br/>        pulse_stop = time.time()<br/><br/>      duration = pulse_stop - pulse_start<br/>      distance = duration*17150.0<br/>     distance = round(distance,2)<br/><br/>    return distance<br/><br/>while True:<br/>   <br/>   <br/>   H = datetime.datetime.now().strftime('%H')<br/><br/>   if H == 12 or H==16 or H==20:<br/>    value = adc.get_last_result()<br/><br/>    while value &lt; 100:<br/>        GPIO.output(BUZZER,1)<br/>        GPIO.output(MOTOR1a,1)<br/>        GPIO.output(MOTOR1b,0)<br/><br/>time.sleep(5)<br/><br/>GPIO.output(MOTOR1a,0)<br/>GPIO.output(MOTOR1b,0)<br/><br/>if Distance() &lt;=2 :<br/><br/>    GPIO.output(Buzzer, 0)<br/>    time.sleep(5)<br/> <br/>  adc.stop_adc()</pre>
<p>As you can see, most of the code is almost identical; however, there is an added feature that will keep ringing the buzzer till the time the pet does not come and eat the food. To do this, we input the following: </p>
<pre>def Distance():<br/>    GPIO.output(23,GPIO.LOW)<br/><br/>    time.sleep(0.2)<br/><br/>    GPIO.output(23,GPIO.HIGH)<br/><br/>    time.sleep(0.000010)<br/><br/>    GPIO.output(23,GPIO.LOW)<br/><br/>    while GPIO.input(24)==0:<br/>        pulse_start = time.time()<br/><br/>    while GPIO.input(24)==1:<br/>        pulse_stop = time.time()<br/><br/>      duration = pulse_stop - pulse_start<br/>      distance = duration*17150.0<br/>     distance = round(distance,2)<br/><br/>    return distance</pre>
<p>We have defined a function that notes down the distance taken from the ultrasonic sensor. You may recollect this code form the previous chapters. So, now, whenever this function is called, the distance will be noted down:</p>
<pre>    while value &lt; 100:<br/>        GPIO.output(BUZZER,1)<br/>        GPIO.output(MOTOR1a,1)<br/>        GPIO.output(MOTOR1b,0)<br/><br/>time.sleep(5)<br/><br/>GPIO.output(MOTOR1a,0)<br/>GPIO.output(MOTOR1b,0)</pre>
<p>As you can see, the buzzer is getting switched on in the while loop just like last time; however, after <kbd>5</kbd> in the previous code after 5 second of wait the buzzer was switched off.  However, in this code, we are not doing so. Hence, the buzzer will stay active till the time some part of our code does not turn it off. Now, to turn on the buzzer, we are calculating the distance at the end of the code:</p>
<pre>if Distance() &lt;=2 &amp;&amp; value &lt; 50:<br/><br/>    GPIO.output(Buzzer, 0)<br/>    time.sleep(5)</pre>
<p>This part of code is checking whether distance is less than <kbd>2</kbd> centimeters and the weight value of the food container is less than <kbd>50</kbd>. This means the pet approaches the food container and eats at least half of the food. If he does not eat the food properly, then the buzzer will keep on buzzing.</p>


            

            
        
    </div>
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>So readers, I think you understood the basics of motor integration with logic of time and force sensor to make a robot that does some of your work on a daily basis. These kinds of robots are available on the market for hundreds of dollars, but see how easily and at such low cost you made one for yourself. Moving forward, in the next chapter, we will be building a Bluetooth controlled robotic car.</p>


            

            
        
    </div></body></html>