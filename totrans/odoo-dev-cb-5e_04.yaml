- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will guide you through some small enhancements to an existing add-on
    module. You already registered your add-on module in the Odoo instance in [*Chapter
    3*](B20997_03.xhtml#_idTextAnchor083), *Creating Odoo Add-On Modules*. Now, you
    will explore the database aspects of the module in more depth. You will learn
    how to create a new model (database table), add new fields, and apply constraints.
    You will also discover how to use inheritance in Odoo to modify existing models.
    In this chapter, you will use the same module that you created in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the model representation and order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding data fields to a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a float field with configurable precision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a monetary field to a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding relational fields to a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a hierarchy to a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding constraint validations to a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding computed fields to a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing related fields stored in other models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding dynamic relations using reference fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding features to a model using inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using abstract models for reusable model features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying the model definition using inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before proceeding with the examples in this chapter, make sure you have the
    module that we developed in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083), *Creating
    Odoo Add-On Modules*, and that it is properly installed and configured.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the model representation and order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A model refers to a representation of a database table. A model defines the
    structure and behavior of a database table, including fields, relationships, and
    various methods. Models are defined in Python code using Odoo’s **object-relational
    mapping** (**ORM**) system. ORM allows developers to interact with the database
    using Python classes and methods, rather than writing raw SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Model attributes are the features of a model that will be defined when we create
    a new model; otherwise, we use the attributes of the model that already exists.
    Models use structural attributes with an underscore prefix to define their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `my_hostel` instance should already contain a Python file called `models/hostel.py`,
    which defines a basic model. We will edit it to add new class-level attributes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By utilizing these attributes effectively, developers can create well-organized,
    reusable, and maintainable code in Odoo, leading to a more efficient and robust
    application. The following are the attributes that can be used on a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_name` : The `name` attribute is the most important one, as it determines
    the internal global identifier and the database table name. The model name is
    expressed in dot notation within the module namespace. For instance, `name="hostel.hostel"`
    will create the `hostel_hostel` table in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`_table`: We can define the SQL table name utilized by the model if ‘`_auto`’
    is enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`_description`: To assign a descriptive title to the model that reflects its
    purpose and functionality, insert the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t use `_description` for your model, Odoo will show a warning in
    the logs.
  prefs: []
  type: TYPE_NORMAL
- en: '`_order`: The default field for ordering the search results is ‘`id`’. However,
    this can be changed so that we can use the fields of our choice, by providing
    an `_order` attribute with a string containing a comma-separated list of field
    names. A field name can be followed by the `desc` keyword to sort it in descending
    order. To order the records by `id` in descending order, followed by names in
    ascending order, use the following code syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Only fields stored in the database can be used. Non-stored computed fields can’t
    be used to sort records. The syntax for the `_order` string is similar to the
    `SQL ORDER BY` clauses, although it’s stripped down. For instance, special clauses,
    such as `NULLS FIRST`, are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '`_rec_name`: This is used to set the field that’s used as a representation
    or title for the records. The default field for `rec_name` is the name field.
    `_rec_name` is the display name of the record used by Odoo’s `rec_name` and set
    `hostel_code` as a representative of the model, use the following code syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If your model doesn’t have a name field and you haven’t specified `_rec_name`
    either, your display name will be a combination of the model name and record ID,
    like this – `(``hostel.hostel, 1)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`_rec_names_search`: This is used to search specific records by mentioned field
    values. It is similar to using the `name_search` function. You can directly use
    this attribute instead of using the `name_search` method. To do so, use the following
    code syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All models have a `display_name` field that shows the record representation
    in a human-readable format, which has been automatically added to all models since
    version 8.0\. The default `_compute_display_name()` method uses the `_rec_name`
    attribute to determine which field contains the data for the display name. To
    customize the display name, you can override the `_compute_display_name()` method
    and provide your logic. The method should return a list of tuples, each containing
    the record ID and the Unicode string representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to have the hostel name and hostel code in the representation,
    such as `Youth Hostel (YHG015)`, we can define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example. This will add a release date to the record’s
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After adding the preceding code, your `display_name` record will be updated.
    Suppose you have a record with the name `Bell House Hostel` and its code is `BHH101`;
    then, the preceding `_compute_display_name()` method will generate a name such
    as `Bell House` `Hostel (BHH101)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we’re done, our `hostel.py` file should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `<form>` view in the `hostel.xml` file will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We should then upgrade the module to activate these changes in Odoo.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the module, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, search for the `my_hostel` module and upgrade it via the dropdown, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The option to update the module](img/B20997_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The option to update the module
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can also use the `-u my_hostel` command in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data fields to a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A field represents a column in a database table and defines the structure of
    the data that can be stored in that column. Fields in Odoo models are used to
    specify the attributes and characteristics of the data that the model will store.
    Each field has a data type (e.g., `Char`, `Integer`, `Float`, or `Date`) and various
    attributes that determine how the field behaves.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will explore the various data types that fields can support
    and how to add them to a model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes that you have an instance ready with the `my_hostel` add-on
    module available, as described in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo* *Add-On Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `my_hostel` add-on module should already have `models/hostel.py`, defining
    a basic model. We will edit it to add new fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the minimal syntax to add fields to the `Hostel` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have added new fields to the model. We still need to add these fields to
    the form view in order to reflect these changes in the user interface. Refer to
    the following code to add fields to the form view:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upgrading the module will make these changes effective in the Odoo model.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add fields to models, you need to define an attribute of the corresponding
    type in their Python classes. The available types of non-relational fields are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Char**: Stores string values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text**: Stores multiline string values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selection**: Stores one value from a list of predefined values and descriptions.
    This has a list of values and description pairs. The value that is selected is
    what gets stored in the database, and it can be a string or an integer. The description
    is automatically translatable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Odoo does not display the description if the value is zero for integer keys.
    The `Selection` field also accepts a function reference as its `selection` attribute
    instead of a list. This allows you to dynamically generate lists of options. You
    can find an example relating to this in the *Adding dynamic relations using reference
    fields* recipe in this chapter, where a `selection` attribute is also used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Html**: Stores rich text in the HTML format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binary**: Stores binary files, such as images or documents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`True`/`False` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Date.today()` to set the default value to the current date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`datetime` values as Python datetime objects in UTC time. Use `fields.Date.now()`
    to set the default value to the current time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer**: Stores integer values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float**: Stores numeric values with optional precision (total digits and
    decimal digits).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monetary**: Stores an amount in a specific currency. This will be explained
    further in the *Adding a monetary field to a model* recipe in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Step 1* of this recipe shows the minimal syntax to add to each field type.
    The field definitions can be expanded to add other optional attributes, as shown
    in *step 2*. Here’s an explanation of the field attributes that were used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string` is the field’s title and is used in UI view labels. It is optional.
    If not set, a label will be derived from the field name by adding a title case
    and replacing the underscores with spaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translate`, when set to `True`, makes the field translatable. It can hold
    a different value, depending on the user interface language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` is the default value. It can also be a function that is used to calculate
    the default value – for example, `default=_compute_default`, where `_compute_default`
    is a method that was defined on the model before the field definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help` is an explanation text that’s displayed in the UI tooltips.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groups` makes the field available only to some security groups. It is a string
    containing a comma-separated list of XML IDs for security groups. This is addressed
    in more detail in [*Chapter 10*](B20997_10.xhtml#_idTextAnchor549), *Security
    Access*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy` flags whether the field value is copied when the record is duplicated.
    By default, it is `True` for non-relational and `Many2one` fields, and `False`
    for `One2many` and computed fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`, when set to `True`, creates a database index for the field, which
    sometimes allows for faster searches. It replaces the deprecated `select=1` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `readonly` flag makes the field read-only by default in the user interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `required` flag makes the field mandatory by default in the user interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The various whitelists that are mentioned here are defined in `odoo/fields.py`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `company_dependent` flag makes the field store different values for each
    company. It replaces the deprecated `Property` field type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value isn’t stored on the model table. It is registered as ``ir.property``.
    When the value of the `company_dependent` field is needed, an ``ir.property``
    is searched and linked to the current company (and the current record if one property
    exists). If the value is changed on the record, it either modifies the existing
    property for the current record (if one exists) or creates a new one for the current
    company and `res_id`. If the value is changed on the company side, it will impact
    all records on which the value hasn’t been changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group_operator` is an aggregate function used to display results in the group
    by mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible values for this attribute include `count`, `count_distinct`, `array_agg`,
    `bool_and`, `bool_or`, `max`, `min`, `avg`, and `sum`. Integer, float, and monetary
    field types have the default `sum` value for this attribute. This field is used
    by the `:meth:~odoo.models.Model.read_group` method to group rows based on this
    field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The supported aggregate functions are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`array_agg`: Concatenates all values, including nulls, into an array'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: Counts the number of rows'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count_distinct`: Counts the number of distinct rows'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool_and`: Returns `true` if all values are `true`, and `false` otherwise'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool_or`: Returns `true` if at least one value is `true`, and `false` otherwise'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max`: Returns the maximum value of all values'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`: Returns the minimum value of all values'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`avg`: Returns the average (arithmetic mean) of all values'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sum`: Returns the sum of all values'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Store`: This is for whether the field is stored in the database (the default
    is `True`, and `False` for computed fields).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group_expand`: This function is used to expand `read_group` results when grouping
    on the current field:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `sanitize` flag is employed within HTML fields to systematically remove
    potentially insecure tags from their content. Activation of this flag results
    in a comprehensive cleansing of the input. For users seeking more nuanced control
    over HTML sanitization, there are additional attributes available. It is important
    to note that these attributes are effective only when the sanitize flag is enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need finer control in HTML sanitization, there are a few more attributes
    that you can use, which only work if `sanitize` is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sanitize_tags=True`, to remove tags that are not part of a whitelist (this
    is the default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sanitize_attributes=True`, to remove attributes of the tags that are not part
    of a whitelist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sanitize_style=True`, to remove style properties that are not part of a whitelist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strip_style=True`, to remove all style elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strip_class=True`, to remove the class attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we updated the form view according to the newly added fields in the
    model. We placed all fields in form view, but you can place them anywhere you
    want. Form views are explained in more detail in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Date` and `Datetime` field objects expose a few utility methods that can
    be convenient for Date and Datetime:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Date`, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.Date.to_date(string_value)` parses the string into a date object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Date.to_string(date_value)` converts the Python Date object to a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Date.today()` returns the current day in a string format. This is appropriate
    for use with default values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Date.context_today(record, timestamp)` returns the day of the timestamp
    (or the current day, if the timestamp is omitted) in a string format, according
    to the time zone of the record’s (or record set’s) context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For `Datetime`, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.Datetime.to_datetime(string_value)` parses the string into a datetime
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Datetime.to_string(datetime_value)` converts the datetime object to
    a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Datetime.now()` returns the current day and time in a string format.
    This is appropriate to use for default values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Datetime.context_timestamp(record, timestamp)` converts a timestamp-naive
    datetime object into a time zone-aware datetime object. using the time zone in
    the context of a record. This is not suitable for default values but can be used
    for instances when you’re sending data to an external system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the basic fields, there are also few relational fields such as
    `Many2one`, `One2many`, and `Many2many`. These are covered in the *Adding relational
    fields to a model* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create fields with values that are computed automatically by using
    the `compute` field attribute to define the computation function. This is covered
    in the *Adding computed fields to a model* recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some fields are added by default in Odoo models, so you should avoid using
    these names for your fields. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id` (the record’s automatically generated identifier)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_date` (the record creation timestamp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_uid` (the user who created the record)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write_date` (the last recorded timestamp edit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write_uid` (the user who last edited the record)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The automatic creation of these log fields can be disabled by setting the `_log_access=False`
    model attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another special column that can be added to a model is `active`. It must be
    a `Boolean` field, allowing users to mark records as inactive. It is used to enable
    the `archive`/`unarchive` feature on the records. Its definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, only records with `active` set to `True` are visible. To retrieve
    them, we need to use a domain filter with `[(''active'', ''='', False)]`. Alternatively,
    if the `''active_test'': False` value is added to the environment’s context, ORM
    will not filter out inactive records.'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you may not be able to modify the context to get both the active
    and the inactive records. If so, you can use the `['|', ('active', '=', True),
    ('active', '=',` `False)]` domain.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '`[(''active'', ''in'' (True, False))]` does not work as you might expect. Odoo
    explicitly looks for an `(''active'', ''='', False)` clause in the domain. It
    will default to restricting the search to active records only.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a float field with configurable precision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using `float` fields, we may want to let the end user configure the decimal
    precision that will be used. In this recipe, we will add a `hostel_rating` field
    to the `hostel` model, with user-configurable decimal precision.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to apply dynamic decimal precision to the model’s
    `hostel_rating` field:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a data folder and add a `data.xml` file. Inside this file, add the following
    record for the decimal precision model. This will add a new configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Activate **Developer Mode** from the link in the **Settings** menu (refer to
    the *Activating the Odoo developer tools* recipe in [*Chapter 1*](B20997_01.xhtml#_idTextAnchor020),
    *Installing the Odoo Development Environment*). This will enable the **Settings**
    | **Technical** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the decimal precision configurations. To do this, open the **Settings**
    top menu and select **Technical** | **Database Structure** | **Decimal Accuracy**.
    We should see a list of the currently defined settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Creating new decimal precision](img/B20997_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Creating new decimal precision
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the `model` field using this decimal precision setting, edit the `models/hostel.py`
    file by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you add a string value to the `digits` attribute of the field, Odoo looks
    up that string in the decimal accuracy model’s `Usage` field and returns a tuple,
    with 16-digit precision and the number of decimals that were defined in the configuration.
    Using the field definition, instead of having it hardcoded, we allow the end user
    to configure it according to their needs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a monetary field to a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with monetary values and currencies in a model, we can use Odoo to provide
    special support for working with monetary values and currencies in its models,
    through the use of specific field types and features. Odoo’s special support for
    monetary values and currencies simplifies the handling of financial data, ensuring
    accuracy, consistency, and compliance with currency-related requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to add a currency field along with a monetary field to store the currency
    for the amounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add `models/hostel_room.py`, to add the necessary fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the field to store the currency for the amounts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the monetary field to store the amount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a security file for the new model and a form view to show it in the
    UI. Upgrade the add-on module to apply the changes. The monetary field will appear
    like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 4.3 – The currenc\uFEFFy symbol in the monetary field](img/B20997_04_3.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The currency symbol in the monetary field
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Odoo can display `monetary` fields correctly in the user interface because they
    have a second field that indicates their currency. This field is similar to a
    float field.
  prefs: []
  type: TYPE_NORMAL
- en: The currency field is usually named `currency_id`, but we can use any other
    name as long as we specify it with the optional `currency_field` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If your currency information is stored in a field named `currency_id`, you don’t
    need to specify the `currency_field` attribute for the monetary field.
  prefs: []
  type: TYPE_NORMAL
- en: This is helpful when you have to store amounts in different currencies in the
    same record. For example, if you want to have the currency of the sale order and
    the company, you can create two fields as `fields.Many2one(res.currency)` and
    use one for each amount.
  prefs: []
  type: TYPE_NORMAL
- en: The currency definition (the `decimal_precision` field of the `res.currency
    model`) determines the decimal precision for the amount.
  prefs: []
  type: TYPE_NORMAL
- en: Adding relational fields to a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Relational fields are used to represent relations between Odoo models. There
    are three types of relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`many-to-one`, or `m2o` for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`one-to-many`, or `o2m` for short'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`many-to-many`, or `m2m` for short'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate this, let’s consider the hostel room model. A room belongs to
    a single hostel, so the relation between the hostel and the room is `m2o`. However,
    a hostel can have multiple rooms, so the opposite relationship is `o2m`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also have a `m2m` relationship. For instance, a room can offer various
    amenities and amenities can be available in different rooms. This is a bidirectional
    `m2m` relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will edit the `models/hostel_room.py` file to add these fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `m2o` field for the hostel in `Hostel Room`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to create a `o2m` field for a student that links to a room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we need a new model for hostel students. We will make a `hostel_student.py`
    file and add some basic fields to the hostel student model. Then, we will add
    a `room_id` `m2o` field to connect the student and room models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we will add an `o2m` field, `student_ids`, of the `hostel.student`
    model to the `hostel.room` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create a new file, `hostel_amenities.py`. Add the following code to
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will add an `m2m` field of amenities to the `hostel.room` model. Add
    the following code to `hostel_room.py`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, upgrade the add-on module, and the new fields should be available in the
    model. They won’t be visible in the views until they are added to them. We will
    add new fields to the `hostel_room.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: We can confirm their addition by inspecting the `model` fields in **Settings**
    | **Technical** | **Database Structure** | **Models** in **Developer** mode.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `m2o` field stores the database ID of another record in a column of the model’s
    table. This creates a foreign key constraint in the database, which ensures that
    the stored ID is a valid reference to a record in another table. By default, these
    relationship fields do not have a database index, but you can add one by setting
    the `index=True` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify what happens when the record that is referenced by an `m2o`
    field is deleted. The `ondelete` attribute controls this behavior. For instance,
    what should happen to students when their room record is deleted? The default
    option is `'set null'`, which means the field will have an empty value. Another
    option is `'restrict'`, which means the related record cannot be deleted. A third
    option is `'cascade'`, which means the linked record will be deleted as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `context` and `domain` for other relational fields. These
    attributes are mainly useful on the client side, and they provide default values
    for the views of the related records that are accessed through a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context` sets some variables in the client context when you click on a field
    to see the related record’s view. For example, you can use it to set default values
    for new records that are created in that view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain` is a filter that limits the list of related records that you can choose
    from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about `context` and `domain` in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*.
  prefs: []
  type: TYPE_NORMAL
- en: An `o2m` field is the opposite of an `m2o` field, and it lets you access a list
    of related records from a model. Unlike other fields, it does not have a column
    in the database table. It is just a convenient way to display these related records
    in views. To use an `o2m` field, you need to have a corresponding `m2o field`
    in the other model. In our example, we added an `o2m` field to the room model.
    The `student_ids` `o2m` field has a reference to the `room_id` field of the `hostel.room`
    model.
  prefs: []
  type: TYPE_NORMAL
- en: A `m2m` field does not have a column in the model’s table. Instead, it uses
    another table in the database to store the relationship between two models. This
    table has two columns for the IDs of the related records. When you link a room
    and its amenity with an `m2m` field, a new record is created in this table with
    the room’s ID and the amenity’s ID.
  prefs: []
  type: TYPE_NORMAL
- en: Odoo creates the relationship table for you. By default, the name of the relationship
    table is made from the names of the two models, sorted alphabetically, with a
    `_rel` suffix. You can change this name with the `relation` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: You should use the `relation` attribute when the names of the two models are
    too long for the default name. PostgreSQL has a limit of 63 characters for database
    identifiers. So, if the names of the two models are more than 23 characters each,
    you should set a shorter name with the `relation` attribute. We will explain this
    more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also use the `auto_join` attribute for `m2o` fields. This attribute
    lets ORM use SQL joins on this field. This means that ORM does not check the user
    access control and record access rules for this field. This can help with performance
    issues in some cases, but it is better to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the simplest way to define the relational fields. Now, let’s look
    at the attributes that are specific to these fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the attributes for the `o2m` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`comodel_name`: This is the name of the model that the field relates to. You
    need this attribute for all relational fields. You can write it without the keyword,
    as the first argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inverse_name`: This is only for the `o2m` fields. It is the name of the `m2o`
    field in the other model that links back to this model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`: This is for the `o2m` and `m2m` fields. It sets a maximum number of
    records to read and display in the user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the attributes for the `m2m` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`comodel_name`: This is the name of the model that the field relates to. It
    is the same as for the `o2m` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`relation`: This is the name of the table in the database that stores the relationship.
    You can use this attribute to change the default name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`column1`: This is the name of column 1 in the relation table that links to
    this model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`column2`: This is the name of column 2 in the relation table that links to
    the other model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Odoo typically handles the creation and management of these attributes automatically.
    It can identify and utilize an existing relation table for an inverse `m2m` field.
    However, there are specific scenarios where manual intervention is required.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with multiple `m2m` fields between the same two models, it becomes
    necessary to assign distinct relation table names for each field.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where the names of the two models exceed PostgreSQL’s limit of 63 characters
    for database object names, you must set these attributes yourself. The default
    relation table name is typically `<model1>_<model2>rel`. However, this table includes
    a primary key index with a longer name (`<model1><model2>rel<model1>id<model2>_id_key`),
    which also needs to adhere to the 63-character limit. Therefore, if the combined
    names of the two models surpass this limit, you must opt for a shorter relation
    table name.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a hierarchy to a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use an `m2o` field to represent hierarchies, where each record has a
    parent record and many child records in the same model. However, Odoo also provides
    improved support for this type of field by using the `nested set model` ([https://en.wikipedia.org/wiki/Nested_set_model](https://en.wikipedia.org/wiki/Nested_set_model)).
    When activated, queries using the `child_of` operator in their domain filters
    will run significantly faster.
  prefs: []
  type: TYPE_NORMAL
- en: Staying with the `Hostel` example, we will build a hierarchical category tree
    that can be used to categorize hostels.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add a new Python file, `models/hostel_categ.py`, for the category tree,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the new Python code file, add the following line to `models/__init__.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from odoo import models, fields, api
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'class HostelCategory(models.Model):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _name = "hostel.category"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: name = fields.Char('Category')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parent_id = fields.Many2one(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''hostel.category'','
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: string='Parent Category',
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ondelete='restrict',
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: index=True)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parent_path = fields.Char(index=True)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: child_ids = fields.One2many(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''hostel.category'', ''parent_id'','
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: string='Child Categories')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enable the special hierarchy support, also add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add a check to prevent looping relations, add the following line to the
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to assign a category to a hostel. To do this, we will add a new
    `m2o` field to the `hostel.hostel` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, a module upgrade will make these changes effective.
  prefs: []
  type: TYPE_NORMAL
- en: To display the `hostel.category` model in the user interface, you will need
    to add menus, views, and security rules. For more details, refer to [*Chapter
    3*](B20997_03.xhtml#_idTextAnchor083), *Creating Odoo Add-On Modules*. Alternatively,
    you can access all code at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to create a new model with hierarchical relations. This means that
    each record can have a parent record and many child records in the same model.
    Here are the steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: We create an `m2o` field to reference the parent record. We use `index=True`
    to make this field indexed in the database for faster queries. We also use `ondelete='cascade'`
    or `ondelete='restrict'` to control what happens when the parent record is deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `o2m` field to access all the child records of a record. This field
    does not add anything to the database, but it is a convenient way to get the child
    records. We add a special support for hierarchies by using `parent_store=True`
    in the model attribute. This makes the queries using the `child_of` operator faster,
    but it also makes the write operations slower. We also add a helper field called
    `parent_path` to store data for hierarchical searches. If we use a different name
    from `parent_id` for the parent field, we need to specify it with `parent_name`
    in the model attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We prevent cyclic dependencies in the hierarchy by using the `_check_recursion`
    method from `models.Model`. This avoids us having a record that is both an ancestor
    and a descendant of another record, which can cause infinite loops.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `category_id` field with `Many2one` type to the hostel.hostel model,
    so that we can assign a category to each hostel. This is just to complete our
    example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should use this technique for hierarchies that do not change much but are
    read and queried a lot. This is because the nested set model in the database needs
    to update the `parent_path` column (and the related database indexes) for all
    records when a category is added, deleted, or moved. This can be slow and costly,
    especially when there are many concurrent transactions.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a hierarchy that changes a lot, you might get better performance
    by using the standard `parent_id` and `child_ids` relationships. This way, you
    can avoid table-level locks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding constraints validations to a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to make sure that our models do not have invalid or inconsistent data.
    Odoo has two kinds of constraints to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Database-level constraints`: These are the constraints that PostgreSQL supports.
    The most common ones are the `UNIQUE` constraints, which prevent duplicate values.
    We can also use `CHECK` and `EXCLUDE` constraints for other conditions. These
    constraints are fast and reliable, but they are limited by what PostgreSQL can
    do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Server-level constraints`: These are the constraints that we write in Python
    code. We can use these constraints when the database-level ones are not enough
    for our needs. These constraints are more flexible and powerful, but they are
    slower and more complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
    We will use the hostel room model and add some constraints to it. We will use
    the hostel room model from [*Chapter* *3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo Add-On Modules*, and add some constraints to it.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a `UNIQUE` constraint to ensure that room numbers are not repeated.
    We will also add a Python model constraint to check that the rent amount is positive.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL constraints are defined through the `_sql_constraints` model attribute.
    This attribute is assigned a list of triples containing strings `(name`, `sql_definition`,
    `message)`, where `name` is a valid SQL constraint name, `sql_definition` is a
    `table_constraint` expression, and `message` is the error message. We can add
    the following code to the `hostel.room` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A Python constraint is a method that checks a condition on a set of records.
    We use the `constrains()` decorator to mark the method as a constraint and to
    indicate which fields are involved in the condition. The constraint is automatically
    checked when any of these fields are changed. The method should raise an exception
    if the condition is not met:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You need to upgrade the add-on module and restart the server after you make
    these changes to the code file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you add SQL constraints to the existing model through model inheritance,
    make sure you don’t have rows that violate the constraints. If you have such rows,
    then SQL constraints will not be added, and an error will be generated in the
    log.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on PostgreSQL constraints in general and table constraints
    in particular, take a look at [http://www.postgresql.org/docs/current/static/ddl-constraints.html](http://www.postgresql.org/docs/current/static/ddl-constraints.html).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use Python code to validate our models and prevent invalid data. To
    do this, we use two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A method that checks a condition on a set of records. We use the `constrains()`
    decorator to mark the method as a constraint and to indicate which fields are
    involved in the condition. The constraint is automatically checked when any of
    these fields are changed.
  prefs: []
  type: TYPE_NORMAL
- en: A `ValidationError` exception that we raise when the condition is not met. This
    exception shows an error message to the user and stops the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding computed fields to a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may want to create a field that depends on the values of other fields in
    the same record or in related records. For instance, we can calculate the total
    amount by multiplying a unit price by a quantity. In Odoo models, we can use computed
    fields to do this.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how computed fields work, we will add one to the Hostel Room
    model that computes the availability of rooms based on student occupancy.
  prefs: []
  type: TYPE_NORMAL
- en: We can also make computed fields editable and searchable. We will show you how
    to do this in our example as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will modify the `models/hostel_room.py` code file to include a new field
    and the methods that implement its logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A computed field’s value usually relies on the values of other fields in the
    same record. ORM requires the developer to declare those dependencies on the `compute`
    method using the `depends()` decorator. ORM uses the given dependencies to recompute
    the field whenever any of its dependencies change. Start by adding the new fields
    to the `Hostel` `Rooms` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, computed fields are read-only because the user should not enter
    a value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'However, in some cases, it might be helpful to allow the user to set a value
    directly. For example, in our hostel student scenario, we will add an admission
    date, discharge date, and duration. We would like the user to be able to enter
    either the duration or the discharge date and have the other value updated accordingly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A compute method assigns a value to the field, while an inverse method assigns
    values to the field’s dependencies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the inverse method is invoked when the record is saved, while the
    compute method is invoked whenever any of its dependencies change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Computed fields are not stored in the database by default. One solution is
    to store the field with the `store=True` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As computed fields are not stored in the database by default, it is not possible
    to search on a computed field unless we use the `store=True` attribute or add
    a `search` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A computed field looks like a regular field, except that it has a `compute`
    attribute that specifies the name of the method that computes its value.
  prefs: []
  type: TYPE_NORMAL
- en: However, computed fields are not the same as regular fields internally. Computed
    fields are calculated on the fly at runtime, and because of that, they are not
    stored in the database, so you cannot search or write on them by default. You
    need to do some extra work to enable writing and search support for them. Let’s
    see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: The computation method is calculated on the fly at runtime, but ORM uses caching
    to avoid recalculating it unnecessarily every time its value is accessed. So,
    it needs to know what other fields it relies on. It uses the `@depends` decorator
    to determine when its cached values should be invalidated and recalculated.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the compute method always assigns a value to the computed field.
    Otherwise, an error will occur. This can happen when you have conditions in your
    code that sometimes fail to assign a value to the computed field. This can be
    hard to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Write support can be added by implementing the `inverse` method. This uses the
    value assigned to the computed field to update the source fields. Of course, this
    only works for simple calculations. However, there are still cases where it can
    be helpful. In our example, we make it possible to set the discharge date by editing
    the duration days, since `Duration` is a computed field.
  prefs: []
  type: TYPE_NORMAL
- en: The `inverse` attribute is optional; if you don’t want to make the computed
    field editable, you can skip it.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to make a non-stored computed field searchable by setting
    the `search` attribute to the method name (similar to `compute` and `inverse`).
    Like `inverse`, `search` is also optional; if you don’t want to make the computed
    field searchable, you can skip it.
  prefs: []
  type: TYPE_NORMAL
- en: However, this method is not supposed to perform the actual search. Instead,
    it receives the operator and value used to search on the field as parameters and
    is supposed to return a domain, with the alternative search conditions to use.
  prefs: []
  type: TYPE_NORMAL
- en: The optional `store=True` flag stores the field in the database. In this case,
    after being computed, the field values are stored in the database, and from then
    on, they are retrieved in the same way as regular fields, instead of being recomputed
    at runtime. Thanks to the `@api.depends` decorator, ORM will know when these stored
    values need to be recomputed and updated. You can think of it as a persistent
    cache. It also has the benefit of making the field usable for search conditions,
    including sorting and grouping by operations. If you use `store=True` in your
    compute field, you no longer need to implement the `search` method because the
    field is stored in a database, and you can search/sort based on it.
  prefs: []
  type: TYPE_NORMAL
- en: The `compute_sudo=True` flag is for cases where the computations need to be
    done with higher privileges. This might be needed when the computation needs to
    use data that may not be accessible to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `compute_sudo` changed in Odoo v13\. Before Odoo v13, the
    value of `compute_sudo` was `False`, but in v13, the default value of `compute_sudo`
    depends on the store attribute. If the `store` attribute is `True`, then `compute_sudo`
    is `True`; otherwise, it is `False`. However, you can always override it by explicitly
    setting `compute_sudo` in your field definition.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Odoo v13 introduced a new caching mechanism for ORM. Previously, the cache
    was based on the environment, but now, in Odoo v13, there is one global cache.
    So, if you have a computed field that relies on context values, then you may get
    the wrong values sometimes. To solve this problem, you need to use the `@api.depends_context`
    decorator. Refer to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding example that our computation uses `company_id`
    from the context. By using `company_id` in the `depends_context` decorator, we
    ensure that the field value will be recomputed based on the value of `company_id`
    in the context.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing related fields stored in other models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odoo clients can only read data from the server for the fields that belong to
    the model they are querying. They cannot access data from related tables using
    dot notation as server-side code can.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can make the data from related tables available to the clients by
    adding it as related fields. This is what we will do to get the hostel of the
    room in the student model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Edit the `models/hostel_student.py` file to add the new `related` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that we have a field for the hostel room, and then, we add a new relation
    field to link the student with their hostel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to upgrade the add-on module for the new field to be available
    in the model.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A related field is a special type of field that references another field from
    a different record. To create a related field, we need to specify the `related`
    attribute and give it a string that shows the path of fields to follow. For example,
    we can create a related field that shows the hostel of the room of a student by
    following the `room_id.hostel_id` path.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Related fields are, in fact, computed fields. They just provide a convenient
    shortcut syntax to read field values from related models. As they are computed
    fields, this means that the `store` attribute is also available. As a shortcut,
    they also have all the attributes from the referenced field, such as `name` and
    `translatable`, as required.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, they support a `related_sudo` flag, similar to `compute_sudo`;
    when set to `True`, the field chain is traversed without checking the user access
    rights.
  prefs: []
  type: TYPE_NORMAL
- en: Using related fields in a `create()` method can affect performance, as the computation
    of these fields is delayed until the end of their creation. So, if you have an
    `o2m` relationship, such as in the `sale.order` and `sale.order.line` models,
    and you have a related field on the line model referring to a field on the order
    model, you should explicitly read the field on the order model during record creation,
    instead of using the related field shortcut, especially if there are a lot of
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dynamic relations using reference fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With relational fields, we need to decide the relation’s target model (or co-model)
    beforehand. However, sometimes, we may need to leave that decision to the user
    and first choose the model we want and then the record we want to link it to.
  prefs: []
  type: TYPE_NORMAL
- en: With Odoo, this can be achieved using reference fields.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `models/hostel.py` file to add the new related field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add a helper method to dynamically build a list of selectable
    target models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to add the reference field and use the previous function to provide
    a list of selectable models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we are changing the model’s structure, a module upgrade is needed to activate
    these changes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reference fields are similar to `m2o` fields, except that they allow the user
    to select the model to link to.
  prefs: []
  type: TYPE_NORMAL
- en: The target model is selectable from a list that’s provided by the `selection`
    attribute. The `selection` attribute must be a list of two-element tuples, where
    the first is the model’s internal identifier and the second is a text description
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: However, rather than providing a fixed list, we can use the most common models.
    For simplicity, we used all the models that have the messaging feature. Using
    the `_referencable_models` method, we provided a model list dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Our recipe started by providing a function to browse all the model records that
    can be referenced, to dynamically build a list that will be provided to the `selection`
    attribute. Although both forms are allowed, we declared the function name inside
    quotes, instead of directly referencing the function without quotes. This is more
    flexible, and it allows for the referenced function to be defined only later in
    code, for example, which is something that is not possible when using a direct
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: The function needs the `@api.model` decorator because it operates on the model
    level, not on the record set level.
  prefs: []
  type: TYPE_NORMAL
- en: While this feature looks nice, it comes with a significant execution overhead.
    Displaying the reference fields for a large number of records (for instance, in
    a list view) can create heavy database loads, as each value has to be looked up
    in a separate query. It is also unable to take advantage of database referential
    integrity, unlike regular relation fields.
  prefs: []
  type: TYPE_NORMAL
- en: Adding features to a model using inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odoo boasts a robust feature that significantly enhances its flexibility and
    functionality, which is particularly beneficial for businesses seeking tailored
    solutions. This feature enables the integration of module add-ons, allowing them
    to augment the capabilities of existing modules without the need to alter their
    underlying codebase. This is achieved through the addition or modification of
    fields and methods, as well as the extension of current methods with supplementary
    logic. This modular approach not only facilitates a customizable and scalable
    system but also ensures that upgrades and maintenance remain streamlined, preventing
    the complexities typically associated with custom modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official documentation describes three kinds of inheritance in Odoo:'
  prefs: []
  type: TYPE_NORMAL
- en: Class inheritance (extension)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegation inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see each one of these in a separate recipe. In this recipe, we will
    see class inheritance (extension). This is used to add new fields or methods to
    existing models.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll expand the existing partner model, `res.partner`, to include it in a computed
    field that calculates how many hostel rooms are assigned to each user. This will
    help determine which section each room is assigned to and which user occupies
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will extend the built-in partner model. If you remember, we already inherited
    the `res.parnter` model in the *Adding relational fields to a model* recipe in
    this chapter. To keep the explanation as simple as possible, we will reuse the
    `res.partner` model in the `models/hostel_book.py` code file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will ensure that the `authored_book_ids` inverse relation is in the
    partner model and add the computed field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the method that’s needed to compute the book count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we need to upgrade the add-on module for the modifications to take
    effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a model class is defined with the `_inherit` attribute, it adds modifications
    to the inherited model, rather than replacing it.
  prefs: []
  type: TYPE_NORMAL
- en: This means that fields defined in the inheriting class are added or changed
    on the parent model. At the database layer, ORM adds fields to the same database
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Fields are also incrementally modified. This means that if the field already
    exists in the superclass, only the attributes declared in the inherited class
    are modified; the other ones are kept as they are in the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Methods defined in the inheriting class replace methods in the parent class.
    If you don’t invoke the parent method with the `super` call, the parent’s version
    of the method will not be executed, and we will lose the features. So, whenever
    you add a new logic by inheriting existing methods, you should include a statement
    with `super` to call its version in the parent class. This is discussed in more
    detail in [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238), *Basic* *Server-Side
    Development*.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will add new fields to the existing model. If you also want to add
    these new fields to existing views (the user interface), refer to the *Changing
    existing views –* *view inheritance* recipe in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*.
  prefs: []
  type: TYPE_NORMAL
- en: Copying the model definition using inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw class inheritance (extension) in the previous recipe. Now, we will see
    `hostel.room` model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prototype inheritance is executed by using the `_name` and `_inherit` class
    attributes at the same time. Perform the following steps to generate a copy of
    the `hotel.room` model:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new file called `hostel_room_copy.py` to the `/``my_hostel/models/` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following content to the `hostel_room_copy.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import a new file reference into the `/my_library/models/__init__.py` file.
    Following the changes, your `__init__.py` file will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we need to upgrade the add-on module for the modifications to take
    effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To check the new model’s definition, go to the `hostel.room.copy` model here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In order to see menus and views for the new model, you need to add the XML definition
    of views and menus. To learn more about views and menus, refer to the *Adding
    menu items and views recipe* in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo* *Add-On Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using `_name` with the `_inherit` class attribute at the same time, you can
    copy the definition of the model. When you use both attributes in the model, Odoo
    will copy the model definition of `_inherit` and create a new model with the `_name`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, Odoo will copy the definition of the `Hostel.room` model and
    create a new model, `hostel.room.copy`. The new `hostel.room.copy` model has its
    own database table with its own data that is totally independent from the `hostel.room`
    parent model. Since it still inherits from the partner model, any subsequent modifications
    to it will also affect the new model.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype inheritance copies all the properties of the parent class. It copies
    fields, attributes, and methods. If you want to modify them in the child class,
    you can simply do so by adding a new definition to the child class. For example,
    the `hostel.room` model has the `_name_get` method. If you want to use a different
    version of `_name_get` in the child, you need to redefine the method in the `hostel.room.copy`
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Prototype inheritance does not work if you use the same model name in the `_inherit`
    and `_name` attributes. If you do use the same model name in the `_inherit` and
    `_name` attributes, it will just behave like a normal extension inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the official documentation, this is called prototype inheritance, but in
    practice, it is rarely used. The reason for this is that delegation inheritance
    usually answers to that need in a more efficient way, without the need to **duplicate
    data structures**. For more information on this, you can refer to the next recipe,
    Using delegation inheritance to copy features to another model.
  prefs: []
  type: TYPE_NORMAL
- en: Using delegation inheritance to copy features to another model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third type of inheritance is Delegation inheritance. Instead of `_inherit`,
    it uses the `_inherits` class attribute. There are cases where, rather than modifying
    an existing model, we want to create a new model based on an existing one to use
    the features it already has. We can copy a model’s definitions with prototype
    inheritance, but this will generate duplicate data structures. If you want to
    copy a model’s definitions without duplicating data structures, then the answer
    lies in Odoo’s delegation inheritance, which uses the `_inherits` model attribute
    (note the additional `s`).
  prefs: []
  type: TYPE_NORMAL
- en: Traditional inheritance is quite different from the similarly named concept
    in object-oriented programming. Delegation inheritance, in turn, is similar, in
    that a new model can be created to include the features from a parent model. It
    also supports polymorphic inheritance, where we inherit from two or more other
    models.
  prefs: []
  type: TYPE_NORMAL
- en: We operate a hostel that accommodates both rooms and students. To better manage
    our accommodations, it’s essential to integrate student-related information into
    our system. Specifically, for each student, we require comprehensive identification
    and address details, similar to those captured in the partner model. Additionally,
    it’s crucial to maintain records related to room allocation, including the start
    and end dates of each student’s stay and their card number.
  prefs: []
  type: TYPE_NORMAL
- en: Directly adding these fields to the existing partner model isn’t an ideal approach,
    as it would unnecessarily clutter the model with student-specific data that is
    irrelevant for non-student partners. A more effective solution would be to enhance
    the partner model by creating a new model that inherits from it and introduces
    the additional fields required to manage student information. This approach ensures
    a cleaner, more organized, and functionally efficient system to cater to our hostel’s
    unique needs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new library member model should be in its own Python code file, but to
    keep the explanation as simple as possible, we will reuse the `models/hostel_student.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the new model, inheriting from `res.partner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add the fields that are specific to each student:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we should upgrade the add-on module to activate the changes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `_inherits` model attribute sets the parent models that we want to inherit
    from. In this case, we just have one – `res.partner`. Its value is a key-value
    dictionary, where the keys are the inherited models and the values are the field
    names that were used to link to them. These are `m2o` fields that we must also
    define in the model. In our example, `partner_id` is the field that will be used
    to link with the `Partner` parent model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how this works, let’s look at what happens at a database
    level when we create a new member:'
  prefs: []
  type: TYPE_NORMAL
- en: A new record is created in the `res_partner` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new record is created in the `hostel_student` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `partner_id` field of the `hostel_student` table is set to the ID of the
    `res_partner` record that is created for it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member record is automatically linked to a new partner record. It’s just
    an `m2o` relationship, but the delegation mechanism adds some magic so that the
    partner’s fields are seen as if they belong to the member record, and a new partner
    record is also automatically created with the new member.
  prefs: []
  type: TYPE_NORMAL
- en: You may be interested to know that this automatically created partner record
    has nothing special about it. It’s a regular partner, and if you browse the partner
    model, you will be able to find that record (without the additional member data,
    of course). All members are partners, but only some partners are also members.
    So, what happens if you delete a partner record that is also a member? You decide
    by choosing the `ondelete` value for the relation field. For `partner_id`, we
    used `cascade`. This means that deleting the partner will also delete the corresponding
    member. We could have used the more conservative setting, `restrict`, to prohibit
    deleting the partner while it has a linked member. In this case, only deleting
    the member will work.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that delegation inheritance only works for fields, not
    for methods. So, if the partner model has a `do_something()` method, the members
    model will not automatically inherit it.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a shortcut for this inheritance delegation. Instead of creating an
    `_inherits` dictionary, you can use the `delegate=True` attribute in the `m2o`
    field definition. This will work exactly like the `_inherits` option. The main
    advantage is that this is simpler. In the given example, we performed the same
    inheritance delegation as in the previous one, but in this case, instead of creating
    an `_inherits` dictionary, we used the `delegate=True` option in the `partner_id`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: A noteworthy case of delegation inheritance is the users model, `res.users`.
    It inherits from partners (`res.partner`). This means that some of the fields
    that you can see on the user are actually stored in the partner model (notably,
    the `name` field). When a new user is created, we also get a new, automatically
    created partner.
  prefs: []
  type: TYPE_NORMAL
- en: We should also mention that traditional inheritance with `_inherit` can also
    copy features into a new model, although in a less efficient way. This was discussed
    in the *Adding features to a model using* *inheritance* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using abstract models for reusable model features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, there is a particular feature that we want to be able to add to several
    different models. Repeating the same code in different files is a bad programming
    practice; it would be better to implement it once and reuse it.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract models allow us to create a generic model that implements some features
    that can then be inherited by regular models, in order to make that feature available.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will implement a simple archive feature. This adds the `active`
    field to the model (if it doesn’t exist already) and makes an archive method available
    to toggle the `active` flag. This works because `active` is a magic field. If
    it is present in a model by default, the records with `active=False` will be filtered
    out from the queries. We will then add it to the `hostel` `room` model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The archive feature certainly deserves its own add-on module, or at least its
    own Python code file. However, to keep the explanation as simple as possible,
    we will cram it into the `models/hostel_room.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the abstract model for the archive feature. It must be defined in the library
    book model, where it will be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will edit the Hostel Room model to inherit the archive model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An upgrade of the add-on module is required in order for the changes to be activated.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An abstract model is created by a class based on `models.AbstractModel`, instead
    of the usual `models.Model`. It has all the attributes and capabilities of regular
    models; the difference is that ORM will not create an actual representation for
    it in the database. This means that it can’t have any data stored in it. It only
    serves as a template for a reusable feature that will be added to regular models.
  prefs: []
  type: TYPE_NORMAL
- en: Our archive abstract model is quite simple. It just adds the `active` field
    and a method to toggle the value of the `active` flag, which we expect to be used
    later, via a button on the user interface. When a model class is defined with
    the `_inherit` attribute, it inherits the attribute methods of those classes,
    and the attribute methods that are defined in the current class add modifications
    to those inherited features.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism at play here is the same as that of a regular model extension
    (as per the *Adding features to a model using inheritance* recipe). You may have
    noticed that `_inherit` uses a list of model identifiers instead of a string with
    one model identifier. In fact, `_inherit` can have both forms. Using the list
    form allows us to inherit from multiple (usually `Abstract`) classes. In this
    case, we inherit just one, so a text string would be fine. A list was used instead,
    for illustration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A noteworthy built-in abstract model is `mail.thread`, which is provided by
    the `mail (Discuss)` add-on module. On models, it enables the discussion features
    that power the message wall that’s seen at the bottom of many forms.
  prefs: []
  type: TYPE_NORMAL
- en: Other than `AbstractModel`, a third model type is available – `models.TransientModel`.
    This has a database representation like `models.Model`, but the records that are
    created there are supposed to be temporary and regularly purged by a server-scheduled
    job. Other than that, transient models work just like regular models.
  prefs: []
  type: TYPE_NORMAL
- en: '`models.TransientModel` is useful for more complex user interactions, known
    as **wizards**. A wizard is used to request inputs from the user. In [*Chapter
    8*](B20997_08.xhtml#_idTextAnchor388), *Advanced Server-Side Development Techniques*,
    we will explore how to use these for advanced user interaction.'
  prefs: []
  type: TYPE_NORMAL
