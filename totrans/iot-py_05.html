<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 5. Working with Digital Inputs, Polling and Interrupts"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Working with Digital Inputs, Polling and Interrupts</h1></div></div></div><p>In this chapter, we will use digital inputs to make it possible for users to interact with the board while we process the HTTP requests. We will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understand the difference between pull-up and pull-down resistors to connect pushbuttons</li><li class="listitem" style="list-style-type: disc">Wire digital input pins with pushbuttons</li><li class="listitem" style="list-style-type: disc">Use polling to check the pushbutton status with the <code class="literal">mraa</code> and <code class="literal">wiring-x86</code> libraries</li><li class="listitem" style="list-style-type: disc">Combine polling to read digital inputs while running a RESTful API</li><li class="listitem" style="list-style-type: disc">Write code that maintains consistency when we provide shared features with electronic components and APIs</li><li class="listitem" style="list-style-type: disc">Use interrupts and the <code class="literal">mraa</code> library to detect pressed pushbuttons</li><li class="listitem" style="list-style-type: disc">Understand the differences, advantages, and trade-offs between polling and interrupts to detect changes in digital inputs</li></ul></div><div class="section" title="Understanding pushbuttons and pullup resistors"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Understanding pushbuttons and pullup resistors</h1></div></div></div><p>We controlled <a id="id235" class="indexterm"/>the brightness levels for red, green, and blue LEDs with a RESTful API. Then, we replaced the three LEDs with a single RGB LED and <a id="id236" class="indexterm"/>generated lights of different colors with the same RESTful API. Now, we want to make it possible for the users to change the brightness level for the three components with two pushbuttons added to the breadboard:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A pushbutton to turn off all the colors, that is, to set all the colors to a brightness level equal to 0</li><li class="listitem" style="list-style-type: disc">A pushbutton to set all the colors to their maximum brightness levels, that is, to set all the colors to a brightness level equal to 255</li></ul></div><p>When the user presses the pushbutton, also known as a microswitch, it acts like a wire, and therefore, it lets the current flow through the circuit in which it is incorporated. When the pushbutton isn't pressed, the circuit in which it is incorporated is interrupted. Thus, whenever the <a id="id237" class="indexterm"/>user releases the pushbutton, the circuit is interrupted. Obviously, we don't want to short circuit the connection whenever the user presses a pushbutton, and therefore, we will analyze the different possible ways to safely connect a pushbutton to an Intel Galileo Gen 2 board.</p><p>The following <a id="id238" class="indexterm"/>picture shows one of the ways in which we can connect a pushbutton to an Intel Galileo Gen 2 board and uses the GPIO pin number <span class="strong"><strong>0</strong></span> as an input to determine whether the pushbutton is pressed or not. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_05_01.fzz</code> and the following picture is the breadboard view:</p><div class="mediaobject"><img src="images/B05042_05_01.jpg" alt="Understanding pushbuttons and pullup resistors"/></div><p>The following picture shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_05_02.jpg" alt="Understanding pushbuttons and pullup resistors"/></div><p>As seen in <a id="id239" class="indexterm"/>the previous schematic, the GPIO pin labeled <span class="strong"><strong>D0/RX</strong></span>, in the <a id="id240" class="indexterm"/>board's symbol, is connected to a 120Ω resistor with 5% tolerance (brown red brown gold), and wired to the <span class="strong"><strong>IOREF</strong></span> pin. We already know that the pin labeled <span class="strong"><strong>IOREF</strong></span> provides us the IOREF voltage, that is, 5V in our actual configuration. As we might want to work with other voltage configuration in the future, we can always work with the IOREF pin instead of specifically using the <span class="strong"><strong>5V</strong></span> or the <span class="strong"><strong>3V3</strong></span> pins. The GPIO pin labeled <span class="strong"><strong>D0/RX</strong></span> in the board's symbol is also connected to the <span class="strong"><strong>S1</strong></span> pushbutton, wired to the 120Ω resistor and <span class="strong"><strong>GND</strong></span> (ground).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip32"/>Tip</h3><p>The configuration is known as a voltage divider and the 120Ω resistor is called a pull-up resistor.</p></div></div><p>The <a id="id241" class="indexterm"/>pull-up resistor limits the electric current when we press the <span class="strong"><strong>S1</strong></span> pushbutton. As an effect of the pull-up resistor, if we press the <span class="strong"><strong>S1</strong></span> pushbutton, we will read a low value (0V) in the GPIO pin labeled <span class="strong"><strong>D0/RX</strong></span>. When we release the S1 pushbutton, we will read a high value, that is, the IOREF voltage (5V in our actual configuration). </p><p>The situation might be confusing because we read a low value when the button in pressed. However, we can write object-oriented code to encapsulate the behavior for a pushbutton and work with easier to understand states that isolate the way in which the pull-up resistor works.</p><p>It is also <a id="id242" class="indexterm"/>possible to work with a pull-down resistor. We can connect the 120Ω resistor to ground and transform it from a pull-up resistor into a pull-down resistor. The following picture shows how we can connect a pushbutton to an Intel Galileo Gen 2 board with a pull-down resistor and use the GPIO pin number <span class="strong"><strong>0</strong></span> as an input to determine whether the pushbutton is pressed or not. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_05_02.fzz</code> and the following picture is the breadboard view:</p><div class="mediaobject"><img src="images/B05042_05_03.jpg" alt="Understanding pushbuttons and pullup resistors"/></div><p>The following picture shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_05_04.jpg" alt="Understanding pushbuttons and pullup resistors"/></div><p>As seen<a id="id243" class="indexterm"/> in the<a id="id244" class="indexterm"/> previous schematic, in this case, the GPIO pin labeled <span class="strong"><strong>D0/RX</strong></span> in the board's symbol is connected to the <span class="strong"><strong>S1</strong></span> pushbutton and the <span class="strong"><strong>IOREF</strong></span> pin. The other connector of the S1 pushbutton is wired to the 120Ω resistor and this resistor is wired to <span class="strong"><strong>GND</strong></span> (ground).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>In this configuration, the 120Ω resistor is called a pull-down resistor.</p></div></div><p>The pull-down resistor limits the electric current when we press the <span class="strong"><strong>S1</strong></span> pushbutton. As an effect of the pull-down resistor, if we press the <span class="strong"><strong>S1</strong></span> pushbutton, we will read a high value, that is, the IOREF voltage (5V in our actual configuration) in the GPIO pin labeled <span class="strong"><strong>D0/RX</strong></span>. When we release the <span class="strong"><strong>S1</strong></span> pushbutton, we will read a low value (0V). Thus, the pull-down resistor works with the inverse values we read when we use a pull-up resistor.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Wiring digital input pins with pushbuttons"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Wiring digital input pins with pushbuttons</h1></div></div></div><p>Now, we <a id="id245" class="indexterm"/>will use the following pins to connect the two pushbuttons and we will work with pull-up resistors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pin <span class="strong"><strong>1</strong></span> (labeled <span class="strong"><strong>D1/TX</strong></span>) to connect the pushbutton that turns off the three colors</li><li class="listitem" style="list-style-type: disc">Pin <span class="strong"><strong>0</strong></span> (labeled <span class="strong"><strong>D0/RX</strong></span>) to connect the pushbutton that sets the three colors to their maximum brightness levels</li></ul></div><p>After we finish the necessary wirings, we will write the Python code to check whether each pushbutton was pressed while keeping our RESTful API working as expected. This way, we will make it possible for the user to interact with the RGB LED with the pushbuttons and also with the RESTful API. We need the following additional parts to work with this example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Two pushbuttons with two pins</li><li class="listitem" style="list-style-type: disc">Two 120Ω resistors with 5% tolerance (brown red brown gold)</li></ul></div><p>The following diagram shows the components connected to the breadboard, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_05_03.fzz</code> and the following picture is the breadboard view:</p><div class="mediaobject"><img src="images/B05042_05_05.jpg" alt="Wiring digital input pins with pushbuttons"/></div><p>The following picture shows the schematic with the electronic components represented as symbols.</p><div class="mediaobject"><img src="images/B05042_05_06.jpg" alt="Wiring digital input pins with pushbuttons"/></div><p>As seen in<a id="id246" class="indexterm"/> the previous schematic, we added two pushbuttons (<span class="strong"><strong>S1</strong></span> and <span class="strong"><strong>S2</strong></span>) and two 120Ω pull-up resistors (<span class="strong"><strong>R4</strong></span> and <span class="strong"><strong>R5</strong></span>). The GPIO pin labeled <span class="strong"><strong>D0/RX</strong></span> in the board's symbol is connected to the <span class="strong"><strong>S2</strong></span> pushbutton and the <span class="strong"><strong>R4</strong></span> resistor is its pull-up resistor. The GPIO pin labeled <span class="strong"><strong>D1/TX</strong></span> in the board's symbol is connected to the <span class="strong"><strong>S1</strong></span> pushbutton and the R5 resistor is its pull-up resistor. This way, GPIO pin number 0 will be low when the <span class="strong"><strong>S2</strong></span> pushbutton is pressed and GPIO pin number 1 will be low when the <span class="strong"><strong>S1</strong></span> pushbutton is pressed. The <span class="strong"><strong>S1</strong></span> pushbutton is located at the left-hand side in the breadboard while the <span class="strong"><strong>S2</strong></span> pushbutton is located at the right-hand side.</p><p>Now, it is time to insert the components in the breadboard and make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any<a id="id247" class="indexterm"/> wire from the board's pins.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Reading pushbutton statuses with digital inputs and the mraa library"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Reading pushbutton statuses with digital inputs and the mraa library</h1></div></div></div><p>We will<a id="id248" class="indexterm"/> create a new <code class="literal">PushButton</code> class to represent a pushbutton connected to our board that can use either a pull-up or a pull-down resistor. The following lines show the code for the new <code class="literal">PushButton</code> class that works with the <code class="literal">mraa</code> library. The code file for the sample is <code class="literal">iot_python_chapter_05_01.py</code>.</p><div class="informalexample"><pre class="programlisting">import mraa
import time
from datetime import date

class PushButton:
    def __init__(self, pin, pull_up=True):
        self.pin = pin
        self.pull_up = pull_up
        self.gpio = mraa.Gpio(pin)
        self.gpio.dir(mraa.DIR_IN)

    @property
    def is_pressed(self):
        push_button_status = self.gpio.read()
        if self.pull_up:
            # Pull-up resistor connected
            return push_button_status == 0
        else:
            # Pull-down resistor connected
            return push_button_status == 1

    @property
    def is_released(self):
        return not self.is_pressed</pre></div><p>We have to specify the pin number to which the pushbutton is connected when we create an instance of the <code class="literal">PushButton</code> class in the <code class="literal">pin</code> required argument. In case we don't specify additional values, the optional <code class="literal">pull_up</code> argument will be <code class="literal">True</code> and the instance will work as if the pushbutton were connected with a pull-up resistor. If we work with a pull-down resistor, we must pass <code class="literal">False</code> in the <code class="literal">pull_up</code> argument. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">mraa.Gpio</code> instance with the received <code class="literal">pin</code> as its <code class="literal">pin</code> argument, saves its reference in the <code class="literal">gpio</code> attribute and calls its <code class="literal">dir</code> method to configure the pin to be an input pin (<code class="literal">mraa.DIR_IN</code>).</p><p>The class<a id="id249" class="indexterm"/> defines the following two properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">is_pressed</code>: Calls <a id="id250" class="indexterm"/>the <code class="literal">read</code> method for the related <code class="literal">mraa.Gpio</code> instance to retrieve the value from the pin and saved it in the <code class="literal">push_button_status</code> variable. If the pushbutton is connected with a pull-up resistor (<code class="literal">self.pull_up</code> is <code class="literal">True</code>), the code will return <code class="literal">True</code>, indicating that the pushbutton is pressed if the value in <code class="literal">push_button_status</code> is <code class="literal">0</code> (low value). If the pushbutton is connected with a pull-down resistor (<code class="literal">self.pull_up</code> is <code class="literal">False</code>), the code will return <code class="literal">True</code>, indicating that the pushbutton is pressed if the value in <code class="literal">push_button_status</code> is <code class="literal">1</code> (high value).</li><li class="listitem" style="list-style-type: disc"><code class="literal">is_released</code>: Returns <a id="id251" class="indexterm"/>the inverted result of the <code class="literal">is_pressed</code> property.</li></ul></div><p>Now, we can write code that uses the new <code class="literal">PushButton</code> class to create one instance for each of the two pushbuttons and easily check whether they are pressed or not. The new class handles whether the pushbuttons are connected with pull-up or pull-down resistors, and therefore, we just need to check the value of the <code class="literal">is_pressed</code> or <code class="literal">is_released</code> properties without worrying about the specific details about their connection.</p><p>We will integrate the code that considers the statuses of the two pushbuttons in our RESTful API later. First, we will isolate the two pushbuttons in a simple example to understand how we can read their statuses. In this case, we will use polling, that is, a loop that will check whether the pushbuttons are pressed or not. If a pushbutton is pressed, we want the code to print a message in the console output indicating the specific pushbutton that is being pressed.</p><p>The following lines show the Python code that performs the previously explained actions. The code file for the sample is <code class="literal">iot_python_chapter_05_01.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    s1_push_button = PushButton(1)
    s2_push_button = PushButton(0)
    while True:
        # Check whether the S1 pushbutton is pressed
        if s1_push_button.is_pressed:
            print("You are pressing S1.")
        # Check whether the S2 pushbutton is pressed
        if s2_push_button.is_pressed:
            print("You are pressing S2.")
        # Sleep 500 milliseconds (0.5 seconds)
        time.sleep(0.5)</pre></div><p>The<a id="id252" class="indexterm"/> first two lines create two instances of the previously coded <code class="literal">PushButton</code> class. The <span class="strong"><strong>S1</strong></span> pushbutton is connected to GPIO pin number 1 and the <span class="strong"><strong>S2</strong></span> pushbutton is connected to GPIO pin number 0. In both cases, the code doesn't specify a value for the <code class="literal">pull_up</code> argument. Thus, the constructor, that is, the <code class="literal">__init__</code> method, will use the default value for this argument, <code class="literal">True</code>, and the instance will be configured for a pushbutton connected with a pull-up resistor. We need to worry about this when we create the two instances, and then, we work with the names of the variables that hold the instances: <code class="literal">s1_push_button</code> and <code class="literal">s2_push_button</code>.</p><p>Then, the code runs in a loop forever, that is, until you interrupt the execution by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> or the button to stop the process, in case you are using a Python IDE with remote development features to run the code in your board.</p><p>The first line within the <code class="literal">while</code> loop checks the value of the <code class="literal">is_pressed</code> property for the <code class="literal">PushButton</code> instance named <code class="literal">s1_push_button</code> is <code class="literal">True</code>. A <code class="literal">True</code> value means that the pushbutton is pressed at this time, and therefore, the code prints a message to the console output indicating that the S1 pushbutton is being pressed. The next lines within the while loop follow the same procedure for the <code class="literal">PushButton</code> instance named <code class="literal">s2_push_button</code>.</p><p>After we check the statuses for both the pushbuttons, a call to <code class="literal">time.sleep</code> with <code class="literal">0.5</code> as the value for the second argument delays the execution for 500 milliseconds, that is, 0.5 seconds.</p><p>The following line will start the example; don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_05_01.py</pre></div><p>After you run the example, perform the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Press the S1 pushbutton for 1 second</li><li class="listitem" style="list-style-type: disc">Press the S2 pushbutton for 1 second</li><li class="listitem" style="list-style-type: disc">Press both the S1 and S2 pushbuttons for one second</li></ul></div><p>As a result of the previous actions, you will see the following output:</p><div class="informalexample"><pre class="programlisting">You are pressing S1.
You are pressing S2.
You are pressing S1.
You are pressing S2.</pre></div><p>In<a id="id253" class="indexterm"/> this case, we are reading digital inputs with polling. The <code class="literal">mraa</code> library also allows us to work with interrupts and declare interrupt handlers with Python. This way, whenever a user presses a button, the event generates an interrupt and the <code class="literal">mraa</code> library calls the specified interrupt handler. If you have ever worked with event-based programming, you can think about events and event handlers instead of interrupts and interrupt handlers and you will easily understand how things work.</p><p>The interrupt handlers run in a different thread, and the code you can write for them has many limitations. For example, you cannot use the basic types within interrupt handlers. Thus, in this case, it doesn't make sense to work with interrupts and polling makes things easier for us due to the tasks that we have to execute when the user presses any of the two buttons.</p><p>Reading digital inputs with polling as in the previous example has the following advantages compared with the usage of interrupts for the same task:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code is easy to understand and read</li><li class="listitem" style="list-style-type: disc">The flow is easy to understand and we don't have to worry about code running in callbacks</li><li class="listitem" style="list-style-type: disc">We can write all the necessary code to perform actions when the button is pressed without worrying about specific limitations related to interrupt callbacks</li><li class="listitem" style="list-style-type: disc">We don't have to worry about code running in multiple threads</li></ul></div><p>However, reading digital inputs with polling has the following disadvantages compared with the usage of interrupts for the same task:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If we don't keep the pushbutton pressed for a specific amount of time, the code might not detect that the pushbutton has been pressed.</li><li class="listitem" style="list-style-type: disc">If we keep the pushbutton pressed for a long time, the code will behave as if the pushbutton was pressed many times. Sometimes, we don't want this situation to happen.</li><li class="listitem" style="list-style-type: disc">The loop consumes more resources that we can require for other tasks compared with an interrupt triggered event.</li></ul></div><p>In this case, we want users to keep any of the two buttons pressed for at least half a second, and <a id="id254" class="indexterm"/>therefore, we don't need the advantages of interrupts. However, we will use interrupts later in this chapter.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Reading pushbutton statuses and running a RESTful API"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Reading pushbutton statuses and running a RESTful API</h1></div></div></div><p>Now, we <a id="id255" class="indexterm"/>will integrate the code that checks the statuses of the two pushbuttons in our RESTful API. We want to be able to make HTTP requests to the RESTful API and we also want to be able to use the two buttons we have added to the breadboard.</p><p>We have to make Tornado run a periodic callback and write the code that checks the statuses of the two pushbuttons in this callback. We will take the code we wrote in the previous chapter when we created the last version of our RESTful API with the <code class="literal">mraa</code> library and we will use this code as a baseline to add the new features. The code file for the sample was <code class="literal">iot_python_chapter_04_03.py</code>.</p><p>We will add two class attributes and three class methods to the existing <code class="literal">BoardInteraction</code> class. The code file for the sample is <code class="literal">iot_python_chapter_05_02.py</code>.</p><div class="informalexample"><pre class="programlisting">class BoardInteraction:
    # The Red LED is connected to pin ~6
    red_led = AnalogLed(6, 'Red')
    # The Green LED is connected to Pin ~5
    green_led = AnalogLed(5, 'Green')
    # The Blue LED is connected to Pin ~3
    blue_led = AnalogLed(3, 'Blue')
<span class="strong"><strong>    # The push button to reset colors</strong></span>
<span class="strong"><strong>    reset_push_button = PushButton(1)</strong></span>
<span class="strong"><strong>    # The push button to set colors to their maximum brightness</strong></span>
<span class="strong"><strong>    max_brightness_push_button = PushButton(0)</strong></span>

<span class="strong"><strong>    @classmethod</strong></span>
<span class="strong"><strong>    def set_min_brightness(cls):</strong></span>
<span class="strong"><strong>        cls.red_led.set_brightness(0)</strong></span>
<span class="strong"><strong>        cls.green_led.set_brightness(0)</strong></span>
<span class="strong"><strong>        cls.blue_led.set_brightness(0)</strong></span>

<span class="strong"><strong>    @classmethod</strong></span>
<span class="strong"><strong>    def set_max_brightness(cls):</strong></span>
<span class="strong"><strong>        cls.red_led.set_brightness(255)</strong></span>
<span class="strong"><strong>        cls.green_led.set_brightness(255)</strong></span>
<span class="strong"><strong>        cls.blue_led.set_brightness(255)</strong></span>

<span class="strong"><strong>    @classmethod</strong></span>
<span class="strong"><strong>    def check_push_buttons_callback(cls):</strong></span>
<span class="strong"><strong>        # Check whether the reset push button is pressed</strong></span>
<span class="strong"><strong>        if cls.reset_push_button.is_pressed:</strong></span>
<span class="strong"><strong>            print("You are pressing the reset pushbutton.")</strong></span>
<span class="strong"><strong>            cls.set_min_brightness()</strong></span>

<span class="strong"><strong>        # Check whether the maximum brightness push button is pressed</strong></span>
<span class="strong"><strong>        if cls.max_brightness_push_button.is_pressed:</strong></span>
<span class="strong"><strong>            print("You are pressing the maximum brightness pushbutton.")</strong></span>
<span class="strong"><strong>            cls.set_max_brightness()</strong></span>
</pre></div><p>The <a id="id256" class="indexterm"/>previous code adds two class attributes to the <code class="literal">BoardInteraction</code> class: <code class="literal">reset_push_button</code> and <code class="literal">max_brightness_push_button</code>. The <code class="literal">reset_push_button</code> class attribute is an instance of <code class="literal">PushButton</code> with its <code class="literal">pin</code> attribute set to <code class="literal">1</code>. This way, the instance can check the status of the pushbutton connected to GPIO pin number 1. The <code class="literal">max_brightness_push_button</code> class attribute is an instance of <code class="literal">PushButton</code> with its <code class="literal">pin</code> attribute set to <code class="literal">0</code>, and therefore, this instance can check the status of the pushbutton connected to GPIO pin number 0. In addition, the previous code adds the following class methods to the <code class="literal">BoardInteraction</code> class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">set_min_brightness</code>: Calls<a id="id257" class="indexterm"/> the <code class="literal">set_brightness</code> method with <code class="literal">0</code> as an argument for the three <code class="literal">AnalogLed</code> instances saved in the <code class="literal">red_led</code>, <code class="literal">green_led</code> and <code class="literal">blue_led</code> class attributes. This way, the three components of the RGB LED will be turned off.</li><li class="listitem" style="list-style-type: disc"><code class="literal">set_max_brightness</code>: Calls<a id="id258" class="indexterm"/> the <code class="literal">set_brightness</code> method with <code class="literal">255</code> as an argument for the three <code class="literal">AnalogLed</code> instances saved in the <code class="literal">red_led</code>, <code class="literal">green_led</code> and <code class="literal">blue_led</code> class attributes. This way, the three components of the RGB LED will be turned on with their maximum brightness levels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">check_push_buttons_callback</code>: First, checks whether the reset pushbutton is pressed by evaluating the value of the <code class="literal">is_pressed</code> property for<a id="id259" class="indexterm"/> the <code class="literal">PushButton</code> instance that represents the reset pushbutton, that is, <code class="literal">cls.reset_push_button</code>. In case the value for the property is <code class="literal">True</code>, the code prints a message indicating that you are pressing the reset pushbutton and calls the previously described <code class="literal">cls.set_min_brightness</code> class method to turn off the three components of the RGB LED. Then, the code checks whether the maximum brightness pushbutton is pressed by evaluating the value of the <code class="literal">is_pressed</code> property for the <code class="literal">PushButton</code> instance that represents the maximum brightness pushbutton, that is, <code class="literal">cls.max_brightness_push_button</code>. In case the value for the property is <code class="literal">True</code>, the code prints a message indicating that you are pressing the maximum brightness pushbutton and calls the previously described <code class="literal">cls.set_max_brightness</code> class method to turn on the three components of the RGB LED with their maximum brightness levels.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip34"/>Tip</h3><p>It is necessary to add the <code class="literal">@classmethod</code> decorator before the class method header to declare class methods in Python. Instance methods receive <code class="literal">self</code> as the first argument, but class methods receive the current class as the first argument and the parameter name is usually called <code class="literal">cls</code>. In the previous code, we have been using <code class="literal">cls</code> to access the class attributes and class methods for the <code class="literal">BoardInteraction</code> class.</p></div></div><p>The <a id="id260" class="indexterm"/>following lines show the new classes that we must add to our existing code to make it possible to set the minimum and maximum brightness with HTTP requests. We want to be able to have the same features we can command with pushbuttons available in our RESTful API. The code adds the following two classes: <code class="literal">PutMinBrightnessHandler</code> and <code class="literal">PutMaxBrightnessHandler</code>. The code file for the sample is <code class="literal">iot_python_chapter_05_02.py</code>.</p><div class="informalexample"><pre class="programlisting">class PutMinBrightnessHandler(tornado.web.RequestHandler):
    def put(self):
        BoardInteraction.set_min_brightness()
        response = dict(
            red=BoardInteraction.red_led.brightness_value,
            green=BoardInteraction.green_led.brightness_value,
            blue=BoardInteraction.blue_led.brightness_value)
        self.write(response)


class PutMaxBrightnessHandler(tornado.web.RequestHandler):
    def put(self):
        BoardInteraction.set_max_brightness()
        response = dict(
            red=BoardInteraction.red_led.brightness_value,
            green=BoardInteraction.green_led.brightness_value,
            blue=BoardInteraction.blue_led.brightness_value)
        self.write(response)</pre></div><p>The code declares the following two subclasses of <code class="literal">tornado.web.RequestHandler</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PutMinBrightnessHandler</code>: Defines <a id="id261" class="indexterm"/>the <code class="literal">put</code> method that calls the <code class="literal">set_min_brightness</code> class method for the <code class="literal">BoardInteraction</code> class. Then, the code returns a response with the minimum brightness levels that have been translated to output duty cycle percentages in the PWM pins to which the red, green and blue anodes of the RGB LED are connected to.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PutMaxBrightnessHandler</code>: Defines<a id="id262" class="indexterm"/> the <code class="literal">put</code> method that calls the <code class="literal">set_max_brightness</code> class method for the <code class="literal">BoardInteraction</code> class. Then, the code returns a response with the maximum brightness levels that have been translated to output duty cycle percentages in the PWM pins to which the red, green and blue anodes of the RGB LED are connected to.</li></ul></div><p>Now, it is <a id="id263" class="indexterm"/>necessary to add the highlighted lines to the code that creates an instance of the <code class="literal">tornado.web.Application</code> class named <code class="literal">application</code> with the list of request handlers that make up the Web application, that is, the tuples of regular expressions and subclasses of <code class="literal">tornado.web.RequestHandler</code>. The code file for the sample is <code class="literal">iot_python_chapter_05_02.py</code>.</p><div class="informalexample"><pre class="programlisting">application = tornado.web.Application([
    (r"/putredbrightness/([0-9]+)", PutRedBrightnessHandler),
    (r"/putgreenbrightness/([0-9]+)", PutGreenBrightnessHandler),
    (r"/putbluebrightness/([0-9]+)", PutBlueBrightnessHandler),
    (r"/putrgbbrightness/r([0-9]+)g([0-9]+)b([0-9]+)",
     PutRGBBrightnessHandler),
<span class="strong"><strong>    (r"/putminbrightness", PutMinBrightnessHandler),</strong></span>
<span class="strong"><strong>    (r"/putmaxbrightness", PutMaxBrightnessHandler),</strong></span>
    (r"/getredbrightness", GetRedBrightnessHandler),
    (r"/getgreenbrightness", GetGreenBrightnessHandler),
    (r"/getbluebrightness", GetBlueBrightnessHandler),
    (r"/version", VersionHandler)])</pre></div><p>As shown in our previous example, the code creates an instance of the <code class="literal">tornado.web.Application</code> class named <code class="literal">application</code> with the list of request handlers that make up the Web application, that is, the tuples of regular expressions and subclasses of <code class="literal">tornado.web.RequestHandler</code>.</p><p>Finally, it is necessary to replace the <code class="literal">__main__</code> method with a new one because we want to run a periodic callback to check whether any of the two pushbuttons was pressed. The code file for the sample is <code class="literal">iot_python_chapter_05_02.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    print("Listening at port 8888")
    application.listen(8888)
<span class="strong"><strong>    ioloop = tornado.ioloop.IOLoop.instance()</strong></span>
<span class="strong"><strong>    periodic_callback = tornado.ioloop.PeriodicCallback(BoardInteraction.check_push_buttons_callback, 500, ioloop)</strong></span>
<span class="strong"><strong>    periodic_callback.start()</strong></span>
<span class="strong"><strong>    ioloop.start()</strong></span>
</pre></div><p>As <a id="id264" class="indexterm"/>happened in the previous examples, the <code class="literal">__main__</code> method calls the <code class="literal">application.listen</code> method to build an HTTP server for the application with the defined rules on the port number <code class="literal">8888</code>. Then, the code retrieves the global <code class="literal">IOLoop</code> instance and saves it in the <code class="literal">ioloop</code> local variable. We have to use the instance as one of the arguments to create a <code class="literal">tornado.ioloop.PeriodicCallback</code> instance named <code class="literal">periodic_callback</code>.</p><p>The <code class="literal">PeriodicCallback</code> instance allows us to schedule a specified callback to be called periodically. In this case, we specify the <code class="literal">BoardInteraction.check_push_buttons_callback</code> class method as the callback that will be called every 500 milliseconds. This way, we instruct Tornado to run the <code class="literal">BoardInteraction.check_push_buttons_callback</code> class method every 500 milliseconds. In case the method takes more than 500 milliseconds to complete its execution, Tornado will skip subsequent invocations to get back on schedule. After the code creates the <code class="literal">PeriodicCallback</code> instance, the next line calls its <code class="literal">start</code> method.</p><p>Finally, the call to <code class="literal">ioloop.start()</code> starts the server created with <code class="literal">application.listen</code>. This way, the Web application will process the received requests and will also run a callback to check whether the buttons are pressed.</p><p>The following line will start the HTTP server and our new version of the RESTful API. Don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_05_02.py</pre></div><p>After you run the example, press the pushbutton that sets the colors to their maximum brightness for one second. The RGB LED will display a white light and you will see the following output:</p><div class="informalexample"><pre class="programlisting">You are pressing the maximum brightness pushbutton.
Red LED connected to PWM Pin #6 set to brightness 255.
Green LED connected to PWM Pin #5 set to brightness 255.
Blue LED connected to PWM Pin #3 set to brightness 255.</pre></div><p>Now, press<a id="id265" class="indexterm"/> the pushbutton that sets the colors to their minimum brightness for one second. The RGB LED will turn off and you will see the following output:</p><div class="informalexample"><pre class="programlisting">You are pressing the reset pushbutton.
Red LED connected to PWM Pin #6 set to brightness 0.
Green LED connected to PWM Pin #5 set to brightness 0.
Blue LED connected to PWM Pin #3 set to brightness 0.</pre></div><p>With the new RESTful API we can compose the following HTTP verb and request URL:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">PUT http://192.168.1.107:8888/putmaxbrightness</code>
</pre></div><p>The previous request path will match the previously added tuple (<code class="literal">regexp</code>, <code class="literal">request_class</code>) <code class="literal">(r"/putmaxbrightness", PutMaxBrightnessHandler)</code> and Tornado will call the <code class="literal">PutMaxBrightnessHandler.put</code> method. The RGB LED will display a white light, as happened when you pressed the maximum brightness button. The following lines show the response from the HTTP server with the brightness levels that have been set for the three LEDs:</p><div class="informalexample"><pre class="programlisting">{
    "blue": 255, 
    "green": 255, 
    "red": 255
}</pre></div><p>The following HTTP verb and request URL will turn off the RGB LED, as happened when we pressed the pushbutton that sets the colors to their minimum brightness:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">PUT http://192.168.1.107:8888/putminbrightness</code>
</pre></div><p>The following lines show the response from the HTTP server with the brightness levels that have been set for the three LEDs:</p><div class="informalexample"><pre class="programlisting">{
    "blue": 0, 
    "green": 0, 
    "red": 0
}</pre></div><p>Now, press the pushbutton that sets the colors to their maximum brightness for one second. The RGB LED will display a white light. Then, the following three HTTP verbs and request URLs will retrieve the brightness level for each of the colors. All the requests will return <code class="literal">255</code> as the current value. We set the brightness level with the pushbutton, but the code <a id="id266" class="indexterm"/>has the same effect as if we were making API calls to change the colors. We kept the consistency for our application.</p><div class="informalexample"><pre class="programlisting">
<code class="literal">GET http://192.168.1.107:8888/getredbrightness</code>
<code class="literal">GET http://192.168.1.107:8888/getgreenbrightness</code>
<code class="literal">GET http://192.168.1.107:8888/getbluebrightness</code>
</pre></div><p>If we work with HTTPie, the following commands will do the job:</p><div class="informalexample"><pre class="programlisting">http –b GET http://192.168.1.107:8888/getredbrightness
http –b GET http://192.168.1.107:8888/getgreenbrightness
http –b GET http://192.168.1.107:8888/getbluebrightness</pre></div><p>The following lines show the responses from the three requests:</p><div class="informalexample"><pre class="programlisting">{
    "red": 255
}
{
    "green": 255
}
{
    "blue": 255
}</pre></div><p>We created methods that we could use in both an API call and when the user presses the pushbuttons. We can process HTTP requests and run actions when the user presses pushbuttons. As we build our RESTful API with Tornado, we had to create and configure a <code class="literal">PeriodicCallback</code> instance to make it possible to check whether the pushbuttons are pressed every 500 milliseconds.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip35"/>Tip</h3><p>It is very important to take into account consistency when we add features that we can control with pushbuttons or other electronic components that interact with the board. In this case, we made sure that when the user pressed the pushbuttons and changed the brightness values for the three colors, the brightness values read with API calls were exactly the values set. We worked with object-oriented code and with the same methods, and therefore, it was easy to keep consistency.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Reading digital inputs with the wiring-x86 library"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Reading digital inputs with the wiring-x86 library</h1></div></div></div><p>So far, we <a id="id267" class="indexterm"/>have been using the <code class="literal">mraa</code> library to read digital inputs. However, in the first chapter, we also installed the <code class="literal">wiring-x86</code> library. We can change just a few lines of our object-oriented code to replace the <code class="literal">mraa</code> library with the <code class="literal">wiring-x86</code> one to check whether the pushbuttons were pressed.</p><p>We will take the code we wrote in the previous chapter when we created the last version of our RESTful API with the <code class="literal">wiring-x86</code> library and we will use this code as a baseline to add the new features. The code file for the sample was <code class="literal">iot_python_chapter_04_04.py</code>.</p><p>First, we will create a new version of the <code class="literal">PushButton</code> class to represent a pushbutton connected to our board that can use either a pull-up or a pull-down resistor. The following lines show the code for the new <code class="literal">PushButton</code> class that works with the <code class="literal">wiring-x86</code> library. The code file for the sample is <code class="literal">iot_python_chapter_05_03.py</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from wiringx86 import GPIOGalileoGen2 as GPIO</strong></span>

class PushButton:
    def __init__(self, pin, pull_up=True):
        self.pin = pin
        self.pull_up = pull_up
<span class="strong"><strong>        self.gpio = Board.gpio</strong></span>
<span class="strong"><strong>        pin_mode = self.gpio.INPUT_PULLUP if pull_up else self.gpio.INPUT_PULLDOWN</strong></span>
<span class="strong"><strong>        self.gpio.pinMode(pin, pin_mode)</strong></span>

    @property
    def is_pressed(self):
<span class="strong"><strong>        push_button_status = self.gpio.digitalRead(self.pin)</strong></span>
        if self.pull_up:
            # Pull-up resistor connected
            return push_button_status == 0
        else:
            # Pull-down resistor connected
            return push_button_status == 1

    @property
    def is_released(self):
        return not self.is_pressed</pre></div><p>We just needed to change a few lines from the previous code of the <code class="literal">PushButton</code> class, that is, the version that worked with the <code class="literal">mraa</code> library. The new lines that interact with the <code class="literal">wiring-x86</code> library are highlighted in the previous code. The constructor, that is, the <code class="literal">__init__</code> method receives the same argument as the <code class="literal">PushButton</code> class that worked with the <code class="literal">mraa</code> library. In<a id="id268" class="indexterm"/> this case, this method saves a reference to the <code class="literal">Board.gpio</code> class attribute in <code class="literal">self.gpio</code>. Then, the code determines the value of the <code class="literal">pin_mode</code> local variable based on the value of the <code class="literal">pull_up</code> parameter. If <code class="literal">pull_up</code> is <code class="literal">true</code>, the value will be <code class="literal">self.gpio.INPUT_PULLUP</code> and <code class="literal">self.gpio.INPUT_PULLDOWN</code> otherwise. Finally, the constructor calls the <code class="literal">self.gpio.pinMode</code> method with the received <code class="literal">pin</code> as its <code class="literal">pin</code> argument and <code class="literal">pin_mode</code> as its mode argument. This way, we configure the pin to be a digital input pin with the appropriate pull-up or pull-down resistor. All the <code class="literal">PushButton</code> instances will save a reference to the same <code class="literal">Board.gpio</code> class attribute that created an instance of the <code class="literal">GPIO</code> class, specifically, the <code class="literal">wiringx86.GPIOGalileoGen2</code> class with its <code class="literal">debug</code> argument set to <code class="literal">False</code> to avoid unnecessary debug information for the low-level communications.</p><p>The <code class="literal">is_pressed</code> property calls the <code class="literal">digitalRead</code> method for the GPIO instance (<code class="literal">self.gpio</code>) to set retrieve the digital value for the pin configured as a digital input. The <code class="literal">self.pin</code> attribute specifies the <code class="literal">pin</code> value for the <code class="literal">analogRead</code> method call. The rest of the code for the <code class="literal">is_pressed</code> property and the <code class="literal">PushButton</code> class remains the same as the version that works with the <code class="literal">mraa</code> library.</p><p>Then, it is necessary to make the same edits we made in the previous example to create the new version of the <code class="literal">BoardInteraction</code> class, add the <code class="literal">PutMinBrightnessHandler</code> and <code class="literal">PutMaxBrightnessHandler</code> classes, create the <code class="literal">tornado.web.Application</code> instance and the new version of the <code class="literal">__main__</code> method that created and configured the <code class="literal">PeriodicCallback</code> instance. Thus, the rest of the code for our RESTful API remains the same one that we have used for the previous example. There is no need to make changes to the rest of the code because it will automatically work with the new <code class="literal">PushButton</code> class and there were no changes in the arguments for its constructor or its properties.</p><p>The following line will start the HTTP server and our new version of the RESTful API that works with the <code class="literal">wiring-x86</code> library. Don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client, as explained in the previous chapter.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_05_03.py</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip36"/>Tip</h3><p>We can press the pushbuttons and then make the same HTTP requests we made in our previous example to check that we can achieve exactly the same results with the <code class="literal">wiring-x86</code> library.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using interrupts to detect pressed pushbuttons"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Using interrupts to detect pressed pushbuttons</h1></div></div></div><p>Previously, we<a id="id269" class="indexterm"/> analyzed the advantages of disadvantages of reading digital inputs with polling as in the previous examples compared with the usage of interrupts for the same task. If we keep any of the pushbuttons pressed for a long time, the code behaves as if the pushbutton was pressed many times. Now, we don't want this situation to happen, and therefore, we will use interrupts instead of polling to detect when the pushbuttons are pressed.</p><p>Before we start editing our code, it is necessary to make changes to our existing wirings. The problem is that not all the GPIO pins support interrupts. In fact, pins number 0 and 1 don't support interrupts and we have our pushbuttons connected to them. In <a class="link" href="ch01.html" title="Chapter 1. Understanding and Setting up the Base IoT Hardware">Chapter 1</a>, <span class="emphasis"><em>Understanding and Setting up the Base IoT Hardware</em></span> when we learned about the I/O pins included in the Intel Galileo Gen 2 board, we understood that the pins labeled with a tilde symbol (<span class="strong"><strong>~</strong></span>) as a prefix for the number can be used as PWM output pins. The fact is that the pins labeled with a tilde symbol (<span class="strong"><strong>~</strong></span>) as a prefix for the number also supports interrupts.</p><p>Thus, we can move the wire that connects the reset pushbutton that turns off the three colors from pin <span class="strong"><strong>1</strong></span> to pin <span class="strong"><strong>~11</strong></span>, and move the wire that connects the pushbutton that sets the three colors to their maximum brightness from pin <span class="strong"><strong>0</strong></span> to pin <span class="strong"><strong>~10</strong></span>. </p><p>The following diagram shows the components connected to the breadboard, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_05_04.fzz</code> and the following picture is the breadboard view:</p><div class="mediaobject"><img src="images/B05042_05_07.jpg" alt="Using interrupts to detect pressed pushbuttons"/></div><p>The following picture shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_05_08.jpg" alt="Using interrupts to detect pressed pushbuttons"/></div><p>The <a id="id270" class="indexterm"/>GPIO pin labeled <span class="strong"><strong>D10 PWM/SS</strong></span> in the board's symbol is connected to the <span class="strong"><strong>S2</strong></span> pushbutton and the <span class="strong"><strong>R4</strong></span> resistor is its pull-up resistor. The GPIO pin labeled <span class="strong"><strong>D11 PWM/MOSI</strong></span> in the board's symbol is connected to the <span class="strong"><strong>S1</strong></span> pushbutton and the <span class="strong"><strong>R5</strong></span> resistor is its pull-up resistor. This way, GPIO pin number 10 will be low when the <span class="strong"><strong>S2</strong></span> pushbutton is pressed and GPIO pin number 11 will be low when the <span class="strong"><strong>S1</strong></span> pushbutton is pressed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip37"/>Tip</h3><p>The signal will fall from high to low when the pushbutton is pressed, and therefore, we are interested in the interrupt that is generated when the signal falls because it indicates that the pushbutton has been pressed. If the user keeps the pushbutton pressed, the signal won't fall many times, and the GPIO pin will stay in the low level. Thus, only one interrupt will be fired when we are observing the fall from high to low and we won't have multiple calls to the interrupt handler code even if the user keeps the button pressed for a long time.</p></div></div><p>Remember <a id="id271" class="indexterm"/>that the <span class="strong"><strong>S1</strong></span> pushbutton is located at the left-hand side in the breadboard while the <span class="strong"><strong>S2</strong></span> pushbutton is located at the right-hand side. Now, it is time to make the changes to the wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before removing any wire from the board's pins. After we finish the changes in the wirings, we will write the Python code to detect when the user presses the pushbuttons with interrupts instead of working with polling.</p><p>We will take the code we wrote in the previous example when we created the last version of our RESTful API with the <code class="literal">mraa</code> library and we will use this code as a baseline to add the new features. The code file for the sample was <code class="literal">iot_python_chapter_05_02.py</code>.</p><p>We will create a new <code class="literal">PushButtonWithInterrupt</code> class to represent a pushbutton connected to our board that can use either a pull-up or a pull-down resistor and will specify the callback that needs to be called when the button is pressed, that is, the interrupt handler. When the button is pressed, an interrupt will occur and the specified callback will be executed as the interrupt handler. The following lines show the code for the new <code class="literal">PushButtonWithInterrupt</code> class that works with the <code class="literal">mraa</code> library. The code file for the sample is <code class="literal">iot_python_chapter_05_04.py</code>.</p><div class="informalexample"><pre class="programlisting">import mraa
import time
from datetime import date

class PushButtonWithInterrupt:
    def __init__(self, pin, pyfunc, args, pull_up=True):
        self.pin = pin
        self.pull_up = pull_up
        self.gpio = mraa.Gpio(pin)
        self.gpio.dir(mraa.DIR_IN)
        mode = mraa.EDGE_FALLING if pull_up else mraa.EDGE_RISING
        result = self.gpio.isr(mode, pyfunc, args)
        if result != mraa.SUCCESS:
            raise Exception("I could not configure ISR on pin {0}".format(pin))

    def __del__(self):
        self.gpio.isrExit()</pre></div><p>We have to specify the following arguments when we create an instance of the <code class="literal">PushButtonWithInterrupt</code> class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The pin number to which the pushbutton is connected in the <code class="literal">pin</code> argument</li><li class="listitem" style="list-style-type: disc">The function that will be called when the interrupt is triggered, that is, the interrupt handler function, in the <code class="literal">pyfunc</code> argument</li><li class="listitem" style="list-style-type: disc">The arguments that will be passed to the interrupt handler function, in the <code class="literal">args</code> argument</li></ul></div><p>In case <a id="id272" class="indexterm"/>we don't specify additional values, the optional <code class="literal">pull_up</code> argument will be <code class="literal">True</code> and the instance will work as if the pushbutton were connected with a pull-up resistor. If we work with a pull-down resistor, we must pass <code class="literal">False</code> in the <code class="literal">pull_up</code> argument.</p><p>The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">mraa.Gpio</code> instance with the received <code class="literal">pin</code> as its <code class="literal">pin</code> argument, saves its reference in the <code class="literal">gpio</code> attribute and calls its <code class="literal">dir</code> method to configure the pin to be an input pin (<code class="literal">mraa.DIR_IN</code>). Then, the code determines the value of the <code class="literal">mode</code> local variable based on the value of the <code class="literal">pull_up</code> parameter. If <code class="literal">pull_up</code> is <code class="literal">true</code>, the value will be <code class="literal">mraa.EDGE_FALLING</code> and <code class="literal">mraa.EDGE_RISING</code> otherwise. The <code class="literal">mode</code> local variable holds the edge mode that will trigger the interrupt. When we work with pull-up resistors and the user presses a pushbutton, the signal will fall from high to low, and therefore, we want an edge falling scenario to trigger the interrupt that indicates the button has been pressed.</p><p>Then, the code calls the <code class="literal">self.gpio.isr</code> method with the received <code class="literal">pin</code> as its <code class="literal">pin</code> argument, the local <code class="literal">mode</code> variable as its <code class="literal">mode</code> argument, and the received <code class="literal">pyfunc</code> and <code class="literal">args</code> as its <code class="literal">pyfunc</code> and <code class="literal">args</code> arguments. This way, we set the callback to be called when the pin value changes because a pushbutton was pressed. As we determined the appropriate value for the <code class="literal">mode</code> local variable before, we will configure the appropriate edge mode that will trigger an interrupt when the button is pressed based on the usage of pull-up or pull-down resistors. As previously explained, not all the GPIO pins support interrupts, and therefore, it is necessary to check the results of calling the <code class="literal">self.gpio.isr</code> method. In case an interrupt handler has already been set to the pin with a previous call to the <code class="literal">self.gpio.isr</code> method wouldn't return an <code class="literal">mraa.SUCCESS</code> value.</p><p>The <code class="literal">PushButtonWithInterrupt</code> class also declares a <code class="literal">__del__</code> method that will be called before Python removes an instance of this class from memory, that is, when the object becomes inaccessible and gets deleted by the garbage-collection mechanism. The method just calls the <code class="literal">self.gpio.isrExit</code> method to remove the interrupt handler associated to the pin.</p><p>We will <a id="id273" class="indexterm"/>replace the two class attributes in the existing <code class="literal">BoardInteraction</code> class. Instead of working with <code class="literal">PushButton</code> instances, we will work with <code class="literal">PushButtonWithInterrupt</code> instances. The class methods declared in the class remain the same as in the code we are using as a baseline but they aren't included in the next lines. The code file for the sample is <code class="literal">iot_python_chapter_05_04.py</code>.</p><div class="informalexample"><pre class="programlisting">class BoardInteraction:
    # The Red LED is connected to pin ~6
    red_led = AnalogLed(6, 'Red')
    # The Green LED is connected to Pin ~5
    green_led = AnalogLed(5, 'Green')
    # The Blue LED is connected to Pin ~3
    blue_led = AnalogLed(3, 'Blue')
<span class="strong"><strong>    # The push button to reset colors</strong></span>
<span class="strong"><strong>    reset_push_button = PushButtonWithInterrupt(11, set_min_brightness_callback, set_min_brightness_callback)</strong></span>
<span class="strong"><strong>    # The push button to set colors to their maximum brightness</strong></span>
<span class="strong"><strong>    max_brightness_push_button = PushButtonWithInterrupt(10, set_max_brightness_callback, set_max_brightness_callback)</strong></span>
</pre></div><p>The highlighted lines of code declare two class attributes for the <code class="literal">BoardInteraction</code> class: <code class="literal">reset_push_button</code> and <code class="literal">max_brightness_push_button</code>. The <code class="literal">reset_push_button</code> class attribute is an instance of <code class="literal">PushButtonWithInterrupt</code> with its <code class="literal">pin</code> attribute set to <code class="literal">11</code> and its interrupt handler set to the <code class="literal">set_min_brightness_callback</code> function that we will declare later. This way, the instance will make all the necessary configurations to call the <code class="literal">set_min_brightness_callback</code> function when the user presses the pushbutton connected to GPIO pin number 11. The <code class="literal">max_brightness_push_button</code> class attribute is an instance of <code class="literal">PushButtonWithInterrupt</code> with its <code class="literal">pin</code> attribute set to <code class="literal">10</code>, and therefore, will make all the necessary configurations to call the <code class="literal">set_max_brightness_callback</code> function when the user presses the pushbutton connected to GPIO pin number 10.</p><p>Now, it is necessary to declare the functions that will be called when the interrupts are triggered: <code class="literal">set_min_brightness_callback</code> and <code class="literal">set_max_brightness_callback</code>. Notice that the functions are declared as functions and they aren't methods of any class.</p><div class="informalexample"><pre class="programlisting">def set_max_brightness_callback(args):
    print("You have pressed the maximum brightness pushbutton.")
    BoardInteraction.set_max_brightness()


def set_min_brightness_callback(args):
    print("You have pressed the reset pushbutton.")
    BoardInteraction.set_min_brightness()</pre></div><p>Both <a id="id274" class="indexterm"/>functions declared in the previous code print a message indicating that a specific button has been pressed and call either the <code class="literal">BoardInteraction.set_max_brightness</code> or the <code class="literal">BoardInteraction.set_min_brightness</code> class method. We already know these class methods from our previous examples and we didn't have to make any changes to them.</p><p>Finally, it is necessary to replace the <code class="literal">__main__</code> method with a new one because we don't need to run a periodic callback anymore. Now, our <code class="literal">PushButtonWithInterrupt</code> instances configure the interrupt handlers that will be called whenever a pushbutton is pressed. The code file for the sample is <code class="literal">iot_python_chapter_05_04.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    print("Listening at port 8888")
    application.listen(8888)
    ioloop = tornado.ioloop.IOLoop.instance()
    ioloop.start()</pre></div><p>When the <code class="literal">__main__</code> method starts running, the <code class="literal">BoardInteraction</code> class already executed the code that creates the two <code class="literal">PushButtonWithInterrupt</code> instances, and therefore, the interrupt handlers will run whenever we press a pushbutton. The <code class="literal">__main__</code> method just builds and starts the HTTP server.</p><p>The following line will start the HTTP server and our new version of the RESTful API. Don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_05_04.py</pre></div><p>After you run the example, press the pushbutton that sets the colors to their maximum brightness for 5 seconds. The RGB LED will display a white light and you will see the following output:</p><div class="informalexample"><pre class="programlisting">You are pressing the maximum brightness pushbutton.
Red LED connected to PWM Pin #6 set to brightness 255.
Green LED connected to PWM Pin #5 set to brightness 255.
Blue LED connected to PWM Pin #3 set to brightness 255.</pre></div><p>You<a id="id275" class="indexterm"/> were pressing the pushbutton for 5 seconds but the output displayed the messages indicating that you were pressing the button just once. The GPIO pin number 10 signal went from high to low once when you pressed the button, and therefore, the <code class="literal">mraa.EDGE_FALLING</code> interrupt was fired and the configured interrupt handler (<code class="literal">set_max_brightness_callback</code>) was executed. You kept the pushbutton pressed, but the signal stayed in the low value, and therefore, the interrupt wasn't triggered again.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip38"/>Tip</h3><p>Obviously, when you want to run code just once when a pushbutton is pressed even for a long time, the usage of interrupt handlers provides the necessary precision that polling makes more complex to achieve.</p></div></div><p>Now, press the pushbutton that sets the colors to their minimum brightness for 10 seconds. The RGB LED will turn off and you will see the following output:</p><div class="informalexample"><pre class="programlisting">You are pressing the reset pushbutton.
Red LED connected to PWM Pin #6 set to brightness 0.
Green LED connected to PWM Pin #5 set to brightness 0.
Blue LED connected to PWM Pin #3 set to brightness 0.</pre></div><p>As happened with the other pushbutton, you were pressing the pushbutton for many seconds but the output displayed the messages indicating that you were pressing the button just once. The GPIO pin number 11 signal went from high to low once when you pressed the button, and therefore, the <code class="literal">mraa.EDGE_FALLING</code> interrupt was fired and the configured interrupt handler (<code class="literal">set_min_brightness_callback</code>) was executed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip39"/>Tip</h3><p>We can make the same HTTP requests we made in our previous examples to check that we can achieve exactly the same results with the new code that works with interrupt handlers while running the HTTP server.</p></div></div><p>We can process HTTP requests and run interrupt handlers when the user presses pushbuttons. We improved accuracy compared with the previous version in which the code acted as if the pushbuttons were pressed many times when the user kept the pushbuttons for a long time. In addition, we removed the periodic callback.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip40"/>Tip</h3><p>Whenever we have to read digital inputs, we can decide between working with polling or interrupt handlers based on the specific requirements we have for our projects. Sometimes, interrupt handlers are the best solution but in other cases polling is more suitable. It is very important to know that the <code class="literal">wiring-x86</code> library doesn't allow us to work with interrupt handlers for digital inputs, and therefore, in case we decide to use them, we have to work with the <code class="literal">mraa</code> library.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As an effect of using a pull-up resistor with a pushbutton, we will read the following value when the pushbutton is pressed in the GPIO pin to which it is connected:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A low value (0V).</li><li class="listitem">A high value, that is, the IOREF voltage.</li><li class="listitem">A value between 1V and 3.3V.</li></ol></div></li><li class="listitem">As an effect of using a pull-up resistor with a pushbutton, we will read the following value when the pushbutton is released in the GPIO pin to which it is connected:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A low value (0V).</li><li class="listitem">A high value, that is, the IOREF voltage.</li><li class="listitem">A value between 1V and 3.3V.</li></ol></div></li><li class="listitem">If we check a pushbutton status by reading the GPIO pin value to which it is connected with polling, the loop runs every 0.5 seconds and the user keeps the pushbutton pressed for 3 seconds:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The code will behave as if the pushbutton was pressed more than once.</li><li class="listitem">The code will behave as if the pushbutton was pressed just once.</li><li class="listitem">The code will behave as if the pushbutton was never pressed.</li></ol></div></li><li class="listitem">We have an interrupt handler for a pushbutton with the interrupt edge mode set to <code class="literal">mraa.EDGE_FALLING</code>, and the pushbutton is connected with a pull-up resistor. If the user keeps the pushbutton pressed for 3 seconds:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The code will behave as if the pushbutton was pressed more than once.</li><li class="listitem">The code will behave as if the pushbutton was pressed just once.</li><li class="listitem">The code will behave as if the pushbutton was never pressed.</li></ol></div></li><li class="listitem">In the Intel Galileo Gen 2 board, the pins labeled with the following symbol as a prefix for the number can be configured with interrupt handlers for digital inputs in the <code class="literal">mraa</code> library:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Hash sign (<span class="strong"><strong>#</strong></span>).</li><li class="listitem">Dollar sign (<span class="strong"><strong>$</strong></span>).</li><li class="listitem">Tilde symbol (<span class="strong"><strong>~</strong></span>).</li></ol></div></li></ol></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Summary</h1></div></div></div><p>In this chapter, we understood the difference between pull-up and pull-down resistors to wire pushbuttons and read their status with the <code class="literal">mraa</code> and <code class="literal">wiring-x86</code> libraries. We understood the difference between reading the pushbutton statuses with polling and working with interrupts and interrupt handlers.</p><p>We created consistent code that allowed the user to perform the same actions with either pushbuttons in the breadboard or HTTP request. We combined code that reacts to changes in the statuses of the pushbuttons with a RESTful API built with Tornado Web server. As in the previous chapters, we took advantage of Python's object-oriented features and we created classes to encapsulate pushbuttons and the necessary configurations with the <code class="literal">mraa</code> and <code class="literal">wiring-x86</code> libraries. Our code is easy to read and understand and we can easily switch the underlying low-level library.</p><p>Now that we were able to read digital inputs in different ways and configurations that made is possible for users to interact with our IoT device while it processed HTTP requests, we can work with more complex communications capabilities included in the board and take advantage of its storage, which are the topics of the next chapter.</p></div></div>
</body></html>