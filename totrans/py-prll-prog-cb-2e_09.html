<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Python Debugging and Testing</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This last chapter will introduce two important software engineering </span><span><span class="koboSpan" id="kobo.3.1">topics</span></span><span class="koboSpan" id="kobo.4.1">—debugging and testing—that are important steps in the software development process. </span></p>
<p><span class="koboSpan" id="kobo.5.1">The first part of the chapter is focused on code debugging. </span><span class="koboSpan" id="kobo.5.2">A bug is a mistake in a program and can cause different problems that may be more or less serious depending on the situation. To encourage programmers to search for bugs, special software tools are used, called </span><strong><span class="koboSpan" id="kobo.6.1">debuggers</span></strong><em><span class="koboSpan" id="kobo.7.1">;</span></em><span class="koboSpan" id="kobo.8.1"> using these software tools, we have the ability to find errors or malfunctions within a program by taking advantage of specific debugging functions, an activity that exists precisely for identifying the portion of software affected by a bug.</span></p>
<p><span class="koboSpan" id="kobo.9.1">In the second part, the main topic is </span><em><span class="koboSpan" id="kobo.10.1">software testing: </span></em><span class="koboSpan" id="kobo.11.1"> it is a process used to identify deficiencies of </span><em><span class="koboSpan" id="kobo.12.1">correctness</span></em><span class="koboSpan" id="kobo.13.1">, </span><em><span class="koboSpan" id="kobo.14.1">completeness</span></em><span class="koboSpan" id="kobo.15.1">, and </span><em><span class="koboSpan" id="kobo.16.1">reliability</span></em><span class="koboSpan" id="kobo.17.1"> in a software product that is being developed. </span></p>
<p><span class="koboSpan" id="kobo.18.1">In this context, we will, therefore, examine the three most important Python tools for debugging code</span><span><span class="koboSpan" id="kobo.19.1"> in action.</span></span><span class="koboSpan" id="kobo.20.1"> These are </span><kbd><span class="koboSpan" id="kobo.21.1">winpdb-reborn</span></kbd><span><span class="koboSpan" id="kobo.22.1">, which involves debugging with a visualization tool; </span><kbd><span class="koboSpan" id="kobo.23.1">pdb</span></kbd><span class="koboSpan" id="kobo.24.1">, the debugger from the Python standard library; and</span></span> <kbd><span class="koboSpan" id="kobo.25.1">rpdb</span></kbd><span class="koboSpan" id="kobo.26.1">, where </span><kbd><span class="koboSpan" id="kobo.27.1">r</span></kbd><span class="koboSpan" id="kobo.28.1"> stands for remote, meaning that it is code debugging from a remote machine</span><em><span class="koboSpan" id="kobo.29.1">.</span></em></p>
<p><span class="koboSpan" id="kobo.30.1">Regarding software testing, we will examine the following tools: </span><kbd><span class="koboSpan" id="kobo.31.1">unittest</span></kbd><span class="koboSpan" id="kobo.32.1"> and </span><kbd><span class="koboSpan" id="kobo.33.1">nose</span></kbd><span class="koboSpan" id="kobo.34.1">.</span></p>
<p><span class="koboSpan" id="kobo.35.1">These are frameworks for developing unit tests, whereby the unit is the minimum component of a program within an independent operation.</span></p>
<p><span class="koboSpan" id="kobo.36.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.37.1">What is debugging?</span></li>
<li><span class="koboSpan" id="kobo.38.1">What is software testing?</span></li>
<li><span class="koboSpan" id="kobo.39.1">Debugging using Winpdb Reborn</span></li>
<li><span class="koboSpan" id="kobo.40.1">Interacting with </span><kbd><span class="koboSpan" id="kobo.41.1">pdb</span></kbd></li>
<li><span class="koboSpan" id="kobo.42.1">Implementing </span><kbd><span class="koboSpan" id="kobo.43.1">rpdb</span></kbd><span class="koboSpan" id="kobo.44.1"> for debugging</span></li>
<li><span class="koboSpan" id="kobo.45.1">Dealing with </span><kbd><span class="koboSpan" id="kobo.46.1">unittest</span></kbd></li>
<li><span class="koboSpan" id="kobo.47.1">Application testing using </span><kbd><span class="koboSpan" id="kobo.48.1">nose</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">What is debugging?</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The term </span><em><span class="koboSpan" id="kobo.3.1">debugging</span></em><span class="koboSpan" id="kobo.4.1"> indicates the activity of identifying the portion of code in which one or more errors (bugs) </span><span><span class="koboSpan" id="kobo.5.1">are </span></span><span class="koboSpan" id="kobo.6.1">detected in software following its use.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The error can be localized during the testing phase of the program; that is when it is still in the development phase and is not yet ready to be used by the end-user, or during the use of the program by the latter. </span><span class="koboSpan" id="kobo.7.2">After finding the error, the debugging phase ensues and identifies the software part </span><span><span class="koboSpan" id="kobo.8.1">in which the error lies, which is sometimes very complex</span></span><span class="koboSpan" id="kobo.9.1">.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Nowadays, this activity is supported by specific applications and debuggers, which show the execution to the programmer using step-by-step software instructions, allowing the viewing and analysis of the inputs and outputs of the program itself </span><span><span class="koboSpan" id="kobo.11.1">at the same time</span></span><span class="koboSpan" id="kobo.12.1">.</span></p>
<p><span class="koboSpan" id="kobo.13.1">Before these tools were available for the activity of identifying and correcting errors (and even now, in the absence of them), the simplest (but also least effective) techniques for code inspection were printing a file or </span><span><span class="koboSpan" id="kobo.14.1">printing </span></span><span class="koboSpan" id="kobo.15.1">the instructions </span><span><span class="koboSpan" id="kobo.16.1">on the screen </span></span><span class="koboSpan" id="kobo.17.1">that the program was executing.</span></p>
<p><span class="koboSpan" id="kobo.18.1">Debugging is one of the most important operations for the development of a program. </span><span class="koboSpan" id="kobo.18.2">It is often extremely difficult due to the complexity of the software that is being developed. </span><span class="koboSpan" id="kobo.18.3">It is even delicate due to the risk of introducing new errors or behaviors that are not in line with those desired in the attempt to correct those for which the activity was undertaken.</span></p>
<p><span class="koboSpan" id="kobo.19.1">Although the task of perfecting software using </span><span><span class="koboSpan" id="kobo.20.1">debugging is</span></span><span class="koboSpan" id="kobo.21.1"> unique every time and constitutes a story in itself, some general principles are always applicable. </span><span class="koboSpan" id="kobo.21.2">In particular, in the context of software applications, it is possible to recognize the following four </span><em><span class="koboSpan" id="kobo.22.1">debugging phases</span></em><span class="koboSpan" id="kobo.23.1">, summarized in the following diagram:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.24.1"><img src="assets/16de8223-a2d3-4378-8677-70527c657df8.png" style="width:17.00em;height:26.00em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.25.1">Debugging phases</span></div>
<div class="packt_infobox"><span class="koboSpan" id="kobo.26.1">Of course, Python offers the developer numerous debugging tools (see </span><a href="https://wiki.python.org/moin/PythonDebuggingTools"><span class="koboSpan" id="kobo.27.1">https://wiki.python.org/moin/PythonDebuggingTools</span></a><span class="koboSpan" id="kobo.28.1"> for a list of Python debuggers). </span><span class="koboSpan" id="kobo.28.2">In this chapter, we will consider Winpdb Reborn, </span><kbd><span class="koboSpan" id="kobo.29.1">rpdb</span></kbd><span class="koboSpan" id="kobo.30.1">, and </span><kbd><span class="koboSpan" id="kobo.31.1">pdb</span></kbd><span class="koboSpan" id="kobo.32.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">What is software testing?</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As mentioned in the introduction of this chapter, software testing is a process used to identify deficiencies of correctness, completeness, and reliability in a software product that is being developed.</span></p>
<p><span class="koboSpan" id="kobo.3.1">With this activity, we, therefore, want to ensure the quality of the product by searching search for defects, or a sequence of instructions and procedures that, when executed with particular input data and in particular operating environments, generate malfunctions. </span><span><span class="koboSpan" id="kobo.4.1">A malfunction is a behavior of the software that is not expected by the user; therefore, it is different from the specifications and from the implicit or explicit requirements defined for such applications. </span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The purpose of testing is, therefore, to detect defects through malfunctions, so as to minimize the probability of such malfunctions occurring in the normal use of the software product. </span><span class="koboSpan" id="kobo.5.2">Testing cannot establish that a product functions correctly under all possible conditions of execution, but it can highlight defects under specific conditions.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In fact, given the impossibility of testing all the input combinations and the possible software and hardware environments in which the application may be operating, the probability of malfunctions cannot be reduced to zero, but it must be reduced to a minimum in order to be acceptable to the user.</span></p>
<p><span class="koboSpan" id="kobo.7.1">A particular type of software testing is the unit test (which we will learn about in this chapter), the purpose of which is to isolate each part of a program and show its correctness and completeness in the implementation. </span><span class="koboSpan" id="kobo.7.2">It also promptly brings out any defects so that they can be corrected easily before integration.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Furthermore, the unit test lowers the costs—in terms of time and resources—of identifying and correcting defects, compared to achieving the same result by performing tests on the entire application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Debugging using Winpdb Reborn</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">Winpdb Reborn</span></strong><span class="koboSpan" id="kobo.3.1"> is one of the most important and well-known Python debuggers. </span><span class="koboSpan" id="kobo.3.2">The major strength of this debugger is managing the debugging of thread-based code.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.4.1">Winpdb Reborn is based on the RPDB2 debugger, while Winpdb is the GUI frontend to RPDB2 (see: </span><a href="https://github.com/bluebird75/winpdb/blob/master/rpdb2.py"><span class="koboSpan" id="kobo.5.1">https://github.com/bluebird75/winpdb/blob/master/rpdb2.py</span></a><span class="koboSpan" id="kobo.6.1">).</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The most commonly used way to install Winpdb Reborn (</span><em><span class="koboSpan" id="kobo.3.1">release 2.0.0 dev5</span></em><span class="koboSpan" id="kobo.4.1">) is via </span><kbd><span class="koboSpan" id="kobo.5.1">pip</span></kbd><span class="koboSpan" id="kobo.6.1">, so from your console, you need to type the following:</span></p>
<pre><strong><span class="koboSpan" id="kobo.7.1">C:\&gt;pip install winpdb-reborn</span></strong></pre>
<p><span class="koboSpan" id="kobo.8.1">Also, if you have not already installed </span><span><span class="koboSpan" id="kobo.9.1">wxPython </span></span><span class="koboSpan" id="kobo.10.1">in your Python distribution, then you need to do so. </span><span class="koboSpan" id="kobo.10.2">wxPython is a cross-platform GUI toolkit for the Python language.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.11.1">For Python Version 2.x, please refer to </span><span class="MsoHyperlink"><a href="https://sourceforge.net/projects/wxpython/files/wxPython/"><span class="koboSpan" id="kobo.12.1">https://sourceforge.net/projects/wxpython/files/wxPython/</span></a><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">F</span><span><span class="koboSpan" id="kobo.14.1">or Python Version 3.x, wxPython is automatically installed as a dependency via </span><kbd><span class="koboSpan" id="kobo.15.1">pip</span></kbd><span class="koboSpan" id="kobo.16.1">.</span></span></span></div>
<p><span class="koboSpan" id="kobo.17.1">In the next section, we will examine the main features and the graphical interface of Winpdb Reborn through a simple example of its use.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Suppose we want to analyze the following Python application, which uses the threading library. An example that is very similar to the following example is already described in the </span><em><span class="koboSpan" id="kobo.3.1">How to define a thread subclass</span></em><span class="koboSpan" id="kobo.4.1"> section of </span><a href="c95be391-9558-4d2d-867e-96f61fbc5bbf.xhtml"><span class="koboSpan" id="kobo.5.1">Chapter 2</span></a><span class="koboSpan" id="kobo.6.1">, </span><em><span class="koboSpan" id="kobo.7.1">Thread-Based Parallelism</span></em><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">In the following example, we use the </span><kbd><span class="koboSpan" id="kobo.9.1">MyThreadClass</span></kbd><span class="koboSpan" id="kobo.10.1"> class to create and manage the execution of three threads. </span><span class="koboSpan" id="kobo.10.2">Here is the entire code to debug:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">import time</span><br/><span class="koboSpan" id="kobo.12.1">import os</span><br/><span class="koboSpan" id="kobo.13.1">from random import randint</span><br/><span class="koboSpan" id="kobo.14.1">from threading import Thread</span><br/><br/><span class="koboSpan" id="kobo.15.1">class MyThreadClass (Thread):</span><br/><span class="koboSpan" id="kobo.16.1">   def __init__(self, name, duration):</span><br/><span class="koboSpan" id="kobo.17.1">      Thread.__init__(self)</span><br/><span class="koboSpan" id="kobo.18.1">      self.name = name</span><br/><span class="koboSpan" id="kobo.19.1">      self.duration = duration</span><br/><span class="koboSpan" id="kobo.20.1">   def run(self):</span><br/><span class="koboSpan" id="kobo.21.1">      print ("---&gt; " + self.name + \</span><br/><span class="koboSpan" id="kobo.22.1">             " running, belonging to process ID "\</span><br/><span class="koboSpan" id="kobo.23.1">             + str(os.getpid()) + "\n")</span><br/><span class="koboSpan" id="kobo.24.1">      time.sleep(self.duration)</span><br/><span class="koboSpan" id="kobo.25.1">      print ("---&gt; " + self.name + " over\n")</span><br/><span class="koboSpan" id="kobo.26.1">def main():</span><br/><span class="koboSpan" id="kobo.27.1">    start_time = time.time()</span><br/>    <br/><span class="koboSpan" id="kobo.28.1">    # Thread Creation</span><br/><span class="koboSpan" id="kobo.29.1">    thread1 = MyThreadClass("Thread#1 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.30.1">    thread2 = MyThreadClass("Thread#2 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.31.1">    thread3 = MyThreadClass("Thread#3 ", randint(1,10))</span><br/><br/><span class="koboSpan" id="kobo.32.1">    # Thread Running</span><br/><span class="koboSpan" id="kobo.33.1">    thread1.start()</span><br/><span class="koboSpan" id="kobo.34.1">    thread2.start()</span><br/><span class="koboSpan" id="kobo.35.1">    thread3.start()</span><br/><br/><span class="koboSpan" id="kobo.36.1">    # Thread joining</span><br/><span class="koboSpan" id="kobo.37.1">    thread1.join()</span><br/><span class="koboSpan" id="kobo.38.1">    thread2.join()</span><br/><span class="koboSpan" id="kobo.39.1">    thread3.join()</span><br/><br/><span class="koboSpan" id="kobo.40.1">    # End </span><br/><span class="koboSpan" id="kobo.41.1">    print("End")</span><br/><br/><span class="koboSpan" id="kobo.42.1">    #Execution Time</span><br/><span class="koboSpan" id="kobo.43.1">    print("--- %s seconds ---" % (time.time() - start_time))</span><br/><br/><span class="koboSpan" id="kobo.44.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.45.1">    main()</span></pre>
<p><span class="koboSpan" id="kobo.46.1">Let's have a look at the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.47.1">Open your console and type in the name of the folder containing the sample file, </span><kbd><span class="koboSpan" id="kobo.48.1">winpdb_reborn_code_example.py</span></kbd><span class="koboSpan" id="kobo.49.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.50.1">   python -m winpdb .\winpdb_reborn_code_example.py</span></strong></pre>
<div class="packt_infobox"><span><span class="koboSpan" id="kobo.51.1">This works on macOS as well, but you have to use a framework build of Python. </span><span class="koboSpan" id="kobo.51.2">If you are using Winpdb Reborn with Anaconda, simply use </span><kbd><span class="koboSpan" id="kobo.52.1">pythonw</span></kbd><span class="koboSpan" id="kobo.53.1"> instead of </span><kbd><span class="koboSpan" id="kobo.54.1">python</span></kbd><span class="koboSpan" id="kobo.55.1"> to launch a Winpdb Reborn session.</span></span></div>
<ol start="2">
<li><span class="koboSpan" id="kobo.56.1">If the installation was successful, then the Winpdb Reborn GUI should open:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.57.1"><img src="assets/2fba89a5-4840-407f-8266-63aab36b85ba.png"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.58.1">Windpdb Reborn GUI</span></div>
<ol start="3">
<li><span class="koboSpan" id="kobo.59.1">As you can see in the following screenshot, we have inserted two breakpoints (using the </span><span class="packt_screen"><span class="koboSpan" id="kobo.60.1">Breakpoints</span></span><span class="koboSpan" id="kobo.61.1"> menu), in both line </span><span class="packt_screen"><span class="koboSpan" id="kobo.62.1">12</span></span><span class="koboSpan" id="kobo.63.1"> and line </span><span class="packt_screen"><span class="koboSpan" id="kobo.64.1">23</span></span><span class="koboSpan" id="kobo.65.1"> (highlighted in red):</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><strong><em><span class="koboSpan" id="kobo.66.1"><img src="assets/5a2ccb87-7020-4948-8b20-80a3f393b972.png" style="width:57.50em;height:31.92em;"/></span></em><br/></strong></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.67.1">Code breakpoints</span></div>
<div class="packt_infobox"><span class="koboSpan" id="kobo.68.1">To learn about what a breakpoint is, move on to the </span><em><span class="koboSpan" id="kobo.69.1">There's more...</span></em><span class="koboSpan" id="kobo.70.1"> section of this recipe.</span></div>
<ol start="4">
<li><span class="koboSpan" id="kobo.71.1">Remaining in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.72.1">Source</span></span><span class="koboSpan" id="kobo.73.1"> window, we place the mouse on line </span><span class="packt_screen"><span class="koboSpan" id="kobo.74.1">23</span></span><span class="koboSpan" id="kobo.75.1">, where we have inserted the second breakpoint, and press the </span><em><span class="koboSpan" id="kobo.76.1">F8</span></em> <span><span class="koboSpan" id="kobo.77.1">key, </span></span><span class="koboSpan" id="kobo.78.1">and then the </span><em><span class="koboSpan" id="kobo.79.1">F5</span></em><span class="koboSpan" id="kobo.80.1"> key. </span><span class="koboSpan" id="kobo.80.2">The breakpoint allows the code to be </span><span><span class="koboSpan" id="kobo.81.1">executed </span></span><span class="koboSpan" id="kobo.82.1">up to the selected line. </span><span class="koboSpan" id="kobo.82.2">As you can see, </span><span class="packt_screen"><span class="koboSpan" id="kobo.83.1">Namespace</span></span><span class="koboSpan" id="kobo.84.1"> indicates that we are considering the instance of the </span><kbd><span class="koboSpan" id="kobo.85.1">MyThreadClass</span></kbd><span class="koboSpan" id="kobo.86.1"> class, with </span><kbd><span class="koboSpan" id="kobo.87.1">thread#1</span></kbd><span class="koboSpan" id="kobo.88.1"> as an argument:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.89.1"><img src="assets/1a27af00-4468-449f-88ee-ee0c6b9bb6a4.png" style="width:43.50em;height:9.92em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.90.1">Namespace</span></div>
<ol start="5">
<li><span class="koboSpan" id="kobo.91.1">Another fundamental feature of the debugger is the </span><strong><span class="packt_screen"><span class="koboSpan" id="kobo.92.1">Step Into</span></span></strong><span class="koboSpan" id="kobo.93.1"> capability, which is the ability to inspect not only the code being debugged but also the library functions and the subroutines called for execution.</span></li>
<li><span class="koboSpan" id="kobo.94.1">Before you start to delete the previous breakpoints (</span><span class="packt_screen"><span class="koboSpan" id="kobo.95.1">Menu</span></span><span class="koboSpan" id="kobo.96.1"> | </span><span class="packt_screen"><span class="koboSpan" id="kobo.97.1">Breakpoints</span></span><span class="koboSpan" id="kobo.98.1"> | </span><span class="packt_screen"><span class="koboSpan" id="kobo.99.1">Clear All</span></span><span><span class="koboSpan" id="kobo.100.1">), insert the new breakpoint on line</span></span> <span class="packt_screen"><span class="koboSpan" id="kobo.101.1">28</span></span><span class="koboSpan" id="kobo.102.1">:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.103.1"><img src="assets/b27f1402-d9ab-4924-bfa2-df62a894b50c.png" style="width:43.58em;height:31.17em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.104.1">Line 28 breakpoint</span></div>
<ol start="7">
<li><span class="koboSpan" id="kobo.105.1">Finally, press the </span><em><span class="koboSpan" id="kobo.106.1">F5</span></em><span class="koboSpan" id="kobo.107.1"> key and the application will be executed up to the breakpoint of line </span><strong><span class="packt_screen"><span class="koboSpan" id="kobo.108.1">28</span></span></strong><span class="koboSpan" id="kobo.109.1">.</span></li>
<li><span class="koboSpan" id="kobo.110.1">Then, press </span><em><span class="koboSpan" id="kobo.111.1">F7</span></em><span><span class="koboSpan" id="kobo.112.1">. </span><span class="koboSpan" id="kobo.112.2">Here, </span></span><span><span class="koboSpan" id="kobo.113.1">the source window no longer shows our sample code, but rather, the </span><kbd><span class="koboSpan" id="kobo.114.1">threading</span></kbd></span><span><span class="koboSpan" id="kobo.115.1"> library we are using (see the next screenshot).</span></span></li>
<li><span class="koboSpan" id="kobo.116.1">T</span><span><span class="koboSpan" id="kobo.117.1">herefore, t</span></span><span class="koboSpan" id="kobo.118.1">he </span><span class="packt_screen"><span class="koboSpan" id="kobo.119.1">Breakpoints </span></span><span><span class="koboSpan" id="kobo.120.1">functionality, together with that of</span></span> <span class="packt_screen"><span class="koboSpan" id="kobo.121.1">Step Into</span></span><span class="koboSpan" id="kobo.122.1">,</span><span><span class="koboSpan" id="kobo.123.1"> not only allow</span></span><span><span class="koboSpan" id="kobo.124.1"> the debugging of the code in question but also allow the inspection of all the library </span></span><span><span class="koboSpan" id="kobo.125.1">functions and any other subroutines used:</span></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.126.1"><img src="assets/70c4308b-78e8-4633-8a9c-7435c583eb9c.png"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.127.1">Line 28 Source window after </span><span><span class="koboSpan" id="kobo.128.1">executing </span></span><span class="koboSpan" id="kobo.129.1">Step Into</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this first example, we have become familiar with the Winpdb Reborn tool. </span><span class="koboSpan" id="kobo.2.2">This debugging environment (like every</span><span><span class="koboSpan" id="kobo.3.1"> environment</span></span><span class="koboSpan" id="kobo.4.1"> in general) allows you to stop program execution at precise points, inspect the execution stack, the contents of the variables, the status of the objects created, and much more.</span></p>
<p><span class="koboSpan" id="kobo.5.1">To use </span><span><span class="koboSpan" id="kobo.6.1">Winpdb Reborn,</span></span><span class="koboSpan" id="kobo.7.1"> just take a note of the following basic steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.8.1">Set some breakpoints in the source code (the </span><span class="packt_screen"><span class="koboSpan" id="kobo.9.1">Source</span></span><span class="koboSpan" id="kobo.10.1"> window).</span></li>
<li><span class="koboSpan" id="kobo.11.1">Inspect the functions through the </span><span class="packt_screen"><span class="koboSpan" id="kobo.12.1">Step Into</span></span><span class="koboSpan" id="kobo.13.1"> function.</span></li>
<li><span class="koboSpan" id="kobo.14.1">View the status of the variables (</span><span><span class="koboSpan" id="kobo.15.1">the </span></span><span class="packt_screen"><span class="koboSpan" id="kobo.16.1">Namespace</span></span><span class="koboSpan" id="kobo.17.1"> window) and the execution stack (</span><span><span class="koboSpan" id="kobo.18.1">the </span></span><span class="packt_screen"><span class="koboSpan" id="kobo.19.1">Stack</span></span><span class="koboSpan" id="kobo.20.1"> window).</span></li>
</ol>
<p><span class="koboSpan" id="kobo.21.1">The breakpoints are set by simply double-clicking </span><span><span class="koboSpan" id="kobo.22.1">the desired line </span></span><span class="koboSpan" id="kobo.23.1">with the left mouse button (you will see the selected line underlined in red). </span><span class="koboSpan" id="kobo.23.2">As a general warning, it is inadvisable to have multiple commands on the same line; otherwise, it will not be possible to associate breakpoints with some of them.</span></p>
<p><span class="koboSpan" id="kobo.24.1">When you use the right mouse button, you can selectively </span><em><span class="koboSpan" id="kobo.25.1">disable breakpoints</span></em><span class="koboSpan" id="kobo.26.1"> without removing them (the red highlighting will disappear). </span><span class="koboSpan" id="kobo.26.2">To remove all the breakpoints instead, use the </span><span class="packt_screen"><span class="koboSpan" id="kobo.27.1">Clear All</span></span><span class="koboSpan" id="kobo.28.1"> command, which is present in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.29.1">Breakpoints</span></span> <span><span class="koboSpan" id="kobo.30.1">menu, </span></span><span class="koboSpan" id="kobo.31.1">as mentioned previously.</span></p>
<p><span class="koboSpan" id="kobo.32.1">When the first breakpoint is reached, it is good to keep an eye on the following views in the</span><span><span class="koboSpan" id="kobo.33.1"> point of the program that is being analyzed</span></span><span class="koboSpan" id="kobo.34.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.35.1">The </span><span class="packt_screen"><span class="koboSpan" id="kobo.36.1">Stack</span></span><span class="koboSpan" id="kobo.37.1"> view shows the contents of the execution stack, where all the instances of various methods that are currently suspended appear. </span><span class="koboSpan" id="kobo.37.2">Typically, the one at the bottom of the stack is the main method and the one at the top of the stack is the method containing the breakpoint that has been reached.</span></li>
<li><span class="koboSpan" id="kobo.38.1">The </span><span class="packt_screen"><span class="koboSpan" id="kobo.39.1">Namespace</span></span><span class="koboSpan" id="kobo.40.1"> view shows the local variables of the method and allows you to inspect the values. </span><span class="koboSpan" id="kobo.40.2">If the variables refer to objects, then it is possible to find out the unique identifier of the object and inspect its status.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.41.1">In general, the execution of a program can be managed with different modes associated with the icon (or the </span><em><span class="koboSpan" id="kobo.42.1">Fx</span></em><span class="koboSpan" id="kobo.43.1"> keys) present on the </span><span><span class="koboSpan" id="kobo.44.1">Winpdb Reborn </span></span><span class="koboSpan" id="kobo.45.1">command bar.</span></p>
<p><span class="koboSpan" id="kobo.46.1">Finally, we'll point out the following important execution methods:</span></p>
<ul>
<li><span class="packt_screen"><span class="koboSpan" id="kobo.47.1">Step Into</span></span><span class="koboSpan" id="kobo.48.1"> (</span><em><span class="koboSpan" id="kobo.49.1">F7</span></em><span class="koboSpan" id="kobo.50.1"> key): This resumes the execution of the program one line at a time, and invocations of library methods or subroutines.</span></li>
<li><span class="packt_screen"><span class="koboSpan" id="kobo.51.1">Return</span></span><span class="koboSpan" id="kobo.52.1"> (</span><em><span class="koboSpan" id="kobo.53.1">F12</span></em><span class="koboSpan" id="kobo.54.1"> key): This allows you to resume execution at the </span><span><span class="koboSpan" id="kobo.55.1">exact </span></span><span class="koboSpan" id="kobo.56.1">point where the </span><span class="packt_screen"><span class="koboSpan" id="kobo.57.1">Step Into</span></span><span class="koboSpan" id="kobo.58.1"> function was activated.</span></li>
<li><span class="packt_screen"><span class="koboSpan" id="kobo.59.1">Next</span></span><span class="koboSpan" id="kobo.60.1"> (</span><em><span class="koboSpan" id="kobo.61.1">F6</span></em><span class="koboSpan" id="kobo.62.1"> key): This resumes the execution of the program one line at a time without stopping in any methods invoked.</span></li>
<li><span class="packt_screen"><span class="koboSpan" id="kobo.63.1">Run to Line</span></span><span class="koboSpan" id="kobo.64.1"> (</span><em><span class="koboSpan" id="kobo.65.1">F8</span></em><span class="koboSpan" id="kobo.66.1"> key) This runs the program until it stops (waiting for new commands) at the indicated line.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As you saw in the Winpdb Reborn GUI screenshot, the GUI is divided into five main windows:</span></p>
<ul>
<li><span class="packt_screen"><span class="koboSpan" id="kobo.3.1">Namespace</span></span><span class="koboSpan" id="kobo.4.1">:</span><span><span class="koboSpan" id="kobo.5.1"> </span></span><span class="koboSpan" id="kobo.6.1">In this window, the names of entities are displayed, which are various variables and identifiers that are defined by the program and used in the source file.</span></li>
<li><span class="packt_screen"><span class="koboSpan" id="kobo.7.1">Threads</span></span><span class="koboSpan" id="kobo.8.1">:</span><span><span class="koboSpan" id="kobo.9.1"> </span></span><span class="koboSpan" id="kobo.10.1">The current thread of the execution is shown, and it is characterized by the </span><strong><span class="koboSpan" id="kobo.11.1">TID</span></strong><span><span class="koboSpan" id="kobo.12.1">  (short for </span><strong><span class="koboSpan" id="kobo.13.1">T</span></strong><span class="koboSpan" id="kobo.14.1">hread </span><strong><span class="koboSpan" id="kobo.15.1">ID</span></strong><span class="koboSpan" id="kobo.16.1">entification) fields</span></span><span class="koboSpan" id="kobo.17.1">, the name of the thread, and the thread status.</span></li>
<li><span class="packt_screen"><span class="koboSpan" id="kobo.18.1">Stack</span></span><span class="koboSpan" id="kobo.19.1">:</span><span><span class="koboSpan" id="kobo.20.1"> This is w</span></span><span class="koboSpan" id="kobo.21.1">here the execution stack of the program to be analyzed is shown. </span><span class="koboSpan" id="kobo.21.2">Stacks are also known as</span><strong><em><span class="koboSpan" id="kobo.22.1"> </span></em><span class="koboSpan" id="kobo.23.1">Last In, First Out</span></strong><span><span class="koboSpan" id="kobo.24.1"> (</span></span><strong><span class="koboSpan" id="kobo.25.1">LIFO</span></strong><span class="koboSpan" id="kobo.26.1">)</span><span><span class="koboSpan" id="kobo.27.1"> </span></span><span class="koboSpan" id="kobo.28.1">data structures, as the last element inserted is the first to be removed. </span><span class="koboSpan" id="kobo.28.2">When a program calls a function, the called function must know how to return the calling control, so the return address of the calling function is entered into the program execution stack. </span><span class="koboSpan" id="kobo.28.3">The program execution stack also contains the memory for the local variables used at each invocation of the function.</span></li>
<li><span class="packt_screen"><span class="koboSpan" id="kobo.29.1">Console</span></span><span class="koboSpan" id="kobo.30.1">: This is a command-line interface, thus allowing a textual interaction between the user and Winpdb Reborn.</span></li>
<li><span class="packt_screen"><span class="koboSpan" id="kobo.31.1">Source</span></span><span class="koboSpan" id="kobo.32.1">:</span><strong><span class="koboSpan" id="kobo.33.1"> </span></strong><span class="koboSpan" id="kobo.34.1">Th</span><span><span class="koboSpan" id="kobo.35.1">is</span></span><span class="koboSpan" id="kobo.36.1"> window shows the source code to debug. </span><span class="koboSpan" id="kobo.36.2">By scrolling along the lines of code, it is also possible to insert the breakpoints by pressing</span><span><span class="koboSpan" id="kobo.37.1"> </span></span><em><span class="koboSpan" id="kobo.38.1">F9</span><span><span class="koboSpan" id="kobo.39.1"> </span></span></em><span class="koboSpan" id="kobo.40.1">once you are on the line of code of interest.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.41.1">The breakpoint is a very basic debugging tool. </span><span class="koboSpan" id="kobo.41.2">In fact, it allows you to run a program, but with the possibility of interrupting it at the desired point or when certain conditions occur, in order to acquire information on a running program</span><strong><em><span class="koboSpan" id="kobo.42.1">.</span></em></strong></p>
<p><span class="koboSpan" id="kobo.43.1">There </span><span><span class="koboSpan" id="kobo.44.1">are multiple</span></span><span class="koboSpan" id="kobo.45.1"> debugging strategies. </span><span class="koboSpan" id="kobo.45.2">Here, we list some of them:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.46.1">Reproduce the error</span></strong><span class="koboSpan" id="kobo.47.1">: Identify the input data that caused it.</span></li>
<li><strong><span class="koboSpan" id="kobo.48.1">Simplify the error</span></strong><span class="koboSpan" id="kobo.49.1">: Identify the simplest possible data that caused it.</span></li>
<li><strong><span class="koboSpan" id="kobo.50.1">Divide and</span></strong> <strong><span class="koboSpan" id="kobo.51.1">rule</span></strong><span class="koboSpan" id="kobo.52.1">: Perform the main proceeding in step-over mode until the anomaly occurs. </span><span class="koboSpan" id="kobo.52.2">The method that caused it is the last performed before it was possible to find the problem, so we can re-debug by doing step-in into that particular invocation, and proceeding again with step-over following the method's instructions.</span></li>
<li><strong><span class="koboSpan" id="kobo.53.1">Proceed consciously</span></strong><span class="koboSpan" id="kobo.54.1">: During debugging, you constantly compare the current values of the variables with the ones you would expect.</span></li>
<li><strong><span class="koboSpan" id="kobo.55.1">Check all the details</span></strong><span class="koboSpan" id="kobo.56.1">: Don't overlook the details while debugging. </span><span class="koboSpan" id="kobo.56.2">It is best to make a note if you notice any discrepancies in the source code.</span></li>
<li><strong><span class="koboSpan" id="kobo.57.1">Correct the errors</span></strong><span class="koboSpan" id="kobo.58.1">: Correct the error only if you are sure you have understood the problem well.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A good Winpdb Reborn tutorial can be found at </span><a href="http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin"><span class="MsoHyperlink"><span class="koboSpan" id="kobo.3.1">http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin</span></span></a><span class="koboSpan" id="kobo.4.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Interacting with pdb</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">pdb</span></kbd><span class="koboSpan" id="kobo.3.1"> is a Python module for performing interactive debugging.</span></p>
<p><span class="koboSpan" id="kobo.4.1">The main features of </span><kbd><span class="koboSpan" id="kobo.5.1">pdb</span></kbd><span class="koboSpan" id="kobo.6.1"> are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">The use of breakpoints</span></li>
<li><span class="koboSpan" id="kobo.8.1">Interactive processing of the source code line by line</span></li>
<li><span class="koboSpan" id="kobo.9.1">Stack frame analysis</span></li>
</ul>
<p><span class="koboSpan" id="kobo.10.1">The debugger is implemented through the</span><span><span class="koboSpan" id="kobo.11.1"> </span></span><kbd><span class="koboSpan" id="kobo.12.1">pdb</span></kbd><span class="koboSpan" id="kobo.13.1"> class. </span><span class="koboSpan" id="kobo.13.2">For this reason, it can be easily extended with new features.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">No installation of </span><kbd><span class="koboSpan" id="kobo.3.1">pdb</span></kbd><span class="koboSpan" id="kobo.4.1"> is required because it is part of the Python standard library. </span></span><span class="koboSpan" id="kobo.5.1">It can be launched with the following main use pattern:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.6.1">Interacting with the command line</span></li>
<li><span class="koboSpan" id="kobo.7.1">Using the Python interpreter</span></li>
<li><span class="koboSpan" id="kobo.8.1">Inserting a directive (that is, a </span><kbd><span class="koboSpan" id="kobo.9.1">pdb</span></kbd><span class="koboSpan" id="kobo.10.1"> statement) in the code to debug</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Interacting with the command line</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The simplest method is simply passing the name of your program as input. </span><span class="koboSpan" id="kobo.2.2">For example, for the </span><kbd><span class="koboSpan" id="kobo.3.1">pdb_test.py</span></kbd><span class="koboSpan" id="kobo.4.1"> </span><span><span class="koboSpan" id="kobo.5.1">program, this is as follows</span></span><span class="koboSpan" id="kobo.6.1">:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">class Pdb_test(object):</span><br/><span class="koboSpan" id="kobo.8.1">    def __init__(self, parameter):</span><br/><span class="koboSpan" id="kobo.9.1">    self.counter = parameter</span><br/><br/><span class="koboSpan" id="kobo.10.1">    def go(self):</span><br/><span class="koboSpan" id="kobo.11.1">        for j in range(self.counter):</span><br/><span class="koboSpan" id="kobo.12.1">             print ("---&gt;",j)</span><br/><span class="koboSpan" id="kobo.13.1">        return</span><br/><br/><span class="koboSpan" id="kobo.14.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.15.1">    Pdb_test(10).go()</span></pre>
<p><span class="koboSpan" id="kobo.16.1">By executing from the command line, </span><kbd><span class="koboSpan" id="kobo.17.1">pdb</span></kbd><span class="koboSpan" id="kobo.18.1"> loads the source file to be analyzed and stops its execution at the first statement found. </span><span class="koboSpan" id="kobo.18.2">In this case, the debug stops at line </span><kbd><span class="koboSpan" id="kobo.19.1">1</span></kbd><span class="koboSpan" id="kobo.20.1"> (that is, at the definition of the</span><em><span><span class="koboSpan" id="kobo.21.1"> </span></span></em><kbd><span class="koboSpan" id="kobo.22.1">Pdb_test</span></kbd><span><span class="koboSpan" id="kobo.23.1"> </span></span><span class="koboSpan" id="kobo.24.1">class):</span></p>
<pre><strong><span class="koboSpan" id="kobo.25.1">python -m pdb pdb_test.py</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">&gt; .../pdb_test.py(1)&lt;module&gt;()</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">-&gt; class Pdb_test(object):</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">(Pdb)</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using the Python interpreter</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">pdb</span></kbd><span class="koboSpan" id="kobo.4.1"> module can be used in interactive mode by using the</span><span><span class="koboSpan" id="kobo.5.1"> </span></span><kbd><span class="koboSpan" id="kobo.6.1">run()</span></kbd><span><span class="koboSpan" id="kobo.7.1"> </span></span><span class="koboSpan" id="kobo.8.1">command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1">&gt;&gt;&gt; import pdb_test</span></strong><br/><strong><span class="koboSpan" id="kobo.10.1">&gt;&gt;&gt; import pdb</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">&gt;&gt;&gt; pdb.run('pdb_test.Pdb_test(10).go()')</span></strong><br/><strong><span class="koboSpan" id="kobo.12.1">&gt; &lt;string&gt;(1)&lt;module&gt;()</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">(Pdb)</span></strong></pre>
<p><span class="koboSpan" id="kobo.14.1">In this case, the</span><span><span class="koboSpan" id="kobo.15.1"> </span></span><kbd><span class="koboSpan" id="kobo.16.1">run()</span></kbd><span><span class="koboSpan" id="kobo.17.1"> </span></span><span class="koboSpan" id="kobo.18.1">statement is from the debugger and will stop the execution before evaluating the first expression.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Inserting a directive in the code to debug</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">For a long-running process, where the problem occurs much later in the program execution, it would be much more convenient to start the debugger within the program using the </span><kbd><span class="koboSpan" id="kobo.3.1">pdb set_trace()</span></kbd><span class="koboSpan" id="kobo.4.1"> directive:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">import pdb</span><br/><br/><span class="koboSpan" id="kobo.6.1">class Pdb_test(object):</span><br/><span class="koboSpan" id="kobo.7.1">    def __init__(self, parameter):</span><br/><span class="koboSpan" id="kobo.8.1">        self.counter = parameter</span><br/><span class="koboSpan" id="kobo.9.1">    def go(self):</span><br/><span class="koboSpan" id="kobo.10.1">        for j in range(self.counter):</span><br/><span class="koboSpan" id="kobo.11.1">            pdb.set_trace()</span><br/><span class="koboSpan" id="kobo.12.1">            print ("---&gt;",j)</span><br/><span class="koboSpan" id="kobo.13.1">        return</span><br/><br/><span class="koboSpan" id="kobo.14.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.15.1">    Pdb_test(10).go()</span></pre>
<p><kbd><span class="koboSpan" id="kobo.16.1">set_trace()</span></kbd><span><span class="koboSpan" id="kobo.17.1"> </span></span><span class="koboSpan" id="kobo.18.1">can be called at any point in the program to debug. </span><span class="koboSpan" id="kobo.18.2">For example, it can be called based on</span><span><span class="koboSpan" id="kobo.19.1"> </span></span><span class="koboSpan" id="kobo.20.1">conditions,</span><span><span class="koboSpan" id="kobo.21.1"> </span></span><span class="koboSpan" id="kobo.22.1">exception handlers,</span><span><span class="koboSpan" id="kobo.23.1"> </span></span><span class="koboSpan" id="kobo.24.1">or a specific branch of control instructions.</span></p>
<p><span class="koboSpan" id="kobo.25.1">In this case, the output is as follows: </span></p>
<pre><strong><span><span class="koboSpan" id="kobo.26.1">-&gt; print ("---&gt;",j)</span></span></strong><br/><strong><span><span class="koboSpan" id="kobo.27.1">(P</span></span></strong><span><strong><span class="koboSpan" id="kobo.28.1">db)</span></strong> </span></pre>
<p><span class="koboSpan" id="kobo.29.1">The code run stops, exactly after the </span><kbd><span class="koboSpan" id="kobo.30.1">pdb.set_trace()</span></kbd><span class="koboSpan" id="kobo.31.1"> statement completes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To interact with </span><kbd><span class="koboSpan" id="kobo.3.1">pdb</span></kbd><span class="koboSpan" id="kobo.4.1">, you need to use its language, which allows you to move around the code, examine and modify the values of the variables, insert breakpoints, or move through stack calls:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.5.1">Use the </span><kbd><span class="koboSpan" id="kobo.6.1">where</span></kbd><span class="koboSpan" id="kobo.7.1"> command (or alternatively, the compact form, </span><kbd><span class="koboSpan" id="kobo.8.1">w</span></kbd><span class="koboSpan" id="kobo.9.1">) to view which line of code is running and the call stack. </span><span class="koboSpan" id="kobo.9.2">In this case, this is on line </span><span class="packt_screen"><span class="koboSpan" id="kobo.10.1">17</span></span><span class="koboSpan" id="kobo.11.1"> in the</span><span><span class="koboSpan" id="kobo.12.1"> </span></span><kbd><span class="koboSpan" id="kobo.13.1">go()</span></kbd><span><span class="koboSpan" id="kobo.14.1"> </span></span><span class="koboSpan" id="kobo.15.1">method of the</span><span><span class="koboSpan" id="kobo.16.1"> </span></span><kbd><span class="koboSpan" id="kobo.17.1">pdb_test.py</span></kbd><span><span class="koboSpan" id="kobo.18.1"> </span></span><span class="koboSpan" id="kobo.19.1">module:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.20.1">&gt; python -m pdb pdb_test.py</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">-&gt; class Pdb_test(object):</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">(Pdb) where</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">  c:\python35\lib\bdb.py(431)run()</span></strong><br/><strong><span class="koboSpan" id="kobo.24.1">-&gt; exec(cmd, globals, locals)</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">  &lt;string&gt;(1)&lt;module&gt;()</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">(Pdb)</span></strong></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.27.1">Inspect the lines of code near the current location (indicated by an arrow) by using </span><kbd><span class="koboSpan" id="kobo.28.1">list</span></kbd><span class="koboSpan" id="kobo.29.1">. In the default mode, </span><kbd><span class="koboSpan" id="kobo.30.1">11</span></kbd><span class="koboSpan" id="kobo.31.1"> rows are listed around the current one (five before and five after):</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.32.1"> (Pdb) list</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">  1 -&gt; class Pdb_test(object):</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">  2 def __init__(self, parameter):</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">  3 self.counter = parameter</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">  4</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">  5 def go(self):</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">  6 for j in range(self.counter):</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">  7 print ("---&gt;",j)</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">  8 return</span></strong><br/><strong><span class="koboSpan" id="kobo.41.1">  9</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1"> 10 if __name__ == '__main__':</span></strong><br/><strong><span class="koboSpan" id="kobo.43.1"> 11 Pdb_test(10).go()</span></strong></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.44.1">If </span><kbd><span class="koboSpan" id="kobo.45.1">list</span></kbd><span class="koboSpan" id="kobo.46.1"> receives two parameters, then they are interpreted as the first and last lines to be displayed:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.47.1"> (Pdb) list 3,9</span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">  3 self.counter = parameter</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">  4</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">  5 def go(self):</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">  6 for j in range(self.counter):</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">  7 print ("---&gt;",j)</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">  8 return</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">  9</span></strong></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.55.1">Use </span><kbd><span class="koboSpan" id="kobo.56.1">up</span></kbd><span class="koboSpan" id="kobo.57.1"> (or </span><kbd><span class="koboSpan" id="kobo.58.1">u</span></kbd><span class="koboSpan" id="kobo.59.1">) to move to older frames on the stack and </span><kbd><span class="koboSpan" id="kobo.60.1">down</span></kbd><span class="koboSpan" id="kobo.61.1"> (or </span><kbd><span class="koboSpan" id="kobo.62.1">d</span></kbd><span class="koboSpan" id="kobo.63.1">) to move to more recent stack frames:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.64.1">(Pdb) up</span></strong><br/><strong><span class="koboSpan" id="kobo.65.1">&gt; &lt;string&gt;(1)&lt;module&gt;()</span></strong><br/><strong><span class="koboSpan" id="kobo.66.1">(Pdb) up</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1">&gt; c:\python35\lib\bdb.py(431)run()</span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">-&gt; exec(cmd, globals, locals)</span></strong><br/><strong><span class="koboSpan" id="kobo.69.1">(Pdb) down</span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">&gt; &lt;string&gt;(1)&lt;module&gt;()</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">(Pdb) down</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">&gt;....\pdb_test.py(1)&lt;module&gt;()</span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">-&gt; class Pdb_test(object):</span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">(Pdb)</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The debugging activity is carried out following the flow of the running program (tracing). </span><span class="koboSpan" id="kobo.2.2">In each </span><span><span class="koboSpan" id="kobo.3.1">line</span></span><span class="koboSpan" id="kobo.4.1"> of code,</span><span><span class="koboSpan" id="kobo.5.1"> </span></span><span class="koboSpan" id="kobo.6.1">the coder displays</span><span><span class="koboSpan" id="kobo.7.1"> </span></span><span class="koboSpan" id="kobo.8.1">the operations performed by the instructions in real time and the values recorded in the variables. </span><span class="koboSpan" id="kobo.8.2">In this way, the developer can check that everything is working properly or identify the cause of a malfunction.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Each programming language has its own debugger. </span><span class="koboSpan" id="kobo.9.2">However, there is no valid debugger for all programming languages because each language has its own syntax and grammar. </span><span class="koboSpan" id="kobo.9.3">The debugger executes the step-by-step source code. </span><span class="koboSpan" id="kobo.9.4">Therefore, the debugger must know the rules of the language, like the compiler.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The most useful </span><kbd><span class="koboSpan" id="kobo.3.1">pdb</span></kbd><span class="koboSpan" id="kobo.4.1"> commands, along with their short forms, to keep in mind while working with the Python debugger are as follows:</span></p>
<table style="border-collapse: collapse;width: 90%" border="1">
<tbody>
<tr>
<td>
<p><strong><span class="koboSpan" id="kobo.5.1">Command</span></strong></p>
</td>
<td>
<p><strong><span class="koboSpan" id="kobo.6.1">Action</span></strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.7.1">args</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.8.1">Prints the argument list of the current function</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.9.1">break</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.10.1">Creates a breakpoint (requires parameters) </span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.11.1">continue</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.12.1">Continues program execution</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.13.1">help</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.14.1">Lists the commands (or help) for a command (as a parameter)</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.15.1">jump</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.16.1">Sets the next line to be executed</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.17.1">list</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.18.1">Prints the source code around the current line</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.19.1">next</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.20.1">Continues execution until the next line in the current function is reached or returns</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.21.1">step</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.22.1">Executes the current line, stopping at the first possible occasion</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.23.1">pp</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.24.1">Pretty-prints the value of the expression</span></p>
</td>
</tr>
<tr>
<td>
<p><strong><kbd><span class="koboSpan" id="kobo.25.1">quit</span></kbd><span class="koboSpan" id="kobo.26.1"> </span></strong><span class="koboSpan" id="kobo.27.1">or</span><strong><span class="koboSpan" id="kobo.28.1"> </span><kbd><span class="koboSpan" id="kobo.29.1">exit</span></kbd></strong></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.30.1">Aborts from </span><kbd><span class="koboSpan" id="kobo.31.1">pdb</span></kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.32.1">return</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.33.1">Continues execution until the current function returns</span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You can find out more about </span><kbd><span class="koboSpan" id="kobo.3.1">pdb</span></kbd><span class="koboSpan" id="kobo.4.1"> by watching this interesting video tutorial:</span><span><span class="koboSpan" id="kobo.5.1"> </span></span><a href="https://www.youtube.com/watch?v=bZZTeKPRSLQ"><span class="koboSpan" id="kobo.6.1">https://www.youtube.com/watch?v=bZZTeKPRSLQ</span></a><span class="koboSpan" id="kobo.7.1">.</span><a href="https://www.youtube.com/watch?v=bZZTeKPRSLQ"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Implementing rpdb for debugging</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In some cases, it is appropriate to debug code in a remote location; that is, a </span><span><span class="koboSpan" id="kobo.3.1">location that does</span></span><span class="koboSpan" id="kobo.4.1">n't reside on the same machine in which we run the debugger. </span><span class="koboSpan" id="kobo.4.2">For this purpose, </span><kbd><span class="koboSpan" id="kobo.5.1">rpdb</span></kbd><span class="koboSpan" id="kobo.6.1"> was developed. </span><span class="koboSpan" id="kobo.6.2">This is a wrapper on </span><kbd><span class="koboSpan" id="kobo.7.1">pdb</span></kbd><span class="koboSpan" id="kobo.8.1"> that uses a TCP socket to communicate with the world outside.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The installation of </span><kbd><span class="koboSpan" id="kobo.3.1">rpdb</span></kbd><span class="koboSpan" id="kobo.4.1"> first requires the main step of using </span><kbd><span class="koboSpan" id="kobo.5.1">pip</span></kbd><span class="koboSpan" id="kobo.6.1">. For Windows </span><span><span class="koboSpan" id="kobo.7.1">OS, </span></span><span class="koboSpan" id="kobo.8.1">just type the following:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.9.1">C:\&gt;pip install rpdb</span></strong></pre>
<p><span class="koboSpan" id="kobo.10.1">Then, you need to be sure that you have a working </span><strong><span class="koboSpan" id="kobo.11.1">telnet</span></strong><span class="koboSpan" id="kobo.12.1"> client enabled on your machine. </span><span class="koboSpan" id="kobo.12.2">In Windows 10, if you open Command Prompt and type </span><kbd><span class="koboSpan" id="kobo.13.1">telnet</span></kbd><span class="koboSpan" id="kobo.14.1">, then the OS will respond with an error as it is not present by default in the installation.</span></p>
<p><span class="koboSpan" id="kobo.15.1">Let's see how to install it with a few simple steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.16.1">Open Command Prompt in administrator mode.</span></li>
<li><span class="koboSpan" id="kobo.17.1">Click on the Cortana button and type </span><kbd><span class="koboSpan" id="kobo.18.1">cmd</span></kbd><span class="koboSpan" id="kobo.19.1">.</span></li>
<li><span class="koboSpan" id="kobo.20.1">In the list that appears, right-click on the Command Prompt item and select </span><span class="packt_screen"><span class="koboSpan" id="kobo.21.1">Run as Administrator</span></span><span class="koboSpan" id="kobo.22.1">.</span></li>
</ol>
<ol start="4">
<li><span class="koboSpan" id="kobo.23.1">Then, when running Command Prompt as an administrator, type the following command:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong><span class="koboSpan" id="kobo.24.1">dism /online /Enable-Feature /FeatureName:TelnetClient</span></strong></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.25.1">Wait a few minutes until the installation finishes. </span><span class="koboSpan" id="kobo.25.2">If the process is successful, then you will see this:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.26.1"><img src="assets/92df2ec3-4eb3-43be-a8a0-f6351d39f5de.png" style="width:38.75em;height:15.42em;"/></span></p>
<ol start="6">
<li><span class="koboSpan" id="kobo.27.1">Now, you can use telnet directly from the prompt. </span><span class="koboSpan" id="kobo.27.2">By typing </span><kbd><span class="koboSpan" id="kobo.28.1">telnet</span></kbd><span class="koboSpan" id="kobo.29.1">, the following window should appear:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.30.1"><img src="assets/1e25886f-dca3-41a6-8e2a-efaf80ff5b05.png" style="width:40.75em;height:22.67em;"/></span></p>
<p><span class="koboSpan" id="kobo.31.1">In the following example, let's see how to run a remote debug with </span><kbd><span class="koboSpan" id="kobo.32.1">rpdb</span></kbd><span class="koboSpan" id="kobo.33.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's perform the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">Consider the following sample code:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.4.1">import threading</span><br/><br/><span class="koboSpan" id="kobo.5.1">def my_func(thread_number):</span><br/><span class="koboSpan" id="kobo.6.1">    return print('my_func called by thread N°</span><br/><span class="koboSpan" id="kobo.7.1">        {}'.format(thread_number))</span><br/><br/><span class="koboSpan" id="kobo.8.1">def main():</span><br/><span class="koboSpan" id="kobo.9.1">    threads = []</span><br/><span class="koboSpan" id="kobo.10.1">    for i in range(10):</span><br/><span class="koboSpan" id="kobo.11.1">        t = threading.Thread(target=my_func, args=(i,))</span><br/><span class="koboSpan" id="kobo.12.1">        threads.append(t)</span><br/><span class="koboSpan" id="kobo.13.1">        t.start()</span><br/><span class="koboSpan" id="kobo.14.1">        t.join()</span><br/><br/><span class="koboSpan" id="kobo.15.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.16.1">    main()</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.17.1">To use </span><kbd><span class="koboSpan" id="kobo.18.1">rpdb</span></kbd><span class="koboSpan" id="kobo.19.1">, you need to insert the following lines of code (just after the </span><kbd><span class="koboSpan" id="kobo.20.1">import threading</span></kbd><span class="koboSpan" id="kobo.21.1"> statement). </span><span class="koboSpan" id="kobo.21.2">In fact, these three lines of code enable the use of </span><kbd><span class="koboSpan" id="kobo.22.1">rpdb</span></kbd><span class="koboSpan" id="kobo.23.1"> via a remote client on port </span><kbd><span class="koboSpan" id="kobo.24.1">4444</span></kbd><span class="koboSpan" id="kobo.25.1"> with an IP address of </span><kbd><span class="koboSpan" id="kobo.26.1">127.0.0.1</span></kbd><span class="koboSpan" id="kobo.27.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.28.1">import rpdb</span><br/><span class="koboSpan" id="kobo.29.1">debugger = rpdb.Rpdb(port=4444)</span><br/><span class="koboSpan" id="kobo.30.1">rpdb.Rpdb().set_trace()</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.31.1">If you run the sample code after inserting these three lines of code that enable the use of </span><kbd><span class="koboSpan" id="kobo.32.1">rpdb</span></kbd><span class="koboSpan" id="kobo.33.1">, then you should see the following message on Python Command Prompt:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.34.1">pdb is running on 127.0.0.1:4444</span></strong></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.35.1">Then, you can switch to debug the sample code remotely by making the following telnet connection:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.36.1">telnet localhost 4444</span></strong></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.37.1">The following window should open:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.38.1"><img src="assets/9f1b0949-3689-4ca7-9cd9-502cdaf6a028.png"/></span></p>
<ol start="6">
<li><span class="koboSpan" id="kobo.39.1">In the sample code, note the arrow in line </span><span class="packt_screen"><span class="koboSpan" id="kobo.40.1">7</span></span><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">The code is not running, it is just waiting for an instruction to execute:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.42.1"><img src="assets/1aa03050-e016-4563-94a9-b3418cef7ef4.png" style="width:40.33em;height:16.83em;"/></span></p>
<ol start="7">
<li><span class="koboSpan" id="kobo.43.1">For example, here, we execute the code and type the </span><kbd><span class="koboSpan" id="kobo.44.1">next</span></kbd><span class="koboSpan" id="kobo.45.1"> statement </span><span><span class="koboSpan" id="kobo.46.1">repeatedly</span></span><span class="koboSpan" id="kobo.47.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.48.1"> (Pdb) next</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">&gt; c:\users\giancarlo\desktop\python parallel programming cookbook 2nd edition\python parallel programming new book\chapter_x- code debugging\rpdb_code_example.py(10)&lt;module&gt;()</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">-&gt; def main():</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">(Pdb) next</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">&gt; c:\users\giancarlo\desktop\python parallel programming cookbook 2nd edition\python parallel programming new book\chapter_x- code debugging\rpdb_code_example.py(18)&lt;module&gt;()</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">-&gt; if __name__ == "__main__":</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">(Pdb) next</span></strong><br/><strong><span class="koboSpan" id="kobo.55.1">&gt; c:\users\giancarlo\desktop\python parallel programming cookbook 2nd edition\python parallel programming new book\chapter_x- code debugging\rpdb_code_example.py(20)&lt;module&gt;()</span></strong><br/><strong><span class="koboSpan" id="kobo.56.1">-&gt; main()</span></strong><br/><strong><span class="koboSpan" id="kobo.57.1">(Pdb) next</span></strong><br/><strong><span class="koboSpan" id="kobo.58.1">my_func called by thread N 0</span></strong><br/><strong><span class="koboSpan" id="kobo.59.1">my_func called by thread N 1</span></strong><br/><strong><span class="koboSpan" id="kobo.60.1">my_func called by thread N 2</span></strong><br/><strong><span class="koboSpan" id="kobo.61.1">my_func called by thread N 3</span></strong><br/><strong><span class="koboSpan" id="kobo.62.1">my_func called by thread N 4</span></strong><br/><strong><span class="koboSpan" id="kobo.63.1">my_func called by thread N 5</span></strong><br/><strong><span class="koboSpan" id="kobo.64.1">my_func called by thread N 6</span></strong><br/><strong><span class="koboSpan" id="kobo.65.1">my_func called by thread N 7</span></strong><br/><strong><span class="koboSpan" id="kobo.66.1">my_func called by thread N 8</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1">my_func called by thread N 9</span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">--Return--</span></strong><br/><strong><span class="koboSpan" id="kobo.69.1">&gt; c:\users\giancarlo\desktop\python parallel programming cookbook 2nd edition\python parallel programming new book\chapter_x- code debugging\rpdb_code_example.py(20)&lt;module&gt;()-&gt;None</span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">-&gt; main()</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">(Pdb)</span></strong></pre>
<p><span class="koboSpan" id="kobo.72.1">Once the program is finished, you can still run a new debug section. </span><span class="koboSpan" id="kobo.72.2">Now, let's see how </span><kbd><span class="koboSpan" id="kobo.73.1">rpdp</span></kbd><span class="koboSpan" id="kobo.74.1"> works </span><span><span class="koboSpan" id="kobo.75.1">in the next section</span></span><span class="koboSpan" id="kobo.76.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this section, we'll see how to </span><span><span class="koboSpan" id="kobo.3.1">simply </span></span><span class="koboSpan" id="kobo.4.1">move through the code by using the </span><kbd><span class="koboSpan" id="kobo.5.1">next</span></kbd><span class="koboSpan" id="kobo.6.1"> statement, which continues execution until the next line in the current function is reached or returned.</span></p>
<p><span class="koboSpan" id="kobo.7.1">To use </span><kbd><span class="koboSpan" id="kobo.8.1">rpdb</span></kbd><span class="koboSpan" id="kobo.9.1">, follow these steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.10.1">Import the relevant </span><kbd><span class="koboSpan" id="kobo.11.1">rpdb</span></kbd><span class="koboSpan" id="kobo.12.1"> library:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.13.1">import rpdb</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.14.1">Set the </span><kbd><span class="koboSpan" id="kobo.15.1">debugger</span></kbd><span class="koboSpan" id="kobo.16.1"> parameter, which specifies the telnet port to connect to in order to run the debugger:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.17.1">debugger = rpdb.Rpdb(port=4444)</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.18.1">Call the  </span><kbd><span class="koboSpan" id="kobo.19.1">set_trace()</span></kbd><span class="koboSpan" id="kobo.20.1">  directive, which makes it possible to enter into debugging mode:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.21.1">rpdb.Rpdb().set_trace()</span></pre>
<p><span class="koboSpan" id="kobo.22.1">In our case, we placed the </span><kbd><span class="koboSpan" id="kobo.23.1">set_trace()</span></kbd><span class="koboSpan" id="kobo.24.1"> directive immediately after the </span><kbd><span class="koboSpan" id="kobo.25.1">debugger</span></kbd><span class="koboSpan" id="kobo.26.1"> instance. </span><span class="koboSpan" id="kobo.26.2">In reality, we can place it anywhere in the code; for example, if conditions are satisfied, or within a section managed by an exception.</span></p>
<p><span class="koboSpan" id="kobo.27.1">The second step, instead, consists of opening Command Prompt and launching </span><kbd><span class="koboSpan" id="kobo.28.1">telnet</span></kbd><span class="koboSpan" id="kobo.29.1"> by setting the same port value specified in the </span><kbd><span class="koboSpan" id="kobo.30.1">debugger</span></kbd><span class="koboSpan" id="kobo.31.1"> parameter definition within the sample code:</span></p>
<pre><strong><span class="koboSpan" id="kobo.32.1">telnet localhost 4444</span></strong></pre>
<p><span class="koboSpan" id="kobo.33.1">It is possible to interact with the </span><kbd><span class="koboSpan" id="kobo.34.1">rpdb</span></kbd><span class="koboSpan" id="kobo.35.1"> debugger by using a small command language that allows movement between calls to the stack, to examine and to modify the values of the variables and control the way in which the debugger executes its own program.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The list of commands with which you can interact with in </span><kbd><span class="koboSpan" id="kobo.3.1">rpdb</span></kbd><span class="koboSpan" id="kobo.4.1"> can be displayed by typing the </span><kbd><span class="koboSpan" id="kobo.5.1">help</span></kbd><span class="koboSpan" id="kobo.6.1"> command from the </span><kbd><span class="koboSpan" id="kobo.7.1">Pdb</span></kbd><span class="koboSpan" id="kobo.8.1"> prompt:</span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1">&gt; c:\users\giancarlo\desktop\python parallel programming cookbook 2nd edition\python parallel programming new book\chapter_x- code debugging\rpdb_code_example.py(7)&lt;module&gt;()</span></strong><br/><strong><span class="koboSpan" id="kobo.10.1">-&gt; def my_func(thread_number):</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">(Pdb) help</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.12.1">Documented commands (type help &lt;topic&gt;):</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">========================================</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">EOF   c   d   h list q rv undisplay</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">a cl debug help ll quit s unt</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">alias clear disable ignore longlist r source until</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">args commands display interact n restart step up</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">b condition down j next return tbreak w</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">break cont enable jump p retval u whatis</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">bt continue exit l pp run unalias where</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.21.1">Miscellaneous help topics:</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">==========================</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">pdb exec</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.24.1">(Pdb)</span></strong></pre>
<p><span class="koboSpan" id="kobo.25.1">Among the most useful commands, this is how we insert the breakpoints in the code:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.26.1">Type </span><kbd><span class="koboSpan" id="kobo.27.1">b</span></kbd><span class="koboSpan" id="kobo.28.1"> and the line number</span><em><span class="koboSpan" id="kobo.29.1"> </span></em><span><span class="koboSpan" id="kobo.30.1">to set a breakpoint. </span><span class="koboSpan" id="kobo.30.2">Here, a breakpoint is set in lines</span></span><span class="koboSpan" id="kobo.31.1"> </span><kbd><span class="koboSpan" id="kobo.32.1">5</span></kbd> <span><span class="koboSpan" id="kobo.33.1">and</span></span> <kbd><span class="koboSpan" id="kobo.34.1">10</span></kbd><span><span class="koboSpan" id="kobo.35.1">:</span></span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.36.1"> (Pdb) b 5</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">Breakpoint 1 at c:\users\giancarlo\desktop\python parallel programming cookbook 2nd edition\python parallel programming new book\chapter_x- code debugging\rpdb_code_example.py:5</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">(Pdb) b 10</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">Breakpoint 2 at c:\users\giancarlo\desktop\python parallel programming cookbook 2nd edition\python parallel programming new book\chapter_x- code debugging\rpdb_code_example.py:10</span></strong></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.40.1">It is sufficient to type the </span><kbd><span class="koboSpan" id="kobo.41.1">b</span></kbd><span class="koboSpan" id="kobo.42.1"> command to display the list of breakpoints implemented:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.43.1"> (Pdb) b</span></strong><br/><strong><span class="koboSpan" id="kobo.44.1">Num Type Disp Enb Where</span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">1 breakpoint keep yes at c:\users\giancarlo\desktop\python parallel programming cookbook 2nd edition\python parallel programming new book\chapter_x- code debugging\rpdb_code_example.py:5</span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">2 breakpoint keep yes at c:\users\giancarlo\desktop\python parallel programming cookbook 2nd edition\python parallel programming new book\chapter_x- code debugging\rpdb_code_example.py:10</span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">(Pdb)</span></strong></pre>
<p><span class="koboSpan" id="kobo.48.1">At each new breakpoint added, a numeric identifier is assigned. </span><span class="koboSpan" id="kobo.48.2">These identifiers are used to enable, disable, and interactively remove breakpoints. </span><span class="koboSpan" id="kobo.48.3">To disable a breakpoint, use the </span><kbd><span class="koboSpan" id="kobo.49.1">disable</span></kbd><span class="koboSpan" id="kobo.50.1"> command, which tells the debugger not to stop when that line is reached. </span><span class="koboSpan" id="kobo.50.2">The breakpoint is not forgotten but is ignored.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You can find a lot of information on </span><kbd><span class="koboSpan" id="kobo.3.1">pdb</span></kbd><span class="koboSpan" id="kobo.4.1">, and then on </span><kbd><span class="koboSpan" id="kobo.5.1">rpdb</span></kbd><span class="koboSpan" id="kobo.6.1">, on this site: </span><a href="https://github.com/spiside/pdb-tutorial"><span class="koboSpan" id="kobo.7.1">https://github.com/spiside/pdb-tutorial</span></a><span class="koboSpan" id="kobo.8.1">.</span><a href="https://github.com/spiside/pdb-tutorial"/></p>
<p><span class="koboSpan" id="kobo.9.1">In the next two sections, we will look at some Python tools that are used for the implementation of unit tests:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.10.1">unittest</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.11.1">nose</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dealing with unittest</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">unittest</span></kbd><span class="koboSpan" id="kobo.4.1"> module is provided with the standard Python library. </span><span class="koboSpan" id="kobo.4.2">It has an extensive set of tools and procedures for performing unit tests. </span><span class="koboSpan" id="kobo.4.3">In this section, we'll briefly see how the </span><kbd><span class="koboSpan" id="kobo.5.1">unittest</span></kbd><span class="koboSpan" id="kobo.6.1"> module works. </span></p>
<p><span><span class="koboSpan" id="kobo.7.1">A unit test consists of two parts:</span></span></p>
<ul>
<li><span><span class="koboSpan" id="kobo.8.1">The code to manage the so-called </span></span><em><span class="koboSpan" id="kobo.9.1">test system</span></em></li>
<li><span class="koboSpan" id="kobo.10.1">The test itself</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The simplest </span><kbd><span class="koboSpan" id="kobo.3.1">unittest</span></kbd> <span><span class="koboSpan" id="kobo.4.1">module </span></span><span class="koboSpan" id="kobo.5.1">can be obtained via the </span><kbd><span class="koboSpan" id="kobo.6.1">TestCase</span></kbd><span class="koboSpan" id="kobo.7.1"> subclass, to which the appropriate methods must be rewritten or added.</span></p>
<p><span class="koboSpan" id="kobo.8.1">A simple </span><kbd><span class="koboSpan" id="kobo.9.1">unittest</span></kbd> <span><span class="koboSpan" id="kobo.10.1">module </span></span><span class="koboSpan" id="kobo.11.1">can be composed as follows:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">import unittest</span><br/><br/><span class="koboSpan" id="kobo.13.1">class SimpleUnitTest(unittest.TestCase):</span><br/><br/><span class="koboSpan" id="kobo.14.1">    def test(self):</span><br/><span class="koboSpan" id="kobo.15.1">        self.assertTrue(True)</span><br/><br/><span class="koboSpan" id="kobo.16.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.17.1">    unittest.main()</span></pre>
<p><span class="koboSpan" id="kobo.18.1">To run the </span><kbd><span class="koboSpan" id="kobo.19.1">unittest</span></kbd><span class="koboSpan" id="kobo.20.1"> </span><span><span class="koboSpan" id="kobo.21.1">module,</span></span><span class="koboSpan" id="kobo.22.1"> you need to include </span><kbd><span class="koboSpan" id="kobo.23.1">unittest.main ()</span></kbd><span class="koboSpan" id="kobo.24.1">, while we have a single method, </span><kbd><span class="koboSpan" id="kobo.25.1">test()</span></kbd><span class="koboSpan" id="kobo.26.1">, which fails if </span><kbd><span class="koboSpan" id="kobo.27.1">True</span></kbd><span class="koboSpan" id="kobo.28.1"> is ever </span><kbd><span class="koboSpan" id="kobo.29.1">False</span></kbd><span class="koboSpan" id="kobo.30.1">.</span></p>
<p><span class="koboSpan" id="kobo.31.1">By executing the preceding example, you get the following result:</span></p>
<pre><strong><span class="koboSpan" id="kobo.32.1">-----------------------------------------------------------</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">Ran 1 test in 0.005s</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.34.1">OK</span></strong></pre>
<p><span class="koboSpan" id="kobo.35.1">The test was successful, thus giving the result, </span><kbd><span class="koboSpan" id="kobo.36.1">OK</span></kbd><span class="koboSpan" id="kobo.37.1">.</span></p>
<p><span class="koboSpan" id="kobo.38.1">In the following section, we go into more detail about how the </span><kbd><span class="koboSpan" id="kobo.39.1">unittest</span></kbd><span class="koboSpan" id="kobo.40.1"> module works. </span><span class="koboSpan" id="kobo.40.2">In particular, we want to study what the possible outcomes of a unit test</span><span><span class="koboSpan" id="kobo.41.1"> are</span></span><span class="koboSpan" id="kobo.42.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's see how we can characterize the results of a test with this example:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">Import the relevant module:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.4.1">import unittest</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.5.1">Define the </span><kbd><span class="koboSpan" id="kobo.6.1">outcomesTest</span></kbd> <span><span class="koboSpan" id="kobo.7.1">class, </span></span><span class="koboSpan" id="kobo.8.1">which has the </span><kbd><span class="koboSpan" id="kobo.9.1">TestCase</span></kbd><span><span class="koboSpan" id="kobo.10.1"> subclass</span></span><span><span class="koboSpan" id="kobo.11.1"> as its argument:</span></span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><span class="koboSpan" id="kobo.12.1">class OutcomesTest(unittest.TestCase):</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.13.1">The first method we define is </span><kbd><span class="koboSpan" id="kobo.14.1">testPass</span></kbd><span class="koboSpan" id="kobo.15.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.16.1">    def testPass(self):</span><br/><span class="koboSpan" id="kobo.17.1">        return</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.18.1">Here is the </span><kbd><span class="koboSpan" id="kobo.19.1">TestFail</span></kbd><span class="koboSpan" id="kobo.20.1"> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.21.1">    def testFail(self):</span><br/><span class="koboSpan" id="kobo.22.1">        self.failIf(True)</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.23.1">Next, we have the </span><kbd><span class="koboSpan" id="kobo.24.1">TestError</span></kbd><span class="koboSpan" id="kobo.25.1"> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.26.1">    def testError(self):</span><br/><span class="koboSpan" id="kobo.27.1">        raise RuntimeError('test error!')</span></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.28.1">Finally,</span><span><span class="koboSpan" id="kobo.29.1"> we have</span></span><span class="koboSpan" id="kobo.30.1"> the </span><kbd><span class="koboSpan" id="kobo.31.1">main</span></kbd><span class="koboSpan" id="kobo.32.1"> function, with which we recall our procedure:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.33.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.34.1">    unittest.main()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this example, the possible outcomes of a unit test by </span><kbd><span class="koboSpan" id="kobo.3.1">unittest</span></kbd><span class="koboSpan" id="kobo.4.1"> are shown.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The possible outcomes are as follows:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.6.1">ERROR</span></kbd><span class="koboSpan" id="kobo.7.1">: The test raises an exception other than </span><kbd><span class="koboSpan" id="kobo.8.1">AssertionError</span></kbd><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">There is no explicit way to pass a test, so the test status depends on the presence (or absence) of an exception.</span></li>
</ul>
<ul>
<li><kbd><span class="koboSpan" id="kobo.10.1">FAILED</span></kbd><span class="koboSpan" id="kobo.11.1">: The test is not passed and an </span><kbd><span class="koboSpan" id="kobo.12.1">AssertionError</span></kbd><span class="koboSpan" id="kobo.13.1"> exception is raised.</span></li>
<li><kbd><span class="koboSpan" id="kobo.14.1">OK</span></kbd><span class="koboSpan" id="kobo.15.1">: The test is passed.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.16.1">The output is as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.17.1">===========================================================</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">ERROR: testError (__main__.OutcomesTest)</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">-----------------------------------------------------------</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">Traceback (most recent call last):</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">  File "unittest_outcomes.py", line 15, in testError</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">    raise RuntimeError('Errore nel test!')</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">RuntimeError: Errore nel test!</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.24.1">===========================================================</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">FAIL: testFail (__main__.OutcomesTest)</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">-----------------------------------------------------------</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">Traceback (most recent call last):</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">  File "unittest_outcomes.py", line 12, in testFail</span></strong><br/><strong><span class="koboSpan" id="kobo.29.1">    self.failIf(True)</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">AssertionError</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.31.1">-----------------------------------------------------------</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">Ran 3 tests in 0.000s</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.33.1">FAILED (failures=1, errors=1)</span></strong></pre>
<p><span class="koboSpan" id="kobo.34.1">Most tests affirm the truth of a condition. </span><span class="koboSpan" id="kobo.34.2">There are different ways of writing tests that verify a truth, depending on the perspective of the author of the test and whether the desired result of the code is verified. </span><span class="koboSpan" id="kobo.34.3">If the code produces a value that can be evaluated as true, then the </span><kbd><span class="koboSpan" id="kobo.35.1">failUnless</span><span><span class="koboSpan" id="kobo.36.1"> </span></span><span class="koboSpan" id="kobo.37.1">()</span></kbd><span class="koboSpan" id="kobo.38.1"> and</span><span><span class="koboSpan" id="kobo.39.1"> </span></span><kbd><span class="koboSpan" id="kobo.40.1">assertTrue</span><span><span class="koboSpan" id="kobo.41.1"> </span></span><span class="koboSpan" id="kobo.42.1">()</span></kbd><span class="koboSpan" id="kobo.43.1"> methods should be used. </span><span class="koboSpan" id="kobo.43.2">If the code produces a false value, </span><span><span class="koboSpan" id="kobo.44.1">then </span></span><span class="koboSpan" id="kobo.45.1">it makes more sense to use the </span><kbd><span class="koboSpan" id="kobo.46.1">failIf</span><span><span class="koboSpan" id="kobo.47.1"> </span></span><span class="koboSpan" id="kobo.48.1">()</span></kbd><span class="koboSpan" id="kobo.49.1"> and </span><kbd><span class="koboSpan" id="kobo.50.1">assertFalse</span><span><span class="koboSpan" id="kobo.51.1"> </span></span><span class="koboSpan" id="kobo.52.1">()</span></kbd><span class="koboSpan" id="kobo.53.1"> methods:</span></p>
<pre><span class="koboSpan" id="kobo.54.1">import unittest</span><br/><br/><span class="koboSpan" id="kobo.55.1">class TruthTest(unittest.TestCase):</span><br/><br/><span class="koboSpan" id="kobo.56.1">    def testFailUnless(self):</span><br/><span class="koboSpan" id="kobo.57.1">        self.failUnless(True)</span><br/><br/><span class="koboSpan" id="kobo.58.1">    def testAssertTrue(self):</span><br/><span class="koboSpan" id="kobo.59.1">        self.assertTrue(True)</span><br/><br/><span class="koboSpan" id="kobo.60.1">    def testFailIf(self):</span><br/><span class="koboSpan" id="kobo.61.1">        self.</span><span><span class="koboSpan" id="kobo.62.1">assertFalse</span></span><span class="koboSpan" id="kobo.63.1">(False)</span><br/><br/><span class="koboSpan" id="kobo.64.1">    def testAssertFalse(self):</span><br/><span class="koboSpan" id="kobo.65.1">        self.assertFalse(False)</span><br/><br/><span class="koboSpan" id="kobo.66.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.67.1">    unittest.main()</span></pre>
<p><span class="koboSpan" id="kobo.68.1">The result is as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.69.1">&gt; python unittest_failwithmessage.py -v</span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">testFail (__main__.FailureMessageTest) ... </span><span class="koboSpan" id="kobo.70.2">FAIL</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.71.1">===========================================================</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">FAIL: testFail (__main__.FailureMessageTest)</span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">-----------------------------------------------------------</span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">Traceback (most recent call last):</span></strong><br/><strong><span class="koboSpan" id="kobo.75.1">  File "unittest_failwithmessage.py", line 9, in testFail</span></strong><br/><strong><span class="koboSpan" id="kobo.76.1">    self.failIf(True, 'Il messaggio di fallimento va qui')</span></strong><br/><strong><span class="koboSpan" id="kobo.77.1">AssertionError: Il messaggio di fallimento va qui</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.78.1">-----------------------------------------------------------</span></strong><br/><strong><span class="koboSpan" id="kobo.79.1">Ran 1 test in 0.000s</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.80.1">FAILED (failures=1)</span></strong><br/><strong><span class="koboSpan" id="kobo.81.1">robby@robby-desktop:~/pydev/pymotw-it/dumpscripts$ python unittest_truth.py -v</span></strong><br/><strong><span class="koboSpan" id="kobo.82.1">testAssertFalse (__main__.TruthTest) ... </span><span class="koboSpan" id="kobo.82.2">ok</span></strong><br/><strong><span class="koboSpan" id="kobo.83.1">testAssertTrue (__main__.TruthTest) ... </span><span class="koboSpan" id="kobo.83.2">ok</span></strong><br/><strong><span class="koboSpan" id="kobo.84.1">testFailIf (__main__.TruthTest) ... </span><span class="koboSpan" id="kobo.84.2">ok</span></strong><br/><strong><span class="koboSpan" id="kobo.85.1">testFailUnless (__main__.TruthTest) ... </span><span class="koboSpan" id="kobo.85.2">ok</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.86.1">-----------------------------------------------------------</span></strong><br/><strong><span class="koboSpan" id="kobo.87.1">Ran 4 tests in 0.000s</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.88.1">OK</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As mentioned previously, if a test raises an exception other than </span><kbd><span class="koboSpan" id="kobo.3.1">AssertionError</span></kbd><span class="koboSpan" id="kobo.4.1">, then it is treated as an error. </span><span class="koboSpan" id="kobo.4.2">This is very useful for discovering errors that occur while you are editing code for which a matched test already exists.</span></p>
<p><span class="koboSpan" id="kobo.5.1">There are circumstances, however, in which you would want to run a test to verify that certain code actually produces an exception. </span><span class="koboSpan" id="kobo.5.2">For example, in cases when an invalid value is passed as an attribute of an object. </span><span class="koboSpan" id="kobo.5.3">In such cases, </span><kbd><span class="koboSpan" id="kobo.6.1">failUnlessRaises()</span></kbd><span class="koboSpan" id="kobo.7.1"> makes the code clearer than capturing the exception in your code:</span></p>
<pre><span class="koboSpan" id="kobo.8.1">import unittest</span><br/><br/><span class="koboSpan" id="kobo.9.1">def raises_error(*args, **kwds):</span><br/><span class="koboSpan" id="kobo.10.1">    print (args, kwds)</span><br/><span class="koboSpan" id="kobo.11.1">    raise ValueError\</span><br/><span class="koboSpan" id="kobo.12.1">        ('Valore non valido:'+ str(args)+ str(kwds))</span><br/><br/><span class="koboSpan" id="kobo.13.1">class ExceptionTest(unittest.TestCase):</span><br/><span class="koboSpan" id="kobo.14.1">    def testTrapLocally(self):</span><br/><span class="koboSpan" id="kobo.15.1">        try:</span><br/><span class="koboSpan" id="kobo.16.1">            raises_error('a', b='c')</span><br/><span class="koboSpan" id="kobo.17.1">        except ValueError:</span><br/><span class="koboSpan" id="kobo.18.1">            pass</span><br/><span class="koboSpan" id="kobo.19.1">        else:</span><br/><span class="koboSpan" id="kobo.20.1">            self.fail('Non si vede ValueError')</span><br/><br/><span class="koboSpan" id="kobo.21.1">    def testFailUnlessRaises(self):</span><br/><span class="koboSpan" id="kobo.22.1">       self.assertRaises\</span><br/><span class="koboSpan" id="kobo.23.1">               (ValueError, raises_error, 'a', b='c')</span><br/><br/><span class="koboSpan" id="kobo.24.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.25.1">    unittest.main()</span></pre>
<p><span class="koboSpan" id="kobo.26.1">The results for both are the same. </span><span class="koboSpan" id="kobo.26.2">However, the result for the second test, which uses </span><kbd><span class="koboSpan" id="kobo.27.1">failUnlessRaises()</span></kbd><span class="koboSpan" id="kobo.28.1">, is shorter:</span></p>
<pre><strong><span class="koboSpan" id="kobo.29.1">&gt; python unittest_exception.py -v</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">testFailUnlessRaises (__main__.ExceptionTest) ... </span><span class="koboSpan" id="kobo.30.2">('a',) {'b': 'c'}</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">ok</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">testTrapLocally (__main__.ExceptionTest) ...('a',) {'b': 'c'}</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">ok</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.34.1">-----------------------------------------------------------</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">Ran 2 tests in 0.000s</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.36.1">OK</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">More information on Python testing can be found at </span><a href="https://realpython.com/python-testing/"><span class="koboSpan" id="kobo.3.1">https://realpython.com/python-testing/</span></a><span class="koboSpan" id="kobo.4.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Application testing using nose</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">nose</span></kbd><span class="koboSpan" id="kobo.3.1"> is an important Python module for defining unit tests. </span><span class="koboSpan" id="kobo.3.2">It allows us to write simple test functions using subclasses of </span><kbd><span class="koboSpan" id="kobo.4.1">unittest.TestCase</span></kbd><span class="koboSpan" id="kobo.5.1"> but also, classes of tests that are </span><em><span class="koboSpan" id="kobo.6.1">not subclasse</span></em><span class="koboSpan" id="kobo.7.1">s of </span><kbd><span class="koboSpan" id="kobo.8.1">unittest.TestCase</span></kbd><span class="koboSpan" id="kobo.9.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Install </span><kbd><span class="koboSpan" id="kobo.3.1">nose</span></kbd><span class="koboSpan" id="kobo.4.1"> by using </span><kbd><span class="koboSpan" id="kobo.5.1">pip</span></kbd><span class="koboSpan" id="kobo.6.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.7.1">C:\&gt;pip install nose</span></strong></pre>
<p><span class="koboSpan" id="kobo.8.1">The source package can be downloaded and installed at </span><a href="https://pypi.org/project/nose/"><span class="koboSpan" id="kobo.9.1">https://pypi.org/project/nose/</span></a><span class="koboSpan" id="kobo.10.1"> by following these steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.11.1">Unzip the source package.</span></li>
<li><kbd><span class="koboSpan" id="kobo.12.1">cd</span></kbd><span class="koboSpan" id="kobo.13.1"> to the new directory.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.14.1">Then, enter the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.15.1">C:\&gt;python setup.py install</span></strong></pre>
<p><span class="koboSpan" id="kobo.16.1">One of the strengths of </span><kbd><span class="koboSpan" id="kobo.17.1">nose</span></kbd><span class="koboSpan" id="kobo.18.1"> is automatically collecting tests from the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Python source files</span></li>
<li><span class="koboSpan" id="kobo.20.1">Directories and packages found in the working directory</span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">To specify which tests to run, pass the relevant test names on the command line:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.22.1">C:\&gt;nosetests only_test_this.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.23.1">The test names specified may be file or module names, and may optionally indicate the test case to run by separating the module or filename from the test case name with a colon. </span><span class="koboSpan" id="kobo.23.2">Filenames may be relative or absolute.</span></p>
<p><span class="koboSpan" id="kobo.24.1">Some examples are as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.25.1">C:\&gt;nosetests test.module</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">C:\&gt;nosetests another.test:TestCase.test_method</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">C:\&gt;nosetests a.test:TestCase</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">C:\&gt;nosetests /path/to/test/file.py:test_function</span></strong></pre>
<p><span class="koboSpan" id="kobo.29.1">You may also change the working directory, where </span><kbd><span class="koboSpan" id="kobo.30.1">nose</span></kbd><span class="koboSpan" id="kobo.31.1"> looks for tests, by using the </span><kbd><span class="koboSpan" id="kobo.32.1">-w</span></kbd><span class="koboSpan" id="kobo.33.1"> switch:</span></p>
<pre><strong><span class="koboSpan" id="kobo.34.1">C:\&gt;nosetests -w /path/to/tests</span></strong></pre>
<p><span class="koboSpan" id="kobo.35.1">Note, however, that support for multiple </span><kbd><span class="koboSpan" id="kobo.36.1">-w</span></kbd><span class="koboSpan" id="kobo.37.1"> arguments is now deprecated and will be removed in a future release. However, it is possible to get the same behavior by specifying the target directories without the </span><kbd><span class="koboSpan" id="kobo.38.1">-w</span></kbd><span class="koboSpan" id="kobo.39.1"> switch:</span></p>
<pre><strong><span class="koboSpan" id="kobo.40.1">C:\&gt;nosetests /path/to/tests /another/path/to/tests</span></strong></pre>
<p><span class="koboSpan" id="kobo.41.1">Further customization of test selection and loading is possible through the use of plugins.</span></p>
<p><span class="koboSpan" id="kobo.42.1">The test result output is identical to that of </span><kbd><span class="koboSpan" id="kobo.43.1">unittest</span></kbd><span class="koboSpan" id="kobo.44.1">, except for the additional features, such as error classes, and plugin-supplied features such as output capture and assert introspection.</span></p>
<p><span class="koboSpan" id="kobo.45.1">In the next section, we look at testing a class using </span><kbd><span class="koboSpan" id="kobo.46.1">nose</span></kbd><em><span class="koboSpan" id="kobo.47.1">.</span></em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's perform the steps that follow:</span></p>
<ol>
<li class="CDPAlignLeft CDPAlign"><span class="koboSpan" id="kobo.3.1">Import the relevant </span><kbd><span class="koboSpan" id="kobo.4.1">nose.tools</span></kbd><em><span class="koboSpan" id="kobo.5.1">:</span></em></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.6.1">from nose.tools import eq_ </span></pre>
<ol start="2">
<li><span><span class="koboSpan" id="kobo.7.1">Then, set the </span><kbd><span class="koboSpan" id="kobo.8.1">TestSuite</span></kbd><span class="koboSpan" id="kobo.9.1"> class. </span><span class="koboSpan" id="kobo.9.2">Here,</span><em><span class="koboSpan" id="kobo.10.1"> </span></em><span class="koboSpan" id="kobo.11.1">the methods of the class are tested by the </span><kbd><span class="koboSpan" id="kobo.12.1">eq_</span></kbd><span class="koboSpan" id="kobo.13.1"> function:</span></span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.14.1">class TestSuite:</span><br/><span class="koboSpan" id="kobo.15.1">    def test_mult(self):</span><br/><span class="koboSpan" id="kobo.16.1">        eq_(2*2,4)</span><br/>        <br/><span class="koboSpan" id="kobo.17.1">    def ignored(self):</span><br/><span class="koboSpan" id="kobo.18.1">        eq_(2*2,3)</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A unit test can be developed independently by the developer, but it is good practice to have a standard product such as </span><kbd><span class="koboSpan" id="kobo.3.1">unittest</span></kbd><span class="koboSpan" id="kobo.4.1"> and adhere to a common test practice. </span></p>
<p><span><span class="koboSpan" id="kobo.5.1">As you can see from the following example, the test method was set by using the </span><kbd><span class="koboSpan" id="kobo.6.1">eq_</span></kbd><span class="koboSpan" id="kobo.7.1"> function. </span><span class="koboSpan" id="kobo.7.2">This is similar to </span><kbd><span class="koboSpan" id="kobo.8.1">assertEquals</span></kbd><span class="koboSpan" id="kobo.9.1"> by </span><kbd><span class="koboSpan" id="kobo.10.1">unittest</span></kbd><span class="koboSpan" id="kobo.11.1">, which verifies that the two parameters are equal:</span></span></p>
<pre><span class="koboSpan" id="kobo.12.1">    def test_mult(self):</span><br/><span class="koboSpan" id="kobo.13.1">        eq_(2*2,4)</span><br/>        <br/><span class="koboSpan" id="kobo.14.1">    def ignored(self):</span><br/><span class="koboSpan" id="kobo.15.1">        eq_(2*2,3)</span></pre>
<p><span class="koboSpan" id="kobo.16.1">This testing practice, despite good in intentions, has obvious limitations, such as not being able to be repeated over time (for example, when a software module changes) for so-called </span><strong><span class="koboSpan" id="kobo.17.1">regression tests</span></strong><span class="koboSpan" id="kobo.18.1">.</span></p>
<p><span class="koboSpan" id="kobo.19.1">Here is the output:</span></p>
<pre><strong><span class="koboSpan" id="kobo.20.1">C:\&gt;nosetests -v testset.py</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">testset.TestSuite.test_mult ... </span><span class="koboSpan" id="kobo.21.2">ok</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.22.1">-----------------------------------------------------------</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">Ran 1 tests in 0.001s</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.24.1">OK</span></strong></pre>
<p><span class="koboSpan" id="kobo.25.1">In general, testing is not able to identify all the errors in a program and the same is true for unit testing, which, by analyzing individual units by definition, cannot identify integration errors, performance problems, and other system-related problems. </span><span class="koboSpan" id="kobo.25.2">In general, unit testing is more effective when used in conjunction with other software testing techniques.</span></p>
<p><span class="koboSpan" id="kobo.26.1">Like any form of testing, even unit testing cannot certify the absence of errors, but can only </span><em><span class="koboSpan" id="kobo.27.1">highlight</span></em><span class="koboSpan" id="kobo.28.1"> their presence.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Software testing is a combinatorial mathematics problem. </span><span class="koboSpan" id="kobo.2.2">For example, each Boolean test requires at least two tests, one for the true condition and one for the false condition. </span><span class="koboSpan" id="kobo.2.3">It can be shown that, for each functional code line, three to five lines of code are required for a test. </span><span class="koboSpan" id="kobo.2.4">It is therefore unrealistic to test all possible input combinations of any non-trivial code without a dedicated test case generation tool.</span></p>
<p><span class="koboSpan" id="kobo.3.1">To achieve the desired benefits from a unit test, a strict sense of discipline is required throughout the development process. </span><span class="koboSpan" id="kobo.3.2">It is essential to keep track not only of the tests that have been developed and performed but also of all the changes made to the functional code of the unit in question and all the other units. </span><span class="koboSpan" id="kobo.3.3">The use of a version control system is essential. </span><span class="koboSpan" id="kobo.3.4">If a later version of a unit fails a test that it previously passed, then a version control system allow you to highlight the code changes that have occurred in the meantime.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A valid tutorial on </span><kbd><span class="koboSpan" id="kobo.3.1">nose</span></kbd><span class="koboSpan" id="kobo.4.1"> is available at </span><a href="https://nose.readthedocs.io/en/latest/index.html"><span class="koboSpan" id="kobo.5.1">https://nose.readthedocs.io/en/latest/index.html</span></a><span class="koboSpan" id="kobo.6.1">.</span></p>


            </article>

            
        </section>
    </body></html>