- en: Chapter 9. Improving Performance – Part Two, NumPy and Parallelization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。提高性能 – 第二部分，NumPy 和并行化
- en: 'This is the final chapter in the series of the three chapters on performance
    improvement. It will introduce you to two important libraries, **NumPy**, a third-party
    package, and the built-in **multiprocessing** module. In this chapter, we will
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于性能改进的三章中的最后一章。它将介绍两个重要的库，**NumPy**，一个第三方包，以及内置的 **multiprocessing** 模块。在本章中，我们将涵盖以下主题：
- en: A brief introduction to the NumPy package
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 包的简要介绍
- en: Using NumPy to speed up the *Gold Hunt* application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NumPy 加速 *Gold Hunt* 应用
- en: An introduction to parallel processing using the `multiprocessing` module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `multiprocessing` 模块介绍并行处理
- en: Using the `multiprocessing` module to further improve the application runtime
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `multiprocessing` 模块进一步改善应用运行时间
- en: Prerequisites for this chapter
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的先决条件
- en: You should read the last two chapters, [Chapter 7](ch07.html "Chapter 7. Performance
    – Identifying Bottlenecks"), *Performance – Identifying Bottlenecks*, and [Chapter
    8](ch08.html "Chapter 8. Improving Performance – Part One"), *Improving Performance
    – Part one*, on performance that teaches you how to identify the performance bottlenecks
    and improve the runtime using built-in functionality. This chapter takes the application
    to the next level by drastically improving performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该阅读最后两个章节，[第7章](ch07.html "第7章。性能 – 识别瓶颈")，*性能 – 识别瓶颈*，和[第8章](ch08.html "第8章。提高性能
    – 第一部分")，*提高性能 – 第一部分*，这些章节介绍了如何识别性能瓶颈并使用内置功能来提高运行时间。本章通过大幅提高性能将应用提升到下一个层次。
- en: This is how the chapter is organized
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是本章的组织结构
- en: This chapter will be the *Part two* of performance improvement. Just like the
    previous chapter, the performance of the *Gold Hunt* program will be improved
    in steps. We will start with a quick introduction to NumPy, just enough to use
    its functionality for *optimization passes four* and *five*, which follow next.
    Moving ahead, there will be a superficial introduction to the `multiprocessing`
    module. In *optimization pass six*, we will use this module to parallelize a portion
    of the application code. Let's pull up the same bar chart from the previous chapter.
    The last two bars indicate the speedup accomplished by the end of this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是性能改进的 *第二部分*。就像上一章一样，*Gold Hunt* 程序的性能将通过逐步改进。我们将从对 NumPy 的快速介绍开始，仅足够使用其功能进行
    *优化过程四* 和 *五*，接下来将介绍。继续前进，将对 `multiprocessing` 模块进行浅显的介绍。在 *优化过程六* 中，我们将使用此模块来并行化应用代码的一部分。让我们拉起上一章中相同的柱状图。最后两个柱子表示到本章结束时实现的加速。
- en: '![This is how the chapter is organized](img/B05034_09_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![这是本章的组织结构](img/B05034_09_01.jpg)'
- en: But the chart does not tell the full story. The *optimization pass four*, will
    significantly speedup the `generate_random_points` function of the *Gold Hunt*
    program. This speedup is not reflected in the chart as the function does not significantly
    contribute to the runtime in this scenario. Towards the end, the chapter will
    provide preliminary information on **PyPy** for further reading. PyPy is a Python
    interpreter that provides a **Just In Time** (**JIT**) compiler.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但图表并没有讲述完整的故事。*优化过程四*将显著加快 *Gold Hunt* 程序的 `generate_random_points` 函数。这种加速在图表中没有体现，因为在这个场景中该函数对运行时间没有显著贡献。在结尾部分，本章将提供关于
    **PyPy** 的初步信息，供进一步阅读。PyPy 是一个提供 **即时** (**JIT**) 编译器的 Python 解释器。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Running Gold Hunt optimization examples**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行 Gold Hunt 优化示例**'
- en: If you look closely at the profiling output shown in the upcoming discussion,
    you will notice a filename, `goldhunt_run_master.py`. Using this file is optional
    but it provides a convenient way to run any of the optimization passes. You can
    find this file in this chapter's supporting code bundle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看即将讨论的性能分析输出，你会注意到一个文件名，`goldhunt_run_master.py`。使用此文件是可选的，但它提供了一种方便的方式来运行任何优化过程。你可以在这个章节的支持代码包中找到此文件。
- en: Introduction to NumPy
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 简介
- en: NumPy is a powerful Python package for scientific computing. It provides a multidimensional
    `array` object that enables efficient implementation of numerical computations
    in Python. It also has a relatively smaller memory footprint when compared to
    a list. An `array` object is just one of the many important features of NumPy.
    Among other things, it offers linear algebra and random number generation capabilities.
    It also provides tools to access codes written in other languages, such as C/C++
    and Fortran. Let's start with a short introduction that gives a flavor of its
    capabilities. What we will discuss in this book is more like scratching the surface
    of NumPy! This chapter covers some features to be used later to speed up the *Gold
    Hunt* application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Review the official NumPy documentation ([http://docs.scipy.org](http://docs.scipy.org))
    to learn about several other features that are not covered here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with NumPy, you can optionally skip this introduction
    and directly move on to the *Optimizing Gold Hunt – Part two* section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Installing NumPy
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some Python distributions, such as Anaconda ([https://www.continuum.io/downloads](https://www.continuum.io/downloads)),
    provide NumPy by default. If unavailable, use `pip` to install it. Here is how
    to do it on Linux, assuming `pip` is available as a command in the terminal:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should install NumPy. If you encounter problems, refer to the platform
    specific installation instructions at [http://www.scipy.org/install.html](http://www.scipy.org/install.html).
    Alternatively, you can use the earlier mentioned Anaconda Python distribution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, open the Python interpreter and type the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Assuming the installation is successful, it should import NumPy. For the rest
    of the discussion, we will use the notation `np` as the alias for `numpy`. Keep
    the interpreter window open. For the rest of the introduction, we will run some
    simple NumPy operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Creating array objects
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As noted before, a multidimensional (**N-dimensional**) array object is one
    of the core NumPy capabilities. This array is provided by a built-in class, `numpy.ndarray`.
    It represents a collection of elements of the same type. In other words, it is
    a homogeneous array. There are several ways to create a Numpy array. Type the
    following code in your Python interpreter:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This creates an array instance denoted by the `x` variable with two elements.
    This is of the `numpy.ndarray` type. It is a single dimensional array. You can
    access any element or change its value, just like a Python `list`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this simple example, the size of the array is `2`. This is also called the
    *shape* of an array. NumPy represents the array shape as a tuple of integers.
    It gives the size of the array along each dimension. This is shown in the following
    line of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Continuing further, here is another example that creates a two-dimensional
    array:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `ndim` represents the number of dimensions of an array. The array shape
    indicates the size of two in each dimension.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`ndim`代表数组的维度数。数组形状表示每个维度的大小。
- en: 'Let''s review the `numpy.arange` function. This is similar to the Python `range`
    function. But, `arange` returns an `array` object instead of a `list`. The following
    is another way to create an array using `numpy.arange`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`numpy.arange`函数。这与Python的`range`函数类似。但是，`arange`返回一个`array`对象而不是`list`。以下是用`numpy.arange`创建数组的另一种方法：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are many other ways to create arrays in NumPy. Refer to the documentation,
    ([http://docs.scipy.org/doc/numpy/reference/](http://docs.scipy.org/doc/numpy/reference/))
    for more details. Specifically, look for array creation routines.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy中创建数组的方法有很多。有关更多详细信息，请参阅文档（[http://docs.scipy.org/doc/numpy/reference/](http://docs.scipy.org/doc/numpy/reference/））。特别是，查找数组创建例程。
- en: Simple array operations
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单数组操作
- en: 'We will review some basic mathematical operations that can be performed on
    NumPy arrays. Let''s create two arrays, `x` and `y` (these are one-dimensional
    arrays or vectors):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾一些可以在NumPy数组上执行的基本数学操作。让我们创建两个数组，`x`和`y`（这些是一维数组或向量）：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using these arrays, you can perform mathematical operations, such as addition,
    subtraction, multiplication, and so on. NumPy performs all these operations element
    by element:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些数组，您可以执行数学运算，如加法、减法、乘法等。NumPy按元素逐个执行所有这些操作：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is important to note here that `x*y` is not the inner product. It is just
    a multiplication of the corresponding elements in the `x` and `y` arrays. The
    inner product of these vectors can be accomplished using the `dot` function, as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的是，`x*y`不是内积。它只是`x`和`y`数组中相应元素的乘法。这些向量的内积可以通过`dot`函数实现，如下所示：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code illustrates the concept using a two-dimensional array. Here,
    `x2.dot(y2)` is a matrix multiplication operation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用二维数组说明了这个概念。在这里，`x2.dot(y2)`是一个矩阵乘法操作：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Array slicing and indexing
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组切片和索引
- en: For single dimensional arrays, the **indexing** and **slicing** operations are
    similar to a Python `list`. If you are unfamiliar with the `list` slicing operation,
    refer to [https://docs.python.org/3/tutorial/introduction.html#lists](https://docs.python.org/3/tutorial/introduction.html#lists).
    This is an important concept. In this chapter, we will only need to perform a
    few basic indexing operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一维数组，**索引**和**切片**操作与Python `list`类似。如果您不熟悉`list`切片操作，请参阅[https://docs.python.org/3/tutorial/introduction.html#lists](https://docs.python.org/3/tutorial/introduction.html#lists)。这是一个重要的概念。在本章中，我们只需要执行几个基本的索引操作。
- en: Indexing
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引
- en: 'Array indexing is essentially an operation that enables us to access a particular
    element in an array. Here is a simple one-dimensional array with a size of five:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数组索引本质上是一种操作，使我们能够访问数组中的特定元素。这里有一个简单的一维数组，大小为五个：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The simplest indexing operation is shown below, which accesses an element of
    this array. This operation is similar to how it is done for a Python `list`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了最简单的索引操作，它访问了这个数组的一个元素。这个操作与Python `list`中的操作类似：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is how you can retrieve elements from a two-dimensional array:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您如何从二维数组中检索元素的方法：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once complete, it returns an array with only the first row.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，它返回一个只包含第一行的数组。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'It is important to note that the basic array indexing does not return a copy
    of the original array. It just points to the same memory location as the original
    array. Refer to the following link where the basic and advanced indexing has been
    comprehensively documented: [http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html](http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，基本的数组索引不会返回原始数组的副本。它只是指向与原始数组相同的内存位置。请参阅以下链接，其中详细记录了基本和高级索引：[http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html](http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html）
- en: 'The following code will retrieve a single value from a two-dimensional array:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将从二维数组中检索一个值：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this basic introduction to array indexing, let's learn about some common
    slicing operations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在对数组索引的基本介绍之后，让我们学习一些常见的切片操作。
- en: Slicing
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切片
- en: 'Suppose you want to get an array with only the first two elements. Just like
    a `list`, you will need to specify a start and an end. For example, `b[start:stop]`
    means the resulting (sliced) array will begin at the `start` index and end at
    the `stop-1` index:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly, to get any array with only the elements at the positions `1` and
    `2`, you can do as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the N-dimensional arrays, you have to give the slicing instructions in
    each direction. Consider the following array with four rows and columns:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s slice this array so that it returns only the first row. Here is the
    syntax to do that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you want to get only the first column of `z2` instead, then specify the
    slicing as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following slicing operation will create a new array using elements of the
    first two rows and columns:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To gain a better understanding of array slicing operations, try more examples
    in a Python interpreter. See the documentation for details (search the Web for
    NumPy array slicing).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Broadcasting is another important NumPy feature. Let''s understand this concept
    with a simple example. We have two arrays, `p0` and `p1`, as shown in the following
    example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The shapes of these arrays are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Although the arrays have different shapes, NumPy can perform arithmetic operations
    on these arrays. A basic multiplication operation is shown next:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is referred to as broadcasting. The `p0` array has a smaller shape relative
    to `p1`. The broadcasting enables this array to work with `p1`. In this example,
    it enables the multiplication operation. Of course, the two arrays need to meet
    certain requirements to take advantage of this feature. Refer to the NumPy documentation
    to learn more about broadcasting.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous functions
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at some advanced mathematical operations that you can perform using
    the NumPy arrays.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the operations illustrated here will be used in the upcoming discussion
    on performance improvement using NumPy. So, pay close attention to this section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: numpy.ndarray.tolist
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a handy function that returns the NumPy array as a Python `list` object.
    Depending on the array dimension, it can be a nested list. Here is an example
    that shows this function in action:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: numpy.reshape
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name suggests, it changes the shape of an array without actually changing
    its data. Look at the following code; the `x` array is one dimensional and has
    a size (shape) of `9`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s see how to reshape this into a matrix that has three rows and columns.
    In other words, the following code returns an array with a new shape of `(3,3)`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The new shape selected should be compatible with the original shape of the array;
    otherwise, it will throw an error. For the preceding example, if you reshape it
    as `np.reshape(x, (3,2))`, it will throw a value error complaining about changed
    size.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: numpy.random
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This module provides several functions for random sampling. For a detailed list,
    refer to [http://docs.scipy.org/doc/numpy/reference/routines.random.html](http://docs.scipy.org/doc/numpy/reference/routines.random.html).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review `np.random.uniform` that draws samples from a uniform distribution:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first two arguments of this function represent the lower (`0.0`) and upper
    (`2.0`) boundaries of the output interval. You can specify any float value as
    the limit. All the random values or samples generated by the function lie within
    these two limits. The default lower and upper limits are `0.0` and `1.0`, respectively.
    The `size` argument represents the shape of the output array. In the preceding
    example, it is specified as a single integer value. If you do not specify the
    `size` argument, it defaults to `None`. In that case, the function will simply
    return a single floating point number. The following is a slightly complicated
    example of when the `size` (or shape) argument is a tuple `(2,2)`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Have you already noticed a difference between Python's built-in `random.uniform`
    function and NumPy equivalent's `np.random.uniform`? The Numpy `np.random.uniform`
    function, can optionally give us an `array` object with samples drawn from uniform
    distribution, whereas the built-in `random.uniform` can only give us a single
    number. We will use this NumPy function in *optimization pass four*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: numpy.dstack
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This provides a simple way to stack or concatenate a sequence of arrays along
    a third axis. Consider two NumPy arrays, `x` and `y`, representing the x and y
    coordinates of some points in space. These arrays are shown below:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Thus, `x[0]=1` and `y[0]=10` represent a point `(1, 10)`. Likewise, we can
    represent other points for the remaining elements. Sometimes, it is convenient
    to use a single array to express the coordinates of several such points, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'How do we create such an array using the `x` and `y` arrays shown earlier?
    There are multiple ways to do this. One option is to use `numpy.dstack`. This
    function enables stacking arrays along a third axis to create a single array.
    The following code shows how to create a `points` array discussed earlier using
    the input `x` and `y` arrays:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice that the resultant array is three-dimensional:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The size of the array along each axis (or dimension) is given by its shape:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will use this function in *optimization pass five*. Similarly, there are
    other ways of stacking arrays, for example, `numpy.hstack` or `numpy.vstack`.
    These are not discussed in this book. Refer to the NumPy documentation for further
    details.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: numpy.einsum
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function provides a way to compute the **Einstein notation** (or **Einstein
    summation convention**) on the input arrays for the operations (called **operands**).
    In terms of performance, this function offers great efficiency. Later in the chapter,
    we will exploit it to find the square of the distance between two points.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding the mathematical concept behind `einsum` can be a bit challenging,
    especially if you do not have a math background. In that case, just remember one
    key thing about `numpy.einsum`—It is a function that allows you to perform some
    highly efficient operations involving arrays. For example, a matrix multiplication
    operation between two NumPy arrays or a dot product can be done more efficiently
    using `numpy.einsum`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the NumPy documentation for more information on this function. Also,
    see [https://en.wikipedia.org/wiki/Einstein_notation](https://en.wikipedia.org/wiki/Einstein_notation)
    for information on Einstein notation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be better explained with an example. Consider the following equations
    that represent two vectors, *A* and *B*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![numpy.einsum](img/B05034_09_02.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'These are two points in space with some *x*, *y*, and *z* coordinates. The
    dot product of these vectors is represented as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![numpy.einsum](img/B05034_09_03.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about a dot product, see [https://en.wikipedia.org/wiki/Dot_product](https://en.wikipedia.org/wiki/Dot_product).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a scalar product and can be represented as a summation, as shown in the
    following equation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![numpy.einsum](img/B05034_09_04.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'The Einstein summation convention for the preceding equation is written as
    follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![numpy.einsum](img/B05034_09_05.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Here, it is implied that *AiBi* is a summation over *i* with a lower bound of
    *1* and upper bound of *3*. This is the Einstein summation convention in a nutshell.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.einsum` evaluates the Einstein summation convention on the given input
    arrays. The basic syntax is shown below—there are other optional arguments as
    well, but those are not shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first argument, `subscripts`, is a string that represents a list of subscript
    labels. These are separated by a comma and each label represents a dimension of
    a particular operand. In the example we just saw, there was only one subscript
    label, *i*. The second argument, `operands`, represents the input arrays (*A*
    and *B* in the example).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the *A* and *B* vectors are one dimensional. Their inner product can
    be represented with the subscript string `''i,i''`. This can be better explained
    with the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The arrays `a` and `b` are one dimensional. You can also cross-check the answer
    using the `numpy.inner` function, which returns the same answer:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `numpy.einsum` function is faster and also memory efficient. Now, take
    a look at the following code—it represents a dot product (or matrix multiplication)
    of two vectors, `a2` and `b2`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The subscript string for `numpy.einsum` is `''ij,jk''`, where `ij` is the subscript
    for two dimensions of array `a2`, and `jk` is the one for array `b2`. The dot
    product can also be obtained by following this example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Computing distance square with einsum
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples shown so far should just give you a flavor of the `einsum` function.
    Let's only discuss how to use this function to calculate the square of the distance
    between two points. Again, for a comprehensive reference, refer to the NumPy documentation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止展示的示例应该只是给你一个关于`einsum`函数的味觉。让我们只讨论如何使用这个函数来计算两点之间的距离的平方。再次提醒，为了全面的参考，请参阅NumPy文档。
- en: 'Consider any point `p1` with coordinates (`0, 2`). Furthermore, assume that
    the center is located at (`0,` `0`). As the x coordinate of the `p1` point is
    `0`, you can easily determine the distance between `p1` and center as 2 units.
    The square of the distance can be found using the `einsum` function, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑任意一个坐标为(`0, 2`)的点`p1`。此外，假设中心位于(`0,` `0`)。由于`p1`点的x坐标是`0`，你可以很容易地确定`p1`和中心之间的距离是2个单位。距离的平方可以使用`einsum`函数找到，如下所示：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, imagine that there are multiple such points and you want to find the square
    of the distance of each point from the center. Here is one way to compute this
    using `einsum`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设有多个这样的点，并且你想找到每个点与中心的距离的平方。这是使用`einsum`计算的一种方法：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `points` array represents a list of points. For each of these points, we
    will find a vector, with `center` as its starting point and the given point (from
    the `points` array) as its end. Let''s represent the array of such vectors as
    `diff`, as shown in the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`points`数组代表一系列点。对于这些点中的每一个，我们将找到一个向量，以`center`作为起点，以`points`数组中的给定点作为终点。让我们将这样的向量数组表示为`diff`，如下面的示例所示：'
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As the center is (`0,0`), the `diff` array is essentially the same as the `points`
    array. The following line of code shows the `einsum` syntax—it uses the ellipsis
    notation (`…`), to the left of each term in the subscripts argument:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中心是(`0,0`)，`diff`数组本质上与`points`数组相同。以下代码行显示了`einsum`语法——它使用省略号符号(`…`)在子脚本的每个项的左侧：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It returns an array that contains a square of the distances for each point in
    the `points` array. That's all we need!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个包含`points`数组中每个点距离平方的数组。这就是我们需要的全部！
- en: What does this ellipsis notation do? Why didn't we use the earlier syntax?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个省略号符号表示什么？为什么我们没有使用早期的语法？
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The earlier syntax involved single dimensional arrays (`d`) that had only one
    subscript label. We cannot use it here as the operand (or the `diffs` array) for
    the Einstein sum is a two-dimensional array. To understand this, let''s look at
    the `diffs` array one more time:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的语法涉及单维数组（`d`），它只有一个下标标签。在这里我们不能使用它作为操作数（或`diffs`数组），因为爱因斯坦求和的操作数是一个二维数组。为了理解这一点，让我们再次看看`diffs`数组：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Consider any row of this array. It is essentially a vector between a point
    and the center. For example, `[0, 2]` represents a vector between a center `[0,0]`
    and a point `[0,2]`. The other dimension of the array is to hold many such vectors.
    The ellipsis symbol, "`…`", is a convenient way to broadcast the second dimension.
    The alternative syntax to get the same result is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个数组的任意一行。它本质上是一个点和中心之间的向量。例如，`[0, 2]`代表一个中心`[0,0]`和一个点`[0,2]`之间的向量。数组的另一个维度是用来存放许多这样的向量。省略号符号"`…`"是一个方便地广播第二个维度的方式。得到相同结果的另一种语法如下：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, if the array shapes change further, you will need to work on constructing
    a proper subscript string for the `einsum` function again. The NumPy documentation
    has several examples that show how to use `einsum`. Here is a NumPy version 1.10
    documentation: [http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.einsum.html](http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.einsum.html).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果数组形状进一步改变，你将需要再次工作于为`einsum`函数构建一个合适的下标字符串。NumPy文档中有几个示例展示了如何使用`einsum`。以下是一个NumPy
    1.10版本的文档：[http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.einsum.html](http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.einsum.html)。
- en: Where to get more information on NumPy?
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪里可以找到更多关于NumPy的信息？
- en: In the NumPy introduction, you were presented with several links to the documentation.
    Just for the completeness, let's summarize where to find more information on NumPy.
    You can start by visiting their website ([http://www.numpy.org/](http://www.numpy.org/))
    or just do a web search on NumPy to get to its homepage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy的介绍中，你被提供了几个指向文档的链接。为了完整性，让我们总结一下在哪里可以找到更多关于NumPy的信息。你可以从访问他们的网站([http://www.numpy.org/](http://www.numpy.org/))或在网上搜索NumPy以到达其主页开始。
- en: '**SciPy** is another project worth mentioning. It is a library that integrates
    several open source tools for mathematics, science, and engineering disciplines.
    NumPy, matplotlib, and pandas are some of its core packages. See the project website
    ([https://www.scipy.org/](https://www.scipy.org/)) for more information.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**SciPy** 是另一个值得提及的项目。它是一个集成了数学、科学和工程学科多个开源工具的库。NumPy、matplotlib和pandas是其核心包之一。更多信息请参阅项目网站([https://www.scipy.org/](https://www.scipy.org/))。'
- en: In an earlier discussion, several links were provided to the NumPy documentation.
    Looking at those links, you must have already noticed that they all point to the
    SciPy website. The documentation for both NumPy and SciPy is located at [http://docs.scipy.org/doc/](http://docs.scipy.org/doc/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的讨论中，提供了一些指向NumPy文档的链接。查看这些链接，你一定已经注意到它们都指向SciPy网站。NumPy和SciPy的文档都位于[http://docs.scipy.org/doc/](http://docs.scipy.org/doc/)。
- en: The open source pandas library is used for data analysis using Python. It provides
    high performance data structures and tools to analyze data. Refer to [http://pandas.pydata.org/](http://pandas.pydata.org/)
    for more information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 用于Python数据分析的开源pandas库。它提供了高性能的数据结构和工具来分析数据。更多信息请参阅[http://pandas.pydata.org/](http://pandas.pydata.org/)。
- en: Optimizing Gold Hunt – Part two
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化黄金狩猎 – 第二部分
- en: The previous section served as a short introduction to NumPy. Recall that, in
    earlier chapters, we gradually improved the runtime performance of the game. The
    last recorded timing was the one obtained with *optimization pass three*. We successfully
    reduced the total runtime down to nearly 44 seconds from the original time of
    about 106 seconds. NumPy supports vectorized calculation routines such as element-wise
    multiplication. It internally uses efficient C loops that help run such operations
    faster. Let's leverage NumPy capabilities to speed up the *Gold Hunt* game even
    further.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节简要介绍了NumPy。回想一下，在早期章节中，我们逐步提高了游戏的运行性能。最后一次记录的时间是使用**优化迭代三次**获得的时间。我们成功将总运行时间从大约106秒减少到近44秒。NumPy支持向量化计算例程，如元素级乘法。它内部使用高效的C循环，有助于加快此类操作的运行速度。让我们利用NumPy的功能，进一步加快*黄金狩猎*游戏的运行速度。
- en: Gold Hunt optimization – pass four
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黄金狩猎优化 – 第四次迭代
- en: It is now time to resume the optimization operation for the *Gold Hunt* problem.
    Let's start with *optimization pass four*. We will focus our attention once again
    on the function, `generate_random_numbers`. As a refresher, the `cProfiler` output
    of the last optimization run reported the total time as ~ 2.6 seconds and a cumulative
    time, which includes the time spent by sub-functions, was ~ 5.2 seconds*.*
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候继续对*黄金狩猎*问题进行优化操作了。让我们从**优化迭代四次**开始。我们将再次关注函数`generate_random_numbers`。作为一个复习，上次优化运行的`cProfiler`输出报告了总时间为约2.6秒，累计时间（包括子函数花费的时间）为约5.2秒**。
- en: '![Gold Hunt optimization – pass four](img/B05034_09_06.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第四次迭代](img/B05034_09_06.jpg)'
- en: '| *You are right. For this example, it is not worth optimizing this piece of
    code. The 5.2 seconds time doesn''t look that bad. At this time, the function
    is called only once, as indicated by the* `ncalls` *column of the* `cProfile`
    *output. But any future requirements can potentially make this function a new
    bottleneck. As an example, imagine a new game scenario where there are hundreds
    of such gold fields or places full of abandoned weapons. We might need to call
    such a function many times. This will increase the total time spent in generating
    points. Keeping this in mind, let''s work on improving its performance.* |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| *你说得对。对于这个例子，优化这段代码不值得。5.2秒的时间看起来并不那么糟糕。目前，该函数只被调用一次，正如`cProfile`输出的`ncalls`列所示。但任何未来的需求都可能使这个函数成为新的瓶颈。例如，想象一个新游戏场景，其中有成百上千这样的黄金区域或充满废弃武器的场所。我们可能需要多次调用这样的函数。这将增加生成点所需的总时间。考虑到这一点，让我们努力提高其性能。*
    |'
- en: 'We will revamp the code from the previous optimization run (`goldhunt_pass3.py`).
    The supporting source code is in the `goldhunt_pass4.py` file. The first thing
    we will add is the NumPy `import` statement at the beginning of the file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新编写上次优化运行中的代码（`goldhunt_pass3.py`）。支持源代码位于`goldhunt_pass4.py`文件中。我们将首先在文件开头添加NumPy的`import`语句：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The reworked `generate_random_points` function is illustrated in the following
    code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了重新工作的`generate_random_points`函数：
- en: '![Gold Hunt optimization – pass four](img/B05034_09_07.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第四次迭代](img/B05034_09_07.jpg)'
- en: 'It is optional to use local variables such as `l_uniform`. Those are used here
    to skip the function reevaluation. This was already discussed in the *Skipping
    the dots* section from the previous chapter. Let''s review this function next:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Compare the new function with the previous implementation. The key thing to
    note here is the use of the NumPy functions, such as `np.random.uniform`, `np.sqrt`,
    and others in place of the built-in functions.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another major difference is that we no longer need a `for` loop. The `np.random.uniform`
    function returns a NumPy array. The last argument specifies its size. Refer to
    the earlier introductory section on NumPy for more information on the `random.uniform`
    functionality.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `x` and `y` coordinates are computed using the `radius` and `theta` arrays.
    Note that the variables, `x` and `y`, are created as NumPy arrays. For efficiency
    reasons, we will return these as Python lists. This is accomplished by using `numpy.ndarray.tolist()`,
    a method accessible to NumPy `array` objects.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s profile this code and compare the performance with the previous optimization
    pass. Here is the command to execute this code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The profiler output is shown next:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Gold Hunt optimization – pass four](img/B05034_09_08.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Observe the cumulative time column for the `generate_random_points` function.
    The cumulative time for the original function was ~ 5.2 seconds, that is now reduced
    to `0.346` seconds. This is already a significant improvement.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to further improve the performance of the `generate_random_points`
    function. For example, at the beginning of the function, you can compute the product
    `2*l_pi`, for example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Then use this variable in the computation of `theta`. However, this will only
    result in a marginal improvement in the runtime.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Gold Hunt optimization – pass five
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this optimization pass, we will further improve the runtime performance of
    the `GoldHunt.find_coins` method. The original method is shown in the following
    code snippet for convenience. You can also find it in an earlier `goldhunt_pass4.py`
    file. For more details, see the previous chapter's, *Gold Hunt Optimization –
    Pass two* section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Gold Hunt optimization – pass five](img/B05034_09_09.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Recall that the last recorded runtime for this method was about 38 seconds.
    Our task is to improve it further. We will start the optimization work by making
    a small change to the `generate_random_points` function. Recall that this function
    returns the `x` and `y` coordinates of the *gold coins* on the field as Python
    lists. Instead, let's return these as NumPy arrays.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have skipped reading the earlier introductory section on NumPy, now would
    be the time to go back and read it! The *optimization pass five* uses the NumPy
    functions discussed in that section. More specifically, the code presented next
    uses the `einsum` and `dpstack` functions. You may find the `einsum` syntax confusing.
    Therefore, it is recommended that you read the introduction first before diving
    into the code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `find_coins` method, we will use the NumPy functions that work efficiently
    with these NumPy arrays. The following code fragment shows the updated function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Gold Hunt optimization – pass five](img/B05034_09_10.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: 'With this change, let''s quickly review the reworked `find_coins` method next:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![Gold Hunt optimization – pass five](img/B05034_09_11.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the preceding code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Recall that our task is to find the square of the distance between any gold
    coin on the field and the center of the search circle, and then use this value
    to check if the gold coin lies inside the search circle.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input argument, `x_list` and `y_list`, are the NumPy arrays representing
    the x and y positions of the gold coins on the field.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these coordinates, we will create a single `points` array that contains
    (x, y) coordinate pairs as its elements. This is accomplished using `numpy.dstack`.
    See the earlier introductory section on NumPy for an example usage.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will find the vector between each point in the `points` array and the
    `center` array for the search circle. These vectors are stored as the elements
    of the `diff` array.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using this `diff` array, we will find the square of the distances between all
    the gold coins from the center using `einsum`. See an earlier, *Computing distance
    square with einsum* section, where this was discussed in detail.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will check if the gold coin lies inside the circle by comparing
    the distance squares. The `enumerate()` function is a built-in function that presents
    a cleaner way to get the current index (`i`) of the loop and the corresponding
    value (`d`).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code is ready. Now, it is time to profile it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The profiler output is shown below:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Gold Hunt optimization – pass five](img/B05034_09_12.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: Observe that the cumulative time taken by the `find_coins` function has gone
    down to ~19.5 seconds from the earlier ~ 38 seconds. It is nearly a 50% improvement
    for this function alone. Also, the total runtime is now ~ 21.5 seconds compared
    to the previous timing of ~38 seconds.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to improve the performance of `find_coins` by using list comprehension
    instead of the `for` loop. However, the improvement will be marginal. You can
    try it as an exercise (no solution is provided). Here is a sample code that uses
    list comprehension:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Parallelization with the multiprocessing module
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before jumping onto the discussion of the `multiprocessing` module, let's first
    understand what we mean by parallelization. This will be a very short introduction
    to parallelization, just enough to understand how to use some features of the
    `multiprocessing` module.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to parallelization
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you are standing in a long queue at a checkout counter in a grocery
    store, waiting for your turn. Now, three more counters are opened to serve the
    customers and the existing queue is split. As a result, you can pay and get out
    of the store quickly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Parallelization, in some sense, accomplishes similar results. In this example,
    each counter can be imagined as a separate process, carrying out independent tasks
    of accepting payments. The initial queue of the customers can be imagined as your
    program. This long queue is then divided into independent queues (or tasks), processing
    them parallely on separate counters (processes).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The *Gold Hunt* program we have written so far runs serially. The program executes
    a set of tasks one after another on a single processor. This is analogous to the
    single counter in the previously mentioned grocery store example. Many times,
    it is possible to split the program into smaller tasks and run them independently
    using multiple processes or threads.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly review two broad programming models that handle parallel process
    communications. These are **shared memory** and **distributed memory** parallelization.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Shared memory parallelization
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the shared memory programming model, the parallel processes access the same
    memory segment. Thus, the exchange of data and the communication between processes
    happens through this common memory. This programming model is often referred to
    as *threaded programming*. The disadvantage of the shared memory model is something
    known as a **race condition**. Here, multiple threads compete to access or modify,
    for instance, data at a memory location. The race condition can be avoided by
    controlling access to that critical information using *locks*. However, this adds
    to the programming overhead. Refer to [https://en.wikipedia.org/wiki/Shared_memory](https://en.wikipedia.org/wiki/Shared_memory)
    for further information.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Distributed memory parallelization
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, each process gets its own memory space. The processes do not share any
    memory resources, and they run independent of each other. The communication between
    the processes happens over inter-process communication channels. This is referred
    to as **message passing**. To learn more about message passing, see [https://en.wikipedia.org/wiki/Message_passing](https://en.wikipedia.org/wiki/Message_passing).
    Since the processes do not share the same memory space, there is an additional
    communication overhead associated with the distributed memory mechanism.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Global interpreter lock
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, the `threading` module provides a high-level interface for thread
    based parallelization. To avoid the race condition discussed earlier, Python employs
    a mechanism called **global interpreter lock** (**GIL**). When a thread is executing
    a block of code, a global lock is acquired. This lock makes sure that only one
    thread is executed at a time in the Python interpreter environment. The disadvantage
    of GIL is that you cannot take full advantage of a multiprocessor machine.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The multiprocessing module
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `multiprocessing` module addresses the GIL problem and provides a simple
    way to parallelize Python programs. Instead of using threads, it uses sub-processes
    and avoids GIL. In this module, the exchange of data between processes is supported
    using two communication channels, a `Queue` class and a `Pipe` function. This
    module also provides several other useful features, such as *managers* and *proxy
    objects*. The `Manager` object is created using `multiprocessing.Manager()`. It
    controls a server process that manages the Python objects. The manager also enables
    other processes to manipulate these Python objects using proxies. Discussing these
    features is beyond the scope of this book. Python documentation has great examples
    of how these features work. Refer to [https://docs.python.org/3/library/multiprocessing.html](https://docs.python.org/3/library/multiprocessing.html)
    for more information.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover only a few features of the `Pool` class.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The Pool class
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `multiprocessing.Pool` class provides a simple approach to parallelize the
    program. It is used to manage a pool of worker processes and defines methods that
    enable various ways to run the given tasks parallely.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other basic approach is to use the `Process` class, which is not discussed
    in this book. See the previous documentation link for details.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The `Pool.map` and `Pool.apply` methods are among the ones frequently used.
    These are the parallel equivalents of the Python built-in `map` and `apply` functions.
    Both these methods block the main program until a worker process is finished and
    the results are ready. The blocking nature is useful if you are interested in
    getting a sequential output from the parallel processes. They also have their
    asynchronous variants, namely `map_async` and `apply_async`. The asynchronous
    variants are better suited to run parallel jobs where you don't care about the
    order in which results are returned by the processes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `apply` function is no longer a built-in function in Python 3\. However,
    it was supported in Python 2.7\. You can refer to Python 2 documentation to learn
    what this function does.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work on a simple example that shows how to use the `Pool` class and
    its methods, `map` and `apply`. Observe the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![The Pool class](img/B05034_09_13.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the preceding code snippet:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the `multiprocessing` module.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pool` instance is created with two worker processes. You can specify the
    number of worker processes as an optional input argument.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating a pool of workers, the `pool.map` method is called. As previously
    stated, this is a parallel equivalent of the built-in `map` function. The first
    argument is a trivial function called `get_result`. This function is applied to
    the `iterable` specified as the second argument.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the `get_result` function is applied on each element of the `numbers`
    list. Inside this function, we also print the name of the current worker process
    doing the job.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pool.close()` method stops the worker processes after execution, whereas
    the `pool.join()` method blocks until the worker process terminates. This mimics
    the API provided by the `threading` module.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding code can also be found in `pool_example.py`. In this file, you
    just need to enable the relevant code and disable the other function calls. The
    file can be run from the Command Prompt, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is a sample command-line output after this execution:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice that the elements of the output list (`mylist`) are arranged in the same
    order as the input list (`numbers`). In other words, we have the input as `[2,
    4, 6, 8]` and the output is 10 times each element, given as `[20, 40, 60, 80]`.
    This may or may not be the case for asynchronous variants. It will depend on which
    order the processes finish and return the results for.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'With just a single line change, we can run the same example using `Pool.apply`.
    The following code snippet shows how to do this. The `get_result` function is
    not shown as it remains the same as before, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![The Pool class](img/B05034_09_14.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Here, we created `mylist` using list comprehension. For each element of the
    `numbers` list, it calls the `Pool.apply` method. The first argument to the method
    is the name of the function whereas the second argument, `args`,is used to specify
    the other arguments to this function. This method offers convenient syntax to
    specify any number of arguments to the function being sent to the worker processes.
    The rest of the code and programming output remains the same, as shown in the
    `Pool.map` method example. Let''s review one of the asynchronous variants, `Pool.apply_async`.
    The code is shown as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![The Pool class](img/B05034_09_15.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: 'Let''s talk through this code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: This involves two changes. The first one is a trivial one. The `apply` method
    is simply replaced with `apply_async` (shown highlighted). There is no change
    in the method syntax.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the output of the `apply_async` call does not directly give us the
    final values we need. Instead, it returns the object of a `Pool.ApplyResult` class.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, `apply_async` is used inside a list comprehension. So, the
    elements of the `results` list are objects of the `ApplyResult` class.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final value can be obtained using the `ApplyResult.get()` method. We do
    this using a list comprehension, as shown in the preceding image. Alternatively,
    you can also use the generator expression syntax discussed in the previous chapter.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this short introduction on parallelization, let's see how to parallelize
    some functionality from the *Gold Hunt* application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Parallelizing the Gold Hunt program
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at the previous profiler output, the `find_coins` function is still
    the main bottleneck with ~19.5 seconds of cumulative time. Let's see how parallelization
    can help speed it up further.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the gold field
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the *gold field* image from [Chapter 7](ch07.html "Chapter 7. Performance
    – Identifying Bottlenecks"), *Performance – Identifying Bottlenecks*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting the gold field](img/B05034_09_16.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'Let''s quickly summarize what we already saw in [Chapter 7](ch07.html "Chapter 7. Performance
    – Identifying Bottlenecks"), *Performance – Identifying Bottlenecks*:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The `find_coins` method is called for each of the small search circles shown
    in the figure. So, if there are 10 search circles, `find_coins` will be called
    10 times, one after the other.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `find_coins` method returns the coordinates of the gold coins lying inside
    the given search circle.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The information about all such collected coins is maintained in a list object.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one important thing to note here. It is a serial execution. You start
    with the first circle, collect the coins and move on to the next one, and repeat
    the procedure until you hit the other end of the field.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '| *So how can we further enhance the search operation? Any thoughts, Mr. Great
    Dwarf?* |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '![Revisiting the gold field](img/B05034_09_17.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: '| *Perfect! The search* *operation inside each circle is independent of the
    others. Therefore, the* `find_coins` *function can be independently executed for
    each search circle. This is an ideal candidate for parallelization.* |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '![Revisiting the gold field](img/B05034_09_18.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: '| *That is even better!**Since the order in which the results are returned
    (by the worker processes) is not important, we can use* `Pool.apply_async` *to
    parallelize this task.* |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: Gold Hunt optimization – Pass six, parallelization
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a first step, you should skim through the `play` method of the last *optimization
    pass five*. Most of the changes we are about to make will be in this method. Additionally,
    we will pass some more arguments to the `find_coins` method.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: So, we decided to use a pool of worker processes represented by a `Pool` object.
    The *work queue* of this `Pool` object consists of all the search circles inside
    the gold field shown earlier. Each worker process will parallely run the search
    operation (`find_coins`), and it doesn't depend on other search circles. Generally,
    the worker processes within a `Pool` object are not terminated until the complete
    work queue is processed. When a worker process is done finding the coins in a
    particular search circle, it may get assigned to perform this operation for another
    search circle.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '| *So what changes are required to be done to the play method? The code will
    be very similar to the basic example of* `apply_async`*, as seen earlier. Does
    anything else need to be changed in the existing method? Our friend Elf has a
    question...* |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '![Gold Hunt optimization – Pass six, parallelization](img/B05034_09_19.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: '| *You are spot on! The existing* `play` *method serially runs the search operation.
    It starts with the leftmost circle, finds the coins, and moves on to the next
    circle by updating* `x_ref`. *Note that we have chosen* `y_ref` *as* `0.0` *in
    this example.**When we run this search* *operation on parallel processes, each
    circle will have its unique center coordinates. We need to provide appropriate
    values of these coordinates to each parallel process. To do this, let''s remove
    the dependence on* `x_ref` *and* `y_ref`*. The center coordinates of all the circles
    will be determined and stored in a list before parallelizing the search operation.*
    |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: 'The `play` method with the preceding changes is shown below:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Gold Hunt optimization – Pass six, parallelization](img/B05034_09_20.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: 'Let''s talk through the important changes in this method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In a `while` loop, we will first determine the centers of all the search circles
    and store the coordinates in a list called `x_centers`. The y coordinate (`y_ref`)
    is not updated because we have chosen it as constant `(0.0)` for all the circles.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the same `while` loop, another `circle_number` list is populated to represent
    the circle id. This is just for printing purposes so that we will know which search
    operation is being performed.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After preparing the list, a pool of worker threads is created and then `apply_async`
    is called in a list comprehension.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall that the first argument to the `Pool.apply_async` method is the name
    of the function (`self.find_coins)`, whereas the second argument, `args`, is used
    to specify all the arguments to this function.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the code is similar to what we saw in the introduction of the `multiprocessing`
    module. The `apply_async` call returns a list containing objects of the `ApplyResult`
    class. Then, the `get()` method of this class is used to obtain the final values.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Python 2.7.9, you may have to create and use a global function
    as the first argument to `apply_async`. This global function can then return the
    `GoldHunt.find_coins` method. This is a workaround to avoid a `PicklingError`
    exception noticed while testing the code. For Python 3.x, there is no problem.
    This code is provided in the supplementary code bundle. See the Python 2 equivalent
    of the `goldhunt_pass6_parallel.py` file for details.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there are some changes to the `GoldHunt.find_coins` method. It now
    takes the `process_x_ref` and `circle_number` functions as two new arguments.
    The `process_x_ref` function represents the x coordinate of a given search circle.
    The `process_` prefix is added just to distinguish it from `self.x_ref`, and indicate
    that its value will be different for each worker process.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Using `apply_async`, we will run this method on separate parallel processes.
    Each process gets its own circle center and number to be given as an input for
    the `find_coins` method. The method is shown in the following code snippet. The
    highlighted code indicates the changes in comparison with the previous optimization
    pass.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![Gold Hunt optimization – Pass six, parallelization](img/B05034_09_21.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: 'The rest of the code remains the same as the previous optimization pass. The
    source code is provided in the `goldhunt_pass6_parallel.py` file. Let''s run this
    code and see the profiler output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will print information on the search circles as it did earlier. Here is
    the profiler output:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Gold Hunt optimization – Pass six, parallelization](img/B05034_09_22.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: Note that the `find_coins` call is not shown in the profiler output. It is hidden
    inside the reported timing of the `play` method. Comparing the cumulative time
    (`cumtime`) of the `play` method should give a reasonable estimate on the performance
    gain with parallelization.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the parallelization has helped improve the total timing from earlier,
    ~21.5 seconds to ~13.5 seconds.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on your machine specifications, you can try increasing the number
    of worker processes by updating the argument to the `Pool` class. For example,
    instead of three processes you can run the program with four processes. However,
    this is a simple case and the runtime is so short that you will hardly see any
    further improvement. In fact, the overhead of the sub-processes may even result
    in a slightly degraded performance. Also, depending on the problem, beyond a certain
    number of processes, the performance gain due to parallelization can fade away.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Other methods for parallelization
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Is the `apply_async` method the only way to parallelize this problem? Certainly
    not. There are other methods in the `multiprocessing` module that can do this
    efficiently. `Pool.starmap_async` is one such method available in Python 3.3 and
    beyond. We are not going to discuss this here, but the following code shows how
    to invoke it along with the `itertools.repeat` function:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For more information on such methods, refer to the `multiprocessing` module
    documentation.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the series of the three chapters on performance, we covered several important
    aspects. The things learned here will help you with the majority of common application
    performance enhancement tasks. Where do we go from here? There are some other
    important topics that you can explore, among those are JIT compilers and **Graphics
    Processing Unit** (**GPU**) programming. This section aims at providing some basic
    information on these two topics. You can follow the links provided here for further
    understanding.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: JIT compilers
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is an interpreted language. In simple terms, it means that the code is
    parsed and executed directly without involving any code compilation. Although
    this offers a great deal of flexibility, the program typically runs slower.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: In high-level programming languages such as C++, the code is compiled ahead
    of time or before the execution. Generally speaking, a compiled program (C++)
    runs faster compared to the equivalent interpreted program (Python).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we have an interpreted code on one side which offers flexibility and a
    compiled code on the other that runs faster. The JIT compiler gets the best of
    both worlds. It compiles the code, but instead of compiling it ahead of execution,
    it does this just-in-time or during the program execution.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: PyPy is one such project that provides an alternative implementation of the
    Python language that comes with a JIT compiler. Python programs often run faster
    with PyPy. It is also memory efficient and offers high compatibility with the
    existing Python code. To learn more about PyPy, check out [http://pypy.org](http://pypy.org).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '**Numba** is another project aimed at speeding up the application. It provides
    a JIT compiler and a very simple syntax to mark a function for optimization using
    a JIT compiler. You just need to use the `numba.git()` decorator. In other words,
    add `@jit` above the function name to mark the function for optimization. If you
    are using the Anaconda Python distribution discussed in [Chapter 1](ch01.html
    "Chapter 1. Developing Simple Applications"), *Developing Simple Applications*,
    it already provides the `numba` module by default. To learn more, visit the project
    home page ([http://numba.pydata.org](http://numba.pydata.org)).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: GPU accelerated computing
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GPU is traditionally used for applications involving heavy rendering, such as
    game applications. It is now widely used for applications involving scientific
    simulations, neural networks, financial modeling, and so on. The massively parallel
    architecture of a GPU offers tremendous performance improvement (of the order
    of 100x or more) over the CPU-based parallelization. A typical strategy is to
    identify the most compute intensive part of your application, and then send it
    to a GPU. The rest of the code can continue to use CPU. However, it is not as
    simple as it sounds, especially if you are working on a legacy code. In such cases,
    the challenge can be to make it compatible to fully utilize the GPU acceleration.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**PyCUDA** ([https://pypi.python.org/pypi/pycuda](https://pypi.python.org/pypi/pycuda))
    is a popular Python package that provides a wrapper to access Nvidia''s CUDA parallel
    API. CUDA is a parallel computing platform by NVIDIA. More information can be
    found at [http://www.nvidia.com/object/cuda_home_new.html](http://www.nvidia.com/object/cuda_home_new.html).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '**PyOpenCL** ([https://pypi.python.org/pypi/pyopencl](https://pypi.python.org/pypi/pyopencl))
    is another Python package. It provides an easy access to the **Open Computing
    Language** (**OpenCL**) API. OpenCL is a framework for parallel computation. Refer
    to [https://en.wikipedia.org/wiki/OpenCL](https://en.wikipedia.org/wiki/OpenCL)
    for further information.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we end the series of chapters focused on performance improvements.
    Let's first summarize what you learned in this chapter. We started with a basic
    introduction to the NumPy library and saw how to leverage it to further speed
    up the *Gold Hunt* application. In particular, we used the array (`numpy.ndarray`)
    data structure and other functionalities, such as `numpy.random.uniform` and `numpy.einsum`
    to achieve the speedup. The final optimization pass involved parallelizing the
    code. The chapter briefly introduced you to the basics of parallel processing.
    We used functionality from Python's `multiprocessing.Pool` class to further trim
    down the application runtime.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's summarize the three performance chapters together. We started
    by profiling the code to identify the performance bottlenecks and learned about
    the big O notation. We gradually addressed these bottlenecks to improve the application
    performance. This was accomplished by several means, ranging from changing the
    algorithm and implementing efficient data structures to using the functionality
    from a Python standard library. We further improved the runtime by using NumPy
    and also by parallelizing the code.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The timings reported by the profiler will vary widely. It depends on your machine
    specifications, and also on the current running tasks. So, the timings observed
    in your case will likely be different than the numbers reported in this book.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: For the *Gold Hunt* example discussed in these chapters, the total runtime was
    reduced almost by an order of magnitude, from an initial value of about 106 seconds
    to a final runtime of nearly 13.5 seconds.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: So far, in this book, you learned several key aspects of application development
    using command-line programs. In the final chapter, we'll see how to develop simple
    GUI applications in Python.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
