- en: 9 Best Practices to Improve your Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高你的Web应用程序的9个最佳实践
- en: 'From *Chapter 1* through *Chapter 8,* we learned how to build a web application
    from conception through deployment. Pat yourself on the back and give yourself
    a round of applause. Building and deploying a web application is not a simple
    feat. So, what have we learned? We, of course, spent time learning all of the
    fundamental tools that Sanic provides: route handlers, blueprints, middleware,
    signals, listeners, decorators, exception handlers, and so on. More importantly,
    however, we spent some time thinking about how HTTP works, and how we can use
    these tools to design and build applications that are secure, scalable, maintainable,
    and easily deployable.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从*第一章*到*第八章*，我们学习了如何从构思到部署构建Web应用程序。给自己鼓掌，给自己来个满堂彩。构建和部署Web应用程序不是一件简单的事情。那么，我们学到了什么呢？我们当然花了时间学习Sanic提供的所有基本工具：路由处理程序、蓝图、中间件、信号、监听器、装饰器、异常处理程序等等。然而，更重要的是，我们花了时间思考HTTP是如何工作的，以及我们如何可以使用这些工具来设计和构建安全、可扩展、可维护且易于部署的应用程序。
- en: 'There have been a lot of specific patterns in this book for you to use, but
    also quite intentionally I have left a lot of ambiguity. You have continually
    read statements like: “*it depends upon your application’s need*.” Afterall, one
    of the goals of the Sanic project is to remain “*unopinionated*”.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中有许多特定的模式供你使用，但我故意留下很多模糊性。你不断地读到这样的声明：“*这取决于你的应用程序需求*。”毕竟，Sanic项目的目标之一是保持“*无偏见*”。
- en: That’s all well and good, and flexibility is great. But what if you are a developer
    that has not yet determined what patterns work, and which do not? The difference
    between writing a “*Hello, world*” application and a production-ready, real-world
    application is huge. If you have only limited experience in writing applications,
    then you have also only had limited experience in making mistakes. It is through
    those mistakes (whether made by yourself, or from lessons learned by others who
    have made them) that I truly believe we become better developers. Like so many
    other things in life, failure leads to success.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很好，而且灵活性是极好的。但是，如果你是一个尚未确定哪些模式有效，哪些无效的开发者呢？编写一个“*Hello, world*”应用程序和编写一个生产就绪、真实世界的应用程序之间的差异是巨大的。如果你在编写应用程序方面只有有限的经验，那么你在犯错误方面的经验也是有限的。正是通过这些错误（无论是你自己犯的，还是从犯过错误的其他人那里学到的教训），我真正相信我们成为了更好的开发者。就像生活中许多其他事情一样，失败导致成功。
- en: The purpose of this chapter, therefore, is to include several examples and *preferences*
    that I have learned from my 20+ years of building web applications. That means
    for every best practice you will learn in this Chapter, there is probably some
    *mistake* that I made to go along with it. These are a set of base-level *best
    practices* that I think is critical for any professional-grade application to
    include from the beginning.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章的目的是包括我从20多年的构建Web应用程序中学到的几个示例和*偏好*。这意味着在本章中你将学习的每一个最佳实践，可能都伴随着我犯过的某个*错误*。这是一套基础级别的*最佳实践*，我认为对于任何专业级应用程序从一开始就包括在内是至关重要的。
- en: 'In this chapter, we are going to look at:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨：
- en: Practical real-world exception handlers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用的真实世界异常处理程序
- en: How to setup a testable application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置可测试的应用程序
- en: The benefit of real-world logging and tracing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实世界日志和跟踪的好处
- en: Managing database connections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数据库连接
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'There are no new technical requirements that you have not already seen. By
    this point, you should hopefully have a nice environment available for building
    Sanic, along with all the tools like Docker, Git, Kubernetes, and Curl that we
    have been using all along. You can follow along with the code examples on the
    GitHub repository: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 没有新的技术要求是你之前没有见过的。到这一点，你希望有一个适合构建Sanic的环境，以及我们一直在使用的所有工具，如Docker、Git、Kubernetes和Curl。你可以在GitHub仓库上的代码示例中跟随：[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09)。
- en: Implementing practical real-world exception handlers
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施实用的真实世界异常处理程序
- en: Exception handling is not a new concept at this point. We have explored the
    topic in the *Implementing proper exception handling* section in *Chapter 6*.
    I emphasized the importance of creating our own set of exceptions that include
    default status messages and response codes. This useful pattern was meant to get
    you up and running very quickly to be able to send *useful* messages to your users.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，异常处理不是一个新概念。我们在第6章的 *实现适当的异常处理* 部分探讨了这一主题。我强调了创建我们自己的异常集的重要性，这些异常包括默认状态消息和响应代码。这个有用的模式旨在让你能够快速启动并运行，以便能够向用户发送
    *有用的* 消息。
- en: For example, imagine we are building an application for travel agents to book
    airline tickets for customers. You can imagine one of the steps of the operation
    might be to assist in matching flights through connecting airports.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，设想我们正在为旅行代理人开发一个应用程序，用于为客户预订机票。你可以想象操作步骤之一可能是协助通过连接机场匹配航班。
- en: 'Well, what if the customer selected two flights where the time between the
    flights was too short. You might do something like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果客户选择了两个时间间隔太短的航班，你可能会这样做：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I love this pattern because it makes it super easy for us to now repeatably
    raise an `InsufficientConnection` exception and have a known response for the
    user. But, responding properly to the user is only half of the battle. When something
    goes wrong in our applications in the *real world,* we want to know about it.
    Our applications need to be able to report back so that if there is indeed a problem,
    then we can fix it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这个模式，因为它使我们现在能够重复性地抛出 `InsufficientConnection` 异常，并为用户提供已知的响应。但是，正确地响应用户只是战斗的一半。在我们的应用程序的
    *现实世界* 中，当发生错误时，我们想要知道。我们的应用程序需要能够报告问题，以便如果确实存在问题，我们可以修复它。
- en: So, how do we go about solving this problem? Logging is, of course, essential
    (we will look at that soon in the *Gaining insight from logging and tracing* section
    later). Having a reliable way to get to your system logs is an absolute must for
    a lot of reasons. But do you want to monitor your logs all day long every day
    looking for a traceback? Of course not!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解决这个问题呢？日志记录当然是必不可少的（我们将在后面的 *从日志和跟踪中获得洞察力* 部分很快探讨这一点）。有一个可靠的方式来获取你的系统日志是绝对必须的，出于很多原因。但你真的想每天整天监控你的日志，寻找跟踪信息吗？当然不想！
- en: Somehow, in some way you need to set up some alerts to notify you that an exception
    happened. You will learn that not all exceptions are created equal, and only sometimes
    will you actually want your attention called to the fact that there was an exception.
    If a customer forgets to input valid data, you do not need your mobile phone waking
    you up at 3 am. And while setting up system monitoring and alerting tools is outside
    the scope of this book, the point that I am trying to make is that your application
    should be proactive about warning you when certain things happen. Sometimes bad
    things will happen, and you want to make sure that you are able to sift through
    the noise and not miss out on the issues that really matter. A simple form of
    this might be to send an email when something particularly bad happens.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以某种方式，你需要设置一些警报来通知你发生了异常。你会了解到并非所有异常都是平等的，而且只有有时你才真正希望你的注意力被吸引到异常发生的事实上。如果客户忘记输入有效数据，你不需要在凌晨3点被你的手机吵醒。虽然设置系统监控和警报工具超出了本书的范围，但我试图说明的是，你的应用程序应该主动警告你在某些事情发生时。有时会发生不好的事情，你想要确保你能够从噪音中筛选出真正重要的问题。这种简单形式可能是在发生特别糟糕的事情时发送一封电子邮件。
- en: Knowing what you do about Sanic so far, if I came to you and asked you to build
    a system that sent me an email whenever a `PinkElephantError` is raised, how would
    you do it?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你迄今为止对 Sanic 的了解，如果我来找你并要求你构建一个系统，每当抛出 `PinkElephantError` 异常时，就给我发送一封电子邮件，你会怎么做？
- en: 'I hope this is not your answer:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这并不是你的答案：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: “*Why?*”you might ask. For starters, what if this needs to be implemented in
    a few locations, and then we need to change the notification from `send_adam_an_email()`
    to `build_a_fire_and_send_a_smoke_signal()`? You now need to go searching through
    all of your code to make sure it is done consistently and hope you did not miss
    anything.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “*为什么？*”你可能会问。首先，如果需要在几个地方实现这个功能，然后我们需要将通知从 `send_adam_an_email()` 更改为 `build_a_fire_and_send_a_smoke_signal()`，那会怎样？现在你需要搜索所有代码以确保它是一致的，并希望你没有错过任何东西。
- en: What else could you do? How can you simply write the following code in your
    application and have it know that it needs to send me an email?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你还能做什么？你如何在应用程序中简单地编写以下代码，并让它知道它需要给我发送电子邮件？
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s learn that next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下次再学习这个。
- en: Catching errors with middleware
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用中间件捕获错误
- en: Adding the notification mechanism (in this case, `send_adam_an_email()`) right
    next to where we raise the exception is not the best solution. One solution would
    be to catch the exception with response middleware and send out the alert from
    there. The response is not likely to have an easily parseable exception for you.
    If `PinkElephantError` raises a 400 response, howe are you to be able to distinguish
    it from any other 400 response? You could, of course, have JSON formatting, and
    check the exception type. But that will only work in `DEBUG` mode because in `PRODUCITON`
    mode you do not have that information available.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们抛出异常的地方旁边添加通知机制（在这种情况下，`send_adam_an_email()`）并不是最好的解决方案。一个解决方案是使用响应中间件捕获异常，并从那里发送警报。响应不太可能有一个易于解析的异常供你使用。如果
    `PinkElephantError` 抛出一个 400 响应，你如何能够将它与其他任何 400 响应区分开来？当然，你可以有 JSON 格式，并检查异常类型。但这只能在
    `DEBUG` 模式下工作，因为在 `PRODUCTION` 模式下，你无法获得这些信息。
- en: 'One creative solution might be to attach an arbitrary exception code, and rewrite
    it in the middleware as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个创造性的解决方案可能是附加一个任意的异常代码，并在中间件中按如下方式重写：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For some very targeted use cases, I can see how this might be useful, and if
    it works for you, I will encourage you to do this. It does sort of remind me of
    the old-school style of error coding. You know the ones where you need a lookup
    table to translate a number to an error, which still has some incomprehensible
    meaning because there is no standardization or documentation? Just thinking about
    seeing *E19* on my coffee machine as I race around to find the owner’s manual
    to look up what that means is enough to raise my stress levels. What I am trying
    to say is: “*Save yourself the hassle and try to find a nicer solution to identifying
    exceptions than attaching some otherwise hard-to-understand error codes that you
    later need to translate to something else.*”'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些非常具体的用例，我可以想象这可能会很有用，如果你觉得它对你有用，我会鼓励你这样做。它确实让我想起了老式的错误编码风格。你知道的，那种你需要查找表将数字转换为错误，而这个错误仍然有些难以理解，因为没有标准化或文档的情况？仅仅想象在我四处寻找用户手册来查找
    *E19* 的含义时，我的咖啡机上的这个错误代码就足以提高我的压力水平。我想说的是：“*省去麻烦，尝试找到一种比附加一些难以理解的错误代码更好的方法来识别异常，这些错误代码你后来还需要翻译成其他东西。*”
- en: Catching errors with signals
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用信号捕获错误
- en: Remember our old friend signals from way back in *Leveraging signals for intra-worker
    communication* section in *Chapter 6*, *Outside the Response Cycle*? If you recall,
    Sanic can dispatch event signals when certain things occur. One of them is when
    an exception is raised. Better yet, the signal context includes the exception
    instance making it *MUCH* easier to identify which exception occurred.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们以前的老朋友信号吗？在 *第6章* 的 *利用信号进行工作间通信* 部分中提到的？如果你还记得，Sanic 在某些事情发生时会派发事件信号。其中之一就是当抛出异常时。更好的是，信号上下文包括异常实例，这使得识别哪个异常发生了变得
    *非常* 容易。
- en: 'A cleaner and more maintainable solution to the aforementioned code would look
    like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述代码的一个更干净、更易于维护的解决方案如下：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I think you can already see this is a much classier and fitting solution. For
    a lot of use cases, this might very well be the best solution for you. Therefore,
    I suggest you commit this simple 4-line pattern to memory. Now, when we need to
    change `send_adam_an_email()` to `build_a_fire_and_send_a_smoke_signal()` that
    will be a super simple change to our code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你已经可以看出这是一个更优雅、更合适的解决方案。对于许多用例来说，这可能是你最好的解决方案。因此，我建议你记住这个简单的 4 行模式。现在，当我们需要将
    `send_adam_an_email()` 更改为 `build_a_fire_and_send_a_smoke_signal()` 时，这将是一个超级简单的代码更改。
- en: Longtime builders of Sanic applications may be looking at this example of mine
    wondering if we can just use `app.exception`? This is certainly an acceptable
    pattern, but not without its potential pitfalls. Let’s look at that next.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来一直在构建 Sanic 应用程序的开发者可能会看到我的这个例子，想知道我们是否可以直接使用 `app.exception`？这当然是一个可接受的模式，但并非没有潜在的风险。我们接下来看看这个问题。
- en: Catching the error and responding manually
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获错误并手动响应
- en: When an exception is raised, Sanic stops the regular route handling process
    and moves it over to an `ErrorHandler` instance. This is a single object that
    exists throughout the lifespan of your application instance. Its purpose is to
    act as a sort of mini-router to take incoming exceptions and make sure they are
    passed off to the proper exception handler. If there is none, then it uses the
    default exception handler. As we have seen already, the default handler is what
    we can modify by using `error_format` argument.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当异常被抛出时，Sanic会停止常规的路由处理过程，并将其移动到`ErrorHandler`实例。这是一个在整个应用程序实例生命周期中存在的单个对象。它的目的是充当一种迷你路由器，接收传入的异常并确保它们被传递到适当的异常处理程序。如果没有，则使用默认的异常处理程序。正如我们之前所看到的，默认处理程序是我们可以通过使用`error_format`参数来修改的。
- en: 'Here is a quick example of what an exception handler looks like in Sanic:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速示例，展示了Sanic中的异常处理程序是什么样的：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The problem with this pattern is that because you took over the actual handling
    of the exception, it is now your job to respond with an appropriate response.
    If you build an application with 10, 20, or even more of these exception handlers,
    keeping their responses consistent becomes a chore.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的问题在于，因为你接管了实际的异常处理，现在你需要负责提供适当的响应。如果你构建了一个包含10个、20个甚至更多这些异常处理程序的应用程序，保持它们的响应一致性就会变成一项繁琐的工作。
- en: It is for this reason that I genuinely try to avoid custom exception handling
    unless I need to. In my experience, I get much better results by controlling formatting
    as discussed in *Fallback handling* section in *Chapter 6*, *Operating outside
    the Request Handler*. However, there is one caveat to this which we will explore
    in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '正是因为这个原因，我真正地尽量避免自定义异常处理，除非我需要。根据我的经验，通过控制格式化（如第6章“操作在请求处理程序之外”的*Fallback处理*部分中讨论的）可以获得更好的结果。然而，这里有一个需要注意的例外，我们将在下一节中探讨。 '
- en: I try to avoid one-off response customizations that only target a single use
    case. While building an application, we likely need to build error handlers for
    many types of exceptions, and not just the `PinkElephantError`. Therefore, I tend
    to disfavor using exception handlers when I need to do something with the error—like
    sending an email—and not just deal with how it is output for the user.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量避免只针对单一用例进行一次性响应定制。在构建应用程序时，我们可能需要为许多类型的异常构建错误处理程序，而不仅仅是`PinkElephantError`。因此，当需要处理错误（如发送邮件）而不是仅仅处理用户输出的格式时，我通常不倾向于使用异常处理程序。
- en: 'Okay, okay, I give in. I will let you in on a secret: you can still use the
    `app.exception` pattern to intercept the error, do *something* with it, and then
    use the built-in error formatting. If you like the exception handler pattern better
    than the signal, then it is possible to use it without needing worry about my
    concern of formatting too many custom error responses. Let’s see how we can achieve
    this.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，好吧，我认输了。我会告诉你一个秘密：你仍然可以使用`app.exception`模式来拦截错误，对它进行一些操作，然后使用内置的错误格式化。如果你更喜欢异常处理程序模式而不是信号，那么你可以使用它，而无需担心我关于格式化太多自定义错误响应的担忧。让我们看看我们如何实现这一点。
- en: 'First, let’s make a simple endpoint to throw our error, and report back in
    text format:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个简单的端点来抛出我们的错误，并以文本格式报告：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I have added `quiet=True` to the exception because that will suppress the traceback
    from being logged. This is a helpful technique when the traceback is not important
    for you and it just gets in the way.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我已经将`quiet=True`添加到异常中，这样就会抑制跟踪信息被记录。当跟踪信息对你来说不重要，只是妨碍了你的工作，这是一个有用的技术。
- en: 'Next, create an exception handler to send the email, but still use the default
    error response:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个异常处理程序来发送邮件，但仍然使用默认的错误响应：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can access the default `ErrorHandler` instance using our application instance
    as shown in the preceding code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用应用程序实例来访问默认的`ErrorHandler`实例，如前述代码所示。
- en: I would like you to hit that endpoint using `curl` so you can see that this
    works as expected. You should get the default text response and see that a mock
    email was sent to me as faked in the logs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能使用`curl`来访问那个端点，这样你就可以看到它按预期工作。你应该得到默认的文本响应，并看到日志中记录了一个模拟的邮件发送给我。
- en: As you can also see, we are using the `error_handler` object that exists application
    wide. In our next section, we will look at modifying that object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你也能看到的，我们正在使用存在于应用程序范围内的`error_handler`对象。在我们下一节中，我们将探讨如何修改该对象。
- en: Modifying the ErrorHandler
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改ErrorHandler
- en: When Sanic starts up, one of the first things that it does is create an `ErrorHandler`
    instance. We saw in the previous example that we can access it from the application
    instance. Its purpose is to make sure that when you define an exception handler,
    the request is responded to from the proper location.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当Sanic启动时，它首先做的事情之一就是创建一个`ErrorHandler`实例。我们在前面的例子中看到，我们可以从应用程序实例中访问它。它的目的是确保当你定义异常处理程序时，请求会从正确的位置得到响应。
- en: One of the other benefits of this object is that it is easily customizable and
    is triggered on every single exception. Therefore, in the days before Sanic introduced
    signals, it was the easiest way to get some arbitrary code to run on every exception,
    like our error reporting utility.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象的另一个好处是它易于定制，并且会在每个异常上触发。因此，在Sanic引入信号之前的日子里，这是在每次异常上运行任意代码的最简单方法，就像我们的错误报告工具一样。
- en: 'Modifying the default `ErrorHandler` instance might have looked something like
    this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 修改默认的`ErrorHandler`实例可能看起来像这样：
- en: Create an `ErrorHandler` and inject the reporting code.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ErrorHandler`并注入报告代码。
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instantiate your application using your new handler.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的新处理程序实例化你的应用程序。
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s it. Personally, I would almost *always* go for the signals solution when
    dealing with alerting or other error reporting. Signals have the benefit of being
    a much more succinct and targeted solution. It does not require me to subclass
    or monkey patch any objects. However, it is helpful to know how to create a custom
    `ErrorHandler` instance as you will see it out there in the wild.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。就我个人而言，在处理警报或其他错误报告时，我几乎*总是*会选择信号解决方案。信号的好处是它是一个更简洁、更有针对性的解决方案。它不需要我子类化或修补任何对象。然而，了解如何创建自定义`ErrorHandler`实例是有帮助的，因为你在野外会看到它。
- en: For example, you will see them in third-party error-reporting services. These
    services are platforms that you can subscribe to that will aggregate and track
    exceptions in your application. They can be incredibly helpful in identifying
    and debugging problems in production applications. Usually, they work by hooking
    into your normal exception handling process. Since overriding `ErrorHandler` used
    to be the best method for low-level access to all exceptions in Sanic, many of
    these providers will provide sample code or libraries to use that implement this
    strategy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你会在第三方错误报告服务中看到它们。这些服务是你可以订阅的平台，它们会聚合和跟踪你的应用程序中的异常。它们在识别和调试生产应用程序中的问题方面可以非常有帮助。通常，它们通过挂钩到你的正常异常处理流程来实现。由于在Sanic中，覆盖`ErrorHandler`曾经是访问所有异常的底层访问的最佳方法，因此许多这些提供商将提供示例代码或库来使用该策略。
- en: Whether you use a custom `ErrorHandler` or signals is still a matter of personal
    taste. The biggest benefit, however, for signals is that they are run in a separate
    `asyncio` task. This means that Sanic will efficiently manage the *concurrent*
    response to the user with the reporting (provided you do not introduce other blocking
    code).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用自定义的`ErrorHandler`还是信号，这仍然是一个个人喜好的问题。然而，信号的最大好处是它们在单独的`asyncio`任务中运行。这意味着Sanic将有效地管理对用户的报告（前提是你没有引入其他阻塞代码）的并发响应。
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this in mind, you now have the ability to format all of your errors as
    needed. An alternative strategy to this would be to manage this with exception
    handlers. The problem with that method is that you potentially lose out on Sanic’s
    built-in auto-formatting logic. As a reminder, one of the great benefits of the
    default `ErrorHandler` is that it will attempt to respond with an appropriate
    format like HTML, JSON, or plain text depending upon the circumstance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你现在有权限根据需要格式化所有的错误。与此策略不同的替代策略是使用异常处理程序来管理。这种方法的问题是你可能会失去Sanic内置的自动格式化逻辑。提醒一下，默认`ErrorHandler`的一个巨大好处是它会尝试根据情况以适当的格式（如HTML、JSON或纯文本）做出响应。
- en: Exception handling may not be the most exciting thing to build. It is, nonetheless,
    an incredibly important fundamental component of any professional-grade web application.
    Make sure to put some thought into your application needs when designing a strategy.
    You very well may find that you need a mixture of signals, exception handlers,
    and a custom `ErrorHandler`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理可能不是构建中最激动人心的事情。然而，它无疑是任何专业级Web应用程序的一个极其重要的基本组件。在设计策略时，请确保考虑你的应用程序需求。你可能会发现你需要信号、异常处理程序和自定义`ErrorHandler`的混合。
- en: 'We now turn our attention to another important aspect of professional-grade
    application development that may also not be exciting for some people to build:
    testing.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向专业级应用程序开发的另一个重要方面，这可能对一些人来说构建起来并不令人兴奋：测试。
- en: Setting up a testable application
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置可测试的应用程序
- en: 'Imagine this scenario: inspiration strikes you and you have a great application
    idea. Your excitement and creative juices are flowing as you start formulating
    ideas in your head about what to build. Of course, you do not rush straight into
    building it because you have read all the earlier chapters in this book. You take
    some time to plan it out, and in a caffeine-induced marathon, you start hacking
    away. Slowly you start to see the application take shape and it is working beautifully.
    Hours go by, maybe it''s days or weeks–you are not sure because you are in the
    zone. Finally, after all that work you have a **minimum viable product (MVP)**.
    You deploy it and go for some much-deserved sleep.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这个场景：灵感突然降临，你有一个很棒的应用程序想法。当你开始在脑海中构思要构建的内容时，你的兴奋和创造力都在流淌。当然，你不会直接冲进去构建它，因为你已经阅读了这本书的所有前面的章节。你花了一些时间来规划它，然后在咖啡因的驱动下，你开始着手编写代码。慢慢地，你开始看到应用程序的轮廓，它运行得非常完美。几个小时过去了，也许是一天或一周——你不确定，因为你完全沉浸在其中。最后，经过所有这些工作，你得到了一个**最小可行产品(MVP**)。你部署了它，然后去享受一些应得的睡眠。
- en: The problem is that you never set up testing. Undoubtedly when you now come
    online and check out your error handling system that you set up with advice from
    the previous section, you notice that it is swamped with errors. Uh oh. Users
    are doing things in your application that you did not anticipate. Data is not
    behaving as you thought it might. Your application is broken.///
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于你从未设置过测试。毫无疑问，当你现在上线并检查你根据上一节建议设置的错误处理系统时，你会发现它被错误信息淹没了。哎呀。用户在你的应用程序中做了你没有预料到的事情。数据没有按照你想象的方式表现。你的应用程序出问题了。///
- en: I would venture to guess that most people that have developed a web application
    or done any software development can sympathize with this story. We have all been
    there before. For many newcomers and experienced developers alike, testing is
    not fun. Maybe you are one of those rare breeds of engineers that completely love
    setting up a testing environment. If so, with all honesty, I tip my hat to you.
    For the rest of us, suffice it to say that if you want to build a professional
    application you need to find it in you to develop a test suite.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，大多数开发过Web应用程序或进行过任何软件开发的人都能对这个故事表示同情。我们之前都经历过这种情况。对于许多新手和经验丰富的开发者来说，测试并不有趣。也许你是那些少数喜欢设置测试环境的工程师之一。如果是这样，我真诚地向你致敬。对于其他人来说，简单地说，如果你想构建一个专业应用程序，你需要找到内在的动力来开发测试套件。
- en: 'Testing is a *huge* field, and I will not cover it here. There are plenty of
    testing strategies out there, including the often-celebrated **test driven design**(**TDD**).
    If you know what it is and it works for you: great. If not: I will not judge you.
    If you are unfamiliar with it, I do suggest that you take some time and do some
    Internet research on the topic. It is a fundamental part of many professional
    development workflows and many companies have adopted it.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个*巨大的*领域，我这里不会详细讲解。有许多测试策略，包括经常被称赞的**测试驱动设计**(TDD)。如果你知道它是什么并且它对你有效：太好了。如果你不知道：我不会评判你。如果你不熟悉它，我建议你花些时间在网上对这个主题进行一些研究。它是许多专业发展工作流程的基础部分，许多公司已经采用了它。
- en: 'Similarly, there are a lot of testing terms like **unit-testing** and **integration-testing**.
    Again, this book is not on test theory so we will use simplified definitions:
    unit testing is when you test a single component or endpoint, and integration-testing
    is when you test the component or endpoint interacting with another system (like
    a database). I know some people will not like my definitions, but the semantics
    of the terms is not important for our needs right now.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有许多测试术语，如**单元测试**和**集成测试**。再次强调，这本书不是关于测试理论的，所以我们将使用简化的定义：单元测试是在测试单个组件或端点时进行的，集成测试是在测试与另一个系统（如数据库）交互的组件或端点时进行的。我知道有些人可能不喜欢我的定义，但术语的语义对我们当前的需求并不重要。
- en: What we care about in this book is how you can test your Sanic application in
    both unit and integration tests. Therefore, while I hope the general idea and
    approaches here are useful, to truly have a well-tested application you will need
    to go beyond the pages of this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们关注的是您如何在单元测试和集成测试中测试您的Sanic应用程序。因此，虽然我希望这里的一般思想和方法是有用的，但要真正拥有一个经过良好测试的应用程序，您需要超越本书的页面。
- en: The last ground rule that we need to get out of the way is that the tests here
    will all assume that you are using `pytest`. It is one of the most widely used
    testing frameworks with many plugins and resources.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的最后一个基本规则是，这里的测试都将假设您正在使用`pytest`。它是最广泛使用的测试框架之一，拥有许多插件和资源。
- en: Getting started with sanic-testing
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用sanic-testing
- en: The Sanic Community Organization (the community of developers that maintain
    the project) also maintains a testing library for Sanic. Although its primary
    utility is used by the Sanic project itself to achieve a high level of test coverage,
    it nonetheless has found a home and use case for developers working with Sanic.
    We will use it extensively because it provides a convenient interface for interacting
    with Sanic.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic社区组织（维护此项目的开发者社区）还维护了一个用于Sanic的测试库。尽管它的主要效用是Sanic项目本身用来实现高水平的测试覆盖率，但它仍然为与Sanic一起工作的开发者找到了一个归宿和用例。我们将广泛使用它，因为它提供了一个方便的接口来与Sanic交互。
- en: 'To start we will need to install it into your virtual environment. While we
    are at it, we will install `pytest` too:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将它安装到您的虚拟环境中。在此过程中，我们还将安装`pytest`：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, what does `sanic-testing` do? It provides an HTTP client that you can use
    to reach your endpoints.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`sanic-testing`到底做了什么？它提供了一个HTTP客户端，您可以使用它来访问您的端点。
- en: 'A typical barebones implementation would look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的基本实现可能看起来像这样：
- en: First, you will have your application defined in some module or factory. For
    now, it will be a global scoped variable, but later in the chapter, we will start
    working with factory-pattern applications where the application instance is defined
    inside of a function.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您将在某个模块或工厂中定义您的应用程序。目前，它将是一个全局作用域的变量，但稍后在本章中，我们将开始使用工厂模式应用程序，其中应用程序实例是在一个函数内部定义的。
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, in your testing environment, you initialize a test client. Since we are
    using `pytest`, let’s set that up in a `conftest.py` file as a fixture so we can
    easily access it:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在您的测试环境中，您初始化一个测试客户端。由于我们正在使用`pytest`，让我们在`conftest.py`文件中将其设置为一个固定装置，这样我们就可以轻松访问它：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will now have access to the HTTP client in your unit tests:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将能够在单元测试中访问HTTP客户端：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running your tests now is a matter of executing the pytest command. It should
    look something like this:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行您的测试只是执行pytest命令。它应该看起来像这样：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, what just happened here? What happened is that the test client took your
    application instance and actually ran it locally on your operating system. It
    initiated the Sanic server binding it to a host and port address on your operating
    system and ran whatever event listeners were attached to your application. Then,
    once the server was running, it used `httpx` as an interface to send an actual
    HTTP request to the server. It then bundled up both the `Request` and the `HTTPResponse`
    objects and provided them as the return value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里到底发生了什么？发生的事情是测试客户端获取了您的应用程序实例，并在您的操作系统上实际运行了它。它启动了Sanic服务器，将其绑定到操作系统上的主机和端口地址，并运行了附加到您的应用程序上的任何事件监听器。然后，一旦服务器运行起来，它使用`httpx`作为接口向服务器发送实际的HTTP请求。然后，它将`Request`和`HTTPResponse`对象捆绑在一起，并将它们作为返回值提供。
- en: 'The code for this example can be found in the GitHub repository: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/testing0](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/testing0).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的代码可以在GitHub仓库中找到：[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/testing0](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/testing0)。
- en: This is something that I cannot stress enough. Just about every time that someone
    has come to me with a question about or problem using `sanic-testing` it is because
    the person failed to understand that the test client is *actually* running your
    application. This happens on every single call.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我无法强调得足够的事情。几乎每次有人向我提出关于或使用`sanic-testing`的问题时，都是因为那个人没有理解测试客户端实际上是在运行您的应用程序。这种情况在每次调用中都会发生。
- en: 'For example, consider the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下内容：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you run this, it will first start up the application and send a `GET` request
    to `/foo`. The server then goes through the full shutdown. Next, it stands up
    the application again and sends a `POST` request to `/bar`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此操作时，它将首先启动应用程序并向 `/foo` 发送 `GET` 请求。然后服务器完成完全关闭。接下来，它再次启动应用程序并向 `/bar`
    发送 `POST` 请求。
- en: For most test cases, this starting and stopping of the server is preferred.
    It will make sure that your application runs in a clean environment every time.
    It happens very quickly and you can still whip through a bunch of unit tests without
    feeling this as a performance penalty.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数测试用例，这种启动和停止服务器的操作是首选的。这确保了每次您的应用程序都在一个干净的环境中运行。这个过程非常快，您仍然可以快速完成一系列单元测试，而不会感到性能上的惩罚。
- en: There are some other options that we will explore later in the following sections.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探索一些其他选项。
- en: A more practical test client implementation
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更实用的测试客户端实现
- en: 'Now that you have seen how the test client works, I am going to let you in
    on a little secret: you do not actually need to instantiate the test client. In
    fact, other than the previous example, I have *never* used `sanic-testing` like
    this in a real application.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了测试客户端是如何工作的，我要向您透露一个小秘密：您实际上并不需要实例化测试客户端。实际上，除了之前的例子之外，我**从未**在真实的应用程序中以这种方式使用
    `sanic-testing`。
- en: The Sanic application instance has a built-in property that can set up the test
    client for you if `sanic-testing` has been installed. Since we already installed
    the package, we can just go ahead and start using it. All that you need is access
    to your application instance.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 应用实例有一个内置属性，如果已经安装了 `sanic-testing`，则可以为您设置测试客户端。由于我们已经安装了该包，我们可以直接开始使用它。您所需的一切就是访问您的应用实例。
- en: Setting up an application fixture
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置应用程序 fixture
- en: Before going further, we will revisit the `pytest` fixtures. If you are unfamiliar
    with them, they might seem somewhat magical to you. In brief, they are a pattern
    in `pytest` to declare a function that will return a value. That value can then
    be used to inject an object into your individual tests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将重新审视 `pytest` 的 fixture。如果您不熟悉它们，它们可能对您来说有些神奇。简而言之，它们是 `pytest` 中声明一个将返回值的函数的模式。该值然后可以用来将对象注入到您的单个测试中。
- en: So, for example in our last use case, we defined a fixture in a special file
    called `conftest.py`. Any fixtures that are defined there will be available anywhere
    in your testing environment. That is why we were able to inject `test_client`
    as an argument in our test case.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，在我们的上一个用例中，我们在一个名为 `conftest.py` 的特殊文件中定义了一个 fixture。在那里定义的任何 fixture
    都将在您的测试环境中任何地方可用。这就是我们能够在测试用例中将 `test_client` 作为参数注入的原因。
- en: I find it almost always beneficial to do this with the application instance.
    Whether you are using a globally defined instance, or a factory pattern, you will
    make testing much easier with fixtures.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现几乎总是有益于使用应用实例来做这件事。无论您是使用全局定义的实例，还是使用工厂模式，使用 fixture 都会使测试变得更容易。
- en: 'Therefore, I will always do something like this in my `conftest.py`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我总是在我的 `conftest.py` 中做类似的事情：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I now have access to my application instance everywhere in the test environment
    without importing it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以在测试环境的任何地方访问我的应用实例，而无需导入它：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**TIP**'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There is one more quick trick you should know about fixtures. You can use the
    yield syntax here to help you inject code before and after your test. This is
    particularly helpful with an application if you need to do any sort of cleanup
    after the test runs. To achieve this, do the following:'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您还需要了解关于 fixture 的一个快速技巧。您可以使用 yield 语法在这里帮助您在测试前后注入代码。这对于应用程序尤其有用，如果您需要在测试运行后进行任何清理操作。为了实现这一点，请执行以下操作：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With access to our app instance using fixtures, we can now rewrite the previous
    unit test like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 fixture 访问我们的应用实例，我们现在可以像这样重写之前的单元测试：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To make our lives a little simpler, I added the type annotation for the fixture
    so that my **integrated development environment** (**IDE**) knows that it is a
    Sanic instance. Even though the main purpose of type hinting is to catch mistakes
    early, I also like to use it in cases like this to just make my IDE experience
    nicer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的生活变得简单一些，我为 fixture 添加了类型注解，这样我的 **集成开发环境**（**IDE**）就知道它是一个 Sanic 实例。尽管类型提示的主要目的是尽早捕捉错误，但我还喜欢在类似的情况下使用它来使我的
    IDE 体验更佳。
- en: This example shows that access to the test client is simply a matter of using
    the `app.test_client` property. By doing that, Sanic will automatically instantiate
    the client for you as long as the package is installed. This makes it super simple
    to write unit tests like this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，访问测试客户端只是使用 `app.test_client` 属性的问题。通过这样做，只要安装了包，Sanic 就会自动为您实例化客户端。这使得编写这样的单元测试变得非常简单。
- en: Testing blueprints
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试蓝图
- en: Sometimes you may run across a scenario where you want to test some functionality
    that exists on a blueprint alone. In this case, we are assuming that any application-wide
    middleware or listeners that run before the blueprint are not relevant to our
    test. This means that we are testing some functionality that is entirely contained
    within the boundaries of the blueprint.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能会遇到一个场景，你想测试蓝图上存在的某些功能。在这种情况下，我们假设在蓝图之前运行的任何应用程序范围的中间件或监听器都与我们的测试无关。这意味着我们正在测试一些完全包含在蓝图边界内的功能。
- en: I love situations like this, and actively seek them out. The reason is that
    these are super easy to test as we will see in a minute. These types of testing
    patterns are probably best understood as they contrast to what we will do in the
    *Testing a full application section*. The main differentiator is that in these
    tests, our endpoints do not rely upon the existence of a third-party system like
    a database. Perhaps more accurately I should say that they do not rely upon the
    impacts that a third-party system might have. The functionality and business logic
    are self-contained, and therefore very conducive to unit testing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这种情况，并且会积极寻找它们。原因在于，正如我们将在下一分钟看到的那样，这些测试非常容易进行。这些类型的测试模式最好理解为与我们在 *测试完整应用程序部分*
    中将要做的对比。主要区别在于，在这些测试中，我们的端点不依赖于第三方系统（如数据库）的存在。也许更准确地说，我应该说我应该说的是，它们不依赖于第三方系统可能产生的影响。功能性和业务逻辑是自包含的，因此非常适合单元测试。
- en: When I find a situation like this, the first thing that I do is add a new fixture
    to my `conftest.py` file. It will act as a dummy application that I can use for
    testing. Each unit test I create can use this dummy application with my target
    blueprint attached and nothing else. This allows for my unit test to be more narrowly
    focused on my single example. Let’s see how that looks next.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我发现这种情况时，我首先会在我 的 `conftest.py` 文件中添加一个新的 fixture。它将作为一个我可以用于测试的虚拟应用程序。我创建的每个单元测试都可以使用这个虚拟应用程序，并附加我的目标蓝图，而无需其他任何内容。这使我的单元测试能够更专注于单个示例。让我们看看接下来会是什么样子。
- en: Here, we will create a new fixture that creates a new application instance.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个新的 fixture，它将创建一个新的应用程序实例。
- en: '[PRE21]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now stub out a test in our blueprint tests:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在蓝图测试中创建一个测试桩：
- en: '[PRE22]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, we see that I created a fixture that is localized to this one
    module. The point of this is to create a reusable application instance that has
    my target blueprint attached to it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到我创建了一个仅限于这个模块的 fixture。这样做是为了创建一个可重用的应用程序实例，该实例附加了我的目标蓝图。
- en: A simple use case for this kind of testing might be input validation. Let’s
    add a blueprint that does some input validation. The blueprint will have a simple
    `POST` handler that looks at the incoming JSON body and just checks that the key
    exists, and the type matches the expectation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型测试的一个简单用例可能是输入验证。让我们添加一个执行一些输入验证的蓝图。该蓝图将有一个简单的 `POST` 处理程序，它检查传入的 JSON 主体，并仅检查键是否存在，以及类型是否与预期匹配。
- en: First, we will create a schema that will be the keys and the value type that
    we expect our endpoint to be able to test.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个模式，它将是我们的端点预期能够测试的键和值类型。
- en: '[PRE23]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Second, we will make a simple type checker that responds with one of three
    values depending upon whether the value exists, and is of the expected type:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，我们将创建一个简单的类型检查器，根据值是否存在以及是否为预期的类型，响应三个值之一：
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we will create our endpoint that will take the request JSON and respond
    with a dictionary about whether the passed data was valid.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建我们的端点，它将接收请求 JSON 并响应一个字典，说明传递的数据是否有效。
- en: '[PRE25]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we have now created a very simplistic data checker. We loop
    over the definitions in the schema, and check each to see whether it is as expected.
    All of the values should be `"OK"` and the request data should be the same length
    as the schema.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们现在创建了一个非常简单的数据检查器。我们遍历模式中的定义，并检查每个定义是否符合预期。所有值都应该是 `"OK"`，并且请求数据的长度应该与模式相同。
- en: 'We can now test this out in our test suite. The first thing that we could test
    is to make sure that all the required fields are present. There are three potential
    scenarios here: the input is missing fields, the input has only the correct fields,
    and the input has extra fields. Let’s take a look at these scenarios and create
    some tests for them:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的测试套件中测试这一点。我们首先可以测试的是确保所有必需的字段都存在。这里有三种可能的场景：输入缺少字段，输入只有正确的字段，以及输入有额外的字段。让我们看看这些场景并为它们创建一些测试：
- en: First, we will create a test to check that there are no missing fields.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个测试来检查没有缺少字段。
- en: '[PRE26]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this test, we sent some bad data. Notice how the `an_int` value is actually
    a `str`. But we do not care about that right now. What this meant to test is that
    all the proper fields were sent.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个测试中，我们发送了一些不良数据。注意`an_int`值实际上是一个`str`。但我们现在并不关心这一点。这意味着要测试的是所有适当的字段都已发送。
- en: Next up is a test that should contain all of the inputs, of the correct types,
    but nothing more.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一个应该包含所有输入、正确类型但没有更多内容的测试。
- en: '[PRE27]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, all we need to assert is that the response is a 200 since we know that
    it will be a 400 if it is bad data.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们只需要断言响应是200，因为我们知道如果数据有问题，它将是400。
- en: Lastly, we create a test that checks that we extraneous information is not sent.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个测试来检查我们没有发送多余的信息。
- en: '[PRE28]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this final test, we are sending known bad data since it contains the exact
    same payload as the previous test, except for the additional `"a_bool": True`.
    Therefore, we should assert that the response will be a 400.'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在这个最终测试中，我们发送了已知的不良数据，因为它包含与上一个测试完全相同的有效载荷，除了额外的`"a_bool": True`。因此，我们应该断言响应将是400。'
- en: Looking at these tests, it seems very repetitive. While the general rule of
    **Don’t Repeat Yourself** (aka **DRY**) is often cited as a reason to abstract
    logic, be careful with this in testing. I would prefer to see repetitive testing
    code over some highly abstracted, beautiful, shiny factory pattern. In my experience—and
    yes, I have been burned by this many times in the past—adding fancy abstraction
    layers into testing code is a recipe for disaster. Some abstraction might be helpful
    (creating the `dummy_app` fixture is an example of good abstraction), but too
    much could be disastrous. Unwinding them in the future when some functionality
    needs to change will become a nightmare. This is certainly one of those areas
    where development shades the line between science and art. Creating a powerful
    testing suite with a proper balance of repetition and abstraction will take some
    practice and is highly subjective.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 看这些测试，似乎非常重复。虽然“不要重复自己”的原则（简称DRY）通常被引用为抽象逻辑的理由，但在测试中要小心这一点。我更愿意看到重复的测试代码，而不是一些高度抽象、美丽、闪亮的工厂模式。根据我的经验——是的，我过去曾多次因此受到伤害——在测试代码中添加花哨的抽象层是灾难的配方。一些抽象可能是有帮助的（创建`dummy_app`固定值是一个好的抽象例子），但过多可能会造成灾难。在未来需要更改某些功能时，解开这些抽象将变得是一场噩梦。这确实是在开发中科学与艺术之间界限模糊的一个领域。创建一个功能强大的测试套件，在重复和抽象之间取得适当的平衡，需要一些实践，并且非常主观。
- en: With that warning out of the way, there is an abstraction layer that I do really
    like. It makes use of `pytest.parametrize`. This is a super helpful feature that
    allows you to create a test and run it against multiple inputs. We are not abstracting
    our tests, per se, but instead are testing the same code with a variety of inputs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在消除这些警告之后，有一个抽象层我确实很喜欢。它利用了`pytest.parametrize`。这是一个超级有用的功能，允许你创建一个测试并针对多个输入运行它。我们并不是在抽象测试本身，而是在使用各种输入测试相同的代码。
- en: 'Using `pytest.parametrize`, we can actually condense those three tests into
    a single test:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pytest.parametrize`，我们实际上可以将这三个测试压缩成一个测试：
- en: 'We create a decorator that has two arguments: a string containing a comma-delimited
    list of argument names, and an iterable that contains values to be injected into
    the test.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个有两个参数的装饰器：一个包含逗号分隔的参数名称列表的字符串，以及一个包含要注入测试中的值的可迭代对象。
- en: '[PRE29]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have three values that we are going to inject into our test: `input`, `has_missing`,
    and `expected_status`. The test is going to run multiple times, and each time
    it will pull one of the tuples of arguments to inject into the test function.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有三个值要注入到我们的测试中：`input`、`has_missing`和`expected_status`。测试将运行多次，每次它都会从参数的元组中抽取一个来注入到测试函数中。
- en: 'Our test function can now be abstracted to use these arguments:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的测试函数现在可以抽象化以使用这些参数：
- en: '[PRE30]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this way, it is much easier for us to write multiple unit tests across different
    use cases. You may have noticed that I actually just created a fourth test. Since
    it was so simple to add more tests using this method, I included one use case
    that we had not previously tested. I hope you see the huge benefit that this creates
    and come to learn to love testing with `@pytest.mark.parametrize`.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, we are defining the inputs and what our expected outcome should
    be. By parametrizing the single test, it actually turns this into multiple tests
    inside `pytest`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for these examples can be found in the GitHub repository: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/testing2](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/testing2).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Mocking out services
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The sample blueprint that we were testing against is obviously not something
    we would ever use in real life. In that example, we were not actually doing anything
    with the data. The reason I oversimplified it was so that we did not need to worry
    about how you handle interactions with services like a database access layer.
    What about when we are testing a real endpoint? And, but a real endpoint I mean
    one that is meant to interface with a database. For example, how about a registration
    endpoint? How can we test that the registration endpoint actually does what it
    is supposed to do and injects data as expected?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'I still like using the `dummy_app` pattern for testing even when I know that
    my endpoint needs to perform some database operation. We will look at how we can
    use Python’s mocking utilities to pretend like we have a real database layer:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to refactor our blueprint so that it looks like something
    you might actually encounter in the wild:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We are still doing the input validation. However, instead of simply storing
    the registration details to memory, we will send them off to a database for writing
    to disk. You can checkout the full code at [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/testing3](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/testing3)
    to see the input validation. The important things to note here are that we have
    a `RegistrationService`, and that is calling a `register_user` method.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since we still have not looked at the usage of **object relationship mapping**
    (**ORM**), our database storage function will ultimately just call some raw SQL
    queries. We will look at ORMs in more detail in *Managing database connections*,
    but for now, let’s create the registration service:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The registration service calls into our database to execute some SQL. We will
    also need a connection to our database. For the sake of the example, I am using
    a fake class, but this would (and should) be the actual object that your application
    uses to connect to the database. Therefore, imagine that this is a proper DB client:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With this in place, we can now create a new fixture that will take the places
    of our data access layer. Normally you would create something like this to instantiate
    the client:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Use your imagination and imagine that the aforementioned piece of code exists
    on our *actual* application. It initiates the database connection and allows us
    to access the client within our endpoints as shown in the preceding code because
    our connection uses the applications `ctx` object. Since our unit tests will not
    have access to a database, we need to create a *mock* database instead and attach
    that to our dummy application.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To do that, we will create our `dummy_app` and then import the actual listener
    used by the real application to instantiate the fake client.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To force our client to use a mocked method instead of actually sending a network
    request to a database, we are going to monkeypatch the DB client using a feature
    of pytest. Setup a fixture like this:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We now have a mock object in place of the real `execute` method, and we can
    proceed to build out a test on our registration blueprint. One of the great benefits
    of using the `unittest.mock` library is that it allows us to create assertions
    that the database client would have been called. We will see what that looks like
    next.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, we create a test with some assertions that help us to know that the correct
    data will make its way to the data access layer:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Just like before, we are using `parametrize` so that we could run multiple tests
    with different inputs. The key takeaway is that since we are using a mocked `execute`
    method, we can ask pytest to provide that to us so that our test can assert that
    it was called as we expected it to be.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is certainly helpful for testing isolated issues, but what about when there
    needs to be application-wide testing? We will look at that next.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Testing a full application
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an application progresses from its infancy, there is likely to begin a network
    of middleware, listeners, and signals that process requests that are not just
    limited to the route handler. In addition, there are likely to be connections
    to other services (like databases) that complicate the entire process. A typical
    web application cannot be run in a vacuum. When it starts up, it needs to connect
    to other services. These connections are critical to the proper performance of
    the application, and therefore if they do not exist, then the applications cannot
    start. Testing these can be very troublesome. Do not just throw your hands up
    and give up. Resist the temptation. In the previous tests, there was a glimpse
    of how this can be achieved quite simply. We did in fact successfully test against
    our database. But what about when that is not enough?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes testing against a `dummy_app` is not sufficient.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: This is why I really like applications that are created by a factory pattern.
    The GitHub repository for this chapter is an example of a factory pattern that
    I use a lot. It has some very helpful features in it. Essentially, the end result
    is a function that returns a Sanic instance with everything attached to it. Through
    the implementation of the Sanic standard library, the function crawls through
    your source code looking for things to attach to it (routes, blueprints, middleware,
    signals, listeners, and much more), and is set up to avoid circular import issues.
    We talked about factory patterns and their benefits back in *Chapter 2*, *Organizing
    a project*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么我非常喜欢由工厂模式创建的应用程序。本章的GitHub仓库就是一个我经常使用的工厂模式的例子。它包含了一些非常有用的功能。本质上，最终结果是返回一个带有所有附加内容的Sanic实例的函数。通过Sanic标准库的实现，该函数会遍历你的源代码，寻找可以附加到其上的内容（路由、蓝图、中间件、信号、监听器等等），并且被设置为避免循环导入问题。我们之前在*第二章*，*组织项目*中讨论了工厂模式和它们的优点。
- en: What is particularly important right now is that the factory in the GitHub repository
    can selectively choose what to instantiate. This means we can use our actual application
    with targeted functionality. Let me provide an example.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 目前特别重要的是，GitHub仓库中的工厂可以选择性选择要实例化的内容。这意味着我们可以使用具有针对性功能的有效应用程序。让我提供一个例子。
- en: Once I was building an application. It was critical to know exactly how it was
    performing in the real world. Therefore, I created a middleware that would calculate
    some performance metrics and then send them off to a vendor for analysis. Performance
    was critical—which was part of my decision to use Sanic to begin with. When I
    tried to do some testing, I realized that I could not run the application in my
    test suite if it did not connect to the vendor. Yes, I could have mocked it out.
    However, a better strategy was to just skip the operation altogether. Sometimes,
    there really is no need to test every bit of functionality.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我正在构建一个应用程序。了解它在现实世界中的确切性能至关重要。因此，我创建了一个中间件，它会计算一些性能指标，然后将它们发送给供应商进行分析。性能至关重要——这也是我最初选择使用Sanic的原因之一。当我尝试进行一些测试时，我意识到如果它没有连接到供应商，我就无法在我的测试套件中运行应用程序。是的，我可以模拟它。然而，更好的策略是根本跳过这个操作。有时候，真的没有必要测试每一个功能点。
- en: 'To make this concrete, here is a real quick explanation of what I am talking
    about. Here is a middleware code snippet that calculates runtime at the beginning
    and end of the request, and sends it off:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一点更具体，这里是对我所谈论的内容的一个快速解释。这是一个中间件代码片段，它在请求的开始和结束时计算运行时间，并将它发送出去：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'One solution to my problem of contrasting testing versus production behavior
    could be to change the application code to only run in production:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 解决我的测试与生产行为对比问题的解决方案之一可能是将应用程序代码更改为仅在生产中运行：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But in my opinion, a better solution was to skip this middleware altogether.
    Using the factory pattern shown in the repo, I could do this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我看来，更好的解决方案是根本跳过这个中间件。使用仓库中显示的工厂模式，我可以这样做：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this factory, we are creating a new application instance and looping through
    a list of known modules to import them. In normal usage, we would create an application
    by calling `create_app()`, and the factory would import the `DEFAULT` known modules.
    By importing them, they will attach to our application instance. More importantly,
    however, this factory allows us to send an arbitrary list of modules to load.
    This allows us the flexibility to create a fixture in our tests that uses the
    actual factory pattern for our application, but has the control to pick and choose
    what to load.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工厂中，我们正在创建一个新的应用程序实例，并遍历一个已知模块列表来导入它们。在正常使用中，我们会通过调用`create_app()`来创建一个应用程序，工厂会导入`DEFAULT`已知模块。通过导入它们，它们将附加到我们的应用程序实例上。更重要的是，这个工厂允许我们发送一个任意模块列表来加载。这使我们能够在测试中创建一个使用我们应用程序的实际工厂模式的固定装置，同时拥有选择加载内容的控制权。
- en: 'In our use case, we decided that we do not want to test the performance middleware.
    We can skip it by creating a test fixture that simply ignores that module:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用例中，我们决定我们不想测试性能中间件。我们可以通过创建一个简单地忽略该模块的测试固定装置来跳过它：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, this opens up the ability for me to create tests that are specifically
    targeting parts of my actual application, and not just a dummy application. Using
    a factory through the use of inclusion and exclusion, I can create unit tests
    with only the functionality that I need, and avoid the unneeded functionality.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: I hope your mind is now racing with possibilities that this opens up for you.
    Testing becomes so much easier when the application is itself composable. This
    awesome trick is one way you can really move your application development to the
    next level. An easily composable application becomes an easily testable application.
    This leads to the application being well-tested and now you are truly on your
    way to becoming a next-level developer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: If you have not already begun, I highly suggest that you use a factory like
    mine. Go ahead and copy it. Just promise me that you will use it to create some
    unit tests.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Using the ReusableClient for testing
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up until this point, we have been using a test client that starts and stops
    a service on every call to it. The `sanic-testing` package ships with it another
    test client that can be manually started and stopped. Therefore, it is possible
    to reuse it between calls, or even tests. In the next subsection, we will learn
    about this reusable test client.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Running a single test server per test
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may sometimes need to have multiple calls to your API running on the same
    instance. For example, this could be useful if you were storing some temporary
    state in between calls in memory. This is obviously not a good solution in most
    use cases because storing the state in memory makes horizontal scaling difficult.
    Leaving that issue aside, let’s take a quick look at how you might implement this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create an endpoint that just spits out a counter:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this simplified example, every time that you hit the endpoint, it will increment
    a number.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can test this endpoint that maintains an internal state by using a `ReusableClient`
    instance as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As long as you are using the client inside that `with` context manager, then
    you will be hitting the exact same instance of your application in each call.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can simplify the preceding code by using fixtures:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, when you set up a unit test, it will keep the server running for as long
    as the test function is executing.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The aforementioned unit test could be written as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see, this is a potentially powerful strategy if you want to run
    only a single server for the duration of your test function.What if you want to
    keep the instance running for the entire duration of your testing? The simplest
    way would be to change the `scope` of the fixture to `session`:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this setup, no matter where you are running tests in `pytest`, it will
    be using the same application. While I personally have never felt the need for
    this pattern, I can definitely see its utility.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this example can be found in the GitHub repository: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/testing4](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/testing4).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: With both proper exception management and testing out of the way, the next critical
    addition of any true professional application is logging.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Gaining insight from logging and tracing
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to logging, I think that most Python developers fall into three
    main categories:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: People that always use `print` statements.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People that have extremely strong opinions and absurdly complex logging setups.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People that know they should not use `print`, but do not have the time or energy
    to understand Python’s `logging` module.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you fall into the second category, you might as well skip this section. There
    is nothing in it for you except if you want to criticize my solutions and tell
    me there is a better way.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: If you fall into the first category, then you really need to learn to change
    your habits. Do not get me wrong, `print` is fantastic. However, it does not have
    a place in professional-grade web applications because it does not provide the
    flexibility that the logging module offers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: “*Wait a minute!*” I hear the first category people shouting already. “*If I
    deploy my application with containers and Kubernetes, it can pick up my output
    and redirect it from there.*”/// If you are deadset against using logging, then
    I suppose I might not be able to change your mind. However, leaving aside the
    configuration complexity, consider that the logging module provides a rich API
    to send messages at different levels and with meta context.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the standard Sanic access logs. The message that the access logger sends
    out is actually blank. Take a look for yourself in the Sanic codebase if you want.
    The access log is this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'What you actually see is something more like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Embedded in that line is a bunch of metadata that is both machine-friendly
    and human-readable, thanks to the `logging` module. In fact, you can store arbitrary
    data with logs that some logging configurations will store for you. Something
    like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If I have convinced you, and you want to learn more about how to use logging
    in Sanic, let’s continue.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Types of Sanic loggers
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sanic itself ships with three loggers. You can access all of them in the `log`
    module:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Feel free to use these in your own applications. Especially on smaller projects,
    I often will use the Sanic `logger` object for convenience. These are, of course,
    actually intended for use by Sanic itself, but nothing is stopping you from using
    them. In fact, it might be convenient as you know that all of your logs are formatted
    consistently. My only word of caution is that it’s best to leave the `access_logger`
    object alone since it has a highly specific job.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Why would you want to use both an `error_logger` and a regular logger? I think
    the answer depends upon what you want to happen to your logs. There are many options
    to choose from. The simplest form is obviously just to output to the console.
    This is not a great idea for error logs, however, since you have no way to persist
    the message and review them when something bad happens. Therefore, you might take
    the next step and output your `error_logger` to a file. This, of course, could
    become cumbersome, so you decide instead to use a third-party system to ship off
    your logs to another application to store and make them accessible. Whatever setup
    you desire, using multiple loggers may play a particular role in how the logging
    messages are handled and distributed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own loggers, my first step in application development
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When I approach a new project, one of the things I ask myself is what will
    happen with my production logs? This is, of course, a question highly dependent
    upon your application, and you will need to decide this for yourself. Asking the
    question though highlights a very important point: there is a distinction between
    development logs and production logs. More often than not, I have no clue what
    I want to do with them in production yet. We can defer that question off for another
    day.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Before I even begin writing my application, I will create a logging framework.
    I know that the goal is to have two sets of configurations, so I begin with my
    development logs.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to emphasize this again: The *very first step* in building an application
    is to make a super simple framework for standing up an application with logging.
    So, let’s go through that setup process now:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing, we are going to do is make a super basic scaffold following
    the patterns that we established in *Chapter 2*, *Organizing a Project*:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the application structure that I like to work with because it makes
    it very easy for me to develop on. Using this structure, we can easily create
    a development environment focused upon running the application locally, testing
    the application, logging, and building images. Here, we obviously are concerned
    with running the application locally with logging.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next thing I like to create is my application factory with a dummy route
    on it that I will remove later. Here is how we can begin `server.py`. We will
    continue to add to it:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There is a very important reason that I call `setup_logging` after creating
    my app instance. I want to be able to use the configuration logic from Sanic to
    load environment variables that may be used in creating my logging setup.Here’s
    a quick aside that I want to point out before continuing. There are two different
    camps when it comes to creating a Python `logger` object. One side says that it
    is best practice to create a new `logger` in every module. In this scenario, you
    would put the following code at the top of *every single Python file*:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The benefit of this approach is having the module name of where it was created
    closely related to the logger name. This is certainly helpful in tracking down
    where a log came from. The other camp, however, says that it should be a single
    global variable that is imported and reused since that may be easier to configure
    and control. Besides, we can get the specific targeting of file names and line
    numbers quickly with proper log formatting, so it is unnecessary to include the
    module name in the logger name. While I do not discredit the localized, per module
    approach, I too prefer the simplicity of importing a single instance like this:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you dive really deep into logging, this also provides you with a much greater
    ability to control how different logger instances operate. Similar to the conversation
    about exception handlers, I would rather limit the number of instances I need
    to control. In the example that I just showed for `server.py`, I chose the second
    option to use a single global `logging` instance. This is a personal choice and
    there is no wrong answer in my opinion. There are benefits and detriments of both
    strategies, so choose which makes sense to you.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to create the basic `log.py`. For now, let’s keep it super
    simple, and we will build from there:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'With this in place, we are ready to run the application and test it out. But
    wait?! Where is the app that we pass to our `sanic` command?We previously had
    used this to run our application:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Instead, we will tell the Sanic CLI the location of the `create_app` function,
    and let it run that for us. Change your startup to this:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You should now be able to hit your endpoint and see some basic messages output
    to your terminal. You likely will not have the `DEBUG` message since the logger
    is still probably set to only `INFO` and above. You should see something super
    basic like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Configuring logging
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preceding logging messages are exactly what using `print` could provide.
    The next thing that we need to add is some configuration that will output some
    metadata and format the messages. It is important to keep in mind that some logging
    details may need to be customized to suit the production environment:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: We, therefore, will start by creating a simple configuration.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Make sure to note that we changed the signature function of `setup_logging`
    to now take the application instance as an argument. Make sure to go back to update
    your `server.py` file to reflect this change.As a side note, sometimes you might
    want to simplify your logging to force Sanic to use the same handlers. While you
    can certainly go through the process of updating the Sanic logger configuration
    (see [https://sanicframework.org/en/guide/best-practices/logging.html#changing-sanic-loggers](https://sanicframework.org/en/guide/best-practices/logging.html#changing-sanic-loggers)),
    I find that to be much too tedious. A simpler approach is to set up the logging
    handlers, and then simply apply them to the Sanic loggers as follows:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It is good practice to always have a `StreamHandler`. This will be used to output
    your logs to the console. But what about when we want to add some additional logging
    utilities for production? Since we are not 100% sure yet what our production requirements
    will be, we will set up logging to a file for now. This can always be swapped
    out at another time.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change your `log.py` to look like this:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can easily see how this could be configured with a different kind of logging
    handler or formatting that might more closely match your needs in different environments.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: All of the configurations shown used programmatic controls of the logging instance.
    One of the great flexibilities of the `logging` library is that all of this can
    be controlled with a single `dict` configuration object. You, therefore, will
    find it a very common practice to keep YAML files containing logging configurations.
    These files are easy to update and swap in and out of build environments to control
    production settings.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Adding color context
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding setup is entirely functional, and you could stop there. However,
    to me, this is not enough. When I am developing a web application, I always have
    my terminal open spitting out logs. In a sea of messages, it might be hard to
    sift through all of the text. How can we make this better? We will achieve this
    through the appropriate use of color.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Because I generally do not need to add color to my production output, we will
    go through adding color formatting in my local environment only:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by setting up a custom logging formatter that will add colors
    based upon the logging level. Any debug messages are blue, warnings are yellow,
    errors are red, and a critical message will be red with a white background to
    help them stand out (in a dark colored terminal):'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We are using the standard color escape codes that most terminals understand
    to apply the colors. This will color the entire message. You, of course, could
    get much fancier by coloring only parts of your messages, and if that interests
    you, I suggest you play around with this formatter to see what you can achieve.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After we create this, we will make a quick internal function to decide which
    formatter to use:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If we are in a local environment that is a TTY terminal, then we use our color
    formatter.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to change the start of our `setup_logging` function to account for
    these changes. We will also abstract some more details to our configuration for
    easy access to change them per environment:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Besides dynamically getting a formatter, this example adds one more new piece
    to the puzzle. It is using a configuration value to determine the logging level
    of your logger.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Adding some basic tracing with request IDs
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common problem with logs is that they can become noisy. It might be tough
    to correlate a specific log with a specific request. For example, you might be
    handling multiple requests at the same time. If there is an error, and you want
    to look back at earlier messages, how do you know which logs should be grouped
    together?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: There are entire third-party applications that add what is known as **tracing**.
    This is particularly helpful if you are building out a system of inter-related
    microservices that work together to respond to incoming requests. While not necessarily
    diving into microservice architecture, it is worth mentioning here that tracing
    is an important concept that should be added to your application. This is true
    regardless if your application architecture uses microservices or not.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purpose, what we want to achieve is to add a request identifier to
    every single request. Whenever that request attempts to log something, that identifier
    will automatically be injected into our request format. In order to accomplish
    this goal:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a mechanism to inject the request object into every logging operation.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we need a way to show the identifier if it exists or ignore it if it
    does not.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we get to the code implementation, I would like to point out that the
    second part could be handled in a couple of ways. The simplest might be to create
    a specific logger that will only be used inside of a request context. This means
    that you would have one logger that is used in startup and shutdown operations,
    and another that is used only for requests. I have seen this approach used well.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we are again using multiple loggers. To be entirely honest,
    I really do prefer the simplicity of having just a single instance that works
    for all of my use cases. This way I do not need to bother thinking about which
    logger I should reach for. Therefore, I will show you here how to build option
    two: an omni logger that can be used anywhere in your application. If you instead
    prefer the more targeted types, then I challenge you to take my concepts here
    and build out two loggers instead of one.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get started by tackling the issue of passing the request context. Remember,
    because Sanic operates asynchronously, there is no way to guarantee which request
    will be handled in what order. Luckily the Python standard library has a utility
    that works great with `asyncio`. It is the `contextvars` module. What we will
    do to start is create a listener that setups up a context that we can use to share
    our request object and pass it to the logging framework:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `./middleware/request_context.py`. It should look like
    this:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: What is happening here is that we are creating a context object that can be
    accessed from anywhere that has access to our app. Then, on every single request,
    we will attach the current request to the context variable to make it accessible
    from anywhere the application instance is accessible.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next thing that needs to happen is to create a logging filter that will
    grab the request (if it exists) and add it to our logging record. In order to
    do this, we will actually override Python’s function that creates logging records
    in our `log.py` file:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Make sure you notice that we need to stash the default record factory because
    we want to make use of it. Then when this function is executed, it will check
    to see if there is a current request by looking inside that request context we
    just set up.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to update our format to use this new bit of information. Make
    sure to update this value:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, we can inject the new factory as shown:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Feel free to check this book’s GitHub repository to make sure that your `log.py`
    looks like mine: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/tracing](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/tracing).'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With all of this in place, it is time to hit our endpoint. You should now see
    some nice pretty colors in your terminal, and some request information inserted:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: After running through these examples, one thing you might have noticed and not
    seen before is `request.id`. What is this, and where does it come from?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Using X-Request-ID
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a common practice to use UUIDs to track requests. This makes it very easy
    for client applications to also track requests and *correlate* them to specific
    instances. This is why you will often hear them called correlation IDs. If you
    hear the term, they are the exact same thing.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'As a part of the practice of correlating requests, many client applications
    will send an X-Request-ID header. If Sanic sees that header in an incoming request,
    then it will grab that ID and use it to identify the request. If not, then it
    will automatically generate a UUID for you. Therefore, you should be able to send
    the following request to our logging application and see that ID populated in
    the logs:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: For the sake of simplicity, I am not using a UUID.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Your logs should now reflect this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Logging is a critical component of professional-grade web applications. It really
    does not need to be that complicated. I have seen super lengthy and overly verbose
    configurations that quite honestly scared me away. With a little bit of attention
    to detail, however, you can make a truly fantastic logging experience without
    much effort. I encourage you to grab the source code for this and hack it until
    it meets your needs.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'We next turn our attention to another critical component of web applications:
    database management.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Managing database connections
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book above all else is really hoping to provide you with confidence to
    build applications *your* way. This means we are actively looking to stomp out
    copy/paste development. You know what I mean. You go to **Stackoverflow** or some
    other website, copy code, paste it, and then move on with your day without thinking
    twice about it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of copy/paste mentality is perhaps most prevalent when it comes to
    database connections. Time for a challenge. Go startup a new Sanic app and connect
    it to a database. Some developers might approach this challenge by heading to
    some other codebase (from another project, an article, documentation, or a help
    website), copying some basic connection functions, changing the credentials, and
    calling it a day. They may never have put much thought into what it means to connect
    to a database: if it works, then it must be okay. I know I certainly did that
    for a long time.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: This is not what we are doing here. Instead, we will consider a couple of common
    scenarios, think through our concerns, and develop a solution around them.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: To ORM or Not to ORM, that is the question
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the benefit of anyone that does not know what an ORM is, here is a quick
    definition:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '**ORM** is a framework used to build Python native objects. Those objects are
    related directly to a database schema and are also used to build queries to fetch
    data from the database to be used when building the Python objects. In other words,
    they are a data access layer that has the capability of two-way translation from
    Python and to the database. When people are talking about an ORM, they are typically
    referring to one that is intended to be used with an SQL-based database.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The question about whether to use an ORM or not is one fraught with some strong
    opinions. In some contexts, people might think you are living in the stone age
    if instead of using one you are hand-writing your SQL queries. On the other hand,
    some people will think ORMs are a nuisance and lead to both overly simplistic,
    yet grotesquely complicated and inefficient queries. I suppose to an extent both
    groups are correct.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, I cannot tell you what you should or should not do. The implementation
    details and the use case are highly relevant to any decision. In my projects,
    I tend to shy away from them. I like to use the `databases` project ([https://github.com/encode/databases](https://github.com/encode/databases))
    to build custom SQL queries, and then map the results to `dataclass` objects.
    After handcrafting my SQL, I use some utilities to hydrate them from raw, unstructured
    values into schema-defined Python objects. I have also in the past made extensive
    use of ORMs like peewee ([https://github.com/coleifer/peewee](https://github.com/coleifer/peewee))
    and SQLAlchemy ([https://github.com/sqlalchemy/sqlalchemy](https://github.com/sqlalchemy/sqlalchemy)).
    And, of course, since I developed in Django for many years, I have done a lot
    of work in its internal ORM.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: When should you use an ORM? First and foremost, for most projects using an ORM
    should probably be the default option. They are great at adding the required safety
    and security to make sure that you do not accidentally introduce a security bug.
    By enforcing types, they can be extremely beneficial in maintaining data integrity.
    And, of course, there is the benefit of abstracting away a lot of the database
    knowledge. Where they fall short, perhaps, is in their ability to handle complexity.
    As a project grows in the number of tables and interconnected relationships it
    may be more difficult to continue using ORMs. There also are a lot of more advanced
    options in SQL languages like Postgresql that you simply cannot accomplish with
    an ORM building your queries. I find them to really shine in more simplistic CRUD
    (create/read/update/delete) applications, but actually get in the way of more
    complex database schemas.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Another potential downside to ORMs is that they make it super easy to sabotage
    your own project. A little mistake in building an inefficient query could be the
    difference between absurdly long response times, and super-fast responses. Speaking
    from experience as someone who was bit by this bug, I find that applications that
    are built with ORMs tend to over fetch data and inefficiently, run more network
    calls than are needed. If you feel comfortable with SQL and know that your data
    will become fairly complicated, then perhaps you are better off writing your own
    SQL queries. The biggest benefit of using hand-crafted SQL is that it overcomes
    the complexity-scaling issue of ORMs.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Even though this book is not about SQL, after much consideration I think the
    best use of our time is to build a custom data layer and not use an off-the-shelf
    ORM. This option will force us into making good choices about maintaining our
    connection pools and developing secure and practical SQL queries. Moreover, anything
    that is discussed here in regards to implementation can easily be swapped out
    to a more fully featured ORM. If you are more familiar and comfortable with SQL
    Alchemy (which now has async support), then feel free to swap out my code accordingly.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom data access layer in Sanic
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When deciding upon which strategy to use for this book I explored a lot of the
    options out there. I looked at all of the popular ORMs that I see people using
    with Sanic. Some options like SQLAlchemy have so much material out there that
    I could not possibly do it justice. Other options encouraged lesser quality patterns.
    Therefore, we turn to one of my favorites, the `databases` package using `asyncpg`
    to connect to Postgres (my relational DB of choice). The goal will be to implement
    good connection management,
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'I highly encourage you to look at the code in the repository at [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/hikingapp](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/09/hikingapp).
    This is one of the first times that we have created a *complete* application.
    By that, I mean an example of an application that goes out to fetch some data.
    Going back to the discussion from *Chapter 2, Organizing a project* about project
    layout, you will see an example of how we might structure a real-world application.
    There also is a lot going on in there that is somewhat outside of the discussion
    here (which is much more narrowly focused on database connections), so we will
    not dive too deeply into it right now. But do not worry, we will come back to
    the application’s patterns again in *Chapter 11* when we build out a full application.
    In the meantime, it might be a good opportunity for you to review that source
    code now. Try to understand how the project is structured, run it, and then test
    out some of the endpoints. Instructions are in the repository: [https://github.com/PacktPublishing/Web-Development-with-Sanic/blob/main/chapters/09/hikingapp/README.md](https://github.com/PacktPublishing/Web-Development-with-Sanic/blob/main/chapters/09/hikingapp/README.md).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: I also would like to point out that since our applications are growing with
    the addition of another service, I am going to start running it using docker-compose
    and Docker containers locally. All the build materials are in the GitHub repository
    for you to copy for your own needs. But, of course, you would not dare just copy
    and paste the code without actually understanding it, so let’s make sure that
    you do.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: The application we are talking about is a web API for storing details about
    hiking. It connects its database of known hiking trails to users who can keep
    track of the total distance they have hiked and when they hiked certain trails.
    When you spin up the database, there should be some information prepopulated for
    you.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we must do is make sure that our connection details are
    coming from environment variables. Never store them in the project files. Besides
    the security concerns associated with this, it is super helpful to make changes
    by redeploying your application with different values if you need to change the
    size of your connection pool or rotate your passwords. Let’s begin:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Store your connection settings using docker-compose, kubernetes, or whatever
    other tool you are using to run your containers. If you are not running Sanic
    in a container (for example, you plan to deploy to a PAAS that offers environment
    variables for you thru a GUI), an option that I like to use for local development
    is `dotenv` ([https://github.com/theskumar/python-dotenv](https://github.com/theskumar/python-dotenv)).The
    config values that we care about right now are the **data source name** (**DSN**),
    and the pool settings. If you are not familiar with a DSN, it is a string that
    contains all of the information needed to connect to a database in a form that
    might look familiar to you as a URL.*What is a connection pool?* Imagine a scenario
    where a web request comes in, your application goes and opens a network socket
    to your database. It fetches information, serializes it and sends it back to the
    client. But, it also closes that connection. The next time that happens your application
    needs to reopen a connection to the database. This is hugely inefficient. Instead,
    your application can warm up several connections by opening them and holding them
    in reserve.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, when the application needs a connection, instead of opening a new connection
    it can simply connect to your database using a connection pool, and store that
    object on your application `ctx`:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As you can see, three main things are happening:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first is we are creating the Database object that stores our connection
    pool and acts as the interface for querying. We store it on the `app.ctx` object
    so that it will be easily accessible from anywhere in the application. This was
    placed inside of the `before_server_start` listener since it alters the state
    of our application.
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second is that the listener actually opens up the connections to the database
    and holds them at the ready until they are needed. We are warming up the connection
    pool prematurely so that we do not need to spend the overhead at query time.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: And of course, the important step we do is to make sure that our application
    properly shuts down its connections.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next thing we need to do is create our endpoints. In this example, we will
    use class-based views:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here the `GET` endpoint on the root level of the `/trails` endpoint is meant
    to provide a list of all trails in the database (forgetting about pagination).
    The `TrailExecutor` is one of those objects that I do not want to dive too deeply
    into right now. But, as you can probably guess from this code, it takes the instance
    of our database (which we initiated in the last step) and provides methods to
    fetch data from the database.One of the reasons that I really like the databases
    package is that it makes it incredibly easy to handle connection pooling and session
    management. It basically does it all for you under the hood. But one thing that
    is a good habit to get into (regardless of what system you are using) is to wrap
    multiple consecutive writes to your database in a transaction.Imagine that you
    needed to do something like this:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Often when you have multiple database writes in a single function you either
    want them all to succeed or them all to fail. Having a mixture of success and
    failures might, for example, leave your application in a bad state. When you identify
    situations like this it is almost always beneficial to nest your functions inside
    of a single transaction. To implement such a transaction within our sample, it
    would look something like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now, if one of the queries fails for whatever reason, the database state will
    be rolled back to where it was before the change. I highly encourage you to adopt
    a similar practice no matter what framework you use for connecting to your database.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, a discussion of databases is not necessarily limited to SQL databases.
    There are plenty of NoSQL options out there, and you, of course, should figure
    out what works for your needs. We will next take a look at connecting my personal
    favorite database option to Sanic: Redis.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Sanic to Redis
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redis is a blazingly fast and simple database to work with. Many people think
    of it simply as a key/value store, which is something that it does extremely well.
    It also has a lot of other features that could be thought of as a sort of shared
    primitive data type. For example, Redis has hashes, lists, and sets. These correspond
    nicely to Python’s `dict`, `list`, and `set`. It is for this reason that I often
    recommend this as a solution to someone that needs to share data across a horizontal
    scale-out.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will use Redis as a caching layer. For this, we are relying
    upon its hashmap capability to store a `dict` like structure with details about
    a response. We have an endpoint that might take several seconds to generate a
    response. Let’s simulate that now:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'First create a route that will take a while to generate a response:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Check to see that it works:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To fix this, we will create a decorator whose job is to look for precached
    responses and serve that if it exists:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will install `aioredis`:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create a database connection pool similar to what we did in the previous section:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Next, we will create a decorator to use with our endpoints.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: What is happening here is pretty simple. First, we generate some keys that will
    be used to look up and store values. Then we check to see if anything exists for
    that key. If yes, then use that to build a response. If no, then execute the actual
    route handler (which we know takes some time).
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s see what we have accomplished in action. First, we will hit the endpoint
    again. To emphasize on my point, I will include some stats from `curl`:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, we will try it again:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Wow! It returned almost instantly! In the first attempt, it took just under
    6 seconds to respond. In the second, because the information has been stored in
    Redis, we got an identical response in about 4/1000 of a second. And, don’t forget
    that in those 4/1000 of a second, Sanic went to fetch data from Redis. Amazing!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis as a caching layer is incredibly powerful as it can be used to significantly
    boost your performance. The flip side–as anyone that has worked with caching before
    knows–is that you need to have an appropriate use case and a mechanism for invalidating
    your cache. In the aforementioned example, this is accomplished in two ways. If
    you check the source code at GitHub ([https://github.com/PacktPublishing/Web-Development-with-Sanic/blob/main/chapters/09/hikingapp/application/hiking/common/cache.py#L43](https://github.com/PacktPublishing/Web-Development-with-Sanic/blob/main/chapters/09/hikingapp/application/hiking/common/cache.py#L43)),
    you will see that we are expiring the value automatically after 72 hours, or if
    someone sends a `?refresh=1` query argument to the endpoint.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are past the point of talking about basic concepts in application development,
    we have graduated to the level of exploring some best practices that I have learned
    over the years of developing web applications. This is clearly just the tip of
    the iceberg, but they are some very important foundational practices that I encourage
    you to adopt. The examples from this chapter could become a great foundation for
    starting your next web application process.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: First, we saw how you can use smart and repeatable exception handling to create
    a consistent and thoughtful experience for your users. Second, we explored the
    importance of creating a testable application, and some techniques to make it
    easily approachable. Third, we discussed implementing logging in both development
    and production environments, and how you could use those logs to easily debug
    and trace requests through your application. Finally, we spent time learning how
    databases could be integrated into your application.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to expand upon the basic platform that
    we have built. You will continue to see a lot of the same patterns (like logging)
    continuing to reappear in our examples as we look at some common use cases of
    Sanic.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
