<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer149">
<h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor107"/>7</h1>
<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Building an IoT Button</h1>
<p>In this chapter, we will build an essential component of our IoT home security system: an IoT button. We will build two versions of this button, using different hardware bases – the M5Stack ATOM Matrix and the Raspberry Pi <span class="No-Break">Pico W.</span></p>
<p>The M5Stack ATOM Matrix is a compact ESP32-based microcontroller boasting a built-in dot-matrix screen that also serves as a touch button, a design choice that significantly reduces its size, making it a highly compact solution for IoT projects. Our now familiar Raspberry Pi Pico W stands as a favored microcontroller option, noted for its versatility and seamless integration with a wide array of <span class="No-Break">external peripherals.</span></p>
<p>We will build a simple version of an IoT button, starting with the ATOM Matrix, before we create a more advanced version with our Raspberry Pi <span class="No-Break">Pico W:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<img alt="Figure 7.1 – IoT button architecture" height="621" src="image/B21282_07_01.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – IoT button architecture</p>
<p>In our design, the IoT alarm module (from <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>), Raspberry Pi Pico W, and M5Stack ATOM Matrix all communicate using the <strong class="source-inline">IoTAlarm</strong> topic, as represented by the black box with white lettering in the cloud in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em>. In our graphic, we moved the topic to the cloud since we are now familiar with the MQTT protocol and no longer need to represent it visually. Messages are presented as white boxes with black lettering, and while every device can read and send any message through this topic, they are configured to filter relevant messages and transmit device-specific ones. In <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em>, we see the specific messages each device handles as well as the difference in complexity between the implementation of our two IoT <span class="No-Break">button microcontrollers.</span></p>
<p>We’ll use CloudAMQP for MQTT communication with our second IoT button, ensuring efficient and reliable data transmission through its scalable messaging service. This enhances the button’s performance and real-time data <span class="No-Break">exchange reliability.</span></p>
<p>As we navigate the creation process of these buttons, we deepen our understanding of MQTT communication and Python programming while getting accustomed to different hardware platforms. By using two distinct bases for our projects, we equip ourselves with the insight needed to choose the best platform for our upcoming <span class="No-Break">IoT applications.</span></p>
<p>We will cover the following main topics in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Introducing <span class="No-Break">IoT buttons</span></li>
<li>Creating our IoT button using the M5Stack <span class="No-Break">ATOM Matrix</span></li>
<li>Improving on our IoT button with the Raspberry Pi <span class="No-Break">Pico W</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/>Technical requirements</h1>
<p>The following are the requirements for completing <span class="No-Break">this chapter:</span></p>
<ul>
<li>Intermediate knowledge of <span class="No-Break">Python programming</span></li>
<li>1 x M5Stack <span class="No-Break">ATOM Matrix</span></li>
<li>1 x Raspberry Pi Pico WH (with headers) to use <span class="No-Break">with breadboard</span></li>
<li>1 x Raspberry Pi Pico W (no headers) to be installed in an optional <span class="No-Break">3D-printed case</span></li>
<li>1 x 24 mm <span class="No-Break">arcade-style pushbutton</span></li>
<li>1 x mini <span class="No-Break">SPST switch</span></li>
<li>1 x 0.96-inch <span class="No-Break">OLED screen</span></li>
<li>1 x LED connected with a 220 Ohm resistor (as previously used in <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">)</span></li>
<li>1 x SFM-27 <span class="No-Break">active buzzer</span></li>
<li>12 x M2 5 <span class="No-Break">mm screws</span></li>
<li>2 x M4 20 <span class="No-Break">mm bolts</span></li>
<li>2 x <span class="No-Break">M4 nuts</span></li>
<li>4 x M3 10 <span class="No-Break">mm bolts</span></li>
<li>1 x M5 25 <span class="No-Break">mm bolt</span></li>
<li>1 x <span class="No-Break">M5 nut</span></li>
<li>1 x <span class="No-Break">LED holder</span></li>
<li>Hot <span class="No-Break">glue gun</span></li>
<li>Access to a 3D printer to print <span class="No-Break">optional case</span></li>
</ul>
<p>The code for this chapter may be <span class="No-Break">found here:</span></p>
<p><a href="https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter7"><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter7</span></a></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Introducing IoT buttons</h1>
<p>Toward the end of the animated movie <em class="italic">WALL-E</em> (2008), Captain McCrea battles against the AI autopilot <a id="_idIndexMarker550"/>to regain control of the Axiom spaceship by pushing a big blue button. This results in the massive Axiom starting its hyperjump on a return to Earth. The single button in sci-fi often stands as a beacon of innovation, a dramatic tool that accentuates pivotal moments. In the case of <em class="italic">WALL-E</em>, this button surpasses a simple one-action result, such as sounding a buzzer, and instead carries the weight of humanity’s future, triggering a series of actions that eventually lead to the redemption and rebirth of both mankind <span class="No-Break">and Earth.</span></p>
<p>In this chapter, we will build our own powerful button, although not one with the power of the blue button from <em class="italic">WALL-E</em>. Our button will, however, introduce us to the world of IoT buttons where single actions can trigger a series of automated tasks – in our case, interacting with the IoT alarm module we built in the <span class="No-Break">last chapter.</span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>Utilizing IoT buttons</h2>
<p>IoT buttons are central in the IoT landscape, bridging distances with the aid of the internet to initiate actions globally. Consider the possibility of activating a machine in Mumbai with <a id="_idIndexMarker551"/>a button press from Toronto or remotely triggering an alarm to assist a dormitory-based student in waking up on time for classes. This global reach transforms simple buttons into powerful tools, making daily tasks more efficient <span class="No-Break">and connected.</span></p>
<p>The following <a id="_idIndexMarker552"/>are a few examples of what we can do with <span class="No-Break">IoT buttons:</span></p>
<ul>
<li><strong class="bold">Smart home control button</strong>: This button facilitates control over various household appliances and systems through simple configured commands – a single or double press can <span class="No-Break">control lights</span></li>
<li><strong class="bold">Ordering button</strong>: Especially useful in retail settings, this button facilitates quick orders or reorders of specific products from suppliers, enhancing <span class="No-Break">business efficiency</span></li>
<li><strong class="bold">Feedback button</strong>: These buttons can be installed in corporate or service environments to accumulate immediate feedback from users or customers, helping to maintain a high standard <span class="No-Break">of service</span></li>
<li><strong class="bold">Conference room booking button</strong>: In office spaces, these buttons can aid in the smooth booking of conference rooms, preventing booking conflicts and <span class="No-Break">promoting efficiency</span></li>
<li><strong class="bold">Smart agriculture</strong>: These buttons can streamline processes in agriculture, with functionalities such as immediate watering of farm sections or automated feed release <span class="No-Break">for livestock</span></li>
</ul>
<p>In this chapter, we will use our IoT button to interact with our IoT alarm module. For this, we will build a simple button with the M5Stack ATOM Matrix and a more complex button with our Raspberry Pi <span class="No-Break">Pico W.</span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/>Exploring various technologies in IoT button development</h2>
<p>In the fast-growing field of IoT, the choice of technology can greatly affect the functionality <a id="_idIndexMarker553"/>and adaptability of the devices we create. In this chapter, we adopt this approach as we use two different yet effective platforms – the M5Stack ATOM Matrix and the Raspberry Pi Pico W – to construct IoT buttons with varying levels <span class="No-Break">of complexity.</span></p>
<p>We start with the M5Stack ATOM Matrix to build our initial button. This microcontroller is notable for its compactness, featuring an integrated dot-matrix screen that functions as a touch button. Its straightforward design not only allows for easy assembly but also supports a simple button solution, ideal for our first IoT button (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer127">
<img alt="Figure 7.2 – Raspberry Pi Pico W and M5Stack ATOM Matrix" height="250" src="image/B21282_07_02.jpg" width="848"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Raspberry Pi Pico W and M5Stack ATOM Matrix</p>
<p>Building on what we learned from the ATOM Matrix project, we then move on to leverage the capabilities of the Raspberry Pi Pico W (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.2</em>). We know this platform for its versatility and compatibility with various peripherals. This offers us more customization in button development. The Raspberry Pi Pico W enables us to create a button with a higher degree of functionality than the M5Stack <span class="No-Break">ATOM Matrix.</span></p>
<p>Working with two different technological bases not only broadens our understanding but also encourages a flexible approach to IoT project development. This progression from a simple to a more advanced button is designed to help us steadily build on our knowledge, equipping us with the insight to choose the right platform for future <span class="No-Break">IoT projects.</span></p>
<p>Let’s <span class="No-Break">get started.</span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Creating our IoT button using the M5Stack ATOM Matrix</h1>
<p>In <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em>, we depict the ATOM Matrix on the right-hand side, receiving a <strong class="source-inline">motion</strong> input message <a id="_idIndexMarker554"/>and issuing a <strong class="source-inline">buzzer</strong> output message. These <a id="_idIndexMarker555"/>messages are associated with <strong class="bold">passive infrared</strong> (<strong class="bold">PIR</strong>) sensor detections and buzzer activation on the IoT alarm module, respectively. Utilizing its integrated dot-matrix screen, which also serves as a touch <a id="_idIndexMarker556"/>button, we will use the M5Stack ATOM Matrix to create our first <span class="No-Break">IoT button.</span></p>
<p>Before we initiate the setup and programming of the ATOM Matrix, let’s take a moment to familiarize ourselves with the range of products <span class="No-Break">M5Stack offers.</span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>Exploring M5Stack devices</h2>
<p>M5Stack is <a id="_idIndexMarker557"/>known for its stackable development kits, suitable for hobbyists and professionals alike. Based on the ESP32 microcontroller, these kits offer functionality and scalability, crucial for IoT, AI, and robotics projects. M5Stack’s modules provide easy integration of various functionalities, coupled with a user-friendly <span class="No-Break">development environment.</span></p>
<p>In <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.3</em>, we see a photo of various <span class="No-Break">M5Stack devices:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer128">
<img alt="Figure 7.3 – M5Stack devices" height="491" src="image/B21282_07_03.jpg" width="958"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – M5Stack devices</p>
<p>Let’s see what the <span class="No-Break">devices do:</span></p>
<ul>
<li><strong class="bold">M5Stack Basic</strong> (<em class="italic">A</em>): The M5Stack Basic is an all-encompassing central controller <a id="_idIndexMarker558"/>for IoT applications, powered by the Espressif ESP32 chipset housing two Xtensa® 32-bit LX6 microprocessors with a 240 MHz <a id="_idIndexMarker559"/>peak frequency. It provides <a id="_idIndexMarker560"/>a rich array of development interfaces, including <strong class="bold">Analog-to-Digital Converter</strong> (<strong class="bold">ADC</strong>), <strong class="bold">Digital-to-Analog Converter</strong> (<strong class="bold">DAC</strong>), and <strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>), alongside 15 Input/Output (IO) pins. It <a id="_idIndexMarker561"/>features a 2.0-inch HD <strong class="bold">in-plane switching</strong> (<strong class="bold">IPS</strong>) display <a id="_idIndexMarker562"/>panel, accompanied by a speaker and microSD <span class="No-Break">card slot.</span></li>
<li><strong class="bold">M5StickC PLUS</strong> (<em class="italic">B</em>): The M5StickC <a id="_idIndexMarker563"/>PLUS is powered by ESP32-PICO-D4 with Wi-Fi. It offers a large 1.14-inch screen with 135 x 240 px <a id="_idIndexMarker564"/>resolution. The board houses infrared, <strong class="bold">Real-Time Clock</strong> (<strong class="bold">RTC</strong>), microphone, and LED, and features a robust 120 mAh battery. It supports HAT and Unit <span class="No-Break">product families.</span></li>
<li><strong class="bold">M5Stack Unit LoRaWAN915</strong> (<em class="italic">C</em>): The M5Stack Unit LoRaWAN915 is a <strong class="bold">LoRaWAN</strong> (short for <strong class="bold">Long Range Wide Area Network</strong>) module designed for 915 MHz <a id="_idIndexMarker565"/>frequency communications, leveraging <a id="_idIndexMarker566"/>the ASR6501 chipset <a id="_idIndexMarker567"/>to enable long-distance connections while maintaining low power usage and <span class="No-Break">high sensitivity.</span></li>
<li><strong class="bold">ENV III HAT</strong> (<em class="italic">D</em>): The ENV III HAT is a versatile environmental sensor compatible <a id="_idIndexMarker568"/>with the M5StickC series, housing the SHT30 and QMP6988 to measure temperature, humidity, and <span class="No-Break">atmospheric pressure.</span></li>
<li><strong class="bold">ATOM Matrix</strong> (<em class="italic">E</em>): The ATOM Matrix is M5Stack’s most compact development board at 24*24 mm, offering an extensive range of GPIO pins for compact embedded <a id="_idIndexMarker569"/>device projects. Powered by the <a id="_idIndexMarker570"/>ESP32-PICO-D4 chip, it integrates Wi-Fi technologies and 4 MB of <strong class="bold">SPI</strong> ( short for <strong class="bold">Serial Peripheral Interface</strong>) flash memory. The board features a 5*5 RGB LED matrix, an infrared LED, a programmable <a id="_idIndexMarker571"/>button for added input support, and a built-in <strong class="bold">Inertial Measurement Unit</strong> (<strong class="bold">IMU</strong>) <span class="No-Break">sensor (MPU6886).</span></li>
</ul>
<p>For our first IoT button, we will be using the ATOM Matrix. While we could have opted for the Basic, M5StickC PLUS, or the newer ATOMS3 (not shown), as all these devices provide a pushbutton and a screen for feedback, we chose the ATOM Matrix because it offers a unique blend of compactness and simplicity, making it ideal for this introductory project. Furthermore, its integrated dot-matrix screen, doubling as a touch button, presents a more intuitive and interactive experience <span class="No-Break">for users.</span></p>
<p>M5Stack provides intuitive tools to set up and program our ATOM Matrix. We’ll begin with the burner tool to configure <span class="No-Break">our Matrix.</span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>Flashing the firmware to our ATOM Matrix</h2>
<p>The M5Burner <a id="_idIndexMarker572"/>allows us to flash firmware onto our M5Stack devices. This tool simplifies the process the process <span class="No-Break">for us.</span></p>
<p>To use the tool, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We download the installation file from the M5Stack website using this <span class="No-Break">URL: </span><a href="https://docs.m5stack.com/en/download"><span class="No-Break">https://docs.m5stack.com/en/download</span></a><span class="No-Break">.</span></li>
<li>For our project, we’ll download and install the Windows version of the burner. Once installed, we’ll run the program and click on the <strong class="bold">ATOM</strong> tab on the left, and we should see the <span class="No-Break">following screen:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer129">
<img alt="Figure 7.4 – M5Burner ATOM screen" height="374" src="image/B21282_07_04.jpg" width="1149"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – M5Burner ATOM screen</p>
<ol>
<li value="3">The <strong class="source-inline">UIFlow_MATRIX</strong> firmware is designed for the ATOM Matrix, enabling drag-and-drop graphical programming that translates to MicroPython. It features <a id="_idIndexMarker573"/>built-in libraries and offers <strong class="bold">over-the-air</strong> (<strong class="bold">OTA</strong>) updates for wireless programming. We click on the <strong class="bold">Download</strong> button to download the firmware onto our <span class="No-Break">local computer.</span></li>
<li>Once the firmware has finished downloading, we click on the <strong class="bold">Burn</strong> button (formally the <strong class="bold">Download</strong> button) to start flashing the <strong class="bold">UIFlow_MATRIX</strong> firmware onto our ATOM Matrix. We should see a dialog requesting our <span class="No-Break">Wi-Fi information.</span></li>
<li>By clicking the top-right blue button, we can auto-fill our computer’s Wi-Fi details or enter them manually. Once entered, we click <strong class="bold">Next</strong> to continue. We should see the <strong class="bold">Burn</strong> <span class="No-Break">screen next.</span></li>
<li>We choose the port where the ATOM Matrix is connected and click the <strong class="bold">Start</strong> button to <a id="_idIndexMarker574"/>initiate the firmware burn. A progress screen will then display the ongoing <span class="No-Break">burn status.</span></li>
<li>Upon successful completion, we click on the green <strong class="bold">Burn successfully, click here to </strong><span class="No-Break"><strong class="bold">return</strong></span><span class="No-Break"> button:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer130">
<img alt="Figure 7.5 – Burn successful" height="507" src="image/B21282_07_05.jpg" width="848"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Burn successful</p>
<p>We now have successfully installed the <strong class="bold">UIFlow_MATRIX</strong> firmware onto our ATOM Matrix. We should observe that the dot-matrix screen on our device blinks green. This firmware comes with dedicated libraries that we will use to create our first <span class="No-Break">IoT button.</span></p>
<p>With the firmware installed, it is now time to configure our ATOM Matrix so that we can start <span class="No-Break">programming it.</span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Configuring the ATOM Matrix for programming</h2>
<p>To program <a id="_idIndexMarker575"/>our ATOM Matrix, we’ll use M5Stack’s UIFlow, specifically its Python environment. UIFlow serves as an online IDE, connecting to our devices through an API key. For successful development, it’s essential to retrieve this key and properly configure our <span class="No-Break">ATOM Matrix.</span></p>
<p>To configure <a id="_idIndexMarker576"/>our ATOM Matrix, we do <span class="No-Break">the following:</span></p>
<ol>
<li>In the <strong class="bold">M5Burner</strong> window, we click on the <span class="No-Break"><strong class="bold">ATOM</strong></span><span class="No-Break"> tab.</span></li>
<li>We click on the <strong class="bold">Configure</strong> button in the <span class="No-Break"><strong class="bold">UIFlow_Matrix</strong></span><span class="No-Break"> section:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer131">
<img alt="Figure 7.6 – UIFlow Matrix Configure button" height="332" src="image/B21282_07_06.jpg" width="1330"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – UIFlow Matrix Configure button</p>
<ol>
<li value="3">This should open the <strong class="bold">UIFlow Configuration</strong> dialog, and the port to which our ATOM Matrix is connected should be displayed. We click on <strong class="bold">Load</strong> to proceed to the <span class="No-Break">next screen.</span></li>
<li>This will bring us to the next screen, <span class="No-Break"><strong class="bold">UIFlow Configuration</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer132">
<img alt="Figure 7.7 – Main UIFlow configuration screen" height="631" src="image/B21282_07_07.jpg" width="755"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Main UIFlow configuration screen</p>
<ol>
<li value="5">Using <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.7</em> as a reference, we’ll focus on the parameters highlighted by the boxes. Starting with <strong class="bold">COM</strong>, it should be set to the port where our ATOM Matrix <span class="No-Break">is connected.</span></li>
<li>The <strong class="bold">APIKEY</strong> parameter serves as the connection bridge between the UIFlow IDE and <a id="_idIndexMarker577"/>our device. We take note of this key and keep it <span class="No-Break">easily accessible.</span></li>
<li><strong class="bold">Start Mode</strong> determines the device’s startup behavior. We configure it to <strong class="bold">Internet Mode</strong> for connectivity with the UIFlow IDE. After programming our ATOM Matrix, this mode will switch to <strong class="bold">App Mode</strong> automatically. To re-connect with the IDE after that, we’ll need to revisit <strong class="bold">M5Burner</strong> and reset this to <span class="No-Break"><strong class="bold">Internet Mode</strong></span><span class="No-Break">.</span></li>
<li>We set the <strong class="bold">WIFI SSID</strong> and <strong class="bold">WIFI Password</strong> parameters if they are not already set to the <span class="No-Break">correct values.</span></li>
<li>We click on the blue <strong class="bold">Save</strong> button to save the parameters to our <span class="No-Break">ATOM Matrix.</span></li>
</ol>
<p>With our ATOM Matrix configured, we’re set to start programming and turn the device into our first functional <span class="No-Break">IoT button.</span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor117"/>Turning our ATOM Matrix into an IoT button</h2>
<p>We will <a id="_idIndexMarker578"/>use M5Stack’s UIFlow online IDE <a id="_idIndexMarker579"/>for development as it provides a straightforward coding platform for M5Stack devices. We will make use of the API key that we recorded from the configuration of our device to connect to <span class="No-Break">the IDE.</span></p>
<p>To add MicroPython code to our ATOM Matrix, we do <span class="No-Break">the following:</span></p>
<ol>
<li>In an internet-enabled browser, we navigate to the following <span class="No-Break">URL: </span><a href="https://flow.m5stack.com"><span class="No-Break">https://flow.m5stack.com</span></a><span class="No-Break">.</span></li>
<li>We will be presented with a screen to choose either <strong class="source-inline">UIFlow1.0</strong> or <strong class="source-inline">UIFlow2.0</strong>. Since we are using an ATOM Matrix, we choose UIFlow1.0 and click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">Confirm</strong></span><span class="No-Break">.</span></li>
<li>In the IDE, we click on the <strong class="bold">&lt;/&gt; Python</strong> tab so that we can program our ATOM Matrix <span class="No-Break">in MicroPython:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer133">
<img alt="Figure 7.8 – UIFlow IDE" height="444" src="image/B21282_07_08.jpg" width="1163"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – UIFlow IDE</p>
<ol>
<li value="4">To link our ATOM Matrix to UIFlow, we click the <strong class="bold">Api key</strong> label at the bottom left of the screen to open the <span class="No-Break"><strong class="bold">Setting</strong></span><span class="No-Break"> screen:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer134">
<img alt="Figure 7.9 – Setting screen" height="448" src="image/B21282_07_09.jpg" width="1081"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Setting screen</p>
<ol>
<li value="5">We <a id="_idIndexMarker580"/>enter the API key for our <a id="_idIndexMarker581"/>device and click <strong class="bold">OK</strong> to connect our ATOM Matrix to the <span class="No-Break">UIFlow IDE.</span></li>
<li>In the code editor, we overwrite the existing code with <span class="No-Break">the following:</span><pre class="source-code">
from m5stack import *
from m5ui import *
from uiflow import *
from m5mqtt import M5mqtt
import time
rgb.setColorAll(0x000000)
def cb_IoTAlarm(topic_data):
    if topic_data == 'motion':
        rgb.setColorAll(0xff0000)
        wait(5)
    rgb.setColorAll(0x00cccc)
def buttonA_pressFor():
    m5mqtt.publish(str('IoTAlarm'), str('buzzer'), 0)
btnA.pressFor(1, buttonA_pressFor)
m5mqtt = M5mqtt(
    'IoTMatrix',
    'broker.mqtthq.com',
    1883,
    '',
    '',
    300
)
m5mqtt.subscribe(str('IoTAlarm'), cb_IoTAlarm)
rgb.setColorAll(0x00cccc)
m5mqtt.start()</pre><p class="list-inset">Before <a id="_idIndexMarker582"/>downloading the code <a id="_idIndexMarker583"/>to our ATOM Matrix, let’s break it down. We start with <span class="No-Break">our imports:</span></p><ul><li><strong class="source-inline">from m5stack import *</strong>: Imports all functions and classes from the <span class="No-Break">M5Stack library.</span></li><li><strong class="source-inline">from m5ui import *</strong>: Imports all UI-related functions and classes <span class="No-Break">for M5Stack.</span></li><li><strong class="source-inline">from uiflow import *</strong>: Imports all UIFlow-specific functions <span class="No-Break">and classes.</span></li><li><strong class="source-inline">from m5mqtt import M5mqtt</strong>: Imports the <strong class="source-inline">M5mqtt</strong> class, which allows for <span class="No-Break">MQTT communication.</span></li><li><strong class="source-inline">import time</strong>: Imports the standard Python <span class="No-Break"><strong class="source-inline">time</strong></span><span class="No-Break"> library.</span></li></ul></li> <li>We <a id="_idIndexMarker584"/>then set our screen to black <a id="_idIndexMarker585"/>with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">rgb.setColorAll(0x000000)</strong></pre></li> <li>We define our callback function as <strong class="source-inline">cb_IoTAlarm(topic_data)</strong>. This does <span class="No-Break">the following:</span><ol><li class="upper-roman">Checks if the incoming message under the <strong class="source-inline">IoTAlarm</strong> topic <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">motion</strong></span><span class="No-Break">.</span></li><li class="upper-roman">If <strong class="source-inline">motion</strong> is received, the RGB LED color is set to red (<strong class="source-inline">0xff0000</strong>) for <span class="No-Break">5 seconds.</span></li><li class="upper-roman">Afterward, the RGB LED color is reset to a cyan <span class="No-Break">color (</span><span class="No-Break"><strong class="source-inline">0x00cccc</strong></span><span class="No-Break">).</span></li></ol></li>
<li>We then define a function to scan for a press of button <strong class="source-inline">A</strong> (the screen) and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">buttonA_pressFor()</strong></span><span class="No-Break">.</span><p class="list-inset">In this method, we publish a message with the <strong class="source-inline">IoTAlarm</strong> topic and <strong class="source-inline">buzzer</strong> payload when button <strong class="source-inline">A</strong> is pressed for <span class="No-Break">1 second.</span></p></li>
<li>We then create an instance of the <strong class="source-inline">M5mqtt</strong> class we call <strong class="source-inline">m5mqtt</strong> with the <span class="No-Break">given parameters:</span><ul><li>The device name is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">IoTMatrix</strong></span><span class="No-Break">.</span></li><li>The MQTT broker address is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">broker.mqtthq.com</strong></span><span class="No-Break">.</span></li><li>The MQTT port is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1883</strong></span><span class="No-Break">.</span></li><li>We provide empty strings for username and password as none <span class="No-Break">are required.</span></li><li>We set the MQTT keep-alive time set to <span class="No-Break"><strong class="source-inline">300</strong></span><span class="No-Break"> seconds.</span></li></ul></li>
<li>Our code <a id="_idIndexMarker586"/>then subscribes to the <strong class="source-inline">IoTAlarm</strong> topic and sets the callback function with the <span class="No-Break">following code:</span><pre class="source-code">
m5mqtt.subscribe(str('IoTAlarm'), cb_IoTAlarm)</pre></li> <li>We then <a id="_idIndexMarker587"/>set the RGB LED matrix color to cyan as an <span class="No-Break">initial state:</span><pre class="source-code">
rgb.setColorAll(0x00cccc)</pre></li> <li>The final line starts the MQTT client, enabling it to send and <span class="No-Break">receive messages:</span><pre class="source-code">
m5mqtt.start()</pre></li> <li>With the code in place, we download it to our ATOM Matrix by clicking on the blue <strong class="bold">Download</strong> button located on the lower right-hand side of <span class="No-Break">the screen.</span></li>
</ol>
<p>With the code loaded onto our ATOM Matrix, we are now ready to <span class="No-Break">test it.</span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor118"/>Testing our IoT button</h2>
<p>For our initial tests, we’ll use the MQTTHQ web client, as previously covered in <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, before <a id="_idIndexMarker588"/>testing our IoT button on our IoT <span class="No-Break">alarm module.</span></p>
<p>To do this, we do <span class="No-Break">the following:</span></p>
<ol>
<li>In a browser, we navigate to the following <span class="No-Break">URL: </span><a href="https://mqtthq.com/client"><span class="No-Break">https://mqtthq.com/client</span></a><span class="No-Break">.</span></li>
<li>In the <strong class="bold">Publish to topic:</strong> section, we set the topic <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">IoTAlarm</strong></span><span class="No-Break">.</span></li>
<li>In the <strong class="bold">Payload to publish:</strong> section, we type in the <strong class="source-inline">motion</strong> message and press the orange <span class="No-Break"><strong class="bold">Publish</strong></span><span class="No-Break"> button.</span></li>
<li>On our ATOM Matrix, we should observe that our screen turns red for 5 seconds before returning to its <span class="No-Break">initial color.</span></li>
<li>In the <strong class="bold">Subscribe to topic:</strong> section of the MQTTHQ web client, we subscribe to the <span class="No-Break"><strong class="source-inline">IoTAlarm</strong></span><span class="No-Break"> topic.</span></li>
<li>On our ATOM Matrix, we press and hold down the main button (the screen) for 1 second <span class="No-Break">before releasing.</span></li>
<li>In the <strong class="bold">Subscribe to topic:</strong> section, we should observe a <span class="No-Break"><strong class="source-inline">buzzer</strong></span><span class="No-Break"> message.</span></li>
<li>With the successful completion of our MQTTHQ tests, we are now ready to test our IoT button <a id="_idIndexMarker589"/>on our IoT alarm module. Using a micro-USB cable, we plug the IoT alarm module we created in <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> into a USB <span class="No-Break">power brick.</span></li>
<li>After initializing, we wave our hand in front of the PIR sensor and observe the screen on our ATOM Matrix turn red for <span class="No-Break">5 seconds.</span></li>
<li>Pressing and holding the primary button on our ATOM Matrix for a second and then releasing should trigger the buzzer on our IoT <span class="No-Break">alarm module.</span></li>
</ol>
<p>Congratulations are in order as we have just created our first IoT button using the M5Stack ATOM Matrix! As the connection between our IoT alarm module and our IoT button is through the internet, we may place either device anywhere in the world and have <span class="No-Break">them communicate.</span></p>
<p>Even though our ATOM Matrix comes in a convenient form factor, as do all M5Stack controllers, we do have a custom stand that we may mount it with (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.10</em>). The 3D printer files are in the <strong class="source-inline">Build Files</strong> folder of this chapter’s <span class="No-Break">GitHub repository:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer135">
<img alt="Figure 7.10 – M5Stack ATOM Matrix stand" height="468" src="image/B21282_07_10.jpg" width="1197"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – M5Stack ATOM Matrix stand</p>
<p>To use the stand, we position the ATOM Matrix (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.10</em>) into the stand’s cup section (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.10</em>) with the USB-C port facing the stand’s base. The stand features <a id="_idIndexMarker590"/>a rear hole, accommodating an M2 5 mm screw (not shown) to anchor the ATOM Matrix, which has a 2 mm mounting hole at the back. The stand is designed to accommodate a USB-C cable or adapter at a 90-degree angle. Additionally, it can be mounted over an opening to conceal the USB-C cable, making it suitable for ceilings <span class="No-Break">or shelves.</span></p>
<p>With our first IoT button completed, we are now ready to build the more complex second version of <span class="No-Break">our button.</span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/>Improving on our IoT button with the Raspberry Pi Pico W</h1>
<p>As our IoT alarm system becomes more complex, the limitations of the public MQTTHQ server <a id="_idIndexMarker591"/>become increasingly evident. Given that it’s a public platform, its reliability can be inconsistent. Transitioning to a reliable, private server would significantly enhance our development process and <span class="No-Break">system dependability.</span></p>
<p>In this section, we will build an improved IoT button using a Raspberry Pi Pico W, a buzzer, an arcade-style pushbutton, a switch, an LED, and an OLED screen (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.11</em>). We’re enhancing our project’s reliability and efficiency by moving to a private MQTT server <span class="No-Break">using CloudAMQP.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer136">
<img alt="Figure 7.11 – Enhanced IoT button" height="557" src="image/B21282_07_11.jpg" width="1289"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Enhanced IoT button</p>
<p>While <a id="_idIndexMarker592"/>using a private server is optional, it stands as a significant upgrade over continuing with the public MQTTHQ server. The code in this section will still work with the public MQTTHQ server (with configuration changes); however, by opting for CloudAMQP, we will improve the reliability and security of our IoT <span class="No-Break">alarm system.</span></p>
<p>We will start by setting up an MQTT instance <span class="No-Break">with CloudAMQP.</span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor120"/>Setting up a CloudAMQP instance</h2>
<p>CloudAMQP is a managed MQTT service optimized for IoT devices and applications. It ensures <a id="_idIndexMarker593"/>reliable, real-time messaging with features such as WebSockets and retained messages. With its intuitive interface, CloudAMQP caters to both hobbyists and enterprises and makes an excellent choice for our IoT <span class="No-Break">alarm system.</span></p>
<p>We may view the pricing of the services here – <a href="https://www.cloudamqp.com/plans.xhtml"><span class="No-Break">https://www.cloudamqp.com/plans.xhtml</span></a></p>
<p>For our purposes, the free <strong class="bold">Little Lemur</strong> service will suffice. Upon setting up an account, we create an instance to use with our project. To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Logging in to our account will bring up the <strong class="bold">Instances</strong> page. To create a new instance, we click on the green <strong class="bold">Create New </strong><span class="No-Break"><strong class="bold">Instance</strong></span><span class="No-Break"> button.</span></li>
<li>This will take us to the <strong class="bold">Select a plan and name</strong> page. In the appropriate boxes, we fill out the name of our instance, the plan we are using, and any tags we may wish to associate our instance with. For our example, we call our instance <strong class="source-inline">IoTProgrammingProjects</strong>, set our plan to <strong class="source-inline">Little Lemur</strong>, and leave the <strong class="bold">Tags</strong> field blank. We click on the green <strong class="bold">Select Region</strong> button to go to the <span class="No-Break">next screen.</span></li>
<li>This takes <a id="_idIndexMarker594"/>us to the <strong class="bold">Select a region and data center</strong> screen where we select a nearby data center. For our example, we select <strong class="source-inline">CA-Central Canada-1(Canada)</strong> under <strong class="bold">AWS</strong>. We click on the green <strong class="bold">Review</strong> button to go to the <span class="No-Break">next screen.</span></li>
<li>In the <strong class="bold">Confirm new instance</strong> screen, we review our <span class="No-Break">instance settings.</span></li>
<li>To create our instance, <strong class="source-inline">IoTProgrammingProjects</strong>, we click on the green <strong class="bold">Create </strong><span class="No-Break"><strong class="bold">instance</strong></span><span class="No-Break"> button.</span></li>
<li>To get more details on our instances, we click on the link in the <strong class="bold">Name</strong> field. In our example, this is the <span class="No-Break"><strong class="source-inline">IoTAlarmSystem</strong></span><span class="No-Break"> link.</span></li>
<li>Clicking the link provides our instance details, which we’ll use to connect our applications to the <span class="No-Break">MQTT server:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer137">
<img alt="Figure 7.12 – MQTT connection details" height="274" src="image/B21282_07_12.jpg" width="777"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – MQTT connection details</p>
<p>Having created our instance and obtained the details, we can now update the alarm module code from <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> to integrate with the new MQTT server and enhance <span class="No-Break">its functionality.</span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/>Modifying our alarm module code</h2>
<p>We will modify the code from <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> for our alarm module so that it will work with our more <a id="_idIndexMarker595"/>advanced second IoT button. Our revised code shifts from a public MQTTHQ server to the more dependable CloudAMQP <span class="No-Break">private server.</span></p>
<p>To support this, our new code adds <strong class="source-inline">USERNAME</strong>, <strong class="source-inline">MQTT_PASSWORD</strong>, and <strong class="source-inline">DEVICE_ID</strong> authentication parameters to enhance security. Another significant update is the <strong class="source-inline">ARMED</strong> mode, which lets us arm or disarm the system via MQTT. The modified <strong class="source-inline">motion_handler()</strong> function, when detecting motion, considers the <strong class="source-inline">ARMED</strong> status, sounding <span class="No-Break">the buzzer.</span></p>
<p>Finally, our revised code alters the LED feedback system. Beyond showing Wi-Fi and MQTT connection statuses, the LED also indicates if the alarm is armed by blinking <span class="No-Break">very slowly.</span></p>
<p>The new version of our IoT alarm module code may be found under the <strong class="source-inline">CloudAMQP</strong> folder of this chapter’s GitHub repository. To install the code onto the IoT alarm module, we follow the steps outlined in <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/>Building our Raspberry Pi Pico W IoT button</h2>
<p>The second IoT button features significant advancements in both the hardware and software <a id="_idIndexMarker596"/>as we make use of the Raspberry Pi Pico W. The Raspberry Pi Pico W and the M5Stack ATOM Matrix ESP32 both stand out as impressive microcontrollers. The Pico W is notable for its dual-core ARM Cortex-M0+ processor and Wi-Fi capabilities, whereas the ATOM Matrix brings both Wi-Fi and Bluetooth to the table with its ESP32 chip. However, considering our second IoT button project values computational strength and Wi-Fi above all, we will go with the Raspberry Pi <span class="No-Break">Pico W.</span></p>
<p>The inclusion of an OLED screen provides us with the status of the alarm, as well as acting as a monitor for our MQTT messages. Software-wise, the shift from a public MQTTHQ server to CloudAMQP’s private server improves reliability and security. This move reduces risks linked to <span class="No-Break">public servers.</span></p>
<h3>Looking at the components for our Pico W IoT button</h3>
<p>For the second version of our IoT button, we will be using an arcade-style button to send a <a id="_idIndexMarker597"/>message to arm the alarm module. An OLED screen will display MQTT messages sent back from the IoT alarm module. A <strong class="source-inline">buzzer</strong> message sent from the IoT alarm module will start a melody on the active buzzer that makes up the second version of the IoT button assembly. To disarm the IoT alarm module, we simply toggle a switch from its <span class="No-Break">current position.</span></p>
<p>In <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.13</em>, we see the components that make up our Raspberry Pi Pico W <span class="No-Break">IoT button:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<img alt="Figure 7.13 – IoT button V2 circuit arranged on a Pico GPIO expander" height="717" src="image/B21282_07_13.jpg" width="1470"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – IoT button V2 circuit arranged on a Pico GPIO expander</p>
<p>The components are <span class="No-Break">the following:</span></p>
<ul>
<li><em class="italic">A</em>: Single color LED with 220 <span class="No-Break">Ohm resistor</span></li>
<li><em class="italic">B</em>: SM-127 <span class="No-Break">active buzzer</span></li>
<li><em class="italic">C</em>: 0.96-inch <span class="No-Break">OLED screen</span></li>
<li><em class="italic">D</em>: 24 mm <span class="No-Break">arcade button</span></li>
<li><em class="italic">E</em>: GPIO expander board for the Raspberry Pi <span class="No-Break">Pico (optional)</span></li>
<li><em class="italic">F</em>: Raspberry Pi Pico WH for <span class="No-Break">development usage</span></li>
<li><em class="italic">G</em>: <span class="No-Break">SPST switch</span></li>
</ul>
<p>For development, we will use a Raspberry Pi Pico WH but switch to the non-header version <a id="_idIndexMarker598"/>for installation into the <span class="No-Break">custom case.</span></p>
<p class="callout-heading">Using a GPIO expander</p>
<p class="callout">The use of <a id="_idIndexMarker599"/>a GPIO expander (see <em class="italic">E</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.13</em>) is optional. To use the expander, female jumper connections are required. Using a GPIO expander offers the benefit of easily transitioning components to installations with the Pico WH in future projects, thanks to its female <span class="No-Break">jumper connections.</span></p>
<p>We will start our construction of the Raspberry Pi Pico W IoT button by examining the wiring diagram on a <span class="No-Break">standard breadboard.</span></p>
<h3>Wiring up our Raspberry Pi Pico W IoT button</h3>
<p>In <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.14</em>, we can <a id="_idIndexMarker600"/>see a wiring diagram for the Raspberry Pi Pico W IoT button. We will use a standard micro-USB cable connected to the USB port of the Pico WH to provide power. The 3.3 V pin from the Pico W is used to provide power to the rails of <span class="No-Break">the breadboard:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer139">
<img alt="Figure 7.14 – Raspberry Pi Pico W IoT button wiring diagram" height="887" src="image/B21282_07_14.jpg" width="1331"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Raspberry Pi Pico W IoT button wiring diagram</p>
<p>Now that <a id="_idIndexMarker601"/>our wiring is set, we’ll move on to the coding phase. We will start by loading the necessary packages we require for <span class="No-Break">our code.</span></p>
<h3>Setting up the required packages for our program</h3>
<p>The packages <a id="_idIndexMarker602"/>required to run our code for our Raspberry Pi Pico W IoT button are the <strong class="source-inline">micropython-umqtt.simple</strong> package and the <strong class="source-inline">micropython-ssd1306</strong> package. To load the packages onto our Raspberry Pi Pico W, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using the Thonny IDE, we click on <strong class="bold">Tools</strong> | <span class="No-Break"><strong class="bold">Manage packages</strong></span><span class="No-Break">.</span></li>
<li>In the search box, we type in the name of the package we would like to search for and then click on the <strong class="bold">Search on </strong><span class="No-Break"><strong class="bold">PyPI</strong></span><span class="No-Break"> button.</span></li>
<li>We then proceed to install the package by clicking on the <span class="No-Break"><strong class="bold">Install</strong></span><span class="No-Break"> button.</span></li>
</ol>
<p class="callout-heading">What to do if there are errors when loading packages?</p>
<p class="callout">In situations where there is an error when loading a package, we may simply copy the <strong class="source-inline">library</strong> folder from our GitHub repository to our Pico W. The folder may be found under <strong class="source-inline">Second IoT Button/library-files-from-pico-w</strong> from this chapter’s repository. See <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.15</em> for clarification on the file structure of the Raspberry Pi <span class="No-Break">Pico W.</span></p>
<ol>
<li value="4">Before <a id="_idIndexMarker603"/>proceeding to write our code, we should verify that the file structure on our Pico W looks like <span class="No-Break">the following:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer140">
<img alt="Figure 7.15 – Raspberry Pi Pico W library structure" height="198" src="image/B21282_07_15.jpg" width="718"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Raspberry Pi Pico W library structure</p>
<p>With our packages installed, it is now time to write our code. We will start with code to control the buzzer as it will be contained in a separate file from the <span class="No-Break">main code.</span></p>
<h3>Activating the buzzer</h3>
<p>In <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em>, we see a <strong class="source-inline">buzzer</strong> message sent from the IoT alarm module. In our rewrite of <a id="_idIndexMarker604"/>the IoT alarm module code, a <strong class="source-inline">buzzer</strong> message is sent out when the alarm has been armed and motion is detected from the PIR sensor. We will use this message in our Raspberry Pi Pico W IoT button to activate its alarm, although we will use it to play a melody through its speaker. As we did with the IoT alarm module code, we will use a separate file for our code to activate <span class="No-Break">the buzzer.</span></p>
<p>To do this, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use our Raspberry Pi or another operating system <span class="No-Break">for this.</span></li>
<li>We then activate the MicroPython environment on our Pico W by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>In a <a id="_idIndexMarker605"/>new tab, we enter the <span class="No-Break">following code:</span><pre class="source-code">
from machine import Pin, PWM
import utime
BUZZER_PIN = 16
buzzer = PWM(Pin(BUZZER_PIN))
def play_notes(
    notes = [
        (330, 0.5),  # E4 for 0.5 seconds
        (262, 0.5),  # C4 for 0.5 seconds
        (330, 0.5),  # E4 for 0.5 seconds
        (392, 0.5),  # G4 for 0.5 seconds
        (349, 0.5),  # F4 for 0.5 seconds
        (262, 1),  # C4 for 0.5 seconds
    ]
    ):
    for freq, duration in notes:
        buzzer.freq(freq)
        buzzer.duty_u16(32768)
        utime.sleep(duration)
    buzzer.duty_u16(0)</pre><p class="list-inset">Before <a id="_idIndexMarker606"/>we test out our code, let’s break <span class="No-Break">it down:</span></p><ol><li class="upper-roman">We start by importing <strong class="source-inline">Pin</strong> and <strong class="source-inline">PWM</strong> from the <strong class="source-inline">machine</strong> module, and the <span class="No-Break"><strong class="source-inline">utime</strong></span><span class="No-Break"> module.</span></li><li class="upper-roman">We set the <strong class="source-inline">BUZZER_PIN</strong> constant to pin number <strong class="source-inline">16</strong>, which corresponds to our wiring diagram (<span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">).</span></li><li class="upper-roman">We then initialize <strong class="source-inline">buzzer</strong> using the <strong class="source-inline">PWM</strong> class with the <span class="No-Break">defined pin.</span></li><li class="upper-roman">Our <strong class="source-inline">play_notes()</strong> function takes a default argument, <strong class="source-inline">notes</strong>, which is a list of tuples. Each tuple represents a frequency in Hertz (such as <strong class="source-inline">E4</strong>, <strong class="source-inline">C4</strong>, and so on) and a duration <span class="No-Break">in seconds.</span></li><li class="upper-roman">For each frequency-duration pair in the <strong class="source-inline">notes</strong> list, we do <span class="No-Break">the following:</span><ol><li class="lower-roman">We set the buzzer’s frequency to the <span class="No-Break">specified frequency.</span></li><li class="lower-roman">We activate the buzzer with a 50% duty cycle (<strong class="source-inline">duty_u16(32768)</strong>). This produces a square wave, defining the character of the sound emitted by <span class="No-Break">the buzzer.</span></li><li class="lower-roman">We wait for the specified duration <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">utime.sleep(duration)</strong></span><span class="No-Break">.</span></li></ol></li><li class="upper-roman">After playing all the notes, we turn off the buzzer (by setting its duty cycle <span class="No-Break">to 0).</span></li></ol></li> <li>To save the file, we click on <strong class="bold">File</strong> |<strong class="bold">Save as...</strong> from the drop-down menu. We save our file as <strong class="source-inline">buzzer.py</strong> to our Raspberry Pi <span class="No-Break">Pico W.</span></li>
<li>To test our code, we use the <strong class="bold">Shell</strong> in Thonny. We start by importing the <strong class="source-inline">play_notes()</strong> function from our new <span class="No-Break">buzzer script:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer141">
<img alt="Figure 7.16 – Importing the play_notes() function" height="181" src="image/B21282_07_16.jpg" width="873"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Importing the play_notes() function</p>
<ol>
<li value="6">To <a id="_idIndexMarker607"/>activate our buzzer, we simply call the function and <span class="No-Break">hit </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer142">
<img alt="Figure 7.17 – Running the play_notes() function" height="177" src="image/B21282_07_17.jpg" width="801"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17 – Running the play_notes() function</p>
<ol>
<li value="7">We should hear our buzzer play its default melody. To test our function further, let’s send <strong class="source-inline">[(262, 1),(330, 2),(392, 0.5),(262, 1)]</strong> notes <span class="No-Break">to it:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer143">
<img alt="Figure 7.18 – Playing a new melody with the play_notes() function" height="182" src="image/B21282_07_18.jpg" width="907"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18 – Playing a new melody with the play_notes() function</p>
<ol>
<li value="8">We should notice that a different melody plays from <span class="No-Break">our buzzer.</span></li>
</ol>
<p>With our buzzer code in place, it’s now time to focus on the main code that will power our Raspberry Pi Pico W <span class="No-Break">IoT button.</span></p>
<h3>Coding the primary functionality for our IoT button</h3>
<p>After finalizing the buzzer script, we’re ready to develop the main code for our enhanced <a id="_idIndexMarker608"/>IoT button. This new iteration can arm the IoT alarm module and features a display screen. The screen indicates the alarm module’s status (either armed or disarmed) and presents the latest MQTT message from our <span class="No-Break">CloudAMQP server.</span></p>
<p>When the IoT alarm module triggers, our IoT button’s buzzer provides audible feedback. It activates upon receiving a <strong class="source-inline">buzzer</strong> message. We use the switch on our IoT button assembly as a toggle to disarm the alarm on our IoT <span class="No-Break">alarm module.</span></p>
<p>To create the code for our enhanced IoT button, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use our Raspberry Pi or another operating system <span class="No-Break">for this.</span></li>
<li>We then activate the MicroPython environment on our Pico W by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>We will start with our imports. In a new tab, we enter the <span class="No-Break">following code:</span><pre class="source-code">
from machine import Pin, I2C
import utime
import network
from umqtt.simple import MQTTClient
from buzzer import play_notes
import ssd1306
import _thread</pre></li> <li>We then define variables with values obtained from our CloudAMQP account (<span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">):</span><pre class="source-code">
SSID = "MyWiFiNetwork"
WIFI_PASSWORD = "xxxxxxxxxxxxx"
led = machine.Pin(15, machine.Pin.OUT)
button = Pin(0, Pin.IN, Pin.PULL_UP)
switch = Pin(1, Pin.IN, Pin.PULL_UP)
previous_switch_state = switch.value()
MQTT_SERVER = "codfish.rmq.cloudamqp.com"
MQTT_PORT = 1883
USERNAME = "xxxxxx"
PASSWORD = "xxxxxx"
DEVICE_ID = "IoTAlarmSystem"
last_message = ""
i2c = I2C(0, scl=Pin(9), sda=Pin(8))
display = ssd1306.SSD1306_I2C(128, 64, i2c)
mqtt_client = None</pre></li> <li>The <strong class="source-inline">on_message_received()</strong> method serves as our MQTT client’s callback. By <a id="_idIndexMarker609"/>using the <strong class="source-inline">global</strong> keyword with <strong class="source-inline">last_message</strong>, we ensure updates to this variable are reflected globally throughout <span class="No-Break">the code:</span><pre class="source-code">
def on_message_received(topic, msg):
    global last_message
    print("Received:", topic, msg)
    if topic == b"IoTAlarm":
        last_message = msg.decode()
        if msg == b"buzzer":
            play_notes()</pre></li> <li>The <strong class="source-inline">connect_wifi()</strong> function initializes and activates Pico W’s Wi-Fi. If not connected, it attempts to join the network using a predefined SSID and password. Meanwhile, an LED blinks to indicate the connection process. Upon successful <a id="_idIndexMarker610"/>connection, the LED stays on, and the device’s IP address <span class="No-Break">is displayed:</span><pre class="source-code">
def connect_wifi():
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    if not wlan.isconnected():
        print('Connecting to WiFi...')
        wlan.connect(SSID, WIFI_PASSWORD)
        while not wlan.isconnected():
            led.on()
            utime.sleep(0.5)
            led.off()
            utime.sleep(0.5)
        led.on()
        print('WiFi connected, IP:', wlan.ifconfig()[0])</pre></li> <li>The <strong class="source-inline">connect_mqtt()</strong> function tries to establish an MQTT connection using predefined <a id="_idIndexMarker611"/>server details. If successful, it sets a message callback and subscribes to the <strong class="source-inline">IoTAlarm</strong> topic. If the connection fails, the function waits for 5 seconds <span class="No-Break">and retries:</span><pre class="source-code">
def connect_mqtt():
    global mqtt_client
    while mqtt_client is None:
        try:
            print('Trying to connect to MQTT Server...')
            mqtt_client = MQTTClient(
                DEVICE_ID, MQTT_SERVER, MQTT_PORT,
                USERNAME, PASSWORD
            )
            mqtt_client.set_callback(
                          on_message_received)
            mqtt_client.connect()
            mqtt_client.subscribe(b"IoTAlarm")
            print('MQTT connection established and subscribed to IoTAlarm')
        except:
            mqtt_client = None
            print('Failed to connect, retrying...')
            utime.sleep(5)</pre></li> <li>The <strong class="source-inline">display_status()</strong> function continuously updates the display every 5 seconds. It shows the MQTT connection status at the top, the <strong class="source-inline">arm</strong>/<strong class="source-inline">disarm</strong> status <a id="_idIndexMarker612"/>in the middle, and the last received MQTT message at the bottom. If connected to MQTT, <strong class="source-inline">MQTT Connected</strong> is displayed; otherwise, <strong class="source-inline">MQTT waiting</strong> is shown. We run this method in a separate thread in <span class="No-Break">our code:</span><pre class="source-code">
def display_status():
    global last_message
    is_armed = False
    while True:
        display.fill(0)
        if mqtt_client:
            msg = "MQTT Connected"
        else:
            msg = "MQTT waiting"
        display.text(msg, 0, 0)
        if last_message == "arm":
            is_armed = True
        elif last_message == "disarm":
            is_armed = False
        if is_armed:
            display.text("Status: Armed", 0, 20)
        else:
            display.text("Status: Disarmed", 0, 20)
        display.text("Msg: " + last_message, 0, 40)
        display.show()
        utime.sleep(5)</pre></li> <li>The <strong class="source-inline">main()</strong> function initiates Wi-Fi and MQTT connections and continuously checks the button and switch states. If the button is pressed for over a second, an <strong class="source-inline">arm</strong> message is published via MQTT. If the switch state changes, a <strong class="source-inline">disarm</strong> message is sent. The function also checks for incoming MQTT messages. If an error <a id="_idIndexMarker613"/>occurs while checking for messages, the error is printed, and the system waits for 5 seconds before resuming checks. The system waits 0.1 seconds between loop iterations to optimize performance. We start by defining the <strong class="source-inline">main()</strong> function <span class="No-Break">and variables:</span><pre class="source-code">
def main():
    global last_message, previous_switch_state
    connect_wifi()
    connect_mqtt()
    button_start_time = None</pre></li> <li>Then, we define an infinite loop and check to see if the main button has been pressed for a second (<strong class="source-inline">1000</strong> ms) <span class="No-Break">or greater:</span><pre class="source-code">
    while True:
        if button.value() == 0:
            if button_start_time is None:
                button_start_time = utime.ticks_ms()
        else:
            if button_start_time is not None:
                button_elapsed_time = utime.ticks_diff(utime.ticks_ms(), button_start_time)
                if button_elapsed_time &gt;= 1000:
                    mqtt_client.publish(
                        b"IoTAlarm",
                        b"arm"
                    )
                    last_message = "arm"
                button_start_time = None
        current_switch_state = switch.value()</pre></li> <li>Our code then sends a <strong class="source-inline">disarm</strong> message if the current switch state is not equal to <a id="_idIndexMarker614"/>the previous switch state. This conditional check allows us to use our switch as a toggle and not have a defined on or <span class="No-Break">off state:</span><pre class="source-code">
if current_switch_state != previous_switch_state:
            mqtt_client.publish(
                b"IoTAlarm",
                b"disarm"
            )
            last_message = "disarm"
        previous_switch_state = current_switch_state
        try:
            mqtt_client.check_msg()
        except Exception as e:
            print("Error checking MQTT message:", str(e))
            utime.sleep(5)
        utime.sleep(0.1)</pre></li> <li>We then initialize a new thread to run the <strong class="source-inline">display_status()</strong> function concurrently. By using threading, it allows the <strong class="source-inline">display_status()</strong> function to operate independently and simultaneously with other parts of the program, ensuring <a id="_idIndexMarker615"/>continuous updates to the display status without hindering or waiting for <span class="No-Break">other processes:</span><pre class="source-code">
_thread.start_new_thread(display_status, ())</pre></li> <li>Finally, we call the <strong class="source-inline">main()</strong> function, which directs the program’s core activities — handling connections, button inputs, and managing <span class="No-Break">MQTT messages:</span><pre class="source-code">
main()</pre></li> <li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. We save our file as <strong class="source-inline">main.py</strong> to our Raspberry Pi <span class="No-Break">Pico W.</span></li>
</ol>
<p>With our main code written, it is time to test it. </p>
<h3>Running our enhanced IoT button</h3>
<p>Executing the code on our Raspberry Pi Pico W IoT button allows it to interact with the IoT alarm module. The button can arm or disarm the module. We will use the <strong class="bold">MQTT Explorer</strong> app in <a id="_idIndexMarker616"/>Windows to monitor real-time MQTT messages, as well as send messages to test our enhanced <span class="No-Break">IoT button.</span></p>
<p>We will start <a id="_idIndexMarker617"/>by sending messages from the MQTT Explorer app. To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>From the Microsoft Store in Windows, we search for the MQTT <span class="No-Break">Explorer app:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer144">
<img alt="" height="765" role="presentation" src="image/B21282_07_19.jpg" width="1061"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19 – MQTT Explorer in the Microsoft Store</p>
<ol>
<li value="2">We run  <strong class="source-inline">main.py</strong> on our Raspberry Pi Pico W IoT button application by either clicking on the <strong class="bold">Run</strong> button in Thonny or by plugging our Pico W into a USB <span class="No-Break">power supply.</span></li>
<li>Using MQTT Explorer, we create a connection called <strong class="source-inline">IoTAlarmSystem</strong> with the MQTT <a id="_idIndexMarker618"/>server credentials from <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer145">
<img alt="Figure 7.20 – Creating an MQTT connection using MQTT Explorer" height="448" src="image/B21282_07_20.jpg" width="857"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20 – Creating an MQTT connection using MQTT Explorer</p>
<ol>
<li value="4">To send a message using MQTT Explorer, we type in <strong class="source-inline">IoTAlarm</strong> for the topic and <strong class="source-inline">test</strong> for the message before clicking on the <span class="No-Break"><strong class="bold">PUBLISH</strong></span><span class="No-Break"> button:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer146">
<img alt="Figure 7.21 – Sending an MQTT message" height="658" src="image/B21282_07_21.jpg" width="1033"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.21 – Sending an MQTT message</p>
<ol>
<li value="5">We should <a id="_idIndexMarker619"/>observe that a <strong class="source-inline">test</strong> message appears on the OLED screen of our IoT <span class="No-Break">button circuit.</span></li>
<li>We then press and hold the arcade pushbutton on the IoT button circuit for more than <span class="No-Break">a second.</span></li>
<li>We should observe an <strong class="source-inline">arm</strong> message on the MQTT <span class="No-Break">Explorer app.</span></li>
<li>We should also observe the LED on the IoT alarm module start blinking every 5 seconds. This indicates that the IoT alarm module <span class="No-Break">is armed.</span></li>
<li>We test the IoT alarm module by waving our hands in front of the PIR sensor. We should observe that the alarm <span class="No-Break">goes off.</span></li>
<li>We should observe that after a short time, the alarm on the enhanced IoT button circuit <span class="No-Break">goes off.</span></li>
<li>To disarm the alarm, we toggle the switch from its current position. This should result in the buzzer turning off when motion is detected by the PIR sensor. This should also disable the buzzer on the enhanced <span class="No-Break">IoT button.</span></li>
</ol>
<p>We should <a id="_idIndexMarker620"/>congratulate ourselves as we have successfully built a basic IoT alarm system! For the final section of this chapter, we will install the components into the custom <span class="No-Break">3D-printed case.</span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor123"/>Installing the components in a custom case</h2>
<p>Wiring our components and running our code is an exciting step. Yet, housing them in a custom case <a id="_idIndexMarker621"/>elevates our project and allows us to use our application for practical purposes. A custom case offers not only protection but also the versatility to install our advanced IoT button in any <span class="No-Break">desired location.</span></p>
<p>In <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>, we view the components of our custom case, all 3D printed. Parts <em class="italic">A</em> and <em class="italic">B</em> were produced <a id="_idIndexMarker622"/>using a <strong class="bold">Fused Deposition Modeling</strong> (<strong class="bold">FDM</strong>) printer, while <em class="italic">C</em> and <em class="italic">D</em> utilized a liquid resin printer. While either printer type is suitable, FDM printing requires careful part orientation on the print bed to account for <span class="No-Break">layer-line strength:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<img alt="Figure 7.22 – Custom case for enhanced IoT button" height="620" src="image/B21282_07_22.jpg" width="1363"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.22 – Custom case for enhanced IoT button</p>
<p>The parts <a id="_idIndexMarker623"/>of our custom case are broken down <span class="No-Break">as follows:</span></p>
<ul>
<li><span class="No-Break"><em class="italic">A</em></span><span class="No-Break">: Shell</span></li>
<li><span class="No-Break"><em class="italic">B</em></span><span class="No-Break">: Backplate</span></li>
<li><span class="No-Break"><em class="italic">C</em></span><span class="No-Break">: Hook</span></li>
<li><em class="italic">D</em>: Mounting bracket wall <span class="No-Break">side mount</span></li>
</ul>
<p>All parts may be found in the <strong class="source-inline">Pico Button</strong> subfolder of the <strong class="source-inline">Build Files</strong> folder in this chapter’s GitHub repository. The mounting screws and LED holder are <span class="No-Break">not shown.</span></p>
<p class="callout-heading">Printing the split stand with FDM printers</p>
<p class="callout">The split stand in the SenseHAT case files (<strong class="source-inline">Build Files</strong> folder, <a href="B21282_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> repository) is ideal for FDM printing. By splitting and printing each half on its side, the stand gains significant strength. An accompanying base is <span class="No-Break">also provided.</span></p>
<p>To install <a id="_idIndexMarker624"/>the components into our custom case, we follow the steps in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.23</em></span><span class="No-Break">:</span></p>
<ol>
<li>We start by installing the buzzer (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.13</em>) into the shell (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>) with two M5 10 mm bolts and two M5 nuts (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 1</em></span><span class="No-Break">).</span></li>
<li>Then (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.23</em>, <em class="italic">Step 2</em>), we install the switch (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.13</em>, <em class="italic">G</em>) and arcade pushbutton (see <em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.13</em>) into their appropriate holes in the shell (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.22</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer148">
<img alt="Figure 7.23 – Constructing the case for the enhanced IoT button" height="904" src="image/B21282_07_23.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.23 – Constructing the case for the enhanced IoT button</p>
<ol>
<li value="3">Using an <a id="_idIndexMarker625"/>LED holder, we install the LED with 220 Ohm resistor (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.13</em>) into the shell (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>) using the left-side hole (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.23</em>,<em class="italic"> </em><span class="No-Break"><em class="italic">Step 3</em></span><span class="No-Break">).</span></li>
<li>We secure the OLED screen (see <em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.13</em>) into the shell (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>) using 4 M2 5 mm screws or glue from a hot glue gun (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.23</em>,<em class="italic"> </em><span class="No-Break"><em class="italic">Step 4</em></span><span class="No-Break">).</span></li>
<li>Then (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.23</em>, <em class="italic">Step 4</em>), we wire the components to a new Raspberry Pi <span class="No-Break">Pico W.</span></li>
<li>We then install the hook (see <em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>) onto the back plate (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>) using two M2 5 mm screws (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 5</em></span><span class="No-Break">).</span></li>
<li>We secure the Pico W onto the back plate (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>) with four M2 5 mm screws (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 6</em></span><span class="No-Break">).</span></li>
<li>Then (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.23</em>, <em class="italic">Step</em><em class="italic"> 7</em>), we use four M3 10 mm bolts to secure the back plate (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>) to the shell (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.13</em></span><span class="No-Break">).</span></li>
<li>With the <a id="_idIndexMarker626"/>back plate (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>) secured to the shell (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>), we connect the assembly to the mounting bracket (see <em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.22</em>) using an M5 20 mm bolt and <span class="No-Break">M5 nut.</span></li>
<li>Using the steps from the section, <em class="italic">Coding the primary functionality for our IoT button</em>, we install the packages and client code for our enhanced <span class="No-Break">IoT button.</span></li>
</ol>
<p>With the components securely installed, we can now position our Raspberry Pi Pico W IoT button in any desired location, be it a home, office, or workshop setting. Our design not only serves our primary alarm system purpose but also makes it adaptable for a multitude of other applications, expanding its utility and offering potential for innovative integrations in many <span class="No-Break">different scenarios.</span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/>Summary</h1>
<p>In this chapter, we explored IoT buttons, starting with a description of what they are and where they are used. We then explored various technologies that we could use to build an <span class="No-Break">IoT button.</span></p>
<p>We then proceeded to build our first IoT button using a public MQTT service and an M5Stack ATOM Matrix. We were able to connect our IoT button to the IoT alarm module we built in <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">.</span></p>
<p>From there, we upgraded our MQTT server to a private one using CloudAMQP. We did so for reliability and security reasons as we started to build out our IoT alarm system more. We upgraded the code sitting on our IoT alarm module before building our second IoT button using a Raspberry Pi Pico W and <span class="No-Break">various components.</span></p>
<p>We finished the chapter by installing the components of our second (enhanced) IoT button into a 3D-printed case. Doing so transformed our circuit from an educational tool to a working device suitable for deployment in <span class="No-Break">commercial settings.</span></p>
<p>In the next chapter, we will continue to build our IoT alarm system by going back to the Raspberry Pi, where we will build a <span class="No-Break">security dashboard.</span></p>
</div>
</div></body></html>