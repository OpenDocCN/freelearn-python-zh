- en: Chapter 3. Enhancing Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned a lot about day-to-day image processing.
    We accomplished the learning objective of performing basic image manipulation
    by working on several examples and small projects. In this chapter, we will move
    a step further by learning how to add special effects to an image. The special
    effects added to the image serve several purposes. These not only give a pleasing
    appearance to the image but may also help you to understand important information
    presented by the image.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to adjust brightness and contrast levels of an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add code to selectively modify the color of an image and create gray scale images
    and negatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use PIL functionality to combine two images together and add transparency effects
    to the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply various image-enhancement filters to an image to achieve effects such
    as smoothing, sharpening, embossing, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undertake a project to develop a tool to add a watermark or text or a date stamp
    to an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and download prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The installation prerequisites for this chapter are same as the ones in [Chapter
    2](ch02.html "Chapter 2. Working with Images"), *Working with Images*. Please
    refer to that chapter for further details.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to download all the images required for this chapter from the
    Packt website at [http://www.packtpub.com/](http://www.packtpub.com/). We will
    be using these images throughout this chapter in the image processing code. Additionally,
    please download the PDF file, `Chapter 3 Supplementary Material.pdf` from Packt
    website. This is very important if you are reading a hard copy of this book which
    is printed in black and white. In the upcoming sections such as "Tweaking Colors",
    we compare the images before and after processing. In the black and white edition,
    you won't be able to see the difference between the compared images. For example,
    the effects such as changed image color, modified contrast, and so on, won't be
    noticeable. The PDF file contains all these image comparisons. So please keep
    this file handy while working on the examples in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting brightness and contrast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One often needs to tweak the brightness and contrast level of an image. For
    example, you may have a photograph that was taken with a basic camera, when there
    was insufficient light. How would you correct that digitally? The brightness adjustment
    helps make the image brighter or darker whereas the contrast adjustments emphasize
    differences between the color and brightness level within the image data. The
    image can be made lighter or darker using the `ImageEnhance` module in PIL. The
    same module provides a class that can auto-contrast an image.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - adjusting brightness and contrast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn how to modify the image brightness and contrast. First, we will
    write code to adjust brightness. The `ImageEnhance` module makes our job easier
    by providing `Brightness` class.
  prefs: []
  type: TYPE_NORMAL
- en: Download image `0165_3_12_Before_BRIGHTENING.png` and rename it to `Before_BRIGHTENING.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On line 6 in the code snippet, we created an instance of the class `Brightness`.
    It takes `Image` instance as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Line 7 creates a new image `bright` by using the specified `brightness` value.
    A value between `0.0` and less than `1.0` gives a darker image, whereas a value
    greater than `1.0` makes it brighter. A value of `1.0` keeps the brightness of
    the image unchanged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original and resultant image are shown in the next illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comparison of images before and after brightening.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - adjusting brightness and contrast](img/0165_3_1.jpg)![Time
    for action - adjusting brightness and contrast](img/0165_3_2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let's move on and adjust the contrast of the brightened image. We will append
    the following lines of code to the code snippet that brightened the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Thus, similar to what we did to brighten the image, the image contrast was tweaked
    by using the `ImageEnhance.Contrast` class. A contrast value of `0.0` creates
    a black image. A value of `1.0` keeps the current contrast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resultant image is compared with the original in the following illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: As mentioned in the *Installation and Download Prerequisites* section,
    the images compared in the following illustration will appear identical if you
    are reading a hard copy of this book. Please download and refer to the supplementary
    PDF file `Chapter 3 Supplementary Material.pdf`. Here, the color images are provided,
    which will help you see the difference.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The original image with the image displaying the increasing contrast.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Time for action - adjusting brightness and contrast](img/0165_3_3.jpg)![Time
    for action - adjusting brightness and contrast](img/0165_3_4.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In the preceding code snippet, we were required to specify a contrast value.
    If you prefer PIL for deciding an appropriate contrast level, there is a way to
    do this. The `ImageOps.autocontrast` functionality sets an appropriate contrast
    level. This function normalizes the image contrast. Let's use this functionality
    now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The highlighted line in the code is where contrast is automatically set. The
    `autocontrast` function computes histogram of the input image. The `cutoff` argument
    represents the percentage of lightest and darkest pixels to be trimmed from this
    histogram. The image is then remapped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the classes and functionality in `ImageEnhance` module, we learned how
    to increase or decrease the brightness and the contrast of the image. We also
    wrote code to auto-contrast an image using functionality provided in the `ImageOps`
    module. The things we learned here will be useful in the upcoming sections in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful operation performed on the image is adjusting the colors within
    an image. The image may contain one or more bands, containing image data. The
    `image` mode contains information about the depth and type of the image pixel
    data. The most common modes we will use in this chapter are `RGB` (true color,
    3x8 bit pixel data), `RGBA` (true color with transparency mask, 4x8 bit) and `L`
    (black and white, 8 bit).
  prefs: []
  type: TYPE_NORMAL
- en: In PIL, you can easily get the information about the bands data within an image.
    To get the name and number of bands, the `getbands()` method of the class `Image`
    can be used. Here, `img` is an instance of class `Image`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Time for action - swap colors within an image!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand some basic concepts, let's write code that just swaps the image
    band data.
  prefs: []
  type: TYPE_NORMAL
- en: Download the image `0165_3_15_COLOR_TWEAK.png` and rename it as `COLOR_TWEAK.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's analyze this code now. On line 2, the `Image` instance is created as usual.
    Then, we change the `mode` of the image to `RGBA`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we should check if the image already has that mode or if this conversion
    is possible. You can add that check as an exercise!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, the call to `Image.split()` creates separate instances of `Image` class,
    each containing a single band data. Thus, we have four `Image` instances `r, g,
    b`, and `alpha` corresponding to red, green, and blue bands, and the alpha channel
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code in line 6 does the main image processing. The first argument that `Image.merge`
    takes `mode` as the first argument whereas the second argument is a tuple of image
    instances containing band information. It is required to have same size for all
    the bands. As you can notice, we have swapped the order of band data in `Image`
    instances `r` and `g` while specifying the second argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original and resultant image thus obtained are compared in the next illustration.
    The color of the flower now has a shade of green and the grass behind the flower
    is rendered with a shade of red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in the *Installation and Download Prerequisites* section, the images
    compared in the following illustration will appear identical if you are reading
    a hard copy of this book. Please download and refer to the supplementary PDF file
    `Chapter 3 Supplementary Material.pdf`. Here, the color images are provided that
    will help you see the difference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Original (left) and the color swapped image (right).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - swap colors within an image!](img/0165_3_6.jpg)![Time for
    action - swap colors within an image!](img/0165_3_5.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We accomplished creating an image with its band data swapped. We learned how
    to use PIL's `Image.split()` and `Image.merge()` to achieve this. However, this
    operation was performed on the whole image. In the next section, we will learn
    how to apply color changes to a specific color region.
  prefs: []
  type: TYPE_NORMAL
- en: Changing individual image band
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw how to change the data represented by the whole
    band. As a result of this band swapping, the color of the flower was changed to
    a shade of green and the grass color was rendered as a shade of red. What if we
    just want to change the color of the flower and keep the color of the grass unchanged?
    To do this, we will make use of `Image.point` functionality along with `Image.paste`
    operation discussed in depth in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that we need to be careful in specifying the color region that
    needs to be changed. It may also depend on the image. Sometimes, it will select
    some other regions matching the specified color range, which we don't want.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - change the color of a flower
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make use of the same flower image used in the previous section. As mentioned
    earlier, our task is to change the color of the flower while keeping the grass
    color unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Add this code in a Python source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lines 1 to 5 remain the same as seen earlier. On line 5, we split the original
    image, creating four `Image` instances, each holding a single band data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new `Image` instance 'selection' is created on line 6\. This is an important
    operation that holds the key to selectively modify color! So let's see what this
    line of code does. If you observe the original image, the flower region (well,
    most of it) is rendered with a shade of red color. So, we have called the `point(function)`
    method on `Image` instance `r`. The `point` method takes a single function and
    an argument maps the image through this function. It returns a new `Image` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What does this lambda function on line 6 do? Internally, PIL''s `point` function
    does something of this sort:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, function is nothing but the lambda function. The no_of_bands
    for the image is 1\. Thus, line 6 is used to select a region where the red value
    is greater than 120\. The lst is a list which, in this case has the first 120
    values as False whereas the remaining values as 150\. The value of 150 plays a
    role in determining the final color when we perform the paste operation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The image mask thus created after the application of `point` operation is shown
    in the following illustration. The white region in this image represents the region
    captured by the `point` operation that we just performed. Only the white region
    will undergo change when we perform `paste` operation next.![Time for action -
    change the color of a flower](img/0165_3_7.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 8, we perform a `paste` operation discussed in the last chapter. Here,
    the image `g` is pasted onto image `r` using mask `selection`. As a result, the
    band data of image `r` is modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, a new `Image` instance is created using the `merge` operation, by making
    use of the individual `r, g, b`, and `alpha` image instances containing the new
    band information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original and final processed images are compared in the next illustration.
    The new flower color looks as cool as the original color, doesn't it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in the *Installation and download prerequisites* section, the images
    compared in the following illustration will appear identical if you are reading
    a hard copy of this book. Please download and refer to the supplementary PDF file
    `Chapter 3 Supplementary Material.pdf`. The color images are provided that will
    help you see the difference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - change the color of a flower](img/0165_3_8.jpg)![Time for
    action - change the color of a flower](img/0165_3_9.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We worked out an example that modified a selective color region. Individual
    image band data was processed to accomplish this task. With the help of `point,
    paste`, and `merge` operations in PIL's `Image` module, we accomplished changing
    the color of the flower in the provided image.
  prefs: []
  type: TYPE_NORMAL
- en: Gray scale images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to give a nostalgic effect to an image, one of the many things
    that you can do is to convert it to gray scale. There is more than one way to
    create a gray scale image in PIL. When the mode is specified as `L`, the resultant
    image is gray scale. The basic syntax to convert color images to black and white
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we can use functionality provided in the `ImageOps` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are creating the image from scratch, the syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The following illustration shows the original and the converted gray scale images
    created using one of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please download and refer to the supplementary PDF file `Chapter 3 Supplementary
    Material.pdf`. The color images are provided that will help you see the difference
    between the following images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Original and gray scale images of a bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Gray scale images](img/0165_3_11.jpg)![Gray scale images](img/0165_3_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cook up negatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a negative of an image is straightforward. We just need to invert each
    color pixel. Therefore, if you have a color `x` at a pixel, the negative image
    will have (255 `x)` at that pixel. The `ImageOps` module makes it very simple.
    The following line of code creates a negative of an image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: Original image (left) and its negative (right).
  prefs: []
  type: TYPE_NORMAL
- en: '![Cook up negatives](img/0165_3_12.jpg)![Cook up negatives](img/0165_3_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever wished to see yourself in a family photo, taken at a time when
    you were not around? Or what if you just want to see yourself at the top of Mount
    Everest at least in a picture? Well, it is possible to do this digitally, using
    the functionality provided in PIL such as blending, composite image processing,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to blend images together. As the name suggests,
    blending means mixing two compatible images to create a new image. The `blend`
    functionality in PIL creates a new image using two input images of the same `size`
    and `mode`. Internally, the two input images are interpolated using a constant
    value of alpha.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the PIL documentation, it is formulated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this formula, it is clear that `alpha = 1.0` will make the blended
    image the same as 'n_image2 whereas `alpha = 0.0` returns `in_image1` as the blended
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - blending two images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the combined effect of two images mixed together makes a big impact
    compared to viewing the same images differently. Now it's time to give way to
    your imagination by blending two pictures together. In this example, our resultant
    image shows birds flying over the Mackinac bridge in Michigan. However, where
    did they come from? The birds were not there in the original image of the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the following files from Packt website: `0165_3_28_BRIDGE2.png` and
    `0165_3_29_BIRDS2.png`. Rename these files as `BRIDGE2.png` and `BIRDS2.png` respectively.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following code in a Python source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next illustration shows the two images before blending, represented by `img1`
    and `img2` in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Individual images of a bridge and flying birds, before blending.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - blending two images](img/0165_3_14.jpg)![Time for action
    - blending two images](img/0165_3_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The lines 3 to 7 open the two input images to be blended. Notice that we have
    converted both the images `RGBA`. It need not be necessarily `RGBA` mode. We can
    specify the modes such as 'RGB' or 'L'. However, it is required to have both the
    images with same `size` and `mode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The images are blended on line 9 using the `Image.blend` method in PIL. The
    first two arguments in the `blend` method are two `Image` objects representing
    the two images to be blended. The third argument defines the transparency factor
    `alpha`. In this example, the image of the bridge is the main image we want to
    focus on. Thus, the factor `alpha` is defined such that more transparency is applied
    to the image of the flying birds while creating the final image. The `alpha` factor
    can have a value between `0.0` to `1.0`. Note that, while rendering the output
    image, the second image, `img2`, is multiplied by this `alpha` value whereas the
    first image is multiplied by `1 - alpha`. This can be represented by the following
    equation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Thus, if we select an alpha factor of, for instance, 0.8, it means that the
    birds will appear more opaque compared to the bridge. Try changing the alpha factor
    to see how it changes the resultant image. The resultant image with alpha = 0.3
    is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blended image showing birds flying over a bridge.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - blending two images](img/0165_3_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The picture appears a bit dull due to the transparency effect applied while
    creating the image. If you convert the input images to `mode L`, the resultant
    image will look better however, it will be rendered as gray scale. This is shown
    in the next illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blended gray scale image when both the input images have mode L.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - blending two images](img/0165_3_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blending is an important image enhancement feature. With the help of examples,
    we accomplished creating blended images. We learned using the `Image.blend` method
    and applied the transparency factor `alpha` to achieve this task. The technique
    learned in this chapter will be very useful throughout this chapter. In the next
    section, we will apply the blending technique to create a transparent image.
  prefs: []
  type: TYPE_NORMAL
- en: Creating transparent images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to blend two images together. In this
    section, we will go one step further and see how the same `blend` functionality
    can be used to create a transparent image! The images with mode RGBA define an
    `alpha` band. The transparency of the image can be changed by tweaking this band
    data. `Image.putalpha()` method allows defining new data for the `alpha` band
    of an image. We will see how to perform point operation to achieve the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - create transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write a few lines of code that add the transparency effects to an input
    image.
  prefs: []
  type: TYPE_NORMAL
- en: We will use one of the images used in [Chapter 2](ch02.html "Chapter 2. Working
    with Images"). Download `0165_3_25_SMILEY.png` and rename it to `SMILEY.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, the `addTransparency()` function takes the `img` instance as
    input and returns a new image instance with the desired level of transparency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's see how this function works. On line 4, we first convert the image
    mode to `RGBA`. As discussed in an earlier section, you can add a conditional
    here to see if the image is already in the `RGBA` mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create a new `Image` class instance, `image_blender`, using the `Image.new`
    method. It has the same size and mode as the input image. The third argument represents
    the color. Here, we specify the transparency as `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 6, two images, `img` (input image) and `img_blender`, are blended together
    by applying a constant `alpha` value. The function then returns this modified
    `Image` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original image and the one with the transparency effect are compared. The
    images are the screenshots of the images opened in the GIMP editor. This is done
    so that you clearly understand the effect of transparency. The checkered pattern
    in these images represents the canvas. Notice how the canvas appears in the transparent
    image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is another simple way to add transparency to an image, using the `Image.point`
    functionality! Enter the following code in a Python source file and execute it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this new code, we split the original image into four new image instance,
    each having one of the image band data (r, `g, b`, or `alpha)`. Note that we are
    assuming here that the mode of the image is `RGBA`. If it is not, you need to
    convert this image to RGBA! As an exercise, you can add that check in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, on line 4, the `Image.point` method is called. The `lambda` function operates
    on the `alpha` band data. It sets the value as `178`. This is roughly equal to
    the `alpha` factor of 0.7 that we set earlier. It is computed here as `int(255*0.7)
    )`. In the *Changing individual image band* section, where we learned modifying
    colors within images, the point operation was thoroughly discussed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 5, we put back the new `alpha` band data in `img`. The resultant images
    using `blend` and `point` functionality are shown in the next illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Image before and after adding transparency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - create transparency](img/0165_3_18.jpg)![Time for action
    - create transparency](img/0165_3_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We accomplished adding transparency effect to an image. This is a very useful
    image enhancement that we need from time to time. We learned how to create a transparent
    image using two different techniques, namely, using `Image.blend` functionality
    and `Image.point` operation. The knowledge gained in this section will be applied
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Making composites with image mask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have already seen how to blend two images together. It was done
    using the `Image.blend` operation where the two input images were blended by using
    a constant `alpha` transparency factor. In this section, we will learn another
    technique to combine two images together. Here, instead of a constant `alpha`
    factor, an image instance that defines the transparency mask is used as the third
    argument. Another difference is that the input images need not have the same `mode`.
    For instance, the first image can be with mode `L` and the second with mode `RGBA`.
    The syntax to create composite images is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the arguments to the composite method are `Image` instances. The mask
    is specified as `alpha`. The mode for mask image instance can be `1, L`, or `RGBA`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - making composites with image mask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will mix the same two images blended in another section. Just to try out
    something different, in the composite image, we will focus on the flying birds
    instead of the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same set of input images as used in the *Blending* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code until line 7 is identical to the one illustrated in the blending example.
    Note that the two input images need not have the same `mode`. On line 10, the
    `Image.point` method is called. The `lambda` function operates on the `alpha`
    band data. The code on lines 9 and 10 is similar to that illustrated in the section
    *Creating Transparent Images*. Please refer to that section for further details.
    The only difference is that the pixel value is set as `204`. This modifies the
    band data in the image instance `alpha`. This value of `204` is roughly equivalent
    to the `alpha` factor of `0.7` if the image were to be blended. What this implies
    is the bridge will have a fading effect and the flying birds will appear prominently
    in the composite image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One thing you will notice here is we are not putting the modified `alpha` band
    data back in `img2`. Instead, on line 12, the composite image is created using
    the mask as `alpha`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resultant composite image is shown in the next illustration with emphasis
    on the image of the flying birds.![Time for action - making composites with image
    mask](img/0165_3_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to create an image combining two images, using an `alpha` mask.
    This was accomplished by using `Image.composite` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project: Watermark Maker Tool'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now learned enough image enhancement techniques to take up a simple
    project applying these techniques. Let''s create a simple command line utility,
    a "Watermark Maker Tool". Although we call it a "Watermark Maker ", it actually
    provides some more useful features. Using this utility, you can add the date stamp
    to the image (the date on which the image was enhanced using this tool). It also
    enables embedding custom text within an image. The tool can be run on the command
    line using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Where, the `[options]` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--image1:` The file path of the main image that provides canvas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--waterMark:` The file path of the watermark image (if any).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--mark_pos:` The coordinates of top-left corner of the watermark image to
    be embedded. The values should be specified in double quotes, like **100, 50**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--text:` The text that should appear in the output image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--text_pos:` The coordinates of top-left corner of the TEXT to be embedded.
    The values should be specified in double quotes, like **100, 50**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--transparency:` The transparency factor for the watermark (if any)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dateStamp:` Flag (True or `False)` that determines whether to insert date
    stamp in the image. If `True`, the date stamp at the time this image was processed
    will be inserted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is an example that shows how to run this tool with all the options
    specified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This creates an output image file `WATERMARK.png`, with a watermark and text
    at the specified anchor point within the image.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - Watermark Maker Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think about all the methods we would need to accomplish this. The first thing
    that comes to mind is a function that will process the command-line arguments
    mentioned earlier. Next, we need to write code that can add a watermark image
    to the main image. Let's call this `addWaterMark().` On similar lines, we will
    need methods that add text and date stamp to the image. We will call this `addText()`
    and `addDateStamp()` respectively. With this information, we will develop code
    to make this work. In this project, we will encapsulate this functionality in
    a class, but it is not necessary. We do so to make this tool extensible for future
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Download the file `WaterMarkMaker.py`. This has the code required in this project.
    Just keep it for further use. Some of the methods will not be discussed in this
    section. If you encounter difficulties while developing those methods, you can
    always go back and refer to this file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new Python source file and declare the following class and its methods.
    Just create empty methods for now. We will expand these in as we proceed along.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will write code in the constructor of this class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code is self-explanatory. First, all the necessary attributes are initialized
    and then the relevant methods are called to create the image with watermark and/or
    the embedded text. Let's write the methods in the order in which they are called
    in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `processArgs()` method processes the command-line arguments. You can write
    this method as an exercise. Alternatively, you can use code in the `WaterMarkMaker.py`
    file from the Packt website. The process arguments method should take the assignments
    as shown in the following table. In the reference files, `getopt` module is used
    to process these arguments. Alternatively, you can use `OptionParser` in the `optparse`
    module of Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Argument | Value | Argument | Value |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `image1` | `self.mainImgPath` | `text_pos` | `self.text_pos` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `waterMark` | `self.waterMarkPath` | `transparency` | `self.t_factor` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `mark_pos` | `self.mark_pos` | `dateStamp` | `self.dateStamp` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `text` | `self.text` |   |   |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The `printUsage()` method just prints how to run this tool. You can easily write
    that method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's review the `addText()and _addTextWorker()` methods now. Note that some
    of the code comments are removed from the code samples for clarity. You can refer
    to the code in `WaterMarkMaker.py` for detailed comments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The addText() method simply calls _addTextWorker() by providing the self.text
    argument received from the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `_addTextWorker()` does the main processing that embeds the text within
    the image. This method is used in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Chapter 2, we created a new image containing a text string. It read "Not
    really a fancy text ". Do you remember? Here, we have written similar code with
    some improvements. The function ImageDraw.Draw takes the self.mainImage (an Image
    instance) as an argument to create a Draw instance, imgDrawer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 18, the text is embedded onto the given position using a given font.
    The text() method of Draw instance takes three arguments, namely, position, text,
    and the font. In the previous chapter, we already made use of the first two arguments.
    The third argument font is an instance of class ImageFont in PIL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On line 4, we create this instance specifying a font type (arial.ttf) and the
    font size (=50). The given text string is now added on to the main image!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next method we will discuss is `addDateStamp()`. It calls the same `_addTextWorker()`
    in the end. However, the placement of this date stamp is fixed at the bottom left
    corner of the image and of course we create our date string by using Python's
    `datetime` module. The code is illustrated below along with the import statement
    declared earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first line of the code in this method creates a date instance `today` with
    today''s date provided as a `3-tuple`. Something like this: `datetime.date(2010,
    1, 20)`. Next, we call the `timetuple` method of `date` instance. The first three
    values in this `tuple` are `year, month`, and `day` respectively.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the code is just the processing of the date stamp as a text string
    and then calling the main worker method just discussed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will review the code in the `addWaterMark()` method. A **watermark**
    is typically a semi-transparent image that appears in the main image. There are
    two different approaches to accomplish creating a watermark. The following code
    considers both these approaches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To add a watermark, first we make the image transparent. This is accomplished
    by calling the `addTransparency()` method. This method also changes the `mode`
    of the image to `RGBA`. This method is shown here. It is almost identical to the
    one we developed in an earlier section where an image was made transparent using
    blending functionality of PIL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, on line 13, we determine the anchor point on the main image, where the
    top-left corner of the watermark will appear. By default, we will match the bottom-left
    corner of the watermark with the main image. You can review the code for method
    _getMarkPosition() in the file WaterMarkMaker.py to see how this is done. Moving
    forward, the code block between lines 16-21 creates the watermark using the paste
    functionality. This is one way to create the image with a watermark. The arguments
    provided in the Image.paste function are image to be pasted, anchor point, and
    mask. The mask is selected as the watermark image itself so as to consider the
    transparency. Otherwise, the watermark image will appear opaque. The resultant
    image with and without image mask specification is compared in the following illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resultant images using Image.paste operation created with and without mask.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - Watermark Maker Tool](img/0165_3_21.jpg)![Time for action
    - Watermark Maker Tool](img/0165_3_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, in the else condition block (lines 22 to 33), we use Image.composite functionality
    in PIL to embed the watermark. The dimensions of the example watermark image used
    here are 200x200 pixels, whereas the dimensions of the main image are 800x600
    pixels. To use the composite() method, we need to make these images of the same
    size, and yet, make sure to paste the watermark at the specified position. How
    to achieve this? The first thing to do is to create a canvas image to hold the
    watermark. The canvas image is of the same size as that of the main image. The
    code block 25-29 creates the canvas and pastes the watermark at an appropriate
    location.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, on line 31, the composite image is created using the canvas image instance
    as the alpha mask.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now lets run this tool! You can use your own image files for main image or
    the watermark. Alternatively, you can use the image `0165_3_34_KokanPeak_for_WATERMARK.png`
    as the main image and `0165_3_38_SMILEY_small.png` as the watermark image. The
    command-line arguments for this run are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resultant image with text, date stamp, and the watermark is shown in the
    next illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Final processed image with text, date stamp, and a watermark.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - Watermark Maker Tool](img/0165_3_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a very useful utility that can add a watermark and/or a text string
    and/or a date stamp to an input image. We used several of the image processing
    techniques learned in this as well as in an earlier chapter on image processing.
    Especially, image enhancement features such as blending, creating composite images,
    and adding transparency were applied to accomplish this task. Additionally we
    made use of common functionality such as pasting an image, drawing text onto the
    image, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero do more with Watermark Maker Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our Watermark Maker tool needs an upgrade. Extend this application so that
    it supports following the features:'
  prefs: []
  type: TYPE_NORMAL
- en: The text or the date stamp color is currently hardcoded. Add a new command-line
    argument so that a text color can be specified as an optional argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some standard default options for specifying anchor position for text, date
    stamp, and the watermark image. These options can be `TOP_RIGHT, TOP_LEFT, BOTTOM_RIGHT`,
    and `BOTTOM_LEFT`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command-line options list is too long. Add code so that all arguments can
    be read from a text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add support so that it can batch-process images to create desired effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applying image filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, `filter` argument was used while performing the image
    resize operation. This `filter` determined the quality of the output image. However,
    there were only four `filter` options available and the scope was limited to a
    resize operation. In this section, some additional image enhancement filters will
    be introduced. These are predefined filters and can be directly used on any input
    image. Following is a basic syntax used for applying a filter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a new image `filtered_image` by filtering image `img` . The
    `FILTER` argument can be one of the predefined filters in the `ImageFilter` module
    of PIL for filtering the image data. PIL offers several predefined image enhancement
    filters. These can be broadly classified into the following categories. With the
    help of examples, we will learn some of these in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blurring and sharpening: `BLUR, SHARPEN, SMOOTH, SMOOTH_MORE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edge detection and enhancement: `EDGE_ENHANCE, EDGE_ENHANCE_MORE, FIND_EDGES,
    CONTOUR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Distortion/special effects: `EMBOSS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file `ImageFilter.py` in the PIL source code defines the-mentioned filter
    classes. You can create your own custom filter by tweaking various arguments in
    these filter classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Where, `kernel` is the convolution kernel. Here, the 'convolution' is a mathematical
    operation, on the image matrix by the 'kernel' matrix to produce a resultant matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The size of matrix is specified by the size argument. It is specified in the
    form (width, height). This can either be (3, 3) or (5, 5) size in the current
    PIL version. The result of each pixel is divided by `scale` argument. This is
    an optional argument. The `offset` value, if specified, has its value is added
    to the result after dividing it by the scale argument.
  prefs: []
  type: TYPE_NORMAL
- en: In some of the image enhancement filter examples, we will create our own custom
    filter.
  prefs: []
  type: TYPE_NORMAL
- en: Smoothing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Smoothing** an image means reducing the noise within the image data. For
    this, certain mathematical approximation is applied on the image data to recognize
    the important patterns within the image. The `ImageFilter` module defines `class
    SMOOTH` for smoothing an image. PIL specifies the following default filter arguments
    for the image-smoothing filter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Time for action - smoothing an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work out an example where a smoothing filter will be applied to an image.
  prefs: []
  type: TYPE_NORMAL
- en: Download the image file `0165_3_Before_SMOOTHING.png` from the Packt website
    and save it as `Before_SMOOTHING.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a low-resolution image scanned from a developed photograph. As you can
    see, there is a lot of salt-and-pepper noise in the image. We will apply smoothing
    filter to reduce some of this noise in the image data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following code in a Python file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The highlighted line in the code is where the smoothing filter is applied to
    the image. The results are shown in the next illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Picture before and after smoothing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - smoothing an image](img/0165_3_24.jpg)![Time for action
    - smoothing an image](img/0165_3_25.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: To reduce the noise further down, you can use `ImageFilter.SMOOTH_MORE` or try
    reapplying the `ImageFilter.SMOOTH` multiple times until you get the desired effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can observe in the illustration, the noise is further reduced but the
    image appears a little bit hazy. Thus, one has to determine an appropriate level
    of smoothness.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comparison of the resultant image with single and multiple smoothing filters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - smoothing an image](img/0165_3_26.jpg)![Time for action
    - smoothing an image](img/0165_3_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to reduce high-level noise from the image data using the smoothing
    filter in the `ImageFilter` module.
  prefs: []
  type: TYPE_NORMAL
- en: Sharpening
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the earlier section, we learned image-smoothing techniques. If you want
    to view the finer details within an image, a sharpening filter can be applied
    over the image. Like image-smoothing filters, PIL provides predefined filters
    for sharpening called `ImageFilter.SHARPEN`. The basic syntax to sharpen an image
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can try this filter on the image that was smoothed multiple times in the
    earlier section.
  prefs: []
  type: TYPE_NORMAL
- en: Blurring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, blurring makes an image lose its focus. In PIL, the predefined filter
    for this is `ImageFilter.BLUR`. This is typically useful if you want to fade out
    the background to highlight some object in the foreground. The syntax is similar
    to the one used for other filters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The following illustration shows the effect of this filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Image before and after application of blurring filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blurring](img/0165_3_28.jpg)![Blurring](img/0165_3_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Edge detection and enhancements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn some general edge detection and enhancement filters.
    The edge enhance filter improves the edge contrast. It increases the contrast
    of the region very close to the edge. This makes the edge stand out. The edge
    detection algorithm looks for discontinuities within the pixel data of the image.
    For example, it looks for sharp change in the brightness to identify an edge.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - detecting and enhancing edges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how the edge detection and enhancement filters modify the data of
    a picture. The photograph that we will use is a close-up of a leaf. The original
    photo is shown in the next illustration. Applying an edge detection filter on
    this image creates a cool effect where only edges are highlighted and the remaining
    portion of the image is rendered as black.
  prefs: []
  type: TYPE_NORMAL
- en: Download the image `0165_3_6_Before_EDGE_ENHANCE.png` from the Packt website
    and save it as `Before_EDGE_ENHANCE.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following code in a Python file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Line 14 modifies the image data using the `FIND_EDGES` filter and then the resulting
    image is saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we modify the original image data, so that more veins within the leaf
    become visible. This is accomplished by the application of `ENHANCE_EDGES` filter
    (line 17).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 20, the `FIND_EDGES` filter is applied on the edge-enhanced image. The
    resultant images are compared in the next illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a) First row: Images before and after application of edge enhancement filter
    b) Second row: The edges detected by ImageFilter.FIND_EDGES filter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - detecting and enhancing edges](img/0165_3_30.jpg)![Time
    for action - detecting and enhancing edges](img/0165_3_31.jpg)![Time for action
    - detecting and enhancing edges](img/0165_3_32.jpg)![Time for action - detecting
    and enhancing edges](img/0165_3_33.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an image with enhanced edges by applying the `EDGE_ENHANCE` filter
    in the `ImageFilter` module. We also learned how to detect edges within the image
    using the edge detection filter. In the next section, we will apply a special
    form of the edge filter that highlights or darkens the detected edges within an
    image. It is called an embossing filter.
  prefs: []
  type: TYPE_NORMAL
- en: Embossing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In image processing, embossing is a process that gives an image a 3-D appearance.
    The edges within the image appear raised above the image surface. This optical
    illusion is accomplished by highlighting or darkening edges within the image.
    The following illustration shows original and embossed images. Notice how the
    edges along the characters in the embossed image are either highlighted or darkened
    to give the desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: '![Embossing](img/0165_3_34.jpg)![Embossing](img/0165_3_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ImageFiltermodule` provides a predefined filter, `ImageFilter.EMBOSS`,
    to achieve the embossing effect for an image. The convolution kernel of this filter
    is of a (3, 3) size and the default filter arguments are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Time for action - embossing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the image `0165_3_4_Bird_EMBOSS.png` from the Packt website and save
    it as `Bird_EMBOSS.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in a Python file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On line 9, the embossing filter `ImageFilter.EMBOSS` is applied to the image
    object `bird`. The resultant embossed image of the bird is shown in the next illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Original and embossed images of a bird using ImageFilter.EMBOSS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - embossing](img/0165_3_36.jpg)![Time for action - embossing](img/0165_3_37.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We applied an embossing filter on an image and created an embossed image. As
    seen in previous section, the filter modified the brightness of various edges
    to make them appear highlighted or darkened. This created an optical illusion
    where the image appeared raised above the surface.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a border
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How would you prefer viewing a family photo? As a bare picture or enclosed
    in a nice photo frame? In `ImageOps` module, PIL provides a preliminary functionality
    to add a plain border around the image. Here is the syntax to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates a border around the image. Internally, PIL just creates an
    image that has dimesions such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Then, the original image is pasted onto this new image to create the border
    effect. The `border` argument in the preceding code suggests border thickness
    in pixels. It is uniform in this example and is set to 20 pixels for left, right,
    top, and bottom borders. The `fill` argument specifies the border color. It can
    be a number in the range `0` to `255` indicating the pixel color, where `0` is
    for 'black' and `255` for 'white' border. Alternatively, you can specify a string
    representing a color, such as 'red' for red color, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - enclosing a picture in a photoframe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's develop code that adds a frame around a picture.
  prefs: []
  type: TYPE_NORMAL
- en: Download the image `0165_3_15_COLOR_TWEAK.png` and rename it to `FLOWER.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following code in a Python source file. Make sure to modify the code
    to specify in the input and output paths appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, three stacked borders are created. The innermost border
    layer is rendered with black color. This is intentionally chosen darker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, there is a middle layer of border, rendered with a lighter color (silver
    color in this case). This is done by the code on line 4\. It is thicker than the
    innermost border.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The outermost border is created by code on line 5\. It is a very thin layer
    rendered as black.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Together, these three layers of borders create an optical illusion of a photo
    frame, by making the border appear raised above the original image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following image shows the result of adding this border to the specified
    input image it shows the image before and after enclosing in a 'photo frame'.![Time
    for action - enclosing a picture in a photoframe](img/0165_3_38.jpg)![Time for
    action - enclosing a picture in a photoframe](img/0165_3_39.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to create a simple border around an image. By calling `ImageOps.expand`
    multiple times, we created a multi-layered border having each layer of variable
    thickness and color. With this, we accomplished creating an optical illusion where
    the picture appears to be enclosed within a simple photo frame.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter taught us several important image enhancement techniques, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: With the help of ample examples, we learned how to adjust the color, brightness,
    and contrast of an image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to blend images together create composites using image mask and
    how to add transparency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We applied blending, pasting, and other techniques learned to develop an interesting
    tool. We implemented features in this tool that enabled inserting a watermark,
    text, or date stamp to an image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of image enhancement filters were discussed. Using code snippets we
    learned how to reduce high-level noise from image, enhance edges, add sharpening
    or blurring effects, emboss an image, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned miscellaneous other useful image enhancements such as creating negatives
    and adding border effects to the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
