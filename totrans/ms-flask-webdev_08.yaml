- en: Building RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is an architectural style that
    is used to implement web services. It was defined by Roy Fielding in his PhD dissertation
    in 2000\. REST aims to implement a standard for uniform and predefined operations
    between systems. These systems can be client browsers, mobile applications, servers
    running parallel worker processes—you name it. By using HTTP methods, REST is
    platform- and programming-language-agnostic, and decouples the client and the
    server for easier development. This is typically used in web **single-page applications**
    (**SPAs**) that need to pull or update user information on the server. REST is
    also used to provide outside developers with a common interface to access user
    data. For example, Facebook and Twitter use REST in their application program
    interface, or API.'
  prefs: []
  type: TYPE_NORMAL
- en: You can take a look at Roy Fielding's original dissertation on REST at [https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP protocol: requests, responses, methods, headers, and the URI format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a REST service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to secure a REST service using JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is REST?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting into the details of REST, and since it is a style for communication
    between systems, let's first have a quick dive into the actual protocol that it
    uses, on which this whole book is based.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Hypertext Transfer Protocol** (**HTTP**) is a request–response protocol
    that belongs to layer 7 (the application layer). This layer interacts with the
    application itself. Some other protocols that belong to layer 7 are the **Simple
    Mail Transfer protoco**l (**SMTP**), **Network File System** (**NFS**), and the **File
    Transfer Protocol** (**FTP**), to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP was designed to be used by clients (user agents) to request resources from
    a server. These resources can be HTML files or any other content, such as JSON,
    XML, or media files. These requests for resources are identified by the network
    using **unified resource locators** (**URLs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'A URL is a specific type of URI, composed of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `<authority>` part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example URL using our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s separate out the elements of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Scheme** | **HTTP** |'
  prefs: []
  type: TYPE_TB
- en: '| `authority.host` | `someserver.com` |'
  prefs: []
  type: TYPE_TB
- en: '| `authority.port` | `5000` |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | `blog/user/user1` |'
  prefs: []
  type: TYPE_TB
- en: '| `query` | `title=sometitle` |'
  prefs: []
  type: TYPE_TB
- en: '| `fragment` | `1` |'
  prefs: []
  type: TYPE_TB
- en: 'Next, we will quickly look at an HTTP request message from a user agent to
    a server. This is a GET request from a Mozilla browser, as shown in the highlighted
    text in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So an HTTP request is composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request line**: Further composed of `<Request method> <Request URI> <HTTP
    version>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request header**: Contains information about what the client accepts, the
    user agent, cookies, and even basic authentication credentials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A** **blank line**: Separates the header from the body section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request body**: Optional'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepted HTTP request methods are `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`,
    `OPTIONS`, `TRACE`, and `PATCH`. The REST specification will use them to identify
    application type operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTP response to a request looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s composed of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status line**: The status of the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response headers**: Contains information about the content type, length,
    the server type (in our example, it''s Flask''s development server itself), date,
    and whether it can send set-cookie operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blank line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response body**: In our example, this is a JSON response, probably a REST
    service response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Status response codes are also very significant to REST. These fall into the
    following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Informational**: 1XX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Successful**: 2XX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redirection**: 3XX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client error**: 4XX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server error**: 5XX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For further details on status response codes, take a look at RFC2616 at [https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
  prefs: []
  type: TYPE_NORMAL
- en: REST definition and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting into the details of REST, let''s look at an example. With a
    client—in this case, a web browser—and a server, the client sends a request to
    the server over HTTP for some models, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dec57efd-0837-4883-bd2d-9971b1a10913.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The server will then respond with a document containing all the models, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ea3f8b0-ab4c-4648-a50b-5b69e62d2552.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The client can then modify the data on the server through a `PUT` HTTP request,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8282865-f224-433a-b137-67f923f75a0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, the server will respond that it has modified the data. This is a very
    simplified example, but it will serve as a backdrop to how REST is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than a strict standard, REST lays out a set of constraints on communications
    to define a methodology that can be implemented in many ways. These constraints
    are born out of years of trial and error with other communication protocols, such
    as the **Remote Procedure Call** (**RPC**) or **Simple Object Access Protocol**
    (**SOAP**). These protocols fell by the wayside because of their strictness, verbosity,
    and the fact that it is difficult to use them to create APIs. The issues with
    these systems were identified, and REST's constraints were created to keep these
    issues from happening again.
  prefs: []
  type: TYPE_NORMAL
- en: 'REST provides the following guiding constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns between the client and server**: The client and server
    should be able to evolve or change independently as long as the API does not change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: Any information that is necessary to handle requests is stored
    in the request itself or by the client. An example of the server being stateless
    is the `session` object in Flask. The `session` object does not store its information
    on the server, but stores it on the client in a cookie. The cookie is sent along
    with every request for the server to parse and determine whether the necessary
    data for the requested resource is stored inside it, rather than the server storing
    session information for every user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**: There are many different parts to this constraint, which
    are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface is based around resources, which in our case are models.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Data sent by the server is not the actual data in the server, but a representation.
    For example, a JSON abstraction of the data is sent with each request, rather
    than the actual database.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The data sent by the server is enough to allow the client to modify the data
    on the server. In the preceding example, the IDs that are passed to the client
    fill this role.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Every resource provided by the API must be represented and accessed in the same
    manner. For example, one resource cannot be represented in XML and while another
    is represented in JSON.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered system:** Load balancers, proxies, caches, and other servers and
    services can act between the client and the server, as long as the final result
    is the same as if they were not there. This improves performance, scalability,
    and availability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheability: **Clients can cache responses, so a server must define whether
    a response is cacheable or not. This improves performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a system adheres to all these constraints, it is considered to be a RESTful
    system. The most common forms of RESTful systems are built of HTTP and JSON. Each
    resource is located on its own URL path and is modified with different HTTP request
    methods. Generally, this takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP method** | **URL** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `http://host/resource` | Get all the resource representations |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `http://host/resource/1` | Get the resource with an ID of `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `http://host/resource` | Create a new resource from the form data
    in the `POST` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `http://host/resource/1` | Modify the existing data of the resource
    with the ID of `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `http://host/resource/1` | Delete the resource with the ID of
    `1` |'
  prefs: []
  type: TYPE_TB
- en: 'As an example, a response to the second `GET` request would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In RESTful APIs, it is also very important that we return the correct HTTP
    status code with the response data to notify the clients of what actually happened
    on the server without the clients resorting to parsing the returned message. Here
    is a list of the main HTTP codes that are used in RESTful APIs, along with their
    meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP code** | **Name** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `200` | OK | The default code of HTTP. The request was successful, and the
    data was returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `201` | Created | The request was successful, and a new resource was created
    on the server. |'
  prefs: []
  type: TYPE_TB
- en: '| `204` | No content | The request was successful, but the response returned
    no content. |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | Bad request | The request was denied because of some perceived client
    error—either it was a malformed request or it was missing the required data. |'
  prefs: []
  type: TYPE_TB
- en: '| `401` | Unauthorized | The request was denied because the client was not
    authenticated, and it should be authenticated before requesting this resource
    again. |'
  prefs: []
  type: TYPE_TB
- en: '| `403` | Forbidden | The request was denied because the client does not have
    permission to access this resource. This is in contrast to the `401` code, which
    assumes that the user is not authenticated. The `403` code says the resource is
    not accessible regardless of authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `404` | Not found | The requested resource does not exist. |'
  prefs: []
  type: TYPE_TB
- en: '| `405` | Method not allowed | The request was denied because the HTTP method
    is not available for the URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `500` | Internal server error | The web server responds with this status
    code when it has encountered an unexpected condition that prevented it from fulfilling
    the request from the client. |'
  prefs: []
  type: TYPE_TB
- en: '| `501` | Not implemented | This error is shown when it does not support the
    functionality required to process the request. This is the appropriate response
    when the server does not recognize the request method. |'
  prefs: []
  type: TYPE_TB
- en: '| `502` | Bad gateway | When the server is acting as a gateway or proxy and
    receives an invalid response from the upstream server. |'
  prefs: []
  type: TYPE_TB
- en: '| `503` | Service unavailable | Currently unable to handle the request because
    of temporary overloading or maintenance of the server.  |'
  prefs: []
  type: TYPE_TB
- en: '| `504` | Gateway timeout | Did not receive a timely response from the upstream
    server. |'
  prefs: []
  type: TYPE_TB
- en: Setting up a RESTful Flask API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our app, we will create a RESTful interface to the blog post data in our
    database. The representations of the data will be sent as JSON. The data will
    be retrieved and modified using the general form in the preceding table, but the
    URI will be `/api/posts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t already downloaded and accessed the example code given for
    this chapter and taken a look at the Flask URL maps for the API, then a simple
    way of doing this can be seen in the root directory of the application, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are going to implement an authentication endpoint for the API and the necessary
    endpoints to create a CRUD API for the blog posts.
  prefs: []
  type: TYPE_NORMAL
- en: We could just use the standard Flask views to create the API, but the Flask
    extension **Flask Restful** makes the task much easier and will help us adhere
    to a full REST compliance (RESTful).
  prefs: []
  type: TYPE_NORMAL
- en: 'To include this new dependency in our application, you can find the following
    in the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to create a new module for the API. The application structure
    looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the idea is to structure our application so that it can grow easily.
    This time, for each application module we add—such as a blog, shared photos, you
    name it—we create a new module inside the `api/` module itself where all the API
    logic is defined. A different approach could be to include the REST API inside
    each module.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with all the other modules, there is a `create_module` function on
    the `api/__init__.py` that handles its own initialization for the main factory
    function, `create_app` . The `PostApi` class will also have its route defined
    with the `add_resource()` method of the `Api` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be seen in the provided code file, `api/__init__.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be seen in the `create_app` function in `__init__.py` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The control logic and views for our `Post` API are stored in a new folder named
    `api/blog` in the `controllers.py` file. Inside the `controllers.py`, we are going
    to create the API itself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In Flask Restful, every REST resource is defined as a class that inherits from
    the `Resource` object. Much like the `MethodView` object shown in [Chapter 4](33c572f2-ce0e-40da-b46a-a7e13ba85496.xhtml),
    *Creating Controllers with Blueprints*, any class that inherits from the `Resource`
    object defines its logic with methods named after the HTTP methods. For example,
    when the `GET` HTTP method hits the `PostApi` class, the `get` method will be
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: JWT authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To solve our authentication problems, `Flask-Login` could be used and the cookie
    data from the login could be checked. However, this would require developers who
    wish to use our API to have their program login through the web interface. We
    could also have developers send their login data with every request, but it's
    a good design practice to only send sensitive information when absolutely necessary.
    Instead, our API will provide an `auth/api` endpoint that allows them to send
    login credentials and get an access token back.
  prefs: []
  type: TYPE_NORMAL
- en: For the authentication mechanism, we are going to use **JSON Web Token** (**JWT**)
    to create access tokens for the consumers of our API upon login. A JWT token asserts
    which user is logged in, thereby saving the server another call to the database
    for authentication. This token has an expiration date encoded inside it that will
    not allow the token to be used after it expires. This means that even if the token
    is stolen by a malicious user, it will only be useful for a limited amount of
    time before the client has to reauthenticate. As always, be sure to use HTTPS
    to encrypt all your client–server connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To leverage this feature, we are going to use another Flask extension—Flask-JWT-extended.
    You will find its dependency declared in the `requirements.txt` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The initialization of the extension is going to be made on the `auth` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following `auth/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the following helper function to authenticate users that are defined
    on the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the login endpoint itself can be found at `auth/controllers.py`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we verify whether the request includes a JSON body. For this, we use
    a `request.is_json` function from Flask. Next, we extract the username and password
    from the JSON body using `request.json.get`. Then we check the user's credentials
    using the previous help function, `authenticate`. Finally, we return the JWT access
    token using the username as our identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users of our API will have to pass the token that is received from this resource
    to any method that requires user credentials. In order to test this code, a tool
    named **curl** will be used. Curl is a command-line tool included in Bash that
    allows for the creation and manipulation of HTTP requests. To test it, use the `curl`utility
    to first log in, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `-H` flag to send the request header stating that the content
    body is JSON and the `-d` flag to send the request body data. Next, we can use
    the token to access API-protected resources, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the access token is sent on the request header user `Authorization:
    Bearer <TOKEN>` convention. If we try to access the same resource without any
    token, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we get an HTTP `401` status code. To protect API endpoints, we
    just have to use the `flask-jwt-extended` decorator `@jwt_required`, and to fetch
    the username, we use the `get_jwt_identity()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `flask-jwt-extended` decorator provides some extra functionalities, such
    as token expiration, the ability to refresh token endpoints, and many configuration
    options. You can read more about it at [http://flask-jwt-extended.readthedocs.io/en/latest/](http://flask-jwt-extended.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Get requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some of our `GET`, `PUT`, and `DELETE` requests, our API will need the ID
    of the post that is to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: The data to be sent to the client must be a representation of the `Post` objects
    in JSON, so how will our `Post` objects be translated? Flask Restful provides
    a way of translating any object into JSON through the `fields` object and the
    `marshal_with` function decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Output formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The output format is defined by creating a dictionary of `field` objects that
    represent basic types. The key of the field defines what attribute the field will
    try to translate. By passing the dictionary to the `marshal_with` decorator, any
    object that the `get` method attempts to return will be first translated using
    the dictionary. This also works for lists of objects. Let's look at a simple way
    of implementing this API endpoint. The following example code takes pagination
    into account, but we will show you how this works later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following `api/blog/controllers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'While reloading the API in the browser, every `Post` object will be shown in
    JSON format. Note the `HTMLField` on the fields declaration. The problem is that
    the API should not return HTML from the WYSIWYG editor in the post creation form.
    As stated earlier, the server should not be concerned with the UI, and the HTML
    is purely for output specification. To solve this, we will need a custom field
    object that strips HTML from the strings. In a new file in the `api/blog/` folder
    named `fields.py`, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The exception block is to take into account Python2 and Python3 compatibility,
    since the standard library has changed for the `HTMLParser` module in Python3. We
    now have a `strip_tags` function that will return any string that has been cleaned
    of HTML tags. A new field type, called `HTMLfield`, is defined by inheriting from
    the `fields.Raw` class and sending values through the `strip_tags` function. If
    the page is reloaded, all HTML is gone and only the text will remain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask Restful provides many default fields, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.String`: This converts the value using `str()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.FormattedString`: This passes the formatted string in Python with the
    variable name in brackets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Url`: This provides the same functionality as the Flask `url_for` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.DateTime`: This converts a Python `date` or `datetime` object to a
    string. The `format` keyword argument specifies whether the string should be an
    `ISO8601` date or an `RFC822` date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Float`: This converts the value to a string representation of a float.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Integer`: This converts the value to a string representation of an
    integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Nested`: This allows nested objects to be represented by another dictionary
    of field objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.List`: Much like the MongoEngine API, this field takes another field
    type as an argument and tries to convert a list of values into a JSON list of
    the field types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Boolean`: This converts the value to a string representation of a `boolean`
    argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two more fields that are added to the returned data: the author and
    the tags. The comments will be left out because they should be contained under
    their own resource.'
  prefs: []
  type: TYPE_NORMAL
- en: The `author` field uses the attribute keyword argument of the `field` class.
    This allows any attribute of the object to be represented rather than just base-level
    properties. Because the many-to-many relationship of the tags returns a list of
    objects, the same solution cannot be used with the tags. A list of tag dictionaries
    can now be returned using the `NestedField` type inside a `ListField` and another
    dictionary of fields. This has the added benefit of giving the end users of the
    API a tag ID so that they can query as easily as if there were a tag API.
  prefs: []
  type: TYPE_NORMAL
- en: Request arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While sending a `GET` request to the base of the resource, our API currently
    sends all the `Post` objects in the database. This is acceptable if the number
    of objects is low or the number of people using the API is low. However, if either
    increases, the API will put a large amount of stress on the database. Much like
    the web interface, the API should be paginated as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve this, our API will need to accept a `GET` query string
    parameter called `page` that specifies which page is to be loaded. Flask Restful
    provides a method to grab request data and parse it. If the required arguments
    aren''t there, or the types don''t match, Flask Restful will autocreate a JSON
    error message. In a new file in the `api/blog/` folder named `parsers.py`, you
    will find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is what we should have on the `PostApi` class when the request
    has no post ID key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `RequestParser` looks for the `page` variable in either
    the query string or the request header and returns the page of `Post` objects
    from that page. Again, we are making the page size configurable with the same
    value as for the web view page version. We use the `current_app` Flask proxy to
    fetch any value from our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a parser object is created with `RequestParser`, arguments can be added
    using the `add_argument` method. The first argument of `add_argument` is the key
    of the argument that is to be parsed, but `add_argument` also takes a lot of keyword
    arguments, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`action`: This is what the parser does with the value after it has been successfully
    parsed. The two available options are `store` and `append`. The `store` option
    adds the parsed value to the returned dictionary. The `append` options adds the
    parsed value to the end of a list in the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case_sensitive`: This is a boolean argument to allow or disallow the keys
    to be case insensitive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`choices`: This is like MongoEngine, a list of the allowed values for the argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: This is the value that is produced if the argument is absent from
    the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dest`: This is the key to add the parsed value to in the returned data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help`: This is a message to return to the user if validation fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignore`: This is a boolean argument to allow or disallow failures of the type
    conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location`: This indicates where to look for the data. The locations available
    are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args` to look in the `GET` query string'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers` to look in the HTTP request headers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form` to look in the HTTP `POST` data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookies` to look in the HTTP cookies'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json` to look in any sent JSON'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`files` to look in the `POST` file data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required`: This is a boolean argument to determine whether the argument is
    optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`store_missing`: This is a boolean argument to determine whether the default
    value should be stored if the argument is not in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This is the Python type to convert the passed value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the Flask Restful parser, it is very easy to add new parameters to the
    API. For example, let''s add a user argument that allows us to search for all
    posts that have been made by a user. First, in the `api/blog/parsers.py` file,
    we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `api/blog/controllers.py` file, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When Flask's `abort` function is called from `Resource`, Flask Restful will
    automatically create an error message to be returned with the status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the API, we use `curl`for the sake of simplicity, but feel free to
    use any other tool available to interact with HTTP APIs. After requesting an access
    token from our authentication endpoint, request `post` with `id=1`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can request all posts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the response only fetches the first page, as intended. Now let''s
    request page two, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can request for posts from a certain user as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Post requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `POST` methods on REST are used for resource creation, not that this isn''t
    considered an idempotent method. Using our new knowledge of the Flask Restful
    parser, we can cover the `POST` endpoint. First, we will need a parser that will
    take a title, the body text, and a list of tags. In the `parser.py` file, find
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have created a helper function, called `add_tags_to_post`, to add tags
    to a post. If the tags don't exist, it will add them to the database. We will
    use it on `POST` and `PUT` requests. Nothing new here—just a simple SQLAlchemy
    helper function to help us keep our code concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `PostApi` class will need a `post` method to handle incoming requests.
    The `post` method will use the given values for the title and body text. Also,
    if the `tags` key exists, then add the tags to the post, which creates new tags
    if the passed ones do not exist, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At the `return` statement, if a tuple is returned, the second argument is treated
    as the status code. There is also a third value that acts as extra header values
    by passing a dictionary. Also, note the `get_jwt_identity` that we use to fetch
    the user ID from the JWT token. This was set up at the login phase where we used
    the user ID to set the JWT identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass `POST` variables, the `d` flag is used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The ID of the newly created post should be returned. If you go to the browser,
    you should see our newly created post, which was made by the user that you used
    to generate the authentication token.
  prefs: []
  type: TYPE_NORMAL
- en: Put requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As listed in the table at the beginning of this chapter, `PUT` requests are
    used to change the values of an existing resource. Like the `post` method, the
    first thing that we should do is create a new parser in `parsers.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic for the `put` method is very similar to the `post` method. The main
    difference is that each change is optional and any request that does not provide
    `post_id` is denied, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Also note that, just as we did with the controller for web views, we are denying
    any request to change a blog post that was not made by the creator of the blog
    post him or herself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this method, `curl` can also create `PUT` requests with the `-X` flag,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Delete requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, in the following code we have the `DELETE` request, which is the simplest
    of the four supported methods. The main difference with the `delete` method is
    that it returns no content, which is the accepted standard with `DELETE` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can test using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If everything is successfully deleted, you should receive a `204` status code
    and nothing should show up.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on from REST completely, there is one final challenge for you
    to test your understanding of Flask Restful. Try to create a comments API that
    is not only modifiable from `http://localhost:5000/api/comments`, but that also
    allows developers to modify only those comments on a specific post by using the
    URL format `http://localhost:5000/api/post/<int:post_id>/comments`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `Post` API is now a complete feature. If a developer wants, then they can
    create a desktop or mobile application using this API, all without using HTML
    scraping, which is a very long and tedious process. Giving the developers who
    wish to use your website as a platform the ability to do so will increase your
    site's popularity, as they will essentially give you free advertising with their
    app or website.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the popular program Celery to run programs
    and tasks asynchronously with our application.
  prefs: []
  type: TYPE_NORMAL
