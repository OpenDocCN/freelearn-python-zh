- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Templating with Jinja
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jinja 模板
- en: This chapter will cover the basics of **Jinja** templating from the perspective
    of Flask. We will also learn how to design and develop applications with modular
    and extensible templates.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从 Flask 的角度介绍 **Jinja** 模板的基础知识。我们还将学习如何使用模块化和可扩展的模板设计和开发应用程序。
- en: Information
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: If you have followed Flask or Jinja or this book’s previous editions, you might
    have noticed that, previously, this templating library was called *Jinja2*. The
    latest version of Jinja at the time of writing is version 3, and the authors/community
    have decided to call it just *Jinja* instead of confusingly continuing with Jinja2,
    Jinja3, and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经跟随 Flask 或 Jinja 或本书的前几版，你可能已经注意到，之前这个模板库被称为 *Jinja2*。本书撰写时 Jinja 的最新版本是
    3 版，作者/社区决定将其称为 *Jinja*，而不是继续使用容易混淆的 Jinja2、Jinja3 等名称。
- en: 'In Flask, we can write a complete web application without the need for a third-party
    templating engine. For example, have a look at the following code; this is a standalone,
    simple Hello World application with a bit of HTML styling included:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flask 中，我们可以编写一个完整的 Web 应用程序，无需第三方模板引擎。例如，看看以下代码；这是一个包含一些 HTML 样式的独立、简单的 Hello
    World 应用程序：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Is the preceding pattern of application writing feasible in the case of large
    applications that involve thousands of lines of HTML, JS, and CSS code? In my
    opinion, no!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及数千行 HTML、JS 和 CSS 代码的大型应用程序中，前面提到的应用程序编写模式可行吗？在我看来，不可行！
- en: Fortunately, templating offers a solution because it allows us to structure
    our views code by keeping our templates extensible and separate. Flask provides
    default support for Jinja, although we can use any templating engine that suits
    us. Furthermore, Jinja provides many additional features that make templates very
    powerful and modular.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，模板提供了一种解决方案，因为它允许我们通过保持模板的可扩展性和分离来结构化我们的视图代码。Flask 默认支持 Jinja，尽管我们可以使用任何适合我们的模板引擎。此外，Jinja
    提供了许多额外的功能，使模板非常强大和模块化。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下食谱：
- en: Bootstrapping the standard layout
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动标准布局
- en: Implementing block composition and layout inheritance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现块组合和布局继承
- en: Creating a custom context processor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义上下文处理器
- en: Creating a custom Jinja filter
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义 Jinja 过滤器
- en: Creating a custom macro for forms
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为表单创建自定义宏
- en: Advanced date and time formatting
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级日期和时间格式化
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Jinja is installed as a part of the standard Flask installation. There is no
    need to install it separately. For more details, refer to the *Setting up a virtual
    environment* section in [*Chapter 1*](B19111_01.xhtml#_idTextAnchor016).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 是作为 Flask 标准安装的一部分安装的。无需单独安装。有关更多详细信息，请参阅 [*第 1 章*](B19111_01.xhtml#_idTextAnchor016)
    中的 *设置虚拟环境* 部分。
- en: Bootstrapping the standard layout
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动标准布局
- en: Most of the applications in Flask follow a specific pattern of laying out templates.
    In this recipe, we will implement the recommended way of structuring the layout
    of templates in a Flask application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 中的大多数应用程序遵循特定的模板布局模式。在本食谱中，我们将实现 Flask 应用程序中模板布局的结构化推荐方式。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: By default, Flask expects templates to be placed inside a folder named `templates`
    at the application root level. If this folder is present, then Flask will automatically
    read the contents by making the contents of this folder available for use with
    the `render_template()` method, which we will use extensively throughout this
    book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Flask 预期模板应放置在应用程序根级别的名为 `templates` 的文件夹中。如果该文件夹存在，那么 Flask 将自动读取其内容，通过使该文件夹的内容可用于
    `render_template()` 方法来使用，我们将在此书中广泛使用该方法。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let’s demonstrate this with a small application. This application is very similar
    to the one we developed in [*Chapter 1*](B19111_01.xhtml#_idTextAnchor016), *Flask
    Configurations*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个小的应用程序来演示这一点。这个应用程序与我们开发的 [*第 1 章*](B19111_01.xhtml#_idTextAnchor016)
    中 *Flask 配置* 部分非常相似。
- en: 'The first thing to do is to add a new folder named `templates` under `my_app`.
    The application structure should look like the following directory structure:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是在 `my_app` 下添加一个名为 `templates` 的新文件夹。应用程序结构应如下目录结构：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We now need to make some changes to the application. The `hello_world()` method
    in the `views` file, `my_app/hello/views.py`, should look like the following lines
    of code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要对应用程序进行一些修改。`views` 文件中的 `hello_world()` 方法，位于 `my_app/hello/views.py`，应如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding method, we look for a URL query argument, `user`. If it is
    found, we use it, and if not, we use the default argument, `Shalabh`. Then, this
    value is passed to the context of the template to be rendered – that is, `index.html`
    – and the resulting template is rendered.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们寻找一个URL查询参数`user`。如果找到了，我们就使用它；如果没有找到，我们就使用默认参数`Shalabh`。然后，这个值被传递到要渲染的模板的上下文中——即`index.html`——然后渲染出结果模板。
- en: 'The `my_app/templates/index.html` template can simply be the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_app/templates/index.html`模板可以简单地是以下内容：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, if we open the `http://127.0.0.1:5000/hello` URL in a browser, we should
    see a response similar to the one shown in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在一个浏览器中打开`http://127.0.0.1:5000/hello` URL，我们应该看到类似于以下截图的响应：
- en: '![Figure 2.1 – The first rendered template](img/B19111_02_1.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 第一个渲染的模板](img/B19111_02_1.jpg)'
- en: Figure 2.1 – The first rendered template
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 第一个渲染的模板
- en: 'If we pass a URL argument with a value for the `user` key as `http://127.0.0.1:5000/hello?user=John`,
    we should see the following response:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递一个包含`user`键值的URL参数，例如`http://127.0.0.1:5000/hello?user=John`，我们应该看到以下响应：
- en: '![Figure 2.2 – Serving custom content in the template](img/B19111_02_2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 在模板中提供自定义内容](img/B19111_02_2.jpg)'
- en: Figure 2.2 – Serving custom content in the template
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 在模板中提供自定义内容
- en: As we can see in `views.py`, the argument passed in the URL is fetched from
    the `request` object using `request.args.get('user')` and then passed to the context
    of the template being rendered, using `render_template`. The argument is then
    parsed using the Jinja placeholder, `{{ user }}`, to fetch the contents from the
    current value of the `user` variable from the template context. This placeholder
    evaluates all of the expressions placed inside it, depending on the template context.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在`views.py`中看到的，传递到URL的参数是通过`request.args.get('user')`从`request`对象中获取的，然后通过`render_template`传递到正在渲染的模板的上下文中。然后，使用Jinja占位符`{{
    user }}`解析该参数，以从模板上下文中的当前`user`变量值获取内容。这个占位符会根据模板上下文评估其内部放置的所有表达式。
- en: Information
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The Jinja documentation can be found at [http://jinja.pocoo.org/](http://jinja.pocoo.org/).
    This will come in handy when writing templates.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja文档可以在[http://jinja.pocoo.org/](http://jinja.pocoo.org/)找到。当编写模板时，这将非常有用。
- en: Implementing block composition and layout inheritance
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实现块组合和布局继承
- en: Usually, any web application will have a number of web pages that are different
    from each other. However, code blocks such as headers and footers will appear
    the same on almost all pages throughout the site; likewise, the menu will remain
    the same. In fact, it is usually just the center container block that changes.
    For this, Jinja provides a great way of ensuring inheritance among templates.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何Web应用程序都将有许多不同的网页。然而，像页眉和页脚这样的代码块几乎在网站的所有页面上都会以相同的方式出现；同样，菜单也会保持不变。实际上，通常只是中心容器块会改变。为此，Jinja提供了确保模板之间继承的绝佳方式。
- en: With this in mind, it’s a good practice to have a base template where the basic
    layout of the site, along with the header and footer, can be structured.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，有一个基础模板是一个好习惯，其中可以构建网站的基本布局，包括页眉和页脚。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will create a small application that will have a home page
    and a product page (such as the ones we see on e-commerce stores). We will use
    the Bootstrap framework to give a minimalistic design and theme to our template.
    Bootstrap v5 can be downloaded from [http://getbootstrap.com/](http://getbootstrap.com/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个小型应用程序，它将有一个主页和一个产品页（例如我们在电子商务网站上看到的）。我们将使用Bootstrap框架为我们的模板提供简约的设计和主题。可以从[http://getbootstrap.com/](http://getbootstrap.com/)下载Bootstrap
    v5。
- en: Information
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The latest version of Bootstrap at the time of writing is v5\. Different versions
    of Bootstrap might cause the UI of an application to behave in different ways,
    but the core essence of Bootstrap remains the same.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 写作本文时，Bootstrap的最新版本是v5。不同的Bootstrap版本可能会导致应用程序的UI以不同的方式表现，但Bootstrap的核心本质保持不变。
- en: For the sake of simplicity and focus on the topic at hand, we have created a
    hardcoded data store of a few products, which can be found in the `models.py`
    file. These are imported and read in `views.py` and are sent over to the template
    as template context variables, via the `render_template()` method. The rest of
    the parsing and display is handled by the templating language, which in our case
    is Jinja.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单和专注于当前的主题，我们创建了一个硬编码的产品数据存储，可以在 `models.py` 文件中找到。这些在 `views.py` 中被导入和读取，并通过
    `render_template()` 方法作为模板上下文变量发送到模板。其余的解析和显示由模板语言处理，在我们的例子中是 Jinja。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Have a look at the following layout:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的布局：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding layout, `static/css/bootstrap.min.css` and `static/js/bootstrap.bundle.min.js`
    are standard files that can be downloaded from the Bootstrap website mentioned
    in the *Getting ready* section. The `run.py` file remains the same, as always.
    The rest of the application-building process is as follows.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的布局中，`static/css/bootstrap.min.css` 和 `static/js/bootstrap.bundle.min.js`
    是可以从 *准备就绪* 部分提到的 Bootstrap 网站下载的标准文件。`run.py` 文件保持不变，就像往常一样。其余的应用程序构建过程如下。
- en: 'First, define the models in `my_app/product/models.py`. In this chapter, we
    will work on a simple, non-persistent key-value store. We will start with a few
    hardcoded product records made well in advance, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `my_app/product/models.py` 中定义模型。在本章中，我们将处理一个简单、非持久的键值存储。我们将从提前编写的几个硬编码的产品记录开始，如下所示：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next comes the views – that is, `my_app/product/views.py`. Here, we will follow
    the blueprint style to write the application, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是视图——即 `my_app/product/views.py`。在这里，我们将遵循蓝图风格来编写应用程序，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Information
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The `abort()` method comes in handy when you want to abort a request with a
    specific error message. Flask provides basic error message pages, which can be
    customized as needed. We will look at them in the *Creating custom 404 and 500
    handlers* recipe in [*Chapter 4*](B19111_04.xhtml#_idTextAnchor184), *Working*
    *with Views*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要用一个特定的错误信息来终止一个请求时，`abort()` 方法会很有用。Flask 提供了基本的错误信息页面，可以根据需要自定义。我们将在 [*第
    4 章*](B19111_04.xhtml#_idTextAnchor184) 的 *创建自定义 404 和 500 处理器* 菜谱中查看它们，*与视图一起工作*。
- en: The name of the blueprint (`product`) that is passed in the `Blueprint` constructor
    will be appended to the endpoints defined in this blueprint. Do have a look at
    the `base.html` code for clarity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Blueprint` 构造函数中传入的蓝图名称（`product`）将被附加到在此蓝图定义的端点上。请查看 `base.html` 代码以获得清晰度。
- en: 'Now, create the application’s configuration file, `my_app/__init__.py`, which
    should look like the following lines of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建应用程序的配置文件，`my_app/__init__.py`，它应该如下几行代码所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is always possible to create your own custom CSS, which can add more flavor
    to the standard CSS provided by Bootstrap. To do this, add a bit of custom CSS
    code in `my_app/static/css/main.css`, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 总是可能创建自己的自定义 CSS，这可以为 Bootstrap 提供的标准 CSS 添加更多风味。为此，在 `my_app/static/css/main.css`
    中添加一些自定义 CSS 代码，如下所示：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When considering templates, it is always a good practice to create a base template
    to house the common code that can be inherited by all the other templates. Name
    this template `base.html` and place it in `my_app/templates/base.html`, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑模板时，始终创建一个基本模板来存放所有其他模板可以继承的通用代码。将此模板命名为 `base.html` 并将其放置在 `my_app/templates/base.html`
    中，如下所示：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Most of the preceding code contains normal HTML and Jinja evaluation placeholders,
    which we introduced in the previous recipe, *Bootstrapping the recommended layout*.
    An important point to note, however, is how the `url_for()` method is used for
    blueprint URLs. The blueprint name is appended to all endpoints. This becomes
    very useful when there are multiple blueprints inside one application, as some
    of them may have similar-looking URLs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的大部分代码包含正常的 HTML 和 Jinja 评估占位符，这是我们之前在 *引导推荐布局* 菜谱中介绍的。然而，需要注意的是 `url_for()`
    方法是如何用于蓝图 URL 的。蓝图名称被附加到所有端点上。当应用程序中存在多个蓝图时，这非常有用，因为其中一些可能具有相似的 URL。
- en: 'On the home page, `my_app/templates/home.html`, iterate over all the products
    and display them, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在主页上，`my_app/templates/home.html`，遍历所有产品并显示它们，如下所示：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, create the individual product page, `my_app/templates/product.html`,
    which should look like the following lines of code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建单个产品页面，`my_app/templates/product.html`，它应该如下几行代码所示：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding template structure, there is an inheritance pattern being
    followed. The `base.html` file acts as the base template for all other templates.
    The `home.html` file inherits from `base.html`, and `product.html` inherits from
    `home.html`. In `product.html`, the `container` block is overwritten, which was
    first populated in `home.html`. When this app is run, we should see output similar
    to that shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述模板结构中，遵循了一个继承模式。`base.html` 文件作为所有其他模板的基础模板。`home.html` 文件从 `base.html` 继承，而
    `product.html` 从 `home.html` 继承。在 `product.html` 中，`container` 块被覆盖，它最初是在 `home.html`
    中填充的。当运行此应用程序时，我们应该看到类似于以下截图所示的输出：
- en: '![Figure 2.3 – Iterating over blocks to create reusable content](img/B19111_02_3.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 遍历块以创建可重用内容](img/B19111_02_3.jpg)'
- en: Figure 2.3 – Iterating over blocks to create reusable content
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 遍历块以创建可重用内容
- en: 'The preceding screenshot shows how the home page will look. Note the URL in
    the browser. The product page should appear as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了主页的外观。注意浏览器中的 URL。产品页面应如下所示：
- en: "![Figure 2.4 – Inheriting template blocks to cre\uFEFFate clean code](img/B19111_02_4.jpg)"
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 继承模板块以创建干净的代码](img/B19111_02_4.jpg)'
- en: Figure 2.4 – Inheriting template blocks to create clean code
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 继承模板块以创建干净的代码
- en: Creating a custom context processor
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义上下文处理器
- en: Sometimes, we might want to calculate or process a value directly in templates.
    Jinja maintains the notion that the processing of logic should be handled in views
    and not in templates, thereby keeping templates clean. A context processor becomes
    a handy tool in this case. With a context processor, we can pass our values to
    a method, which will then be processed in a Python method, and our resultant value
    will be returned. This is done by simply adding a function to the template context,
    thanks to Python allowing its users to pass functions like any other object. In
    this recipe, we’ll see how to write a custom context processor.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望在模板中直接计算或处理一个值。Jinja 维持逻辑处理应在视图中而不是在模板中进行的观点，从而保持模板的简洁。在这种情况下，上下文处理器成为一个方便的工具。使用上下文处理器，我们可以将我们的值传递给一个方法，然后该方法将在
    Python 方法中处理，并返回我们的结果值。这可以通过简单地向模板上下文中添加一个函数来实现，因为 Python 允许用户像传递任何其他对象一样传递函数。在本食谱中，我们将了解如何编写自定义上下文处理器。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To write a custom context processor, follow the steps described as follows.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写自定义上下文处理器，请按照以下步骤操作。
- en: 'Let’s first display the descriptive name of the product in the `Category /
    Product-name` format. Afterward, add the method to `my_app/product/views.py`,
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先以 `类别 / 产品名称` 格式显示产品的描述性名称。之后，将方法添加到 `my_app/product/views.py` 中，如下所示：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A context is simply a dictionary that can be modified to add or remove values.
    Any method decorated with `@product_blueprint.context_processor` should return
    a dictionary that updates the actual context. We can use the preceding context
    processor as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是一个简单的字典，可以修改以添加或删除值。任何使用 `@product_blueprint.context_processor` 装饰的方法都应该返回一个更新实际上下文的字典。我们可以使用前面的上下文处理器如下：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can add the preceding code to our app for the product listing (in the `flask_app/my_app/templates/product.html`
    file) in the following manner:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的代码以以下方式添加到我们的应用程序中，用于产品列表（在 `flask_app/my_app/templates/product.html`
    文件中）：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The resulting parsed HTML page should look like the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的解析后的 HTML 页面应类似于以下截图：
- en: '![Figure 2.5 – A custom context processor for the product name](img/B19111_02_5.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 产品名称的自定义上下文处理器](img/B19111_02_5.jpg)'
- en: Figure 2.5 – A custom context processor for the product name
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 产品名称的自定义上下文处理器
- en: Information
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Have a look at the *Implementing block composition and layout inheritance* recipe
    earlier in this chapter to understand the context of this recipe better regarding
    the product and category logic.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章前面关于实现块组合和布局继承的食谱，以更好地理解本食谱中关于产品和类别逻辑的上下文。
- en: Creating a custom Jinja filter
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义 Jinja 过滤器
- en: 'After looking at the previous recipe, experienced developers might wonder why
    we used a context processor for the purpose of creating a well-formatted product
    name. Well, we can also write a filter for the same purpose, which will make things
    much cleaner. A filter can be written to display the descriptive name of a product,
    as shown in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看前面的菜谱后，经验丰富的开发者可能会想知道为什么我们使用上下文处理器来创建一个格式良好的产品名称。嗯，我们也可以为同一目的编写一个过滤器，这将使事情更加简洁。可以编写一个过滤器来显示产品的描述性名称，如下例所示：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This can also be used as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以按如下方式使用：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code will yield a similar result as in the previous recipe. Moving
    on, let’s now take things to a higher level by using external libraries to format
    currency.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生与前面菜谱中类似的结果。接下来，让我们通过使用外部库来格式化货币，将事情提升到更高的层次。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, let’s create a filter to format a currency based on the current local
    language. Add the following code to `my_app/__init__.py`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个过滤器，根据当前本地语言格式化货币。将以下代码添加到`my_app/__init__.py`中：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Information
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: '`request.accept_languages` might not work in cases where a request does not
    have the `ACCEPT-LANGUAGES` header.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`request.accept_languages`可能在请求没有`ACCEPT-LANGUAGES`头的情况下不起作用。'
- en: 'The preceding snippet will require the installation of a new package, `ccy`,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段需要安装一个新的包，`ccy`，如下所示：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The filter created in this example takes the language that best matches the
    current browser locale (which, in my case, is `en-US`), takes the last two characters
    from the locale string, and then generates the currency as per the ISO country
    code, which is represented by two characters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中创建的过滤器将选择与当前浏览器区域设置最佳匹配的语言（在我的情况下是`en-US`），然后从区域字符串中取出最后两个字符，并按照ISO国家代码生成货币，国家代码由两个字符表示。
- en: Tip
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: An interesting point to note in this recipe is that the Jinja filter can be
    created at the blueprint level as well as at the application level. If the filter
    is at the blueprint level, the decorator would be `app_template_filter`; otherwise,
    at the application level, the decorator would be `template_filter`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中需要注意的一个有趣点是，Jinja过滤器可以在蓝图级别以及应用级别创建。如果过滤器在蓝图级别，装饰器将是`app_template_filter`；否则，在应用级别，装饰器将是`template_filter`。
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The filter can be used in our template for the product as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该过滤器可以按如下方式用于我们的产品模板：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code will yield the result shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生以下截图所示的结果：
- en: "![Figure 2.6 – A custom Jinja filter for the d\uFEFFisplay of currency](img/B19111_02_6.jpg)"
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 用于显示货币的自定义Jinja过滤器](img/B19111_02_6.jpg)'
- en: Figure 2.6 – A custom Jinja filter for the display of currency
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 用于显示货币的自定义Jinja过滤器
- en: See also
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Implementing block composition and layout inheritance* recipe earlier in
    this chapter will aid your understanding of the context of this recipe regarding
    product and category logic.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面关于*实现块组合和布局继承*的菜谱将有助于你理解本菜谱中关于产品和类别逻辑的上下文。
- en: Creating a custom macro for forms
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为表单创建自定义宏
- en: Macros allow us to write reusable pieces of HTML blocks. They are analogous
    to functions in regular programming languages. We can pass arguments to macros
    as we do with functions in Python, and we can then use them to process an HTML
    block. Macros can be called any number of times, and the output will vary as per
    the logic inside them. In this recipe, let’s understand how to write a macro in
    Jinja.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 宏允许我们编写可重用的HTML块。它们类似于常规编程语言中的函数。我们可以像在Python中的函数一样向宏传递参数，然后我们可以使用它们来处理HTML块。宏可以被调用任意次数，输出将根据它们内部的逻辑而变化。在这个菜谱中，让我们了解如何在Jinja中编写宏。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Macros in Jinja are a very common topic and have a lot of use cases. Here, we
    will just take a look at how a macro can be created and then used after importing
    it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja中的宏是一个非常常见的话题，并且有很多用例。在这里，我们只看看如何创建宏并在导入后使用它。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: One of the most redundant pieces of code in HTML is that which defines input
    fields in forms. This is because most fields have similar code with maybe some
    style modifications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: HTML中最冗余的代码之一是定义表单中输入字段的代码。这是因为大多数字段具有相似的代码，可能只是进行了一些样式修改。
- en: 'The following snippet is a macro that creates input fields when invoked. The
    best practice is to create the macro in a separate file for better reusability
    – for example, `_helpers.html`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个宏示例，当调用时会创建输入字段。最佳实践是将宏创建在单独的文件中以提高可重用性——例如，`_helpers.html`：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Information
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The minus sign (`-`) before and after `%` will strip the whitespace before and
    after these blocks, making the HTML code cleaner to read.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`%` 前后的减号 (`-`) 会去除这些块前后空白，使 HTML 代码更易于阅读。'
- en: 'Now, the macro should be imported into the file to be used, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应将宏导入到要使用的文件中，如下所示：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It can now be called using the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用以下代码调用它：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is always good practice to define macros in a different file to keep the
    code clean and increase code readability.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将宏定义在不同的文件中是一种良好的实践，这样可以保持代码整洁并提高代码的可读性。
- en: Tip
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need to write a private macro that cannot be accessed from outside its
    current file, name the macro with an underscore preceding the name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要编写一个不能从当前文件外部访问的私有宏，请使用名称前带有下划线的宏名称。
- en: Advanced date and time formatting
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级日期和时间格式化
- en: Date and time formatting is a painful thing to handle in web applications. Such
    formatting in Python, using the `datetime` library, often increases overhead and
    is pretty complex when it comes to the correct handling of time zones. It is a
    best practice to standardize timestamps to UTC when they are stored in a database,
    but this means that the timestamp needs to be processed every time it is presented
    to users around the world.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序中处理日期和时间格式化是一件痛苦的事情。在 Python 中使用 `datetime` 库进行此类格式化通常会增加开销，并且当涉及到正确处理时区时相当复杂。当在数据库中存储时间戳时，将时间戳标准化为
    UTC 是一种最佳实践，但这意味着每次向全球用户展示时间戳时都需要处理它。
- en: Instead, it is smarter to defer this processing to the client side – that is,
    the browser. The browser always knows the current time zone of its user and will,
    therefore, be able to manipulate the date and time information correctly. This
    approach also reduces any unnecessary overhead from the application servers. In
    this recipe, we will understand how to achieve this. We will use `Moment.js` for
    this purpose.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，将此处理推迟到客户端——即浏览器——会更智能。浏览器始终知道其用户的当前时区，因此将能够正确地操作日期和时间信息。这种方法还可以减少应用程序服务器上的任何不必要的开销。在本食谱中，我们将了解如何实现这一点。我们将使用
    `Moment.js` 来完成此目的。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`Moment.js` can be included in our app just like any JS library. We just have
    to download and place the JS file, `moment.min.js`, in the `static/js` folder.
    The `Moment.js` file can be downloaded from [http://momentjs.com/](http://momentjs.com/).
    This file can then be used in an HTML file by adding the following statement along
    with other JavaScript libraries:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Moment.js` 可以像任何 JS 库一样包含在我们的应用程序中。我们只需下载并将 JS 文件 `moment.min.js` 放置在 `static/js`
    文件夹中。`Moment.js` 文件可以从 [http://momentjs.com/](http://momentjs.com/) 下载。然后，可以通过在
    HTML 文件中添加以下语句以及其他 JavaScript 库来使用此文件：'
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The basic usage of `Moment.js` is shown in the following code. This can be
    done in the browser console for JavaScript:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Moment.js` 的基本用法如下所示。这可以在浏览器控制台中为 JavaScript 执行：'
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To use `Moment.js` in an application, please follow the required steps.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中使用 `Moment.js`，请遵循所需的步骤。
- en: 'First, write a wrapper in Python and use it via the Jinja environment variables,
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 Python 中编写一个包装器，并通过 Jinja 环境变量使用它，如下所示：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can add as many `Moment.js` methods as you want to parse to the preceding
    class, as and when they’re needed. Now, in your `app.py` file, set the following
    created class to the Jinja environment variables:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要添加任意多的 `Moment.js` 方法到前面的类中。现在，在你的 `app.py` 文件中，将以下创建的类设置为 Jinja 环境变量：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can now use the class in templates, as shown in the following example.
    Make sure that `timestamp` is an instance of a JavaScript `date` object:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在模板中使用这个类，如下面的示例所示。确保 `timestamp` 是一个 JavaScript `date` 对象的实例：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The output of the preceding HTML is shown in the following screenshot. Note
    how the formatting varies for each statement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面 HTML 的输出。注意每个语句的格式如何不同。
- en: "![Figure 2.7 – Datetim\uFEFFe formatting using momentjs](img/B19111_02_7.jpg)"
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 使用 momentjs 格式化日期时间](img/B19111_02_7.jpg)'
- en: Figure 2.7 – Datetime formatting using momentjs
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 使用 momentjs 格式化日期时间
- en: There’s more…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: You can read more about the `Moment.js` library at [http://momentjs.com/](http://momentjs.com/).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://momentjs.com/](http://momentjs.com/)了解更多关于`Moment.js`库的信息。
