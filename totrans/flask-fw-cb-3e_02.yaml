- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templating with Jinja
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover the basics of **Jinja** templating from the perspective
    of Flask. We will also learn how to design and develop applications with modular
    and extensible templates.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: If you have followed Flask or Jinja or this book’s previous editions, you might
    have noticed that, previously, this templating library was called *Jinja2*. The
    latest version of Jinja at the time of writing is version 3, and the authors/community
    have decided to call it just *Jinja* instead of confusingly continuing with Jinja2,
    Jinja3, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Flask, we can write a complete web application without the need for a third-party
    templating engine. For example, have a look at the following code; this is a standalone,
    simple Hello World application with a bit of HTML styling included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Is the preceding pattern of application writing feasible in the case of large
    applications that involve thousands of lines of HTML, JS, and CSS code? In my
    opinion, no!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, templating offers a solution because it allows us to structure
    our views code by keeping our templates extensible and separate. Flask provides
    default support for Jinja, although we can use any templating engine that suits
    us. Furthermore, Jinja provides many additional features that make templates very
    powerful and modular.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the standard layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing block composition and layout inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom context processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom Jinja filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom macro for forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced date and time formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja is installed as a part of the standard Flask installation. There is no
    need to install it separately. For more details, refer to the *Setting up a virtual
    environment* section in [*Chapter 1*](B19111_01.xhtml#_idTextAnchor016).
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the standard layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the applications in Flask follow a specific pattern of laying out templates.
    In this recipe, we will implement the recommended way of structuring the layout
    of templates in a Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Flask expects templates to be placed inside a folder named `templates`
    at the application root level. If this folder is present, then Flask will automatically
    read the contents by making the contents of this folder available for use with
    the `render_template()` method, which we will use extensively throughout this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s demonstrate this with a small application. This application is very similar
    to the one we developed in [*Chapter 1*](B19111_01.xhtml#_idTextAnchor016), *Flask
    Configurations*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to add a new folder named `templates` under `my_app`.
    The application structure should look like the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to make some changes to the application. The `hello_world()` method
    in the `views` file, `my_app/hello/views.py`, should look like the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, we look for a URL query argument, `user`. If it is
    found, we use it, and if not, we use the default argument, `Shalabh`. Then, this
    value is passed to the context of the template to be rendered – that is, `index.html`
    – and the resulting template is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `my_app/templates/index.html` template can simply be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, if we open the `http://127.0.0.1:5000/hello` URL in a browser, we should
    see a response similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The first rendered template](img/B19111_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The first rendered template
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pass a URL argument with a value for the `user` key as `http://127.0.0.1:5000/hello?user=John`,
    we should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Serving custom content in the template](img/B19111_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Serving custom content in the template
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in `views.py`, the argument passed in the URL is fetched from
    the `request` object using `request.args.get('user')` and then passed to the context
    of the template being rendered, using `render_template`. The argument is then
    parsed using the Jinja placeholder, `{{ user }}`, to fetch the contents from the
    current value of the `user` variable from the template context. This placeholder
    evaluates all of the expressions placed inside it, depending on the template context.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The Jinja documentation can be found at [http://jinja.pocoo.org/](http://jinja.pocoo.org/).
    This will come in handy when writing templates.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing block composition and layout inheritance
  prefs: []
  type: TYPE_NORMAL
- en: Usually, any web application will have a number of web pages that are different
    from each other. However, code blocks such as headers and footers will appear
    the same on almost all pages throughout the site; likewise, the menu will remain
    the same. In fact, it is usually just the center container block that changes.
    For this, Jinja provides a great way of ensuring inheritance among templates.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, it’s a good practice to have a base template where the basic
    layout of the site, along with the header and footer, can be structured.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a small application that will have a home page
    and a product page (such as the ones we see on e-commerce stores). We will use
    the Bootstrap framework to give a minimalistic design and theme to our template.
    Bootstrap v5 can be downloaded from [http://getbootstrap.com/](http://getbootstrap.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of Bootstrap at the time of writing is v5\. Different versions
    of Bootstrap might cause the UI of an application to behave in different ways,
    but the core essence of Bootstrap remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity and focus on the topic at hand, we have created a
    hardcoded data store of a few products, which can be found in the `models.py`
    file. These are imported and read in `views.py` and are sent over to the template
    as template context variables, via the `render_template()` method. The rest of
    the parsing and display is handled by the templating language, which in our case
    is Jinja.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have a look at the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding layout, `static/css/bootstrap.min.css` and `static/js/bootstrap.bundle.min.js`
    are standard files that can be downloaded from the Bootstrap website mentioned
    in the *Getting ready* section. The `run.py` file remains the same, as always.
    The rest of the application-building process is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define the models in `my_app/product/models.py`. In this chapter, we
    will work on a simple, non-persistent key-value store. We will start with a few
    hardcoded product records made well in advance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next comes the views – that is, `my_app/product/views.py`. Here, we will follow
    the blueprint style to write the application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The `abort()` method comes in handy when you want to abort a request with a
    specific error message. Flask provides basic error message pages, which can be
    customized as needed. We will look at them in the *Creating custom 404 and 500
    handlers* recipe in [*Chapter 4*](B19111_04.xhtml#_idTextAnchor184), *Working*
    *with Views*.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the blueprint (`product`) that is passed in the `Blueprint` constructor
    will be appended to the endpoints defined in this blueprint. Do have a look at
    the `base.html` code for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the application’s configuration file, `my_app/__init__.py`, which
    should look like the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It is always possible to create your own custom CSS, which can add more flavor
    to the standard CSS provided by Bootstrap. To do this, add a bit of custom CSS
    code in `my_app/static/css/main.css`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When considering templates, it is always a good practice to create a base template
    to house the common code that can be inherited by all the other templates. Name
    this template `base.html` and place it in `my_app/templates/base.html`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Most of the preceding code contains normal HTML and Jinja evaluation placeholders,
    which we introduced in the previous recipe, *Bootstrapping the recommended layout*.
    An important point to note, however, is how the `url_for()` method is used for
    blueprint URLs. The blueprint name is appended to all endpoints. This becomes
    very useful when there are multiple blueprints inside one application, as some
    of them may have similar-looking URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the home page, `my_app/templates/home.html`, iterate over all the products
    and display them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the individual product page, `my_app/templates/product.html`,
    which should look like the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding template structure, there is an inheritance pattern being
    followed. The `base.html` file acts as the base template for all other templates.
    The `home.html` file inherits from `base.html`, and `product.html` inherits from
    `home.html`. In `product.html`, the `container` block is overwritten, which was
    first populated in `home.html`. When this app is run, we should see output similar
    to that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Iterating over blocks to create reusable content](img/B19111_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Iterating over blocks to create reusable content
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows how the home page will look. Note the URL in
    the browser. The product page should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.4 – Inheriting template blocks to cre\uFEFFate clean code](img/B19111_02_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Inheriting template blocks to create clean code
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom context processor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we might want to calculate or process a value directly in templates.
    Jinja maintains the notion that the processing of logic should be handled in views
    and not in templates, thereby keeping templates clean. A context processor becomes
    a handy tool in this case. With a context processor, we can pass our values to
    a method, which will then be processed in a Python method, and our resultant value
    will be returned. This is done by simply adding a function to the template context,
    thanks to Python allowing its users to pass functions like any other object. In
    this recipe, we’ll see how to write a custom context processor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write a custom context processor, follow the steps described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first display the descriptive name of the product in the `Category /
    Product-name` format. Afterward, add the method to `my_app/product/views.py`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A context is simply a dictionary that can be modified to add or remove values.
    Any method decorated with `@product_blueprint.context_processor` should return
    a dictionary that updates the actual context. We can use the preceding context
    processor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add the preceding code to our app for the product listing (in the `flask_app/my_app/templates/product.html`
    file) in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting parsed HTML page should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – A custom context processor for the product name](img/B19111_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – A custom context processor for the product name
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at the *Implementing block composition and layout inheritance* recipe
    earlier in this chapter to understand the context of this recipe better regarding
    the product and category logic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom Jinja filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After looking at the previous recipe, experienced developers might wonder why
    we used a context processor for the purpose of creating a well-formatted product
    name. Well, we can also write a filter for the same purpose, which will make things
    much cleaner. A filter can be written to display the descriptive name of a product,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will yield a similar result as in the previous recipe. Moving
    on, let’s now take things to a higher level by using external libraries to format
    currency.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s create a filter to format a currency based on the current local
    language. Add the following code to `my_app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: '`request.accept_languages` might not work in cases where a request does not
    have the `ACCEPT-LANGUAGES` header.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding snippet will require the installation of a new package, `ccy`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The filter created in this example takes the language that best matches the
    current browser locale (which, in my case, is `en-US`), takes the last two characters
    from the locale string, and then generates the currency as per the ISO country
    code, which is represented by two characters.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: An interesting point to note in this recipe is that the Jinja filter can be
    created at the blueprint level as well as at the application level. If the filter
    is at the blueprint level, the decorator would be `app_template_filter`; otherwise,
    at the application level, the decorator would be `template_filter`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The filter can be used in our template for the product as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will yield the result shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.6 – A custom Jinja filter for the d\uFEFFisplay of currency](img/B19111_02_6.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – A custom Jinja filter for the display of currency
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Implementing block composition and layout inheritance* recipe earlier in
    this chapter will aid your understanding of the context of this recipe regarding
    product and category logic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom macro for forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros allow us to write reusable pieces of HTML blocks. They are analogous
    to functions in regular programming languages. We can pass arguments to macros
    as we do with functions in Python, and we can then use them to process an HTML
    block. Macros can be called any number of times, and the output will vary as per
    the logic inside them. In this recipe, let’s understand how to write a macro in
    Jinja.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Macros in Jinja are a very common topic and have a lot of use cases. Here, we
    will just take a look at how a macro can be created and then used after importing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most redundant pieces of code in HTML is that which defines input
    fields in forms. This is because most fields have similar code with maybe some
    style modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet is a macro that creates input fields when invoked. The
    best practice is to create the macro in a separate file for better reusability
    – for example, `_helpers.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The minus sign (`-`) before and after `%` will strip the whitespace before and
    after these blocks, making the HTML code cleaner to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the macro should be imported into the file to be used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It can now be called using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is always good practice to define macros in a different file to keep the
    code clean and increase code readability.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you need to write a private macro that cannot be accessed from outside its
    current file, name the macro with an underscore preceding the name.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced date and time formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Date and time formatting is a painful thing to handle in web applications. Such
    formatting in Python, using the `datetime` library, often increases overhead and
    is pretty complex when it comes to the correct handling of time zones. It is a
    best practice to standardize timestamps to UTC when they are stored in a database,
    but this means that the timestamp needs to be processed every time it is presented
    to users around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it is smarter to defer this processing to the client side – that is,
    the browser. The browser always knows the current time zone of its user and will,
    therefore, be able to manipulate the date and time information correctly. This
    approach also reduces any unnecessary overhead from the application servers. In
    this recipe, we will understand how to achieve this. We will use `Moment.js` for
    this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Moment.js` can be included in our app just like any JS library. We just have
    to download and place the JS file, `moment.min.js`, in the `static/js` folder.
    The `Moment.js` file can be downloaded from [http://momentjs.com/](http://momentjs.com/).
    This file can then be used in an HTML file by adding the following statement along
    with other JavaScript libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic usage of `Moment.js` is shown in the following code. This can be
    done in the browser console for JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use `Moment.js` in an application, please follow the required steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, write a wrapper in Python and use it via the Jinja environment variables,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add as many `Moment.js` methods as you want to parse to the preceding
    class, as and when they’re needed. Now, in your `app.py` file, set the following
    created class to the Jinja environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use the class in templates, as shown in the following example.
    Make sure that `timestamp` is an instance of a JavaScript `date` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The output of the preceding HTML is shown in the following screenshot. Note
    how the formatting varies for each statement.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.7 – Datetim\uFEFFe formatting using momentjs](img/B19111_02_7.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Datetime formatting using momentjs
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can read more about the `Moment.js` library at [http://momentjs.com/](http://momentjs.com/).
  prefs: []
  type: TYPE_NORMAL
