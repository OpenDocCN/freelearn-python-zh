<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfacing with Technology</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Automating your home with remotely controlled electrical sockets</li>
<li>Using SPI to control an LED matrix</li>
<li>Communicating using a serial interface</li>
<li>Controlling Raspberry Pi using Bluetooth</li>
<li>Controlling USB devices</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>One of the key aspects of Raspberry Pi that differentiates it from an average computer is its ability to interface with and control hardware. In this chapter, we use Raspberry Pi to control remotely activated mains sockets, send commands over serial connections from another computer, and control the GPIO remotely. We make use of SPI (another useful protocol) to drive an 8 x 8 LED matrix display.</p>
<p>We also use a Bluetooth module to connect with a smartphone, allowing information to be transferred wirelessly between devices. Finally, we take control of USB devices by tapping into the commands sent over USB.</p>
<div class="packt_infobox">Be sure to check out the <em>Hardware list</em> section in the <span class="ChapterrefPACKT">Appendix</span>, <em>Hardware and Software List</em>; it lists all the items used in this chapter and the places you can obtain them from.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Automating your home with remotely controlled electrical sockets</h1>
                </header>
            
            <article>
                
<p>Raspberry Pi can make an excellent tool for home automation by providing accurate timing, control, and the ability to respond to commands, button inputs, environmental sensors, or messages from the internet.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Great care must be taken when controlling devices that use electricity from the mains, because high voltage and currents are often involved.</p>
<div class="packt_infobox">Never attempt to modify or alter devices that are connected to mains electricity without proper training. You must never directly connect any homemade devices to the mains supply. All electronics must undergo rigorous safety testing to ensure that there will be no risk or harm to people or property in the event of a failure.</div>
<p>In this example, we will use remote-controlled <strong>radio frequency</strong> (<strong>RF</strong>) plug-in sockets; these use a separate remote unit to send a specific RF signal to switch any electrical device that is plugged into it on or off. This allows us to modify the remote control and use Raspberry Pi to activate the switches safely, without interfering with dangerous voltage:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/f157e836-9b25-4b59-b943-4385f5d8472b.png" style="width:34.42em;height:13.17em;" width="1319" height="505"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Remote control and remote mains socket</div>
<p>The particular remote control used in this example has six buttons on it to directly switch three different sockets on or off and is powered by a 12V battery. It can be switched into four different channels, which allows you to control a total of 12 sockets (each socket has a similar selector that will be used to set the signal it will respond to):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/4172e58f-4bf5-4714-938a-c643c00c6e48.png" style="width:38.92em;height:30.42em;" width="800" height="626"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Inside the remote control</div>
<p>The remote buttons, when pressed, will broadcast a specific RF signal (this one uses a transmission frequency of 433.92 MHz). This will trigger any socket(s) that are set to the corresponding channel (A, B, C, or D) and number (1, 2, or 3).</p>
<p>Internally, each of the buttons connects two separate signals to ground, the number (1, 2,<br/>
or 3), and state (on or off). This triggers the correct broadcast that is to be made by the remote control:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/38875392-df46-4627-bd70-098b26c51b77.png" style="width:37.17em;height:24.08em;" width="1116" height="723"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Connect the wires to ON and OFF, 1, 2, and 3, and GND at suitable points on the remote's PCB (only ON, OFF, 1, and GND are connected in the image)</div>
<p>It is recommended that you do not connect anything to your sockets that could cause a hazard if switched on or off. The signals sent by the remote are not unique (there are only four different channels available). This therefore makes it possible for someone else nearby who has a similar set of sockets to unknowingly activate/deactivate one of your sockets. It is recommended that you select a channel other than the default, A, which will slightly reduce the chance of someone else accidentally using the same channel.</p>
<p>To allow Raspberry Pi to simulate the button presses of the remote, we will need five<br/>
relays to allow us to select the number (1, 2, or 3) and state (on or off):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/033eb712-9704-4532-927d-64cdac423a59.png" style="width:36.25em;height:29.17em;" width="700" height="564"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A prebuilt relay module can be used to switch the signals</div>
<p>Alternatively, the transistor and relay circuit from <a href="df3bebe6-c2d8-492c-92bb-298cc2bf49d9.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 12</span></a>, <em>Building Robots</em>, can be used to simulate the button presses.</p>
<p>Wire the relay control pins to the Raspberry Pi GPIO and connect the socket remote control to each relay output as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/a9183efb-b4a0-4d7e-b8a9-36dcf7e75f8a.png" style="width:41.58em;height:30.58em;" width="1023" height="752"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The socket remote control circuit</div>
<div class="packt_infobox">Although the remote socket requires both the number (1, 2, or 3) and the state (on or off) to activate a socket, it is the state signal that activates the RF transmission. To avoid draining the remote's battery, we must ensure that we have turned off the state signal.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create the following <kbd>socketControl.py</kbd> script:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
# socketControl.py 
import time 
import RPi.GPIO as GPIO 
#HARDWARE SETUP 
# P1 
# 2[V=G====XI====]26[=======]40 
# 1[=====321=====]25[=======]39 
#V=5V  G=Gnd 
sw_num=[15,13,11]#Pins for Switch 1,2,3 
sw_state=[16,18]#Pins for State X=Off,I=On 
MSGOFF=0; MSGON=1 
SW_ACTIVE=0; SW_INACTIVE=1 
 
class Switch(): 
  def __init__(self): 
    self.setup() 
  def __enter__(self): 
    return self 
  def setup(self): 
    print("Do init") 
    #Setup the wiring 
    GPIO.setmode(GPIO.BOARD) 
    for pin in sw_num: 
      GPIO.setup(pin,GPIO.OUT) 
    for pin in sw_state: 
      GPIO.setup(pin,GPIO.OUT) 
    self.clear() 
  def message(self,number,state): 
    print ("SEND SW_CMD: %s %d" % (number,state)) 
    if state==MSGON: 
      self.on(number) 
    else: 
      self.off(number) 
  def on(self,number): 
    print ("ON: %d"% number) 
    GPIO.output(sw_num[number-1],SW_ACTIVE) 
    GPIO.output(sw_state[MSGON],SW_ACTIVE) 
    GPIO.output(sw_state[MSGOFF],SW_INACTIVE) 
    time.sleep(0.5) 
    self.clear() 
  def off(self,number): 
    print ("OFF: %d"% number) 
    GPIO.output(sw_num[number-1],SW_ACTIVE) 
    GPIO.output(sw_state[MSGON],SW_INACTIVE) 
    GPIO.output(sw_state[MSGOFF],SW_ACTIVE) 
    time.sleep(0.5) 
    self.clear() 
  def clear(self): 
    for pin in sw_num: 
      GPIO.output(pin,SW_INACTIVE) 
    for pin in sw_state: 
      GPIO.output(pin,SW_INACTIVE) 
  def __exit__(self, type, value, traceback): 
    self.clear() 
    GPIO.cleanup() 
def main(): 
  with Switch() as mySwitches: 
    mySwitches.on(1) 
    time.sleep(5) 
    mySwitches.off(1)   
     
if __name__ == "__main__": 
    main() 
#End </pre>
<p style="padding-left: 60px">The socket control script performs a quick test by switching the first socket on for 5 seconds and then turning it off again.</p>
<ol start="2">
<li>To control the rest of the sockets, create a GUI menu as follows:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/5273a07c-480a-432f-9047-e5f063374e78.png" style="width:16.50em;height:14.67em;" width="263" height="234"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Remote Switches GUI</div>
<ol start="3">
<li>Create the following <kbd>socketMenu.py</kbd> script:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
#socketMenu.py 
import tkinter as TK 
import socketControl as SC 
 
#Define Switches ["Switch name","Switch number"] 
switch1 = ["Living Room Lamp",1] 
switch2 = ["Coffee Machine",2] 
switch3 = ["Bedroom Fan",3] 
sw_list = [switch1,switch2,switch3] 
SW_NAME = 0; SW_CMD  = 1 
SW_COLOR=["gray","green"] 
 
class swButtons: 
  def __init__(self,gui,sw_index,switchCtrl): 
    #Add the buttons to window 
    self.msgType=TK.IntVar() 
    self.msgType.set(SC.MSGOFF) 
    self.btn = TK.Button(gui, 
                  text=sw_list[sw_index][SW_NAME], 
                  width=30, command=self.sendMsg, 
                  bg=SW_COLOR[self.msgType.get()]) 
    self.btn.pack() 
    msgOn = TK.Radiobutton(gui,text="On", 
              variable=self.msgType, value=SC.MSGON) 
    msgOn.pack() 
    msgOff = TK.Radiobutton(gui,text="Off", 
              variable=self.msgType,value=SC.MSGOFF) 
    msgOff.pack() 
    self.sw_num=sw_list[sw_index][SW_CMD] 
    self.sw_ctrl=switchCtrl 
  def sendMsg(self): 
    print ("SW_CMD: %s %d" % (self.sw_num, 
                              self.msgType.get())) 
    self.btn.configure(bg=SW_COLOR[self.msgType.get()]) 
    self.sw_ctrl.message(self.sw_num, 
                         self.msgType.get()) 
 
root = TK.Tk() 
root.title("Remote Switches") 
prompt = "Control a switch" 
label1 = TK.Label(root, text=prompt, width=len(prompt), 
                  justify=TK.CENTER, bg='lightblue') 
label1.pack() 
#Create the switch 
with SC.Switch() as mySwitches: 
  #Create menu buttons from sw_list 
  for index, app in enumerate(sw_list): 
    swButtons(root,index,mySwitches) 
  root.mainloop() 
#End </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The first script defines a class called <kbd>Switch</kbd>; it sets up the GPIO pins required to control the five relays (within the <kbd>setup</kbd> function). It also defines the <kbd>__enter__</kbd> and <kbd>__exit__</kbd> functions, which are special functions used by the <kbd>with..as</kbd> statement. When a class is created using <kbd>with..as</kbd>, it uses <kbd>__enter__</kbd> to perform any extra initialization or setup (if required), and then it performs any cleanup by calling <kbd>__exit__</kbd>. When the <kbd>Switch</kbd> class has been executed, all the relays are switched off to preserve the remote's battery and <kbd>GPIO.cleanup()</kbd> is called to release the GPIO pins. The parameters of the <kbd>__exit__</kbd> function (<kbd>type</kbd>, <kbd>value</kbd>, and <kbd>traceback</kbd>) allow the handling of any specific exceptions that may have occurred when the class was being executed within the <kbd>with..as</kbd> statement (if required).</p>
<p>To control the sockets, create two functions that will switch the relevant relays on or off to activate the remote control to send the required signal to the sockets. Then, shortly after, turn the relays off again using <kbd>clear()</kbd>. To make controlling the switches even easier, create a <kbd>message</kbd> function that will allow a switch number and state to be specified.</p>
<p>We make use of the <kbd>socketControl.py</kbd> script by creating a Tkinter GUI menu. The menu is made up of three sets of controls (one for each of the switches) that are defined by the <kbd>swButtons</kbd> class.</p>
<p>The <kbd>swButtons</kbd> class creates a <kbd>Tkinter</kbd> button and two <kbd>Radiobutton</kbd> controls. Each <kbd>swButtons</kbd> object is given an index and a reference to the <kbd>mySwitches</kbd> object. This allows us to set a name for the button and control a particular switch when it is pressed. The socket is activated/deactivated by calling <kbd>message()</kbd>, with the required switch number and state set by the <kbd>Radiobutton</kbd> controls.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The previous example allows you to rewire the remotes of most remote-controlled sockets, but another option is to emulate the signals to control it directly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending RF control signals directly</h1>
                </header>
            
            <article>
                
<p>Instead of rewiring the remote control, you can replicate the remote's RF signals using a transmitter that uses the same frequency as your sockets (these particular units use 433.94 MHz). This will depend on the particular sockets and sometimes your location – some countries prohibit the use of certain frequencies – as you may require certification before making your own transmissions:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/3029bc19-2d83-4b74-a964-ca2c2e6e078d.png" style="width:37.50em;height:18.25em;" width="1000" height="486"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The 433.94 MHz RF transmitter (left) and receiver (right)</div>
<p>The signals sent by the RF remote control can be recreated using 433Utils created by<br/>
<a href="http://ninjablocks.com"><span class="URLPACKT">http://ninjablocks.com</span></a>. The 433Utils uses WiringPi and is written in C++, allowing high speed capture and replication of the RF signals.</p>
<p>Obtain the code using the following command:</p>
<pre><strong>cd ~</strong>
<strong>wget https://github.com/ninjablocks/433Utils/archive/master.zip</strong>
<strong>unzip master.zip</strong>  </pre>
<p>Next, we need to wire up our RF transmitter (so we can control the switches) and RF receiver (so we can determine the control codes) to the Raspberry Pi.</p>
<p>The transmitter (the smaller square module) has three pins, which are power (VCC), ground (GND), and data out (DATA). The voltage supplied on the power pin will govern the transmission range (we will use a 5V supply from Raspberry Pi, but you could replace this with 12V, as long as you ensure you connect the ground pin to both your 12V supply and Raspberry Pi).</p>
<p>Although the receiver has four pins, there is a power pin (VCC), ground pin (GND), and two data out pins (DATA), which are wired together, so we only need to connect three wires to Raspberry Pi:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>RF Tx</strong></p>
</td>
<td>
<p><strong>RPi GPIO pin</strong></p>
</td>
<td>
<p><strong>RF Rx</strong></p>
</td>
<td>
<p><strong>RPi GPIO pin</strong></p>
</td>
</tr>
<tr>
<td>
<p>VCC (5V)</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>VCC (3V3)</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p>Data out</p>
</td>
<td>
<p>11</p>
</td>
<td>
<p>Data in</p>
</td>
<td>
<p>13</p>
</td>
</tr>
<tr>
<td>
<p>GND</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>GND</p>
</td>
<td>
<p>9</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Before we use the programs within the <kbd>RPi_Utils</kbd>, we will make a few adjustments to ensure our RX and TX pins are set correctly.</p>
<p>Locate <kbd>codesend.cpp</kbd> in <kbd>433Utils-master/RPi_utils/</kbd> to make the required changes:</p>
<pre><strong>cd ~/433Utils-master/RPi_utils</strong>
<strong>nano codesend.cpp -c</strong>  </pre>
<p>Change <kbd>int PIN = 0;</kbd> (located at around line 24) to <kbd>int PIN = 11;</kbd> (RPi physical<br/>
pin number).</p>
<p>Change <kbd>wiringPi</kbd> to use physical pin numbering (located around line 27) by replacing <kbd>wiringPiSetup()</kbd> with <kbd>wiringPiSetupPhy()</kbd>. Otherwise, the default is <kbd>wiringPi</kbd> GPIO numbers; for more details, see <a href="http://wiringpi.com/reference/setup/"><span class="URLPACKT">http://wiringpi.com/reference/setup/</span></a>. Find the following line:</p>
<pre>if (wiringPiSetup () == -1) return 1; </pre>
<p>Change it to this:</p>
<pre>if (wiringPiSetupPhys () == -1) return 1; </pre>
<p>Save and exit <kbd>nano</kbd> using <em>Ctrl</em> + <em>X</em>, <em>Y</em>.</p>
<p>Make similar adjustments to <kbd>RFSniffer.cpp</kbd>:</p>
<pre><strong>nano RFSniffer.cpp -c</strong>  </pre>
<p>Find the following line (located at around line 25):</p>
<pre>int PIN = 2; </pre>
<p>Change it to this:</p>
<pre>int PIN = 13; //RPi physical pin number </pre>
<p>Find the following line (located at around line 27):</p>
<pre>if(wiringPiSetup() == -1) { </pre>
<p>Change it to this:</p>
<pre>if(wiringPiSetupPhys() == -1) { </pre>
<p>Save and exit <kbd>nano</kbd> using <em>Ctrl</em> + <em>X</em>, <em>Y</em>.</p>
<p>Build the code using the following command:</p>
<pre><strong>make all</strong>  </pre>
<p>This should build without errors, as shown here:</p>
<pre><strong>g++    -c -o codesend.o codesend.cpp</strong>
<strong>g++   RCSwitch.o codesend.o -o codesend -lwiringPi</strong>
<strong>g++    -c -o RFSniffer.o RFSniffer.cpp</strong>
<strong>g++   RCSwitch.o RFSniffer.o -o RFSniffer -lwiringPi</strong>  </pre>
<p>Now that we have our RF modules connected to Raspberry Pi and our code ready, we can capture the control signals from our remote. Run the following command and take note of the reported output:</p>
<pre><strong>sudo ./RFSniffer</strong>  </pre>
<p>Get the output by switching button 1 OFF with the remote set to channel A (note that we may pick up some random noise):</p>
<pre><strong>Received 1381716</strong>
<strong>Received 1381716</strong>
<strong>Received 1381716</strong>
<strong>Received 1381717</strong>
<strong>Received 1398103</strong>  </pre>
<p>We can now send out the signals using the <kbd>sendcode</kbd> command to switch the sockets OFF (<kbd>1381716</kbd>) and ON (<kbd>1381719</kbd>):</p>
<pre><strong>sendcode 1381716</strong>
<strong>sendcode 1381719</strong>  </pre>
<p>You could even set up Raspberry Pi to use the receiver module to detect signals from the remote (on an unused channel) and to act upon them to start processes, control other hardware, or perhaps trigger a software shutdown/reboot.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Extending the range of the RF transmitter</h1>
                </header>
            
            <article>
                
<p>The range of the transmitter is very limited when it is powered by 5V and without an additional antenna. However, it is worth testing everything before you make any modifications.</p>
<p>Simple wire antenna can be made from 25 cm of single core wire, 17 mm side connected to the antenna solder point, then 16 turns (made using a thin screwdriver shaft or similar) and the remaining wire on top (approximately 53 mm):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/23e8cd0a-11fe-46ab-b349-65ec56983419.png" style="width:35.25em;height:15.25em;" width="1000" height="432"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The transmitter range is vastly improved with a simple antenna</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Determining the structure of the remote control codes</h1>
                </header>
            
            <article>
                
<p>Recording the codes for each of the buttons, we can determine the codes for each (and break down the structure):</p>
<table>
<tbody>
<tr>
<td>
<p> </p>
</td>
<td colspan="6">
<p><strong>1</strong></p>
</td>
<td colspan="6">
<p><strong>2</strong></p>
</td>
<td colspan="6">
<p><strong>3</strong></p>
</td>
</tr>
<tr>
<td>
<p> </p>
</td>
<td colspan="3">
<p><strong>ON</strong></p>
</td>
<td colspan="3">
<p><strong>OFF</strong></p>
</td>
<td colspan="3">
<p><strong>ON</strong></p>
</td>
<td colspan="3">
<p><strong>OFF</strong></p>
</td>
<td colspan="3">
<p><strong>ON</strong></p>
</td>
<td colspan="3">
<p><strong>OFF</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>A</strong></p>
</td>
<td colspan="3">
<p><kbd>0x15 15 57</kbd></p>
<p><kbd>(1381719)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x15 15 54</kbd></p>
<p><kbd>(1381716)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x15 45 57</kbd></p>
<p><kbd>(1394007)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x15 45 54</kbd></p>
<p><kbd>(1394004)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x15 51 57</kbd></p>
<p><kbd>(1397079)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x15 51 54</kbd></p>
<p><kbd>(1397076)</kbd></p>
</td>
</tr>
<tr>
<td>
<p><strong>B</strong></p>
</td>
<td colspan="3">
<p><kbd>0x45 15 57</kbd></p>
<p><kbd>(4527447)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x45 15 54</kbd></p>
<p><kbd>(4527444)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x45 45 57</kbd></p>
<p><kbd>(4539735)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x45 45 54</kbd></p>
<p><kbd>(4539732)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x45 51 57</kbd></p>
<p><kbd>(4542807)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x45 51 54</kbd></p>
<p><kbd>(4542804)</kbd></p>
</td>
</tr>
<tr>
<td>
<p><strong>C</strong></p>
</td>
<td colspan="3">
<p><kbd>0x51 15 57</kbd></p>
<p><kbd>(5313879)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x51 15 54</kbd></p>
<p><kbd>(5313876)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x51 45 57</kbd></p>
<p><kbd>(5326167)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x51 45 54</kbd></p>
<p><kbd>(5326164)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x51 51 57</kbd></p>
<p><kbd>(5329239)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x51 51 54</kbd></p>
<p><kbd>(5329236)</kbd></p>
</td>
</tr>
<tr>
<td>
<p><strong>D</strong></p>
</td>
<td colspan="3">
<p><kbd>0x54 15 57</kbd></p>
<p><kbd>(5510487)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x54 15 57</kbd></p>
<p><kbd>(5510487)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x54 45 57</kbd></p>
<p><kbd>(5522775)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x54 45 54</kbd></p>
<p><kbd>(5522772)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x54 51 57</kbd></p>
<p><kbd>(5525847)</kbd></p>
</td>
<td colspan="3">
<p><kbd>0x54 51 54</kbd></p>
<p><kbd>(5526612)</kbd></p>
</td>
</tr>
<tr>
<td colspan="2">
<p><strong>A</strong></p>
</td>
<td>
<p><strong>B</strong></p>
</td>
<td colspan="2">
<p><strong>C</strong></p>
</td>
<td>
<p><strong>D</strong></p>
</td>
<td colspan="2">
<p><strong>1</strong></p>
</td>
<td>
<p><strong>2</strong></p>
</td>
<td colspan="2">
<p><strong>3</strong></p>
</td>
<td>
<p><strong>na</strong></p>
</td>
<td colspan="2">
<p><strong>na</strong></p>
</td>
<td>
<p><strong>na</strong></p>
</td>
<td colspan="2">
<p><strong>na</strong></p>
</td>
<td>
<p><strong>ON/OFF</strong></p>
</td>
<td>
<p> </p>
</td>
</tr>
<tr>
<td colspan="2">
<p>01</p>
</td>
<td>
<p>01</p>
</td>
<td colspan="2">
<p>01</p>
</td>
<td>
<p>01</p>
</td>
<td colspan="2">
<p>01</p>
</td>
<td>
<p>01</p>
</td>
<td colspan="2">
<p>01</p>
</td>
<td>
<p>01</p>
</td>
<td colspan="2">
<p>01</p>
</td>
<td>
<p>01</p>
</td>
<td colspan="2">
<p>01</p>
</td>
<td>
<p>11/00</p>
</td>
<td>
<p> </p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The different codes are shown in hex format to help you see the structure; the sendcode command uses the decimal format (shown within the parentheses)</div>
<p>To select channel A, B, C, or D, set the two bits to 00. Similarly, for button 1, 2, or 3, set the two bits to 00 to select that button. Finally, set the last two bits to 11 for ON or 00 for OFF.</p>
<p>See <a href="https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-for-your-arduino/"><span class="URLPACKT">https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-for-your-arduino/</span></a>, which analyses these and other similar RF remote controls.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using SPI to control an LED matrix</h1>
                </header>
            
            <article>
                
<p>In <a href="18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 10</span></a>, <em>Sensing and Displaying Real-World Data</em>, we connected to devices using a bus protocol called I<sup>2</sup>C. Raspberry Pi also supports another chip-to-chip protocol called <strong>Serial Peripheral Interface</strong> (<strong>SPI</strong>). The SPI bus differs from I<sup>2</sup>C because it uses two single direction data lines (where I<sup>2</sup>C uses one bidirectional data line).</p>
<p>Although SPI requires more wires (I<sup>2</sup>C uses two bus signals, SDA and SCL), it supports the simultaneous sending and receiving of data and much higher clock speeds than I<sup>2</sup>C:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/afdd071d-ff0c-4244-b67d-c6e54625ebb5.png" style="width:30.25em;height:14.50em;" width="1298" height="623"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">General connections of SPI devices with Raspberry Pi</div>
<p>The SPI bus consists of the following four signals:</p>
<ul>
<li><strong>SCLK</strong>: This allows the clock edges to read/write data on the input/output lines; it is driven by the master device. As the clock signal changes from one state to another, the SPI device will check the state of the MOSI signal to read a single bit. Similarly, if the SPI device is sending data, it will use the clock signal edges to synchronize when it sets the state of the MISO signal.</li>
<li><strong>CE</strong>: This refers to Chip Enable (typically, a separate Chip Enable is used for each slave device on the bus). The master device will set the Chip Enable signal to low for the device that it wants to communicate with. When the Chip Enable signal is set to high, it ignores any other signals on the bus. This signal is sometimes called <strong>Chip Select</strong> (<strong>CS</strong>) or <strong>Slave Select</strong> (<strong>SS</strong>).</li>
<li><strong><span>Master Output, Slave Input </span>(MOSI)</strong>: It connects to Data Out of the master device and Data In of the slave device.</li>
<li><strong><span>Master Input, Slave Output (</span>MISO)</strong>: It provides a response from the slave.</li>
</ul>
<p>The following diagram shows each of the signals:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/f412c562-9822-401e-b6b9-3d9246592b93.png" style="width:35.17em;height:14.33em;" width="591" height="241"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The SPI signals: SCLK (1), CE(2), MOSI(3), and MISO(4)</div>
<p>The previous scope trace shows two bytes being sent over SPI. Each byte is clocked into the SPI device using the <strong>SCLK (1)</strong> signal. A byte is signified by a burst of eight clock cycles (a low and then high period on the <strong>SCLK (1)</strong> signal), where the value of a specific bit is read when the clock state changes. The exact sample point is determined by the clock mode; in the following diagram, it is when the clock goes from low to high:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/0b4b046d-1e37-4fea-aa27-22c79ee2b224.png" style="width:32.00em;height:13.67em;" width="756" height="324"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The first data byte sent by Raspberry Pi to the SPI device using the MOSI(3) signal</div>
<p>The first byte sent is 0x01 (all the bits are low, except <strong>Bit 0</strong>) and the second sent is 0x03 (only <strong>Bit 1</strong> and <strong>Bit 0</strong> are high). At the same time, the <strong>MOSI (4)</strong> signal returns data from the SPI device-in this case, 0x08 (<strong>Bit 3</strong> is high) and 0x00 (all the bits are low). The <strong>SCLK (1)</strong> signal is used to sync everything, even the data being sent from the SPI device.</p>
<p>The <strong>CE (2)</strong> signal is held low while the data is being sent to instruct that particular SPI device to listen to the <strong>MOSI (4)</strong> signal. When the <strong>CE (2)</strong> signal is set to high again, it indicates to the SPI device that the transfer has been completed.</p>
<p>The following is an image of an 8 x 8 LED matrix that is controlled via the <strong>SPI Bus</strong>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/7f668052-ccd1-451a-9e01-811859262828.png" style="width:30.50em;height:14.75em;" width="1000" height="483"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">An 8 x 8 LED module displaying the letter K</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The <kbd>wiringPi</kbd> library that we used previously for I<sup>2</sup>C also supports SPI. Ensure that <kbd>wiringPi</kbd> is installed (see <a href="18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 10</span></a>, <em>Sensing and Displaying Real-World Data</em>, for details) so that we can use it here.</p>
<p>Next, we need to enable SPI if we didn't do so when we enabled I<sup>2</sup>C previously:</p>
<pre><strong>sudo nano /boot/config.txt</strong>  </pre>
<p>Remove the <kbd>#</kbd> before <kbd>#dtparam=spi=on</kbd> to enable it, so it reads, and save (<em>Ctrl</em> + <em>X</em>, <em>Y</em>, <em>Enter</em>):</p>
<pre><strong>dtparam=spi=on</strong>  </pre>
<p>You can confirm that the SPI is active by listing all the running modules using the following command and locating <kbd>spi_bcm2835</kbd>:</p>
<pre><strong>lsmod</strong>  </pre>
<p>You can test the SPI with the following <kbd>spiTest.py</kbd> script:</p>
<pre>#!/usr/bin/python3 
# spiTest.py 
import wiringpi 
 
print("Add SPI Loopback - connect GPIO Pin19 and Pin21") 
print("[Press Enter to continue]") 
input() 
wiringpi.wiringPiSPISetup(1,500000) 
buffer=str.encode("HELLO") 
print("Buffer sent %s" % buffer) 
wiringpi.wiringPiSPIDataRW(1,buffer) 
print("Buffer received %s" % buffer) 
print("Remove the SPI Loopback") 
print("[Press Enter to continue]") 
input() 
buffer=str.encode("HELLO") 
print("Buffer sent %s" % buffer) 
wiringpi.wiringPiSPIDataRW(1,buffer) 
print("Buffer received %s" % buffer) 
#End </pre>
<p>Connect inputs <strong>19</strong> and <strong>21</strong> to create an SPI loopback for testing:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/1fc6523a-7814-4fbd-8c0c-09e4dbc2af52.png" style="width:13.25em;height:11.25em;" width="323" height="275"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The SPI loopback test</div>
<p>You should get the following result:</p>
<pre><strong>Buffer sent b'HELLO'</strong>
<strong>Buffer received b'HELLO'</strong>
<strong>Remove the SPI Loopback</strong>
<strong>[Press Enter to continue]</strong>
<strong>Buffer sent b'HELLO'</strong>
<strong>Buffer received b'x00x00x00x00x00'</strong>  </pre>
<p>The example that follows uses an LED 8 x 8 matrix display that is being driven by an<br/>
SPI-controlled <strong>MAX7219 LED driver</strong>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/a18157d2-1ba5-449a-a279-3f5d5dfce1b5.png" style="width:10.75em;height:16.58em;" width="99" height="153"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">An LED Controller MAX7219 pin-out, LED matrix pin-out, and LED matrix internal wiring (left to right)</div>
<p>Although the device has been designed to control eight separate seven-segment LED digits, we can use it for our LED matrix display. When used for digits, each of the seven segments (plus a decimal place) is wired to one of the SEG pins and the COM connection of each of the digits is wired to the DIG pins. The controller then switches each of the segments on as required, while setting the relevant digit COM to low to enable it. The controller can quickly cycle through each of the digits using the DIG pin quickly enough that all eight appear to be lit at the same time:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/046af381-a802-4f12-a6a4-8187b2941489.png" style="width:10.17em;height:15.75em;" width="99" height="153"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A seven-segment LED digit uses segments A to G, plus DP (decimal place)</div>
<p>We use the controller in a similar way, except each SEG pin will connect to a column in the matrix and the DIG pins will enable/disable a row.</p>
<p>We use an 8 x 8 module connected to the MAX7219 chip as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/67c17366-1d28-48d8-a6a5-a64c97fe129a.png" style="width:41.08em;height:23.83em;" width="1393" height="809"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The MAX7219 LED controller driving an 8 x 8 LED matrix display</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>To control an LED matrix connected to an SPI MAX7219 chip, create the following <kbd>matrixControl.py</kbd> script:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
# matrixControl.py 
import wiringpi 
import time 
 
MAX7219_NOOP        = 0x00 
DIG0=0x01; DIG1=0x02; DIG2=0x03; DIG3=0x04 
DIG4=0x05; DIG5=0x06; DIG6=0x07; DIG7=0x08 
MAX7219_DIGIT=[DIG0,DIG1,DIG2,DIG3,DIG4,DIG5,DIG6,DIG7] 
MAX7219_DECODEMODE  = 0x09 
MAX7219_INTENSITY   = 0x0A 
MAX7219_SCANLIMIT   = 0x0B 
MAX7219_SHUTDOWN    = 0x0C 
MAX7219_DISPLAYTEST = 0x0F 
SPI_CS=1 
SPI_SPEED=100000 
 
class matrix(): 
  def __init__(self,DEBUG=False): 
    self.DEBUG=DEBUG 
    wiringpi.wiringPiSPISetup(SPI_CS,SPI_SPEED) 
    self.sendCmd(MAX7219_SCANLIMIT, 8)   # enable outputs 
    self.sendCmd(MAX7219_DECODEMODE, 0)  # no digit decode 
    self.sendCmd(MAX7219_DISPLAYTEST, 0) # display test off 
    self.clear() 
    self.brightness(7)                   # brightness 0-15 
    self.sendCmd(MAX7219_SHUTDOWN, 1)    # start display 
  def sendCmd(self, register, data): 
    buffer=(register&lt;&lt;8)+data 
    buffer=buffer.to_bytes(2, byteorder='big') 
    if self.DEBUG:print("Send byte: 0x%04x"% 
                        int.from_bytes(buffer,'big')) 
    wiringpi.wiringPiSPIDataRW(SPI_CS,buffer) 
    if self.DEBUG:print("Response:  0x%04x"% 
                        int.from_bytes(buffer,'big')) 
    return buffer 
  def clear(self): 
    if self.DEBUG:print("Clear") 
    for row in MAX7219_DIGIT: 
      self.sendCmd(row + 1, 0) 
  def brightness(self,intensity): 
    self.sendCmd(MAX7219_INTENSITY, intensity % 16) 
 
def letterK(matrix): 
    print("K") 
    K=(0x0066763e1e366646).to_bytes(8, byteorder='big') 
    for idx,value in enumerate(K): 
        matrix.sendCmd(idx+1,value) 
 
def main(): 
    myMatrix=matrix(DEBUG=True) 
    letterK(myMatrix) 
    while(1): 
      time.sleep(5) 
      myMatrix.clear()</pre>
<pre style="padding-left: 60px">      time.sleep(5) 
      letterK(myMatrix) 
 
if __name__ == '__main__': 
    main() 
#End </pre>
<p style="padding-left: 60px">Running the script (<kbd>python3 matrixControl.py</kbd>) displays the letter <kbd>K</kbd>.</p>
<ol start="2">
<li>We can use a GUI to control the output of the LED matrix using <kbd>matrixMenu.py</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
#matrixMenu.py 
import tkinter as TK 
import time 
import matrixControl as MC 
 
#Enable/Disable DEBUG 
DEBUG = True 
#Set display sizes 
BUTTON_SIZE = 10 
NUM_BUTTON = 8 
NUM_LIGHTS=NUM_BUTTON*NUM_BUTTON 
MAX_VALUE=0xFFFFFFFFFFFFFFFF 
MARGIN = 2 
WINDOW_H = MARGIN+((BUTTON_SIZE+MARGIN)*NUM_BUTTON) 
WINDOW_W = WINDOW_H 
TEXT_WIDTH=int(2+((NUM_BUTTON*NUM_BUTTON)/4)) 
LIGHTOFFON=["red4","red"] 
OFF = 0; ON = 1 
colBg = "black" 
 
def isBitSet(value,bit): 
  return (value&gt;&gt;bit &amp; 1) 
 
def setBit(value,bit,state=1): 
  mask=1&lt;&lt;bit 
  if state==1: 
    value|=mask 
  else: 
    value&amp;=~mask 
  return value 
 
def toggleBit(value,bit): 
  state=isBitSet(value,bit) 
  value=setBit(value,bit,not state) 
  return value 
 
class matrixGUI(TK.Frame): 
  def __init__(self,parent,matrix): 
    self.parent = parent 
    self.matrix=matrix 
    #Light Status 
    self.lightStatus=0 
    #Add a canvas area ready for drawing on 
    self.canvas = TK.Canvas(parent, width=WINDOW_W, 
                        height=WINDOW_H, background=colBg) 
    self.canvas.pack() 
    #Add some "lights" to the canvas 
    self.light = [] 
    for iy in range(NUM_BUTTON): 
      for ix in range(NUM_BUTTON): 
        x = MARGIN+MARGIN+((MARGIN+BUTTON_SIZE)*ix) 
        y = MARGIN+MARGIN+((MARGIN+BUTTON_SIZE)*iy) 
        self.light.append(self.canvas.create_rectangle(x,y, 
                              x+BUTTON_SIZE,y+BUTTON_SIZE, 
                              fill=LIGHTOFFON[OFF])) 
    #Add other items 
    self.codeText=TK.StringVar() 
    self.codeText.trace("w", self.changedCode) 
    self.generateCode() 
    code=TK.Entry(parent,textvariable=self.codeText, 
                  justify=TK.CENTER,width=TEXT_WIDTH) 
    code.pack() 
    #Bind to canvas not tk (only respond to lights) 
    self.canvas.bind('&lt;Button-1&gt;', self.mouseClick) 
   
  def mouseClick(self,event): 
    itemsClicked=self.canvas.find_overlapping(event.x, 
                             event.y,event.x+1,event.y+1) 
    for item in itemsClicked: 
      self.toggleLight(item) 
 
  def setLight(self,num): 
    state=isBitSet(self.lightStatus,num) 
    self.canvas.itemconfig(self.light[num], 
                           fill=LIGHTOFFON[state]) 
     
  def toggleLight(self,num): 
    if num != 0: 
      self.lightStatus=toggleBit(self.lightStatus,num-1) 
      self.setLight(num-1) 
      self.generateCode() 
 
  def generateCode(self): 
    self.codeText.set("0x%016x"%self.lightStatus) 
 
  def changedCode(self,*args): 
    updated=False 
    try: 
      codeValue=int(self.codeText.get(),16) 
      if(codeValue&gt;MAX_VALUE): 
        codeValue=codeValue&gt;&gt;4 
      self.updateLight(codeValue) 
      updated=True 
    except: 
      self.generateCode() 
      updated=False 
    return updated 
 
  def updateLight(self,lightsetting): 
    self.lightStatus=lightsetting 
    for num in range(NUM_LIGHTS): 
      self.setLight(num) 
    self.generateCode() 
    self.updateHardware() 
 
  def updateHardware(self): 
    sendBytes=self.lightStatus.to_bytes(NUM_BUTTON, 
                                        byteorder='big') 
    print(sendBytes) 
    for idx,row in enumerate(MC.MAX7219_DIGIT): 
      response = self.matrix.sendCmd(row,sendBytes[idx]) 
      print(response) 
 
def main(): 
  global root 
  root=TK.Tk() 
  root.title("Matrix GUI") 
  myMatrixHW=MC.matrix(DEBUG) 
  myMatrixGUI=matrixGUI(root,myMatrixHW) 
  TK.mainloop() 
     
if __name__ == '__main__': 
    main() 
#End</pre>
<ol start="3">
<li>The Matrix GUI allows us to switch each of the LEDs on/off by clicking on each of the squares (or by directly entering the hexadecimal value) to create the required pattern:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/24ec196a-5ac9-4b64-8920-4f0855eaeb4c.png" style="width:10.50em;height:9.50em;" width="150" height="137"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Using the Matrix GUI to control the 8 x 8 LED matrix</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Initially, we defined addresses for each of the control registers used by the MAX7219 device. View the datasheet at for more information:</p>
<p><a href="https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf" target="_blank">https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf</a>.</p>
<p>We created a class called <kbd>matrix</kbd> that will allow us to control the module. The <kbd>__init__()</kbd> function sets up the SPI of Raspberry Pi (using <kbd>SPI_CS</kbd> as pin 26 CS1 and <kbd>SPI_SPEED</kbd> as 100 kHz).</p>
<p>The key function in our <kbd>matrix</kbd> class is the <kbd>sendCmd()</kbd> function; it uses <kbd>wiringpi.wiringPiSPIDataRW(SPI_CS,buff)</kbd> to send <kbd>buffer</kbd> (which is the raw byte data that we want to send) over the SPI bus (while also setting the <kbd>SPI_CS</kbd> pin to low when the transfer occurs). Each command consists of two bytes: the first specifies the address of the register, and the second sets the data that needs to be put into it. To display a row of lights, we send the address of one of the <kbd>ROW</kbd> registers (<kbd>MC.MAX7219_DIGIT</kbd>) and the bit-pattern we want to display (as a byte).</p>
<div class="packt_infobox">After the <kbd>wiringpi.wiringPiSPIDataRW()</kbd> function is called, <kbd>buffer</kbd> contains the result of whatever is received on the MISO pin (which is read simultaneously as the data is sent via the MOSI pin). If connected, this will be the output of the LED module (a delayed copy of the data that was sent). Refer to the following <em>There's more...</em> section regarding daisy-chained SPI configurations to learn how the chip output can be used.</div>
<p>To initialize the MAX7219, we need to ensure that it is configured in the correct mode. First, we set the <span class="packt_screen">Scan Limit</span> field to <kbd>7</kbd> (which enables all the DIG0 - DIG7 outputs). Next, we disable the built-in digit decoding since we are using the raw output for the display (and don't want it to try to display digits). We also want to ensure that the <kbd>MAX7219_DISPLAYTEST</kbd> register is disabled (if enabled, it would turn on all the LEDs).</p>
<p>We ensure the display is cleared by calling our own <kbd>clear()</kbd> function, which sends <kbd>0</kbd><br/>
to each of the <kbd>MAX7219_DIGIT</kbd> registers to clear each of the rows. Finally, we use the <kbd>MAX7219_INTENSITY</kbd> register to set the brightness of the LEDs. The brightness is controlled using a PWM output to make the LEDs appear brighter or darker according to the brightness that is required.</p>
<p>Within the <kbd>main()</kbd> function, we perform a quick test to display the letter K on the grid by sending a set of 8 bytes (<kbd>0x0066763e1e366646</kbd>):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/7a631f4d-d84f-4dd3-a1d4-f49476f7735c.png" style="width:19.92em;height:19.08em;" width="639" height="610"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Each 8 x 8 pattern consists of 8 bits in 8 bytes (one bit for each column, making each byte a row in the display)</div>
<p>The <kbd>matrixGUI</kbd> class creates a canvas object that is populated with a grid of rectangle objects to represent the 8 x 8 grid of LEDs we want to control (these are kept in <kbd>self.light</kbd>). We also add a text entry box to display the resulting bytes that we will send to the LED matrix module. We then bind the <kbd>&lt;Button-1&gt;</kbd> mouse event to the canvas so that <kbd>mouseClick</kbd> is called whenever a mouse click occurs within the area of the canvas.</p>
<p>We attach a function called <kbd>changedCode()</kbd> to the <kbd>codeText</kbd> variable using <kbd>trace</kbd>, a special Python function, which allows us to monitor specific variables or functions. If we use the <kbd>'w'</kbd> value with the <kbd>trace</kbd> function, the Python system will call the <kbd>callback</kbd> function whenever the value is written to.</p>
<p>When the <kbd>mouseClick()</kbd> function is called, we use the <kbd>event.x</kbd> and <kbd>event.y</kbd> coordinates to identify the object that is located there. If an item is detected, then the ID of the item is used (via <kbd>toggleLight()</kbd>) to toggle the corresponding bit in the <kbd>self.lightStatus</kbd> value, and the color of the light in the display changes accordingly (via <kbd>setLight()</kbd>). The <kbd>codeText</kbd> variable is also updated with the new hexadecimal representation of the <kbd>lightStatus</kbd> value.</p>
<p>The <kbd>changeCode()</kbd> function allows us to use the <kbd>codeText</kbd> variable and translate it into an integer. This allows us to check whether it is a valid value. Since it is possible to enter text here freely, we must validate it. If we are unable to convert it to an integer, the <kbd>codeValue</kbd> text is refreshed using the <kbd>lightStatus</kbd> value. Otherwise, we check if it is too large, in which case we perform a bit-shift by 4 to divide it by 16 until it is within a valid range. We update the <kbd>lightStatus</kbd> value, the GUI lights, the <kbd>codeText</kbd> variable, and also the hardware (by calling <kbd>updateHardware()</kbd>).</p>
<p>The <kbd>updateHardware()</kbd> function makes use of the <kbd>myMatrixHW</kbd> object that was created using the <kbd>MC.matrix</kbd> class. We send the bytes that we want to display to the matrix hardware one byte at a time (along with the corresponding <kbd>MAX7219_DIGIT</kbd> value to specify the row).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The SPI bus allows us to control multiple devices on the same bus by using the Chip<br/>
Enable signal. Some devices, such as the MAX7219, also allow what is known as a<br/>
daisy-chain SPI configuration.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Daisy-chain SPI configuration</h1>
                </header>
            
            <article>
                
<p>You may have noticed that the <kbd>matrix</kbd> class also returns a byte when we send the data on the MOSI line. This is the data output from the MAX7219 controller on the DOUT connection. The MAX7219 controller actually passes all the DIN data through to DOUT, which is one set of instructions behind the DIN data. In this way, the MAX7219 can be daisy-chained (with each DOUT feeding into the next DIN). By keeping the CE signal low, multiple controllers can be loaded with data by being passed though one another.</p>
<p>The data is ignored while CE is set to low; the output will only be changed when we set it to high again. In this way, you can clock in all the data for each of the modules in the chain and then set the CE to high to update them:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/11bafa78-73ba-47e9-8c55-dc53b6880c4e.png" style="width:37.33em;height:10.83em;" width="1137" height="331"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The daisy-chain SPI configuration</div>
<p>We need to do this for each row that we wish to update (or use <kbd>MAX7219_NOOP</kbd> if we want to keep the current row the same). This is known as a daisy-chain SPI configuration, supported by some SPI devices, where data is passed through each device on the SPI bus to the next one, which allows the use of three bus control signals for multiple devices.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communicating using a serial interface</h1>
                </header>
            
            <article>
                
<p>Traditionally, serial protocols such as RS232 are a common way to connect devices such as printers and scanners as well as joysticks and mouse devices to computers. Now, despite being superseded by USB, many peripherals still make use of this protocol for internal communication between components, to transfer data, and to update firmware. For electronics hobbyists, RS232 is a very useful protocol for debugging and controlling other devices while avoiding the complexities of USB.</p>
<p>The two scripts in this example allow for the control of the GPIO pins to illustrate how we can remotely control Raspberry Pi using the serial port. The serial port can be connected to a PC, another Raspberry Pi device, or even an embedded microcontroller (such as Arduino, PIC, or similar).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The easiest way to connect to Raspberry Pi via a serial protocol will depend on whether your computer has a built-in serial port or not. The serial connection, software, and test setup are described in the following three steps:</p>
<ol>
<li>Create an RS232 serial connection between your computer and Raspberry Pi. For this, you need one of the following setups:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>If your computer has a built-in serial port available, you can use<br/>
a Null-Modem cable with an RS232-to-USB adaptor to connect to Raspberry Pi:</li>
</ul>
</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/1e43a32d-07cc-4c10-b29a-3b5d38c666dc.png" style="width:24.92em;height:18.00em;" width="800" height="577"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">RS232-to-USB adapter</div>
<p style="padding-left: 120px">A Null-Modem is a serial cable/adapter that has the TX and RX wires crossed over so that one side is connected to the TX pin of the serial port and the other side is connected to the RX pin:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/acf971b4-d912-4d17-b8e5-dc8a97b101ed.png" style="width:34.58em;height:7.25em;" width="1531" height="321"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A PC serial port connected to Raspberry Pi via a Null-Modem cable and an RS232-to-USB adapter USB for an RS232 adapter</div>
<div class="packt_infobox">A list of supported USB-to-RS232 devices is available at the following link:<br/>
<a href="http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters"><span class="URLPACKT">http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters</span></a><span class="URLPACKT">.<br/>
<br/></span> Refer to the <em>There's more...</em> section for details on how to set them up.<br/>
<br/>
If you do not have a serial port built in to your computer, you can use another USB-to-RS232 adapter to connect to the PC/laptop, converting the RS232 to the more common USB connection.<br/>
<br/>
If you do not have any available USB ports on Raspberry Pi, you can use the GPIO serial pins directly with either a serial console cable or a Bluetooth serial module (refer to the <em>There's more...</em> section for details). Both of these will require some additional setup.<br/>
<br/>
In all cases, you can use an RS232 loopback to confirm that everything is working and set up correctly (again, refer to the <em>There's more...</em> section).</div>
<ol start="2">
<li>Next, prepare the software you need for this example.</li>
</ol>
<p style="padding-left: 60px">You will need to install <kbd>pyserial</kbd> so we can use the serial port with Python.</p>
<ol start="3">
<li>Install <kbd>pyserial</kbd> with the following command (you will also need <kbd>pip</kbd> installed; refer to <a href="eb11b6c6-b334-42e0-941c-5d32db18cc9d.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Using Python for Automation and Productivity</em>, for details):</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo pip-3.2 install pyserial </strong></pre>
<p style="padding-left: 60px">Refer to the <kbd>pySerial</kbd> site for further documentation:</p>
<p style="padding-left: 60px"><a href="https://pyserial.readthedocs.io/en/latest/"><span class="URLPACKT">https://pyserial.readthedocs.io/en/latest/</span></a>.</p>
<p style="padding-left: 60px">In order to demonstrate the RS232 serial control, you will require some example hardware attached to Raspberry Pi's GPIO pins.</p>
<p style="padding-left: 60px">The <kbd>serialMenu.py</kbd> script allows the GPIO pins to be controlled using commands sent through the serial port. To fully test this, you can connect suitable output devices (such as LEDs) to each of the GPIO pins. You can ensure that the total current is kept low using 470-ohm resistors for each of the LEDs so that the maximum GPIO current that the Raspberry Pi can supply is not exceeded:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/a019b67d-3b3c-4793-bec9-74a1e7dac4af.png" style="width:32.42em;height:25.00em;" width="850" height="656"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A test circuit to test the GPIO output via serial control</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create the following <kbd>serialControl.py</kbd> script:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
#serialControl.py 
import serial 
import time 
 
#Serial Port settings 
SERNAME="/dev/ttyUSB0" 
#default setting is 9600,8,N,1 
IDLE=0; SEND=1; RECEIVE=1 
 
def b2s(message): 
  '''Byte to String''' 
  return bytes.decode(message) 
def s2b(message): 
  '''String to Byte''' 
  return bytearray(message,"ascii") 
 
class serPort(): 
  def __init__(self,serName="/dev/ttyAMA0"): 
    self.ser = serial.Serial(serName) 
    print (self.ser.name) 
    print (self.ser) 
    self.state=IDLE 
  def __enter__(self): 
    return self 
  def send(self,message): 
    if self.state==IDLE and self.ser.isOpen(): 
      self.state=SEND 
      self.ser.write(s2b(message)) 
      self.state=IDLE 
 
  def receive(self, chars=1, timeout=5, echo=True, 
              terminate="r"): 
    message="" 
    if self.state==IDLE and self.ser.isOpen(): 
      self.state=RECEIVE 
      self.ser.timeout=timeout 
      while self.state==RECEIVE: 
        echovalue="" 
        while self.ser.inWaiting() &gt; 0: 
          echovalue += b2s(self.ser.read(chars)) 
        if echo==True: 
          self.ser.write(s2b(echovalue)) 
        message+=echovalue 
        if terminate in message: 
          self.state=IDLE 
    return message 
  def __exit__(self,type,value,traceback): 
    self.ser.close()       
 
def main(): 
  try: 
    with serPort(serName=SERNAME) as mySerialPort: 
      mySerialPort.send("Send some data to me!rn") 
      while True: 
        print ("Waiting for input:") 
        print (mySerialPort.receive()) 
  except OSError: 
    print ("Check selected port is valid: %s" %serName) 
  except KeyboardInterrupt: 
    print ("Finished") 
 
if __name__=="__main__": 
  main() 
#End     </pre>
<p style="padding-left: 60px">Ensure that the <kbd>serName</kbd> element is correct for the serial port you want to use (such as <kbd>/dev/ttyAMA0</kbd> for the GPIO pins or <kbd>/dev/ttyUSB0</kbd> for a USB RS232 adapter).</p>
<p style="padding-left: 60px">Connect the other end to a serial port on your laptop or computer (the serial port can be another USB-to-RS232 adapter).</p>
<p style="padding-left: 60px">Monitor the serial port on your computer using a serial program such as HyperTerminal or RealTerm for Windows or Serial Tools for OS X. You will need to ensure that you have the correct COM port set and a baud rate of 9,600 bps (<kbd>Parity=None</kbd>, <kbd>Data Bits=8</kbd>, <kbd>Stop Bits=1</kbd>, and <kbd>Hardware Flow Control=None</kbd>).</p>
<p style="padding-left: 60px">The script will send a request for data to the user and wait for a response.</p>
<p style="padding-left: 60px">To send data to Raspberry Pi, write some text on the other computer and press <em>Enter</em> to send it over to Raspberry Pi.</p>
<ol start="2">
<li>You will see output similar to the following in the Raspberry Pi terminal:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/7020a150-d190-44bc-8c5b-53c79957578f.png" width="491" height="160"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The text Switch on LED 1 has been sent via a USB-to-RS232 cable from a connected computer</div>
<ol start="3">
<li>You will also see output similar to the following in the serial monitoring program:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/f490dd93-6784-471c-92a7-efa990579863.png" style="width:40.42em;height:21.67em;" width="688" height="369"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">RealTerm displaying typical output from the connected serial port</div>
<ol start="4">
<li>Press <em>Ctrl</em> + <em>C</em> on Raspberry Pi to stop the script.</li>
<li>Now, create a GPIO control menu. Create <kbd>serialMenu.py</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
#serialMenu.py 
import time 
import RPi.GPIO as GPIO 
import serialControl as SC 
SERNAME = "/dev/ttyUSB0" 
running=True 
 
CMD=0;PIN=1;STATE=2;OFF=0;ON=1 
GPIO_PINS=[7,11,12,13,15,16,18,22] 
GPIO_STATE=["OFF","ON"] 
EXIT="EXIT" 
 
def gpioSetup(): 
  GPIO.setmode(GPIO.BOARD) 
  for pin in GPIO_PINS: 
    GPIO.setup(pin,GPIO.OUT) 
 
def handleCmd(cmd): 
  global running 
  commands=cmd.upper() 
  commands=commands.split() 
  valid=False 
  print ("Received: "+ str(commands)) 
  if len(commands)==3: 
    if commands[CMD]=="GPIO": 
      for pin in GPIO_PINS: 
        if str(pin)==commands[PIN]: 
          print ("GPIO pin is valid") 
          if GPIO_STATE[OFF]==commands[STATE]: 
            print ("Switch GPIO %s %s"% (commands[PIN], 
                                         commands[STATE])) 
            GPIO.output(pin,OFF) 
            valid=True 
          elif GPIO_STATE[ON]==commands[STATE]: 
            print ("Switch GPIO %s %s"% (commands[PIN], 
                                         commands[STATE])) 
            GPIO.output(pin,ON) 
            valid=True 
  elif commands[CMD]==EXIT: 
    print("Exit") 
    valid=True 
    running=False 
  if valid==False: 
    print ("Received command is invalid") 
    response="  Invalid:GPIO Pin#(%s) %srn"% ( 
                      str(GPIO_PINS), str(GPIO_STATE)) 
  else: 
    response="  OKrn" 
  return (response) 
 
def main(): 
  try: 
    gpioSetup() 
    with SC.serPort(serName=SERNAME) as mySerialPort: 
      mySerialPort.send("rn") 
      mySerialPort.send("  GPIO Serial Controlrn") 
      mySerialPort.send("  -------------------rn") 
      mySerialPort.send("  CMD PIN STATE "+ 
                        "[GPIO Pin# ON]rn") 
      while running==True: 
        print ("Waiting for command...") 
        mySerialPort.send("&gt;&gt;") 
        cmd = mySerialPort.receive(terminate="rn") 
        response=handleCmd(cmd) 
        mySerialPort.send(response) 
      mySerialPort.send("  Finished!rn") 
  except OSError: 
    print ("Check selected port is valid: %s" %serName) 
  except KeyboardInterrupt: 
    print ("Finished") 
  finally: 
    GPIO.cleanup() 
 
main() 
#End </pre>
<ol start="6">
<li>When you run the script (<kbd>sudo python3 serialMenu.py</kbd>), type the control messages within the serial monitoring program:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/cd8061b0-5146-474b-9586-719162945205.png" style="width:15.25em;height:8.92em;" width="294" height="171"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The GPIO Serial Control menu</div>
<ol start="7">
<li>The Terminal output on Raspberry Pi will be similar to the following screenshot, and the LEDs should respond accordingly:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/3637fda1-fe71-4192-99c9-db6f793215c4.png" style="width:38.17em;height:23.17em;" width="497" height="302"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The GPIO Serial Control menu</div>
<p style="padding-left: 60px">Raspberry Pi validates the commands received from the serial connection and switches the LEDs connected to the GPIO pins 7 and 11 on and then off.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The first script, <kbd>serialControl.py</kbd>, provides us with a <kbd>serPort</kbd> class. We define the class with the following functions:</p>
<ul>
<li><kbd>__init__(self,serName="/dev/ttyAMA0")</kbd>: This function will create a new serial device using <kbd>serName</kbd> – the default of <kbd>/dev/ttyAMA0</kbd> is the ID for the GPIO serial pins (see the <em>There's more...</em> section). After it is initialized, information about the device is displayed.</li>
<li><kbd>__enter__(self)</kbd>: This is a dummy function that allows us to use the <kbd>with...as</kbd> method.</li>
<li><kbd>send(self,message)</kbd>: This is used to check that the serial port is open and not in use; if this is the case, it will then send a message (after converting it to raw bytes using the <kbd>s2b()</kbd> function).</li>
<li><kbd>receive(self, chars=1, echo=True, terminate="r")</kbd>: After checking whether the serial port is open and not in use, this function then waits for data through the serial port. The function will collect data until the terminated characters are detected and then the full message is returned.</li>
<li><kbd>__exit__(self,type,value,traceback)</kbd>: This function is called when the <kbd>serPort</kbd> object is no longer required by the <kbd>with...as</kbd> method, so we can close the port at this point.</li>
</ul>
<p>The <kbd>main()</kbd> function in the script performs a quick test of the class by sending a prompt for data through the serial port to a connected computer and then waits for input that will be followed by the terminated character(s).</p>
<p>The next script, <kbd>serialMenu.py</kbd>, allows us to make use of the <kbd>serPort</kbd> class.</p>
<p>The <kbd>main()</kbd> function sets up the GPIO pins as output (via <kbd>gpioSetup()</kbd>), creates a new <kbd>serPort</kbd> object, and finally waits for commands coming from the serial port. Whenever a new command is received, the <kbd>handleCmd()</kbd> function is used to parse the message to ensure that it is correct before acting on it.</p>
<p>The script will switch a particular GPIO pin on or off as commanded via the serial port using the <kbd>GPIO</kbd> command keyword. We could add any number of command keywords and control (or read) whatever device (or devices) we attached to Raspberry Pi. We now have a very effective way to control Raspberry Pi using any devices connected via a serial link.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In addition to the serial transmit and receive, the RS232 serial standard includes several other control signals. To test it, you can use a serial loopback to confirm if the serial ports<br/>
are set up correctly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring a USB-to-RS232 device for Raspberry Pi</h1>
                </header>
            
            <article>
                
<p>Once you have connected the USB-to-RS232 device to Raspberry Pi, check to see whether<br/>
a new serial device is listed by typing the following command:</p>
<pre><strong>dmesg | grep tty</strong>  </pre>
<p>The <kbd>dmesg</kbd> command lists events that occur on the system; using <kbd>grep</kbd>, we can filter any messages that mention <kbd>tty</kbd>, as shown in the following code:</p>
<pre><strong>[ 2409.195407] usb 1-1.2: pl2303 converter now attached to ttyUSB0</strong>  </pre>
<p>This shows that a PL2303-based USB-RS232 device was attached (2,409 seconds after startup) and allocated the <kbd>ttyUSB0</kbd> identity. You will see that a new serial device has been added within the <kbd>/dev/</kbd> directory (usually <kbd>/dev/ttyUSB0</kbd> or something similar).</p>
<p>If the device has not been detected, you can try steps similar to the ones used in <a href="b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Getting Started with a Raspberry Pi 3 Computer</em>, to locate and install suitable drivers (if they are available).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">RS232 signals and connections</h1>
                </header>
            
            <article>
                
<p>The RS232 serial standard has lots of variants and includes six additional control signals.</p>
<p>The Raspberry Pi GPIO serial drivers (and the Bluetooth TTL module used in the following example) only support RX and TX signals. If you require support for other signals, such as DTR, which is often used for a reset prior to the programming of AVR/Arduino devices, then alternative GPIO serial drivers may be needed to set these signals via other GPIO pins. Most RS232-to-USB adapters support the standard signals; however, ensure that anything you connect is able to handle standard RS232 voltages:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/51528259-42e7-4569-8158-ae7f567feca0.png" style="width:37.75em;height:11.75em;" width="1046" height="326"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The RS232 9-Way D connector pin-out and signals</div>
<p>For more details on the RS232 serial protocol and to learn how these signals are used, visit the following link:</p>
<p><a href="http://en.wikipedia.org/wiki/Serial_port"><span class="URLPACKT">http://en.wikipedia.org/wiki/Serial_port</span></a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the GPIO built-in serial pins</h1>
                </header>
            
            <article>
                
<p>Standard RS232 signals can range from -15V to +15V, so you must never directly connect any RS232 device to the GPIO serial pins. You must use an RS232 to TTL voltage-level converter (such as a MAX232 chip) or a device that uses TTL-level signals (such as another microcontroller or a TTL serial console cable):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/a732198e-8bcb-49ff-97e9-54aa9e31528e.png" style="width:16.50em;height:11.42em;" width="800" height="554"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A USB-to-TTL serial console cable (voltage level is 3V)</div>
<p>Raspberry Pi has TTL-level serial pins on the GPIO header that allow the connection of a TTL serial USB cable. The wires will connect to the Raspberry Pi GPIO pins and the USB will plug in to your computer and be detected like a standard RS232-to-USB cable:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/d45db928-bd0e-448d-bf93-443c59267a0d.png" style="width:24.83em;height:9.00em;" width="1203" height="439"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Connection of a USB-to-TTL serial console cable to the Raspberry Pi GPIO</div>
<p>It is possible to provide power from the USB port to the 5V pin; however, this will bypass the built-in polyfuse, so it is not recommended for general use (just leave the 5V wire disconnected and power it up as normal using the micro USB).</p>
<p>By default, these pins are set up to allow remote terminal access, allowing you to connect<br/>
to the COM port via PuTTY and to create a serial SSH session.</p>
<div class="packt_infobox">A serial SSH session can be helpful if you want to use Raspberry Pi without a display attached to it.<br/>
<br/>
However, a serial SSH session is limited to text-only Terminal access since it does not support X10 forwarding, as used in the <em>Connecting remotely to Raspberry Pi over the network using SSH (and X11 forwarding)</em> section of <a href="b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Getting Started with a Raspberry Pi 3 Computer</em>.</div>
<p>In order to use it as a standard serial connection, we have to disable the serial console so it is available for us to use.</p>
<p>First, we need to edit <kbd>/boot/cmdline.txt</kbd> to remove the first <kbd>console</kbd> and <kbd>kgboc</kbd> options (do not remove the other <kbd>console=tty1</kbd> option, which is the default Terminal when you switch on):</p>
<pre><strong>sudo nano /boot/cmdline.txt</strong>
<strong>dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait</strong>  </pre>
<p>The previous command line becomes the following (ensure that this is still a single<br/>
command line):</p>
<pre><strong>dwc_otg.lpm_enable=0 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait</strong>  </pre>
<p>We also have to remove the task that runs the <kbd>getty</kbd> command (the program that handles the text Terminal for the serial connection) by commenting it out with <kbd>#</kbd>. This is set in <kbd>/etc/inittab</kbd> as follows:</p>
<pre><strong>sudo nano /etc/inittab</strong>
<strong>T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100</strong>  </pre>
<p>The previous command line becomes the following:</p>
<pre><strong>#T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100</strong>  </pre>
<p>To reference the GPIO serial port in our script, we use its name, <kbd>/dev/ttyAMA0</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The RS232 loopback</h1>
                </header>
            
            <article>
                
<p>You can check whether the serial port connections are working correctly using a<br/>
serial loopback.</p>
<p>A simple loopback consists of connecting RXD and TXD together. These are pins 8 and 10 on the Raspberry Pi GPIO header, or pins 2 and 3 on the standard RS232 D9 connector on the USB-RS232 adapter:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/12505654-6822-4caa-8598-b5c4ddd62d07.png" style="width:32.50em;height:13.83em;" width="1347" height="573"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Serial loopback connections to test the Raspberry Pi GPIO (left) and RS232 9-Way D connector (right)</div>
<p>An RS232 full loopback cable also connects pin 4 (DTR) and pin 6 (DSR) as well as pin 7 (RTS) and pin 8 (CTS) on the RS232 adapter. However, this is not required for most situations, unless these signals are used. By default, no pins are allocated on Raspberry Pi specifically for these additional signals:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/4cb2a5a1-40c9-4c0b-8682-a549c491034a.png" style="width:19.00em;height:9.25em;" width="784" height="383"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">RS232 full loopback</div>
<p>Create the following <kbd>serialTest.py</kbd> script:</p>
<pre>#!/usr/bin/python3 
#serialTest.py 
import serial 
import time 
 
WAITTIME=1 
serName="/dev/ttyAMA0" 
ser = serial.Serial(serName) 
print (ser.name) 
print (ser) 
if ser.isOpen(): 
  try: 
    print("For Serial Loopback - connect GPIO Pin8 and Pin10") 
    print("[Type Message and Press Enter to continue]") 
    print("#:") 
    command=input() 
    ser.write(bytearray(command+"rn","ascii")) 
    time.sleep(WAITTIME) 
    out="" 
    while ser.inWaiting() &gt; 0: 
      out += bytes.decode(ser.read(1)) 
    if out != "": 
      print ("&gt;&gt;" + out) 
    else: 
      print ("No data Received") 
  except KeyboardInterrupt: 
    ser.close() 
#End </pre>
<p>When a loopback is connected, you will observe that the message is echoed back to the screen (when removed, <kbd>No data Received</kbd> will be displayed):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/d5ba2a9f-3e18-4a10-bc04-0d9ba7282a18.png" width="496" height="160"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">An RS232 loopback test on GPIO serial pins</div>
<p>If we require non-default settings, they can be defined when the serial port is initialized (the pySerial documentation at <a href="https://pyserial.readthedocs.io/en/latest/"><span class="URLPACKT">https://pyserial.readthedocs.io/en/latest/</span></a> provides full details of all the options), as shown in the following code:</p>
<pre>ser = serial.Serial(port=serName, baudrate= 115200,  
    timeout=1, parity=serial.PARITY_ODD, 
    stopbits=serial.STOPBITS_TWO, 
    bytesize=serial.SEVENBITS) </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling Raspberry Pi using Bluetooth</h1>
                </header>
            
            <article>
                
<p>Serial data can also be sent through Bluetooth by connecting a HC-05 Bluetooth module that supports the <strong>Serial Port Profile</strong> (<strong>SPP</strong>) to the GPIO serial RX/TX pins. This allows the serial connection to become wireless, which allows Android tablets or smartphones to be used to control things and to read data from Raspberry Pi:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/85c1c7b6-68c2-48df-ba23-d81bd93ec6cd.png" style="width:42.67em;height:21.08em;" width="1000" height="494"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The HC-05 Bluetooth module for the TLL serial</div>
<div class="packt_infobox">While it is possible to achieve a similar result using a USB Bluetooth dongle, additional configuration would be required depending on the particular dongle used. The TTL Bluetooth module provides a drop-in replacement for a physical cable, requiring very little additional configuration.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Ensure that the serial console has been disabled (see the previous <em>There's more...</em> section).</p>
<p>The module should be connected using the following pins:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/c2cf2f1f-224d-401f-833f-67be4a33e960.png" style="width:34.00em;height:10.50em;" width="1189" height="366"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Connection to a Bluetooth module for the TLL serial</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>With the Bluetooth module configured and connected, we can pair the module with a laptop or smartphone to send and receive commands wirelessly. Bluetooth spp pro provides an easy way to use a serial connection over Bluetooth to control or monitor Raspberry Pi for Android devices.</p>
<p>Alternatively, you may be able to set up a Bluetooth COM port on your PC/laptop and use it in the same way as the previous wired example:</p>
<ol>
<li>When the device is connected initially, the LED flashes quickly to indicate that it is waiting to be paired. Enable Bluetooth on your device and select the <span class="packt_screen">HC-05</span> device:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/eb5aa69e-f913-4bf7-94b6-6804a93f8993.png" style="width:25.08em;height:6.67em;" width="800" height="212"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The HC-05 Bluetooth module viewable in Bluetooth spp pro</div>
<ol start="2">
<li>Click on the <span class="packt_screen">Pair</span> button to begin the pairing process and enter the device's <span class="packt_screen">PIN</span> (the default is <kbd>1234</kbd>):</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/eaacb1c8-65f6-408e-8ac4-7347cfcd283c.png" style="width:41.33em;height:18.17em;" width="1290" height="566"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Pair the Bluetooth device with the PIN code (1234)</div>
<ol start="3">
<li>If the pairing was successful, you will be able to connect with the device and send and receive messages to and from Raspberry Pi:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/ea1f4551-307b-49b5-9cb3-ae5850c51155.png" style="width:47.25em;height:20.92em;" width="1323" height="587"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Connect to the device and select the control method</div>
<ol start="4">
<li>In <span class="packt_screen">Keyboard mode</span>, you can define actions for each of the buttons to send suitable commands when pressed.</li>
</ol>
<p style="padding-left: 60px">For example, <span class="packt_screen">Pin12 ON</span> can be set to send <kbd>gpio 12 on</kbd> and <span class="packt_screen">Pin12 OFF</span> can be set to send <kbd>gpio 12 off</kbd>.</p>
<ol start="5">
<li>Ensure that you set the end flag to <kbd>rn</kbd> via the menu options.</li>
<li>Ensure that <kbd>menuSerial.py</kbd> is set to use the GPIO serial connection:</li>
</ol>
<pre style="padding-left: 60px"><strong>serName="/dev/ttyAMA0"</strong>  </pre>
<ol start="7">
<li>Run the <kbd>menuSerial.py</kbd> script (with the LEDs attached):</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo python3 menuSerial.py</strong></pre>
<ol start="8">
<li>Check that the Bluetooth serial app displays the <kbd>GPIO Serial Control</kbd> menu as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/95a5b345-114c-48f2-a5ab-f7540890c12c.png" style="width:26.67em;height:22.67em;" width="800" height="683"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">GPIO control over Bluetooth</div>
<p style="padding-left: 60px">We can see from the output in the following screenshot that the commands have been received and the LED connected to pin 12 has been switched on and off as required:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/c473b6fa-7f5d-4b90-b756-80754fb516bf.png" width="496" height="205"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Raspberry Pi receiving GPIO control over Bluetooth</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>By default, the Bluetooth module is set up to act like a TTL serial slave device, so we can simply plug it in to the GPIO RX and TX pins. Once the module is paired with a device, it will transfer the serial communication over the Bluetooth connection. This allows us to send commands and receive data via Bluetooth and to control Raspberry Pi using a smartphone or PC.</p>
<p>This means you can attach a second module to another device (such as an Arduino) that<br/>
has TTL serial pins and control it using Raspberry Pi (either by pairing it with another<br/>
TTL Bluetooth module or suitably configuring a USB Bluetooth dongle). If the module is<br/>
set up as a master device, then you will need to reconfigure it to act as a slave (see the <em>There's more...</em> section).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Now, let's understand how to configure the Bluetooth settings.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring Bluetooth module settings</h1>
                </header>
            
            <article>
                
<p>The Bluetooth module can be set to one of two different modes using the KEY pin.</p>
<p>In a normal operation, serial messages are sent over Bluetooth; however, if we need to change the settings of the Bluetooth module itself, we can do so by connecting the KEY pin to 3V3 and putting it into AT mode.</p>
<p>AT mode allows us to directly configure the module, allowing us to change the baud rate, the pairing code, the device name, or even set it up as a master/slave device.</p>
<p>You can use <kbd>miniterm</kbd>, which is part of pySerial, to send the required messages, as shown in the following code:</p>
<pre><strong>python3 -m serial.tools.miniterm</strong>  </pre>
<p>The <kbd>miniterm</kbd> program, when started, will prompt you for the port to use:</p>
<pre><strong>Enter port name: /dev/ttyAMA0</strong>  </pre>
<p>You can send the following commands (you will need to do this quickly, or paste them in, as the module will time out if there is a gap and respond with an error):</p>
<ul>
<li><kbd>AT</kbd>: This command should respond with <span class="packt_screen">OK</span>.</li>
<li><kbd>AT+UART?</kbd>: This command will report the current settings as <kbd>UART=&lt;Param1&gt;,&lt;Param2&gt;,&lt;Param3&gt;</kbd>. The output of this command will be <span class="packt_screen">OK</span>.</li>
<li>To change the current settings, use <kbd>AT+UART=&lt;Param1&gt;,&lt;Param2&gt;,&lt;Param3&gt;</kbd>, that is, <kbd>AT+UART=19200,0,0</kbd>.</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/d0a9ec96-7589-4751-928e-ac2fbdd6294c.png" style="width:42.33em;height:8.75em;" width="1120" height="233"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">HC-05 AT mode AT+UART command parameters</div>
<p>Zak Kemble has written an excellent guide on how to configure modules as paired master and slave devices (for example, between two Raspberry Pi devices). It is available at the following link:</p>
<p><a href="http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/"><span class="URLPACKT">http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/</span></a>.</p>
<p>For additional documentation on the HC-05 module, visit the following link:</p>
<p><a href="http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf"><span class="URLPACKT">http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf</span></a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling USB devices</h1>
                </header>
            
            <article>
                
<p>The <strong>Universal Serial Bus</strong> (<strong>USB</strong>) is used extensively by computers to provide additional peripherals and expansion through a common standard connection. We will use the<br/>
<kbd>pyusb</kbd> Python library to send custom commands to connected devices over USB.</p>
<p>The following example controls a USB toy missile launcher, which in turn allows it to be controlled by our Python control panel. We can see that the same principle can be applied to other USB devices, such as a robotic arm, using similar techniques, and the controls can be activated using a sensor connected to the Raspberry Pi GPIO:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/58c8a524-baa9-4bf4-b085-2b4e7672e8d8.png" style="width:15.58em;height:20.50em;" width="603" height="800"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The USB Tenx Technology SAM missile launcher</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will need to install <kbd>pyusb</kbd> for Python 3 using <kbd>pip-3.2</kbd> as follows:</p>
<pre><strong>sudo pip-3.2 install pyusb</strong>  </pre>
<p>You can test whether <kbd>pyusb</kbd> has installed correctly by running the following:</p>
<pre><strong>python3</strong>
<strong>&gt; import usb</strong>
<strong>&gt; help (usb)</strong>
<strong>&gt; exit()</strong>  </pre>
<p>This should allow you to view the package information, if it was installed correctly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will create the following <kbd>missileControl.py</kbd> script, which will include two classes and a default <kbd>main()</kbd> function to test it:</p>
<ol>
<li>Import the required modules as follows:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
# missileControl.py 
import time 
import usb.core </pre>
<ol start="2">
<li>Define the <kbd>SamMissile()</kbd> class, which provides the specific commands for the USB device, as follows:</li>
</ol>
<pre style="padding-left: 60px">class SamMissile(): 
  idVendor=0x1130 
  idProduct=0x0202 
  idName="Tenx Technology SAM Missile" 
  # Protocol control bytes 
  bmRequestType=0x21 
  bmRequest=0x09 
  wValue=0x02 
  wIndex=0x01 
  # Protocol command bytes 
  INITA     = [ord('U'), ord('S'), ord('B'), ord('C'), 
               0,  0,  4,  0] 
  INITB     = [ord('U'), ord('S'), ord('B'), ord('C'), 
               0, 64,  2,  0] 
  CMDFILL   = [ 8,  8, 
                0,  0,  0,  0,  0,  0,  0,  0, 
                0,  0,  0,  0,  0,  0,  0,  0, 
                0,  0,  0,  0,  0,  0,  0,  0, 
                0,  0,  0,  0,  0,  0,  0,  0, 
                0,  0,  0,  0,  0,  0,  0,  0, 
                0,  0,  0,  0,  0,  0,  0,  0, 
                0,  0,  0,  0,  0,  0,  0,  0]#48 zeros 
  STOP      = [ 0,  0,  0,  0,  0,  0] 
  LEFT      = [ 0,  1,  0,  0,  0,  0] 
  RIGHT     = [ 0,  0,  1,  0,  0,  0] 
  UP        = [ 0,  0,  0,  1,  0,  0] 
  DOWN      = [ 0,  0,  0,  0,  1,  0] 
  LEFTUP    = [ 0,  1,  0,  1,  0,  0] 
  RIGHTUP   = [ 0,  0,  1,  1,  0,  0] 
  LEFTDOWN  = [ 0,  1,  0,  0,  1,  0] 
  RIGHTDOWN = [ 0,  0,  1,  0,  1,  0] 
  FIRE      = [ 0,  0,  0,  0,  0,  1] 
  def __init__(self): 
    self.dev = usb.core.find(idVendor=self.idVendor, 
                                idProduct=self.idProduct) 
  def move(self,cmd,duration): 
    print("Move:%s %d sec"% (cmd,duration)) 
    self.dev.ctrl_transfer(self.bmRequestType, 
                           self.bmRequest,self.wValue, 
                           self.wIndex, self.INITA) 
    self.dev.ctrl_transfer(self.bmRequestType, 
                           self.bmRequest,self.wValue, 
                           self.wIndex, self.INITB) 
    self.dev.ctrl_transfer(self.bmRequestType, 
                           self.bmRequest, self.wValue, 
                           self.wIndex, cmd+self.CMDFILL) 
    time.sleep(duration) 
    self.dev.ctrl_transfer(self.bmRequestType, 
                           self.bmRequest, self.wValue, 
                           self.wIndex, self.INITA) 
    self.dev.ctrl_transfer(self.bmRequestType, 
                           self.bmRequest, self.wValue, 
                           self.wIndex, self.INITB) 
    self.dev.ctrl_transfer(self.bmRequestType, 
                      self.bmRequest, self.wValue, 
                      self.wIndex, self.STOP+self.CMDFILL) </pre>
<ol start="3">
<li>Define the <kbd>Missile()</kbd> class, which allows you to detect the USB device and provide command functions, as follows:</li>
</ol>
<pre style="padding-left: 60px">class Missile(): 
  def __init__(self): 
    print("Initialize Missiles") 
    self.usbDevice=SamMissile() 
     
    if self.usbDevice.dev is not None: 
      print("Device Initialized:" + 
            " %s" % self.usbDevice.idName) 
      #Detach the kernel driver if active 
      if self.usbDevice.dev.is_kernel_driver_active(0): 
        print("Detaching kernel driver 0") 
        self.usbDevice.dev.detach_kernel_driver(0) 
      if self.usbDevice.dev.is_kernel_driver_active(1): 
        print("Detaching kernel driver 1") 
        self.usbDevice.dev.detach_kernel_driver(1) 
      self.usbDevice.dev.set_configuration() 
    else: 
      raise Exception("Missile device not found") 
  def __enter__(self): 
    return self 
  def left(self,duration=1): 
    self.usbDevice.move(self.usbDevice.LEFT,duration) 
  def right(self,duration=1): 
    self.usbDevice.move(self.usbDevice.RIGHT,duration) 
  def up(self,duration=1): 
    self.usbDevice.move(self.usbDevice.UP,duration) 
  def down(self,duration=1): 
    self.usbDevice.move(self.usbDevice.DOWN,duration) 
  def fire(self,duration=1): 
    self.usbDevice.move(self.usbDevice.FIRE,duration) 
  def stop(self,duration=1): 
    self.usbDevice.move(self.usbDevice.STOP,duration) 
  def __exit__(self, type, value, traceback): 
    print("Exit") </pre>
<ol start="4">
<li>Finally, create a <kbd>main()</kbd> function, which provides a quick test of our <kbd>missileControl.py</kbd> module if the file is run directly, as follows:</li>
</ol>
<pre style="padding-left: 60px">def main(): 
  try: 
    with Missile() as myMissile: 
      myMissile.down() 
      myMissile.up() 
  except Exception as detail: 
 
      time.sleep(2) 
    print("Error: %s" % detail) 
     
if __name__ == '__main__': 
    main() 
#End </pre>
<ol start="5">
<li>When the script is run using the following command, you should see the missile launcher move downwards and then up again:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo python3 missileControl.py</strong>  </pre>
<ol start="6">
<li>To have easy control of the device, create the following GUI:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/0e2a7913-c477-481e-930e-c0128ef286bc.png" style="width:18.58em;height:6.75em;" width="312" height="113"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The Missile Command GUI</div>
<p style="padding-left: 60px">Although simple commands have been used here, you could use a series of preset commands if desired.</p>
<ol start="7">
<li>Create the GUI for the <kbd>missileMenu.py</kbd> missile command:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
#missileMenu.py 
import tkinter as TK 
import missileControl as MC 
 
BTN_SIZE=10 
 
def menuInit(): 
  btnLeft = TK.Button(root, text="Left", 
                      command=sendLeft, width=BTN_SIZE)    
  btnRight = TK.Button(root, text="Right", 
                       command=sendRight, width=BTN_SIZE)    
  btnUp = TK.Button(root, text="Up", 
                    command=sendUp, width=BTN_SIZE)    
  btnDown = TK.Button(root, text="Down", 
                      command=sendDown, width=BTN_SIZE) 
  btnFire = TK.Button(root, text="Fire",command=sendFire, 
                      width=BTN_SIZE, bg="red") 
  btnLeft.grid(row=2,column=0) 
  btnRight.grid(row=2,column=2) 
  btnUp.grid(row=1,column=1) 
  btnDown.grid(row=3,column=1) 
  btnFire.grid(row=2,column=1) 
 
def sendLeft(): 
  print("Left") 
  myMissile.left() 
        
def sendRight(): 
  print("Right")     
  myMissile.right() 
        
def sendUp(): 
  print("Up") 
  myMissile.up() 
        
def sendDown(): 
  print("Down") 
  myMissile.down() 
        
def sendFire(): 
  print("Fire") 
  myMissile.fire() 
        
 
root = TK.Tk() 
root.title("Missile Command") 
prompt = "Select action" 
label1 = TK.Label(root, text=prompt, width=len(prompt), 
                  justify=TK.CENTER, bg='lightblue') 
label1.grid(row=0,column=0,columnspan=3) 
menuInit() 
with MC.Missile() as myMissile: 
  root.mainloop() 
#End </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The control script consists of two classes: one called <kbd>Missile</kbd>, which provides a common interface for the control, and another called <kbd>SamMissile</kbd>, which provides all the specific details of the particular USB device being used.</p>
<p>In order to drive a USB device, we need a lot of information about the device, such as its USB identification, its protocol, and the control messages it requires to be controlled.</p>
<p>The USB ID for the Tenx Technology SAM missile device is determined by the vendor<br/>
ID (<kbd>0x1130</kbd>) and the product ID (<kbd>0x0202</kbd>). This is the same identification information<br/>
you would see within <span class="packt_screen">Device Manager</span> in Windows. These IDs are usually registered with <a href="http://www.usb.org" target="_blank"><span class="URLPACKT">www.usb.org</span></a>; therefore, each device should be unique. Again, you can use the <kbd>dmesg | grep usb</kbd> command to discover these.</p>
<p>We use the device IDs to find the USB device using <kbd>usb.core.find</kbd>; then, we can send messages using <kbd>ctrl_transfer()</kbd>.</p>
<p>The USB message has five parts:</p>
<ul>
<li><strong>Request type (0x21)</strong>: This defines the type of the message request, such as the message direction (host to device), its type (vendor), and the recipient (interface).</li>
<li><strong>Request</strong> <strong>(0x09)</strong>: This is the set configuration.</li>
<li><strong>Value</strong> <strong>(0x02)</strong>: This is the configuration value.</li>
<li><strong>Index</strong> <strong>(0x01)</strong>: This is the command we want to send.</li>
<li><strong>Data</strong>: This is the command we want to send (as described next).</li>
</ul>
<p>The <kbd>SamMissile</kbd> device requires the following commands to move:</p>
<ul>
<li>It requires two initialization messages (<kbd>INITA</kbd> and <kbd>INITB</kbd>).</li>
<li>It also requires the control message. This consists of the <kbd>CMD</kbd>, which includes one of the control bytes that has been set to <kbd>1</kbd> for the required component. The <kbd>CMD</kbd> is then added to <kbd>CMDFILL</kbd> to complete the message.</li>
</ul>
<p>You will see that the other missile devices and the robot arm (see the following <em>There's more...</em> section) have similar message structures.</p>
<p>For each device, we created the <kbd>__init__()</kbd> and <kbd>move()</kbd> functions and defined values for each of the valid commands, which the <kbd>missile</kbd> class will use whenever the <kbd>left()</kbd>, <kbd>right()</kbd>, <kbd>up()</kbd>, <kbd>down()</kbd>, <kbd>fire()</kbd>, and <kbd>stop()</kbd> functions are called.</p>
<p>For the control GUI for our missile launcher, we create a small Tkinter window with five buttons, each of which will send a command to the missile device.</p>
<p>We import <kbd>missileControl</kbd> and create a <kbd>missile</kbd> object called <kbd>myMissile</kbd> that will be controlled by each of the buttons.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The example only shows how to control one particular USB device; however, it is possible to extend this to support several types of missile devices and even other USB devices in general.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling similar missile-type devices</h1>
                </header>
            
            <article>
                
<p>There are several variants of USB missile-type devices, each with their own USB IDs and USB commands. We can add support for these other devices by defining their own classes to handle them.</p>
<p>Use <kbd>lsusb -vv</kbd> to determine the vendor and product ID that matches your device.</p>
<p>For <kbd>Chesen Electronics/Dream Link</kbd>, we have to add the following code:</p>
<pre>class ChesenMissile(): 
  idVendor=0x0a81 
  idProduct=0x0701 
  idName="Chesen Electronics/Dream Link" 
  # Protocol control bytes 
  bmRequestType=0x21 
  bmRequest=0x09 
  wValue=0x0200 
  wIndex=0x00 
  # Protocol command bytes 
  DOWN    = [0x01] 
  UP      = [0x02] 
  LEFT    = [0x04] 
  RIGHT   = [0x08] 
  FIRE    = [0x10] 
  STOP    = [0x20] 
  def __init__(self): 
    self.dev = usb.core.find(idVendor=self.idVendor, 
                             idProduct=self.idProduct) 
  def move(self,cmd,duration): 
    print("Move:%s"%cmd) 
    self.dev.ctrl_transfer(self.bmRequestType, 
                           self.bmRequest, 
                           self.wValue, self.wIndex, cmd) 
    time.sleep(duration) 
    self.dev.ctrl_transfer(self.bmRequestType, 
                           self.bmRequest, self.wValue, 
                           self.wIndex, self.STOP) </pre>
<p>For <kbd>Dream Cheeky Thunder</kbd>, we need the following code:</p>
<pre>class ThunderMissile(): 
  idVendor=0x2123 
  idProduct=0x1010 
  idName="Dream Cheeky Thunder" 
  # Protocol control bytes 
  bmRequestType=0x21 
  bmRequest=0x09 
  wValue=0x00 
  wIndex=0x00 
  # Protocol command bytes 
  CMDFILL = [0,0,0,0,0,0] 
  DOWN    = [0x02,0x01] 
  UP      = [0x02,0x02] 
  LEFT    = [0x02,0x04] 
  RIGHT   = [0x02,0x08] 
  FIRE    = [0x02,0x10] 
  STOP    = [0x02,0x20] 
  def __init__(self): 
    self.dev = usb.core.find(idVendor=self.idVendor, 
                             idProduct=self.idProduct) 
  def move(self,cmd,duration): 
    print("Move:%s"%cmd) 
    self.dev.ctrl_transfer(self.bmRequestType, 
                           self.bmRequest, self.wValue, 
                           self.wIndex, cmd+self.CMDFILL) 
    time.sleep(duration) 
    self.dev.ctrl_transfer(self.bmRequestType, 
                      self.bmRequest, self.wValue, 
                      self.wIndex, self.STOP+self.CMDFILL) </pre>
<p>Finally, adjust the script to use the required class as follows:</p>
<pre>class Missile(): 
  def __init__(self): 
    print("Initialize Missiles") 
    self.usbDevice = ThunderMissile() </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Robot arm</h1>
                </header>
            
            <article>
                
<p>Another device that can be controlled in a similar manner is the OWI Robotic Arm with a USB interface:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/1af76f13-d717-4b72-909a-41d8a6c59244.png" style="width:22.83em;height:17.50em;" width="847" height="650"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The OWI Robotic Arm with a USB interface (image courtesy of Chris Stagg)</div>
<p>This has featured in <em>The MagPi</em> magazine several times, thanks to <em>Stephen Richards's</em><br/>
articles on Skutter; the USB control has been explained in detail in issue 3 (page 14)<br/>
at <a href="https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14"><span class="URLPACKT">https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14</span></a>. It can also be found at <a href="https://www.raspberrypi.org/magpi/issues/3/"><span class="URLPACKT">https://www.raspberrypi.org/magpi/issues/3/</span></a>.</p>
<p>The robotic arm can be controlled using the following class. Remember that you will also need to adjust the commands, <kbd>UP</kbd>, <kbd>DOWN</kbd>, and so on, when calling the <kbd>move()</kbd> function, as shown in the following code:</p>
<pre>class OwiArm(): 
  idVendor=0x1267 
  idProduct=0x0000 
  idName="Owi Robot Arm" 
  # Protocol control bytes 
  bmRequestType=0x40 
  bmRequest=0x06 
  wValue=0x0100 
  wIndex=0x00 
  # Protocol command bytes 
  BASE_CCW    = [0x00,0x01,0x00] 
  BASE_CW     = [0x00,0x02,0x00] 
  SHOLDER_UP  = [0x40,0x00,0x00] 
  SHOLDER_DWN = [0x80,0x00,0x00] 
  ELBOW_UP    = [0x10,0x00,0x00] 
  ELBOW_DWN   = [0x20,0x00,0x00] 
  WRIST_UP    = [0x04,0x00,0x00] 
  WRIST_DOWN  = [0x08,0x00,0x00] 
  GRIP_OPEN   = [0x02,0x00,0x00] 
  GRIP_CLOSE  = [0x01,0x00,0x00] 
  LIGHT_ON    = [0x00,0x00,0x01] 
  LIGHT_OFF   = [0x00,0x00,0x00] 
  STOP        = [0x00,0x00,0x00] </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Taking USB control further</h1>
                </header>
            
            <article>
                
<p>The theory and method of control used for the USB missile device can be applied to very complex devices such as the Xbox 360's Kinect (a special 3D camera add-on for the Xbox game console) as well.</p>
<p>Adafruit's website has a very interesting tutorial written by <em>Limor Fried</em> (also known as <em>Ladyada</em>) on how to analyze and investigate USB commands; access it at <a href="http://learn.adafruit.com/hacking-the-kinect"><span class="URLPACKT">http://learn.adafruit.com/hacking-the-kinect</span></a>.</p>
<p>This is well worth a look if you intend to reverse engineer other USB items. In this chapter, we have used Raspberry Pi to control remotely activated mains sockets, to send commands over serial connections from another computer, and to control the GPIO remotely. We have also used SPI to drive an 8 x 8 LED matrix display.</p>


            </article>

            
        </section>
    </div>



  </body></html>