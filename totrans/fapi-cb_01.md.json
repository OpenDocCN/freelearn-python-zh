["```py\n$ /bin/bash -c \"$(curl –fsSL https://raw.githubusercontent.com/\\Homebrew/install/HEAD/install.sh)\"\n```", "```py\n$ brew install python\n```", "```py\n$ sudo apt-get install python3\n```", "```py\n$ python --version\n```", "```py\n$ python3 --version\n```", "```py\n$ pip --version\n```", "```py\n$ pip3 --version\n```", "```py\n$ pip install fastapi[all]\n```", "```py\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"your.email@example.com\"\n```", "```py\n    .venv folder that will contain all packages required for the project within our project's root folder.\n    ```", "```py\n    (.venv) $. Alternatively, if you check the location of the python binary command, it should be located within the .venv folder. From now on, each time you install a module with pip, it will be installed in the .venv folder, and it will be activated only if the environment is active.\n    ```", "```py\n    main.py.\n    ```", "```py\n    from fastapi import FastAPI\n    app = FastAPI()\n    ```", "```py\n    @app.get(\"/\")\n    def read_root():\n        return {\"Hello\": \"World\"}\n    ```", "```py\n    .gitignore file to specify untracked files to ignore (such as __pychache__, .venv, or IDE-specific folders). You can also have a look at the one on the GitHub repository of the project at the link: https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/.gitignore.\n    ```", "```py\n    $ git add .\n    ```", "```py\n    $ git commit –m \"Initial commit\"\n    ```", "```py\n@app.get(\"/\")\nasync def read_root():\n    return {\"Hello\": \"World\"}\n```", "```py\nfrom fastapi import FastAPI\napp = FastAPI()\n@app.get(\"/\")\nasync def read_root():\n    return {\"Hello\": \"World\"}\n```", "```py\nfrom fastapi import APIRouter\nrouter = APIRouter()\n@router.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id}\n```", "```py\nimport router_example\nfrom fastapi import FastAPI\napp = FastAPI()\napp.include_router(router_example.router)\n@app.get(\"/\")\nasync def read_root():\n    return {\"Hello\": \"World\"}\n```", "```py\n$ uvicorn main:app --reload\n```", "```py\n    from fastapi import FastAPI\n    app = FastAPI()\n    @app.get(\"/books/{book_id}\")\n    async def read_book(book_id: int):\n        return {\n            \"book_id\": book_id,\n            \"title\": \"The Great Gatsby\",\n            \"author\": \"F. Scott Fitzgerald\"\n        }\n    ```", "```py\n$ uvicorn main:app --reload\n```", "```py\n    @app.get(\"/authors/{author_id}\")\n    async def read_author(author_id: int):\n        return {\n            \"author_id\": author_id,\n            \"name\": \"Ernest Hemingway\"\n        }\n    ```", "```py\n    @app.get(\"/books\")\n    async def read_books(year: int = None):\n        if year:\n            return {\n                \"year\": year,\n                \"books\": [\"Book 1\", \"Book 2\"]\n            }\n        return {\"books\": [\"All Books\"]}\n    ```", "```py\n$ uvicorn main:app\n```", "```py\nfrom pydantic import BaseModel\nclass Book(BaseModel):\n    title: str\n    author: str\n    year: int\n```", "```py\nfrom models import Book\n@app.post(\"/book\")\nasync def create_book(book: Book):\n    return book\n```", "```py\nfrom pydantic import BaseModel, Field\nclass Book(BaseModel):\n    title: str = Field(..., min_length=1, max_length=100)\n    author: str = Field(..., min_length=1, max_length=50)\n    year: int = Field(..., gt=1900, lt=2100)\n```", "```py\nfrom pydantic import BaseModel\nclass BookResponse(BaseModel):\n    title: str\n    author: str\n@app.get(\"/allbooks\")\nasync def read_all_books() -> list[BookResponse]:\n    return [\n        {\n            \"id\": 1,\n            \"title\": \"1984\",\n            \"author\": \"George Orwell\"},\n        {\n            \"id\": 1,\n            \"title\": \"The Great Gatsby\",\n            \"author\": \"F. Scott Fitzgerald\",\n        },\n    ]\n```", "```py\n@app.get(\"/allbooks\", response_model= list[BookResponse])\nasync def read_all_books() -> Any:\n# rest of the endpoint content\n```", "```py\n[\n  {\n    \"title\": \"string\",\n    \"author\": \"string\"\n  }\n]\n```", "```py\nfrom fastapi import FastAPI, HTTPException\nfrom starlette.responses import JSONResponse\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request, exc):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            \"message\": \"Oops! Something went wrong\"\n        },\n    )\n```", "```py\n@app.get(\"/error_endpoint\")\nasync def raise_exception():\n    raise HTTPException(status_code=400)\n```", "```py\nhttp://localhost:8000/error_endpoint, and you will have a JSON response like this:\n\n```", "```py\n\n The response returns the default message we defined for any HTTP exception returned by the code.\nThere’s more…\nAs discussed in the previous recipe, *Defining and using request and response models*, FastAPI uses Pydantic models for data validation. When a request is made with data that does not conform to the defined model, FastAPI automatically raises an exception and returns an error response.\nIn some cases, you might want to customize the response for validation errors. FastAPI makes this quite straightforward:\n\n```", "```py\n\n This custom handler will catch any `RequestValidationError` error and return a plain text response with the details of the error.\nIf you try, for example, to call the `POST /book` endpoint with a number type of `title` instead of a string, you will get a response with a status code of `400` and body:\n\n```", "```py\n\n You can also, for example, mask the message to add a layer of security to protect from unwanted users using it incorrectly.\nThis is all you need to customize responses when a request validation error occurs.\nYou will use this basic knowledge as you move to the next chapter. [*Chapter 2*](B21025_02.xhtml#_idTextAnchor052) will teach you more about data management in web applications, showing you how to set up and use SQL and NoSQL databases and stressing data security. This will not only improve your technical skills but also increase your awareness of creating scalable and reliable FastAPI applications.\nSee also\nYou can find more information about customizing errors and exceptions using FastAPI in the official documentation:\n\n*   *Handling* *Errors*: [https://fastapi.tiangolo.com/tutorial/handling-errors/](https://fastapi.tiangolo.com/tutorial/handling-errors/)\n\n```"]