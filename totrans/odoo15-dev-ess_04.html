<html><head></head><body><div><div><h1 id="_idParaDest-160"><em class="italic"><a id="_idTextAnchor164"/></em><a href="B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>: Models – Structuring the Application Data</h1>
			<p>In this chapter, we will learn more about the model layer and how to use models to design the data structures that support applications. We will explore the available model types, when each should be used, and how to define constraints that enforce data validations.</p>
			<p>Models are composed of data fields that support several data types, and some field types support defining relationships between models. More advanced usage of fields involves having values automatically computed using specific business logic.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Learning project – improving the Library app</li>
				<li>Creating models</li>
				<li>Creating fields</li>
				<li>Relationships between models</li>
				<li>Computed fields</li>
				<li>Model constraints</li>
				<li>Overview of the Odoo base models</li>
			</ul>
			<p>Throughout these topics, you will learn how to create non-trivial data structures for your Odoo projects. By the end of this chapter, you should have a clear overview of all the relevant features needed to structure data models.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor165"/>Technical requirements</h1>
			<p>This chapter is based on the code we created in <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>. This code can be found in the <code>ch06/</code> directory of this book's GitHub repository at <a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials">https://github.com/PacktPublishing/Odoo-15-Development-Essentials</a>.</p>
			<p>You should have it in your add-ons path. Make sure that you install the <code>library_app</code> module.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor166"/>Learning project – improving the Library app</h1>
			<p>In <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>, we created the <code>library_app</code> add-on module and implemented the <a id="_idIndexMarker406"/>simple <code>library.book</code> model to represent a book catalog. In this chapter, we will revisit that module to enrich the data that we can store for each book.</p>
			<p>We will add a category hierarchy to use for book categorization with the following structure:</p>
			<ul>
				<li><strong class="bold">Name</strong>: The category title</li>
				<li><strong class="bold">Parent</strong>: The parent category that it belongs to</li>
				<li><strong class="bold">Subcategories</strong>: The categories that have this one as the parent</li>
				<li><strong class="bold">Featured book or author</strong>: A selected book or author that represents this category</li>
			</ul>
			<p>A few more fields will be added to showcase the different data types available for Odoo fields. We will also use model constraints to implement a few validations on the Books model:</p>
			<ul>
				<li>The title and publication date should be unique.</li>
				<li>ISBNs entered should be valid.</li>
			</ul>
			<p>We will start by revisiting Odoo models, now in more depth, to learn about all the options that are available for us.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor167"/>Creating models</h1>
			<p>Models are at the heart of the Odoo framework. They describe the application data structures and are the bridge <a id="_idIndexMarker407"/>between the application server and the database storage. Business logic can be implemented around models to provide application features, and user interfaces are created on top of them to provide the user experience.</p>
			<p>In the following <a id="_idIndexMarker408"/>subsections, we will learn about the model's generic attributes, which <a id="_idIndexMarker409"/>are used to <a id="_idIndexMarker410"/>influence their behavior, and the several types we have available – <strong class="bold">regular models</strong>, <strong class="bold">transient models</strong>, and <strong class="bold">abstract models</strong>.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor168"/>Model attributes</h2>
			<p>Model classes can use <a id="_idIndexMarker411"/>additional attributes to control some behaviors. These are the most commonly used attributes:</p>
			<ul>
				<li><code>_name</code>: This is the internal identifier for the Odoo model we are creating. This is mandatory when creating a new model.</li>
				<li><code>_description</code>: This is a user-friendly title that can be used to refer to a single <code>Model</code> record, such as <code>Book</code>. This is optional but recommended. If this is not set, a server log warning will be displayed during the loading sequence.</li>
				<li><code>_order</code>: This sets the <a id="_idIndexMarker412"/>default order to use when the model's records are browsed, or shown in a list view. It is a text string to be used as the SQL order by clause, so it can be anything you could use there, although it has smart behavior and supports translatable and many-to-one field names.</li>
			</ul>
			<p>Our <code>Book</code> model is already using the <code>_name</code> and <code>_description</code> attributes. The following code adds the <code>_order</code> attribute to have the default order by book title, and then by reverse order of publication date (from newest to oldest):</p>
			<pre>class Book(models.Model):
    _name = "library.book"
    _description = "Book"
    _order = "name, date_published desc"</pre>
			<p>There are a few more advanced attributes available that can be helpful in advanced cases:</p>
			<ul>
				<li><code>_rec_name</code>: This sets the field to use for the record's display name. By default, it is the <code>name</code> field, which is why we usually choose this particular field name for the records title field.</li>
				<li><code>_table</code>: This is the name of the database table supporting the model. Usually, it is left to be automatically set by the ORM, which will use the model name after replacing the dots with underscores. However, we are free to choose a specific database table name to be used.</li>
				<li><code>_log_access=False</code>: This can be used to prevent audit tracking fields from being automatically created; that is, <code>create_uid</code>, <code>create_date</code>, <code>write_uid</code>, and <code>write_date</code>.</li>
				<li><code>_auto=False</code>: This prevents the underlying database table from being automatically created. In this case, we should use the <code>init()</code> method to provide our specific logic for creating the supporting database object, a table, or a view. This is usually used for views that support read-only reports.</li>
			</ul>
			<p>As an example, the following code sets the default values on the <code>library.book</code> model:</p>
			<pre>    _recname = "name"
    _table = "library_book"
    _log_access = True
    _auto = True</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">There are also the <code>_inherit</code> and <code>_inherits</code> attributes, which are used for module extension. These were explained in detail in <a href="B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 4</em></a>, <em class="italic">Extending Modules</em>.</p>
			<p>When using <code>_auto = False</code>, we are overriding the process of creating the database object, so we should provide <a id="_idIndexMarker413"/>the logic for that. A frequent application of this is models to use for reports, based on a database view that gathers all the data needed for the report.</p>
			<p>Here is an example taken from the <code>sale</code> core module, in the <code>sale/report/sale_report.py</code> file:</p>
			<pre>    def init(self):
        tools.drop_view_if_exists(self.env.cr, self._table)
        self.env.cr.execute(
            "CREATE or REPLACE VIEW %s as (%s)"
            % (self._table, self._query())
        )  </pre>
			<p>The preceding code uses a <code>tools</code> Python module, which needs to be imported using <code>odoo import tools</code>.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor169"/>Models and Python classes</h2>
			<p>Odoo models use Python classes. In the preceding <a id="_idIndexMarker414"/>code, we can see a Python class, <code>Book</code>, based on the <code>models.Model</code> class, being used to define an Odoo model named <code>library.book</code>.</p>
			<p>Odoo models are kept in a <em class="italic">central registry</em>, available through the <em class="italic">environment object</em>, which is usually accessed using <code>self.env</code>. The central registry keeps references to all the models available, and they can be accessed with a dictionary-like syntax.</p>
			<p>For example, to get a reference to the library book model inside a method, we could use <code>self.env["library.book"]</code> or <code>self.env.get(["library.book"])</code>.</p>
			<p>As you can see, model names are important and are the key to accessing the model registry.</p>
			<p>Model names must be globally unique. Because of this, it is a good practice to use the first word of the application the module belongs to as the first word in the model's name. In the case of the <code>Library</code> app, all model names should have <code>library</code> as a prefix. Other examples from the core modules are <code>project</code>, <code>crm</code>, or <code>sale</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Model names should use the singular form, <code>library.book</code>, rather than <code>library.books</code>. The convention is to use a list of lowercase words joined with dots. The first word should identify the main app the model belongs to, such as <code>library.book</code> or <code>library.book.category</code>. Other examples that have been taken from official add-ons include <code>project.project</code>, <code>project.task</code>, and <code>project.task.type</code>.</p>
			<p>On the other hand, Python class identifiers are local to the Python file where they are declared and are not relevant to the Odoo framework. The identifier that's used for them is only significant for the code in that file and is rarely relevant. The Python convention for class identifiers is to use <em class="italic">CamelCase</em>, following the standards defined by the PEP8 coding conventions.</p>
			<p>There are several types of models available. The most frequently used one is the <code>models.Model</code> class, for persistent database stored models. Next, we will learn about the other available model types.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor170"/>Transient and abstract models</h2>
			<p>For most Odoo <a id="_idIndexMarker415"/>models, the Python <a id="_idIndexMarker416"/>class is <a id="_idIndexMarker417"/>based <a id="_idIndexMarker418"/>on <code>models.Model</code>. This type of model has permanent database persistence, which means that database tables are created for them and their records are stored until they're explicitly deleted. And most of the time, this is what you need.</p>
			<p>But in some cases, we don't need permanent database persistence, and hence these two other model types can be useful:</p>
			<ul>
				<li><code>models.TransientModel</code>, are used for wizard-style user <a id="_idIndexMarker419"/>interaction. Their data is still stored in the database, but it is expected to <a id="_idIndexMarker420"/>be temporary. A vacuum job periodically clears old data from these tables. For example, the <strong class="bold">Settings</strong> | <strong class="bold">Translations</strong> | <strong class="bold">Import Translation</strong> menu option opens a dialog window that uses a transient model to store the user selections and implement the wizard logic. An example of using a transient model will be discussed in <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>.</li>
				<li><code>models.AbstractModel</code> class and have no data storage <a id="_idIndexMarker421"/>attached to them. They can be used as reusable feature sets, to be mixed in with <a id="_idIndexMarker422"/>other models using Odoo's inheritance capabilities. For example, <code>mail.thread</code> is an abstract model provided by the <code>mail.thread</code> example mentioned previously were discussed in <a href="B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 4</em></a>, <em class="italic">Extending Modules</em>.</li>
			</ul>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor171"/>Inspecting existing models</h2>
			<p>The models and fields <a id="_idIndexMarker423"/>that are created by Python classes can be inspected through the user interface. With <strong class="bold">Developer Mode</strong> enabled, via the <strong class="bold">Settings</strong> top menu, navigate to the <strong class="bold">Technical</strong> | <strong class="bold">Database Structure</strong> | <strong class="bold">Models</strong> menu item. Here, you will find a list of all the models available in the database.</p>
			<p>Clicking on a model in the list will open a form showing its details, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_6.1_B16119.jpg" alt="Figure 6.1 – Inspecting the Book model from the Technical menu&#13;&#10;" width="1185" height="768"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Inspecting the Book model from the Technical menu</p>
			<p>This is a good tool for inspecting a model since it shows the results of all the modifications made by different modules. At the top <a id="_idIndexMarker424"/>right of the form, in the <code>library.book</code> is affected by the <code>library_app</code> and <code>library_member</code> modules.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As seen in <a href="B16119_01_Final_PD_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Quick Start Using Developer Mode</em>, the <strong class="bold">Models</strong> form is editable! It is possible to create and modify models, fields, and views from here. You can use this to build prototypes that will be implemented as add-on modules later.</p>
			<p>In the lower area, we have some tabs with additional information available:</p>
			<ul>
				<li><strong class="bold">Fields</strong> lists the model fields.</li>
				<li><strong class="bold">Access Rights</strong> lists the access control rules granted to security groups.</li>
				<li><strong class="bold">Record Rules</strong> lists the record rules applying filters to records.</li>
				<li><strong class="bold">Notes</strong> is the model definition docstring.</li>
				<li><strong class="bold">Views</strong> lists the views available for the model.</li>
			</ul>
			<p>To find the model's external identifier or XML ID, we can use the <code>model_</code>. As an example, the <a id="_idIndexMarker425"/>identifier that's generated for the <code>library.book</code> model, as created by the <code>library_app</code> module, is <code>library_app.model_library_book</code>. These XML IDs are usually needed for the CSV files defining the security ACLs.</p>
			<p>We are now familiar with the options we have for defining the model. The next step is to understand the several field types, as well as the options available to configure them.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor172"/>Creating fields</h1>
			<p>Having created a new model, the next step is to add fields to it. Odoo supports all the basic data types that are <a id="_idIndexMarker426"/>expected, such as text strings, integers, floating-point numbers, Booleans, dates and time, and image or binary data.</p>
			<p>Let's explore the several types of fields available in Odoo.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor173"/>Basic field types</h2>
			<p>We will go back to <a id="_idIndexMarker427"/>the book model to present the several available field types.</p>
			<p>In the <code>library_app/models/library_book.py</code> file, edit the <code>Book</code> class, replacing the current field definitions with this one:</p>
			<pre>class Book(models.Model):
    _name = "library.book"
    _description = "Book"
    # String fields:
    name = fields.Char("Title")
    isbn = fields.Char("ISBN")
    book_type = fields.Selection(
        [("paper","Paperback"),
         ("hard","Hardcover"),
         ("electronic","Electronic"),
         ("other", "Other")],
        "Type")
    notes = fields.Text("Internal Notes") 
    descr = fields.Html("Description") 
    # Numeric fields:
    copies = fields.Integer(default=1)
    avg_rating = fields.Float("Average Rating", (3, 2))
    price = fields.Monetary("Price", "currency_id") 
    # price helper
    currency_id = fields.Many2one("res.currency")  
    # Date and time fields:
    date_published = fields.Date()
    last_borrow_date = fields.Datetime(
        "Last Borrowed On",
         default=lambda self: fields.Datetime.now()) 
    # Other fields:
    active = fields.Boolean("Active?")
    image = fields.Binary("Cover") 
    # Relational Fields
    publisher_id = fields.Many2one(
        "res.partner", string="Publisher")
    author_ids = fields.Many2many(
        "res.partner", string="Authors")</pre>
			<p>These are examples of the non-relational field types that are available in Odoo with the positional <a id="_idIndexMarker428"/>arguments expected by each one. Next, we will explain all these field types and options. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Python functions can have two types of arguments: positional and keyword. </p>
			<p class="callout"><code>fn(x, y)</code> should <a id="_idIndexMarker429"/>be something such as <code>f(1, 2)</code>.</p>
			<p class="callout"><code>f(x=1, y=2)</code>, or even mix both styles, with something such as <code>f(1, y=2)</code>.</p>
			<p class="callout">However, note that positional arguments must come before keyword arguments, so <code>f(x=1, 2)</code> is not allowed. More information <a id="_idIndexMarker431"/>on keyword arguments can be found in the Python official documentation at <a href="https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments">https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments</a>.</p>
			<p>As a general rule, the first positional argument is the field title, which corresponds to the <code>string</code> keyword argument. The exception to this rule is the <strong class="bold">Selection</strong> fields and all the relational fields.</p>
			<p>The <code>string</code> attribute is used as the default text for the user interface labels. If the <code>string</code> attribute is not provided, it will be automatically generated from the field name, replacing underscores with spaces and capitalizing the first letter in each word. For example, the <code>date_published</code> default label is <strong class="bold">Date Published</strong>.</p>
			<p>For reference, this is the list of all the non-relational field types that are available, along with the positional arguments expected by each:</p>
			<ul>
				<li><code>Char(string)</code> is a simple text field. The only positional argument that's expected is the field label.</li>
				<li><code>Text(string)</code> is a multiline text field. The only positional argument is also the field label.</li>
				<li><code>Selection(selection, string)</code> is a drop-down selection list. The selection positional arguments is a <code>[("value", "Description"),]</code> list of tuples. For each pair, the first <a id="_idIndexMarker432"/>element is the value stored in the database, and the second element is the description presented in the user interface. Extension modules can add options to this list using the <code>selection_add</code> keyword argument.</li>
				<li><code>Html(string)</code> is stored as a text field but has specific handling for the user interface for HTML content presentation. For security reasons, it is sanitized by default, but this behavior can be overridden using the <code>sanitize=False</code> attribute.</li>
				<li><code>Integer(string)</code> is for integer numbers and expects a string argument for the field label.</li>
				<li><code>Float(string, digits)</code> stores floating-point numbers and has a second optional argument for the precision to use. This is an <code>(n, d)</code> tuple, where <code>n</code> is the total number of digits, and <code>d</code> is the number of those digits used for decimals.</li>
				<li><code>Monetary(string, currency_field)</code> is similar to a <code>float</code> field but has specific handling for currency values. The <code>currency_field</code> second argument is for the name of the currency field. By default, it is set to <code>currency_field="currency_id"</code>.</li>
				<li>The <code>Date(string)</code> and <code>Datetime(string)</code> fields are for dates and date-time values. They only expect the label text as a positional argument.</li>
				<li><code>Boolean(string)</code> stores True or False values and has one positional argument for the label text.</li>
				<li><code>Binary(string)</code> stores binary data, including images, and expects the string label positional argument.</li>
			</ul>
			<p>These field definitions provide the basic parameters that are usually used. Note that there are no required arguments, and Odoo will use reasonable defaults for the missing ones.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">The <code>Date</code> and <code>Datetime</code> fields are now handled in the ORM as Python date objects. In previous versions, they were handled as text representations. Because of this, when manipulated, an explicit conversion into a Python date object was needed, which would have to be converted back into a text string after.</p>
			<p>Text-based fields, including <code>Char</code>, <code>Text</code>, and <code>Html</code>, have a few specific attributes:</p>
			<ul>
				<li><code>size</code> (only for <code>Char</code> fields) sets the maximum allowed size. It is recommended to not use it unless there is <a id="_idIndexMarker433"/>a good reason for it; for example, a social security number with a maximum length allowed.</li>
				<li><code>translate=True</code> makes the field contents translatable, holding different values for different languages.</li>
				<li><code>trim</code> is set to <code>True</code> by default and automatically trims the surrounding white space, which is performed by the web client. This can be explicitly disabled by setting <code>trim=False</code>.<p class="callout-heading">Changes in Odoo 12</p><p class="callout">The <code>trim</code> field attribute was introduced in Odoo 12. In previous versions, text fields were saved along with the white space.</p></li>
			</ul>
			<p>Additionally, we also have relational field types available. These will be explained later in this chapter, in the <em class="italic">Relationships between models</em> section.</p>
			<p>Before we get to that, however, there is still more to know about the attributes of the basic field types, as explained in the next section.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor174"/>Common field attributes</h2>
			<p>So far, we have looked at <a id="_idIndexMarker434"/>the basic positional arguments available for several basic field types. However, there are more attributes available to us.</p>
			<p>The following keyword argument attributes are generally available to all field types:</p>
			<ul>
				<li><code>string</code> is the field's default label, to be used in the user interface. Except for <code>Selection</code> and relational fields, it is available as the first positional argument, so most of the time, it is not used as a keyword argument. If it's not provided, it is automatically generated from the field name.</li>
				<li><code>default</code> sets a default value for the field. It can be a fixed value (such as <code>default=True</code> in the <code>active</code> field), or a callable reference, either the named function reference or a <code>lambda</code> anonymous function.</li>
				<li><code>help</code> provides the text for tooltips that are displayed to users when hovering the mouse over the field in the UI.</li>
				<li><code>readonly=True</code> makes the field not editable in the user interface by default. This is not enforced at the API level: code in model methods will still be capable of writing to it, and a view definition can override this. It is only a user interface setting.</li>
				<li><code>required=True</code> makes the field mandatory in the user interface by default. This is enforced at the database level by adding a <code>NOT NULL</code> constraint to the database column.</li>
				<li><code>index=True</code> adds a database index to the field, for faster search operations at the expense of disk space usage and slower write operations.</li>
				<li><code>copy=False</code> has the field ignored when duplicating a record via the <code>copy()</code> ORM method. Field values are <a id="_idIndexMarker435"/>copied by default, except for to-many relational fields, which are not copied by default.</li>
				<li><code>deprecated=True</code> marks the field as deprecated. It will still work as usual, but any access to it will write a warning message to the server log.</li>
				<li><code>groups</code> allows you to limit the field's access and visibility to only some groups. It expects a comma-separated list of XML IDs for security groups; for example, <code>groups="base.group_user,base.group_system"</code>.</li>
				<li><code>states</code> expects dictionary mapping values for UI attributes, depending on the values of the <code>state</code> field. The attributes that can be used are <code>readonly</code>, <code>required</code>, and <code>invisible</code>; for example, <code>states={'done':[('readonly',True)]}</code>.<p class="callout-heading">Tip</p><p class="callout">Note that the <code>states</code> field attribute is equivalent to the <code>attrs</code> attribute in views. Also, views support a <code>states</code> attribute <a id="_idIndexMarker436"/>that has a different use: it is a comma-separated list of states in which the view element should be visible.</p></li>
			</ul>
			<p>Here is an example of the <code>name</code> field with all the available keyword arguments spelled out:</p>
			<pre>    name = fields.Char(
        "Title",
        default=None,
        help="Book cover title.",
        readonly=False,
        required=True,
        index=True,
        copy=False,
        deprecated=True,
        groups="",
        states={},
    )</pre>
			<p>Previous Odoo versions supported the <code>oldname="field"</code> attribute, which is used when a field is renamed in a <a id="_idIndexMarker437"/>newer version. It enabled the data in the old field to be automatically copied into the new field during the module upgrade process.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">The <code>oldname</code> field attribute was removed <a id="_idIndexMarker438"/>and is no longer available. The alternative is to use migration scripts.</p>
			<p>The preceding field attributes are generic and apply to all field types. Next, we will learn how to set default values on fields.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor175"/>Setting default values</h2>
			<p>As we mentioned <a id="_idIndexMarker439"/>previously, the <code>default</code> attribute can have a fixed value or a reference to a function to dynamically compute the default value.</p>
			<p>For trivial computations, we can use a <code>lambda</code> function to avoid the overhead of creating a named method function. Here is a common example of computing a default value with the current date and time:</p>
			<pre>    last_borrow_date = fields.Datetime(
        "Last Borrowed On",
        default=lambda self: fields.Datetime.now(),
    )</pre>
			<p>The <code>default</code> value can also be a function reference. This can be a name reference or a string with the function name.</p>
			<p>The following example uses a name reference to the <code>_default_last_borrow_date</code> function method:</p>
			<pre><strong class="bold">    def _default_last_borrow_date(self):</strong>
<strong class="bold">        return fields.Datetime.now()</strong>
    last_borrow_date = fields.Datetime(
        "Last Borrowed On",
<strong class="bold">        default=_default_last_borrow_date,</strong>
    )</pre>
			<p>And this example does the same, but uses a string with the function name:</p>
			<pre>    last_borrow_date = fields.Datetime(
        "Last Borrowed On",
<strong class="bold">        default="_default_last_borrow_date",</strong>
    ) 
<strong class="bold">    def _default_last_borrow_date(self):</strong>
<strong class="bold">        return fields.Datetime.now()</strong></pre>
			<p>With this latter method, the function name resolution is delayed at runtime, rather than Python file loading time. So, in the <a id="_idIndexMarker440"/>second example, we can reference a function declared later in the code, while in the first example, the function must be declared before the function declaration.</p>
			<p>Still, the general code convention here is to have the default value function defined before the field's definitions. Another argument for preferring the first approach, using the function name reference, is that code editors can detect typing errors if they support static code analysis.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor176"/>Automatic field names</h2>
			<p>Some field names <a id="_idIndexMarker441"/>are special, either because they are reserved by the ORM for special <a id="_idIndexMarker442"/>purposes, or because some built-in features make use of some default field names.</p>
			<p>The <code>id</code> field is reserved to be used as an automatic number, uniquely identifying each record, and is used as the database's primary key. It is automatically added to every model.</p>
			<p>The following fields are automatically created on new models unless the <code>_log_access=False</code> model attribute is set:</p>
			<ul>
				<li><code>create_uid</code> is for the user who created the record.</li>
				<li><code>create_date</code> is for the date and time when the record is created.</li>
				<li><code>write_uid</code> is for the last user to modify the record.</li>
				<li><code>write_date</code> is for the last date and time when the record was modified.</li>
			</ul>
			<p>The information in these fields is available in the web client when in a form view if you go to the <strong class="bold">Developer Mode</strong> menu and then click the <strong class="bold">View Metadata</strong> option.</p>
			<p>The preceding field names have a special meaning for the Odoo framework. Other than these, there are a few more field names that are used as defaults for some Odoo features. The next section describes them.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor177"/>Reserved field names</h2>
			<p>Some built-in API features<a id="_idIndexMarker443"/> expect specific field names by default. These are considered reserved field names, and we <a id="_idIndexMarker444"/>should avoid using them for purposes other than the expected ones.</p>
			<p>These are the reserved fields:</p>
			<ul>
				<li><code>name</code> or <code>x_name</code> of the <code>Char</code> type: These are used by default as the display name for the record. But a different field can be used for the display name by setting the <code>_rec_name</code> model attribute. Non-character field types are also known to work for this, and a number to text conversion will be forced for this.</li>
				<li><code>active</code> or <code>x_active</code> of the <code>Boolean</code> type: These allow you to deactivate records, making them invisible. Records with <code>active=False</code> are automatically excluded from queries unless the <code>{'active_test': False}</code> key is added to the environmental context. It can be used as a record <em class="italic">archive</em> or <em class="italic">soft delete</em> feature.</li>
				<li><code>state</code> of the <code>Selection</code> type: This represents basic states for the record life cycle. It enables the usage of the <code>states</code> field attribute to dynamically set the <code>readonly</code>, <code>required</code>, or <code>invisible</code> attributes; for example, <code>states={'draft': [('readonly', False)]}</code>.</li>
				<li><code>parent_id</code> of the <code>Many2one</code> type: This is used to define tree-like hierarchical structures, and enables <a id="_idIndexMarker445"/>the usage of the <code>child_of</code> and <code>parent_of</code> operators <a id="_idIndexMarker446"/>in domain expressions. The field to use as <code>parent_id</code> can be set to a different one using the <code>_parent_name</code> model attribute.</li>
				<li><code>parent_path</code> of the <code>Char</code> type: This can be used to optimize the usage of the <code>child_of</code> and <code>parent_of</code> operators in domain expressions. For proper operation, use <code>add index=True</code> to use a database index. We will discuss hierarchical relations later in this chapter, in the <em class="italic">Hierarchical relationships</em> section.</li>
				<li><code>company_id</code> of the <code>Many2one</code> type: This is used to identify the company that the record belongs to. An empty value means that the record is shared between companies. It is used by internal checks on company data consistency via the <code>_check_company</code> function.<p class="callout-heading">Changes in Odoo 14</p><p class="callout"><code>x_active</code> is now recognized as an equivalent to the <code>active</code> field and can be used for the same effect. This was introduced for better support for customizations using <strong class="bold">Developer Mode</strong> or the <strong class="bold">Odoo Studio</strong> app.</p></li>
			</ul>
			<p>So far, we have discussed <a id="_idIndexMarker447"/>non-relational fields. But a good part of an application data <a id="_idIndexMarker448"/>structure is about describing the relationships between entities. Let's look at that now.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor178"/>Relationships between models</h1>
			<p>Non-trivial business applications need to use relationships between the different entities involved. To do this, we need to use relational fields.</p>
			<p>Looking at the <code>Library</code> app, the <code>Book</code> model has the following relationships:</p>
			<ul>
				<li>Each book can have <a id="_idIndexMarker449"/>one publisher, and each <a id="_idIndexMarker450"/>publisher can have many books. From the book's point of view, this is a <em class="italic">many-to-one relationship</em>. It is implemented in the database as an integer field, holding the ID of the related publisher record, and a database foreign key in it, enforcing referential integrity.</li>
				<li>The reverse of this, from the publisher's point of view, is a <strong class="bold">one-to-many relation</strong>, meaning that each <a id="_idIndexMarker451"/>publisher can have many books. While this is also <a id="_idIndexMarker452"/>a field type in Odoo, its database representation relies on the many-to-one relationship. We know the books related to a publisher running a query on books, filtered by the publisher ID.</li>
				<li>Each book can have many authors, and each author can have many books. This is a <strong class="bold">many-to-many</strong> relationship. The inverse relationship is also a many-to-many relationship. In relational <a id="_idIndexMarker453"/>databases, many-to-many relationships are <a id="_idIndexMarker454"/>represented through a helper database table. Odoo will automatically take care of this, although we can have some control over the technical details if we want.</li>
			</ul>
			<p>We will explore each of these relationships in the following sections.</p>
			<p>A particular case is hierarchical relations, where records in a model are related to other records in the same model. We will introduce a book category model to explain this.</p>
			<p>Finally, the Odoo framework also supports flexible relationships, where the same field is capable of representing relationships with <a id="_idIndexMarker455"/>several different models. These are called <code>Reference</code> fields.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor179"/>Many-to-one relationships</h2>
			<p>A <code>publisher_id</code> field represents a reference <a id="_idIndexMarker457"/>to the book publisher – a record in the <strong class="bold">Partner</strong> model.</p>
			<p>As a reminder, this is the publisher field definition using positional arguments only:</p>
			<pre>        publisher_id = fields.Many2one(
            "res.partner", "Publisher")</pre>
			<p>The preceding <code>Many2one</code> field definition uses positional arguments:</p>
			<ul>
				<li>The first positional argument is the related model, corresponding to the <code>comodel</code> keyword argument, which is <code>res.partner</code> in this case.</li>
				<li>The second positional argument is the field label, corresponding to the <code>string</code> keyword argument. This is not the case for the other relational fields, so the preferred option is to always use <code>string</code> as a keyword argument.</li>
			</ul>
			<p>A many-to-one model field creates a column in the database table, with a foreign key to the related table, and holds the database ID of the related record.</p>
			<p>Keyword arguments can be used instead of, or to complement, the positional argument. These are the keyword arguments that are supported by many-to-one fields:</p>
			<ul>
				<li><code>ondelete</code>: This defines what happens when the related record is deleted. The possible behaviors are as follows:<p><code>set null</code> (the default): An empty value is set when the related record is deleted.</p><p><code>restricted</code>: This raises an error, preventing the deletion.</p><p><code>cascade</code>: This will also delete this record when the related record is deleted.</p></li>
				<li><code>context</code>: This is a dictionary of data that's meaningful for the web client views to carry information when navigating through the relationship, such as to set default values. This will be explained in more detail in <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>.</li>
				<li><code>domain</code>: This is a domain expression – a list of tuples used to filter the records made available for selection on the relationship field. See <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>, for more details.</li>
				<li><code>auto_join=True</code>: This allows the ORM to use SQL joins when doing searches using this relationship. If used, the <a id="_idIndexMarker458"/>access security rules will be bypassed, and the <a id="_idIndexMarker459"/>user could have access to related records that the security rules would not allow, but the SQL queries will run faster.</li>
				<li><code>delegate=True</code>: This creates a delegation inheritance with the related model. When used, the <code>required=True</code> and <code>ondelete="cascade"</code> attributes must also be set. See <a href="B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 4</em></a>, <em class="italic">Extending Modules</em>, for more information on delegation inheritance.</li>
			</ul>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor180"/>One-to-many inverse relationships</h2>
			<p>A <strong class="bold">one-to-many relationship</strong> is the <a id="_idIndexMarker460"/>inverse of the many-to-one relationship. It lists the records that have <a id="_idIndexMarker461"/>a relationship with this record.</p>
			<p>For example, in the library book model, the <code>publisher_id</code> field has a many-to-one relationship with the partner model. This means that the partner model can have a one-to-many inverse relationship with the book model, listing the books published by each partner.</p>
			<p>Before a one-to-many relationship field can be created, the inverse many-to-one field should be added to the related model. For this, create the <code>library_app/models/res_partner.py</code> file with the following code:</p>
			<pre>from odoo import fields, models
class Partner(models.Model):
    _inherit = "res.partner"
<strong class="bold">    </strong><strong class="bold">published_book_ids = fields.One2many(</strong>
<strong class="bold">        "library.book",</strong>
<strong class="bold">        "publisher_id",</strong>
<strong class="bold">        string="Published Books")</strong></pre>
			<p>Since this is a new code file for the module, it must also be added to the <code>library_app/models/__init__.py</code> file:</p>
			<pre>from . import library_book
<strong class="bold">from . import res_partner</strong></pre>
			<p>The <code>One2many</code> fields expect three positional arguments:</p>
			<ul>
				<li>The related model, which corresponds to the <code>comodel_name</code> keyword argument</li>
				<li>The related model field <a id="_idIndexMarker462"/>that's used to refer to this record, which <a id="_idIndexMarker463"/>corresponds to the <code>inverse_name</code> keyword argument</li>
				<li>The field label, which corresponds to the <code>string</code> keyword argument</li>
			</ul>
			<p>The additional keyword arguments that are available are the same as those for the many-to-one fields: <code>context</code>, <code>domain</code>, <code>auto_join</code>, and <code>ondelete</code> (here, these act on the <strong class="bold">many</strong> sides of the relationship).</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor181"/>Many-to-many relationships</h2>
			<p>A <strong class="bold">many-to-many relationship</strong> is used when both entities have a to-many relationship between them. Using the library <a id="_idIndexMarker464"/>books example, there is a many-to-many relationship <a id="_idIndexMarker465"/>between books and authors: each book can have many authors, and each author can have many books.</p>
			<p>On the book's side – that is, the <code>library.book</code> model – we have the following:</p>
			<pre>class Book(models.Model)
    _name = "library.book"
<strong class="bold">    author_ids = fields.Many2many(</strong>
<strong class="bold">        "res.partner",</strong>
<strong class="bold">        string="Authors")</strong></pre>
			<p>On the author's side, we can have the <code>res.partner</code> model inverse relationship:</p>
			<pre>class Partner(models.Model): 
    _inherit = "res.partner"
<strong class="bold">    book_ids = fields.Many2many(</strong>
<strong class="bold">        "library.book",</strong>
<strong class="bold">        string="Authored Books")</strong></pre>
			<p>The <code>Many2many</code> minimal signature expects one positional argument for the related model – the <code>comodel_name</code> keyword argument – and it is recommended to also provide the <code>string</code> argument with the field label.</p>
			<p>At the database level, many-to-many relationships don't add any columns to the existing tables. Instead, a special <a id="_idIndexMarker466"/>relationship table is automatically created to store the relationships <a id="_idIndexMarker467"/>between records. This special table has only two ID fields, with foreign keys for each of the two related tables.</p>
			<p>By default, the relationship table's name is the two table names joined with an underscore and <code>_rel</code> appended at the end. In the case of our books or authors relationship, it should be named <code>library_book_res_partner_rel</code>.</p>
			<p>On some occasions, we may need to override these automatic defaults. One such case is when the related models have long names, and the name for the automatically generated relationship table is too long, exceeding the 63-character PostgreSQL limit. In these cases, we need to manually choose a name for the relationship table to conform to the table name size limit.</p>
			<p>Another case is when we need a second many-to-many relationship between the same models. In these cases, a relationship table name must be manually provided so that it doesn't collide with the table name already being used for the first relationship.</p>
			<p>There are two alternatives to manually override these values: either use positional arguments or keyword arguments.</p>
			<p>When using positional arguments for the field definition, the field definition looks like this:</p>
			<pre># Book &lt;-&gt; Authors relation (using positional args)
author_ids = fields.Many2many( 
    "res.partner",
    "library_book_res_partner_rel",
    "a_id",
    "b_id",
    "Authors")</pre>
			<p>Keyword arguments can be used instead, which may be preferred for readability:</p>
			<pre># Book &lt;-&gt; Authors relation (using keyword args)
author_ids = fields.Many2many(
    comodel_name="res.partner", 
    relation="library_book_res_partner_rel",
    column1="a_id",
    column2="b_id",
    string="Authors")</pre>
			<p>The following arguments were used here:</p>
			<ul>
				<li><code>comodel_name</code> is the name of the related model.</li>
				<li><code>relation</code> is the database <a id="_idIndexMarker468"/>table name supporting <a id="_idIndexMarker469"/>the relationship data.</li>
				<li><code>column1</code> is the column name referring to the model records.</li>
				<li><code>column2</code> is the column name referring to the related model records.</li>
				<li><code>string</code> is the field label in the user interface.</li>
			</ul>
			<p>Similar to one-to-many relational fields, many-to-many fields can also use the <code>context</code>, <code>domain</code>, and <code>auto_join</code> keyword arguments.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">On abstract models, don't use the many-to-many field <code>column1</code> and <code>column2</code> attributes. There is a limitation in the ORM design regarding abstract models, and when you force the names of the relationship columns, they cannot be cleanly inherited anymore.</p>
			<p>Parent-child relationships are a particular case that is worth looking into in more detail. We will do this in the next section.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor182"/>Hierarchical relationships</h2>
			<p>Parent-child tree relationships are represented using a many-to-one relationship with the same model, where each <a id="_idIndexMarker470"/>record holds a reference to its parent. The inverse one-to-many <a id="_idIndexMarker471"/>relationship represents the record's direct children.</p>
			<p>Odoo provides improved support for these hierarchical data structures, making the <code>child_of</code> and <code>parent_of</code> operators available in domain expressions. These operators are available so long as the model has a <code>parent_id</code> field (or the model has a <code>_parent_name</code> valid definition, setting an alternative field name to use for this purpose).</p>
			<p>Optimized hierarchy tree searching can be enabled by setting the <code>_parent_store=True</code> model attribute and adding the <code>parent_path</code> helper field. This helper field stores additional information about the hierarchy tree structure, which is used to run faster queries.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">The <code>parent_path</code> hierarchy helper field was introduced in Odoo 12. Previous versions used the <code>parent_left</code> and <code>parent_right</code> integer fields for the same purpose, but these were deprecated as of Odoo 12.</p>
			<p>As an example of a hierarchical structure, we will add a category tree to the <strong class="bold">Library</strong> app to be used to categorize books.</p>
			<p>Let's add the <code>library_app/models/library_book_category.py</code> file, along with the following code:</p>
			<pre>from odoo import api, fields, models
class BookCategory(models.Model):
    _name = "library.book.category"
    _description = "Book Category"
<strong class="bold">    _parent_store = True</strong>
    name = fields.Char(translate=True, required=True)
    # Hierarchy fields
<strong class="bold">    parent_id = fields.Many2one(</strong>
<strong class="bold">        "library.book.category",</strong>
<strong class="bold">        "Parent Category",</strong>
<strong class="bold">        ondelete="restrict")</strong>
<strong class="bold">    parent_path = fields.Char(index=True)</strong>
    # Optional, but nice to have:
<strong class="bold">    child_ids = fields.One2many(</strong>
<strong class="bold">        "library.book.category",</strong>
<strong class="bold">        </strong><strong class="bold">"parent_id",</strong>
<strong class="bold">        "Subcategories")</strong></pre>
			<p>Here, we have a basic model with a <code>parent_id</code> field to reference the parent record.</p>
			<p>To enable a faster tree search, we added the <code>_parent_store=True</code> model attribute. When doing so, the <code>parent_path</code> field must also be added, and it must be indexed. The field that's used to refer to the parent is expected to be named <code>parent_id</code>, but any other field name can be used, so long as we declare that in the <code>_parent_name</code> optional model attribute.</p>
			<p>It is often convenient to <a id="_idIndexMarker472"/>add a field to list the direct children. This is the one-to-many <a id="_idIndexMarker473"/>inverse relationship shown in the previous code.</p>
			<p>For the previous code to be used by our module, remember to add a reference to its file in <code>library_app/models/__init__.py</code>:</p>
			<pre><strong class="bold">from . import library_book_category</strong>
from . import library_book
from . import res_partner</pre>
			<p>Be aware that these additional operations come with storage and execution time penalties, so they are best used when you expect to read more frequently than write, such as in the case of category trees. This is only necessary when optimizing deep hierarchies with many nodes; this can be misused for small or shallow hierarchies.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor183"/>Flexible relationships using Reference fields</h2>
			<p>Regular relational fields can only reference one fixed co-model. The <code>Reference</code> field type does not have this <a id="_idIndexMarker474"/>limitation and supports flexible relationships, and<a id="_idIndexMarker475"/> the same field can reference records from different destination models.</p>
			<p>As an example, we will add a <code>Reference</code> field to the book category model, to indicate a highlighted book or author. This field can link to either a book or a partner record:</p>
			<pre>    highlighted_id = fields.Reference(
        [("library.book", "Book"), ("res.partner",
           "Author")],
        "Category Highlight",
    )</pre>
			<p>The field definition is similar to a <code>Selection</code> field, but here, the selection list holds the models that can be used on the field. In the user interface, the user will pick a model from the available list, and then pick a specific record from that model.</p>
			<p>Reference fields are stored in the database as a character field, containing a <code>&lt;model&gt;,&lt;id&gt;</code> string.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">Previous Odoo versions featured a referenceable model configuration that could be used to pick the models used in <code>Reference</code> fields from the <code>Reference</code> field, by adding the <code>odoo.addons.res.res_request.referenceable_models</code> function in place of the model selection list. This feature was removed in Odoo 12.</p>
			<p>With that, we've seen the field types that are supported by Odoo. Not only can fields store user-provided data, but they are also capable of presenting computed values. The next section introduces this feature.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor184"/>Computed fields</h1>
			<p>Fields can have their values <a id="_idIndexMarker476"/>automatically calculated by a function, instead of simply reading a <a id="_idIndexMarker477"/>database stored value. A computed field is declared just like a regular field but has the additional <code>compute</code> argument to define the function that's used for the computation.</p>
			<p>Computed fields involve writing some business logic. So, to take full advantage of this feature, we should be comfortable with the topics that will be explained in <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>. Computed fields will still be explained here, but we will keep the business logic as simple as possible.</p>
			<p>As an example, we will add a computed field to the <code>Books</code> model, displaying the publisher's country. This will allow the country to be displayed in the form view.</p>
			<p>The code that's needed to find the value is simple: if <code>book</code> represents a book record, we can use object dot notation <a id="_idIndexMarker478"/>to get the publisher's country using <code>book.publisher_id.country_id</code>.</p>
			<p>Edit the book model in the <code>library_app/models/library_book.py</code> file by adding the following code:</p>
			<pre>    publisher_country_id = fields.Many2one(
        "res.country", string="Publisher Country",
<strong class="bold">        compute="_compute_publisher_country",</strong>
    )
<strong class="bold">    @api.depends("publisher_id.country_id")</strong>
<strong class="bold">    def _compute_publisher_country(self):</strong>
<strong class="bold">        for book in self:</strong>
<strong class="bold">            book.publisher_country_id = </strong>
<strong class="bold">              book.publisher_id.country_id</strong></pre>
			<p>First, this code adds the <code>publisher_country_id</code> field and sets the compute attribute with the name of the method function to use for its computation, <code>_compute_publisher_country</code>.</p>
			<p>The function name was passed to the field as a string argument, but it may also be passed as a callable reference (the function identifier, without the surrounding quotes). In this case, we need to make sure the function is defined in the Python file before the field is.</p>
			<p>The coding convention for computation method names is to append the <code>_compute_</code> prefix to the computed field name.</p>
			<p>The <code>_compute_publisher_country</code> method receives a <code>self</code> record set to operate on and is expected to set the computed field values for all of those records. The code should iterate on the <code>self</code> recordset, to act on each record.</p>
			<p>The computed value is set using the usual assignment (write) operation. In our case, the computation is quite simple: we assign it to the current book's <code>publisher_id.country_id</code> value.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The same computation method can be used to compute two or more fields. In this case, the method should be used on the <code>compute</code> attribute of the computed fields, and the computation method should assign values to all of them.</p>
			<p>The computation function must always assign a value to the field, or fields, to compute. If your computation <a id="_idIndexMarker479"/>method has <code>if</code> conditions, make sure that all the run paths assign values <a id="_idIndexMarker480"/>to the computed fields. Computation methods will error if it misses assigning a value to some computed field(s).</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">Odoo 13 introduced <strong class="bold">computed writeable</strong> fields, intended to replace the <strong class="bold">onchange</strong> mechanism <a id="_idIndexMarker481"/>in the future. Computed writeable fields have a computation logic, triggered by changes on the dependencies, and also allow for the value to be directly set by users. This mechanism will be discussed alongside <strong class="bold">onchange</strong> in <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>.</p>
			<p>The <code>@api.depends</code> decorator is needed to specify the fields the computation depends on. It is used by the ORM to know when the computation needs to be triggered to update stored or cached values. One or more field names are accepted as arguments and dot-notation can be used to follow field relationships. In this example, the <code>publisher_country_id</code> field should be recomputed when <code>publisher_id.country_id</code> changes.</p>
			<p class="callout-heading">Warning</p>
			<p class="callout">Forgetting to add the <code>@api.depends</code> decorator to a computation method, or adding it but failing to add all the dependency fields used for the computation, will prevent the computed field from being recalculated when it is supposed to. This can lead to hard-to-identify bugs.</p>
			<p>We can see the <a id="_idIndexMarker482"/>result of our work by adding the <code>publisher_country_id</code> field <a id="_idIndexMarker483"/>to the book form view, in the <code>library_app/views/library_book.xml</code> file. Make sure that the selected publishers have the country set on them when trying this with a web client.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor185"/>Searching and writing on computed fields</h2>
			<p>The computed field we created can be read, but it cannot be searched or written to. By default, computed field values are computed immediately when read, and their values are not stored in the database. That's why they can't be searched like regular stored fields can.</p>
			<p>One way to work around this limitation is to have the computed values stored in the database by adding the <code>store = True</code> attribute. They will be recomputed when any of their dependencies change. Since the values are now stored, they can be searched just like regular fields, and a search function is not needed.</p>
			<p>Computed fields also support <a id="_idIndexMarker484"/>search and write operations without being stored<a id="_idIndexMarker485"/> in the database. This can be enabled by implementing specialized functions for these operations, alongside the <code>compute</code> function:</p>
			<ul>
				<li>A <code>search</code> function to implement the search logic</li>
				<li>An <code>inverse</code> function to implement the write logic</li>
			</ul>
			<p>Using these, our computed field declaration will look as follows:</p>
			<pre>    publisher_country_id = fields.Many2one(
        "res.country",
        string="Publisher Country",
        compute="_compute_publisher_country",
<strong class="bold">        inverse="_inverse_publisher_country",</strong>
<strong class="bold">        search="_search_publisher_country",</strong>
    )</pre>
			<p>To write on a computed field, we must implement the <em class="italic">inverse</em> logic of the value computation. This is why the function in charge of handling the write operation is called <code>inverse</code>.</p>
			<p>In this example, setting a value on <code>publisher_country_id</code> is expected to change the publisher's country.</p>
			<p>Note that this will also change the value that's seen in all the books with this publisher. Regular access controls apply to <a id="_idIndexMarker486"/>these write operations, so this action will only be <a id="_idIndexMarker487"/>successful if the current user also has to write access to the partner model.</p>
			<p>This inverse function implementation uses the values set on the computed field to perform the actual write operations needed to make this change persistent:</p>
			<pre>    def _inverse_publisher_country(self):
        for book in self:
            book.publisher_id.country_id = 
              book.publisher_country_id</pre>
			<p>The original value computation copies the <code>book.publisher_id.country_id</code> value to the <code>book.publisher_country_id</code> field. The inverse implementation, shown previously, does the opposite. It reads the value set on <code>book.publisher_country_id</code> and writes it to the <code>book.publisher_id.country_id</code> field.</p>
			<p>To enable search operations on a computed field, its <code>search</code> function must be implemented. The <code>search</code> function intercepts domain expressions operating on the computed field, and then replaces them with an alternative domain expression, using only regular stored fields.</p>
			<p>In the <code>publisher_country_id</code> example, the actual search should be done on the <code>country_id</code> field of the linked <code>publisher_id</code> partner record. Here is the function implementation for this translation:</p>
			<pre>    def _search_publisher_country(self, operator, value):
       return [
            ("publisher_id.country_id", operator, value)
        ]
"</pre>
			<p>When we perform a search on a model, a domain expression tuple is used as an argument, giving the details of the operator and the value that was used in the domain expression.</p>
			<p>The <code>search</code> function is triggered whenever this computed field is found in conditions of a domain expression. It receives <code>operator</code> and <code>value</code> for the search and is expected to translate the original <a id="_idIndexMarker488"/>search element into an alternative domain search <a id="_idIndexMarker489"/>expression. The <code>country_id</code> field is stored in the related partner model, so our search implementation just alters the original search expression to use the <code>publisher_id.country_id</code> field instead.</p>
			<p>For reference, domain expressions will be explained in more detail in <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor186"/>Related fields</h2>
			<p>The computed field we implemented in the previous section simply copies a value from a related record to a field of the <a id="_idIndexMarker490"/>model. This is a common use case and is needed when we want to present <a id="_idIndexMarker491"/>a field in a form from a related record. The Odoo framework provides a shortcut for this: the <strong class="bold">related field</strong> feature.</p>
			<p>Related fields make fields that belong to a related model available in a model and are accessible using a <em class="italic">dot notation chain</em>. This makes them available in cases where dot notation can't be used, such as UI form views.</p>
			<p>To create a related field, a field of the required type must be declared, and the <code>related</code> attribute must be used, with the dot notation field chain needed to reach the target-related field.</p>
			<p>A <code>related</code> field can be used to get the same effect as in the previous <code>publisher_country_id</code> computed field example.</p>
			<p>Here is the alternative implementation, now using a <code>related</code> field:</p>
			<pre>    publisher_country_id = fields.Many2one(
        "res.country",
        string="Publisher Country",
<strong class="bold">        related="publisher_id.country_id",</strong>
    )</pre>
			<p>Behind the scenes, related fields are just computed fields, and they also conveniently implement <code>search</code> and <code>inverse</code> methods. So, they can be searched and written on.</p>
			<p>By default, related fields are read-only, so the inverse write operation won't be available. To enable it, set the <code>readonly=False</code> field attribute.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">In previous Odoo versions, related fields were writable by default, but it was proven to be a dangerous default since it could allow changes to setup or master data in cases where that was not expected to be allowed. Because of this, starting with Odoo 12, the <code>related</code> fields are now read-only by default: <code>readonly=True</code>.</p>
			<p>It's also worth noting that <code>related</code> fields can also be stored in a database using <code>store=True</code>, just like any other computed field.</p>
			<p>With that, we've learned <a id="_idIndexMarker492"/>about the features supported by Odoo fields, including computed fields. Another important <a id="_idIndexMarker493"/>element regarding data structures is constraints that enforce data quality and integrity. This is what the next section will discuss.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor187"/>Model constraints</h1>
			<p>Often, applications need to <a id="_idIndexMarker494"/>ensure data integrity and enforce validations to ensure that the data is complete and correct.</p>
			<p>The PostgreSQL database manager supports many useful validations, such as avoiding duplicates or checking that values meet certain simple conditions. Odoo models can use the PostgreSQL constraints capabilities for this.</p>
			<p>Some checks require more sophisticated logic and are better implemented as Python code. For these cases, we can use specific model methods that implement that Python constraint logic.</p>
			<p>Let's learn more about these two possibilities.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor188"/>SQL model constraints</h2>
			<p>SQL constraints are<a id="_idIndexMarker495"/> added to the database table definition and are enforced directly by PostgreSQL. They are <a id="_idIndexMarker496"/>declared using the <code>_sql_constraints</code> class attribute.</p>
			<p>It is a list of tuples, and each tuple has a format of <code>(name, sql, message)</code>:</p>
			<ul>
				<li><code>name</code> is the constraint identifier name.</li>
				<li><code>sql</code> is the PostgreSQL syntax for the constraint.</li>
				<li><code>message</code> is the error message to present to users when the constraint is not verified.</li>
			</ul>
			<p>The most used SQL constraints are <code>UNIQUE</code> constraints, which are used to prevent data duplication, and <code>CHECK</code> constraints, which are used to test a SQL expression on the data.</p>
			<p>As an example, we will add two constraints to the <code>Book</code> model:</p>
			<ul>
				<li>Ensure that there are repeated books with the same title and publication date.</li>
				<li>Ensure that the publication date is not in the future.</li>
			</ul>
			<p>Edit the <code>library_app/models/library_book.py</code> file by adding the following code, which implements <a id="_idIndexMarker497"/>these two constraints. Usually, this goes after <a id="_idIndexMarker498"/>a section of the code with the field declarations:</p>
			<pre>    _sql_constraints = [
        ("library_book_name_date_uq",
         "UNIQUE (name, date_published)",
        "Title and publication date must be unique."),
        ("library_book_check_date",
         "CHECK (date_published &lt;= current_date)",
         "Publication date must not be in the future."),
    ]</pre>
			<p>For more information <a id="_idIndexMarker499"/>on the PostgreSQL constraint syntax, see the official documentation at <a href="https://www.postgresql.org/docs/current/ddl-constraints.html">https://www.postgresql.org/docs/current/ddl-constraints.html</a>.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor189"/>Python model constraints</h2>
			<p>Python constraints <a id="_idIndexMarker500"/>can use arbitrary code to perform validations. The validation <a id="_idIndexMarker501"/>function should be decorated with <code>@api.constrains</code> and the list of fields involved in the check. The validation is triggered when any of those fields are modified and should raise an exception if the condition fails – usually, <code>ValidationError</code>.</p>
			<p>In the case of the Library app, an obvious example is to prevent inserting incorrect ISBNs. We already have the logic to check that an ISBN is correct in the <code>_check_isbn()</code> method. We can use this in a model constraint to prevent saving incorrect data.</p>
			<p>Edit the <code>library_app/models/library_book.py</code> file <a id="_idIndexMarker502"/>by going to the top of the file and adding <a id="_idIndexMarker503"/>the following <code>import</code> statement:</p>
			<pre>from odoo.exceptions import ValidationError</pre>
			<p>Now, in the same file, add the following code to the <code>Book</code> class:</p>
			<pre>    @api.constrains("isbn")
    def _constrain_isbn_valid(self):
        for book in self:
            if book.isbn and not book._check_isbn():
                raise ValidationError(
                    "%s is an invalid ISBN" % book.isbn)</pre>
			<p>Python SQL constraints are usually added before the code section containing the field declaration.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor190"/>Overview of the Odoo base models</h1>
			<p>In the previous chapters, we had the chance to create new models, such as the <strong class="bold">Book</strong> model, but we also made use <a id="_idIndexMarker504"/>of the already existing models, such as the <strong class="bold">Partner</strong> model, provided by the Odoo base module. In this section, we will provide a short introduction to these built-in models.</p>
			<p>The Odoo core framework includes the <code>base</code> add-on module. It provides the essential features needed for Odoo apps to work. It can be found in the Odoo repository, in the<code>./odoo/addons/base</code> subdirectory.</p>
			<p>The standard add-on modules, which provide the official apps and features made available with Odoo, depend on and build on top of the <code>base</code> module. The standard add-ons can be found in the Odoo repository, in the <code>./addons</code> subdirectory.</p>
			<p>The <code>base</code> module provides two kinds of models:</p>
			<ul>
				<li>Information repository, <code>ir.*</code>, models</li>
				<li>Resources, <code>res.*</code>, models</li>
			</ul>
			<p>The <strong class="bold">information repository</strong> models <a id="_idIndexMarker505"/>are used to store basic data needed for the Odoo framework, such as <a id="_idIndexMarker506"/>Menus, Views, Models, and Actions. The data we find in the <strong class="bold">Technical</strong> menu is usually stored in information repository models.</p>
			<p>Some <a id="_idIndexMarker507"/>relevant examples are as follows:</p>
			<ul>
				<li><code>ir.actions.act_window</code> for <strong class="bold">Windows Actions</strong></li>
				<li><code>ir.config_parameter</code> for global configuration options</li>
				<li><code>ir.ui.menu</code> for <strong class="bold">Menu Items</strong></li>
				<li><code>ir.ui.view</code> for <strong class="bold">Views</strong></li>
				<li><code>ir.model</code> for <strong class="bold">Models</strong></li>
				<li><code>ir.model.fields</code> for model <strong class="bold">Fields</strong></li>
				<li><code>ir.model.data</code> for <strong class="bold">XML IDs</strong></li>
			</ul>
			<p>The <strong class="bold">resources</strong> models store <a id="_idIndexMarker508"/>basic master data<a id="_idIndexMarker509"/> that can be used by any module.</p>
			<p>These are the most important resource models:</p>
			<ul>
				<li><code>res.partner</code> for business partners, such as customers and suppliers, and addresses</li>
				<li><code>res.company</code> for company data</li>
				<li><code>res.country</code> for countries</li>
				<li><code>res.country.state</code> for states or regions inside countries</li>
				<li><code>res.currency</code> for currencies</li>
				<li><code>res.groups</code> for application security groups</li>
				<li><code>res.users</code> for application users</li>
			</ul>
			<p>This should provide useful context to help you understand the origin of these models.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor191"/>Summary</h1>
			<p>In this chapter, we learned about the different model types, such as transient and abstract models, and why these are useful for user interface wizards and mixins, respectively. Other relevant model features include Python and SQL constraints, which can be used to prevent data entry errors.</p>
			<p>We also learned about the available field types, as well as all the attributes they support, to be able to represent the business data in the most accurate way possible. We also learned about relationships fields, and how to use them to create relationships between the different entities that are used by our applications.</p>
			<p>After that, we saw that models are usually based on the <code>models.Model</code> class, but that we can also use <code>models.Abstract</code> for reusable mixin models and <code>models.Transient</code> for wizards or advanced user interaction dialogs. We saw the general model attributes that are available, such as <code>_order</code> for default sort order and <code>_rec_name</code> for the default field to use for record representation.</p>
			<p>The fields in a model define all the data they will store. We have also seen the non-relational field types that are available and the attributes they support. We also learned about the several types of relational fields – many-to-one, one-to-many, and many-to-many – and how they define relationships between models, including hierarchical parent/child relationships.</p>
			<p>Most fields store user input in databases, but fields can have values automatically computed by Python code. We saw how to implement computed fields and some advanced possibilities we have, such as making them writable and searchable.</p>
			<p>Also part of model definitions is constraints, enforcing data consistency, and validation. These can be implemented either using PostgreSQL or Python code.</p>
			<p>Now that we have created the data model, we should populate it with some default and demonstration data. In the next chapter, we will learn how to use data files to export, import, and load data using our system.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor192"/>Further reading</h1>
			<p>The official documentation for models can be found at <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html.</a></p>
		</div>
	</div></body></html>