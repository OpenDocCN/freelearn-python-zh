<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer054">
			<h1 id="_idParaDest-160"><em class="italic"><a id="_idTextAnchor164"/></em><a href="B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>: Models – Structuring the Application Data</h1>
			<p>In this chapter, we will learn more about the model layer and how to use models to design the data structures that support applications. We will explore the available model types, when each should be used, and how to define constraints that enforce data validations.</p>
			<p>Models are composed of data fields that support several data types, and some field types support defining relationships between models. More advanced usage of fields involves having values automatically computed using specific business logic.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Learning project – improving the Library app</li>
				<li>Creating models</li>
				<li>Creating fields</li>
				<li>Relationships between models</li>
				<li>Computed fields</li>
				<li>Model constraints</li>
				<li>Overview of the Odoo base models</li>
			</ul>
			<p>Throughout these topics, you will learn how to create non-trivial data structures for your Odoo projects. By the end of this chapter, you should have a clear overview of all the relevant features needed to structure data models.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor165"/>Technical requirements</h1>
			<p>This chapter is based on the code we created in <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>. This code can be found in the <strong class="source-inline">ch06/</strong> directory of this book's GitHub repository at <a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials">https://github.com/PacktPublishing/Odoo-15-Development-Essentials</a>.</p>
			<p>You should have it in your add-ons path. Make sure that you install the <strong class="source-inline">library_app</strong> module.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor166"/>Learning project – improving the Library app</h1>
			<p>In <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>, we created the <strong class="source-inline">library_app</strong> add-on module and implemented the <a id="_idIndexMarker406"/>simple <strong class="source-inline">library.book</strong> model to represent a book catalog. In this chapter, we will revisit that module to enrich the data that we can store for each book.</p>
			<p>We will add a category hierarchy to use for book categorization with the following structure:</p>
			<ul>
				<li><strong class="bold">Name</strong>: The category title</li>
				<li><strong class="bold">Parent</strong>: The parent category that it belongs to</li>
				<li><strong class="bold">Subcategories</strong>: The categories that have this one as the parent</li>
				<li><strong class="bold">Featured book or author</strong>: A selected book or author that represents this category</li>
			</ul>
			<p>A few more fields will be added to showcase the different data types available for Odoo fields. We will also use model constraints to implement a few validations on the Books model:</p>
			<ul>
				<li>The title and publication date should be unique.</li>
				<li>ISBNs entered should be valid.</li>
			</ul>
			<p>We will start by revisiting Odoo models, now in more depth, to learn about all the options that are available for us.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor167"/>Creating models</h1>
			<p>Models are at the heart of the Odoo framework. They describe the application data structures and are the bridge <a id="_idIndexMarker407"/>between the application server and the database storage. Business logic can be implemented around models to provide application features, and user interfaces are created on top of them to provide the user experience.</p>
			<p>In the following <a id="_idIndexMarker408"/>subsections, we will learn about the model's generic attributes, which <a id="_idIndexMarker409"/>are used to <a id="_idIndexMarker410"/>influence their behavior, and the several types we have available – <strong class="bold">regular models</strong>, <strong class="bold">transient models</strong>, and <strong class="bold">abstract models</strong>.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor168"/>Model attributes</h2>
			<p>Model classes can use <a id="_idIndexMarker411"/>additional attributes to control some behaviors. These are the most commonly used attributes:</p>
			<ul>
				<li><strong class="source-inline">_name</strong>: This is the internal identifier for the Odoo model we are creating. This is mandatory when creating a new model.</li>
				<li><strong class="source-inline">_description</strong>: This is a user-friendly title that can be used to refer to a single <strong class="source-inline">Model</strong> record, such as <strong class="source-inline">Book</strong>. This is optional but recommended. If this is not set, a server log warning will be displayed during the loading sequence.</li>
				<li><strong class="source-inline">_order</strong>: This sets the <a id="_idIndexMarker412"/>default order to use when the model's records are browsed, or shown in a list view. It is a text string to be used as the SQL order by clause, so it can be anything you could use there, although it has smart behavior and supports translatable and many-to-one field names.</li>
			</ul>
			<p>Our <strong class="source-inline">Book</strong> model is already using the <strong class="source-inline">_name</strong> and <strong class="source-inline">_description</strong> attributes. The following code adds the <strong class="source-inline">_order</strong> attribute to have the default order by book title, and then by reverse order of publication date (from newest to oldest):</p>
			<p class="source-code">class Book(models.Model):</p>
			<p class="source-code">    _name = "library.book"</p>
			<p class="source-code">    _description = "Book"</p>
			<p class="source-code">    _order = "name, date_published desc"</p>
			<p>There are a few more advanced attributes available that can be helpful in advanced cases:</p>
			<ul>
				<li><strong class="source-inline">_rec_name</strong>: This sets the field to use for the record's display name. By default, it is the <strong class="source-inline">name</strong> field, which is why we usually choose this particular field name for the records title field.</li>
				<li><strong class="source-inline">_table</strong>: This is the name of the database table supporting the model. Usually, it is left to be automatically set by the ORM, which will use the model name after replacing the dots with underscores. However, we are free to choose a specific database table name to be used.</li>
				<li><strong class="source-inline">_log_access=False</strong>: This can be used to prevent audit tracking fields from being automatically created; that is, <strong class="source-inline">create_uid</strong>, <strong class="source-inline">create_date</strong>, <strong class="source-inline">write_uid</strong>, and <strong class="source-inline">write_date</strong>.</li>
				<li><strong class="source-inline">_auto=False</strong>: This prevents the underlying database table from being automatically created. In this case, we should use the <strong class="source-inline">init()</strong> method to provide our specific logic for creating the supporting database object, a table, or a view. This is usually used for views that support read-only reports.</li>
			</ul>
			<p>As an example, the following code sets the default values on the <strong class="source-inline">library.book</strong> model:</p>
			<p class="source-code">    _recname = "name"</p>
			<p class="source-code">    _table = "library_book"</p>
			<p class="source-code">    _log_access = True</p>
			<p class="source-code">    _auto = True</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are also the <strong class="source-inline">_inherit</strong> and <strong class="source-inline">_inherits</strong> attributes, which are used for module extension. These were explained in detail in <a href="B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 4</em></a>, <em class="italic">Extending Modules</em>.</p>
			<p>When using <strong class="source-inline">_auto = False</strong>, we are overriding the process of creating the database object, so we should provide <a id="_idIndexMarker413"/>the logic for that. A frequent application of this is models to use for reports, based on a database view that gathers all the data needed for the report.</p>
			<p>Here is an example taken from the <strong class="source-inline">sale</strong> core module, in the <strong class="source-inline">sale/report/sale_report.py</strong> file:</p>
			<p class="source-code">    def init(self):</p>
			<p class="source-code">        tools.drop_view_if_exists(self.env.cr, self._table)</p>
			<p class="source-code">        self.env.cr.execute(</p>
			<p class="source-code">            "CREATE or REPLACE VIEW %s as (%s)"</p>
			<p class="source-code">            % (self._table, self._query())</p>
			<p class="source-code">        )  </p>
			<p>The preceding code uses a <strong class="source-inline">tools</strong> Python module, which needs to be imported using <strong class="source-inline">odoo import tools</strong>.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor169"/>Models and Python classes</h2>
			<p>Odoo models use Python classes. In the preceding <a id="_idIndexMarker414"/>code, we can see a Python class, <strong class="source-inline">Book</strong>, based on the <strong class="source-inline">models.Model</strong> class, being used to define an Odoo model named <strong class="source-inline">library.book</strong>.</p>
			<p>Odoo models are kept in a <em class="italic">central registry</em>, available through the <em class="italic">environment object</em>, which is usually accessed using <strong class="source-inline">self.env</strong>. The central registry keeps references to all the models available, and they can be accessed with a dictionary-like syntax.</p>
			<p>For example, to get a reference to the library book model inside a method, we could use <strong class="source-inline">self.env["library.book"]</strong> or <strong class="source-inline">self.env.get(["library.book"])</strong>.</p>
			<p>As you can see, model names are important and are the key to accessing the model registry.</p>
			<p>Model names must be globally unique. Because of this, it is a good practice to use the first word of the application the module belongs to as the first word in the model's name. In the case of the <strong class="source-inline">Library</strong> app, all model names should have <strong class="source-inline">library</strong> as a prefix. Other examples from the core modules are <strong class="source-inline">project</strong>, <strong class="source-inline">crm</strong>, or <strong class="source-inline">sale</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Model names should use the singular form, <strong class="source-inline">library.book</strong>, rather than <strong class="source-inline">library.books</strong>. The convention is to use a list of lowercase words joined with dots. The first word should identify the main app the model belongs to, such as <strong class="source-inline">library.book</strong> or <strong class="source-inline">library.book.category</strong>. Other examples that have been taken from official add-ons include <strong class="source-inline">project.project</strong>, <strong class="source-inline">project.task</strong>, and <strong class="source-inline">project.task.type</strong>.</p>
			<p>On the other hand, Python class identifiers are local to the Python file where they are declared and are not relevant to the Odoo framework. The identifier that's used for them is only significant for the code in that file and is rarely relevant. The Python convention for class identifiers is to use <em class="italic">CamelCase</em>, following the standards defined by the PEP8 coding conventions.</p>
			<p>There are several types of models available. The most frequently used one is the <strong class="source-inline">models.Model</strong> class, for persistent database stored models. Next, we will learn about the other available model types.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor170"/>Transient and abstract models</h2>
			<p>For most Odoo <a id="_idIndexMarker415"/>models, the Python <a id="_idIndexMarker416"/>class is <a id="_idIndexMarker417"/>based <a id="_idIndexMarker418"/>on <strong class="source-inline">models.Model</strong>. This type of model has permanent database persistence, which means that database tables are created for them and their records are stored until they're explicitly deleted. And most of the time, this is what you need.</p>
			<p>But in some cases, we don't need permanent database persistence, and hence these two other model types can be useful:</p>
			<ul>
				<li><strong class="bold">Transient models</strong>, based on <strong class="source-inline">models.TransientModel</strong>, are used for wizard-style user <a id="_idIndexMarker419"/>interaction. Their data is still stored in the database, but it is expected to <a id="_idIndexMarker420"/>be temporary. A vacuum job periodically clears old data from these tables. For example, the <strong class="bold">Settings</strong> | <strong class="bold">Translations</strong> | <strong class="bold">Import Translation</strong> menu option opens a dialog window that uses a transient model to store the user selections and implement the wizard logic. An example of using a transient model will be discussed in <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>.</li>
				<li><strong class="bold">Abstract models</strong> are based on the <strong class="source-inline">models.AbstractModel</strong> class and have no data storage <a id="_idIndexMarker421"/>attached to them. They can be used as reusable feature sets, to be mixed in with <a id="_idIndexMarker422"/>other models using Odoo's inheritance capabilities. For example, <strong class="source-inline">mail.thread</strong> is an abstract model provided by the <strong class="bold">Discuss</strong> app, which is used to add messages and follower features to other models. Mixin classes that use abstract models and the <strong class="source-inline">mail.thread</strong> example mentioned previously were discussed in <a href="B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 4</em></a>, <em class="italic">Extending Modules</em>.</li>
			</ul>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor171"/>Inspecting existing models</h2>
			<p>The models and fields <a id="_idIndexMarker423"/>that are created by Python classes can be inspected through the user interface. With <strong class="bold">Developer Mode</strong> enabled, via the <strong class="bold">Settings</strong> top menu, navigate to the <strong class="bold">Technical</strong> | <strong class="bold">Database Structure</strong> | <strong class="bold">Models</strong> menu item. Here, you will find a list of all the models available in the database.</p>
			<p>Clicking on a model in the list will open a form showing its details, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="Images/Figure_6.1_B16119.jpg" alt="Figure 6.1 – Inspecting the Book model from the Technical menu&#13;&#10;" width="1185" height="768"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Inspecting the Book model from the Technical menu</p>
			<p>This is a good tool for inspecting a model since it shows the results of all the modifications made by different modules. At the top <a id="_idIndexMarker424"/>right of the form, in the <strong class="bold">In Apps</strong> field, we can see the list of modules affecting it. In this example, we can see that <strong class="source-inline">library.book</strong> is affected by the <strong class="source-inline">library_app</strong> and <strong class="source-inline">library_member</strong> modules.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As seen in <a href="B16119_01_Final_PD_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Quick Start Using Developer Mode</em>, the <strong class="bold">Models</strong> form is editable! It is possible to create and modify models, fields, and views from here. You can use this to build prototypes that will be implemented as add-on modules later.</p>
			<p>In the lower area, we have some tabs with additional information available:</p>
			<ul>
				<li><strong class="bold">Fields</strong> lists the model fields.</li>
				<li><strong class="bold">Access Rights</strong> lists the access control rules granted to security groups.</li>
				<li><strong class="bold">Record Rules</strong> lists the record rules applying filters to records.</li>
				<li><strong class="bold">Notes</strong> is the model definition docstring.</li>
				<li><strong class="bold">Views</strong> lists the views available for the model.</li>
			</ul>
			<p>To find the model's external identifier or XML ID, we can use the <strong class="bold">Developer</strong> menu's <strong class="bold">View Metadata</strong> option. Model external identifiers are automatically generated by the ORM and follow a simple rule – the model name, replacing dots with underscores, prefixed with <strong class="source-inline">model_</strong>. As an example, the <a id="_idIndexMarker425"/>identifier that's generated for the <strong class="source-inline">library.book</strong> model, as created by the <strong class="source-inline">library_app</strong> module, is <strong class="source-inline">library_app.model_library_book</strong>. These XML IDs are usually needed for the CSV files defining the security ACLs.</p>
			<p>We are now familiar with the options we have for defining the model. The next step is to understand the several field types, as well as the options available to configure them.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor172"/>Creating fields</h1>
			<p>Having created a new model, the next step is to add fields to it. Odoo supports all the basic data types that are <a id="_idIndexMarker426"/>expected, such as text strings, integers, floating-point numbers, Booleans, dates and time, and image or binary data.</p>
			<p>Let's explore the several types of fields available in Odoo.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor173"/>Basic field types</h2>
			<p>We will go back to <a id="_idIndexMarker427"/>the book model to present the several available field types.</p>
			<p>In the <strong class="source-inline">library_app/models/library_book.py</strong> file, edit the <strong class="source-inline">Book</strong> class, replacing the current field definitions with this one:</p>
			<p class="source-code">class Book(models.Model):</p>
			<p class="source-code">    _name = "library.book"</p>
			<p class="source-code">    _description = "Book"</p>
			<p class="source-code">    # String fields:</p>
			<p class="source-code">    name = fields.Char("Title")</p>
			<p class="source-code">    isbn = fields.Char("ISBN")</p>
			<p class="source-code">    book_type = fields.Selection(</p>
			<p class="source-code">        [("paper","Paperback"),</p>
			<p class="source-code">         ("hard","Hardcover"),</p>
			<p class="source-code">         ("electronic","Electronic"),</p>
			<p class="source-code">         ("other", "Other")],</p>
			<p class="source-code">        "Type")</p>
			<p class="source-code">    notes = fields.Text("Internal Notes") </p>
			<p class="source-code">    descr = fields.Html("Description") </p>
			<p class="source-code">    # Numeric fields:</p>
			<p class="source-code">    copies = fields.Integer(default=1)</p>
			<p class="source-code">    avg_rating = fields.Float("Average Rating", (3, 2))</p>
			<p class="source-code">    price = fields.Monetary("Price", "currency_id") </p>
			<p class="source-code">    # price helper</p>
			<p class="source-code">    currency_id = fields.Many2one("res.currency")  </p>
			<p class="source-code">    # Date and time fields:</p>
			<p class="source-code">    date_published = fields.Date()</p>
			<p class="source-code">    last_borrow_date = fields.Datetime(</p>
			<p class="source-code">        "Last Borrowed On",</p>
			<p class="source-code">         default=lambda self: fields.Datetime.now()) </p>
			<p class="source-code">    # Other fields:</p>
			<p class="source-code">    active = fields.Boolean("Active?")</p>
			<p class="source-code">    image = fields.Binary("Cover") </p>
			<p class="source-code">    # Relational Fields</p>
			<p class="source-code">    publisher_id = fields.Many2one(</p>
			<p class="source-code">        "res.partner", string="Publisher")</p>
			<p class="source-code">    author_ids = fields.Many2many(</p>
			<p class="source-code">        "res.partner", string="Authors")</p>
			<p>These are examples of the non-relational field types that are available in Odoo with the positional <a id="_idIndexMarker428"/>arguments expected by each one. Next, we will explain all these field types and options. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Python functions can have two types of arguments: positional and keyword. </p>
			<p class="callout"><strong class="bold">Positional arguments</strong> are expected to be used in a specific order. For example, the call to <strong class="source-inline">fn(x, y)</strong> should <a id="_idIndexMarker429"/>be something such as <strong class="source-inline">f(1, 2)</strong>.</p>
			<p class="callout"><strong class="bold">Keyword arguments</strong> are passed with the name of the argument. For this same function, we could <a id="_idIndexMarker430"/>also use <strong class="source-inline">f(x=1, y=2)</strong>, or even mix both styles, with something such as <strong class="source-inline">f(1, y=2)</strong>.</p>
			<p class="callout">However, note that positional arguments must come before keyword arguments, so <strong class="source-inline">f(x=1, 2)</strong> is not allowed. More information <a id="_idIndexMarker431"/>on keyword arguments can be found in the Python official documentation at <a href="https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments">https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments</a>.</p>
			<p>As a general rule, the first positional argument is the field title, which corresponds to the <strong class="source-inline">string</strong> keyword argument. The exception to this rule is the <strong class="bold">Selection</strong> fields and all the relational fields.</p>
			<p>The <strong class="source-inline">string</strong> attribute is used as the default text for the user interface labels. If the <strong class="source-inline">string</strong> attribute is not provided, it will be automatically generated from the field name, replacing underscores with spaces and capitalizing the first letter in each word. For example, the <strong class="source-inline">date_published</strong> default label is <strong class="bold">Date Published</strong>.</p>
			<p>For reference, this is the list of all the non-relational field types that are available, along with the positional arguments expected by each:</p>
			<ul>
				<li><strong class="source-inline">Char(string)</strong> is a simple text field. The only positional argument that's expected is the field label.</li>
				<li><strong class="source-inline">Text(string)</strong> is a multiline text field. The only positional argument is also the field label.</li>
				<li><strong class="source-inline">Selection(selection, string)</strong> is a drop-down selection list. The selection positional arguments is a <strong class="source-inline">[("value", "Description"),]</strong> list of tuples. For each pair, the first <a id="_idIndexMarker432"/>element is the value stored in the database, and the second element is the description presented in the user interface. Extension modules can add options to this list using the <strong class="source-inline">selection_add</strong> keyword argument.</li>
				<li><strong class="source-inline">Html(string)</strong> is stored as a text field but has specific handling for the user interface for HTML content presentation. For security reasons, it is sanitized by default, but this behavior can be overridden using the <strong class="source-inline">sanitize=False</strong> attribute.</li>
				<li><strong class="source-inline">Integer(string)</strong> is for integer numbers and expects a string argument for the field label.</li>
				<li><strong class="source-inline">Float(string, digits)</strong> stores floating-point numbers and has a second optional argument for the precision to use. This is an <strong class="source-inline">(n, d)</strong> tuple, where <strong class="source-inline">n</strong> is the total number of digits, and <strong class="source-inline">d</strong> is the number of those digits used for decimals.</li>
				<li><strong class="source-inline">Monetary(string, currency_field)</strong> is similar to a <strong class="source-inline">float</strong> field but has specific handling for currency values. The <strong class="source-inline">currency_field</strong> second argument is for the name of the currency field. By default, it is set to <strong class="source-inline">currency_field="currency_id"</strong>.</li>
				<li>The <strong class="source-inline">Date(string)</strong> and <strong class="source-inline">Datetime(string)</strong> fields are for dates and date-time values. They only expect the label text as a positional argument.</li>
				<li><strong class="source-inline">Boolean(string)</strong> stores True or False values and has one positional argument for the label text.</li>
				<li><strong class="source-inline">Binary(string)</strong> stores binary data, including images, and expects the string label positional argument.</li>
			</ul>
			<p>These field definitions provide the basic parameters that are usually used. Note that there are no required arguments, and Odoo will use reasonable defaults for the missing ones.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">The <strong class="source-inline">Date</strong> and <strong class="source-inline">Datetime</strong> fields are now handled in the ORM as Python date objects. In previous versions, they were handled as text representations. Because of this, when manipulated, an explicit conversion into a Python date object was needed, which would have to be converted back into a text string after.</p>
			<p>Text-based fields, including <strong class="source-inline">Char</strong>, <strong class="source-inline">Text</strong>, and <strong class="source-inline">Html</strong>, have a few specific attributes:</p>
			<ul>
				<li><strong class="source-inline">size</strong> (only for <strong class="source-inline">Char</strong> fields) sets the maximum allowed size. It is recommended to not use it unless there is <a id="_idIndexMarker433"/>a good reason for it; for example, a social security number with a maximum length allowed.</li>
				<li><strong class="source-inline">translate=True</strong> makes the field contents translatable, holding different values for different languages.</li>
				<li><strong class="source-inline">trim</strong> is set to <strong class="source-inline">True</strong> by default and automatically trims the surrounding white space, which is performed by the web client. This can be explicitly disabled by setting <strong class="source-inline">trim=False</strong>.<p class="callout-heading">Changes in Odoo 12</p><p class="callout">The <strong class="source-inline">trim</strong> field attribute was introduced in Odoo 12. In previous versions, text fields were saved along with the white space.</p></li>
			</ul>
			<p>Additionally, we also have relational field types available. These will be explained later in this chapter, in the <em class="italic">Relationships between models</em> section.</p>
			<p>Before we get to that, however, there is still more to know about the attributes of the basic field types, as explained in the next section.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor174"/>Common field attributes</h2>
			<p>So far, we have looked at <a id="_idIndexMarker434"/>the basic positional arguments available for several basic field types. However, there are more attributes available to us.</p>
			<p>The following keyword argument attributes are generally available to all field types:</p>
			<ul>
				<li><strong class="source-inline">string</strong> is the field's default label, to be used in the user interface. Except for <strong class="source-inline">Selection</strong> and relational fields, it is available as the first positional argument, so most of the time, it is not used as a keyword argument. If it's not provided, it is automatically generated from the field name.</li>
				<li><strong class="source-inline">default</strong> sets a default value for the field. It can be a fixed value (such as <strong class="source-inline">default=True</strong> in the <strong class="source-inline">active</strong> field), or a callable reference, either the named function reference or a <strong class="source-inline">lambda</strong> anonymous function.</li>
				<li><strong class="source-inline">help</strong> provides the text for tooltips that are displayed to users when hovering the mouse over the field in the UI.</li>
				<li><strong class="source-inline">readonly=True</strong> makes the field not editable in the user interface by default. This is not enforced at the API level: code in model methods will still be capable of writing to it, and a view definition can override this. It is only a user interface setting.</li>
				<li><strong class="source-inline">required=True</strong> makes the field mandatory in the user interface by default. This is enforced at the database level by adding a <strong class="source-inline">NOT NULL</strong> constraint to the database column.</li>
				<li><strong class="source-inline">index=True</strong> adds a database index to the field, for faster search operations at the expense of disk space usage and slower write operations.</li>
				<li><strong class="source-inline">copy=False</strong> has the field ignored when duplicating a record via the <strong class="source-inline">copy()</strong> ORM method. Field values are <a id="_idIndexMarker435"/>copied by default, except for to-many relational fields, which are not copied by default.</li>
				<li><strong class="source-inline">deprecated=True</strong> marks the field as deprecated. It will still work as usual, but any access to it will write a warning message to the server log.</li>
				<li><strong class="source-inline">groups</strong> allows you to limit the field's access and visibility to only some groups. It expects a comma-separated list of XML IDs for security groups; for example, <strong class="source-inline">groups="base.group_user,base.group_system"</strong>.</li>
				<li><strong class="source-inline">states</strong> expects dictionary mapping values for UI attributes, depending on the values of the <strong class="source-inline">state</strong> field. The attributes that can be used are <strong class="source-inline">readonly</strong>, <strong class="source-inline">required</strong>, and <strong class="source-inline">invisible</strong>; for example, <strong class="source-inline">states={'done':[('readonly',True)]}</strong>.<p class="callout-heading">Tip</p><p class="callout">Note that the <strong class="source-inline">states</strong> field attribute is equivalent to the <strong class="source-inline">attrs</strong> attribute in views. Also, views support a <strong class="source-inline">states</strong> attribute <a id="_idIndexMarker436"/>that has a different use: it is a comma-separated list of states in which the view element should be visible.</p></li>
			</ul>
			<p>Here is an example of the <strong class="source-inline">name</strong> field with all the available keyword arguments spelled out:</p>
			<p class="source-code">    name = fields.Char(</p>
			<p class="source-code">        "Title",</p>
			<p class="source-code">        default=None,</p>
			<p class="source-code">        help="Book cover title.",</p>
			<p class="source-code">        readonly=False,</p>
			<p class="source-code">        required=True,</p>
			<p class="source-code">        index=True,</p>
			<p class="source-code">        copy=False,</p>
			<p class="source-code">        deprecated=True,</p>
			<p class="source-code">        groups="",</p>
			<p class="source-code">        states={},</p>
			<p class="source-code">    )</p>
			<p>Previous Odoo versions supported the <strong class="source-inline">oldname="field"</strong> attribute, which is used when a field is renamed in a <a id="_idIndexMarker437"/>newer version. It enabled the data in the old field to be automatically copied into the new field during the module upgrade process.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">The <strong class="source-inline">oldname</strong> field attribute was removed <a id="_idIndexMarker438"/>and is no longer available. The alternative is to use migration scripts.</p>
			<p>The preceding field attributes are generic and apply to all field types. Next, we will learn how to set default values on fields.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor175"/>Setting default values</h2>
			<p>As we mentioned <a id="_idIndexMarker439"/>previously, the <strong class="source-inline">default</strong> attribute can have a fixed value or a reference to a function to dynamically compute the default value.</p>
			<p>For trivial computations, we can use a <strong class="source-inline">lambda</strong> function to avoid the overhead of creating a named method function. Here is a common example of computing a default value with the current date and time:</p>
			<p class="source-code">    last_borrow_date = fields.Datetime(</p>
			<p class="source-code">        "Last Borrowed On",</p>
			<p class="source-code">        default=lambda self: fields.Datetime.now(),</p>
			<p class="source-code">    )</p>
			<p>The <strong class="source-inline">default</strong> value can also be a function reference. This can be a name reference or a string with the function name.</p>
			<p>The following example uses a name reference to the <strong class="source-inline">_default_last_borrow_date</strong> function method:</p>
			<p class="source-code"><strong class="bold">    def _default_last_borrow_date(self):</strong></p>
			<p class="source-code"><strong class="bold">        return fields.Datetime.now()</strong></p>
			<p class="source-code">    last_borrow_date = fields.Datetime(</p>
			<p class="source-code">        "Last Borrowed On",</p>
			<p class="source-code"><strong class="bold">        default=_default_last_borrow_date,</strong></p>
			<p class="source-code">    )</p>
			<p>And this example does the same, but uses a string with the function name:</p>
			<p class="source-code">    last_borrow_date = fields.Datetime(</p>
			<p class="source-code">        "Last Borrowed On",</p>
			<p class="source-code"><strong class="bold">        default="_default_last_borrow_date",</strong></p>
			<p class="source-code">    ) </p>
			<p class="source-code"><strong class="bold">    def _default_last_borrow_date(self):</strong></p>
			<p class="source-code"><strong class="bold">        return fields.Datetime.now()</strong></p>
			<p>With this latter method, the function name resolution is delayed at runtime, rather than Python file loading time. So, in the <a id="_idIndexMarker440"/>second example, we can reference a function declared later in the code, while in the first example, the function must be declared before the function declaration.</p>
			<p>Still, the general code convention here is to have the default value function defined before the field's definitions. Another argument for preferring the first approach, using the function name reference, is that code editors can detect typing errors if they support static code analysis.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor176"/>Automatic field names</h2>
			<p>Some field names <a id="_idIndexMarker441"/>are special, either because they are reserved by the ORM for special <a id="_idIndexMarker442"/>purposes, or because some built-in features make use of some default field names.</p>
			<p>The <strong class="source-inline">id</strong> field is reserved to be used as an automatic number, uniquely identifying each record, and is used as the database's primary key. It is automatically added to every model.</p>
			<p>The following fields are automatically created on new models unless the <strong class="source-inline">_log_access=False</strong> model attribute is set:</p>
			<ul>
				<li><strong class="source-inline">create_uid</strong> is for the user who created the record.</li>
				<li><strong class="source-inline">create_date</strong> is for the date and time when the record is created.</li>
				<li><strong class="source-inline">write_uid</strong> is for the last user to modify the record.</li>
				<li><strong class="source-inline">write_date</strong> is for the last date and time when the record was modified.</li>
			</ul>
			<p>The information in these fields is available in the web client when in a form view if you go to the <strong class="bold">Developer Mode</strong> menu and then click the <strong class="bold">View Metadata</strong> option.</p>
			<p>The preceding field names have a special meaning for the Odoo framework. Other than these, there are a few more field names that are used as defaults for some Odoo features. The next section describes them.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor177"/>Reserved field names</h2>
			<p>Some built-in API features<a id="_idIndexMarker443"/> expect specific field names by default. These are considered reserved field names, and we <a id="_idIndexMarker444"/>should avoid using them for purposes other than the expected ones.</p>
			<p>These are the reserved fields:</p>
			<ul>
				<li><strong class="source-inline">name</strong> or <strong class="source-inline">x_name</strong> of the <strong class="source-inline">Char</strong> type: These are used by default as the display name for the record. But a different field can be used for the display name by setting the <strong class="source-inline">_rec_name</strong> model attribute. Non-character field types are also known to work for this, and a number to text conversion will be forced for this.</li>
				<li><strong class="source-inline">active</strong> or <strong class="source-inline">x_active</strong> of the <strong class="source-inline">Boolean</strong> type: These allow you to deactivate records, making them invisible. Records with <strong class="source-inline">active=False</strong> are automatically excluded from queries unless the <strong class="source-inline">{'active_test': False}</strong> key is added to the environmental context. It can be used as a record <em class="italic">archive</em> or <em class="italic">soft delete</em> feature.</li>
				<li><strong class="source-inline">state</strong> of the <strong class="source-inline">Selection</strong> type: This represents basic states for the record life cycle. It enables the usage of the <strong class="source-inline">states</strong> field attribute to dynamically set the <strong class="source-inline">readonly</strong>, <strong class="source-inline">required</strong>, or <strong class="source-inline">invisible</strong> attributes; for example, <strong class="source-inline">states={'draft': [('readonly', False)]}</strong>.</li>
				<li><strong class="source-inline">parent_id</strong> of the <strong class="source-inline">Many2one</strong> type: This is used to define tree-like hierarchical structures, and enables <a id="_idIndexMarker445"/>the usage of the <strong class="source-inline">child_of</strong> and <strong class="source-inline">parent_of</strong> operators <a id="_idIndexMarker446"/>in domain expressions. The field to use as <strong class="source-inline">parent_id</strong> can be set to a different one using the <strong class="source-inline">_parent_name</strong> model attribute.</li>
				<li><strong class="source-inline">parent_path</strong> of the <strong class="source-inline">Char</strong> type: This can be used to optimize the usage of the <strong class="source-inline">child_of</strong> and <strong class="source-inline">parent_of</strong> operators in domain expressions. For proper operation, use <strong class="source-inline">add index=True</strong> to use a database index. We will discuss hierarchical relations later in this chapter, in the <em class="italic">Hierarchical relationships</em> section.</li>
				<li><strong class="source-inline">company_id</strong> of the <strong class="source-inline">Many2one</strong> type: This is used to identify the company that the record belongs to. An empty value means that the record is shared between companies. It is used by internal checks on company data consistency via the <strong class="source-inline">_check_company</strong> function.<p class="callout-heading">Changes in Odoo 14</p><p class="callout"><strong class="source-inline">x_active</strong> is now recognized as an equivalent to the <strong class="source-inline">active</strong> field and can be used for the same effect. This was introduced for better support for customizations using <strong class="bold">Developer Mode</strong> or the <strong class="bold">Odoo Studio</strong> app.</p></li>
			</ul>
			<p>So far, we have discussed <a id="_idIndexMarker447"/>non-relational fields. But a good part of an application data <a id="_idIndexMarker448"/>structure is about describing the relationships between entities. Let's look at that now.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor178"/>Relationships between models</h1>
			<p>Non-trivial business applications need to use relationships between the different entities involved. To do this, we need to use relational fields.</p>
			<p>Looking at the <strong class="source-inline">Library</strong> app, the <strong class="source-inline">Book</strong> model has the following relationships:</p>
			<ul>
				<li>Each book can have <a id="_idIndexMarker449"/>one publisher, and each <a id="_idIndexMarker450"/>publisher can have many books. From the book's point of view, this is a <em class="italic">many-to-one relationship</em>. It is implemented in the database as an integer field, holding the ID of the related publisher record, and a database foreign key in it, enforcing referential integrity.</li>
				<li>The reverse of this, from the publisher's point of view, is a <strong class="bold">one-to-many relation</strong>, meaning that each <a id="_idIndexMarker451"/>publisher can have many books. While this is also <a id="_idIndexMarker452"/>a field type in Odoo, its database representation relies on the many-to-one relationship. We know the books related to a publisher running a query on books, filtered by the publisher ID.</li>
				<li>Each book can have many authors, and each author can have many books. This is a <strong class="bold">many-to-many</strong> relationship. The inverse relationship is also a many-to-many relationship. In relational <a id="_idIndexMarker453"/>databases, many-to-many relationships are <a id="_idIndexMarker454"/>represented through a helper database table. Odoo will automatically take care of this, although we can have some control over the technical details if we want.</li>
			</ul>
			<p>We will explore each of these relationships in the following sections.</p>
			<p>A particular case is hierarchical relations, where records in a model are related to other records in the same model. We will introduce a book category model to explain this.</p>
			<p>Finally, the Odoo framework also supports flexible relationships, where the same field is capable of representing relationships with <a id="_idIndexMarker455"/>several different models. These are called <strong class="source-inline">Reference</strong> fields.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor179"/>Many-to-one relationships</h2>
			<p>A <strong class="bold">many-to-one relationship</strong> is a reference to a record in another model. For example, in the library book <a id="_idIndexMarker456"/>model, the <strong class="source-inline">publisher_id</strong> field represents a reference <a id="_idIndexMarker457"/>to the book publisher – a record in the <strong class="bold">Partner</strong> model.</p>
			<p>As a reminder, this is the publisher field definition using positional arguments only:</p>
			<p class="source-code">        publisher_id = fields.Many2one(</p>
			<p class="source-code">            "res.partner", "Publisher")</p>
			<p>The preceding <strong class="source-inline">Many2one</strong> field definition uses positional arguments:</p>
			<ul>
				<li>The first positional argument is the related model, corresponding to the <strong class="source-inline">comodel</strong> keyword argument, which is <strong class="source-inline">res.partner</strong> in this case.</li>
				<li>The second positional argument is the field label, corresponding to the <strong class="source-inline">string</strong> keyword argument. This is not the case for the other relational fields, so the preferred option is to always use <strong class="source-inline">string</strong> as a keyword argument.</li>
			</ul>
			<p>A many-to-one model field creates a column in the database table, with a foreign key to the related table, and holds the database ID of the related record.</p>
			<p>Keyword arguments can be used instead of, or to complement, the positional argument. These are the keyword arguments that are supported by many-to-one fields:</p>
			<ul>
				<li><strong class="source-inline">ondelete</strong>: This defines what happens when the related record is deleted. The possible behaviors are as follows:<p><strong class="source-inline">set null</strong> (the default): An empty value is set when the related record is deleted.</p><p><strong class="source-inline">restricted</strong>: This raises an error, preventing the deletion.</p><p><strong class="source-inline">cascade</strong>: This will also delete this record when the related record is deleted.</p></li>
				<li><strong class="source-inline">context</strong>: This is a dictionary of data that's meaningful for the web client views to carry information when navigating through the relationship, such as to set default values. This will be explained in more detail in <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>.</li>
				<li><strong class="source-inline">domain</strong>: This is a domain expression – a list of tuples used to filter the records made available for selection on the relationship field. See <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>, for more details.</li>
				<li><strong class="source-inline">auto_join=True</strong>: This allows the ORM to use SQL joins when doing searches using this relationship. If used, the <a id="_idIndexMarker458"/>access security rules will be bypassed, and the <a id="_idIndexMarker459"/>user could have access to related records that the security rules would not allow, but the SQL queries will run faster.</li>
				<li><strong class="source-inline">delegate=True</strong>: This creates a delegation inheritance with the related model. When used, the <strong class="source-inline">required=True</strong> and <strong class="source-inline">ondelete="cascade"</strong> attributes must also be set. See <a href="B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 4</em></a>, <em class="italic">Extending Modules</em>, for more information on delegation inheritance.</li>
			</ul>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor180"/>One-to-many inverse relationships</h2>
			<p>A <strong class="bold">one-to-many relationship</strong> is the <a id="_idIndexMarker460"/>inverse of the many-to-one relationship. It lists the records that have <a id="_idIndexMarker461"/>a relationship with this record.</p>
			<p>For example, in the library book model, the <strong class="source-inline">publisher_id</strong> field has a many-to-one relationship with the partner model. This means that the partner model can have a one-to-many inverse relationship with the book model, listing the books published by each partner.</p>
			<p>Before a one-to-many relationship field can be created, the inverse many-to-one field should be added to the related model. For this, create the <strong class="source-inline">library_app/models/res_partner.py</strong> file with the following code:</p>
			<p class="source-code">from odoo import fields, models</p>
			<p class="source-code">class Partner(models.Model):</p>
			<p class="source-code">    _inherit = "res.partner"</p>
			<p class="source-code"><strong class="bold">    </strong><strong class="bold">published_book_ids = fields.One2many(</strong></p>
			<p class="source-code"><strong class="bold">        "library.book",</strong></p>
			<p class="source-code"><strong class="bold">        "publisher_id",</strong></p>
			<p class="source-code"><strong class="bold">        string="Published Books")</strong></p>
			<p>Since this is a new code file for the module, it must also be added to the <strong class="source-inline">library_app/models/__init__.py</strong> file:</p>
			<p class="source-code">from . import library_book</p>
			<p class="source-code"><strong class="bold">from . import res_partner</strong></p>
			<p>The <strong class="source-inline">One2many</strong> fields expect three positional arguments:</p>
			<ul>
				<li>The related model, which corresponds to the <strong class="source-inline">comodel_name</strong> keyword argument</li>
				<li>The related model field <a id="_idIndexMarker462"/>that's used to refer to this record, which <a id="_idIndexMarker463"/>corresponds to the <strong class="source-inline">inverse_name</strong> keyword argument</li>
				<li>The field label, which corresponds to the <strong class="source-inline">string</strong> keyword argument</li>
			</ul>
			<p>The additional keyword arguments that are available are the same as those for the many-to-one fields: <strong class="source-inline">context</strong>, <strong class="source-inline">domain</strong>, <strong class="source-inline">auto_join</strong>, and <strong class="source-inline">ondelete</strong> (here, these act on the <strong class="bold">many</strong> sides of the relationship).</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor181"/>Many-to-many relationships</h2>
			<p>A <strong class="bold">many-to-many relationship</strong> is used when both entities have a to-many relationship between them. Using the library <a id="_idIndexMarker464"/>books example, there is a many-to-many relationship <a id="_idIndexMarker465"/>between books and authors: each book can have many authors, and each author can have many books.</p>
			<p>On the book's side – that is, the <strong class="source-inline">library.book</strong> model – we have the following:</p>
			<p class="source-code">class Book(models.Model)</p>
			<p class="source-code">    _name = "library.book"</p>
			<p class="source-code"><strong class="bold">    author_ids = fields.Many2many(</strong></p>
			<p class="source-code"><strong class="bold">        "res.partner",</strong></p>
			<p class="source-code"><strong class="bold">        string="Authors")</strong></p>
			<p>On the author's side, we can have the <strong class="source-inline">res.partner</strong> model inverse relationship:</p>
			<p class="source-code">class Partner(models.Model): </p>
			<p class="source-code">    _inherit = "res.partner"</p>
			<p class="source-code"><strong class="bold">    book_ids = fields.Many2many(</strong></p>
			<p class="source-code"><strong class="bold">        "library.book",</strong></p>
			<p class="source-code"><strong class="bold">        string="Authored Books")</strong></p>
			<p>The <strong class="source-inline">Many2many</strong> minimal signature expects one positional argument for the related model – the <strong class="source-inline">comodel_name</strong> keyword argument – and it is recommended to also provide the <strong class="source-inline">string</strong> argument with the field label.</p>
			<p>At the database level, many-to-many relationships don't add any columns to the existing tables. Instead, a special <a id="_idIndexMarker466"/>relationship table is automatically created to store the relationships <a id="_idIndexMarker467"/>between records. This special table has only two ID fields, with foreign keys for each of the two related tables.</p>
			<p>By default, the relationship table's name is the two table names joined with an underscore and <strong class="source-inline">_rel</strong> appended at the end. In the case of our books or authors relationship, it should be named <strong class="source-inline">library_book_res_partner_rel</strong>.</p>
			<p>On some occasions, we may need to override these automatic defaults. One such case is when the related models have long names, and the name for the automatically generated relationship table is too long, exceeding the 63-character PostgreSQL limit. In these cases, we need to manually choose a name for the relationship table to conform to the table name size limit.</p>
			<p>Another case is when we need a second many-to-many relationship between the same models. In these cases, a relationship table name must be manually provided so that it doesn't collide with the table name already being used for the first relationship.</p>
			<p>There are two alternatives to manually override these values: either use positional arguments or keyword arguments.</p>
			<p>When using positional arguments for the field definition, the field definition looks like this:</p>
			<p class="source-code"># Book &lt;-&gt; Authors relation (using positional args)</p>
			<p class="source-code">author_ids = fields.Many2many( </p>
			<p class="source-code">    "res.partner",</p>
			<p class="source-code">    "library_book_res_partner_rel",</p>
			<p class="source-code">    "a_id",</p>
			<p class="source-code">    "b_id",</p>
			<p class="source-code">    "Authors")</p>
			<p>Keyword arguments can be used instead, which may be preferred for readability:</p>
			<p class="source-code"># Book &lt;-&gt; Authors relation (using keyword args)</p>
			<p class="source-code">author_ids = fields.Many2many(</p>
			<p class="source-code">    comodel_name="res.partner", </p>
			<p class="source-code">    relation="library_book_res_partner_rel",</p>
			<p class="source-code">    column1="a_id",</p>
			<p class="source-code">    column2="b_id",</p>
			<p class="source-code">    string="Authors")</p>
			<p>The following arguments were used here:</p>
			<ul>
				<li><strong class="source-inline">comodel_name</strong> is the name of the related model.</li>
				<li><strong class="source-inline">relation</strong> is the database <a id="_idIndexMarker468"/>table name supporting <a id="_idIndexMarker469"/>the relationship data.</li>
				<li><strong class="source-inline">column1</strong> is the column name referring to the model records.</li>
				<li><strong class="source-inline">column2</strong> is the column name referring to the related model records.</li>
				<li><strong class="source-inline">string</strong> is the field label in the user interface.</li>
			</ul>
			<p>Similar to one-to-many relational fields, many-to-many fields can also use the <strong class="source-inline">context</strong>, <strong class="source-inline">domain</strong>, and <strong class="source-inline">auto_join</strong> keyword arguments.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">On abstract models, don't use the many-to-many field <strong class="source-inline">column1</strong> and <strong class="source-inline">column2</strong> attributes. There is a limitation in the ORM design regarding abstract models, and when you force the names of the relationship columns, they cannot be cleanly inherited anymore.</p>
			<p>Parent-child relationships are a particular case that is worth looking into in more detail. We will do this in the next section.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor182"/>Hierarchical relationships</h2>
			<p>Parent-child tree relationships are represented using a many-to-one relationship with the same model, where each <a id="_idIndexMarker470"/>record holds a reference to its parent. The inverse one-to-many <a id="_idIndexMarker471"/>relationship represents the record's direct children.</p>
			<p>Odoo provides improved support for these hierarchical data structures, making the <strong class="source-inline">child_of</strong> and <strong class="source-inline">parent_of</strong> operators available in domain expressions. These operators are available so long as the model has a <strong class="source-inline">parent_id</strong> field (or the model has a <strong class="source-inline">_parent_name</strong> valid definition, setting an alternative field name to use for this purpose).</p>
			<p>Optimized hierarchy tree searching can be enabled by setting the <strong class="source-inline">_parent_store=True</strong> model attribute and adding the <strong class="source-inline">parent_path</strong> helper field. This helper field stores additional information about the hierarchy tree structure, which is used to run faster queries.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">The <strong class="source-inline">parent_path</strong> hierarchy helper field was introduced in Odoo 12. Previous versions used the <strong class="source-inline">parent_left</strong> and <strong class="source-inline">parent_right</strong> integer fields for the same purpose, but these were deprecated as of Odoo 12.</p>
			<p>As an example of a hierarchical structure, we will add a category tree to the <strong class="bold">Library</strong> app to be used to categorize books.</p>
			<p>Let's add the <strong class="source-inline">library_app/models/library_book_category.py</strong> file, along with the following code:</p>
			<p class="source-code">from odoo import api, fields, models</p>
			<p class="source-code">class BookCategory(models.Model):</p>
			<p class="source-code">    _name = "library.book.category"</p>
			<p class="source-code">    _description = "Book Category"</p>
			<p class="source-code"><strong class="bold">    _parent_store = True</strong></p>
			<p class="source-code">    name = fields.Char(translate=True, required=True)</p>
			<p class="source-code">    # Hierarchy fields</p>
			<p class="source-code"><strong class="bold">    parent_id = fields.Many2one(</strong></p>
			<p class="source-code"><strong class="bold">        "library.book.category",</strong></p>
			<p class="source-code"><strong class="bold">        "Parent Category",</strong></p>
			<p class="source-code"><strong class="bold">        ondelete="restrict")</strong></p>
			<p class="source-code"><strong class="bold">    parent_path = fields.Char(index=True)</strong></p>
			<p class="source-code">    # Optional, but nice to have:</p>
			<p class="source-code"><strong class="bold">    child_ids = fields.One2many(</strong></p>
			<p class="source-code"><strong class="bold">        "library.book.category",</strong></p>
			<p class="source-code"><strong class="bold">        </strong><strong class="bold">"parent_id",</strong></p>
			<p class="source-code"><strong class="bold">        "Subcategories")</strong></p>
			<p>Here, we have a basic model with a <strong class="source-inline">parent_id</strong> field to reference the parent record.</p>
			<p>To enable a faster tree search, we added the <strong class="source-inline">_parent_store=True</strong> model attribute. When doing so, the <strong class="source-inline">parent_path</strong> field must also be added, and it must be indexed. The field that's used to refer to the parent is expected to be named <strong class="source-inline">parent_id</strong>, but any other field name can be used, so long as we declare that in the <strong class="source-inline">_parent_name</strong> optional model attribute.</p>
			<p>It is often convenient to <a id="_idIndexMarker472"/>add a field to list the direct children. This is the one-to-many <a id="_idIndexMarker473"/>inverse relationship shown in the previous code.</p>
			<p>For the previous code to be used by our module, remember to add a reference to its file in <strong class="source-inline">library_app/models/__init__.py</strong>:</p>
			<p class="source-code"><strong class="bold">from . import library_book_category</strong></p>
			<p class="source-code">from . import library_book</p>
			<p class="source-code">from . import res_partner</p>
			<p>Be aware that these additional operations come with storage and execution time penalties, so they are best used when you expect to read more frequently than write, such as in the case of category trees. This is only necessary when optimizing deep hierarchies with many nodes; this can be misused for small or shallow hierarchies.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor183"/>Flexible relationships using Reference fields</h2>
			<p>Regular relational fields can only reference one fixed co-model. The <strong class="source-inline">Reference</strong> field type does not have this <a id="_idIndexMarker474"/>limitation and supports flexible relationships, and<a id="_idIndexMarker475"/> the same field can reference records from different destination models.</p>
			<p>As an example, we will add a <strong class="source-inline">Reference</strong> field to the book category model, to indicate a highlighted book or author. This field can link to either a book or a partner record:</p>
			<p class="source-code">    highlighted_id = fields.Reference(</p>
			<p class="source-code">        [("library.book", "Book"), ("res.partner",</p>
			<p class="source-code">           "Author")],</p>
			<p class="source-code">        "Category Highlight",</p>
			<p class="source-code">    )</p>
			<p>The field definition is similar to a <strong class="source-inline">Selection</strong> field, but here, the selection list holds the models that can be used on the field. In the user interface, the user will pick a model from the available list, and then pick a specific record from that model.</p>
			<p>Reference fields are stored in the database as a character field, containing a <strong class="source-inline">&lt;model&gt;,&lt;id&gt;</strong> string.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">Previous Odoo versions featured a referenceable model configuration that could be used to pick the models used in <strong class="source-inline">Reference</strong> fields from the <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Database Structure</strong> menu. These configurations could be used in the <strong class="source-inline">Reference</strong> field, by adding the <strong class="source-inline">odoo.addons.res.res_request.referenceable_models</strong> function in place of the model selection list. This feature was removed in Odoo 12.</p>
			<p>With that, we've seen the field types that are supported by Odoo. Not only can fields store user-provided data, but they are also capable of presenting computed values. The next section introduces this feature.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor184"/>Computed fields</h1>
			<p>Fields can have their values <a id="_idIndexMarker476"/>automatically calculated by a function, instead of simply reading a <a id="_idIndexMarker477"/>database stored value. A computed field is declared just like a regular field but has the additional <strong class="source-inline">compute</strong> argument to define the function that's used for the computation.</p>
			<p>Computed fields involve writing some business logic. So, to take full advantage of this feature, we should be comfortable with the topics that will be explained in <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>. Computed fields will still be explained here, but we will keep the business logic as simple as possible.</p>
			<p>As an example, we will add a computed field to the <strong class="source-inline">Books</strong> model, displaying the publisher's country. This will allow the country to be displayed in the form view.</p>
			<p>The code that's needed to find the value is simple: if <strong class="source-inline">book</strong> represents a book record, we can use object dot notation <a id="_idIndexMarker478"/>to get the publisher's country using <strong class="source-inline">book.publisher_id.country_id</strong>.</p>
			<p>Edit the book model in the <strong class="source-inline">library_app/models/library_book.py</strong> file by adding the following code:</p>
			<p class="source-code">    publisher_country_id = fields.Many2one(</p>
			<p class="source-code">        "res.country", string="Publisher Country",</p>
			<p class="source-code"><strong class="bold">        compute="_compute_publisher_country",</strong></p>
			<p class="source-code">    )</p>
			<p class="source-code"><strong class="bold">    @api.depends("publisher_id.country_id")</strong></p>
			<p class="source-code"><strong class="bold">    def _compute_publisher_country(self):</strong></p>
			<p class="source-code"><strong class="bold">        for book in self:</strong></p>
			<p class="source-code"><strong class="bold">            book.publisher_country_id = </strong></p>
			<p class="source-code"><strong class="bold">              book.publisher_id.country_id</strong></p>
			<p>First, this code adds the <strong class="source-inline">publisher_country_id</strong> field and sets the compute attribute with the name of the method function to use for its computation, <strong class="source-inline">_compute_publisher_country</strong>.</p>
			<p>The function name was passed to the field as a string argument, but it may also be passed as a callable reference (the function identifier, without the surrounding quotes). In this case, we need to make sure the function is defined in the Python file before the field is.</p>
			<p>The coding convention for computation method names is to append the <strong class="source-inline">_compute_</strong> prefix to the computed field name.</p>
			<p>The <strong class="source-inline">_compute_publisher_country</strong> method receives a <strong class="source-inline">self</strong> record set to operate on and is expected to set the computed field values for all of those records. The code should iterate on the <strong class="source-inline">self</strong> recordset, to act on each record.</p>
			<p>The computed value is set using the usual assignment (write) operation. In our case, the computation is quite simple: we assign it to the current book's <strong class="source-inline">publisher_id.country_id</strong> value.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The same computation method can be used to compute two or more fields. In this case, the method should be used on the <strong class="source-inline">compute</strong> attribute of the computed fields, and the computation method should assign values to all of them.</p>
			<p>The computation function must always assign a value to the field, or fields, to compute. If your computation <a id="_idIndexMarker479"/>method has <strong class="source-inline">if</strong> conditions, make sure that all the run paths assign values <a id="_idIndexMarker480"/>to the computed fields. Computation methods will error if it misses assigning a value to some computed field(s).</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">Odoo 13 introduced <strong class="bold">computed writeable</strong> fields, intended to replace the <strong class="bold">onchange</strong> mechanism <a id="_idIndexMarker481"/>in the future. Computed writeable fields have a computation logic, triggered by changes on the dependencies, and also allow for the value to be directly set by users. This mechanism will be discussed alongside <strong class="bold">onchange</strong> in <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>.</p>
			<p>The <strong class="source-inline">@api.depends</strong> decorator is needed to specify the fields the computation depends on. It is used by the ORM to know when the computation needs to be triggered to update stored or cached values. One or more field names are accepted as arguments and dot-notation can be used to follow field relationships. In this example, the <strong class="source-inline">publisher_country_id</strong> field should be recomputed when <strong class="source-inline">publisher_id.country_id</strong> changes.</p>
			<p class="callout-heading">Warning</p>
			<p class="callout">Forgetting to add the <strong class="source-inline">@api.depends</strong> decorator to a computation method, or adding it but failing to add all the dependency fields used for the computation, will prevent the computed field from being recalculated when it is supposed to. This can lead to hard-to-identify bugs.</p>
			<p>We can see the <a id="_idIndexMarker482"/>result of our work by adding the <strong class="source-inline">publisher_country_id</strong> field <a id="_idIndexMarker483"/>to the book form view, in the <strong class="source-inline">library_app/views/library_book.xml</strong> file. Make sure that the selected publishers have the country set on them when trying this with a web client.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor185"/>Searching and writing on computed fields</h2>
			<p>The computed field we created can be read, but it cannot be searched or written to. By default, computed field values are computed immediately when read, and their values are not stored in the database. That's why they can't be searched like regular stored fields can.</p>
			<p>One way to work around this limitation is to have the computed values stored in the database by adding the <strong class="source-inline">store = True</strong> attribute. They will be recomputed when any of their dependencies change. Since the values are now stored, they can be searched just like regular fields, and a search function is not needed.</p>
			<p>Computed fields also support <a id="_idIndexMarker484"/>search and write operations without being stored<a id="_idIndexMarker485"/> in the database. This can be enabled by implementing specialized functions for these operations, alongside the <strong class="source-inline">compute</strong> function:</p>
			<ul>
				<li>A <strong class="source-inline">search</strong> function to implement the search logic</li>
				<li>An <strong class="source-inline">inverse</strong> function to implement the write logic</li>
			</ul>
			<p>Using these, our computed field declaration will look as follows:</p>
			<p class="source-code">    publisher_country_id = fields.Many2one(</p>
			<p class="source-code">        "res.country",</p>
			<p class="source-code">        string="Publisher Country",</p>
			<p class="source-code">        compute="_compute_publisher_country",</p>
			<p class="source-code"><strong class="bold">        inverse="_inverse_publisher_country",</strong></p>
			<p class="source-code"><strong class="bold">        search="_search_publisher_country",</strong></p>
			<p class="source-code">    )</p>
			<p>To write on a computed field, we must implement the <em class="italic">inverse</em> logic of the value computation. This is why the function in charge of handling the write operation is called <strong class="source-inline">inverse</strong>.</p>
			<p>In this example, setting a value on <strong class="source-inline">publisher_country_id</strong> is expected to change the publisher's country.</p>
			<p>Note that this will also change the value that's seen in all the books with this publisher. Regular access controls apply to <a id="_idIndexMarker486"/>these write operations, so this action will only be <a id="_idIndexMarker487"/>successful if the current user also has to write access to the partner model.</p>
			<p>This inverse function implementation uses the values set on the computed field to perform the actual write operations needed to make this change persistent:</p>
			<p class="source-code">    def _inverse_publisher_country(self):</p>
			<p class="source-code">        for book in self:</p>
			<p class="source-code">            book.publisher_id.country_id = </p>
			<p class="source-code">              book.publisher_country_id</p>
			<p>The original value computation copies the <strong class="source-inline">book.publisher_id.country_id</strong> value to the <strong class="source-inline">book.publisher_country_id</strong> field. The inverse implementation, shown previously, does the opposite. It reads the value set on <strong class="source-inline">book.publisher_country_id</strong> and writes it to the <strong class="source-inline">book.publisher_id.country_id</strong> field.</p>
			<p>To enable search operations on a computed field, its <strong class="source-inline">search</strong> function must be implemented. The <strong class="source-inline">search</strong> function intercepts domain expressions operating on the computed field, and then replaces them with an alternative domain expression, using only regular stored fields.</p>
			<p>In the <strong class="source-inline">publisher_country_id</strong> example, the actual search should be done on the <strong class="source-inline">country_id</strong> field of the linked <strong class="source-inline">publisher_id</strong> partner record. Here is the function implementation for this translation:</p>
			<p class="source-code">    def _search_publisher_country(self, operator, value):</p>
			<p class="source-code">       return [</p>
			<p class="source-code">            ("publisher_id.country_id", operator, value)</p>
			<p class="source-code">        ]</p>
			<p class="source-code">"</p>
			<p>When we perform a search on a model, a domain expression tuple is used as an argument, giving the details of the operator and the value that was used in the domain expression.</p>
			<p>The <strong class="source-inline">search</strong> function is triggered whenever this computed field is found in conditions of a domain expression. It receives <strong class="source-inline">operator</strong> and <strong class="source-inline">value</strong> for the search and is expected to translate the original <a id="_idIndexMarker488"/>search element into an alternative domain search <a id="_idIndexMarker489"/>expression. The <strong class="source-inline">country_id</strong> field is stored in the related partner model, so our search implementation just alters the original search expression to use the <strong class="source-inline">publisher_id.country_id</strong> field instead.</p>
			<p>For reference, domain expressions will be explained in more detail in <a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>, <em class="italic">Business Logic – Supporting Business Processes</em>.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor186"/>Related fields</h2>
			<p>The computed field we implemented in the previous section simply copies a value from a related record to a field of the <a id="_idIndexMarker490"/>model. This is a common use case and is needed when we want to present <a id="_idIndexMarker491"/>a field in a form from a related record. The Odoo framework provides a shortcut for this: the <strong class="bold">related field</strong> feature.</p>
			<p>Related fields make fields that belong to a related model available in a model and are accessible using a <em class="italic">dot notation chain</em>. This makes them available in cases where dot notation can't be used, such as UI form views.</p>
			<p>To create a related field, a field of the required type must be declared, and the <strong class="source-inline">related</strong> attribute must be used, with the dot notation field chain needed to reach the target-related field.</p>
			<p>A <strong class="source-inline">related</strong> field can be used to get the same effect as in the previous <strong class="source-inline">publisher_country_id</strong> computed field example.</p>
			<p>Here is the alternative implementation, now using a <strong class="source-inline">related</strong> field:</p>
			<p class="source-code">    publisher_country_id = fields.Many2one(</p>
			<p class="source-code">        "res.country",</p>
			<p class="source-code">        string="Publisher Country",</p>
			<p class="source-code"><strong class="bold">        related="publisher_id.country_id",</strong></p>
			<p class="source-code">    )</p>
			<p>Behind the scenes, related fields are just computed fields, and they also conveniently implement <strong class="source-inline">search</strong> and <strong class="source-inline">inverse</strong> methods. So, they can be searched and written on.</p>
			<p>By default, related fields are read-only, so the inverse write operation won't be available. To enable it, set the <strong class="source-inline">readonly=False</strong> field attribute.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">In previous Odoo versions, related fields were writable by default, but it was proven to be a dangerous default since it could allow changes to setup or master data in cases where that was not expected to be allowed. Because of this, starting with Odoo 12, the <strong class="source-inline">related</strong> fields are now read-only by default: <strong class="source-inline">readonly=True</strong>.</p>
			<p>It's also worth noting that <strong class="source-inline">related</strong> fields can also be stored in a database using <strong class="source-inline">store=True</strong>, just like any other computed field.</p>
			<p>With that, we've learned <a id="_idIndexMarker492"/>about the features supported by Odoo fields, including computed fields. Another important <a id="_idIndexMarker493"/>element regarding data structures is constraints that enforce data quality and integrity. This is what the next section will discuss.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor187"/>Model constraints</h1>
			<p>Often, applications need to <a id="_idIndexMarker494"/>ensure data integrity and enforce validations to ensure that the data is complete and correct.</p>
			<p>The PostgreSQL database manager supports many useful validations, such as avoiding duplicates or checking that values meet certain simple conditions. Odoo models can use the PostgreSQL constraints capabilities for this.</p>
			<p>Some checks require more sophisticated logic and are better implemented as Python code. For these cases, we can use specific model methods that implement that Python constraint logic.</p>
			<p>Let's learn more about these two possibilities.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor188"/>SQL model constraints</h2>
			<p>SQL constraints are<a id="_idIndexMarker495"/> added to the database table definition and are enforced directly by PostgreSQL. They are <a id="_idIndexMarker496"/>declared using the <strong class="source-inline">_sql_constraints</strong> class attribute.</p>
			<p>It is a list of tuples, and each tuple has a format of <strong class="source-inline">(name, sql, message)</strong>:</p>
			<ul>
				<li><strong class="source-inline">name</strong> is the constraint identifier name.</li>
				<li><strong class="source-inline">sql</strong> is the PostgreSQL syntax for the constraint.</li>
				<li><strong class="source-inline">message</strong> is the error message to present to users when the constraint is not verified.</li>
			</ul>
			<p>The most used SQL constraints are <strong class="source-inline">UNIQUE</strong> constraints, which are used to prevent data duplication, and <strong class="source-inline">CHECK</strong> constraints, which are used to test a SQL expression on the data.</p>
			<p>As an example, we will add two constraints to the <strong class="source-inline">Book</strong> model:</p>
			<ul>
				<li>Ensure that there are repeated books with the same title and publication date.</li>
				<li>Ensure that the publication date is not in the future.</li>
			</ul>
			<p>Edit the <strong class="source-inline">library_app/models/library_book.py</strong> file by adding the following code, which implements <a id="_idIndexMarker497"/>these two constraints. Usually, this goes after <a id="_idIndexMarker498"/>a section of the code with the field declarations:</p>
			<p class="source-code">    _sql_constraints = [</p>
			<p class="source-code">        ("library_book_name_date_uq",</p>
			<p class="source-code">         "UNIQUE (name, date_published)",</p>
			<p class="source-code">        "Title and publication date must be unique."),</p>
			<p class="source-code">        ("library_book_check_date",</p>
			<p class="source-code">         "CHECK (date_published &lt;= current_date)",</p>
			<p class="source-code">         "Publication date must not be in the future."),</p>
			<p class="source-code">    ]</p>
			<p>For more information <a id="_idIndexMarker499"/>on the PostgreSQL constraint syntax, see the official documentation at <a href="https://www.postgresql.org/docs/current/ddl-constraints.html">https://www.postgresql.org/docs/current/ddl-constraints.html</a>.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor189"/>Python model constraints</h2>
			<p>Python constraints <a id="_idIndexMarker500"/>can use arbitrary code to perform validations. The validation <a id="_idIndexMarker501"/>function should be decorated with <strong class="source-inline">@api.constrains</strong> and the list of fields involved in the check. The validation is triggered when any of those fields are modified and should raise an exception if the condition fails – usually, <strong class="source-inline">ValidationError</strong>.</p>
			<p>In the case of the Library app, an obvious example is to prevent inserting incorrect ISBNs. We already have the logic to check that an ISBN is correct in the <strong class="source-inline">_check_isbn()</strong> method. We can use this in a model constraint to prevent saving incorrect data.</p>
			<p>Edit the <strong class="source-inline">library_app/models/library_book.py</strong> file <a id="_idIndexMarker502"/>by going to the top of the file and adding <a id="_idIndexMarker503"/>the following <strong class="source-inline">import</strong> statement:</p>
			<p class="source-code">from odoo.exceptions import ValidationError</p>
			<p>Now, in the same file, add the following code to the <strong class="source-inline">Book</strong> class:</p>
			<p class="source-code">    @api.constrains("isbn")</p>
			<p class="source-code">    def _constrain_isbn_valid(self):</p>
			<p class="source-code">        for book in self:</p>
			<p class="source-code">            if book.isbn and not book._check_isbn():</p>
			<p class="source-code">                raise ValidationError(</p>
			<p class="source-code">                    "%s is an invalid ISBN" % book.isbn)</p>
			<p>Python SQL constraints are usually added before the code section containing the field declaration.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor190"/>Overview of the Odoo base models</h1>
			<p>In the previous chapters, we had the chance to create new models, such as the <strong class="bold">Book</strong> model, but we also made use <a id="_idIndexMarker504"/>of the already existing models, such as the <strong class="bold">Partner</strong> model, provided by the Odoo base module. In this section, we will provide a short introduction to these built-in models.</p>
			<p>The Odoo core framework includes the <strong class="source-inline">base</strong> add-on module. It provides the essential features needed for Odoo apps to work. It can be found in the Odoo repository, in the<strong class="source-inline">./odoo/addons/base</strong> subdirectory.</p>
			<p>The standard add-on modules, which provide the official apps and features made available with Odoo, depend on and build on top of the <strong class="source-inline">base</strong> module. The standard add-ons can be found in the Odoo repository, in the <strong class="source-inline">./addons</strong> subdirectory.</p>
			<p>The <strong class="source-inline">base</strong> module provides two kinds of models:</p>
			<ul>
				<li>Information repository, <strong class="source-inline">ir.*</strong>, models</li>
				<li>Resources, <strong class="source-inline">res.*</strong>, models</li>
			</ul>
			<p>The <strong class="bold">information repository</strong> models <a id="_idIndexMarker505"/>are used to store basic data needed for the Odoo framework, such as <a id="_idIndexMarker506"/>Menus, Views, Models, and Actions. The data we find in the <strong class="bold">Technical</strong> menu is usually stored in information repository models.</p>
			<p>Some <a id="_idIndexMarker507"/>relevant examples are as follows:</p>
			<ul>
				<li><strong class="source-inline">ir.actions.act_window</strong> for <strong class="bold">Windows Actions</strong></li>
				<li><strong class="source-inline">ir.config_parameter</strong> for global configuration options</li>
				<li><strong class="source-inline">ir.ui.menu</strong> for <strong class="bold">Menu Items</strong></li>
				<li><strong class="source-inline">ir.ui.view</strong> for <strong class="bold">Views</strong></li>
				<li><strong class="source-inline">ir.model</strong> for <strong class="bold">Models</strong></li>
				<li><strong class="source-inline">ir.model.fields</strong> for model <strong class="bold">Fields</strong></li>
				<li><strong class="source-inline">ir.model.data</strong> for <strong class="bold">XML IDs</strong></li>
			</ul>
			<p>The <strong class="bold">resources</strong> models store <a id="_idIndexMarker508"/>basic master data<a id="_idIndexMarker509"/> that can be used by any module.</p>
			<p>These are the most important resource models:</p>
			<ul>
				<li><strong class="source-inline">res.partner</strong> for business partners, such as customers and suppliers, and addresses</li>
				<li><strong class="source-inline">res.company</strong> for company data</li>
				<li><strong class="source-inline">res.country</strong> for countries</li>
				<li><strong class="source-inline">res.country.state</strong> for states or regions inside countries</li>
				<li><strong class="source-inline">res.currency</strong> for currencies</li>
				<li><strong class="source-inline">res.groups</strong> for application security groups</li>
				<li><strong class="source-inline">res.users</strong> for application users</li>
			</ul>
			<p>This should provide useful context to help you understand the origin of these models.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor191"/>Summary</h1>
			<p>In this chapter, we learned about the different model types, such as transient and abstract models, and why these are useful for user interface wizards and mixins, respectively. Other relevant model features include Python and SQL constraints, which can be used to prevent data entry errors.</p>
			<p>We also learned about the available field types, as well as all the attributes they support, to be able to represent the business data in the most accurate way possible. We also learned about relationships fields, and how to use them to create relationships between the different entities that are used by our applications.</p>
			<p>After that, we saw that models are usually based on the <strong class="source-inline">models.Model</strong> class, but that we can also use <strong class="source-inline">models.Abstract</strong> for reusable mixin models and <strong class="source-inline">models.Transient</strong> for wizards or advanced user interaction dialogs. We saw the general model attributes that are available, such as <strong class="source-inline">_order</strong> for default sort order and <strong class="source-inline">_rec_name</strong> for the default field to use for record representation.</p>
			<p>The fields in a model define all the data they will store. We have also seen the non-relational field types that are available and the attributes they support. We also learned about the several types of relational fields – many-to-one, one-to-many, and many-to-many – and how they define relationships between models, including hierarchical parent/child relationships.</p>
			<p>Most fields store user input in databases, but fields can have values automatically computed by Python code. We saw how to implement computed fields and some advanced possibilities we have, such as making them writable and searchable.</p>
			<p>Also part of model definitions is constraints, enforcing data consistency, and validation. These can be implemented either using PostgreSQL or Python code.</p>
			<p>Now that we have created the data model, we should populate it with some default and demonstration data. In the next chapter, we will learn how to use data files to export, import, and load data using our system.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor192"/>Further reading</h1>
			<p>The official documentation for models can be found at <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html.</a></p>
		</div>
	</div></body></html>