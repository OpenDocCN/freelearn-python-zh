- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Using Python for Trading Strategies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行交易策略
- en: Python has gained a reputation as the language of choice for the development
    of a wide range of applications in the financial industry and has become a de
    facto industry standard for the research phase of trading strategy development.
    However, as with any other language or, better put, programming ecosystem, it
    has its advantages and disadvantages. So, as with any tool, it is essential to
    understand its strong and weak points to use the tool properly (not trying to
    hammer nails with a microscope, so to say).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python已经成为金融行业中广泛应用的开发语言的首选，并成为交易策略开发研究阶段的事实上的行业标准。然而，就像任何其他语言或，更确切地说，编程生态系统一样，它有其优点和缺点。因此，就像任何工具一样，了解其优点和缺点对于正确使用工具至关重要（比如说，不要试图用显微镜敲钉子）。
- en: In this chapter, not only will we consider using Python for algorithmic trading
    strategy development but we will also learn about the essential steps in the research
    and development process, discuss the difference between market modeling and event-based
    trading, and point to the mistakes most typically made in the research and development
    process. Finally, we will see the limitations of using Python for algo trading
    so our expectations always meet reality.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不仅将考虑使用Python进行算法交易策略开发，还将学习研究和开发过程中的基本步骤，讨论市场建模和基于事件交易之间的区别，并指出在研究和开发过程中最常犯的错误。最后，我们将看到使用Python进行算法交易的局限性，以确保我们的期望始终与现实相符。
- en: We will quickly dive a bit deeper than just a surface overview to see how the
    strongest advantages of Python, such as native language structures and efficient
    **object-oriented programming** (**OOP**), help make the code transparent and
    keep the architecture of a trading app modular, flexible, and scalable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速深入探讨，不仅仅是对Python的表面概述，看看Python最强大的优势，如原生语言结构和高效的**面向对象编程**（**OOP**），如何帮助使代码透明，并保持交易应用架构的模块化、灵活性和可扩展性。
- en: By the end of this chapter, you will be familiar with the key concepts of trading
    and algo trading, applications of Python, and various **integrated development
    environments** (**IDEs**) for the research and development of trading strategies,
    and you will know the limits beyond which using Python is not efficient.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将熟悉交易和算法交易的关键概念、Python的应用以及用于交易策略研究和开发的多种**集成开发环境**（**IDE**），并且您将了解使用Python效率不高的限制。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The advantages of using Python in trading strategy development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python进行交易策略开发的优点
- en: Modeling – forecasting the future doesn’t necessarily mean practical benefits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建模——预测未来并不一定意味着实际效益
- en: Paper trading and backtesting – an essential part of a systemic trader’s risk
    management
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纸质交易和回测——系统交易员风险管理的一个基本部分
- en: The disadvantages of using Python in trading strategy development
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python进行交易策略开发的缺点
- en: Live trading – where Python faces its limits
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实交易——Python面临的限制
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need Python 3.10 or higher to run the code in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要Python 3.10或更高版本才能运行本章中的代码。
- en: The advantages of using Python in trading strategy development
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行交易策略开发的优点
- en: Today when we say *Python*, we most likely mean not only the most flexible object-oriented
    programming language but also the most powerful and convenient interactive IDEs,
    such as Spyder or PyCharm, along with the vast collection of libraries that extend
    this language to fit virtually any domain of applied and fundamental research,
    from medicine to astronomy. There is no surprise that the Python ecosystem has
    become the de facto standard in the financial industry where numbers play a decisive
    role.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们今天说*Python*时，我们很可能不仅指的是最灵活的面向对象编程语言，还包括最强大和方便的交互式集成开发环境（IDE），如Spyder或PyCharm，以及大量扩展此语言的库，使其几乎适合任何应用和基础研究的领域，从医学到天文学。在数字起决定性作用的金融行业中，Python生态系统已经成为事实上的标准，这并不令人惊讶。
- en: The advantages of using Python for the development of trading strategies are
    obvious and we will look into a few of these advantages in detail in the following
    sections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python进行交易策略开发的优点是显而易见的，我们将在以下几节中详细探讨这些优点。
- en: Memory management
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: Python is one of the few interpreters that has robust built-in memory management
    services such as garbage collection and reference counting. Essentially, this
    means that you don’t have to care about any complex object you work with and the
    amount of data processed by your code. Of course, this dramatically increases
    the development speed, especially if you work with large datasets – and trading
    applications work with large datasets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python是少数具有强大内置内存管理服务（如垃圾回收和引用计数）的解释器之一。本质上，这意味着你不必关心你工作中遇到的任何复杂对象以及你的代码处理的数据量。当然，这大大提高了开发速度，尤其是当你处理大量数据集时——交易应用处理大量数据集。
- en: Interactive computing
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式计算
- en: Python is an interpreted language and this means two important things.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种解释型语言，这意味着两件重要的事情。
- en: First, you can stop executing the code at any moment and check the environment
    at runtime, including all variables, functions, and objects – which is convenient
    for debugging.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以在任何时候停止代码的执行并检查运行时的环境，包括所有变量、函数和对象——这对于调试来说非常方便。
- en: Second, you can work with Python interactively. This means that in all Unix-like
    systems, we run Python in a console where we can send commands one by one and
    immediately get responses from the interpreter. If you develop trading applications,
    this allows you to quickly test some modules on small datasets before integrating
    them into the final code. It also allows you to quickly visualize any portion
    of a data set on the fly without rewriting and rerunning any code, which is invaluable
    for developing any applications that work with time series.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可以以交互式的方式使用Python。这意味着在所有类Unix系统中，我们在控制台中运行Python，可以逐个发送命令并立即从解释器那里获得响应。如果你开发交易应用，这允许你在将它们集成到最终代码之前，快速在小数据集上测试一些模块。这也允许你快速可视化数据集的任何部分，而无需重写和重新运行任何代码，这对于开发任何处理时间序列的应用程序来说是无价的。
- en: 'Working in a native console is not as convenient as in IPython – a command
    shell that supports introspection, rich media, syntax highlighting, tab completion,
    and history. Released in 2001 as an open source project, IPython quickly transformed
    Python into a direct competitor to Matlab, and thanks to the open source status
    and enormous community of contributors we can say that today, Python has won the
    competition. In 2014, a spin-off project based on IPython started with the idea
    of developing a universal interactive computing environment suitable not only
    for Python but also for other languages. This project was called Jupyter and today
    this is probably the most popular notebook-style interactive computing environment.
    Sometimes Jupyter is even considered a replacement for IPython; however, this
    is not really correct. DataCamp published an excellent article that explains the
    difference: [https://www.datacamp.com/blog/ipython-or-jupyter.](https://www.datacamp.com/blog/ipython-or-jupyter'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在原生控制台中工作不如在IPython中方便——IPython是一个支持内省、富媒体、语法高亮、自动补全和历史记录的命令行。作为2001年发布的一个开源项目，IPython迅速将Python转变为Matlab的直接竞争对手，多亏了开源状态和庞大的贡献者社区，我们可以说，如今Python已经赢得了这场竞争。2014年，一个基于IPython的衍生项目启动，其理念是开发一个通用的交互式计算环境，不仅适用于Python，也适用于其他语言。这个项目被称为Jupyter，如今这可能是最受欢迎的笔记本式交互计算环境。有时Jupyter甚至被认为是IPython的替代品；然而，这并不完全正确。DataCamp发布了一篇优秀的文章，解释了两者之间的区别：[https://www.datacamp.com/blog/ipython-or-jupyter.](https://www.datacamp.com/blog/ipython-or-jupyter)
- en: )
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Ease of integration and routing
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成和路由的便捷性
- en: If the previous two advantages are not specific to the development of trading
    applications, then what makes Python the preferred language for both trading research
    and development is the ease with which you can switch between *research mode*
    and *production mode*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前两个优势并非特定于交易应用的开发，那么使Python成为交易研究和开发首选语言的是，你可以轻松地在*研究模式*和*生产模式*之间切换。
- en: 'If you have carefully planned your data structures and codes (and this is what
    we will be learning to do throughout this book), then all essential modules of
    the trading app (which we drafted in the previous chapter) will be independent
    and replaceable. What advantage does this give you as a developer? The advantages
    are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经仔细规划了你的数据结构和代码（这正是我们将在整本书中学到的），那么交易应用（我们在上一章中制定的）的所有基本模块都将独立且可替换。这对作为开发者的你有什么优势？优势如下：
- en: It allows you to develop the trading logic using historical data and then replace
    the data source with a live stream from the broker.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你使用历史数据开发交易逻辑，然后使用来自经纪商的实时流替换数据源。
- en: It allows you to fine-tune and debug your application by simulating order execution
    and letting you switch to production using the same code you used for development.
    This reduces the risk of errors.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这允许你通过模拟订单执行来微调和调试你的应用程序，并让你使用与开发时相同的代码切换到生产环境。这降低了出错的风险。
- en: It allows you to scale your trading business by adding more execution venues,
    protocols, APIs, and trading accounts, keeping the rest of the code the same.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这允许你通过添加更多的执行场所、协议、API和交易账户来扩展你的交易业务，同时保持其余代码不变。
- en: Besides that, thanks to the interactivity of the Python environment, you can
    even intervene in the trading process manually. For example, you can send a `FIX`
    message to close all open positions in case of an emergency. Of course, this is
    *not* the best practice, or even something that can be recommended, but knowing
    that even in the worst unexpected scenario you can take urgent action straight
    from the familiar development environment adds to peace of mind.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，得益于Python环境的交互性，你甚至可以手动干预交易过程。例如，在紧急情况下，你可以发送一个`FIX`消息来关闭所有未平仓的头寸。当然，这*不是*最佳实践，甚至不是可以推荐的做法，但知道即使在最糟糕的意外情况下，你也能直接从熟悉的开发环境中采取紧急行动，这有助于增加安心感。
- en: Native language structures – lists and dictionaries
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生语言结构 - 列表和字典
- en: 'One of the key advantages of using Python for data processing is that it natively
    implements two powerful structures: lists and dictionaries.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python进行数据处理的一个关键优势是它原生实现了两个强大的结构：列表和字典。
- en: Trading applications work with time series, and having convenient tools to read,
    access, compress, and process this data is crucial. Using lists and dictionaries
    along with objects becomes quite efficient. Let’s consider an example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 交易应用处理时间序列数据，拥有方便的工具来读取、访问、压缩和处理这些数据至关重要。使用列表、字典以及对象变得相当高效。让我们考虑一个例子。
- en: 'Imagine we have tick data and want to transform it into OHLC data points (see
    the previous chapter for an explanation of OHLC). We can define such a data point,
    which in trading is normally called a *bar*, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些tick数据，并希望将其转换为OHLC数据点（有关OHLC的解释，请参阅上一章）。在交易中，这种数据点通常被称为*条形图*，我们可以如下定义：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we can create storage for our bars:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为我们的条形图创建存储：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we can define a native Python list where we store OHLC bars and the `self.last`
    pointer, which points to the last element that was read from the list. Then, we
    will add the `read` method, which returns the element to which the `self.last`
    pointer points.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以定义一个本地的Python列表，用于存储OHLC条形图和`self.last`指针，该指针指向列表中最后读取的元素。然后，我们将添加`read`方法，该方法返回`self.last`指针指向的元素。
- en: 'Then, instead of retrieving OHLC bars by index in the production code as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在生产代码中，我们不是通过索引检索OHLC条形图，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will retrieve closing prices without direct reference to the index:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检索收盘价，而不直接引用索引：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This streamlines working with time series (or any data series) dramatically
    as we no longer need to store indices in the main code and even more importantly
    – we reduce the risk of *peeking ahead*. Peek ahead is a common error in trading
    strategy development. While doing backtests, the strategy code must use only past
    and current price data for each emulated trade. For example, if the strategy emulates
    the market on April 1st, it should not refer to price data from April 2nd. The
    same is applied to any time resolution, down to milliseconds. Strategies that
    use future data in the research phase, normally, are unable to work in real life
    (see[*Chapter 5*](B19145_05.xhtml#_idTextAnchor086)*, Retrieving and Handling
    Market Data with Python,* for a detailed discussion on proper data handling when
    performing backtests). It is impossible to overvalue the convenience with which
    Python allows you to avoid critical errors such as this, as these errors may cost
    real and substantial money.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这极大地简化了处理时间序列（或任何数据序列）的工作，因为我们不再需要在主代码中存储索引，更重要的是——我们减少了*提前查看*的风险。提前查看是交易策略开发中常见的错误。在进行回测时，策略代码必须只使用每个模拟交易过去和当前的价格数据。例如，如果策略模拟了4月1日的市场，它就不应参考4月2日的价格数据。同样适用于任何时间分辨率，甚至到毫秒。在研究阶段使用未来数据的策略通常无法在实际生活中工作（参见[*第5章*](B19145_05.xhtml#_idTextAnchor086)*，使用Python检索和处理市场数据,*
    对进行回测时正确处理数据的详细讨论）。Python允许你避免此类关键错误的便利性无法过高估计，因为这些错误可能会造成真实和重大的经济损失。
- en: 'Dictionaries offer another way to store and process series data in Python.
    As each data point, be it a tick or a bar, has a timestamp, we can use timestamps
    as keys in a dictionary:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 字典为在Python中存储和处理序列数据提供了另一种方式。由于每个数据点，无论是tick还是bar，都有一个时间戳，我们可以使用时间戳作为字典中的键：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, retrieving a particular `close` price by its `timestamp` value will be
    simple with the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下代码通过其`timestamp`值检索特定的`close`价格将变得简单：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, even native Python language structures offer a quick, simple, and extremely
    efficient way to handle data specific to trading. However, it is libraries that
    make Python the definite choice for quantitative trading.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使是本地的Python语言结构也提供了快速、简单且极其高效的方式来处理特定的交易数据。然而，是库使得Python成为定量交易的不二选择。
- en: Libraries
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库
- en: The ultimate success of Python as the environment for quantitative finance and
    trading is determined by a number of libraries, which today are de facto industry
    standards and sometimes are so tightly associated with the language itself that
    many developers do not think about them separately. Let us look into some of these
    libraries.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python作为定量金融和交易环境的最终成功取决于许多库，这些库今天实际上是行业标准，有时与语言本身紧密相关，以至于许多开发者甚至没有单独考虑它们。让我们来看看这些库。
- en: NumPy
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy
- en: Originally released in 1995 as Numeric Python, this library is used today in
    virtually any application that uses mathematics. It was the very library that
    transformed Python from just a programming language into a Matlab-like, powerful,
    number-crunching suite.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最初于1995年作为Numeric Python发布，这个库今天几乎用于任何使用数学的应用。它正是将Python从一种编程语言转变为类似Matlab的、强大的、数值处理套件的库。
- en: NumPy offers implementations for a number of core objects from linear algebra
    such as vectors, arrays, and operations with them. It offers comprehensive mathematical
    functions, random number generators, Fourier transforms, and more. Best of all
    – its core is written in C, so all native `numpy` methods work blazingly fast.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy为线性代数中的许多核心对象提供了实现，例如向量、数组和与之相关的操作。它提供了全面的数学函数、随机数生成器、傅里叶变换等。最好的是——它的核心是用C编写的，因此所有本地的`numpy`方法都运行得非常快。
- en: Matplotlib
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Matplotlib
- en: Matplotlib was released in 2003 as the universal plotting library for Python
    and NumPy. It recognizes native NumPy objects and produces print-quality images
    of almost any type of chart used in mathematics.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib于2003年发布，作为Python和NumPy的通用绘图库。它识别本地的NumPy对象，并生成几乎任何类型图表的打印质量图像。
- en: 'What makes Matplotlib especially attractive for trading app development are
    the following features:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下特性使得Matplotlib在交易应用开发中特别吸引人：
- en: It automatically scales data series to fit the chart, so it’s extremely easy
    to visualize any market or trading data with a single command
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会自动将数据系列缩放到适合图表，因此只需一个命令就可以轻松可视化任何市场或交易数据
- en: The charts are embeddable and can be output in consoles such as IPython or Jupyter
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些图表可以嵌入，并且可以输出到IPython或Jupyter等控制台
- en: The charts are interactive, so you can zoom in, zoom out, and drag to explore
    details without needing to write your own image-handling tools
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表是交互式的，因此你可以放大、缩小和拖动来探索细节，而不需要编写自己的图像处理工具。
- en: pandas
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pandas
- en: It is believed that the name **pandas** is derived from **panel data**, a term
    used in econometrics. It can also be understood as **Python Analysis of Data**.
    This is a library that introduces the concept of DataFrames. You can think about
    a DataFrame as a hybrid of a Python dictionary, list, and database. It uses keywords
    to access records but preserves the order of items so data can be retrieved by
    indexing. At the same time, it features routines typical for databases, such as
    making subsets or slices.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 人们认为，**pandas**这个名字来源于计量经济学中使用的术语**面板数据**。它也可以理解为**Python数据分析**。这是一个引入DataFrame概念的库。你可以将DataFrame视为Python字典、列表和数据库的混合体。它使用关键字来访问记录，但保留项目的顺序，以便可以通过索引检索数据。同时，它还具备数据库典型的程序，如制作子集或切片。
- en: On top of DataFrames, pandas offers tools to read and write data between in-memory
    structures and different file formats, including CSV, JSON, SQL queries and tables,
    and MS Excel, which covers virtually all formats used today by data vendors, brokers,
    and exchanges.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在DataFrame的基础上，pandas提供了在内存结构和不同文件格式之间读取和写入数据的功能，包括CSV、JSON、SQL查询和表格，以及MS Excel，几乎涵盖了数据供应商、经纪人和交易所今天使用的所有格式。
- en: If we also take into consideration the fact that pandas offers a variety of
    powerful functions that can rebuild missing data, generate datetime ranges, convert
    sampling frequencies, support sliding window statistics, and many more – you understand
    that you get the ultimate toolbox for developing any kind of trading application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再考虑这样一个事实，即pandas提供了一系列强大的功能，可以重建缺失数据，生成日期时间范围，转换采样频率，支持滑动窗口统计，等等——你就会明白，你得到了开发任何类型交易应用的终极工具箱。
- en: While covering pandas in all its powerful aspects is well beyond the scope of
    this book, we will consider a few useful applications of pandas in [*Chapter 8*](B19145_08.xhtml#_idTextAnchor130),
    *Data Visualization in FX Trading* *with Python*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管全面介绍pandas的所有强大功能超出了本书的范围，但我们将考虑pandas在[*第8章*](B19145_08.xhtml#_idTextAnchor130)中的一些有用应用，即*使用Python进行外汇交易数据可视化*。
- en: NumPy and matplotlib are parts of SciPy – a comprehensive library for any applied
    mathematics, from optimization and linear algebra to signal processing and multidimensional
    image processing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy和matplotlib是SciPy的一部分——一个涵盖任何应用数学的综合性库，从优化和线性代数到信号处理和多维图像处理。
- en: Modeling – forecasting the future doesn’t necessarily mean practical benefits
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模——预测未来并不一定意味着实际的好处。
- en: In order to keep the discussion consistent, we need to draw a thin but solid
    line between trading and modeling. Sometimes, these two terms are seriously confused
    and may lead not only to misunderstanding but also to losing money.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持讨论的一致性，我们需要在交易和建模之间划一条既薄又坚实的界限。有时，这两个术语会被严重混淆，不仅可能导致误解，还可能导致亏损。
- en: 'Modeling is a research activity that aims at building a model that explains
    the observed data. For example, Ptolemy developed a geocentric model of the Solar
    System, whereas Nicolaus Copernicus suggested a model of the Earth spinning around
    its own axis and traveling around the Sun on an elliptical orbit – now known as
    the heliocentric model. Both models explain the observed data: that the Sun visually
    moves around the Earth, that day follows night, and that seasons change in order.
    However, the heliocentric model proved to be far more precise and easy to use,
    so the other one was abandoned.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 建模是一种研究活动，旨在构建一个能够解释观测数据的模型。例如，托勒密提出了一个以地球为中心的太阳系模型，而尼古拉·哥白尼则提出了一个地球围绕其自身轴旋转并在椭圆轨道上绕太阳运行的模式——现在被称为日心模型。这两个模型都解释了观测到的数据：太阳看起来在地球周围移动，白天跟随黑夜，季节按顺序变化。然而，日心模型证明要精确得多，也更容易使用，因此另一个模型被废弃了。
- en: In the financial world, modeling a market means finding a set of quantitative
    rules that explain the observed price behavior. At first glance, it looks like
    modeling any other physical process, for example, the same solar motion. The main
    problem with financial modeling, especially in trading, is that the modeled process
    is non-stationary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在金融世界中，建模市场意味着找到一组能够解释观测价格行为的定量规则。乍一看，它看起来像建模任何其他物理过程，例如，同样的太阳运动。金融建模的主要问题，尤其是在交易中，是建模过程是非平稳的。
- en: In very simple terms, a **non-stationary process** doesn’t have a constant mean
    value or consistent distribution of values across time. This is the very reason
    for the eventual failure of any attempt to use classical statistics, from averages
    to Gaussian distribution, to calculate fair prices or predict anything in the
    future. This is the very reason why many modern approaches that involve elements
    of machine learning, especially based on linear regression, also fail in practical
    trading.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 用非常简单的术语来说，一个**非平稳过程**没有恒定的均值或随时间变化的值的一致分布。这正是任何尝试使用经典统计学（从平均值到高斯分布）来计算公平价格或预测未来的任何尝试最终失败的原因。这也是为什么许多涉及机器学习元素的现代方法，尤其是基于线性回归的方法，在实际交易中也会失败的原因。
- en: 'If you are interested in learning more about non-stationary processes, including
    what they are and what makes successful statistics-based trading so problematic,
    then I’d recommend starting with a basic article from Investopedia: [https://www.investopedia.com/articles/trading/07/stationary.asp](https://www.investopedia.com/articles/trading/07/stationary.asp).
    Or, if you are more advanced in mathematics, there is an excellent book by M.
    B. Priestley, *Non-linear and Non-stationary Time* *Series Analysis*.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于非平稳过程的信息，包括它们是什么以及为什么基于统计学的成功交易如此困难，那么我建议从Investopedia的一个基本文章开始：[https://www.investopedia.com/articles/trading/07/stationary.asp](https://www.investopedia.com/articles/trading/07/stationary.asp)。或者，如果你在数学方面更为精通，M.
    B. Priestley的《非线性与非平稳时间序列分析》是一本优秀的书籍。
- en: Back to the point – modeling non-stationary data is not only problematic but
    also often provides practically useless results. In the case of a stationary process,
    such as the Earth going around the Sun, we can use our model to predict the future
    – and will be correct in the absolute majority of cases. But with a non-stationary
    process, most models will perfectly explain past data, data that had already been
    observed, but will have problems forecasting future observations. So, in my opinion,
    the realm of market modeling is academic research, and using it for practical
    active trading is questionable. I know that there are opposite opinions, but nevertheless,
    in this book, we will focus only on event-driven trading.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 回到正题——对非平稳数据进行建模不仅问题重重，而且往往提供实际上毫无用处的结果。在平稳过程的情况下，例如地球围绕太阳运行，我们可以使用我们的模型来预测未来——在绝大多数情况下都会是正确的。但是，对于非平稳过程，大多数模型将完美地解释过去的数据，即已经观察到的数据，但在预测未来的观察值时将遇到问题。因此，在我看来，市场建模领域属于学术研究，而将其用于实际主动交易是值得怀疑的。我知道存在相反的观点，但无论如何，在这本书中，我们将只关注事件驱动交易。
- en: The difference in approaches is that with market modeling, we try to predict
    future price movements and then follow the forecast to make trading decisions
    while in event-driven trading, we wait for a certain event to happen and then
    react immediately by placing an order. For example, if we run an arbitrage strategy,
    then we wait for the (rare) moment when the asset is mispriced. If we run a directional
    trading strategy, we wait for a moment when certain economic news is released
    or prices start to change rapidly, or vice versa – when the market is slow, but
    anyway – the strategy reacts to what is going on in the market *right now*, without
    *predicting* or *forecasting* anything.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 方法上的差异在于，在市场建模中，我们试图预测未来的价格变动，然后根据预测做出交易决策；而在事件驱动交易中，我们等待某个事件发生，然后立即通过下单来做出反应。例如，如果我们运行套利策略，那么我们会等待资产定价错误的（罕见）时刻。如果我们运行方向性交易策略，我们会等待某些经济新闻发布或价格开始快速变化的时刻，或者相反——当市场缓慢时，但无论如何——策略会对市场当前正在发生的事情做出反应，而不进行任何*预测*或*预测*。
- en: scikit-learn
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: scikit-learn
- en: Nevertheless, some of the inventory traditionally used in market modeling, especially
    machine learning, can be quite useful in event-driven trading strategies as part
    of data pre-processing. Therefore, we should mention at least one more Python
    library that is another de facto industry standard for data science.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，一些在市场建模中传统上使用的库存，尤其是在机器学习中，作为数据处理的一部分，在事件驱动交易策略中可以相当有用。因此，我们应该至少提到一个Python库，它是数据科学事实上的行业标准。
- en: '**scikit-learn** or **sklearn** is a library with implementations of the most
    popular techniques used in data science and machine learning. It includes easy-to-use
    implementations of classification, regression, clustering, and preprocessing along
    with model selection algorithms (cross-validation, grid search, and more). Having
    such a robust library also adds to the choice of Python as the preferred ecosystem
    for the development of trading strategies.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**scikit-learn** 或 **sklearn** 是一个包含数据科学和机器学习中常用技术实现的库。它包括分类、回归、聚类和预处理等易于使用的实现，以及模型选择算法（交叉验证、网格搜索等）。拥有这样一个强大的库也增加了Python作为开发交易策略首选生态系统的选择。'
- en: Now that we have familiarized ourselves with the diversity of powerful features
    offered by Python and numerous libraries, it’s time to dig a bit deeper into the
    process of research and development that is typical for any kind of algo trading
    strategy.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Python和众多库提供的强大功能，是时候深入挖掘任何类型的算法交易策略典型的研发过程了。
- en: Paper trading and backtesting – an essential part of a systemic trader’s risk
    management
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟交易和回测——系统交易者风险管理的重要组成部分
- en: Imagine that we have used all the power of Python and developed a trading application.
    Now what? Is it time to immediately launch it and try earning some money? No!
    Before jumping in the pool, it’s essential to make sure there’s water in it, and
    in our case before putting the app into production, it’s essential that it can
    make money, at least in theory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们已经使用了Python的所有功能并开发了一个交易应用。现在怎么办？是时候立即推出它并尝试赚钱了吗？不！在跳入泳池之前，确保里面有水是至关重要的，在我们的情况下，在将应用投入生产之前，确保它至少在理论上能够赚钱是至关重要的。
- en: In this section, we’ll consider paper trading and backtesting – two cornerstones
    of systematic trading that help us understand potential pitfalls with the newly
    developed strategy. We will learn about historical data, trade simulation, and
    ordering, and we’ll also quickly consider some ready-made packages that simplify
    this part of the development.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨模拟交易和回测——系统交易的两个基石，帮助我们了解新开发策略的潜在陷阱。我们将学习关于历史数据、交易模拟和订单处理，同时也会快速考虑一些现成的包，这些包可以简化这一部分的发展过程。
- en: What are paper trading and backtesting?
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟交易和回测是什么？
- en: 'After we have developed a trading algorithm, connected to the data source,
    and are ready to send orders, it’s time to test our setup. Such a test validates
    the following crucial points:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发了一个交易算法，连接到数据源，并准备好发送订单后，是时候测试我们的设置了。这样的测试验证以下关键点：
- en: The consistency of the trading logic
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易逻辑的一致性
- en: Risk management
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风险管理
- en: Ordering interface and handling errors
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单界面和错误处理
- en: If a test is performed using past market data (mostly referred to as **historical
    data**) with orders sent to a simulation engine, then it is called **backtesting**.
    If the test is performed using live market data with orders sent to the UAT environment
    (provided by the broker, trading venue, or again emulated locally), then it is
    called **paper trading**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用过去的市场数据（通常称为**历史数据**）进行测试，并将订单发送到模拟引擎，那么这被称为**回测**。如果使用实时市场数据进行测试，并将订单发送到UAT环境（由经纪人、交易场所或再次本地模拟提供），那么这被称为**模拟交易**。
- en: The purpose of backtesting is to see how our strategy would have reacted to
    various market situations in the past. This is absolutely essential because all
    systematic trading is built around the idea that if a certain situation happened
    in the past, then most likely it will repeat in the future. For example, if the
    non-farm payroll is way lower than expectations, stock prices go down for some
    time. This is confirmed by many years of historical data. So, we may assume that
    next time it is too low, stock prices will go down again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 回测的目的是查看我们的策略在过去各种市场情况下的反应。这是绝对必要的，因为所有系统交易都是围绕这样一个想法建立的：如果过去发生了某种情况，那么它很可能会在未来重复。例如，如果非农就业人数远低于预期，股票价格会在一段时间内下跌。这一点得到了多年历史数据的证实。因此，我们可能会假设下次它太低时，股票价格会再次下跌。
- en: Paper trading is essential because this is the only test that may prove that
    the strategy is able to practically make money, not only in theory. Remember our
    discussion regarding modeling and forecasting in the previous sections? It is
    possible (and not really difficult) to build a model that perfectly trades in
    the past but is helpless in production. So, any trading app requires a certain
    period of paper trading to check whether it can make money in real life.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 纸化交易是必不可少的，因为这可能是唯一能够证明策略能够在实践中赚钱的测试，而不仅仅是理论上。还记得我们在前几节中关于建模和预测的讨论吗？构建一个在历史中完美交易但无法在生产中使用的模型是可能的（并且并不真的困难）。所以，任何交易应用都需要一定时间的纸化交易来检查它是否能在现实生活中赚钱。
- en: Backtesting and paper trading in Python
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的回测和纸化交易
- en: 'Python itself is very convenient for backtesting and paper trading because
    of its capabilities for interactive computing and ready-made libraries for data
    handling and visualization. We can write an order execution simulator and collect
    cumulative data about returns from our trades in a dataset – this will take some
    time and effort, but is then so easy to analyze: from statistical methods to visual
    representation, which is most widely known as **equity curve**. All this can be
    done interactively by issuing a single command in the console.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Python本身非常适合回测和纸化交易，因为它具有交互式计算的能力以及现成的数据处理和可视化库。我们可以编写一个订单执行模拟器，并在数据集中收集关于我们交易回报的累积数据——这需要一些时间和努力，但分析起来却非常简单：从统计方法到可视化表示，这最广为人知的是**权益曲线**。所有这些都可以通过在控制台中发出单个命令进行交互式完成。
- en: In this book, we will focus on the architecture of trading applications and,
    therefore, mostly consider solutions based on native Python structures as our
    goal is to understand all stages of developing a trading app going down to the
    core logical structures. However, as is the case with data handling, there are
    open source and free libraries and frameworks that facilitate backtesting in Python,
    making it even more attractive for the development of trading strategies. A detailed
    review or tutorial on any of these products is beyond the scope of this book but
    you will be able to easily incorporate any of them into your workflow once you
    understand the research and development process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将重点关注交易应用架构，因此主要考虑基于原生Python结构的解决方案，因为我们的目标是理解开发交易应用的所有阶段，直至核心逻辑结构。然而，正如数据处理的情况一样，存在开源和免费的库和框架，它们简化了Python中的回测，使得开发交易策略更具吸引力。对任何这些产品的详细审查或教程都不在本书的范围之内，但一旦你理解了研究和开发过程，你将能够轻松地将它们中的任何一个整合到你的工作流程中。
- en: PyAlgoTrade
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyAlgoTrade
- en: PyAlgoTrade is a framework with which you can develop full-featured trading
    strategies. It is quite a mature product, as it was one of the first in this class,
    and it is still actively maintained and developed. It follows the modular ideology
    of designing a trading application. So, you can first develop a strategy, backtest
    it, then switch the data source to live data, paper-trade, and finally switch
    the output from emulated order execution to the broker of your choice and trade
    live. It supports free data sources such as Yahoo! Finance and Google Finance,
    but if you want to use PyAlgoTrade for forex trading, you will have to obtain
    data from a third party source, save it in CSV format, and only then use the data
    with this framework.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: PyAlgoTrade是一个框架，你可以用它来开发功能齐全的交易策略。它是一个非常成熟的产品，因为它是这一类中的第一个之一，它仍在积极维护和开发中。它遵循设计交易应用的模块化理念。因此，你可以首先开发一个策略，对其进行回测，然后切换数据源到实时数据，进行纸化交易，最后将输出从模拟订单执行切换到你选择的经纪商，进行实时交易。它支持免费的数据源，如Yahoo!
    Finance和Google Finance，但如果你想要使用PyAlgoTrade进行外汇交易，你必须从第三方来源获取数据，将其保存为CSV格式，然后才能使用这个框架。
- en: It’s important to note that PyAlgoTrade supports real-time Twitter event handling,
    which means that you can use rules based on non-price data for your strategies
    (such as *“when an ECB member says something, sell* *the euro”*).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，PyAlgoTrade支持实时Twitter事件处理，这意味着你可以为你的策略使用基于非价格数据的规则（例如，“当欧洲央行成员说些什么时，卖出*欧元”*）。
- en: 'You will find the project page located here: [github.com/gbeced/pyalgotrade.](https://github.com/gbeced/pyalgotrade'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到项目页面：[github.com/gbeced/pyalgotrade.](https://github.com/gbeced/pyalgotrade)
- en: )
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: bt – backtesting for Python
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bt – Python的回测
- en: bt is another framework for backtesting that is more focused on portfolio trading
    (running many different strategies and trading many different markets in parallel).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: bt 是另一个用于回测的框架，它更专注于投资组合交易（并行运行许多不同的策略和交易许多不同的市场）。
- en: This approach brings bt close to various visual constructors of trading strategies
    that were popular some time ago. Of course, this speeds up the development process
    dramatically as you don’t need to code the algos on a low level; you only select
    the most appropriate from the inventory. However, this advantage is clearly a
    shortcoming as well because you are limited to using what the developers of the
    framework considered suitable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使 bt 接近了曾经流行的各种交易策略可视化构建器。当然，这大大加快了开发过程，因为你不需要在低级别上编写算法；你只需从库存中选择最合适的即可。然而，这种优势显然也是一个缺点，因为你被限制在只能使用框架开发者认为合适的工具。
- en: However, the good news here is that, unlike visual constructors, you can modify
    anything in bt and write your own *building blocks*, which gives you almost the
    same freedom as writing your own strategies from scratch.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，好消息是，与可视化构建器不同，你可以在 bt 中修改任何内容并编写自己的*构建块*，这给你带来了几乎与从头开始编写自己的策略相同的自由度。
- en: bt also offers a comprehensive suite of statistical tools to analyze the strategy
    or portfolio performance and also to quickly try various combinations of trading
    algorithms to discover the one that works best in the particular market.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: bt 还提供了一套全面的统计工具，用于分析策略或投资组合的表现，并快速尝试各种交易算法的组合，以发现最适合特定市场的算法。
- en: This framework is predominantly focused on backtesting and paper trading, so
    you will need to develop your own order generation and submission module if you
    plan to trade live from the same application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架主要关注回测和纸面交易，所以如果你计划从同一应用程序中实时交易，你需要开发自己的订单生成和提交模块。
- en: 'You will find the project page located here: [pmorissette.github.io/bt.](https://pmorissette.github.io/bt'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到项目页面：[pmorissette.github.io/bt.](https://pmorissette.github.io/bt)
- en: )
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Zipline
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Zipline
- en: Zipline is probably the most well-known research and development tool for trading
    strategies. It was developed by Quantopian, the famous project that offered any
    developer an opportunity to become a quantitative trader by providing them with
    an environment for developing trading strategies. It even allocated some capital
    to them in case the strategy performance was proven to be acceptable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Zipline 可能是交易策略最知名的研究和开发工具。它由 Quantopian 开发，这是一个著名的项目，它为任何开发者提供了一个机会，通过提供开发交易策略的环境，使他们有机会成为量化交易员。它甚至为他们分配了一些资金，以防策略表现得到证明是可接受的。
- en: Zipline can be used as a framework and as a standalone application, an algorithmic
    trading constructor and simulator with paper and live trading capabilities. You
    can interact with it using the browser-based iPython Notebook interface.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Zipline 可以用作框架和独立应用程序，是一个具有纸面和实时交易能力的算法交易构建器和模拟器。你可以通过基于浏览器的 iPython Notebook
    界面与之交互。
- en: Zipline comes with 10 years of 1-minute-resolution historical US stock data.
    This is not much, and definitely not relevant to forex trading, but it supports
    importing data in various formats so you can use third-party data, for example,
    from your broker.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Zipline 附带了10年分辨率为1分钟的美国股票历史数据。这并不多，而且绝对与外汇交易无关，但它支持导入各种格式的数据，因此你可以使用第三方数据，例如来自你的经纪商。
- en: As Zipline was designed as part of Quantopian’s ecosystem, its live trading
    capabilities are limited.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Zipline 是作为 Quantopian 生态系统的一部分设计的，其实时交易功能有限。
- en: Despite the initial success of Quantopian and quite some hype in the media,
    in 2020, the company went bankrupt and shut down all operations. Zipline was then
    sold to Robinhood. But the new owners were not interested in the development of
    the product as much as its creators, so the project now exists mainly in form
    of enthusiast-supported forks, the “official” version not being supported any
    longer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Quantopian最初取得了成功，媒体上也有相当多的炒作，但在2020年，该公司破产并关闭了所有业务。Zipline随后被卖给了Robinhood。但新所有者对产品的开发兴趣不如其创造者，因此该项目现在主要以爱好者支持的分支形式存在，“官方”版本不再得到支持。
- en: 'You will find the project page located here: [zipline.io.](https://zipline.io'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到项目页面：[zipline.io.](https://zipline.io)
- en: )
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'You will find the GitHub source here: [github.com/quantopian/zipline.](https://github.com/quantopian/zipline'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下 GitHub 位置找到源代码：[github.com/quantopian/zipline.](https://github.com/quantopian/zipline)
- en: )
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: QSTrader
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QSTrader
- en: QSTrader was developed by QuantStart. It is, again, a framework for research
    and development with live trading capabilities.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: QSTrader是由QuantStart开发的。它再次是一个具有实时交易功能的研发框架。
- en: This framework strictly follows the modular principle of building trading applications
    that we already saw in the previous chapter, which is the main focus throughout
    this book. This helps streamline the general development process – **research**
    | **backtesting** | **paper trading** | **live trading** – because the code responsible
    for the strategy logic remains the same.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架严格遵循我们在上一章中看到的构建交易应用的模块化原则，这也是本书的主要焦点。这有助于简化一般开发过程——**研究** | **回测** | **纸面交易**
    | **实时交易**——因为负责策略逻辑的代码保持不变。
- en: Currently, QSTrader supports bar-based data but tick data can also be used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，QSTrader支持基于bar的数据，但也可以使用tick数据。
- en: 'You will find the project page located here: [https://www.quantstart.com/qstrader/.](https://www.quantstart.com/qstrader/'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下页面找到该项目：[https://www.quantstart.com/qstrader/.](https://www.quantstart.com/qstrader/)
- en: )
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'You will find the Github source here: [github.com/mhallsmoore/qstrader.](https://github.com/mhallsmoore/qstrader'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub源代码中找到该项目：[github.com/mhallsmoore/qstrader.](https://github.com/mhallsmoore/qstrader)
- en: )
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: The disadvantages of using Python in trading strategy development
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在交易策略开发中使用Python的缺点
- en: Having praised the advantages of using Python in algo trading, it’s time to
    mention its important shortcomings. As with many robust and universal ecosystems,
    these shortcomings are the other side of its advantages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在赞扬了Python在算法交易中的优势之后，现在是时候提到它的重要缺点了。正如许多强大而通用的生态系统一样，这些缺点是其优势的另一面。
- en: By any means, the most annoying thing about Python is speed, or, rather, the
    lack of it. Partly this is pre-determined by the fact that Python is an interpreted
    language; however, a much greater contribution to the overall slowness is made
    by weak typing and the same advanced memory management that we love so much when
    we develop code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，Python最令人烦恼的事情是速度，或者更确切地说，是它的缺乏。部分原因是Python是一种解释型语言；然而，对整体缓慢贡献更大的因素是弱类型和我们在开发代码时非常喜爱的相同高级内存管理。
- en: For readers who are not familiar with memory management, I’d recommend starting
    with a simple article at [https://www.geeksforgeeks.org/memory-management-in-python/](https://www.geeksforgeeks.org/memory-management-in-python/),
    which also has references for further reading. In brief, if the language relieves
    the coder of the burden of declaring variables, then every time the variable is
    referenced, a number of routines are executed to make sure the reference is done
    correctly. Of course, this slows down the execution of the entire code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉内存管理的读者，我建议从一篇简单的文章开始，例如[https://www.geeksforgeeks.org/memory-management-in-python/](https://www.geeksforgeeks.org/memory-management-in-python/)，该文章还提供了进一步阅读的参考。简而言之，如果语言减轻了程序员声明变量的负担，那么每次引用变量时，都会执行一系列程序来确保引用是正确的。当然，这会减慢整个代码的执行速度。
- en: The main part of trading strategy development where insufficient speed of code
    execution becomes apparent is backtesting. During a backtest, we should process
    all historical data at a resolution granular enough for the specific strategy,
    and sometimes, this may be as low as raw tick data. As you may remember, the amount
    of such data may reach thousands of ticks per second, so just imagine how many
    times we would repeat the entire strategy logic in a loop processing each tick
    received in the last year!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 交易策略开发的主要部分，在代码执行速度不足的情况下变得明显，就是回测阶段。在回测过程中，我们应该以足够细粒度的分辨率处理所有历史数据，对于特定的策略来说，有时这可能低至原始的tick数据。如您所记得，这类数据的数量可能达到每秒数千tick，所以想象一下我们会在循环中重复多少次整个策略逻辑来处理去年收到的每个tick！
- en: 'But during the research and development phase, this slowness may be just annoying:
    indeed, no one is happy to wait for minutes, sometimes hours, and, in the worst
    cases, days to see the theoretical performance of their strategy. However, waiting
    too long is one thing, and being unable to place trades in production is completely
    different, and live trading is exactly where Python faces its limits.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但在研发阶段，这种缓慢可能只是令人烦恼：确实，没有人愿意等待几分钟、有时是几个小时，甚至在最糟糕的情况下是几天，才能看到他们策略的理论性能。然而，等待时间过长是一回事，而在生产环境中无法进行交易则是完全不同的事情，而实时交易正是Python面临其极限的地方。
- en: Live trading – where Python faces its limits
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时交易——Python面临的极限
- en: Thus said, trading applications written in pure Python are not suitable for
    any live trading activity that assumes the minimization of time from the moment
    market data is received to the moment an order is sent. Therefore, traditional
    arbitrage and many high-frequency trading activities (which sometimes suggest
    sending thousands of orders *per second*) are definitely not for Python.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，纯Python编写的交易应用不适合任何假设从收到市场数据到发送订单的时间最小化的实时交易活动。因此，传统的套利和许多高频交易活动（有时建议每秒发送数千个订单）肯定不适合Python。
- en: Besides that, there is another risk even for *slow* trading strategies that
    derive from automated memory management. We already know that trading strategies
    rely on price time series and the amount of processed market data may be quite
    large. Although both native Python and third-party libraries such as pandas offer
    data structures that ensure data persistence, it may become problematic to update
    data on the fly, especially in trading environments with high throughputs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使是来自自动化内存管理的*慢速*交易策略也存在另一种风险。我们已经知道，交易策略依赖于价格时间序列，处理的市场数据量可能相当大。尽管原生Python和第三方库如pandas提供了确保数据持久性的数据结构，但在高吞吐量的交易环境中，实时更新数据可能会变得有问题。
- en: There are different ways to speed up Python to some extent. There are static
    compilers such as Cython ([https://cython.org](https://cython.org)), which help
    execute the Python code faster and write C extensions for Python as well. There
    are runtime translators such as Numba ([https://numba.pydata.org](https://numba.pydata.org)),
    which also help execute Python code at speeds comparable to C. It also helps to
    use `numpy` structures instead of pandas because, at the cost of reduced convenience
    in some aspects, we have a gain in speed. However, in this book, we won’t really
    focus on this problem because we start with less latency-critical, more simplistic
    strategies that help us to understand the development of trading apps in general.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以在一定程度上加速Python。例如，有静态编译器如Cython ([https://cython.org](https://cython.org))，它可以帮助更快地执行Python代码，并为Python编写C扩展。还有运行时翻译器如Numba
    ([https://numba.pydata.org](https://numba.pydata.org))，它也能以与C相当的速度执行Python代码。此外，使用`numpy`结构代替pandas也有帮助，因为尽管在某些方面会降低便利性，但我们可以获得速度上的提升。然而，在这本书中，我们不会真正关注这个问题，因为我们从更少延迟关键、更简单的策略开始，这些策略有助于我们理解交易应用的一般开发。
- en: 'To summarize, we can say that the Python ecosystem is an excellent tool for
    the research and development of trading strategies of any kind. It can also be
    used for live automated trading if the trading strategy meets the following two
    criteria:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以这样说，Python生态系统是研究和开发任何类型交易策略的绝佳工具。如果交易策略满足以下两个标准，它也可以用于实时自动化交易：
- en: It doesn’t require large amounts of market data to be received in real time
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不需要接收大量实时市场数据
- en: It is not sensitive to internal latency (a delay between data reception and
    order submission)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对内部延迟（数据接收和订单提交之间的延迟）不敏感
- en: In this book, we will mostly focus on using Python for research, development,
    and simulated trading.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将主要关注使用Python进行研究和开发，以及模拟交易。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we considered the pros and cons of using Python for algorithmic
    trading strategy research and development. We considered various options for using
    native Python data structures to handle market data. We learned about the various
    ecosystems, third-party libraries, and environments that speed up the development
    process. We also learned about the most important phases of development and the
    essential procedures that aim to make sure that the strategy has the potential
    to make money in live markets.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑了使用Python进行算法交易策略研究和开发的优缺点。我们考虑了使用原生Python数据结构处理市场数据的各种选项。我们了解了各种生态系统、第三方库和环境，它们可以加快开发过程。我们还了解了开发过程中最重要的阶段和旨在确保策略在实时市场中具有盈利潜力的基本程序。
- en: However, as with any project in any domain, before we can proceed to actual
    coding, we should get acquainted with the subject. In our case, it is the market
    itself, its basic elements, structure, and the organization that we will consider
    in order to see how it operates and what we should take into account to build
    robust trading applications. This is what we are going to do in the very next
    chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与任何领域的任何项目一样，在我们开始实际编码之前，我们应该熟悉主题。在我们的情况下，那就是市场本身，它的基本要素、结构以及组织，这些都是我们将考虑的因素，以便了解它是如何运作的，以及我们在构建稳健的交易应用时应该考虑什么。这正是我们将在下一章中要做的。
