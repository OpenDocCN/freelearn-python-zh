- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Python for Trading Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has gained a reputation as the language of choice for the development
    of a wide range of applications in the financial industry and has become a de
    facto industry standard for the research phase of trading strategy development.
    However, as with any other language or, better put, programming ecosystem, it
    has its advantages and disadvantages. So, as with any tool, it is essential to
    understand its strong and weak points to use the tool properly (not trying to
    hammer nails with a microscope, so to say).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, not only will we consider using Python for algorithmic trading
    strategy development but we will also learn about the essential steps in the research
    and development process, discuss the difference between market modeling and event-based
    trading, and point to the mistakes most typically made in the research and development
    process. Finally, we will see the limitations of using Python for algo trading
    so our expectations always meet reality.
  prefs: []
  type: TYPE_NORMAL
- en: We will quickly dive a bit deeper than just a surface overview to see how the
    strongest advantages of Python, such as native language structures and efficient
    **object-oriented programming** (**OOP**), help make the code transparent and
    keep the architecture of a trading app modular, flexible, and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with the key concepts of trading
    and algo trading, applications of Python, and various **integrated development
    environments** (**IDEs**) for the research and development of trading strategies,
    and you will know the limits beyond which using Python is not efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using Python in trading strategy development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling – forecasting the future doesn’t necessarily mean practical benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paper trading and backtesting – an essential part of a systemic trader’s risk
    management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantages of using Python in trading strategy development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live trading – where Python faces its limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need Python 3.10 or higher to run the code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using Python in trading strategy development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today when we say *Python*, we most likely mean not only the most flexible object-oriented
    programming language but also the most powerful and convenient interactive IDEs,
    such as Spyder or PyCharm, along with the vast collection of libraries that extend
    this language to fit virtually any domain of applied and fundamental research,
    from medicine to astronomy. There is no surprise that the Python ecosystem has
    become the de facto standard in the financial industry where numbers play a decisive
    role.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using Python for the development of trading strategies are
    obvious and we will look into a few of these advantages in detail in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is one of the few interpreters that has robust built-in memory management
    services such as garbage collection and reference counting. Essentially, this
    means that you don’t have to care about any complex object you work with and the
    amount of data processed by your code. Of course, this dramatically increases
    the development speed, especially if you work with large datasets – and trading
    applications work with large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is an interpreted language and this means two important things.
  prefs: []
  type: TYPE_NORMAL
- en: First, you can stop executing the code at any moment and check the environment
    at runtime, including all variables, functions, and objects – which is convenient
    for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you can work with Python interactively. This means that in all Unix-like
    systems, we run Python in a console where we can send commands one by one and
    immediately get responses from the interpreter. If you develop trading applications,
    this allows you to quickly test some modules on small datasets before integrating
    them into the final code. It also allows you to quickly visualize any portion
    of a data set on the fly without rewriting and rerunning any code, which is invaluable
    for developing any applications that work with time series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working in a native console is not as convenient as in IPython – a command
    shell that supports introspection, rich media, syntax highlighting, tab completion,
    and history. Released in 2001 as an open source project, IPython quickly transformed
    Python into a direct competitor to Matlab, and thanks to the open source status
    and enormous community of contributors we can say that today, Python has won the
    competition. In 2014, a spin-off project based on IPython started with the idea
    of developing a universal interactive computing environment suitable not only
    for Python but also for other languages. This project was called Jupyter and today
    this is probably the most popular notebook-style interactive computing environment.
    Sometimes Jupyter is even considered a replacement for IPython; however, this
    is not really correct. DataCamp published an excellent article that explains the
    difference: [https://www.datacamp.com/blog/ipython-or-jupyter.](https://www.datacamp.com/blog/ipython-or-jupyter'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: Ease of integration and routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the previous two advantages are not specific to the development of trading
    applications, then what makes Python the preferred language for both trading research
    and development is the ease with which you can switch between *research mode*
    and *production mode*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have carefully planned your data structures and codes (and this is what
    we will be learning to do throughout this book), then all essential modules of
    the trading app (which we drafted in the previous chapter) will be independent
    and replaceable. What advantage does this give you as a developer? The advantages
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to develop the trading logic using historical data and then replace
    the data source with a live stream from the broker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to fine-tune and debug your application by simulating order execution
    and letting you switch to production using the same code you used for development.
    This reduces the risk of errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to scale your trading business by adding more execution venues,
    protocols, APIs, and trading accounts, keeping the rest of the code the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides that, thanks to the interactivity of the Python environment, you can
    even intervene in the trading process manually. For example, you can send a `FIX`
    message to close all open positions in case of an emergency. Of course, this is
    *not* the best practice, or even something that can be recommended, but knowing
    that even in the worst unexpected scenario you can take urgent action straight
    from the familiar development environment adds to peace of mind.
  prefs: []
  type: TYPE_NORMAL
- en: Native language structures – lists and dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the key advantages of using Python for data processing is that it natively
    implements two powerful structures: lists and dictionaries.'
  prefs: []
  type: TYPE_NORMAL
- en: Trading applications work with time series, and having convenient tools to read,
    access, compress, and process this data is crucial. Using lists and dictionaries
    along with objects becomes quite efficient. Let’s consider an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have tick data and want to transform it into OHLC data points (see
    the previous chapter for an explanation of OHLC). We can define such a data point,
    which in trading is normally called a *bar*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create storage for our bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can define a native Python list where we store OHLC bars and the `self.last`
    pointer, which points to the last element that was read from the list. Then, we
    will add the `read` method, which returns the element to which the `self.last`
    pointer points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, instead of retrieving OHLC bars by index in the production code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will retrieve closing prices without direct reference to the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This streamlines working with time series (or any data series) dramatically
    as we no longer need to store indices in the main code and even more importantly
    – we reduce the risk of *peeking ahead*. Peek ahead is a common error in trading
    strategy development. While doing backtests, the strategy code must use only past
    and current price data for each emulated trade. For example, if the strategy emulates
    the market on April 1st, it should not refer to price data from April 2nd. The
    same is applied to any time resolution, down to milliseconds. Strategies that
    use future data in the research phase, normally, are unable to work in real life
    (see[*Chapter 5*](B19145_05.xhtml#_idTextAnchor086)*, Retrieving and Handling
    Market Data with Python,* for a detailed discussion on proper data handling when
    performing backtests). It is impossible to overvalue the convenience with which
    Python allows you to avoid critical errors such as this, as these errors may cost
    real and substantial money.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries offer another way to store and process series data in Python.
    As each data point, be it a tick or a bar, has a timestamp, we can use timestamps
    as keys in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, retrieving a particular `close` price by its `timestamp` value will be
    simple with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, even native Python language structures offer a quick, simple, and extremely
    efficient way to handle data specific to trading. However, it is libraries that
    make Python the definite choice for quantitative trading.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ultimate success of Python as the environment for quantitative finance and
    trading is determined by a number of libraries, which today are de facto industry
    standards and sometimes are so tightly associated with the language itself that
    many developers do not think about them separately. Let us look into some of these
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Originally released in 1995 as Numeric Python, this library is used today in
    virtually any application that uses mathematics. It was the very library that
    transformed Python from just a programming language into a Matlab-like, powerful,
    number-crunching suite.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy offers implementations for a number of core objects from linear algebra
    such as vectors, arrays, and operations with them. It offers comprehensive mathematical
    functions, random number generators, Fourier transforms, and more. Best of all
    – its core is written in C, so all native `numpy` methods work blazingly fast.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Matplotlib was released in 2003 as the universal plotting library for Python
    and NumPy. It recognizes native NumPy objects and produces print-quality images
    of almost any type of chart used in mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: 'What makes Matplotlib especially attractive for trading app development are
    the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It automatically scales data series to fit the chart, so it’s extremely easy
    to visualize any market or trading data with a single command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The charts are embeddable and can be output in consoles such as IPython or Jupyter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The charts are interactive, so you can zoom in, zoom out, and drag to explore
    details without needing to write your own image-handling tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is believed that the name **pandas** is derived from **panel data**, a term
    used in econometrics. It can also be understood as **Python Analysis of Data**.
    This is a library that introduces the concept of DataFrames. You can think about
    a DataFrame as a hybrid of a Python dictionary, list, and database. It uses keywords
    to access records but preserves the order of items so data can be retrieved by
    indexing. At the same time, it features routines typical for databases, such as
    making subsets or slices.
  prefs: []
  type: TYPE_NORMAL
- en: On top of DataFrames, pandas offers tools to read and write data between in-memory
    structures and different file formats, including CSV, JSON, SQL queries and tables,
    and MS Excel, which covers virtually all formats used today by data vendors, brokers,
    and exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: If we also take into consideration the fact that pandas offers a variety of
    powerful functions that can rebuild missing data, generate datetime ranges, convert
    sampling frequencies, support sliding window statistics, and many more – you understand
    that you get the ultimate toolbox for developing any kind of trading application.
  prefs: []
  type: TYPE_NORMAL
- en: While covering pandas in all its powerful aspects is well beyond the scope of
    this book, we will consider a few useful applications of pandas in [*Chapter 8*](B19145_08.xhtml#_idTextAnchor130),
    *Data Visualization in FX Trading* *with Python*.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy and matplotlib are parts of SciPy – a comprehensive library for any applied
    mathematics, from optimization and linear algebra to signal processing and multidimensional
    image processing.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling – forecasting the future doesn’t necessarily mean practical benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to keep the discussion consistent, we need to draw a thin but solid
    line between trading and modeling. Sometimes, these two terms are seriously confused
    and may lead not only to misunderstanding but also to losing money.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modeling is a research activity that aims at building a model that explains
    the observed data. For example, Ptolemy developed a geocentric model of the Solar
    System, whereas Nicolaus Copernicus suggested a model of the Earth spinning around
    its own axis and traveling around the Sun on an elliptical orbit – now known as
    the heliocentric model. Both models explain the observed data: that the Sun visually
    moves around the Earth, that day follows night, and that seasons change in order.
    However, the heliocentric model proved to be far more precise and easy to use,
    so the other one was abandoned.'
  prefs: []
  type: TYPE_NORMAL
- en: In the financial world, modeling a market means finding a set of quantitative
    rules that explain the observed price behavior. At first glance, it looks like
    modeling any other physical process, for example, the same solar motion. The main
    problem with financial modeling, especially in trading, is that the modeled process
    is non-stationary.
  prefs: []
  type: TYPE_NORMAL
- en: In very simple terms, a **non-stationary process** doesn’t have a constant mean
    value or consistent distribution of values across time. This is the very reason
    for the eventual failure of any attempt to use classical statistics, from averages
    to Gaussian distribution, to calculate fair prices or predict anything in the
    future. This is the very reason why many modern approaches that involve elements
    of machine learning, especially based on linear regression, also fail in practical
    trading.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in learning more about non-stationary processes, including
    what they are and what makes successful statistics-based trading so problematic,
    then I’d recommend starting with a basic article from Investopedia: [https://www.investopedia.com/articles/trading/07/stationary.asp](https://www.investopedia.com/articles/trading/07/stationary.asp).
    Or, if you are more advanced in mathematics, there is an excellent book by M.
    B. Priestley, *Non-linear and Non-stationary Time* *Series Analysis*.'
  prefs: []
  type: TYPE_NORMAL
- en: Back to the point – modeling non-stationary data is not only problematic but
    also often provides practically useless results. In the case of a stationary process,
    such as the Earth going around the Sun, we can use our model to predict the future
    – and will be correct in the absolute majority of cases. But with a non-stationary
    process, most models will perfectly explain past data, data that had already been
    observed, but will have problems forecasting future observations. So, in my opinion,
    the realm of market modeling is academic research, and using it for practical
    active trading is questionable. I know that there are opposite opinions, but nevertheless,
    in this book, we will focus only on event-driven trading.
  prefs: []
  type: TYPE_NORMAL
- en: The difference in approaches is that with market modeling, we try to predict
    future price movements and then follow the forecast to make trading decisions
    while in event-driven trading, we wait for a certain event to happen and then
    react immediately by placing an order. For example, if we run an arbitrage strategy,
    then we wait for the (rare) moment when the asset is mispriced. If we run a directional
    trading strategy, we wait for a moment when certain economic news is released
    or prices start to change rapidly, or vice versa – when the market is slow, but
    anyway – the strategy reacts to what is going on in the market *right now*, without
    *predicting* or *forecasting* anything.
  prefs: []
  type: TYPE_NORMAL
- en: scikit-learn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nevertheless, some of the inventory traditionally used in market modeling, especially
    machine learning, can be quite useful in event-driven trading strategies as part
    of data pre-processing. Therefore, we should mention at least one more Python
    library that is another de facto industry standard for data science.
  prefs: []
  type: TYPE_NORMAL
- en: '**scikit-learn** or **sklearn** is a library with implementations of the most
    popular techniques used in data science and machine learning. It includes easy-to-use
    implementations of classification, regression, clustering, and preprocessing along
    with model selection algorithms (cross-validation, grid search, and more). Having
    such a robust library also adds to the choice of Python as the preferred ecosystem
    for the development of trading strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have familiarized ourselves with the diversity of powerful features
    offered by Python and numerous libraries, it’s time to dig a bit deeper into the
    process of research and development that is typical for any kind of algo trading
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Paper trading and backtesting – an essential part of a systemic trader’s risk
    management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have used all the power of Python and developed a trading application.
    Now what? Is it time to immediately launch it and try earning some money? No!
    Before jumping in the pool, it’s essential to make sure there’s water in it, and
    in our case before putting the app into production, it’s essential that it can
    make money, at least in theory.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll consider paper trading and backtesting – two cornerstones
    of systematic trading that help us understand potential pitfalls with the newly
    developed strategy. We will learn about historical data, trade simulation, and
    ordering, and we’ll also quickly consider some ready-made packages that simplify
    this part of the development.
  prefs: []
  type: TYPE_NORMAL
- en: What are paper trading and backtesting?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After we have developed a trading algorithm, connected to the data source,
    and are ready to send orders, it’s time to test our setup. Such a test validates
    the following crucial points:'
  prefs: []
  type: TYPE_NORMAL
- en: The consistency of the trading logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risk management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering interface and handling errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a test is performed using past market data (mostly referred to as **historical
    data**) with orders sent to a simulation engine, then it is called **backtesting**.
    If the test is performed using live market data with orders sent to the UAT environment
    (provided by the broker, trading venue, or again emulated locally), then it is
    called **paper trading**.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of backtesting is to see how our strategy would have reacted to
    various market situations in the past. This is absolutely essential because all
    systematic trading is built around the idea that if a certain situation happened
    in the past, then most likely it will repeat in the future. For example, if the
    non-farm payroll is way lower than expectations, stock prices go down for some
    time. This is confirmed by many years of historical data. So, we may assume that
    next time it is too low, stock prices will go down again.
  prefs: []
  type: TYPE_NORMAL
- en: Paper trading is essential because this is the only test that may prove that
    the strategy is able to practically make money, not only in theory. Remember our
    discussion regarding modeling and forecasting in the previous sections? It is
    possible (and not really difficult) to build a model that perfectly trades in
    the past but is helpless in production. So, any trading app requires a certain
    period of paper trading to check whether it can make money in real life.
  prefs: []
  type: TYPE_NORMAL
- en: Backtesting and paper trading in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python itself is very convenient for backtesting and paper trading because
    of its capabilities for interactive computing and ready-made libraries for data
    handling and visualization. We can write an order execution simulator and collect
    cumulative data about returns from our trades in a dataset – this will take some
    time and effort, but is then so easy to analyze: from statistical methods to visual
    representation, which is most widely known as **equity curve**. All this can be
    done interactively by issuing a single command in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will focus on the architecture of trading applications and,
    therefore, mostly consider solutions based on native Python structures as our
    goal is to understand all stages of developing a trading app going down to the
    core logical structures. However, as is the case with data handling, there are
    open source and free libraries and frameworks that facilitate backtesting in Python,
    making it even more attractive for the development of trading strategies. A detailed
    review or tutorial on any of these products is beyond the scope of this book but
    you will be able to easily incorporate any of them into your workflow once you
    understand the research and development process.
  prefs: []
  type: TYPE_NORMAL
- en: PyAlgoTrade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PyAlgoTrade is a framework with which you can develop full-featured trading
    strategies. It is quite a mature product, as it was one of the first in this class,
    and it is still actively maintained and developed. It follows the modular ideology
    of designing a trading application. So, you can first develop a strategy, backtest
    it, then switch the data source to live data, paper-trade, and finally switch
    the output from emulated order execution to the broker of your choice and trade
    live. It supports free data sources such as Yahoo! Finance and Google Finance,
    but if you want to use PyAlgoTrade for forex trading, you will have to obtain
    data from a third party source, save it in CSV format, and only then use the data
    with this framework.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that PyAlgoTrade supports real-time Twitter event handling,
    which means that you can use rules based on non-price data for your strategies
    (such as *“when an ECB member says something, sell* *the euro”*).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the project page located here: [github.com/gbeced/pyalgotrade.](https://github.com/gbeced/pyalgotrade'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: bt – backtesting for Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: bt is another framework for backtesting that is more focused on portfolio trading
    (running many different strategies and trading many different markets in parallel).
  prefs: []
  type: TYPE_NORMAL
- en: This approach brings bt close to various visual constructors of trading strategies
    that were popular some time ago. Of course, this speeds up the development process
    dramatically as you don’t need to code the algos on a low level; you only select
    the most appropriate from the inventory. However, this advantage is clearly a
    shortcoming as well because you are limited to using what the developers of the
    framework considered suitable.
  prefs: []
  type: TYPE_NORMAL
- en: However, the good news here is that, unlike visual constructors, you can modify
    anything in bt and write your own *building blocks*, which gives you almost the
    same freedom as writing your own strategies from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: bt also offers a comprehensive suite of statistical tools to analyze the strategy
    or portfolio performance and also to quickly try various combinations of trading
    algorithms to discover the one that works best in the particular market.
  prefs: []
  type: TYPE_NORMAL
- en: This framework is predominantly focused on backtesting and paper trading, so
    you will need to develop your own order generation and submission module if you
    plan to trade live from the same application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the project page located here: [pmorissette.github.io/bt.](https://pmorissette.github.io/bt'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: Zipline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Zipline is probably the most well-known research and development tool for trading
    strategies. It was developed by Quantopian, the famous project that offered any
    developer an opportunity to become a quantitative trader by providing them with
    an environment for developing trading strategies. It even allocated some capital
    to them in case the strategy performance was proven to be acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Zipline can be used as a framework and as a standalone application, an algorithmic
    trading constructor and simulator with paper and live trading capabilities. You
    can interact with it using the browser-based iPython Notebook interface.
  prefs: []
  type: TYPE_NORMAL
- en: Zipline comes with 10 years of 1-minute-resolution historical US stock data.
    This is not much, and definitely not relevant to forex trading, but it supports
    importing data in various formats so you can use third-party data, for example,
    from your broker.
  prefs: []
  type: TYPE_NORMAL
- en: As Zipline was designed as part of Quantopian’s ecosystem, its live trading
    capabilities are limited.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the initial success of Quantopian and quite some hype in the media,
    in 2020, the company went bankrupt and shut down all operations. Zipline was then
    sold to Robinhood. But the new owners were not interested in the development of
    the product as much as its creators, so the project now exists mainly in form
    of enthusiast-supported forks, the “official” version not being supported any
    longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the project page located here: [zipline.io.](https://zipline.io'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the GitHub source here: [github.com/quantopian/zipline.](https://github.com/quantopian/zipline'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: QSTrader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: QSTrader was developed by QuantStart. It is, again, a framework for research
    and development with live trading capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: This framework strictly follows the modular principle of building trading applications
    that we already saw in the previous chapter, which is the main focus throughout
    this book. This helps streamline the general development process – **research**
    | **backtesting** | **paper trading** | **live trading** – because the code responsible
    for the strategy logic remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, QSTrader supports bar-based data but tick data can also be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the project page located here: [https://www.quantstart.com/qstrader/.](https://www.quantstart.com/qstrader/'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the Github source here: [github.com/mhallsmoore/qstrader.](https://github.com/mhallsmoore/qstrader'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantages of using Python in trading strategy development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having praised the advantages of using Python in algo trading, it’s time to
    mention its important shortcomings. As with many robust and universal ecosystems,
    these shortcomings are the other side of its advantages.
  prefs: []
  type: TYPE_NORMAL
- en: By any means, the most annoying thing about Python is speed, or, rather, the
    lack of it. Partly this is pre-determined by the fact that Python is an interpreted
    language; however, a much greater contribution to the overall slowness is made
    by weak typing and the same advanced memory management that we love so much when
    we develop code.
  prefs: []
  type: TYPE_NORMAL
- en: For readers who are not familiar with memory management, I’d recommend starting
    with a simple article at [https://www.geeksforgeeks.org/memory-management-in-python/](https://www.geeksforgeeks.org/memory-management-in-python/),
    which also has references for further reading. In brief, if the language relieves
    the coder of the burden of declaring variables, then every time the variable is
    referenced, a number of routines are executed to make sure the reference is done
    correctly. Of course, this slows down the execution of the entire code.
  prefs: []
  type: TYPE_NORMAL
- en: The main part of trading strategy development where insufficient speed of code
    execution becomes apparent is backtesting. During a backtest, we should process
    all historical data at a resolution granular enough for the specific strategy,
    and sometimes, this may be as low as raw tick data. As you may remember, the amount
    of such data may reach thousands of ticks per second, so just imagine how many
    times we would repeat the entire strategy logic in a loop processing each tick
    received in the last year!
  prefs: []
  type: TYPE_NORMAL
- en: 'But during the research and development phase, this slowness may be just annoying:
    indeed, no one is happy to wait for minutes, sometimes hours, and, in the worst
    cases, days to see the theoretical performance of their strategy. However, waiting
    too long is one thing, and being unable to place trades in production is completely
    different, and live trading is exactly where Python faces its limits.'
  prefs: []
  type: TYPE_NORMAL
- en: Live trading – where Python faces its limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus said, trading applications written in pure Python are not suitable for
    any live trading activity that assumes the minimization of time from the moment
    market data is received to the moment an order is sent. Therefore, traditional
    arbitrage and many high-frequency trading activities (which sometimes suggest
    sending thousands of orders *per second*) are definitely not for Python.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, there is another risk even for *slow* trading strategies that
    derive from automated memory management. We already know that trading strategies
    rely on price time series and the amount of processed market data may be quite
    large. Although both native Python and third-party libraries such as pandas offer
    data structures that ensure data persistence, it may become problematic to update
    data on the fly, especially in trading environments with high throughputs.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways to speed up Python to some extent. There are static
    compilers such as Cython ([https://cython.org](https://cython.org)), which help
    execute the Python code faster and write C extensions for Python as well. There
    are runtime translators such as Numba ([https://numba.pydata.org](https://numba.pydata.org)),
    which also help execute Python code at speeds comparable to C. It also helps to
    use `numpy` structures instead of pandas because, at the cost of reduced convenience
    in some aspects, we have a gain in speed. However, in this book, we won’t really
    focus on this problem because we start with less latency-critical, more simplistic
    strategies that help us to understand the development of trading apps in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we can say that the Python ecosystem is an excellent tool for
    the research and development of trading strategies of any kind. It can also be
    used for live automated trading if the trading strategy meets the following two
    criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t require large amounts of market data to be received in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not sensitive to internal latency (a delay between data reception and
    order submission)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will mostly focus on using Python for research, development,
    and simulated trading.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we considered the pros and cons of using Python for algorithmic
    trading strategy research and development. We considered various options for using
    native Python data structures to handle market data. We learned about the various
    ecosystems, third-party libraries, and environments that speed up the development
    process. We also learned about the most important phases of development and the
    essential procedures that aim to make sure that the strategy has the potential
    to make money in live markets.
  prefs: []
  type: TYPE_NORMAL
- en: However, as with any project in any domain, before we can proceed to actual
    coding, we should get acquainted with the subject. In our case, it is the market
    itself, its basic elements, structure, and the organization that we will consider
    in order to see how it operates and what we should take into account to build
    robust trading applications. This is what we are going to do in the very next
    chapter.
  prefs: []
  type: TYPE_NORMAL
