- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Built-In Data Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置数据类型
- en: ”Data! Data! Data!” he cried impatiently. “I can’t make bricks without clay.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “数据！数据！数据！”他焦急地喊道。“没有粘土，我无法制作砖块。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Sherlock Holmes, in The Adventure of the Copper Beeches
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——夏洛克·福尔摩斯，《铜 Beeches》冒险
- en: Everything you do with a computer is managing data. Data comes in many different
    shapes and flavors. It is the music you listen to, the movies you stream, the
    PDFs you open. Even the source of the chapter you’re reading at this very moment
    is just a file, which is data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你用计算机做的每一件事都是管理数据。数据有多种不同的形状和风味。它是你听的音乐，你流媒体播放的电影，你打开的 PDF 文件。甚至你此刻正在阅读的章节的来源也只是一个文件，它是数据。
- en: Data can be simple, whether it is an integer number to represent an age, or
    a complex structure, like an order placed on a website. It can be about a single
    object or about a collection of them. Data can even be about data—that is, **metadata**
    . This is data that describes the design of other data structures, or data that
    describes application data or its context. In Python, *objects are an abstraction
    for data* , and Python has an amazing variety of data structures that you can
    use to represent data or combine them to create your own custom data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是简单的，无论是代表年龄的整数，还是像网站上的订单这样的复杂结构。它可以关于单个对象，也可以关于它们的集合。数据甚至可以关于数据——即 **元数据**。这是描述其他数据结构设计的数据，或描述应用程序数据或其上下文的数据。在
    Python 中，*对象是数据的抽象*，Python 有许多惊人的数据结构，你可以使用它们来表示数据或将它们组合起来创建自己的自定义数据。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Python objects’ structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 对象的结构
- en: Mutability and immutability
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性和不可变性
- en: 'Built-in data types: numbers, strings, dates and times, sequences, collections,
    and mapping types'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据类型：数字、字符串、日期和时间、序列、集合和映射类型
- en: The `collections` module, briefly
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections` 模块，简要介绍'
- en: Enumerations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Everything is an object
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 万物皆对象
- en: Before we delve into the specifics, we want you to be very clear about objects
    in Python, so let us talk a little bit more about them. *Everything in Python
    is an object* , and every object has an `identity` ( `ID` ), a `type` , and a
    `value` . But what really happens when you type an instruction like `age = 42`
    in a Python module?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入具体细节之前，我们希望你对 Python 中的对象有非常清晰的认识，所以让我们再谈谈它们。*Python 中的万物都是对象*，每个对象都有一个
    `identity`（`ID`）、一个 `type` 和一个 `value`。但当你在一个 Python 模块中输入像 `age = 42` 这样的指令时，实际上会发生什么呢？
- en: If you go to [https://pythontutor.com/](https://pythontutor.com/) , you can
    type that instruction into a text box and get its visual representation. Keep
    this website in mind; it is very useful to consolidate your understanding of what
    goes on behind the scenes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 [https://pythontutor.com/](https://pythontutor.com/)，你可以在文本框中输入那个指令并获取其可视化表示。记住这个网站；它对于巩固你对幕后发生的事情的理解非常有用。
- en: 'So, what happens is that an **object** is created. It gets an `id` , the `type`
    is set to `int` (integer number), and the `value` to `42` . A name, `age` , is
    placed in the global namespace, pointing to that object. Therefore, whenever we
    are in the global namespace, after the execution of that line, we can retrieve
    that object by simply accessing it through its name: `age` .'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，发生的事情是创建了一个 **对象**。它获得了一个 `id`，`type` 被设置为 `int`（整数），`value` 被设置为 `42`。一个名称
    `age` 被放置在全局命名空间中，指向那个对象。因此，每次我们在全局命名空间中，在执行该行之后，我们都可以通过简单地通过其名称访问它来检索该对象：`age`。
- en: 'If you were to move house, you would put all the knives, forks, and spoons
    in a box and label it *cutlery* . This is exactly the same concept. Here is a
    screenshot of what it may look like (you may have to tweak the settings to get
    the same view):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你搬家，你会把所有的刀叉和勺子放进一个盒子里，并在上面贴上 *cutlery* 标签。这正是同样的概念。下面是一个截图，展示了它可能的样子（你可能需要调整设置才能获得相同的视图）：
- en: '![img](img/B30996_02_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B30996_02_01.png)'
- en: Figure 2.1 – A name pointing to an object
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 一个指向对象的名称
- en: So, for the rest of this chapter, whenever you read something such as `name
    = some_value` , think of a name placed in the namespace that is tied to the scope
    in which the instruction was written, with a nice arrow pointing to an object
    that has an *id* , a *type* , and a *value* . There is a little bit more to say
    about this mechanism, but it is much easier to talk about it using an example,
    so we will come back to this later.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章的剩余部分，每当你读到像 `name = some_value` 这样的内容时，请想象一个放置在命名空间中的名称，它与编写指令的作用域相关联，并通过一个指向具有
    *id* 、*type* 和 *value* 的对象的优美箭头。关于这个机制还有更多要说的，但用例子来说明它要容易得多，所以我们稍后再来讨论这个问题。
- en: Mutability
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性
- en: The first fundamental distinction that Python makes about data is whether the
    value of an object can change. If the value can change, the object is called **mutable**
    , otherwise the object is called **immutable** .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python对数据的第一项基本区分是对象的值是否可以改变。如果值可以改变，则该对象称为**可变**，否则该对象称为**不可变**。
- en: 'It is important that you understand the distinction between mutable and immutable
    because it affects the code you write. Let us look at the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 理解可变和不可变之间的区别非常重要，因为它会影响你编写的代码。让我们看看以下例子：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, on line `#A` , have we changed the value of `age` ?
    Well, no. But now it is `43` (we hear you say...). Yes, it is `43` , but `42`
    was an integer number, of the type *int* , which is immutable. So, what happened
    is really that on the first line, `age` is a name that is set to point to an *int*
    object, whose value is `42` . When we type `age = 43` , what happens is that another
    *int* object is created, with the value `43` (also, the *id* will be different),
    and the name `age` is set to point to it. So, in fact, we did not change `42`
    to `43` —we just pointed the name `age` to a different location, which is the
    new *int* object whose value is `43` . Let us see the IDs of the objects:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在行`#A`上，我们是否改变了`age`的值？好吧，没有。但现在它是`43`（我们听到你说...）。是的，它是`43`，但`42`是一个整数，类型为*int*，是不可变的。所以，实际上发生的事情是，在第一行，`age`是一个指向值为`42`的*int*对象的名称。当我们输入`age
    = 43`时，发生的事情是创建了一个新的*int*对象，其值为`43`（同样，*id*也会不同），并且名称`age`被设置为指向它。所以，实际上我们没有将`42`改为`43`——我们只是将名称`age`指向了不同的位置，即新的值为`43`的*int*对象。让我们看看对象的ID：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that we call the built-in `id()` function to print the IDs. As you can
    see, they are different, as expected. Bear in mind that `age` points to one object
    at a time: `42` first, then `43` —never together.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们调用内置的`id()`函数来打印ID。如你所见，它们是不同的，正如预期的那样。记住，`age`一次指向一个对象：首先指向`42`，然后指向`43`——永远不会同时指向。
- en: If you reproduce these examples on your computer, you will notice that the IDs
    you get will be different. This is of course expected, as they are generated randomly
    by Python and will be different every time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你自己的计算机上重现这些例子，你会注意到你得到的ID将是不同的。这是当然的，因为它们是由Python随机生成的，并且每次都会不同。
- en: 'Now, let us see the same example using a mutable object. For this example,
    we will use the built-in `set` type:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用可变对象来查看相同的例子。为此，我们将使用内置的`set`类型：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, we set up an object, `numbers` , which represents a mathematical
    set. We can see its `id` being printed and the fact that it is empty ( `set()`
    ), right after creation. We then proceed to add two numbers to it: `3` and `7`
    . We print the `id` again (which shows it is the same object) and its value, which
    now shows it contains the two numbers. So the object’s value has changed, but
    its `id` is still the same. This shows the typical behavior of a mutable object.
    We will explore sets in more detail later in this chapter.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个对象，`numbers`，它代表一个数学集合。我们可以看到它的`id`在创建后立即被打印出来，并且它是空的（`set()`）。然后我们继续向其中添加两个数字：`3`和`7`。我们再次打印`id`（这表明它是指向同一个对象）和它的值，现在显示它包含这两个数字。所以对象的价值已经改变，但它的`id`仍然是相同的。这显示了可变对象的典型行为。我们将在本章的后面更详细地探讨集合。
- en: Mutability is a very important concept. We will remind you about it throughout
    the rest of the chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可变性是一个非常重要的概念。我们将在本章的其余部分提醒你。
- en: Numbers
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: Let us start by exploring Python’s built-in data types for numbers. Python was
    designed by a man with a master’s degree in mathematics and computer science,
    so it is only logical that it has extensive support for numbers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从探索Python的内置数字数据类型开始。Python是由一个拥有数学和计算机科学硕士学位的人设计的，因此它对数字的广泛支持是合乎逻辑的。
- en: Numbers are immutable objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是不可变对象。
- en: Integers
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: Python integers have an unlimited range, subject only to the available virtual
    memory. This means that it doesn’t really matter how big the number you want to
    store is—as long as it can fit in your computer’s memory, Python will take care
    of it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python整数具有无限的范围，仅受可用虚拟内存的限制。这意味着你想要存储的数字有多大并不重要——只要它能适应你的计算机内存，Python就会处理它。
- en: 'Integer numbers can be positive, negative, or 0 (zero). Their type is *int*
    . They support all the basic mathematical operations, as shown in the following
    example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 整数可以是正数、负数或0（零）。它们的类型是*int*。它们支持所有基本数学运算，如下面的例子所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code should be easy to understand. Just notice one important
    thing: Python has two division operators, one performs the so-called **true division**
    ( `/` ), which returns the quotient of the operands, and another one, the so-called
    **integer division** ( `//` ), which returns the *floored* quotient of the operands.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该很容易理解。只需注意一点：Python 有两个除法运算符，一个执行所谓的**真除法**（`/`），它返回操作数的商，另一个是所谓的**整数除法**（`//`），它返回操作数的**向下取整**商。
- en: As historical information, in Python 2, the division operator `/` behaves differently
    than in Python 3.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为历史信息，在 Python 2 中，除法运算符 `/` 的行为与 Python 3 不同。
- en: 'Let us see how division behaves differently when we introduce negative numbers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们引入负数时，除法是如何表现出不同的行为的：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is an interesting example. If you were expecting `-1` on the last line,
    don’t feel bad, it is just the way Python works. Integer division in Python is
    *always rounded toward minus infinity* . If, instead of flooring, you want to
    truncate a number to an integer, you can use the built-in `int()` function, as
    shown in the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的例子。如果你在最后一行期待 `-1`，请不要感到难过，这只是 Python 的工作方式。Python 中的整数除法**总是向负无穷大舍入**。如果你不想向下取整，而是想将一个数字截断为整数，可以使用内置的
    `int()` 函数，如下面的例子所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the truncation is done toward 0 instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，截断是向 0 方向进行的。
- en: 'The `int()` function can also return integer numbers from string representation
    in a given base:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`int()` 函数还可以从字符串表示中返回给定基数的整数数字：'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is worth noting that the power operator, `**` , also has a built-in function
    counterpart, `pow()` , shown in the example below:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，幂运算符 `**` 也有一个内置函数对应物，即下面的例子中所示的 `pow()` 函数：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is also an operator to calculate the remainder of a division. It is called
    the **modulo operator** , and it is represented by a percentage symbol ( `%` ):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个运算符可以计算除法的余数。它被称为**取模运算符**，用百分号（`%`）表示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `pow()` function allows a third argument to perform **modular exponentiation**
    .
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`pow()` 函数允许第三个参数执行**模幂运算**。'
- en: The form with three arguments also accepts a negative exponent in the case where
    the base is relatively prime to the modulus. The result is the **modular multiplicative
    inverse** of the base (or a suitable power of that, when the exponent is negative,
    but not -1), modulo the third argument.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 带有三个参数的这种形式在基数与模数互质的情况下也接受负指数。结果是基数的**模乘法逆元**（或当指数为负时，该基数的适当幂，但不是 -1），模第三个参数。
- en: 'Here’s an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'One nice feature introduced in Python 3.6 is the ability to add underscores
    within number literals (between digits or base specifiers, but not leading or
    trailing). The purpose is to help make some numbers more readable, such as `1_000_000_000`
    :'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6 引入的一个不错的新特性是能够在数字字面量中添加下划线（在数字或基数指定符之间，但不能是开头或结尾）。其目的是帮助使某些数字更易于阅读，例如
    `1_000_000_000`：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Booleans
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: '**Boolean** algebra is that subset of algebra in which the values of the variables
    are the truth values, *true* and *false* . In Python, `True` and `False` are two
    keywords that are used to represent truth values. Booleans are a subclass of integers,
    so `True` and `False` behave respectively like `1` and `0` . The equivalent of
    the *int* type for Booleans is the *bool* type, which returns either `True` or
    `False` . Every built-in Python object has a value in the Boolean context, which
    means they evaluate to either `True` or `False` when fed to the `bool` function.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔代数**是代数的一个子集，其中变量的值是真理值，即**真**和**假**。在 Python 中，`True` 和 `False` 是两个用于表示真理值的保留字。布尔值是整数的子类，因此
    `True` 和 `False` 分别像 `1` 和 `0` 一样行为。布尔值的**int**类型等价于**bool**类型，它返回 `True` 或 `False`。每个内置的
    Python 对象在布尔上下文都有一个值，这意味着当将它们传递给 `bool` 函数时，它们评估为 `True` 或 `False`。'
- en: 'Boolean values can be combined in Boolean expressions using the logical operators
    `and` , `or` , and `not` . Let us see a simple example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值可以使用逻辑运算符 `and`、`or` 和 `not` 在布尔表达式中进行组合。让我们看一个简单的例子：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Booleans are most used in conditional programming, which we will discuss in
    detail in *Chapter 3* , *Conditionals and Iteration.*
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值在条件编程中最常用，我们将在第 3 章*条件与迭代*中详细讨论。
- en: 'You can see that `True` and `False` are subclasses of integers when you try
    to add them. Python upcasts them to integers and performs the addition:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试将它们相加时，你会看到 `True` 和 `False` 是整数的子类。Python 将它们提升为整数并执行加法：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Upcasting** is a type conversion operation that goes from a subclass to its
    parent. In this example, `True` and `False` , which belong to a class derived
    from the integer class, are converted back to integers when needed. This topic
    is about inheritance and will be explained in detail in *Chapter 6* , *OOP, Decorators,
    and Iterators* .'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**向上转型**是一种类型转换操作，它从子类转换为其父类。在这个例子中，`True`和`False`，属于从整数类派生出的一个类，当需要时会被转换回整数。这个主题是关于继承的，将在*第6章*，*面向对象编程、装饰器和迭代器*中详细解释。'
- en: Real numbers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实数
- en: 'Real numbers, or **floating point numbers** , are represented in Python according
    to the **IEEE 754** double-precision binary floating point format, which stores
    them in 64 bits of information divided into three sections: sign, exponent, and
    mantissa.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实数，或**浮点数**，在Python中根据**IEEE 754**双精度二进制浮点格式表示，它们在64位信息中存储，分为三个部分：符号、指数和尾数。
- en: 'Quench your thirst for knowledge about this format on Wikipedia: [http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format)
    .'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在维基百科上了解更多关于这种格式的知识：[http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format)。
- en: 'Several programming languages offer two different formats: single and double
    precision. The former takes up 32 bits of memory, the latter 64. Python supports
    only the double format. Let us see a simple example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 几种编程语言提供了两种不同的格式：单精度和双精度。前者占用32位内存，后者占用64位。Python只支持双精度格式。让我们看看一个简单的例子：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the calculation of the area, we wrapped the `radius ** 2` within parentheses.
    Even though that wasn’t necessary because the power operator has higher precedence
    than the multiplication one, we think the formula reads more easily like that.
    Moreover, should you get a slightly different result for the area, don’t worry.
    It might depend on your OS, how Python was compiled, and so on. As long as the
    first few decimal digits are correct, you know it is the correct result.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算面积时，我们将`radius ** 2`用括号括起来。即使这不是必要的，因为幂运算符的优先级高于乘法运算符，但我们认为这样公式读起来更清晰。此外，如果你得到的面积结果略有不同，请不要担心。这可能会取决于你的操作系统、Python是如何编译的等等。只要前几位小数是正确的，你就知道这是正确的结果。
- en: 'The `sys.float_info` sequence holds information about how floating point numbers
    will behave on your system. This is an example of what you might see:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.float_info`序列包含有关浮点数在你的系统上如何表现的信息。这是一个你可能看到的例子：'
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let us make a few considerations here: we have 64 bits to represent floating
    point numbers. This means we can represent at most *2* ^(64) (that is *18,446,744,073,709,551,616*
    ) distinct numbers. Take a look at the `max` and `epsilon` values for floating
    point numbers, and you will realize that it is impossible to represent them all.
    There is just not enough space, so they are approximated to the closest representable
    number. You probably think that only extremely big or extremely small numbers
    suffer from this issue. If so, the next example will surprise you:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里让我们做一些考虑：我们有64位来表示浮点数。这意味着我们最多可以表示 *2*^(64)（即 *18,446,744,073,709,551,616*）个不同的数。看看浮点数的`max`和`epsilon`值，你就会意识到不可能表示它们全部。空间实在不够，所以它们被近似到最接近的可表示的数。你可能认为只有极大或极小的数会受到影响。如果是这样，接下来的例子会让你感到惊讶：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What does this tell you? It tells you that double precision numbers suffer from
    approximation issues even when it comes to simple numbers like 0.1 or 0.3. Why
    is this important? It can be a big problem if you are handling prices, financial
    calculations, or any kind of data that requires precision. Don’t worry, Python
    gives you the **Decimal** type, which doesn’t suffer from these issues; we’ll
    look at that in a moment.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你什么？这告诉你，即使对于像0.1或0.3这样的简单数，双精度数也会出现近似问题。为什么这很重要？如果你处理的是价格、金融计算或任何需要精度的数据，这可能会成为一个大问题。别担心，Python提供了**Decimal**类型，它不受这些问题的影响；我们稍后会看到这一点。
- en: Complex numbers
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数
- en: Python supports **complex numbers** out of the box. If you do not know what
    complex numbers are, they are numbers that can be expressed in the form *a + ib*
    , where *a* and *b* are real numbers, and *i* (or *j* , if you use the engineering
    notation) is the imaginary unit; that is, the square root of *-1* . *a* and *b*
    are called, respectively, the *real* and *imaginary* parts of the number.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python默认支持**复数**。如果你不知道什么是复数，它们是可以表示为*a + ib*形式的数字，其中*a*和*b*是实数，而*i*（或如果你使用工程符号是*j*）是虚数单位；也就是说，是*-1*的平方根。*a*和*b*分别称为数字的**实部**和**虚部**。
- en: 'It is perhaps unlikely that you will use them, but nevertheless, let us see
    a small example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不太可能使用它们，但无论如何，让我们看一个小例子：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Fractions and decimals
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分数和小数
- en: 'Let us finish the tour of the number department with a look at fractions and
    decimals. Fractions hold a rational numerator and denominator in their lowest
    forms. Let us see a quick example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看分数和小数来结束对数字部门的游览。分数以它们的最简形式持有有理的分子和分母。让我们快速看一下一个例子：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `as_integer_ratio()` method has also been added to integers and Booleans.
    This is helpful, as it allows you to use it without needing to worry about what
    type of number is being worked with.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`as_integer_ratio()`方法也添加到了整数和布尔值中。这很有帮助，因为它允许你使用它而无需担心正在处理哪种类型的数字。'
- en: 'Other than passing the numerator and denominator, fractions can also be initialized
    by passing strings, decimals, floats, and of course fractions. Let us see an example
    with floats and strings:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传递分子和分母之外，分数还可以通过传递字符串、小数、浮点数以及当然还有分数来初始化。让我们通过浮点数和字符串的例子来看一下：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Although `Fraction` objects can be very useful at times, it is not that common
    to spot them in commercial software. Instead, it is much more common to see decimal
    numbers being used in all those contexts where precision is everything, for example,
    in scientific and financial calculations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Fraction`对象有时非常有用，但在商业软件中并不常见。相反，更常见的是在所有那些精度至关重要的场合使用十进制数，例如在科学和金融计算中。
- en: It is important to remember that arbitrary precision decimal numbers come at
    a price in terms of performance, of course. The amount of data to be stored for
    each number is greater than it is for fractions or floats. The way they are handled
    also requires the Python interpreter to work harder behind the scenes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，任意精度的十进制数在性能方面是有代价的，当然。每个数字要存储的数据量比分数或浮点数要多。它们被处理的方式也要求Python解释器在幕后更加努力。
- en: 'Let us see a quick example with decimal numbers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下十进制数字的例子：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that when we construct a decimal number from a float, it takes on all
    the approximation issues a float may come with. On the other hand, when we create
    a `decimal` from an `integer` or a `string` representation of a number, then the
    `decimal` will have no approximation issues, and therefore no quirky behavior.
    When it comes to currency or situations in which precision is of utmost importance,
    use decimals.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们从一个浮点数构造一个十进制数时，它继承了浮点数可能带来的所有近似问题。另一方面，当我们从一个整数或数字的字符串表示形式创建一个`decimal`时，那么这个`decimal`将没有近似问题，因此也没有奇怪的行为。当涉及到货币或精度至关重要的场合时，请使用十进制。
- en: This concludes our introduction to built-in numeric types. Let us now look at
    sequences.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对内置数字类型的介绍。现在让我们看看序列。
- en: Immutable sequences
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变序列
- en: 'Let us explore immutable sequences: strings, tuples, and bytes.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索不可变序列：字符串、元组和字节。
- en: Strings and bytes
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串和字节
- en: Textual data in Python is handled with **str** objects, more commonly known
    as **strings** . They are immutable sequences of **Unicode code points** .
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，文本数据通过**str**对象处理，更常见的是称为**字符串**。它们是**Unicode代码点**的不可变序列。
- en: Unicode code points are the numbers assigned to each character in the Unicode
    standard, which is a universal character encoding scheme used to represent text
    in computers. The Unicode standard provides a unique number for every character,
    regardless of the platform, program, or language, thereby enabling the consistent
    representation and manipulation of text across different systems. Unicode covers
    a wide range of characters, including letters from the Latin alphabet, ideographs
    from Chinese, Japanese, and Korean writing systems, symbols, emojis, and more.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode码点是分配给Unicode标准中每个字符的数字，Unicode是一种通用的字符编码方案，用于在计算机中表示文本。Unicode标准为每个字符提供唯一的数字，无论平台、程序或语言如何，从而使得在不同系统之间对文本的一致表示和处理成为可能。Unicode涵盖了广泛的字符，包括拉丁字母的字母、中文、日文和韩文书写系统的表意文字、符号、表情符号等等。
- en: Unlike other languages, Python does not have a **char** type, so a single character
    is represented by a string of length 1.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言不同，Python没有**char**类型，所以单个字符由长度为1的字符串表示。
- en: 'Unicode should be used for the internals of any application. When it comes
    to storing textual data though, or sending it on the network, you will usually
    need to encode it, using an appropriate encoding for the medium you are using.
    The result of an encoding produces a **bytes** object, whose syntax and behavior
    are similar to that of strings. String literals are written in Python using single,
    double, or triple quotes (either single or double). If built with triple quotes,
    a string can span multiple lines. An example will clarify this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在任何应用程序的内部使用Unicode。然而，当涉及到存储文本数据或通过网络发送它时，你通常需要使用适当的编码对其进行编码，使用你正在使用的介质的适当编码。编码的结果产生一个**bytes**对象，其语法和行为与字符串类似。在Python中，字符串字面量使用单引号、双引号或三引号（单引号或双引号）编写。如果使用三引号构建，字符串可以跨越多行。以下示例将阐明这一点：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In `#A` and `#B` , we print `str4` , first implicitly, and then explicitly,
    using the `print()` function. A good exercise would be to find out why they are
    different. Are you up to the challenge? (Hint: look up the `str()` and `repr()`
    functions.)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#A`和`#B`中，我们首先隐式地打印`str4`，然后显式地使用`print()`函数打印。一个很好的练习是找出为什么它们不同。你能接受这个挑战吗？（提示：查阅`str()`和`repr()`函数。）
- en: 'Strings, like any sequence, have a length. You can get this by calling the
    `len()` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串，像任何序列一样，都有长度。你可以通过调用`len()`函数来获取它：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Python 3.9 has introduced two new methods that deal with the prefixes and suffixes
    of strings. Here’s an example that explains the way they work:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9引入了两种处理字符串前缀和后缀的新方法。以下是一个示例，解释了它们的工作方式：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The nice thing about them is shown by the last instruction: when we attempt
    to remove a prefix or suffix that is not there, the method simply returns a copy
    of the original string. Behind the scenes, these methods check if the string has
    a prefix or suffix that matches the argument of the call, and if that is the case,
    they remove it.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的优点体现在最后的指令中：当我们尝试移除一个不存在的前缀或后缀时，该方法会简单地返回原始字符串的副本。在幕后，这些方法会检查字符串是否有与调用参数匹配的前缀或后缀，如果是的话，它们会移除它。
- en: Encoding and decoding strings
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串的编码和解码
- en: 'Using the `encode/decode` methods, we can encode Unicode strings and decode
    bytes objects. **UTF-8** is a variable-length **character encoding** , capable
    of encoding all possible Unicode code points. It is the most widely used encoding
    for the web. Also notice that by adding the literal `b` in front of a string declaration,
    we are creating a `bytes` object:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`encode/decode`方法，我们可以对Unicode字符串进行编码，对bytes对象进行解码。**UTF-8**是一种可变长度的**字符编码**，能够编码所有可能的Unicode码点。它是互联网上使用最广泛的编码。注意，通过在字符串声明前添加字面量`b`，我们正在创建一个`bytes`对象：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Indexing and slicing strings
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串的索引和切片
- en: When manipulating sequences, it is very common to access them at one precise
    position ( **indexing** ) or to get a sub-sequence out of them ( **slicing** ).
    When dealing with immutable sequences, both operations are read-only.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理序列时，访问它们的一个精确位置（**索引**）或从中获取子序列（**切片**）是非常常见的。当处理不可变序列时，这两种操作都是只读的。
- en: 'While indexing comes in one form—zero-based access to any position within the
    sequence—slicing comes in different forms. When you get a slice of a sequence,
    you can specify the *start* and *stop* positions, along with the *step* . They
    are separated with a colon ( `:` ) like this: `my_sequence[start:stop:step]` .
    All the arguments are optional; `start` is inclusive, and `stop` is exclusive.
    It is probably better to see an example, rather than trying to explain them any
    further with words:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然索引只有一种形式——对序列中任何位置的零基访问——但切片有不同形式。当你从序列中获取一个切片时，你可以指定 *start* 和 *stop* 位置，以及
    *step* 。它们用冒号（`:`）分隔，如下所示：`my_sequence[start:stop:step]`。所有参数都是可选的；`start` 是包含的，而
    `stop` 是排除的。可能最好通过示例来理解，而不是用文字进一步解释：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last line is quite interesting. If you don’t specify any of the parameters,
    Python will fill in the defaults for you. In this case, *start* will be the start
    of the string, *stop* will be the end of the string, and *step* will be the default:
    1. This is an easy and quick way of obtaining a copy of the string `s` (the same
    value, but a different object). Can you think of a way to get the reversed copy
    of a string using slicing (do not look it up—find it for yourself)?'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行相当有趣。如果你没有指定任何参数，Python 会为你填充默认值。在这种情况下，*start* 将是字符串的开始，*stop* 将是字符串的结束，而
    *step* 将是默认值：1。这是一种简单快捷的方法来获取字符串 `s` 的副本（相同的值，但不同的对象）。你能想到一种使用切片来获取字符串反转副本的方法吗（不要查找它——自己找出来）？
- en: String formatting
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: 'One useful feature of strings is that they can be used as templates. This means
    that they can contain placeholders that can be replaced by arbitrary values using
    formatting operations. There are several ways of formatting a string. For the
    full list of possibilities, we encourage you to look up the documentation. Here
    are some common examples:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的一个有用特性是它们可以用作模板。这意味着它们可以包含占位符，这些占位符可以通过格式化操作用任意值替换。有几种格式化字符串的方法。关于所有可能性的完整列表，我们鼓励您查阅文档。以下是一些常见的示例：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous example, you can see four different ways of formatting strings.
    The first one, which relies on the `%` operator, can lead to unexpected errors
    and should be used with care. A more modern way to format a string is by using
    the `format()` string method. You can see, from the different examples, that a
    pair of curly braces acts as a placeholder within the string. When we call `format()`
    , we feed it data that replaces the placeholders. We can specify indexes (and
    much more) within the curly braces, and even names, which implies we must call
    `format()` using keyword arguments instead of positional ones.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到四种不同的字符串格式化方法。第一种，依赖于 `%` 操作符，可能会导致意外的错误，应该小心使用。一种更现代的字符串格式化方法是使用
    `format()` 字符串方法。你可以从不同的示例中看到，一对大括号在字符串中充当占位符。当我们调用 `format()` 时，我们向它提供数据来替换占位符。我们可以在大括号内指定索引（以及更多），甚至名称，这意味着我们必须使用关键字参数而不是位置参数来调用
    `format()`。
- en: Notice how `greet_positional_idx` is rendered differently by feeding different
    data to the call to `format` .
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `greet_positional_idx` 是如何通过向 `format` 调用提供不同的数据而以不同的方式呈现的。
- en: 'One feature we want to show you was added to Python in version 3.6, and it
    is called **formatted string literals** . This feature is quite cool (and it is
    faster than using the `format()` method): strings are prefixed with `f` , and
    contain replacement fields surrounded by curly braces.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想向您展示的一个特性是在 Python 3.6 版本中添加的，它被称为 **格式化字符串字面量**。这个特性非常酷（而且比使用 `format()`
    方法更快）：字符串以 `f` 为前缀，并包含由大括号包围的替换字段。
- en: 'Replacement fields are expressions evaluated at runtime, and then formatted
    using the format protocol:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字段是在运行时评估的表达式，然后使用格式协议进行格式化：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An interesting addition to f-strings, which was introduced in Python 3.8, is
    the ability to add an equal sign specifier within the f-string clause; this causes
    the expression to expand to the text of the expression, an equal sign, then the
    representation of the evaluated expression. This is great for self-documenting
    and debugging purposes. Here’s an example that shows the difference in behavior:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: f-strings（在 Python 3.8 中引入）的一个有趣补充是，可以在 f-string 子句中添加一个等号指定符；这会导致表达式扩展为表达式的文本，然后是一个等号，接着是评估表达式的表示。这对于自文档化和调试目的来说非常好。以下是一个显示行为差异的示例：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In version 3.12, the f-string syntactic formalization has been upgraded with
    a few features, which are outlined in PEP 701 ( [https://peps.python.org/pep-0701/](https://peps.python.org/pep-0701/)
    ). One of these features is quote reuse:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本3.12中，f-string的语法规范化通过几个特性得到了升级，这些特性在PEP 701（[https://peps.python.org/pep-0701/](https://peps.python.org/pep-0701/)）中概述。这些特性之一是引号重用：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice how we have reused double quotes within the curly braces, and this hasn’t
    broken our code. Here we are using the `join()` method of the string `","` to
    join together the strings from the `languages` list using a comma and a space.
    In previous versions of Python, we would have had to delimit the string inside
    the curly braces using single quotes: `'', ''` .'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在花括号内重用了双引号，这并没有破坏我们的代码。在这里，我们使用字符串`","`的`join()`方法，用逗号和空格将`languages`列表中的字符串连接起来。在Python的早期版本中，我们不得不在花括号内使用单引号来界定字符串：`',
    '`。
- en: Another feature is the ability to write multiline expressions and comments,
    and also to use backslashes ( `\` ), which wasn’t allowed before.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特性是能够编写多行表达式和注释，以及使用反斜杠（`\`），这在之前是不允许的。
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Check out the official documentation to learn everything about string formatting
    and how powerful it can be.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 查看官方文档以了解有关字符串格式化和其强大功能的全部内容。
- en: Tuples
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'The last immutable sequence type we are going to look at here is the **tuple**
    . A tuple is a sequence of arbitrary Python objects. In a tuple declaration, items
    are separated by commas. Tuples are used everywhere in Python. They allow patterns
    that are quite hard to reproduce in other languages. Sometimes tuples are used
    without parentheses; for example, to set up multiple variables on one line, or
    to allow a function to return multiple objects (in several languages, it is common
    for functions to only be able to return one object), and in the Python console,
    tuples can be used implicitly to print multiple elements with one single instruction.
    We will see examples for all these cases:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们要讨论的最后一种不可变序列类型是**元组**。元组是任意Python对象的序列。在元组声明中，项目由逗号分隔。元组在Python中无处不在。它们允许其他语言难以复制的模式。有时元组不使用括号；例如，在一行中设置多个变量，或者允许函数返回多个对象（在许多语言中，函数通常只能返回一个对象），以及在Python控制台中，可以使用单个指令隐式地使用元组打印多个元素。我们将看到所有这些情况的示例：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We use the `in` operator to check whether a value is a member of a tuple. This
    membership operator can also be used with lists, strings, and dictionaries, and
    with collection and sequence objects, in general.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`in`运算符来检查一个值是否是元组的成员。这个成员运算符也可以与列表、字符串和字典一起使用，以及一般地与集合和序列对象一起使用。
- en: To create a tuple with one item, we need to put a comma after the item. The
    reason is that, without the comma, that item is wrapped in braces on its own,
    in what can be considered a redundant expression. Notice also that, on assignment,
    braces are optional, so `my_tuple = 1, 2, 3` is the same as `my_tuple = (1, 2,
    3)` .
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个只有一个元素的元组，我们需要在该元素后放置一个逗号。原因是，如果没有逗号，该元素将单独用大括号括起来，这可以被认为是一个冗余的表达式。注意，在赋值时，大括号是可选的，所以`my_tuple
    = 1, 2, 3`与`my_tuple = (1, 2, 3)`相同。
- en: 'One thing that tuple assignment allows us to do is *one-line swaps* , with
    no need for a third temporary variable. Let us first see the traditional way of
    doing it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 元组赋值允许我们进行*一行交换*，无需第三个临时变量。让我们首先看看传统的做法：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now let us see how we would do it in Python:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在Python中实现它：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Look at the line that shows you the Pythonic way of swapping two values. Do
    you remember what we wrote in *Chapter 1* , *A Gentle Introduction to Python*
    ? A Python program is typically one-fifth to one-third the size of equivalent
    Java or C++ code and features like one-line swaps contribute to this. Python is
    elegant, where elegance in this context also means economy.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 看看展示Python交换两个值方式的行。你还记得我们在*第一章*，《Python的温柔介绍》中写了什么吗？Python程序通常比等价的Java或C++代码小五分之一到三分之一，而像一行交换这样的特性也对此做出了贡献。Python是优雅的，这里的优雅也意味着经济。
- en: Because they are immutable, tuples can be used as keys for dictionaries (we
    will see this shortly). To us, tuples are Python’s built-in data that most closely
    represent a mathematical vector. This does not mean that this was the reason for
    which they were created, though. Tuples usually contain a heterogeneous sequence
    of elements while, on the other hand, lists are, most of the time, homogeneous.
    Moreover, tuples are normally accessed via unpacking or indexing, while lists
    are usually iterated over.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是不可变的，元组可以用作字典的键（我们很快就会看到这一点）。对我们来说，元组是Python中与数学向量最接近的内置数据。这并不意味着这就是它们被创建的原因。元组通常包含异质元素序列，而另一方面，列表大多数时候是同质的。此外，元组通常通过解包或索引访问，而列表通常通过迭代访问。
- en: Mutable sequences
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变序列
- en: '**Mutable sequences** differ from their immutable counterparts in that they
    can be changed after creation. There are two mutable sequence types in Python:
    **lists** and **bytearrays** .'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变序列**与它们的不可变对应物不同，因为它们在创建后可以更改。Python中有两种可变序列类型：**列表**和**字节数组**。'
- en: Lists
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'Python lists are similar to tuples, but they do not have the restrictions of
    immutability. Lists are commonly used for storing collections of homogeneous objects,
    but there is nothing preventing you from storing heterogeneous collections as
    well. Lists can be created in many different ways. Let us see an example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表与元组类似，但它们没有不可变性的限制。列表通常用于存储同质对象的集合，但没有任何阻止您存储异质集合的东西。列表可以通过许多不同的方式创建。让我们看一个例子：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the previous example, we showed you how to create a list using various techniques.
    We would like you to take a good look at the line with the comment *Python is
    magic* , which we do not expect you to fully understand at this point—especially
    if you are unfamiliar with Python. That is called a **list comprehension** : a
    powerful functional feature of Python, which we will see in detail in *Chapter
    5* , *Comprehensions and Generators* . We just wanted to spark your curiosity
    at this point.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们向您展示了如何使用各种技术创建列表。我们希望您仔细看看带有注释*Python is magic*的那一行，我们并不期望您在这个阶段完全理解它——尤其是如果您对Python不熟悉。这被称为**列表推导**：Python的一个强大功能特性，我们将在*第5章*，*推导式和生成器*中详细探讨。我们只是想在这个阶段激发您的兴趣。
- en: 'Creating lists is good, but the real fun begins when we use them, so let us
    see the main methods they offer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表创建是好的，但真正的乐趣在于我们如何使用它们，所以让我们看看它们提供的主要方法：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code gives you a roundup of a list’s main methods. We want to
    show you how powerful they are using the `extend()` method as an example. You
    can extend lists using any sequence type:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为您总结了列表的主要方法。我们想通过使用`extend()`方法作为例子来展示它们的强大功能。您可以使用任何序列类型来扩展列表：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let us see some common operations you can do with lists:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看您可以使用列表执行的一些常见操作：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice how easily we can perform the sum and the product of all values in a
    list. The `prod() function` , from the `math` module, is just one of the many
    additions introduced in Python 3.8. Even if you do not plan to use it that often,
    it is a good idea to check out the `math` module and be familiar with its functions,
    as they can be quite helpful.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何轻松地计算列表中所有值的总和和乘积。`prod()`函数来自`math`模块，是Python 3.8中引入的许多新增功能之一。即使您不打算经常使用它，了解`math`模块并熟悉其函数也是一个好主意，因为它们可能非常有帮助。
- en: The last two lines in the preceding code are also quite interesting, as they
    introduce us to a concept called **operator overloading** . In short, this means
    that operators, such as `+` , `-` , `*` , `%` , and so on, may represent different
    operations according to the context they are used in. It does not make any sense
    to sum two lists, right? Therefore, the `+` sign is used to concatenate them.
    Hence, the `*` sign is used to concatenate the list to itself a number of times
    specified by the right operand.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的最后两行也非常有趣，因为它们向我们介绍了一个称为**运算符重载**的概念。简而言之，这意味着运算符，如`+`、`-`、`*`、`%`等，根据它们使用的上下文可能代表不同的操作。将两个列表相加没有意义，对吧？因此，`+`符号用于连接它们。因此，`*`符号用于将列表与自身连接指定次数，这个次数由右操作数指定。
- en: 'Now, let us take a step further and see something a little more interesting.
    We want to show you how powerful the `sorted` method can be and how easy it is
    in Python to achieve results that may require a great deal of effort in other
    languages:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更进一步，看看一些更有趣的东西。我们想向您展示`sorted`方法有多强大，以及Python如何轻松实现在其他语言中可能需要大量努力才能实现的结果：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding code deserves a little explanation. Note that, `a` is a list
    of tuples. This means each element in `a` is a tuple (a 2-tuple in this case).
    When we call `sorted(my_list)` , we get a sorted version of `my_list` . In this
    case, the sorting on a 2-tuple works by sorting them on the first item in the
    tuple, and on the second when the first one is the same. You can see this behavior
    in the result of `sorted(a)` , which yields `[(1, 2), (1, 3), ...]` . Python also
    gives us the ability to control which element(s) of the tuple the sorting must
    be run against. Notice that when we instruct the `sorted` function, to work on
    the first element of each tuple (with `key=itemgetter(0)` ), the result is different:
    `[(1, 3), (1, 2), ...]` . The sorting is done only on the first element of each
    tuple (which is the one at position 0). If we want to replicate the default behavior
    of a simple `sorted(a)` call, we need to use `key=itemgetter(0, 1)` , which tells
    Python to sort first on the elements at position 0 within the tuples, and then
    on those at position 1. Compare the results and you will see that they match.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码需要一点解释。注意，`a` 是一个元组列表。这意味着 `a` 中的每个元素都是一个元组（在这个例子中是一个2元组）。当我们调用 `sorted(my_list)`
    时，我们得到 `my_list` 的排序版本。在这种情况下，对2元组的排序是通过在元组的第一个元素上进行排序，当第一个元素相同时，在第二个元素上进行排序。你可以在
    `sorted(a)` 的结果中看到这种行为，它产生 `[(1, 2), (1, 3), ...]` 。Python 也给了我们控制元组中哪个元素必须进行排序的能力。注意，当我们指示
    `sorted` 函数在元组的第一个元素上工作（使用 `key=itemgetter(0)` ）时，结果就不同了：`[(1, 3), (1, 2), ...]`
    。排序仅在每个元组的第一个元素上进行（这是位置0的元素）。如果我们想复制简单的 `sorted(a)` 调用的默认行为，我们需要使用 `key=itemgetter(0,
    1)` ，这告诉 Python 首先在元组内的位置0的元素上进行排序，然后是位置1的元素。比较结果，你会发现它们是一致的。
- en: For completeness, we included an example of sorting only on the elements at
    position 1, and then again, with the same sorting but in reverse order. If you
    have ever seen sorting in other languages, you should be quite impressed at this
    moment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们包括了仅对位置1的元素进行排序的示例，然后再次，以相同的排序但顺序相反。如果你在其他语言中见过排序，你应该在这个时刻感到相当印象深刻。
- en: The Python sorting algorithm is very powerful, and it was written by Tim Peters
    (the author of *The Zen of Python* ). It is aptly named **Timsort** , and it is
    a blend between **merge** and **insertion sort** and has better time performance
    than most other algorithms used for mainstream programming languages. Timsort
    is a stable sorting algorithm, which means that when multiple records score the
    same in the comparison, their original order is preserved. We have seen this in
    the result of `sorted(a, key=itemgetter(0))` , which yielded `[(1, 3), (1, 2),
    ...]` , in which the order of those two tuples was preserved because they had
    the same value at position 0.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的排序算法非常强大，它是由 Tim Peters（*Python之禅* 的作者）编写的。它恰当地命名为 **Timsort** ，它是 **归并排序**
    和 **插入排序** 的结合，并且比大多数用于主流编程语言的算法具有更好的时间性能。Timsort 是一个稳定的排序算法，这意味着当多个记录在比较中得分相同时，它们的原始顺序被保留。我们在
    `sorted(a, key=itemgetter(0))` 的结果中看到了这一点，它产生了 `[(1, 3), (1, 2), ...]` ，其中这两个元组的顺序被保留，因为它们在位置0的值相同。
- en: Bytearrays
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节数组
- en: To conclude our overview of mutable sequence types, let us spend a moment on
    the **bytearray** type. Bytearrays are the mutable version of bytes objects. They
    expose most of the usual methods of mutable sequences as well as most of the methods
    of the bytes type. Items in a bytearray are integers in the range [0, 256).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们对可变序列类型的概述，让我们花一点时间来谈谈 **bytearray** 类型。字节数组是字节对象的可变版本。它们公开了大多数可变序列的常规方法以及字节类型的大多数方法。字节数组中的项是范围
    [0, 256) 内的整数。
- en: To represent intervals, we are going to use the standard notation for open/closed
    ranges. A square bracket on one end means that the value is included, while a
    round bracket means that it is excluded. The granularity is usually inferred by
    the type of the edge elements so, for example, the interval [3, 7] means all integers
    between 3 and 7, inclusive. On the other hand, (3, 7) means all integers between
    3 and 7, exclusive (4, 5, and 6). Items in a bytearray type are integers between
    0 and 256; 0 is included, 256 is not.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示区间，我们将使用开放/封闭范围的常规表示法。一个方括号在一端意味着该值被包含，而一个圆括号意味着它被排除。粒度通常由边缘元素的类型推断，例如，区间
    [3, 7] 表示介于3和7之间的所有整数，包括3和7。另一方面，(3, 7) 表示介于3和7之间的所有整数，不包括（4，5和6）。字节数组类型的项是介于0和256之间的整数；0被包含，256不被包含。
- en: 'One reason that intervals are often expressed like this is to ease coding.
    If we break a range [a, b) into N consecutive ranges, we can easily represent
    the original one as a concatenation like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 间隔通常以这种方式表达的一个原因是便于编码。如果我们把范围[a, b)分成N个连续的范围，我们可以很容易地用如下方式表示原始范围：
- en: '[a,k [1] ) + [k [1] ,k [2] ) + [k [2] ,k [3] ) + ... + [k [N-1] ,b)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[a,k[1)] + [k[1],k[2)] + [k[2],k[3)] + ... + [k[N-1],b)'
- en: The middle points (k [i] ) being excluded on one end, and included on the other
    end, allows easy concatenation and splitting.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一端排除中间点(k[i])，另一端包含中间点，使得连接和分割变得容易。
- en: 'Let us see an example with the `bytearray` type:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个`bytearray`类型的例子来看看：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, there are a few ways to create a `bytearray` object. They can
    be useful in many situations; for example, when receiving data through a socket,
    they eliminate the need to concatenate data while polling, hence they can prove
    to be very handy. On line `#A` , we created a `bytearray` named `name` from the
    bytes literal `b'Lina'` to show you how the `bytearray` object exposes methods
    from both sequences and strings, which is extremely handy. If you think about
    it, they can be considered mutable strings.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，创建`bytearray`对象有几种方式。它们在许多情况下都可能很有用；例如，在通过套接字接收数据时，它们消除了在轮询时需要连接数据的需求，因此它们可能非常方便。在行`#A`中，我们从一个字节数组字面量`b'Lina'`创建了一个名为`name`的`bytearray`，以向你展示`bytearray`对象如何公开序列和字符串的方法，这非常方便。如果你这么想，它们可以被看作是可变的字符串。
- en: Set types
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合类型
- en: Python also provides two set types, `set` and `frozenset` . The `set` type is
    mutable, while `frozenset` is immutable. They are unordered collections of immutable
    objects. When printed, they are usually represented as comma-separated values,
    within a pair of curly braces.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了两种集合类型，`set`和`frozenset`。`set`类型是可变的，而`frozenset`是不可变的。它们是无序的不可变对象集合。当打印时，它们通常以逗号分隔的值形式表示，在成对的括号内。
- en: '**Hashability** is a characteristic that allows an object to be used as a set
    member as well as a key for a dictionary, as we will see very soon.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**可哈希性**是一种特性，使得一个对象可以作为集合成员以及作为字典的键使用，正如我们很快就会看到的。'
- en: 'From the official documentation ( [https://docs.python.org/3.12/glossary.html#term-hashable](https://docs.python.org/3.12/glossary.html#term-hashable)
    ):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从官方文档（[https://docs.python.org/3.12/glossary.html#term-hashable](https://docs.python.org/3.12/glossary.html#term-hashable)）：
- en: ”An object is **hashable** if it has a hash value which never changes during
    its lifetime, and can be compared to other objects. […] Hashability makes an object
    usable as a dictionary key and a set member, because these data structures use
    the hash value internally. Most of Python’s immutable built-in objects are hashable;
    mutable containers (such as lists or dictionaries) are not; immutable containers
    (such as tuples and frozensets) are only hashable if their elements are hashable.
    Objects which are instances of user-defined classes are hashable by default. They
    all compare unequal (except with themselves), and their hash value is derived
    from their `id()` .”
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “一个对象是**可哈希的**，如果它在整个生命周期中有一个永远不会改变的哈希值，并且可以与其他对象进行比较。 [...] 可哈希性使得对象可以作为字典键和集合成员使用，因为这些数据结构在内部使用哈希值。Python的大多数不可变内置对象都是可哈希的；可变容器（如列表或字典）不是；不可变容器（如元组和frozenset）只有在它们的元素是可哈希的时才是可哈希的。用户定义类的实例默认是可哈希的。它们都不相等（除了与自己相等），它们的哈希值是从它们的`id()`派生出来的。”
- en: 'Objects that compare equal must have the same hash value. Sets are very commonly
    used to test for membership; let us introduce the `in` operator in the following
    example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 相等的对象必须有相同的哈希值。集合通常被用来测试成员资格；让我们在以下示例中介绍`in`运算符：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code, you can see two ways to create a set. One creates an
    empty set and then adds elements one at a time. The other creates the set using
    a list of numbers as an argument to the constructor, which does all the work for
    us. Of course, you can create a set from a list or tuple (or any iterable) and
    then you can add and remove members from the set as you please.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到创建集合的两种方式。一种是一次添加一个元素创建一个空集合，另一种是使用构造函数的数字列表作为参数来创建集合，这为我们做了所有的工作。当然，你可以从一个列表或元组（或任何可迭代对象）创建一个集合，然后你可以随意添加和删除集合中的成员。
- en: We will look at **iterable** objects and iteration in the next chapter. For
    now, just know that iterable objects are objects you can iterate on in a direction.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中探讨**可迭代**对象和迭代。现在，只需知道可迭代对象是你可以按某个方向迭代的对象。
- en: 'Another way of creating a set is by simply using the curly braces notation,
    like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集合的另一种方法是简单地使用花括号表示法，如下所示：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Notice we added some duplication to emphasize that the resulting set will not
    have any. Let us see an example using the immutable counterpart of the set type,
    `frozenset` :'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加了一些重复来强调结果集合将没有任何重复。让我们用一个不可变的集合类型 `frozenset` 的例子来看看：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, `frozenset` objects are quite limited with respect to their
    mutable counterpart. They still prove very effective for membership tests, union,
    intersection, and difference operations, and for performance reasons.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`frozenset` 对象与其可变对应物相比相当有限。它们在成员测试、并集、交集和差集操作以及性能方面仍然非常有效。
- en: 'Mapping types: dictionaries'
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类型：字典
- en: Of all the built-in Python data types, the dictionary is easily the most interesting.
    It is the only standard mapping type, and it is the backbone of every Python object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有内置的 Python 数据类型中，字典无疑是最好玩的。它是唯一的标准映射类型，并且是每个 Python 对象的骨架。
- en: 'A dictionary maps keys to values. Keys need to be hashable objects, while values
    can be of any arbitrary type. Dictionaries are also mutable objects. There are
    quite a few ways to create a dictionary, so let us give you a simple example of
    five ways to create a dictionary:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 字典将键映射到值。键需要是可哈希的对象，而值可以是任何任意类型。字典也是可变对象。创建字典的方法有很多，所以让我们给你一个创建字典的五种简单方法的例子：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: All these dictionaries map the key `A` to the value `1` , and `Z` to the value
    `-1` .
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些字典都将键 `A` 映射到值 `1`，而 `Z` 映射到值 `-1`。
- en: Did you notice those double equals? Assignment is done with one equal, while
    to check whether an object is the same as another one (or five in one go, in this
    case), we use double equals. There is also another way to compare objects, which
    involves the `is` operator, and checks whether the two objects are the same (that
    is, that they have the same ID, not just the same value), but unless you have
    a good reason to use it, you should use the double equals instead.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到那些双等号吗？赋值使用一个等号，而要检查一个对象是否与另一个对象（或在这种情况下一次五个）相同，我们使用双等号。还有另一种比较对象的方法，它涉及到
    `is` 操作符，并检查两个对象是否相同（即它们具有相同的 ID，而不仅仅是相同的值），但除非你有很好的理由使用它，否则你应该使用双等号。
- en: 'In the preceding code, we also used one nice function: `zip()` . It is named
    after the real-life zip, which glues together two parts, taking one element from
    each part at a time. Let us show you an example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们还使用了一个很棒的功能：`zip()`。它是以现实生活中的拉链命名的，它将两个部分粘合在一起，一次从每个部分取一个元素。让我们给你一个例子：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding example, we have created the same list in two different ways,
    one more explicit, and the other a little bit more Pythonic. Forget for a moment
    that we had to wrap the `list()` constructor around the `zip()` call (the reason
    is `zip()` returns an iterator, not a `list` , so if we want to see the result,
    we need to exhaust that iterator into something—a list in this case), and concentrate
    on the result. See how `zip()` has coupled the first elements of its two arguments
    together, then the second ones, then the third ones, and so on?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们以两种不同的方式创建了相同的列表，一种更明确，另一种更符合 Python 风格。暂时忘记我们不得不在 `zip()` 调用周围包裹
    `list()` 构造函数（原因是 `zip()` 返回一个迭代器，而不是 `list`，因此如果我们想看到结果，我们需要将迭代器耗尽到某种东西——在这个例子中是一个列表），而专注于结果。看看
    `zip()` 是如何将其两个参数的第一个元素配对，然后是第二个，然后是第三个，以此类推？
- en: 'Take a look at the zip of a suitcase, a purse, or the cover of a pillow, and
    you will see it works exactly like the one in Python. But let us go back to dictionaries
    and see how many useful methods they expose for allowing us to manipulate them
    as we want. Let us start with the basic operations:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 看看手提箱、钱包或枕头套的拉链，你会发现它的工作方式与 Python 中的完全一样。但让我们回到字典，看看它们为我们提供了多少有用的方法来按我们的意愿操作它们。让我们从基本操作开始：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice how accessing keys of a dictionary, regardless of the type of operation
    we are performing, is done using square brackets. Do you remember strings, lists,
    and tuples? We were accessing elements at some position through square brackets
    as well, which is yet another example of Python’s consistency.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意访问字典的键时，无论我们执行的操作类型如何，都是使用方括号完成的。你还记得字符串、列表和元组吗？我们也是通过方括号访问某些位置的元素，这是 Python
    一致性的另一个例子。
- en: 'Let us now look at three special objects called **dictionary views** : `keys`
    , `values` , and `items` . These objects provide a dynamic view of the dictionary
    entries. They change when the dictionary changes. `keys()` returns all the keys
    in the dictionary, `values()` returns all the values in the dictionary, and `items()`
    returns all the *(key, value)* pairs in the dictionary, as a list of 2-tuples.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看三个称为**字典视图**的特殊对象：`keys`、`values`和`items`。这些对象提供了对字典条目的动态视图。当字典发生变化时，它们也会发生变化。`keys()`返回字典中的所有键，`values()`返回字典中的所有值，`items()`返回字典中的所有*（键，值）*对，作为一个2元组的列表。
- en: 'Let us exercise all this with some code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些代码来练习所有这些内容：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are a few things to note here. First, notice how we are creating a dictionary
    by iterating over the zipped version of the string `'hello'` and the numbers `0,
    1, 2, 3, 4` . The string `'hello'` has two `'l'` characters inside, and they are
    paired up with the values 2 and 3 by the `zip()` function. Notice how in the dictionary,
    the second occurrence of the `'l'` key (the one with the value 3), overwrites
    the first one (the one with the value 2). This is because every key in a dictionary
    must be unique. Another thing to notice is that when asking for any view, the
    original order in which items were added is preserved.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个需要注意的地方。首先，注意我们是如何通过迭代字符串`'hello'`和数字`0, 1, 2, 3, 4`的打包版本来创建字典的。字符串`'hello'`中有两个`'l'`字符，它们通过`zip()`函数与值2和3配对。注意在字典中，第二个`'l'`键（值为3）覆盖了第一个（值为2）。这是因为字典中的每个键都必须是唯一的。另一件需要注意的事情是，当请求任何视图时，保留项目添加的原始顺序。
- en: 'We will see how these views are fundamental tools when we discuss iterating
    over collections. For now, let us look at some other useful methods exposed by
    Python’s dictionaries:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论遍历集合时，我们将看到这些观点是如何成为基本工具的。现在，让我们看看Python字典暴露的一些其他有用的方法：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'All these methods are quite simple to understand, but it is worth talking about
    that `None` for a moment. Every function in Python returns `None` unless the `return`
    statement is explicitly used to return something else. We will see this in depth
    when we explore functions in *Chapter 4* , *Functions, the Building Blocks of
    Code* . `None` is frequently used to represent the absence of a value, and it
    is quite commonly used as a default value for arguments in function declarations.
    Inexperienced coders may sometimes write functions that return either `False`
    or `None` . Both `False` and `None` evaluate to `False` in a Boolean context,
    so it may seem that there is not much difference between them. But actually, we
    would argue that there is an important difference: `False` means that we have
    information, and the information we have is `False` .'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都很容易理解，但值得花点时间谈谈`None`。Python中的每个函数都会返回`None`，除非显式地使用`return`语句返回其他内容。当我们探索第4章中的函数，即代码的构建块时，我们将深入了解这一点。`None`经常用来表示没有值，并且它通常用作函数声明中参数的默认值。经验不足的程序员有时会编写返回`False`或`None`的函数。在布尔上下文中，`False`和`None`都评估为`False`，所以它们之间似乎没有太大的区别。但实际上，我们会认为它们之间有一个重要的区别：`False`表示我们有信息，而我们拥有的信息是`False`。
- en: '`None` means *no information* ; no information is very different from information
    that is `False` . In plain language, if you ask your mechanic *Is my car ready?*
    , there is a big difference between the answer *No, it is not* ( `False` ) and
    *I have no idea* ( `None` ).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`表示*没有信息*；没有信息与`False`的信息非常不同。用简单的话说，如果你问你的修车工*我的车准备好了吗？*，那么回答*没有，还没有*（`False`）和*我不知道*（`None`）之间有很大的区别。'
- en: 'One last method we really like about dictionaries is `setdefault()` . The `setdefault()`
    method behaves like the `get()` one. When called, it will also set the `key/value`
    pair into the dictionary. Let us see an example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常喜欢字典的最后一个方法`setdefault()`。`setdefault()`方法的行为类似于`get()`方法。当被调用时，它也会将`key/value`对设置到字典中。让我们看一个例子：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This brings us to the end of this tour of dictionaries. Test your knowledge
    about them by trying to predict what `d` looks like after this line:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对字典的这次游览。通过尝试预测这一行之后的`d`看起来像什么来测试你对它们的了解：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Do not worry if it is not immediately obvious to you. We just want to encourage
    you to experiment with dictionaries.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些内容对你来说不是立即显而易见，请不要担心。我们只是想鼓励你尝试使用字典。
- en: 'Python 3.9 added a new union operator, available for `dict` objects, which
    was introduced by **PEP 584** . When it comes to applying union to `dict` objects,
    we need to remember that union for them is not commutative. This becomes evident
    when the two `dict` objects we are merging have one or more keys in common. Check
    out this example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9 添加了一个新的并集操作符，可用于 `dict` 对象，这是由 **PEP 584** 引入的。当涉及到将并集应用于 `dict`
    对象时，我们需要记住，对于它们来说，并集不是交换的。当合并的两个 `dict` 对象有一个或多个共同键时，这一点变得明显。查看以下示例：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, the `dict` objects `d` and `e` have the key `'b'` in common. In `d` ,
    the value associated with `'b'` is `'B'` ; whereas, in `e` , it is the number
    8. This means that when we merge the two, with `e` on the righthand side of the
    union operator, `|` , the value in `e` overrides the one in `d` . The opposite
    happens, of course, when we swap the positions of those objects in relation to
    the union operator.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`dict` 对象 `d` 和 `e` 共享 `'b'` 这个键。在 `d` 中，与 `'b'` 关联的值是 `'B'`；而在 `e` 中，它是数字
    8。这意味着当我们使用并集操作符 `|` 将 `e` 放在右侧合并这两个对象时，`e` 中的值会覆盖 `d` 中的值。当然，当我们交换这些对象相对于并集操作符的位置时，情况正好相反。
- en: In this example, you can also see how the union can be performed by using the
    `**` operator to produce a **dictionary unpacking** . It is worth noting that
    union can also be performed as an augmented assignment operation ( `d |= e` ),
    which works in place. Please refer to PEP 584 for more information about this
    feature.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您还可以看到如何使用 `**` 操作符执行并集操作以产生 **字典解包**。值得注意的是，并集也可以作为增强赋值操作（`d |= e`）执行，它是就地进行的。请参阅
    PEP 584 获取有关此功能的更多信息。
- en: This completes our tour of built-in data types. Before we conclude this chapter,
    we want to take a brief look at other data types provided by the standard library.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对内置数据类型的巡礼。在我们结束这一章之前，我们想简要地看看标准库提供的其他数据类型。
- en: Data types
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'Python provides a variety of specialized data types, such as dates and times,
    container types, and enumerations. There is a whole section in the Python standard
    library titled *Data Types* , which deserves to be explored; it is filled with
    interesting and useful tools for every programmer’s needs. You can find it here:
    [https://docs.python.org/3/library/datatypes.html](https://docs.python.org/3/library/datatypes.html)
    .'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了各种专用数据类型，例如日期和时间、容器类型和枚举。Python 标准库中有一个名为 *数据类型* 的整个章节，值得探索；它充满了满足每个程序员需求的有趣和有用的工具。您可以在以下位置找到它：[https://docs.python.org/3/library/datatypes.html](https://docs.python.org/3/library/datatypes.html)。
- en: In this section, we will give you a brief introduction to dates and times, collections,
    and enumerations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍日期和时间、集合以及枚举。
- en: Dates and times
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期和时间
- en: The Python standard library provides several data types that can be used to
    deal with dates and times. This may seem like a simple topic at first, but time
    zones, daylight saving time, leap years, and other quirks can easily trip up an
    unwary programmer. There are also a huge number of ways to format and localize
    date and time information. This, in turn, makes it challenging to parse dates
    and times. This is probably why it is quite common for professional Python programmers
    to also rely on various third-party libraries to provide some much-needed extra
    power when working with dates and times.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库提供了几种可以用来处理日期和时间的内置数据类型。一开始这可能看起来是一个简单的话题，但时区、夏令时、闰年以及其他怪癖很容易让一个粗心的程序员陷入困境。还有大量格式化和本地化日期和时间信息的方法。这反过来又使得解析日期和时间变得具有挑战性。这可能是为什么专业的
    Python 程序员在处理日期和时间时也常常依赖各种第三方库来提供一些急需的额外功能。
- en: The standard library
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准库
- en: We will start with the standard library and finish the session with a little
    overview of what is out there in terms of the third-party libraries you can use.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从标准库开始，并以第三方库的简要概述结束整个会话。
- en: 'From the standard library, the main modules that are used to handle dates and
    times are `datetime` , `calendar` , `zoneinfo` , and `time` . Let us start with
    the imports you will need for this whole section:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从标准库中，用于处理日期和时间的最主要模块是 `datetime`、`calendar`、`zoneinfo` 和 `time`。让我们从您需要为本节导入的导入开始：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first example deals with dates. Let us see how they look:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子处理日期。让我们看看它们的形状：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We start by fetching the date for today. We can see that it is an instance of
    the `datetime.date` class. Then we get two different representations for it, following
    the **C** and the **ISO 8601** format standards, respectively. After that, we
    ask what day of the week it is, and we get the number 1. Days are numbered 0 to
    6 (representing Monday to Sunday), so we grab the value of the sixth element in
    `calendar.day_name` (notice in the code that we have aliased `calendar` with `cal`
    for brevity).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取今天的日期。我们可以看到它是一个 `datetime.date` 类的实例。然后我们根据 **C** 和 **ISO 8601** 格式标准分别获取它的两种不同表示。之后，我们询问它是星期几，得到数字
    1。天数编号为 0 到 6（代表星期一到星期日），所以我们抓取 `calendar.day_name` 中的第六个元素的值（注意在代码中我们将 `calendar`
    别名为 `cal` 以便简短）。
- en: The last two instructions show how to get detailed information out of a date
    object. We can inspect its `day` , `month` , and `year` attributes, or call the
    `timetuple()` method and get a whole wealth of information. Since we are dealing
    with a date object, notice that all the information about time has been set to
    `0` .
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两条指令展示了如何从日期对象中获取详细信息。我们可以检查其 `day`、`month` 和 `year` 属性，或者调用 `timetuple()`
    方法并获取大量信息。由于我们处理的是日期对象，请注意，所有关于时间的信息都已设置为 `0`。
- en: 'Let us now play with time:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在玩玩时间：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This example is quite similar to the one before, only here, we are dealing with
    time. We can see how to get a printed representation of time according to the
    C format standard, and then how to check if daylight saving time is in effect.
    The `gmtime` function converts a given number of seconds from the epoch to a `struct_time`
    object in UTC. If we don’t feed it a number, it will use the current time.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与之前的例子非常相似，只是这次我们处理的是时间。我们可以看到如何根据 C 格式标准获取时间的打印表示，然后检查夏令时是否生效。`gmtime`
    函数将给定的秒数从纪元转换为 UTC 中的 `struct_time` 对象。如果我们不提供数字，它将使用当前时间。
- en: The **epoch** is a date and time from which a computer system measures system
    time. You can see that, on the machine used to run this code, the epoch is January
    1 ^(st) , 1970. This is the point in time used by both Unix and POSIX.Coordinated
    Universal Time or **UTC** is the primary time standard by which the world regulates
    clocks and time.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**纪元**是从计算机系统测量系统时间的日期和时间。你可以看到，在运行此代码的机器上，纪元是 1970 年 1 月 1 日。这是 Unix 和 POSIX
    使用的点时间。协调世界时或**UTC**是世界调节时钟和时间的主要时间标准。'
- en: We finish the example by getting the `struct_time` object for the current local
    time and the number of seconds from the epoch expressed as a float number ( `time.time()`
    ).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过获取当前本地时间的 `struct_time` 对象以及从纪元以来表示为浮点数的秒数（`time.time()`）来完成这个例子。
- en: Let us now see an example using `datetime` objects, which combine dates and
    times.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在通过使用 `datetime` 对象的例子来看看，这些对象结合了日期和时间。
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding example is rather self-explanatory. We start by setting up two
    instances that represent the current time. One is related to UTC ( `utcnow` ),
    and the other one is a local representation ( `now` ).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子相当直观。我们首先设置两个实例来表示当前时间。一个是与 UTC 相关的（`utcnow`），另一个是本地表示（`now`）。
- en: You can get `date` , `time` , and specific attributes from a `datetime` object
    in a similar way to what we have already seen. It is also worth noting that `now`
    and `utcnow` have different values for the `tzinfo` attribute. `now` is a **naïve**
    object, while `utcnow` is not.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过与我们已经看到的方式类似的方式从 `datetime` 对象中获取 `date`、`time` 和特定属性。还值得注意的是，`now` 和 `utcnow`
    对于 `tzinfo` 属性有不同的值。`now` 是一个**天真**的对象，而 `utcnow` 则不是。
- en: Date and time objects may be categorized as *aware* if they include time zone
    information, or *naïve* if they don’t.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间对象可以根据它们是否包含时区信息分为**有意识的**或**天真的**。
- en: 'Let us now see how a duration is represented in this context:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看在这个上下文中持续时间是如何表示的：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Two objects have been created that represent Fabrizio and Heinrich’s birthdays.
    This time, in order to show you an alternative, we have created **aware** objects.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 已经创建了两个对象来表示 Fabrizio 和 Heinrich 的生日。这次，为了展示一个替代方案，我们创建了**有意识的**对象。
- en: There are several ways to include time zone information when creating a `datetime`
    object, and in this example, we are showing you two of them. One uses the `ZoneInfo`
    object from the `zoneinfo` module, introduced in Python 3.9. The second one uses
    a simple `timedelta` , an object that represents a duration.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `datetime` 对象时，有几种方法可以包含时区信息，在这个例子中，我们展示了其中两种。一种使用 Python 3.9 中引入的 `zoneinfo`
    模块中的 `ZoneInfo` 对象。第二种使用简单的 `timedelta`，这是一个表示持续时间的对象。
- en: We then create the `diff` object, which is assigned as the subtraction of them.
    The result of that operation is an instance of `timedelta` . You can see how we
    can interrogate the `diff` object to tell us how many days Fabrizio and Heinrich’s
    birthdays are apart, and even the number of seconds that represent that whole
    duration. Notice that we need to use `total_seconds()` , which expresses the whole
    duration in seconds. The `seconds` attribute represents the number of seconds
    assigned to that duration. So, a `timedelta(days=1)` will have seconds equal to
    0 and `total_seconds()` equal to 86,400 (which is the number of seconds in a day).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后创建 `diff` 对象，它被分配为它们的差值。这个操作的结果是一个 `timedelta` 实例。你可以看到我们如何查询 `diff` 对象来告诉我们
    Fabrizio 和 Heinrich 的生日相差多少天，甚至代表整个持续时间的秒数。注意，我们需要使用 `total_seconds()`，它以秒为单位表达整个持续时间。`seconds`
    属性代表分配给该持续时间的秒数。所以，`timedelta(days=1)` 将有 0 秒和 `total_seconds()` 等于 86,400（这是一天中的秒数）。
- en: Combining a `datetime` with a duration adds or subtracts that duration from
    the original date and time information. In the last few lines of the example,
    we can see how adding a duration to a `date` object produces a `date` as a result,
    whereas adding it to a `datetime` produces a `datetime` , as it is fair to expect.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个 `datetime` 与一个持续时间结合会将该持续时间加到或从原始日期和时间信息中减去。在示例的最后几行中，我们可以看到将一个持续时间加到一个
    `date` 对象上会产生一个 `date` 作为结果，而将其加到 `datetime` 上会产生一个 `datetime`，正如我们预期的那样。
- en: 'One of the more difficult undertakings to carry out using dates and times is
    parsing. Let us see a short example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日期和时间执行的一些更具挑战性的任务之一是解析。让我们看一个简短的例子：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We can easily create `datetime` objects from ISO-formatted strings, as well
    as from timestamps. However, in general, parsing a date from unknown formats can
    prove to be a difficult task.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地从 ISO 格式字符串以及从时间戳中创建 `datetime` 对象。然而，通常从未知格式解析日期可能是一项困难的任务。
- en: Third-party libraries
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三方库
- en: 'To finish off this subsection, we would like to mention a few third-party libraries
    that you will very likely come across when dealing with dates and times in your
    code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个子节，我们想提一下一些第三方库，你很可能在处理代码中的日期和时间时遇到它们：
- en: '**dateutil** : Powerful extensions to `datetime` ( [https://dateutil.readthedocs.io/](https://dateutil.readthedocs.io/)
    )'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dateutil**：对 `datetime` 的强大扩展（[https://dateutil.readthedocs.io/](https://dateutil.readthedocs.io/)）'
- en: '**Arrow** : Better dates and times for Python ( [https://arrow.readthedocs.io/](https://arrow.readthedocs.io/)
    )'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Arrow**：Python 更好的日期和时间（[https://arrow.readthedocs.io/](https://arrow.readthedocs.io/)）'
- en: '**Pendulum** : Python datetimes made easy ( [https://pendulum.eustace.io/](https://pendulum.eustace.io/)
    )'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pendulum**：让 Python 日期和时间变得简单（[https://pendulum.eustace.io/](https://pendulum.eustace.io/)）'
- en: '**Maya** : Datetimes for humans ^(TM) ( [https://github.com/kennethreitz/maya](https://github.com/kennethreitz/maya)
    )'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maya**：为人类设计的日期和时间（[https://github.com/kennethreitz/maya](https://github.com/kennethreitz/maya)）'
- en: '**Delorean** : Time Travel Made Easy ( [https://delorean.readthedocs.io/](https://delorean.readthedocs.io/)
    )'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**德尔orean**：让时间旅行变得简单（[https://delorean.readthedocs.io/](https://delorean.readthedocs.io/)）'
- en: '**pytz** : World time zone definitions for Python ( [https://pythonhosted.org/pytz/](https://pythonhosted.org/pytz/)
    )'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pytz**：Python 的世界时区定义（[https://pythonhosted.org/pytz/](https://pythonhosted.org/pytz/)）'
- en: These are some of the most common, and they are worth exploring.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最常见的，它们值得探索。
- en: 'Let us take a look at one final example, this time using the Arrow third-party
    library:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看最后一个例子，这次使用 Arrow 第三方库：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Arrow provides a wrapper around the data structures of the standard library,
    plus a whole set of methods and helpers that simplify the task of dealing with
    dates and times. You can see from this example how easy it is to get the local
    date and time in the Italian time zone ( *Europe/Rome* ), as well as to convert
    it to UTC, or to the Russian or Japanese time zones. The last two instructions
    show how you can get the underlying `datetime` object from an Arrow one, and the
    very useful ISO-formatted representation of a date and time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow 在标准库的数据结构周围提供了一个包装器，以及一套简化处理日期和时间的任务的方法和辅助工具。你可以从这个例子中看到，获取意大利时区（*Europe/Rome*）的本地日期和时间，以及将其转换为
    UTC，或者转换为俄罗斯或日本时区是多么容易。最后两条指令展示了如何从一个 Arrow 对象中获取底层的 `datetime` 对象，以及日期和时间的非常有用的
    ISO 格式表示。
- en: The collections module
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合模块
- en: When Python general-purpose built-in containers ( `tuple` , `list` , `set` ,
    and `dict` ) aren’t enough, we can find specialized container data types in the
    `collections` module. They are described in *Table 2.1* .
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python的通用内置容器（`tuple`、`list`、`set`和`dict`）不足以满足需求时，我们可以在`collections`模块中找到专门的容器数据类型。它们在*表2.1*中描述。
- en: '| **Data type** | **Description** |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **描述** |'
- en: '| `namedtuple()` | Factory function for creating tuple subclasses with named
    fields |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `namedtuple()` | 创建具有命名字段的元组子类的工厂函数 |'
- en: '| `deque` | List-like container with fast appends and pops on either end |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `deque` | 具有在两端快速追加和弹出操作类似列表的容器 |'
- en: '| `ChainMap` | Dictionary-like class for creating a single view of multiple
    mappings |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `ChainMap` | 用于创建多个映射的单个视图的字典类似类 |'
- en: '| `Counter` | Dictionary subclass for counting hashable objects |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `Counter` | 用于计数可哈希对象的字典子类 |'
- en: '| `OrderedDict` | Dictionary subclass with methods that allow for re-ordering
    entries |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `OrderedDict` | 具有允许重新排序条目的方法的字典子类 |'
- en: '| `defaultdict` | Dictionary subclass that calls a factory function to supply
    missing values |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `defaultdict` | 调用工厂函数以提供缺失值的字典子类 |'
- en: '| `UserDict` | Wrapper around dictionary objects for easier dictionary subclassing
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `UserDict` | 用于简化字典子类化的字典对象包装器 |'
- en: '| `UserList` | Wrapper around list objects for easier list subclassing |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `UserList` | 用于简化列表子类化的列表对象包装器 |'
- en: '| `UserString` | Wrapper around string objects for easier string subclassing
    |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `UserString` | 用于简化字符串子类化的字符串对象包装器 |'
- en: 'Table 2.1: Collections module data types'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：collections模块数据类型
- en: There is not enough space here to cover them all, but you can find plenty of
    examples in the official documentation; here, we will just give a small example
    to show you `namedtuple` , `defaultdict` , and `ChainMap` .
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有足够的空间涵盖所有内容，但您可以在官方文档中找到大量示例；在这里，我们只提供一个小的例子来展示`namedtuple`、`defaultdict`和`ChainMap`。
- en: namedtuple
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: namedtuple
- en: A **namedtuple** is a tuple-like object that has fields accessible by attribute
    lookup, as well as being indexable and iterable (it is actually a subclass of
    `tuple` ). This is a compromise between a fully-fledged object and a tuple, and
    it can be useful in those cases where you do not need the full power of a custom
    object but only want your code to be more readable by avoiding positional indexing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**namedtuple**是一个类似于元组的对象，它可以通过属性查找访问字段，同时又是可索引和可迭代的（它实际上是`tuple`的子类）。这是完全成熟的对象和元组之间的折衷方案，在那些不需要自定义对象的全功能但只想通过避免位置索引使代码更易读的用例中可能很有用。'
- en: Another use case is when there is a chance that items in the tuple will need
    to change their position after refactoring, forcing the programmer to also refactor
    all the logic involved, which can be tricky.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是，当元组中的项在重构后可能需要改变其位置时，这会迫使程序员也重构所有相关的逻辑，这可能很棘手。
- en: 'For example, say we are handling data about the left and right eyes of a patient.
    We save one value for the left eye (position 0) and one for the right eye (position
    1) in a regular tuple. Here is how that may look:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在处理有关患者左右眼的数据。我们在这个常规元组中为左眼保存一个值（位置0）和一个值用于右眼（位置1）。以下是它可能的样子：
- en: '[PRE57]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now let us pretend we handle `vision` objects all of the time, and, at some
    point, the designer decides to enhance them by adding information for the combined
    vision, so that a `vision` object stores data in this format *(left eye, combined,
    right eye)* .
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们假设我们一直在处理`vision`对象，在某个时候，设计者决定通过添加关于综合视觉的信息来增强它们，因此`vision`对象以以下格式存储数据（左眼，综合，右眼）。
- en: 'Do you see the trouble we’re in now? We may have a lot of code that depends
    on `vision[0]` being the left eye information (which it still is) and `vision[1]`
    being the right eye information (which is no longer the case). We have to refactor
    our code wherever we handle these objects, changing `vision[1]` to `vision[2]`
    , and that can be painful. We could have probably approached this a bit better
    from the beginning, by using a `namedtuple` . Let us show you what we mean:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在看到我们遇到的问题了吗？我们可能有很多代码依赖于`vision[0]`是左眼信息（它仍然是）和`vision[1]`是右眼信息（这不再是情况）。我们必须在我们的代码中重构处理这些对象的地方，将`vision[1]`改为`vision[2]`，这可能很痛苦。我们可能从一开始就通过使用`namedtuple`来更好地处理这个问题。让我们向您展示我们的意思：
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If, within our code, we refer to the left and right eyes using `vision.left`
    and `vision.right` , all we need to do to fix the new design issue is change our
    factory and the way we create instances—the rest of the code won’t need to change:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的代码中，我们通过 `vision.left` 和 `vision.right` 来引用左右眼睛，要解决新的设计问题，我们只需要更改我们的工厂和创建实例的方式——其余的代码不需要更改：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can see how convenient it is to refer to those values by name rather than
    by position. After all, as a wise man once wrote, *Explicit is better than implicit*
    . This example may be a little extreme; of course, it is not likely that a decent
    programmer would choose to represent data in a simple tuple in the first place,
    but you’d be amazed to know how frequently issues similar to this one occur in
    a professional environment, and how complicated it is to refactor in such cases.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到通过名称而不是位置来引用这些值是多么方便。毕竟，正如一位智者曾经写过的，“明确优于隐晦”。这个例子可能有点极端；当然，一个合格的程序员不太可能一开始就选择用简单的元组来表示数据，但你可能会惊讶地知道，在专业环境中，类似这个问题的情况有多么频繁，以及在这种情况下重构是多么复杂。
- en: defaultdict
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: defaultdict
- en: 'The **defaultdict** data type is one of our favorites. It allows you to avoid
    checking whether a key is in a dictionary by simply inserting it for you on your
    first access attempt, with a default value whose type you pass on creation. In
    some cases, this tool can be very handy and shorten your code a little. Let us
    see a quick example. Say we are updating the value of `age` by adding one year
    to it. If `age` is not there, we assume it was `0` and we update it to `1` :'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**defaultdict** 数据类型是我们最喜欢的之一。它允许你在第一次尝试访问时，通过为你插入键来避免检查键是否在字典中，其类型在创建时指定默认值。在某些情况下，这个工具可以非常方便，并稍微缩短你的代码。让我们看看一个快速示例。假设我们正在通过给
    `age` 添加一年来更新它的值。如果 `age` 不存在，我们假设它是 `0` 并将其更新为 `1`：'
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now let us see how we could further simplify the first part of the code above,
    using a `defaultdict` data type:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `defaultdict` 数据类型进一步简化上述代码的第一部分：
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice how we just need to instruct the `defaultdict` factory that we want an
    `int` number to be used if the key is missing (we will get 0, which is the default
    for the `int` type). Also notice that even though in this example there is no
    gain in the number of lines, there is definitely a gain in readability, which
    is very important. You can also use your own functions to customize what value
    will be assigned to missing keys. To learn more, please refer to the official
    documentation.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只需要指示 `defaultdict` 工厂，如果键缺失，我们希望使用 `int` 类型的数字（我们将得到 `0`，这是 `int` 类型的默认值）。此外，请注意，尽管在这个例子中行数没有增加，但可读性的提升确实是肯定的，这非常重要。你还可以使用自己的函数来自定义分配给缺失键的值。要了解更多信息，请参阅官方文档。
- en: ChainMap
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ChainMap
- en: '**ChainMap** is a useful data type which was introduced in Python 3.3. It behaves
    like a normal dictionary but, according to the Python documentation, *is provided
    for quickly linking a number of mappings so they can be treated as a single unit*
    . This is usually much faster than creating one dictionary and running multiple
    `update` calls on it. `ChainMap` can be used to simulate nested scopes and is
    useful in templating. The underlying mappings are stored in a list. That list
    is public and can be accessed or updated using the `maps` attribute. Lookups search
    the underlying mappings successively until a key is found. By contrast, writes,
    updates, and deletions only operate on the first mapping.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**ChainMap** 是一个在 Python 3.3 中引入的有用数据类型。它表现得像一个普通字典，但根据 Python 文档，它是“为了快速链接多个映射，以便它们可以作为一个单一单元来处理”而提供的。这通常比创建一个字典并在其上运行多个
    `update` 调用要快得多。`ChainMap` 可以用来模拟嵌套作用域，在模板中很有用。底层映射存储在一个列表中。该列表是公开的，可以通过 `maps`
    属性来访问或更新。查找会依次搜索底层映射，直到找到一个键。相比之下，写入、更新和删除仅对第一个映射进行操作。'
- en: 'A very common use case is providing defaults, so let us see an example:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的用例是提供默认值，所以让我们看看一个例子：
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is yet another example of how Python simplifies things for us. You work
    on a `ChainMap` object, configure the first mapping as you want, and when you
    need a complete dictionary with all the defaults as well as the customized items,
    you can just feed the `ChainMap` object to a `dict` constructor. If you have ever
    coded in other languages, such as Java or C++, you probably will be able to appreciate
    how precious this is, and how well Python simplifies some tasks.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是 Python 为我们简化事情的一个例子。你在一个 `ChainMap` 对象上工作，按照你的需求配置第一个映射，当你需要一个包含所有默认值以及自定义项的完整字典时，你只需将
    `ChainMap` 对象传递给 `dict` 构造函数。如果你在其他语言中编写过代码，比如 Java 或 C++，你可能会欣赏这一点，以及 Python
    如何简化一些任务。
- en: Enums
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: Living in the `enum` module, and definitely worth mentioning, are **enumerations**
    . They were introduced in Python 3.4, and we thought it would be a good idea to
    give you an example on them for the sake of completeness.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '活在 `enum` 模块中，并且绝对值得提及的是**枚举**。它们是在 Python 3.4 中引入的，我们认为给出一个关于它们的例子是完整的。 '
- en: The official definition of an enumeration is that it is *a set of symbolic names
    (members) bound to unique, constant values. Within an enumeration, the members
    can be compared by identity, and the enumeration itself can be iterated over*
    .
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的官方定义是：它是一组（成员）符号名称（成员）绑定到唯一的、常量值。在枚举中，成员可以通过身份进行比较，枚举本身也可以迭代。
- en: 'Say you need to represent traffic lights; in your code, you might resort to
    the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要表示交通信号灯；在你的代码中，你可能会使用以下方法：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There’s nothing special about this code. It is something, in fact, that is
    very common to find. But, consider doing this instead:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有什么特别之处。实际上，这是非常常见的一种情况。但是，考虑这样做：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Ignoring for a moment the (relative) complexity of a class definition, you can
    appreciate how advantageous this approach may be. The data structure is much cleaner,
    and the API it provides is much more powerful. We encourage you to check out the
    official documentation to explore all the features you can find in the `enum`
    module. We think it is worth exploring, at least once.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略类定义的（相对）复杂性，你可以欣赏这种方法的潜在优势。数据结构更加清晰，它提供的 API 也更加强大。我们鼓励你查看官方文档，以探索 `enum`
    模块中你可以找到的所有功能。我们认为这值得探索，至少一次。
- en: Final considerations
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终考虑
- en: That is it. Now you have seen a very good proportion of the data structures
    that you will use in Python. We encourage you to experiment further with every
    data type we have seen in this chapter. We also suggest that you skim through
    the official documentation, just to get an idea of what is available to you when
    writing Python. That working knowledge can be quite useful when you find it difficult
    to properly represent data using the most common types.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在你已经看到了你将在 Python 中使用的绝大多数数据结构。我们鼓励你进一步实验本章中我们看到的所有数据类型。我们还建议你快速浏览官方文档，以了解当你用最常见的数据类型表示数据有困难时，你可以利用什么。这种实际知识可能非常有用。
- en: Before we leap into *Chapter 3* , *Conditionals and Iteration* , we would like
    to share some final considerations about some aspects that, to our minds, are
    important and not to be neglected.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳到第 3 章，*条件语句和迭代* 之前，我们想分享一些关于一些我们认为重要且不应被忽视的方面的最终考虑。
- en: Small value caching
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小值缓存
- en: 'While discussing objects at the beginning of this chapter, we saw that when
    we assign a name to an object, Python creates the object, sets its value, and
    then points the name to it. We can assign different names to the same value, and
    we expect different objects to be created, like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头讨论对象时，我们看到了当我们给一个对象命名时，Python 会创建该对象，设置其值，然后将名称指向它。我们可以给同一个值分配不同的名称，我们期望创建不同的对象，就像这样：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the preceding example, `a` and `b` are assigned to two `int` objects, which
    have the same value, but they are not the same object—as you can see, their `id`
    is not the same. Let us try with a smaller value:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`a` 和 `b` 被分配给两个具有相同值的 `int` 对象，但它们不是同一个对象——正如你所看到的，它们的 `id` 并不相同。让我们尝试一个更小的值：
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Uh-oh! This, we didn’t expect! Why are the two objects the same now? We didn’t
    do `a = b = 5` ; we set them up separately. The answer is something called object
    interning.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这，我们没想到！为什么这两个对象现在相同了？我们并没有做 `a = b = 5`；我们分别设置了它们。答案是某种称为对象内部化的东西。
- en: '**Object interning** is a memory optimization technique that is used primarily
    for immutable data types, such as strings and integers in Python. The idea is
    to reuse existing objects instead of creating new ones every time an object with
    the same value is required.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象池化** 是一种内存优化技术，主要用于不可变数据类型，例如 Python 中的字符串和整数。其理念是重用现有对象，而不是每次需要具有相同值的对象时都创建新的对象。'
- en: This can lead to significant memory savings and performance improvements because
    it reduces the load on the garbage collector and speeds up comparisons since they
    can be done by comparing object identities.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以导致显著的内存节省和性能提升，因为它减少了垃圾收集器的负担，并且由于可以通过比较对象身份来执行比较，所以可以加快比较速度。
- en: Everything is handled properly, under the hood, so you do not need to worry,
    but it’s important to know about this feature for those cases where we deal directly
    with IDs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在幕后得到妥善处理，所以你不需要担心，但对于那些直接处理 ID 的情况，了解这个特性是很重要的。
- en: How to choose data structures
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何选择数据结构
- en: As we’ve seen, Python provides you with several built-in data types and, sometimes,
    if you’re not that experienced, choosing the one that serves you best can be tricky,
    especially when it comes to collections. For example, say you have many dictionaries
    to store, each of which represents a customer. Within each customer dictionary,
    there’s a unique identification code with the key `"id"` . In what kind of collection
    would you place them? Well, unless we know more about these customers, it might
    be hard to produce an answer. We need to ask questions. What kind of access do
    we need? What sort of operations do we need to perform on each item? How many
    times? Will the collection change over time? Will we need to modify the customer
    dictionaries in any way? What is going to be the most frequent operation we have
    to perform on the collection?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Python 为你提供了几个内置的数据类型，有时，如果你不是那么有经验，选择最适合你的数据类型可能会很棘手，尤其是在处理集合时。例如，假设你有很多字典要存储，每个字典代表一个客户。在客户字典中，有一个唯一的识别码，键为
    `"id"`。你会在哪种集合中放置它们？好吧，除非我们了解更多关于这些客户的信息，否则可能很难给出答案。我们需要提问。我们需要什么样的访问？我们需要对每个项目执行什么样的操作？需要执行多少次？集合会随时间改变吗？我们需要以任何方式修改客户字典吗？我们将要执行的最频繁的操作是什么？
- en: 'If you can answer those questions, then you will know what to choose. If the
    collection never shrinks or grows (in other words, it won’t need to add/delete
    any customer object after creation) or shuffles, then tuples are a possible choice.
    Otherwise, lists are a good candidate. Every customer dictionary has a unique
    identifier though, so even a dictionary could work. Let us draft these options
    for you:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够回答这些问题，那么你就会知道该选择什么。如果集合永远不会缩小或增长（换句话说，在创建后不需要添加/删除任何客户对象或打乱顺序），那么元组是一个可能的选择。否则，列表是一个更好的选择。不过，每个客户字典都有一个唯一的标识符，所以即使字典也可以工作。让我们为你草拟这些选项：
- en: '[PRE67]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Some customers we have there, right? We probably would not go with the tuple
    option, unless we wanted to highlight that the collection is not going to change
    or to suggest it shouldn’t be modified. We would say that, usually, a list is
    better, as it allows for more flexibility.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们那里有一些客户，对吧？我们可能不会选择元组选项，除非我们想要强调集合不会改变，或者建议它不应该被修改。我们通常会认为列表更好，因为它提供了更多的灵活性。
- en: Another factor to keep in mind is that tuples and lists are ordered collections.
    If you use a set, for example, you would lose the ordering, so you need to know
    if ordering is important in your application.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是元组和列表是有序集合。如果你使用集合，例如，你会失去排序，所以你需要知道排序在你的应用中是否重要。
- en: What about performance? For example, in a list, operations such as insertion
    and membership testing can take *O(n)* time, while they are *O(1)* for a dictionary.
    It is not always possible to use dictionaries though, if we don’t have the guarantee
    that we can uniquely identify each item of the collection by means of one of its
    properties and that the property in question is hashable (so it can be a key in
    `dict` ).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 性能如何？例如，在一个列表中，插入和成员资格测试等操作可能需要 *O(n)* 的时间，而对于字典来说，这些操作只需要 *O(1)* 的时间。然而，如果我们不能保证可以通过集合的一个属性唯一地识别每个项目，并且该属性是可哈希的（因此它可以作为
    `dict` 的键），那么使用字典并不总是可能的。
- en: If you’re wondering what *O* *(n)* and *O(1)* mean, please research **big O
    notation** . In this context, let us just say that if performing an operation
    *Op* on a data structure takes *O(f(n))* , it would mean that *Op* takes at most
    time *t ≤ c * f(n)* to complete, where *c* is some positive constant, *n* is the
    size of the input, and *f* is some function. So, think of *O(...)* as an upper
    bound for the running time of an operation (it can also be used to size other
    measurable quantities, of course).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Another way of understanding whether you have chosen the right data structure
    is by looking at the code you have to write in order to manipulate it. If writing
    the logic comes easily and flows naturally, then you probably have chosen correctly,
    but if you find yourself thinking your code is getting unnecessarily complicated,
    then you may need to reconsider your choices. It is quite hard to give advice
    without a practical case though, so when you choose a data structure for your
    data, try to keep ease of use and performance in mind, and give precedence to
    what matters most in the context you are in.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: About indexing and slicing
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw slicing applied to strings. Slicing,
    in general, applies to a sequence: tuples, lists, strings, and so on. With lists,
    slicing can also be used for assignment, although in practice this technique is
    rarely used—at least in our experience. Dictionaries and sets cannot be sliced,
    of course. Let us discuss indexing a bit more in depth.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one characteristic regarding Python indexing that we haven’t mentioned
    before. We will show you by way of an example. How do you address the last element
    of a collection? Let us see:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If list `a` has 10 elements, then due to the 0-index positioning system of
    Python, the first one is at position 0 and the last one is at position 9. In the
    preceding example, the elements are conveniently placed in a position equal to
    their value: `0` is at position 0, `1` at position 1, and so on.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to fetch the last element, we need to know the length of the whole
    list (or tuple, string, and so on) and then subtract 1, hence `len(a) - 1` . This
    is so common an operation that Python provides you with a way to retrieve elements
    using **negative indexing** . This proves quite useful as it simplifies the code.
    *Figure 2.2* displays a neat diagram about how indexing works on the string `"HelloThere"`
    (which is Obi-Wan Kenobi sarcastically greeting General Grievous in *Star Wars:
    Episode III—Revenge of the Sith* ):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30996_02_02.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Python indexing'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Trying to address indexes greater than 9 or smaller than -10 will raise an `IndexError`
    , as expected.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: About names
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that, in order to keep the examples as short as possible,
    we have named many objects using simple letters, like `a` , `b` , `c` , `d` ,
    and so on. This is perfectly fine when debugging on the console, or showing that
    `a + b == 7` , but it is bad practice when it comes to professional code (or any
    type of code, for that matter). We hope you will indulge us where we have done
    it; the reason is to present the code in a more compact way.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，为了使示例尽可能简短，我们使用简单的字母命名了许多对象，例如 `a`、`b`、`c`、`d` 等等。这在控制台调试或展示 `a + b
    == 7` 这样的表达式时是完全可以接受的，但在编写专业代码（或任何类型的代码）时，这并不是一个好的做法。我们希望你在我们这样做的时候能宽容一些；这样做的原因是为了以更紧凑的方式展示代码。
- en: In a real environment though, when you choose names for your data, you should
    choose them carefully—they should reflect what the data is about. So, if you have
    a collection of `Customer` objects, `customers` is a perfectly good name for it.
    Would `customers_list` , `customers_tuple` , or `customers_collection` work as
    well? Think about it for a second. Is it good to tie the name of the collection
    to the datatype? We do not think so unless there is a compelling reason. The reasoning
    behind this is that once `customers_tuple` starts being used in different parts
    of your code, and you realize you actually want to use a list instead of a tuple,
    you have a name tied to the wrong data type, which means you will have to refactor.
    Names for data should be nouns, and names for functions should be verbs. Names
    should be as expressive as possible. Python is actually a very good example when
    it comes to names. Most of the time, you can just guess what a function is called
    if you know what it does.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际环境中，当你为你的数据选择名称时，你应该仔细选择——它们应该反映数据的内容。所以，如果你有一组 `Customer` 对象，`customers`
    是一个很好的名称。`customers_list`、`customers_tuple` 或 `customers_collection` 也能用吗？思考一下。将集合的名称与数据类型绑定是否合适？我们认为不一定，除非有充分的理由。背后的推理是，一旦
    `customers_tuple` 在代码的不同部分开始被使用，你意识到你实际上想使用列表而不是元组，你将会有一个与错误数据类型绑定的名称，这意味着你将不得不重构。数据名称应该是名词，函数名称应该是动词。名称应该尽可能具有表达性。Python
    在名称方面实际上是一个非常好的例子。大多数时候，如果你知道一个函数的功能，你就可以猜出它的名称。
- en: '*Chapter 2* of the book *Clean Code* by *Robert C. Martin* is entirely dedicated
    to names. It is a great book that helped us improve our coding style in many different
    ways—a must-read, if you want to take your skills to the next level.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 《代码整洁之道》（Clean Code）一书的**第2章**完全致力于名称。这是一本伟大的书，它以许多不同的方式帮助我们改进了编码风格——如果你想要将技能提升到下一个层次，这是一本必读的书。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored Python’s built-in data types. We have seen how
    many there are and how much can be achieved just by using them in different combinations.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Python 的内置数据类型。我们看到了有多少种类型，以及仅通过以不同组合使用它们就能实现多少事情。
- en: We have seen number types, sequences, sets, mappings, dates, times, collections,
    and enumerations. We have also seen that everything is an object and learned the
    difference between mutable and immutable. We also learned about slicing and indexing.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了数字类型、序列、集合、映射、日期、时间、集合和枚举。我们还了解到一切都是对象，并学习了可变和不可变之间的区别。我们还学习了切片和索引。
- en: We presented the cases with simple examples, but there is much more that you
    can learn about this subject, so stick your nose into the official documentation
    and go exploring!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过简单的示例展示了这些情况，但关于这个主题，你还有很多可以学习的内容，所以请深入官方文档去探索！
- en: Most of all, we encourage you to try out all the exercises by yourself—get your
    fingers used to that code, build some muscle memory, and experiment, experiment,
    experiment. Learn what happens when you divide by zero, when you combine different
    number types, and when you work with strings. Play with all data types. Exercise
    them, break them, discover all their methods, enjoy them, and learn them very,
    very well. If your foundation is not rock solid, how good can your code be? Data
    is the foundation for everything; data shapes what dances around it.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们鼓励你自己尝试所有练习——让你的手指习惯那种代码，建立一些肌肉记忆，并实验，实验，再实验。学习当你除以零时会发生什么，当你组合不同的数字类型时会发生什么，以及当你处理字符串时会发生什么。与所有数据类型玩耍。练习它们，破坏它们，发现它们的所有方法，享受它们，并且非常非常熟练地学习它们。如果你的基础不是坚如磐石，你的代码能有多好？数据是一切的基础；数据塑造了围绕它的东西。
- en: The more you progress with the book, the more likely it is that you will find
    some discrepancies or a small typo here and there in our code (or yours). You
    will get an error message or something will break. That is wonderful! When you
    code, things break and you have to debug them, all the time, so consider errors
    as useful exercises to learn something new about the language you’re using, and
    not as failures or problems. Errors will keep coming up, that is certain, so you
    may as well start making your peace with them now.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对这本书的进度越来越深入，你可能会发现我们（或你自己的）代码中存在一些差异或小错误。你可能会收到错误信息，或者某些东西会出问题。那真是太好了！当你编写代码时，事情会出错，你必须调试它们，这是常有的事，所以请把错误视为学习新语言的有用练习，而不是失败或问题。错误会不断出现，这是肯定的，所以你现在就开始学会与它们和平共处吧。
- en: The next chapter is about conditionals and iteration. We will see how to actually
    put collections to use and make decisions based on the data that we are presented
    with. We will start to go a little faster now that your knowledge is building
    up, so make sure you are comfortable with the contents of this chapter before
    you move on to the next one. Once more, have fun, explore, and break things—it
    is a very good way to learn.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍条件和迭代。我们将看到如何实际使用集合并根据我们呈现的数据做出决策。现在你的知识正在积累，我们将开始稍微加快速度，所以在继续下一章之前，请确保你对本章的内容感到舒适。再次提醒，享受乐趣，探索，并打破事物——这是学习的好方法。
- en: Join our community on Discord
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_2.xhtml)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_2.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
