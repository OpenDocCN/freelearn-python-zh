- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Built-In Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”Data! Data! Data!” he cried impatiently. “I can’t make bricks without clay.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Sherlock Holmes, in The Adventure of the Copper Beeches
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Everything you do with a computer is managing data. Data comes in many different
    shapes and flavors. It is the music you listen to, the movies you stream, the
    PDFs you open. Even the source of the chapter you’re reading at this very moment
    is just a file, which is data.
  prefs: []
  type: TYPE_NORMAL
- en: Data can be simple, whether it is an integer number to represent an age, or
    a complex structure, like an order placed on a website. It can be about a single
    object or about a collection of them. Data can even be about data—that is, **metadata**
    . This is data that describes the design of other data structures, or data that
    describes application data or its context. In Python, *objects are an abstraction
    for data* , and Python has an amazing variety of data structures that you can
    use to represent data or combine them to create your own custom data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Python objects’ structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutability and immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Built-in data types: numbers, strings, dates and times, sequences, collections,
    and mapping types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `collections` module, briefly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything is an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve into the specifics, we want you to be very clear about objects
    in Python, so let us talk a little bit more about them. *Everything in Python
    is an object* , and every object has an `identity` ( `ID` ), a `type` , and a
    `value` . But what really happens when you type an instruction like `age = 42`
    in a Python module?
  prefs: []
  type: TYPE_NORMAL
- en: If you go to [https://pythontutor.com/](https://pythontutor.com/) , you can
    type that instruction into a text box and get its visual representation. Keep
    this website in mind; it is very useful to consolidate your understanding of what
    goes on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens is that an **object** is created. It gets an `id` , the `type`
    is set to `int` (integer number), and the `value` to `42` . A name, `age` , is
    placed in the global namespace, pointing to that object. Therefore, whenever we
    are in the global namespace, after the execution of that line, we can retrieve
    that object by simply accessing it through its name: `age` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to move house, you would put all the knives, forks, and spoons
    in a box and label it *cutlery* . This is exactly the same concept. Here is a
    screenshot of what it may look like (you may have to tweak the settings to get
    the same view):'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30996_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – A name pointing to an object
  prefs: []
  type: TYPE_NORMAL
- en: So, for the rest of this chapter, whenever you read something such as `name
    = some_value` , think of a name placed in the namespace that is tied to the scope
    in which the instruction was written, with a nice arrow pointing to an object
    that has an *id* , a *type* , and a *value* . There is a little bit more to say
    about this mechanism, but it is much easier to talk about it using an example,
    so we will come back to this later.
  prefs: []
  type: TYPE_NORMAL
- en: Mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first fundamental distinction that Python makes about data is whether the
    value of an object can change. If the value can change, the object is called **mutable**
    , otherwise the object is called **immutable** .
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important that you understand the distinction between mutable and immutable
    because it affects the code you write. Let us look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, on line `#A` , have we changed the value of `age` ?
    Well, no. But now it is `43` (we hear you say...). Yes, it is `43` , but `42`
    was an integer number, of the type *int* , which is immutable. So, what happened
    is really that on the first line, `age` is a name that is set to point to an *int*
    object, whose value is `42` . When we type `age = 43` , what happens is that another
    *int* object is created, with the value `43` (also, the *id* will be different),
    and the name `age` is set to point to it. So, in fact, we did not change `42`
    to `43` —we just pointed the name `age` to a different location, which is the
    new *int* object whose value is `43` . Let us see the IDs of the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we call the built-in `id()` function to print the IDs. As you can
    see, they are different, as expected. Bear in mind that `age` points to one object
    at a time: `42` first, then `43` —never together.'
  prefs: []
  type: TYPE_NORMAL
- en: If you reproduce these examples on your computer, you will notice that the IDs
    you get will be different. This is of course expected, as they are generated randomly
    by Python and will be different every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us see the same example using a mutable object. For this example,
    we will use the built-in `set` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we set up an object, `numbers` , which represents a mathematical
    set. We can see its `id` being printed and the fact that it is empty ( `set()`
    ), right after creation. We then proceed to add two numbers to it: `3` and `7`
    . We print the `id` again (which shows it is the same object) and its value, which
    now shows it contains the two numbers. So the object’s value has changed, but
    its `id` is still the same. This shows the typical behavior of a mutable object.
    We will explore sets in more detail later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Mutability is a very important concept. We will remind you about it throughout
    the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us start by exploring Python’s built-in data types for numbers. Python was
    designed by a man with a master’s degree in mathematics and computer science,
    so it is only logical that it has extensive support for numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers are immutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python integers have an unlimited range, subject only to the available virtual
    memory. This means that it doesn’t really matter how big the number you want to
    store is—as long as it can fit in your computer’s memory, Python will take care
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer numbers can be positive, negative, or 0 (zero). Their type is *int*
    . They support all the basic mathematical operations, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should be easy to understand. Just notice one important
    thing: Python has two division operators, one performs the so-called **true division**
    ( `/` ), which returns the quotient of the operands, and another one, the so-called
    **integer division** ( `//` ), which returns the *floored* quotient of the operands.'
  prefs: []
  type: TYPE_NORMAL
- en: As historical information, in Python 2, the division operator `/` behaves differently
    than in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how division behaves differently when we introduce negative numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an interesting example. If you were expecting `-1` on the last line,
    don’t feel bad, it is just the way Python works. Integer division in Python is
    *always rounded toward minus infinity* . If, instead of flooring, you want to
    truncate a number to an integer, you can use the built-in `int()` function, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the truncation is done toward 0 instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `int()` function can also return integer numbers from string representation
    in a given base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth noting that the power operator, `**` , also has a built-in function
    counterpart, `pow()` , shown in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an operator to calculate the remainder of a division. It is called
    the **modulo operator** , and it is represented by a percentage symbol ( `%` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `pow()` function allows a third argument to perform **modular exponentiation**
    .
  prefs: []
  type: TYPE_NORMAL
- en: The form with three arguments also accepts a negative exponent in the case where
    the base is relatively prime to the modulus. The result is the **modular multiplicative
    inverse** of the base (or a suitable power of that, when the exponent is negative,
    but not -1), modulo the third argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'One nice feature introduced in Python 3.6 is the ability to add underscores
    within number literals (between digits or base specifiers, but not leading or
    trailing). The purpose is to help make some numbers more readable, such as `1_000_000_000`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Boolean** algebra is that subset of algebra in which the values of the variables
    are the truth values, *true* and *false* . In Python, `True` and `False` are two
    keywords that are used to represent truth values. Booleans are a subclass of integers,
    so `True` and `False` behave respectively like `1` and `0` . The equivalent of
    the *int* type for Booleans is the *bool* type, which returns either `True` or
    `False` . Every built-in Python object has a value in the Boolean context, which
    means they evaluate to either `True` or `False` when fed to the `bool` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean values can be combined in Boolean expressions using the logical operators
    `and` , `or` , and `not` . Let us see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Booleans are most used in conditional programming, which we will discuss in
    detail in *Chapter 3* , *Conditionals and Iteration.*
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that `True` and `False` are subclasses of integers when you try
    to add them. Python upcasts them to integers and performs the addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Upcasting** is a type conversion operation that goes from a subclass to its
    parent. In this example, `True` and `False` , which belong to a class derived
    from the integer class, are converted back to integers when needed. This topic
    is about inheritance and will be explained in detail in *Chapter 6* , *OOP, Decorators,
    and Iterators* .'
  prefs: []
  type: TYPE_NORMAL
- en: Real numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Real numbers, or **floating point numbers** , are represented in Python according
    to the **IEEE 754** double-precision binary floating point format, which stores
    them in 64 bits of information divided into three sections: sign, exponent, and
    mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quench your thirst for knowledge about this format on Wikipedia: [http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several programming languages offer two different formats: single and double
    precision. The former takes up 32 bits of memory, the latter 64. Python supports
    only the double format. Let us see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the calculation of the area, we wrapped the `radius ** 2` within parentheses.
    Even though that wasn’t necessary because the power operator has higher precedence
    than the multiplication one, we think the formula reads more easily like that.
    Moreover, should you get a slightly different result for the area, don’t worry.
    It might depend on your OS, how Python was compiled, and so on. As long as the
    first few decimal digits are correct, you know it is the correct result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sys.float_info` sequence holds information about how floating point numbers
    will behave on your system. This is an example of what you might see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us make a few considerations here: we have 64 bits to represent floating
    point numbers. This means we can represent at most *2* ^(64) (that is *18,446,744,073,709,551,616*
    ) distinct numbers. Take a look at the `max` and `epsilon` values for floating
    point numbers, and you will realize that it is impossible to represent them all.
    There is just not enough space, so they are approximated to the closest representable
    number. You probably think that only extremely big or extremely small numbers
    suffer from this issue. If so, the next example will surprise you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What does this tell you? It tells you that double precision numbers suffer from
    approximation issues even when it comes to simple numbers like 0.1 or 0.3. Why
    is this important? It can be a big problem if you are handling prices, financial
    calculations, or any kind of data that requires precision. Don’t worry, Python
    gives you the **Decimal** type, which doesn’t suffer from these issues; we’ll
    look at that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python supports **complex numbers** out of the box. If you do not know what
    complex numbers are, they are numbers that can be expressed in the form *a + ib*
    , where *a* and *b* are real numbers, and *i* (or *j* , if you use the engineering
    notation) is the imaginary unit; that is, the square root of *-1* . *a* and *b*
    are called, respectively, the *real* and *imaginary* parts of the number.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is perhaps unlikely that you will use them, but nevertheless, let us see
    a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Fractions and decimals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us finish the tour of the number department with a look at fractions and
    decimals. Fractions hold a rational numerator and denominator in their lowest
    forms. Let us see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `as_integer_ratio()` method has also been added to integers and Booleans.
    This is helpful, as it allows you to use it without needing to worry about what
    type of number is being worked with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than passing the numerator and denominator, fractions can also be initialized
    by passing strings, decimals, floats, and of course fractions. Let us see an example
    with floats and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Although `Fraction` objects can be very useful at times, it is not that common
    to spot them in commercial software. Instead, it is much more common to see decimal
    numbers being used in all those contexts where precision is everything, for example,
    in scientific and financial calculations.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that arbitrary precision decimal numbers come at
    a price in terms of performance, of course. The amount of data to be stored for
    each number is greater than it is for fractions or floats. The way they are handled
    also requires the Python interpreter to work harder behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see a quick example with decimal numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we construct a decimal number from a float, it takes on all
    the approximation issues a float may come with. On the other hand, when we create
    a `decimal` from an `integer` or a `string` representation of a number, then the
    `decimal` will have no approximation issues, and therefore no quirky behavior.
    When it comes to currency or situations in which precision is of utmost importance,
    use decimals.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our introduction to built-in numeric types. Let us now look at
    sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us explore immutable sequences: strings, tuples, and bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings and bytes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Textual data in Python is handled with **str** objects, more commonly known
    as **strings** . They are immutable sequences of **Unicode code points** .
  prefs: []
  type: TYPE_NORMAL
- en: Unicode code points are the numbers assigned to each character in the Unicode
    standard, which is a universal character encoding scheme used to represent text
    in computers. The Unicode standard provides a unique number for every character,
    regardless of the platform, program, or language, thereby enabling the consistent
    representation and manipulation of text across different systems. Unicode covers
    a wide range of characters, including letters from the Latin alphabet, ideographs
    from Chinese, Japanese, and Korean writing systems, symbols, emojis, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other languages, Python does not have a **char** type, so a single character
    is represented by a string of length 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unicode should be used for the internals of any application. When it comes
    to storing textual data though, or sending it on the network, you will usually
    need to encode it, using an appropriate encoding for the medium you are using.
    The result of an encoding produces a **bytes** object, whose syntax and behavior
    are similar to that of strings. String literals are written in Python using single,
    double, or triple quotes (either single or double). If built with triple quotes,
    a string can span multiple lines. An example will clarify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In `#A` and `#B` , we print `str4` , first implicitly, and then explicitly,
    using the `print()` function. A good exercise would be to find out why they are
    different. Are you up to the challenge? (Hint: look up the `str()` and `repr()`
    functions.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings, like any sequence, have a length. You can get this by calling the
    `len()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Python 3.9 has introduced two new methods that deal with the prefixes and suffixes
    of strings. Here’s an example that explains the way they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The nice thing about them is shown by the last instruction: when we attempt
    to remove a prefix or suffix that is not there, the method simply returns a copy
    of the original string. Behind the scenes, these methods check if the string has
    a prefix or suffix that matches the argument of the call, and if that is the case,
    they remove it.'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding and decoding strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the `encode/decode` methods, we can encode Unicode strings and decode
    bytes objects. **UTF-8** is a variable-length **character encoding** , capable
    of encoding all possible Unicode code points. It is the most widely used encoding
    for the web. Also notice that by adding the literal `b` in front of a string declaration,
    we are creating a `bytes` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and slicing strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When manipulating sequences, it is very common to access them at one precise
    position ( **indexing** ) or to get a sub-sequence out of them ( **slicing** ).
    When dealing with immutable sequences, both operations are read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'While indexing comes in one form—zero-based access to any position within the
    sequence—slicing comes in different forms. When you get a slice of a sequence,
    you can specify the *start* and *stop* positions, along with the *step* . They
    are separated with a colon ( `:` ) like this: `my_sequence[start:stop:step]` .
    All the arguments are optional; `start` is inclusive, and `stop` is exclusive.
    It is probably better to see an example, rather than trying to explain them any
    further with words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line is quite interesting. If you don’t specify any of the parameters,
    Python will fill in the defaults for you. In this case, *start* will be the start
    of the string, *stop* will be the end of the string, and *step* will be the default:
    1. This is an easy and quick way of obtaining a copy of the string `s` (the same
    value, but a different object). Can you think of a way to get the reversed copy
    of a string using slicing (do not look it up—find it for yourself)?'
  prefs: []
  type: TYPE_NORMAL
- en: String formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One useful feature of strings is that they can be used as templates. This means
    that they can contain placeholders that can be replaced by arbitrary values using
    formatting operations. There are several ways of formatting a string. For the
    full list of possibilities, we encourage you to look up the documentation. Here
    are some common examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, you can see four different ways of formatting strings.
    The first one, which relies on the `%` operator, can lead to unexpected errors
    and should be used with care. A more modern way to format a string is by using
    the `format()` string method. You can see, from the different examples, that a
    pair of curly braces acts as a placeholder within the string. When we call `format()`
    , we feed it data that replaces the placeholders. We can specify indexes (and
    much more) within the curly braces, and even names, which implies we must call
    `format()` using keyword arguments instead of positional ones.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how `greet_positional_idx` is rendered differently by feeding different
    data to the call to `format` .
  prefs: []
  type: TYPE_NORMAL
- en: 'One feature we want to show you was added to Python in version 3.6, and it
    is called **formatted string literals** . This feature is quite cool (and it is
    faster than using the `format()` method): strings are prefixed with `f` , and
    contain replacement fields surrounded by curly braces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replacement fields are expressions evaluated at runtime, and then formatted
    using the format protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting addition to f-strings, which was introduced in Python 3.8, is
    the ability to add an equal sign specifier within the f-string clause; this causes
    the expression to expand to the text of the expression, an equal sign, then the
    representation of the evaluated expression. This is great for self-documenting
    and debugging purposes. Here’s an example that shows the difference in behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In version 3.12, the f-string syntactic formalization has been upgraded with
    a few features, which are outlined in PEP 701 ( [https://peps.python.org/pep-0701/](https://peps.python.org/pep-0701/)
    ). One of these features is quote reuse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we have reused double quotes within the curly braces, and this hasn’t
    broken our code. Here we are using the `join()` method of the string `","` to
    join together the strings from the `languages` list using a comma and a space.
    In previous versions of Python, we would have had to delimit the string inside
    the curly braces using single quotes: `'', ''` .'
  prefs: []
  type: TYPE_NORMAL
- en: Another feature is the ability to write multiline expressions and comments,
    and also to use backslashes ( `\` ), which wasn’t allowed before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Check out the official documentation to learn everything about string formatting
    and how powerful it can be.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last immutable sequence type we are going to look at here is the **tuple**
    . A tuple is a sequence of arbitrary Python objects. In a tuple declaration, items
    are separated by commas. Tuples are used everywhere in Python. They allow patterns
    that are quite hard to reproduce in other languages. Sometimes tuples are used
    without parentheses; for example, to set up multiple variables on one line, or
    to allow a function to return multiple objects (in several languages, it is common
    for functions to only be able to return one object), and in the Python console,
    tuples can be used implicitly to print multiple elements with one single instruction.
    We will see examples for all these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We use the `in` operator to check whether a value is a member of a tuple. This
    membership operator can also be used with lists, strings, and dictionaries, and
    with collection and sequence objects, in general.
  prefs: []
  type: TYPE_NORMAL
- en: To create a tuple with one item, we need to put a comma after the item. The
    reason is that, without the comma, that item is wrapped in braces on its own,
    in what can be considered a redundant expression. Notice also that, on assignment,
    braces are optional, so `my_tuple = 1, 2, 3` is the same as `my_tuple = (1, 2,
    3)` .
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that tuple assignment allows us to do is *one-line swaps* , with
    no need for a third temporary variable. Let us first see the traditional way of
    doing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us see how we would do it in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Look at the line that shows you the Pythonic way of swapping two values. Do
    you remember what we wrote in *Chapter 1* , *A Gentle Introduction to Python*
    ? A Python program is typically one-fifth to one-third the size of equivalent
    Java or C++ code and features like one-line swaps contribute to this. Python is
    elegant, where elegance in this context also means economy.
  prefs: []
  type: TYPE_NORMAL
- en: Because they are immutable, tuples can be used as keys for dictionaries (we
    will see this shortly). To us, tuples are Python’s built-in data that most closely
    represent a mathematical vector. This does not mean that this was the reason for
    which they were created, though. Tuples usually contain a heterogeneous sequence
    of elements while, on the other hand, lists are, most of the time, homogeneous.
    Moreover, tuples are normally accessed via unpacking or indexing, while lists
    are usually iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mutable sequences** differ from their immutable counterparts in that they
    can be changed after creation. There are two mutable sequence types in Python:
    **lists** and **bytearrays** .'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python lists are similar to tuples, but they do not have the restrictions of
    immutability. Lists are commonly used for storing collections of homogeneous objects,
    but there is nothing preventing you from storing heterogeneous collections as
    well. Lists can be created in many different ways. Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we showed you how to create a list using various techniques.
    We would like you to take a good look at the line with the comment *Python is
    magic* , which we do not expect you to fully understand at this point—especially
    if you are unfamiliar with Python. That is called a **list comprehension** : a
    powerful functional feature of Python, which we will see in detail in *Chapter
    5* , *Comprehensions and Generators* . We just wanted to spark your curiosity
    at this point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating lists is good, but the real fun begins when we use them, so let us
    see the main methods they offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives you a roundup of a list’s main methods. We want to
    show you how powerful they are using the `extend()` method as an example. You
    can extend lists using any sequence type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us see some common operations you can do with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice how easily we can perform the sum and the product of all values in a
    list. The `prod() function` , from the `math` module, is just one of the many
    additions introduced in Python 3.8. Even if you do not plan to use it that often,
    it is a good idea to check out the `math` module and be familiar with its functions,
    as they can be quite helpful.
  prefs: []
  type: TYPE_NORMAL
- en: The last two lines in the preceding code are also quite interesting, as they
    introduce us to a concept called **operator overloading** . In short, this means
    that operators, such as `+` , `-` , `*` , `%` , and so on, may represent different
    operations according to the context they are used in. It does not make any sense
    to sum two lists, right? Therefore, the `+` sign is used to concatenate them.
    Hence, the `*` sign is used to concatenate the list to itself a number of times
    specified by the right operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us take a step further and see something a little more interesting.
    We want to show you how powerful the `sorted` method can be and how easy it is
    in Python to achieve results that may require a great deal of effort in other
    languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code deserves a little explanation. Note that, `a` is a list
    of tuples. This means each element in `a` is a tuple (a 2-tuple in this case).
    When we call `sorted(my_list)` , we get a sorted version of `my_list` . In this
    case, the sorting on a 2-tuple works by sorting them on the first item in the
    tuple, and on the second when the first one is the same. You can see this behavior
    in the result of `sorted(a)` , which yields `[(1, 2), (1, 3), ...]` . Python also
    gives us the ability to control which element(s) of the tuple the sorting must
    be run against. Notice that when we instruct the `sorted` function, to work on
    the first element of each tuple (with `key=itemgetter(0)` ), the result is different:
    `[(1, 3), (1, 2), ...]` . The sorting is done only on the first element of each
    tuple (which is the one at position 0). If we want to replicate the default behavior
    of a simple `sorted(a)` call, we need to use `key=itemgetter(0, 1)` , which tells
    Python to sort first on the elements at position 0 within the tuples, and then
    on those at position 1. Compare the results and you will see that they match.'
  prefs: []
  type: TYPE_NORMAL
- en: For completeness, we included an example of sorting only on the elements at
    position 1, and then again, with the same sorting but in reverse order. If you
    have ever seen sorting in other languages, you should be quite impressed at this
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: The Python sorting algorithm is very powerful, and it was written by Tim Peters
    (the author of *The Zen of Python* ). It is aptly named **Timsort** , and it is
    a blend between **merge** and **insertion sort** and has better time performance
    than most other algorithms used for mainstream programming languages. Timsort
    is a stable sorting algorithm, which means that when multiple records score the
    same in the comparison, their original order is preserved. We have seen this in
    the result of `sorted(a, key=itemgetter(0))` , which yielded `[(1, 3), (1, 2),
    ...]` , in which the order of those two tuples was preserved because they had
    the same value at position 0.
  prefs: []
  type: TYPE_NORMAL
- en: Bytearrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To conclude our overview of mutable sequence types, let us spend a moment on
    the **bytearray** type. Bytearrays are the mutable version of bytes objects. They
    expose most of the usual methods of mutable sequences as well as most of the methods
    of the bytes type. Items in a bytearray are integers in the range [0, 256).
  prefs: []
  type: TYPE_NORMAL
- en: To represent intervals, we are going to use the standard notation for open/closed
    ranges. A square bracket on one end means that the value is included, while a
    round bracket means that it is excluded. The granularity is usually inferred by
    the type of the edge elements so, for example, the interval [3, 7] means all integers
    between 3 and 7, inclusive. On the other hand, (3, 7) means all integers between
    3 and 7, exclusive (4, 5, and 6). Items in a bytearray type are integers between
    0 and 256; 0 is included, 256 is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason that intervals are often expressed like this is to ease coding.
    If we break a range [a, b) into N consecutive ranges, we can easily represent
    the original one as a concatenation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[a,k [1] ) + [k [1] ,k [2] ) + [k [2] ,k [3] ) + ... + [k [N-1] ,b)'
  prefs: []
  type: TYPE_NORMAL
- en: The middle points (k [i] ) being excluded on one end, and included on the other
    end, allows easy concatenation and splitting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see an example with the `bytearray` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are a few ways to create a `bytearray` object. They can
    be useful in many situations; for example, when receiving data through a socket,
    they eliminate the need to concatenate data while polling, hence they can prove
    to be very handy. On line `#A` , we created a `bytearray` named `name` from the
    bytes literal `b'Lina'` to show you how the `bytearray` object exposes methods
    from both sequences and strings, which is extremely handy. If you think about
    it, they can be considered mutable strings.
  prefs: []
  type: TYPE_NORMAL
- en: Set types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python also provides two set types, `set` and `frozenset` . The `set` type is
    mutable, while `frozenset` is immutable. They are unordered collections of immutable
    objects. When printed, they are usually represented as comma-separated values,
    within a pair of curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hashability** is a characteristic that allows an object to be used as a set
    member as well as a key for a dictionary, as we will see very soon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the official documentation ( [https://docs.python.org/3.12/glossary.html#term-hashable](https://docs.python.org/3.12/glossary.html#term-hashable)
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: ”An object is **hashable** if it has a hash value which never changes during
    its lifetime, and can be compared to other objects. […] Hashability makes an object
    usable as a dictionary key and a set member, because these data structures use
    the hash value internally. Most of Python’s immutable built-in objects are hashable;
    mutable containers (such as lists or dictionaries) are not; immutable containers
    (such as tuples and frozensets) are only hashable if their elements are hashable.
    Objects which are instances of user-defined classes are hashable by default. They
    all compare unequal (except with themselves), and their hash value is derived
    from their `id()` .”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Objects that compare equal must have the same hash value. Sets are very commonly
    used to test for membership; let us introduce the `in` operator in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see two ways to create a set. One creates an
    empty set and then adds elements one at a time. The other creates the set using
    a list of numbers as an argument to the constructor, which does all the work for
    us. Of course, you can create a set from a list or tuple (or any iterable) and
    then you can add and remove members from the set as you please.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at **iterable** objects and iteration in the next chapter. For
    now, just know that iterable objects are objects you can iterate on in a direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of creating a set is by simply using the curly braces notation,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we added some duplication to emphasize that the resulting set will not
    have any. Let us see an example using the immutable counterpart of the set type,
    `frozenset` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `frozenset` objects are quite limited with respect to their
    mutable counterpart. They still prove very effective for membership tests, union,
    intersection, and difference operations, and for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapping types: dictionaries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of all the built-in Python data types, the dictionary is easily the most interesting.
    It is the only standard mapping type, and it is the backbone of every Python object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary maps keys to values. Keys need to be hashable objects, while values
    can be of any arbitrary type. Dictionaries are also mutable objects. There are
    quite a few ways to create a dictionary, so let us give you a simple example of
    five ways to create a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: All these dictionaries map the key `A` to the value `1` , and `Z` to the value
    `-1` .
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice those double equals? Assignment is done with one equal, while
    to check whether an object is the same as another one (or five in one go, in this
    case), we use double equals. There is also another way to compare objects, which
    involves the `is` operator, and checks whether the two objects are the same (that
    is, that they have the same ID, not just the same value), but unless you have
    a good reason to use it, you should use the double equals instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we also used one nice function: `zip()` . It is named
    after the real-life zip, which glues together two parts, taking one element from
    each part at a time. Let us show you an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have created the same list in two different ways,
    one more explicit, and the other a little bit more Pythonic. Forget for a moment
    that we had to wrap the `list()` constructor around the `zip()` call (the reason
    is `zip()` returns an iterator, not a `list` , so if we want to see the result,
    we need to exhaust that iterator into something—a list in this case), and concentrate
    on the result. See how `zip()` has coupled the first elements of its two arguments
    together, then the second ones, then the third ones, and so on?
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the zip of a suitcase, a purse, or the cover of a pillow, and
    you will see it works exactly like the one in Python. But let us go back to dictionaries
    and see how many useful methods they expose for allowing us to manipulate them
    as we want. Let us start with the basic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice how accessing keys of a dictionary, regardless of the type of operation
    we are performing, is done using square brackets. Do you remember strings, lists,
    and tuples? We were accessing elements at some position through square brackets
    as well, which is yet another example of Python’s consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now look at three special objects called **dictionary views** : `keys`
    , `values` , and `items` . These objects provide a dynamic view of the dictionary
    entries. They change when the dictionary changes. `keys()` returns all the keys
    in the dictionary, `values()` returns all the values in the dictionary, and `items()`
    returns all the *(key, value)* pairs in the dictionary, as a list of 2-tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us exercise all this with some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things to note here. First, notice how we are creating a dictionary
    by iterating over the zipped version of the string `'hello'` and the numbers `0,
    1, 2, 3, 4` . The string `'hello'` has two `'l'` characters inside, and they are
    paired up with the values 2 and 3 by the `zip()` function. Notice how in the dictionary,
    the second occurrence of the `'l'` key (the one with the value 3), overwrites
    the first one (the one with the value 2). This is because every key in a dictionary
    must be unique. Another thing to notice is that when asking for any view, the
    original order in which items were added is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how these views are fundamental tools when we discuss iterating
    over collections. For now, let us look at some other useful methods exposed by
    Python’s dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'All these methods are quite simple to understand, but it is worth talking about
    that `None` for a moment. Every function in Python returns `None` unless the `return`
    statement is explicitly used to return something else. We will see this in depth
    when we explore functions in *Chapter 4* , *Functions, the Building Blocks of
    Code* . `None` is frequently used to represent the absence of a value, and it
    is quite commonly used as a default value for arguments in function declarations.
    Inexperienced coders may sometimes write functions that return either `False`
    or `None` . Both `False` and `None` evaluate to `False` in a Boolean context,
    so it may seem that there is not much difference between them. But actually, we
    would argue that there is an important difference: `False` means that we have
    information, and the information we have is `False` .'
  prefs: []
  type: TYPE_NORMAL
- en: '`None` means *no information* ; no information is very different from information
    that is `False` . In plain language, if you ask your mechanic *Is my car ready?*
    , there is a big difference between the answer *No, it is not* ( `False` ) and
    *I have no idea* ( `None` ).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last method we really like about dictionaries is `setdefault()` . The `setdefault()`
    method behaves like the `get()` one. When called, it will also set the `key/value`
    pair into the dictionary. Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings us to the end of this tour of dictionaries. Test your knowledge
    about them by trying to predict what `d` looks like after this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Do not worry if it is not immediately obvious to you. We just want to encourage
    you to experiment with dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 3.9 added a new union operator, available for `dict` objects, which
    was introduced by **PEP 584** . When it comes to applying union to `dict` objects,
    we need to remember that union for them is not commutative. This becomes evident
    when the two `dict` objects we are merging have one or more keys in common. Check
    out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `dict` objects `d` and `e` have the key `'b'` in common. In `d` ,
    the value associated with `'b'` is `'B'` ; whereas, in `e` , it is the number
    8. This means that when we merge the two, with `e` on the righthand side of the
    union operator, `|` , the value in `e` overrides the one in `d` . The opposite
    happens, of course, when we swap the positions of those objects in relation to
    the union operator.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you can also see how the union can be performed by using the
    `**` operator to produce a **dictionary unpacking** . It is worth noting that
    union can also be performed as an augmented assignment operation ( `d |= e` ),
    which works in place. Please refer to PEP 584 for more information about this
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our tour of built-in data types. Before we conclude this chapter,
    we want to take a brief look at other data types provided by the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python provides a variety of specialized data types, such as dates and times,
    container types, and enumerations. There is a whole section in the Python standard
    library titled *Data Types* , which deserves to be explored; it is filled with
    interesting and useful tools for every programmer’s needs. You can find it here:
    [https://docs.python.org/3/library/datatypes.html](https://docs.python.org/3/library/datatypes.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will give you a brief introduction to dates and times, collections,
    and enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: Dates and times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python standard library provides several data types that can be used to
    deal with dates and times. This may seem like a simple topic at first, but time
    zones, daylight saving time, leap years, and other quirks can easily trip up an
    unwary programmer. There are also a huge number of ways to format and localize
    date and time information. This, in turn, makes it challenging to parse dates
    and times. This is probably why it is quite common for professional Python programmers
    to also rely on various third-party libraries to provide some much-needed extra
    power when working with dates and times.
  prefs: []
  type: TYPE_NORMAL
- en: The standard library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will start with the standard library and finish the session with a little
    overview of what is out there in terms of the third-party libraries you can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the standard library, the main modules that are used to handle dates and
    times are `datetime` , `calendar` , `zoneinfo` , and `time` . Let us start with
    the imports you will need for this whole section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The first example deals with dates. Let us see how they look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We start by fetching the date for today. We can see that it is an instance of
    the `datetime.date` class. Then we get two different representations for it, following
    the **C** and the **ISO 8601** format standards, respectively. After that, we
    ask what day of the week it is, and we get the number 1. Days are numbered 0 to
    6 (representing Monday to Sunday), so we grab the value of the sixth element in
    `calendar.day_name` (notice in the code that we have aliased `calendar` with `cal`
    for brevity).
  prefs: []
  type: TYPE_NORMAL
- en: The last two instructions show how to get detailed information out of a date
    object. We can inspect its `day` , `month` , and `year` attributes, or call the
    `timetuple()` method and get a whole wealth of information. Since we are dealing
    with a date object, notice that all the information about time has been set to
    `0` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now play with time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This example is quite similar to the one before, only here, we are dealing with
    time. We can see how to get a printed representation of time according to the
    C format standard, and then how to check if daylight saving time is in effect.
    The `gmtime` function converts a given number of seconds from the epoch to a `struct_time`
    object in UTC. If we don’t feed it a number, it will use the current time.
  prefs: []
  type: TYPE_NORMAL
- en: The **epoch** is a date and time from which a computer system measures system
    time. You can see that, on the machine used to run this code, the epoch is January
    1 ^(st) , 1970. This is the point in time used by both Unix and POSIX.Coordinated
    Universal Time or **UTC** is the primary time standard by which the world regulates
    clocks and time.
  prefs: []
  type: TYPE_NORMAL
- en: We finish the example by getting the `struct_time` object for the current local
    time and the number of seconds from the epoch expressed as a float number ( `time.time()`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Let us now see an example using `datetime` objects, which combine dates and
    times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is rather self-explanatory. We start by setting up two
    instances that represent the current time. One is related to UTC ( `utcnow` ),
    and the other one is a local representation ( `now` ).
  prefs: []
  type: TYPE_NORMAL
- en: You can get `date` , `time` , and specific attributes from a `datetime` object
    in a similar way to what we have already seen. It is also worth noting that `now`
    and `utcnow` have different values for the `tzinfo` attribute. `now` is a **naïve**
    object, while `utcnow` is not.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time objects may be categorized as *aware* if they include time zone
    information, or *naïve* if they don’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see how a duration is represented in this context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Two objects have been created that represent Fabrizio and Heinrich’s birthdays.
    This time, in order to show you an alternative, we have created **aware** objects.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to include time zone information when creating a `datetime`
    object, and in this example, we are showing you two of them. One uses the `ZoneInfo`
    object from the `zoneinfo` module, introduced in Python 3.9. The second one uses
    a simple `timedelta` , an object that represents a duration.
  prefs: []
  type: TYPE_NORMAL
- en: We then create the `diff` object, which is assigned as the subtraction of them.
    The result of that operation is an instance of `timedelta` . You can see how we
    can interrogate the `diff` object to tell us how many days Fabrizio and Heinrich’s
    birthdays are apart, and even the number of seconds that represent that whole
    duration. Notice that we need to use `total_seconds()` , which expresses the whole
    duration in seconds. The `seconds` attribute represents the number of seconds
    assigned to that duration. So, a `timedelta(days=1)` will have seconds equal to
    0 and `total_seconds()` equal to 86,400 (which is the number of seconds in a day).
  prefs: []
  type: TYPE_NORMAL
- en: Combining a `datetime` with a duration adds or subtracts that duration from
    the original date and time information. In the last few lines of the example,
    we can see how adding a duration to a `date` object produces a `date` as a result,
    whereas adding it to a `datetime` produces a `datetime` , as it is fair to expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the more difficult undertakings to carry out using dates and times is
    parsing. Let us see a short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We can easily create `datetime` objects from ISO-formatted strings, as well
    as from timestamps. However, in general, parsing a date from unknown formats can
    prove to be a difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To finish off this subsection, we would like to mention a few third-party libraries
    that you will very likely come across when dealing with dates and times in your
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dateutil** : Powerful extensions to `datetime` ( [https://dateutil.readthedocs.io/](https://dateutil.readthedocs.io/)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arrow** : Better dates and times for Python ( [https://arrow.readthedocs.io/](https://arrow.readthedocs.io/)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pendulum** : Python datetimes made easy ( [https://pendulum.eustace.io/](https://pendulum.eustace.io/)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maya** : Datetimes for humans ^(TM) ( [https://github.com/kennethreitz/maya](https://github.com/kennethreitz/maya)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delorean** : Time Travel Made Easy ( [https://delorean.readthedocs.io/](https://delorean.readthedocs.io/)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pytz** : World time zone definitions for Python ( [https://pythonhosted.org/pytz/](https://pythonhosted.org/pytz/)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the most common, and they are worth exploring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at one final example, this time using the Arrow third-party
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Arrow provides a wrapper around the data structures of the standard library,
    plus a whole set of methods and helpers that simplify the task of dealing with
    dates and times. You can see from this example how easy it is to get the local
    date and time in the Italian time zone ( *Europe/Rome* ), as well as to convert
    it to UTC, or to the Russian or Japanese time zones. The last two instructions
    show how you can get the underlying `datetime` object from an Arrow one, and the
    very useful ISO-formatted representation of a date and time.
  prefs: []
  type: TYPE_NORMAL
- en: The collections module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Python general-purpose built-in containers ( `tuple` , `list` , `set` ,
    and `dict` ) aren’t enough, we can find specialized container data types in the
    `collections` module. They are described in *Table 2.1* .
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `namedtuple()` | Factory function for creating tuple subclasses with named
    fields |'
  prefs: []
  type: TYPE_TB
- en: '| `deque` | List-like container with fast appends and pops on either end |'
  prefs: []
  type: TYPE_TB
- en: '| `ChainMap` | Dictionary-like class for creating a single view of multiple
    mappings |'
  prefs: []
  type: TYPE_TB
- en: '| `Counter` | Dictionary subclass for counting hashable objects |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderedDict` | Dictionary subclass with methods that allow for re-ordering
    entries |'
  prefs: []
  type: TYPE_TB
- en: '| `defaultdict` | Dictionary subclass that calls a factory function to supply
    missing values |'
  prefs: []
  type: TYPE_TB
- en: '| `UserDict` | Wrapper around dictionary objects for easier dictionary subclassing
    |'
  prefs: []
  type: TYPE_TB
- en: '| `UserList` | Wrapper around list objects for easier list subclassing |'
  prefs: []
  type: TYPE_TB
- en: '| `UserString` | Wrapper around string objects for easier string subclassing
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: Collections module data types'
  prefs: []
  type: TYPE_NORMAL
- en: There is not enough space here to cover them all, but you can find plenty of
    examples in the official documentation; here, we will just give a small example
    to show you `namedtuple` , `defaultdict` , and `ChainMap` .
  prefs: []
  type: TYPE_NORMAL
- en: namedtuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **namedtuple** is a tuple-like object that has fields accessible by attribute
    lookup, as well as being indexable and iterable (it is actually a subclass of
    `tuple` ). This is a compromise between a fully-fledged object and a tuple, and
    it can be useful in those cases where you do not need the full power of a custom
    object but only want your code to be more readable by avoiding positional indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is when there is a chance that items in the tuple will need
    to change their position after refactoring, forcing the programmer to also refactor
    all the logic involved, which can be tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we are handling data about the left and right eyes of a patient.
    We save one value for the left eye (position 0) and one for the right eye (position
    1) in a regular tuple. Here is how that may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now let us pretend we handle `vision` objects all of the time, and, at some
    point, the designer decides to enhance them by adding information for the combined
    vision, so that a `vision` object stores data in this format *(left eye, combined,
    right eye)* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you see the trouble we’re in now? We may have a lot of code that depends
    on `vision[0]` being the left eye information (which it still is) and `vision[1]`
    being the right eye information (which is no longer the case). We have to refactor
    our code wherever we handle these objects, changing `vision[1]` to `vision[2]`
    , and that can be painful. We could have probably approached this a bit better
    from the beginning, by using a `namedtuple` . Let us show you what we mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If, within our code, we refer to the left and right eyes using `vision.left`
    and `vision.right` , all we need to do to fix the new design issue is change our
    factory and the way we create instances—the rest of the code won’t need to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You can see how convenient it is to refer to those values by name rather than
    by position. After all, as a wise man once wrote, *Explicit is better than implicit*
    . This example may be a little extreme; of course, it is not likely that a decent
    programmer would choose to represent data in a simple tuple in the first place,
    but you’d be amazed to know how frequently issues similar to this one occur in
    a professional environment, and how complicated it is to refactor in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: defaultdict
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **defaultdict** data type is one of our favorites. It allows you to avoid
    checking whether a key is in a dictionary by simply inserting it for you on your
    first access attempt, with a default value whose type you pass on creation. In
    some cases, this tool can be very handy and shorten your code a little. Let us
    see a quick example. Say we are updating the value of `age` by adding one year
    to it. If `age` is not there, we assume it was `0` and we update it to `1` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us see how we could further simplify the first part of the code above,
    using a `defaultdict` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we just need to instruct the `defaultdict` factory that we want an
    `int` number to be used if the key is missing (we will get 0, which is the default
    for the `int` type). Also notice that even though in this example there is no
    gain in the number of lines, there is definitely a gain in readability, which
    is very important. You can also use your own functions to customize what value
    will be assigned to missing keys. To learn more, please refer to the official
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: ChainMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ChainMap** is a useful data type which was introduced in Python 3.3. It behaves
    like a normal dictionary but, according to the Python documentation, *is provided
    for quickly linking a number of mappings so they can be treated as a single unit*
    . This is usually much faster than creating one dictionary and running multiple
    `update` calls on it. `ChainMap` can be used to simulate nested scopes and is
    useful in templating. The underlying mappings are stored in a list. That list
    is public and can be accessed or updated using the `maps` attribute. Lookups search
    the underlying mappings successively until a key is found. By contrast, writes,
    updates, and deletions only operate on the first mapping.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common use case is providing defaults, so let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is yet another example of how Python simplifies things for us. You work
    on a `ChainMap` object, configure the first mapping as you want, and when you
    need a complete dictionary with all the defaults as well as the customized items,
    you can just feed the `ChainMap` object to a `dict` constructor. If you have ever
    coded in other languages, such as Java or C++, you probably will be able to appreciate
    how precious this is, and how well Python simplifies some tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Living in the `enum` module, and definitely worth mentioning, are **enumerations**
    . They were introduced in Python 3.4, and we thought it would be a good idea to
    give you an example on them for the sake of completeness.
  prefs: []
  type: TYPE_NORMAL
- en: The official definition of an enumeration is that it is *a set of symbolic names
    (members) bound to unique, constant values. Within an enumeration, the members
    can be compared by identity, and the enumeration itself can be iterated over*
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you need to represent traffic lights; in your code, you might resort to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s nothing special about this code. It is something, in fact, that is
    very common to find. But, consider doing this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Ignoring for a moment the (relative) complexity of a class definition, you can
    appreciate how advantageous this approach may be. The data structure is much cleaner,
    and the API it provides is much more powerful. We encourage you to check out the
    official documentation to explore all the features you can find in the `enum`
    module. We think it is worth exploring, at least once.
  prefs: []
  type: TYPE_NORMAL
- en: Final considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That is it. Now you have seen a very good proportion of the data structures
    that you will use in Python. We encourage you to experiment further with every
    data type we have seen in this chapter. We also suggest that you skim through
    the official documentation, just to get an idea of what is available to you when
    writing Python. That working knowledge can be quite useful when you find it difficult
    to properly represent data using the most common types.
  prefs: []
  type: TYPE_NORMAL
- en: Before we leap into *Chapter 3* , *Conditionals and Iteration* , we would like
    to share some final considerations about some aspects that, to our minds, are
    important and not to be neglected.
  prefs: []
  type: TYPE_NORMAL
- en: Small value caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While discussing objects at the beginning of this chapter, we saw that when
    we assign a name to an object, Python creates the object, sets its value, and
    then points the name to it. We can assign different names to the same value, and
    we expect different objects to be created, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `a` and `b` are assigned to two `int` objects, which
    have the same value, but they are not the same object—as you can see, their `id`
    is not the same. Let us try with a smaller value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Uh-oh! This, we didn’t expect! Why are the two objects the same now? We didn’t
    do `a = b = 5` ; we set them up separately. The answer is something called object
    interning.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object interning** is a memory optimization technique that is used primarily
    for immutable data types, such as strings and integers in Python. The idea is
    to reuse existing objects instead of creating new ones every time an object with
    the same value is required.'
  prefs: []
  type: TYPE_NORMAL
- en: This can lead to significant memory savings and performance improvements because
    it reduces the load on the garbage collector and speeds up comparisons since they
    can be done by comparing object identities.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is handled properly, under the hood, so you do not need to worry,
    but it’s important to know about this feature for those cases where we deal directly
    with IDs.
  prefs: []
  type: TYPE_NORMAL
- en: How to choose data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen, Python provides you with several built-in data types and, sometimes,
    if you’re not that experienced, choosing the one that serves you best can be tricky,
    especially when it comes to collections. For example, say you have many dictionaries
    to store, each of which represents a customer. Within each customer dictionary,
    there’s a unique identification code with the key `"id"` . In what kind of collection
    would you place them? Well, unless we know more about these customers, it might
    be hard to produce an answer. We need to ask questions. What kind of access do
    we need? What sort of operations do we need to perform on each item? How many
    times? Will the collection change over time? Will we need to modify the customer
    dictionaries in any way? What is going to be the most frequent operation we have
    to perform on the collection?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can answer those questions, then you will know what to choose. If the
    collection never shrinks or grows (in other words, it won’t need to add/delete
    any customer object after creation) or shuffles, then tuples are a possible choice.
    Otherwise, lists are a good candidate. Every customer dictionary has a unique
    identifier though, so even a dictionary could work. Let us draft these options
    for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Some customers we have there, right? We probably would not go with the tuple
    option, unless we wanted to highlight that the collection is not going to change
    or to suggest it shouldn’t be modified. We would say that, usually, a list is
    better, as it allows for more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Another factor to keep in mind is that tuples and lists are ordered collections.
    If you use a set, for example, you would lose the ordering, so you need to know
    if ordering is important in your application.
  prefs: []
  type: TYPE_NORMAL
- en: What about performance? For example, in a list, operations such as insertion
    and membership testing can take *O(n)* time, while they are *O(1)* for a dictionary.
    It is not always possible to use dictionaries though, if we don’t have the guarantee
    that we can uniquely identify each item of the collection by means of one of its
    properties and that the property in question is hashable (so it can be a key in
    `dict` ).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering what *O* *(n)* and *O(1)* mean, please research **big O
    notation** . In this context, let us just say that if performing an operation
    *Op* on a data structure takes *O(f(n))* , it would mean that *Op* takes at most
    time *t ≤ c * f(n)* to complete, where *c* is some positive constant, *n* is the
    size of the input, and *f* is some function. So, think of *O(...)* as an upper
    bound for the running time of an operation (it can also be used to size other
    measurable quantities, of course).
  prefs: []
  type: TYPE_NORMAL
- en: Another way of understanding whether you have chosen the right data structure
    is by looking at the code you have to write in order to manipulate it. If writing
    the logic comes easily and flows naturally, then you probably have chosen correctly,
    but if you find yourself thinking your code is getting unnecessarily complicated,
    then you may need to reconsider your choices. It is quite hard to give advice
    without a practical case though, so when you choose a data structure for your
    data, try to keep ease of use and performance in mind, and give precedence to
    what matters most in the context you are in.
  prefs: []
  type: TYPE_NORMAL
- en: About indexing and slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw slicing applied to strings. Slicing,
    in general, applies to a sequence: tuples, lists, strings, and so on. With lists,
    slicing can also be used for assignment, although in practice this technique is
    rarely used—at least in our experience. Dictionaries and sets cannot be sliced,
    of course. Let us discuss indexing a bit more in depth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one characteristic regarding Python indexing that we haven’t mentioned
    before. We will show you by way of an example. How do you address the last element
    of a collection? Let us see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If list `a` has 10 elements, then due to the 0-index positioning system of
    Python, the first one is at position 0 and the last one is at position 9. In the
    preceding example, the elements are conveniently placed in a position equal to
    their value: `0` is at position 0, `1` at position 1, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to fetch the last element, we need to know the length of the whole
    list (or tuple, string, and so on) and then subtract 1, hence `len(a) - 1` . This
    is so common an operation that Python provides you with a way to retrieve elements
    using **negative indexing** . This proves quite useful as it simplifies the code.
    *Figure 2.2* displays a neat diagram about how indexing works on the string `"HelloThere"`
    (which is Obi-Wan Kenobi sarcastically greeting General Grievous in *Star Wars:
    Episode III—Revenge of the Sith* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30996_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Python indexing'
  prefs: []
  type: TYPE_NORMAL
- en: Trying to address indexes greater than 9 or smaller than -10 will raise an `IndexError`
    , as expected.
  prefs: []
  type: TYPE_NORMAL
- en: About names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that, in order to keep the examples as short as possible,
    we have named many objects using simple letters, like `a` , `b` , `c` , `d` ,
    and so on. This is perfectly fine when debugging on the console, or showing that
    `a + b == 7` , but it is bad practice when it comes to professional code (or any
    type of code, for that matter). We hope you will indulge us where we have done
    it; the reason is to present the code in a more compact way.
  prefs: []
  type: TYPE_NORMAL
- en: In a real environment though, when you choose names for your data, you should
    choose them carefully—they should reflect what the data is about. So, if you have
    a collection of `Customer` objects, `customers` is a perfectly good name for it.
    Would `customers_list` , `customers_tuple` , or `customers_collection` work as
    well? Think about it for a second. Is it good to tie the name of the collection
    to the datatype? We do not think so unless there is a compelling reason. The reasoning
    behind this is that once `customers_tuple` starts being used in different parts
    of your code, and you realize you actually want to use a list instead of a tuple,
    you have a name tied to the wrong data type, which means you will have to refactor.
    Names for data should be nouns, and names for functions should be verbs. Names
    should be as expressive as possible. Python is actually a very good example when
    it comes to names. Most of the time, you can just guess what a function is called
    if you know what it does.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 2* of the book *Clean Code* by *Robert C. Martin* is entirely dedicated
    to names. It is a great book that helped us improve our coding style in many different
    ways—a must-read, if you want to take your skills to the next level.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored Python’s built-in data types. We have seen how
    many there are and how much can be achieved just by using them in different combinations.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen number types, sequences, sets, mappings, dates, times, collections,
    and enumerations. We have also seen that everything is an object and learned the
    difference between mutable and immutable. We also learned about slicing and indexing.
  prefs: []
  type: TYPE_NORMAL
- en: We presented the cases with simple examples, but there is much more that you
    can learn about this subject, so stick your nose into the official documentation
    and go exploring!
  prefs: []
  type: TYPE_NORMAL
- en: Most of all, we encourage you to try out all the exercises by yourself—get your
    fingers used to that code, build some muscle memory, and experiment, experiment,
    experiment. Learn what happens when you divide by zero, when you combine different
    number types, and when you work with strings. Play with all data types. Exercise
    them, break them, discover all their methods, enjoy them, and learn them very,
    very well. If your foundation is not rock solid, how good can your code be? Data
    is the foundation for everything; data shapes what dances around it.
  prefs: []
  type: TYPE_NORMAL
- en: The more you progress with the book, the more likely it is that you will find
    some discrepancies or a small typo here and there in our code (or yours). You
    will get an error message or something will break. That is wonderful! When you
    code, things break and you have to debug them, all the time, so consider errors
    as useful exercises to learn something new about the language you’re using, and
    not as failures or problems. Errors will keep coming up, that is certain, so you
    may as well start making your peace with them now.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about conditionals and iteration. We will see how to actually
    put collections to use and make decisions based on the data that we are presented
    with. We will start to go a little faster now that your knowledge is building
    up, so make sure you are comfortable with the contents of this chapter before
    you move on to the next one. Once more, have fun, explore, and break things—it
    is a very good way to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_2.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
