- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending the TC1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to expand the functionality of the TC1 simulator
    that we designed in [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091). We also look
    at some of the elements of the design of a simulator, including input/output techniques
    and data validation, and describe how the simulator can display the state of a
    processor as it executes instructions.
  prefs: []
  type: TYPE_NORMAL
- en: TC1 is a compromise. Initially, it was designed to support teaching the basics
    of computer architecture. It is an aid to understanding instruction encoding,
    instruction format trade-offs, the execution of an instruction, addressing modes,
    and the ability to design and implement an instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we look at ways of expanding TC1 by, for example, discussing how new
    instructions can be added. Finally, we deal with a topic that we have omitted
    so far: how to create a computer architecture with variable-length instructions.
    That is, individual instructions can be an integer multiple of the basic word
    length.'
  prefs: []
  type: TYPE_NORMAL
- en: The TC1 CPU simulator executes instructions one by one and prints the contents
    of the registers, program counter, and status flags after each instruction is
    executed. You can use this information to debug assembly-level programs. Often,
    when you look at the data, you find that the results are not what was expected;
    for example, you might want to execute a loop 9 times but execute it 10 times
    because you made an error in testing for the end of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: We have three issues to deal with. The first is displaying the data. How do
    we display the data and how do we format it? Should the contents of a register
    be displayed as a decimal value, a binary string of 1s and 0s, or as hexadecimal
    characters?
  prefs: []
  type: TYPE_NORMAL
- en: Another design issue is whether to store historic data. That is, do we store
    the registers and flags after each instruction has been executed in an array so
    that we can look at values in previous operations?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, how do we proceed? The TC1 simulator executes an instruction every
    time the *Enter* key is pressed. This provides a great way of stepping through
    a program but becomes infeasible when a loop requires 1,000 instructions to be
    executed before you get to the part of the program of interest. We will demonstrate
    how you can leave the single-step mode, execute a batch of instructions, and return
    to the single-step mode.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter07](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Another look at python’s input and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we go into a little more detail about data input and output mechanisms,
    as these topics are so important in the design of a simulator because formatting
    data is all-important to the interpretation of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have another look at input in Python. Inputting data from the keyboard
    is very easy. To input text, you write `x = input()` and that’s it. When this
    statement is encountered, Python waits for your input. You enter the text and
    terminate it with a return (*Enter* key). If you just enter a return without text,
    the value of `x` will be a null string – that is, ' '. The data you input is stored
    in text form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python lets you display a prompt before receiving the input; for example, you
    can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the input is in character form, you must convert numeric values into
    integer form before using them. It’s easy to perform conversions into decimal,
    binary, or hexadecimal, as the following examples show. You just add the number
    base as a second parameter to the `int()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let’s consider a more sophisticated example. We’ll input an instruction such
    as `ADD R3,R7`,`$12FA` and extract the three integers `3`, `7`, and `0x12FA`.
    In this example, a $ prefix indicates a hexadecimal value (a convention used by
    Motorola).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code performs this operation. The input uses a `replace` function
    to convert all commas into spaces. We combine the replace operation with the input
    operation to create compact code. The input is followed by a `split` function
    to convert the string into tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we examine each of the four tokens in turn and extract the parameter
    as an integer (`t1`, `t2`, `t3`, and `t4`). Consider `t4`. The `p[3]` expression
    extracts the `"$12FA"` string. The second index, `[1:]`, extracts all characters
    after the first one to give `"12FA"`. This is still a character string. The final
    operation, int`(p[3]`[1:]`,`16`)`, converts the parameter string in hexadecimal
    form into the integer `4858`. The output produced by a second example, `ADD r3,r7,$1102`,
    was `ADD 3` `7 4354`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve already seen, Python lets you put several equates on a line – for
    example, `a,b,c = p,q,r`. This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This shorthand is useful when dealing with simple equates (usually during an
    initialization process). Some programmers prefer not to use this technique as
    it can reduce program readability. Let’s test the preceding fragment of code.
    We’ve added some `print` statements between the operations so that we can follow
    what’s going on as the code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is next. Note that when we print `t1` to `t4`, the numeric value
    of the hexadecimal operand is given in its decimal form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The next section looks at how we format data such as numbers so that they can
    be made much easier for the reader to understand; for example, sometimes you might
    wish to represent the decimal 42 as `101010` and sometimes as `00101010` or `002A`.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now look more deeply at the ways in which data can be displayed in Python.
    When you are observing the execution of a program, you want to see what has changed
    after each instruction has been executed. A computer’s state is determined by
    the contents of its registers and memory, the program counter, and its status
    bits, plus its memory.
  prefs: []
  type: TYPE_NORMAL
- en: How do we display data? Since data can represent anything you want it to, the
    data in a register has no intrinsic meaning. By convention, CPU simulators represent
    data in hexadecimal form. This is partially because each 16-bit register holds
    4 hexadecimal characters and that provides a rather convenient way for humans
    to handle data (try remembering 16-bit strings of 1s and 0s). Some simulators
    permit binary, hex, or decimal displays, and others allow data to be displayed
    as characters (i.e., the data is assumed to be ASCII-encoded).
  prefs: []
  type: TYPE_NORMAL
- en: As well as choosing the base in which we display numbers, we must choose the
    formatting in order to make it easy to read (e.g., aligning groups of characters).
    Like all high-level computer languages, Python provides ways of formatting printed
    data. And like formatting in most other languages, I am tempted to describe Python’s
    formatting as a bit inelegant.
  prefs: []
  type: TYPE_NORMAL
- en: We do not have the space to do justice to Python’s formatting here. We simply
    provide some examples and enough information for you to modify them.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing we need to print in a simulator is the instruction. That could not
    be simpler because it’s a string. So, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This looks up the string item (instruction) at the `pcOld` address and prints
    it. Since `pc` is modified during an instruction cycle, we print the old value
    at the start of the current cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'But each instruction is going to be of a different length (depending on the
    number of operands), and that means the next item printed on the same line will
    not be vertically aligned. We often need to print the instruction within a predefined
    frame. We can do this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are using the`.format()`method. The `"{:<23}"` expression controls the format.
    The integer `23` is the width of the text in characters. The < symbol indicates
    that the string is left-justified. If we’d wanted it right-justified, we would
    have used >. The value following `format()` is the string to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to display the eight registers on the same line, each as a
    six-character hexadecimal value. First, consider the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, this code prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We set up a variable, `z`, for the `0x4ace` hexadecimal value and use `print("%06x"
    %z)` to display it as hex characters. The printed value is `004ace` because two
    leading zeros have been inserted. The formatting mechanism is `"%06x" %z`. The
    first component, `"`%`06x"`, specifies the format of the six-digit hex value that
    follows. It’s the first % that indicates the formatting. %`z` indicates the value
    to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: The escape character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s `print` mechanism is easy to use; for example, `print('Answer =',a)`
    displays anything in quotes as a literal, and the value of any variables that
    appear in the `print` statement. You can have as many quoted items and variables
    as you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `print` statement also allows formatting by using an *escape character*
    that gives the following character a special meaning. In Python, the escape character
    is `''` `\''`. If the escape is followed by `''n''`, it is equivalent to a new
    line; if the escape is followed by `''t''`, it is equivalent to a tab. Consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how this has been printed on two lines due to `''\n''` and the two values
    tabbed by `''\t''`. You can control the size of the tab, as the following example
    shows. The `expandtabs()` method sets the tab width (number of spaces) to the
    parameter provided. In this case, we have embedded the tab into a string and set
    the tab width to `6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the other escape sequences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\’`     Single quote'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\\`     Backslash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\r`     Enter (return)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b`     Backspace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\f`     Form feed (move to the same spot on the line below)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\xhh`   Hexadecimal character value (e.g., `\x41` would print `A` because
    `0x41` is the ASCII value for A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escaping the escape
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are occasions when you wish to escape the escape character and use the
    backslash as a printable character. In that case, you precede the string to be
    printed with either `r` or `R`. Note the `r` letter goes outside the string quotation
    marks, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `R` to suppress `\n` as a newline command and print
    the actual `\n`. The second `\n` is not preceded by `R` and therefore acts as
    the newline command.
  prefs: []
  type: TYPE_NORMAL
- en: To and from ASCII
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I was lucky enough to be around at the birth of the microprocessor and I built
    a Motorola 6000 microprocessor system from the individual chips (including the
    display). At that time, I did not have any commercial software and I had to convert
    between ASCII characters and their numeric values myself. Life is easier today.
    Python provides two functions that allow you to convert between numeric and ASCII
    values. These are `ord()` and `chr()`. If you write `x = ord('B')`, the value
    of `x` would be its ASCII equivalent, `0x42` or `01000010` in binary. Similarly,
    if you write `y = chr(0x41)`, the value of `y` would be `'A'`.
  prefs: []
  type: TYPE_NORMAL
- en: Binary and hexadecimal strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we look at formatted strings in detail, consider the following simple
    example of console input using the Python interpreter. The text in bold is the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We create an `x` variable equal to `12345` and create a new `y` value that is
    the hex version of `x`. Then, we print it and get the expected result of `0x3039`.
    Next, we create a new variable, `z`, where `z = y + 1`. This generates an error
    message because `y` is a text string and we cannot add the integer `1` to it.
    In the next line, we perform the addition again, but this time, we convert the
    hex string into integer form with `int(y,16)`. Now, we can print `z` as a decimal
    integer or as a hexadecimal string using `print(hex(z))`. In short, Python makes
    it easy to handle decimal, hexadecimal, and binary values, but you must be very
    careful to remember to ensure that you convert between string and integer forms
    where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are dealing with binary numbers, it makes sense to display the output
    of TC1 in binary or hexadecimal formats. Suppose we wish to convert a decimal
    integer value into a *binary* string. Consider the following where we convert
    an integer, `p`, into a binary string and then print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `"{0:b}"` expression is the key to the formatting. It is a string enclosed
    in curly brackets. `0` tells it to print from the first character of the string
    and `b` signifies binary. This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. But what if we want the output to be justified with a fixed
    number of characters – for example, 16? The following demonstrates such formatting
    when we convert 26 and `2033` into binary format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change to the format string is from `"{0:b}"` to `"{0:16b}"`. That
    is, we have inserted the field-width of 16 characters before b. The effect of
    `16` is to define a 16-bit width for the string. The string is padded with spaces
    on the left. The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In a lot of computer texts, it is normal to pad binary and decimal values with
    leading zeros on the left, rather than spaces. We can do this with a small change
    in the format. We insert `0` before the field width – that is, `"{0:0`16`b}"`.
    Now consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives an output where the numbers are displayed in 16 bits and padded
    with leading zeros, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Hexadecimal values are treated in the same way by substituting `x` for `b`
    in the `format` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output. As you can see, it’s analogous to the binary
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can combine both print formats (i.e., binary and hexadecimal),
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We print two numbers, one in a binary format and one in a hexadecimal format.
    In the first case, the number is padded to 16 bits with leading zeros, and in
    the second case, it’s padded to 4 characters with leading zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'We print the result twice. In the second case, prefixes are added to the values
    to indicate the base. If the first number, `xBin`, is binary, we can concatenate
    “`0b`” simply by using a “+” symbol to add `0b` immediately before the binary
    string. The output from this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can generalize the string method format as `"someString".format(<parameter
    list>`. This string method takes the string and inserts parameters into it that
    appear in the parameter list. You have to insert *placeholders* in the form of
    `{a:b}` into the string, which will receive the parameters when the string is
    printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you were printing a table of the powers of integers in the form x,
    x2, x3, x4\. We could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Each parameter placeholder is of the form`{`a`:b}`where the first element,
    a, is the position of the parameter in the list of parameters in the format. The
    second element, `b`, determines how the parameter is printed. In this case, it
    is a number and the letter `d`. The number defines the parameter’s width, and
    `d` indicates that it’s decimal; for example, the last parameter is specified
    as `{`3`:6d}`, which indicates the fourth parameter is a decimal integer taking
    six places. The following demonstrates the output from this fragment of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to demonstrate the versatility of this approach, the next example
    prints the same table of powers but using a different format. As well as decimal,
    we also use binary and hexadecimal. Note that you only have to change b in `{`a`:b}`
    to change the base; for example, `{`6`:x}` tells the `print` statement to print
    the seventh parameter in hexadecimal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note you can write x*x*x, or `x**3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output demonstrates the results of this formatting technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We have repeated the example with a few modifications. It is not necessary
    to give the order of the parameters if they are to be printed sequentially; for
    example, the first parameter specification can be written as `{:2d}` instead of
    `{0:2d}`. We’ve also changed the spacing to demonstrate how the width parameters
    operate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Consider the following examples of the `format` mechanism. Here, we use the
    symbols “`<`, `>`, `^`” to control formatting. In order, these symbols force left
    justification, right justification, and centering within the stated width.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code prints the decimal integer `123` first in decimal form,
    using the three modifiers, and then in binary form using the same three modifiers.
    In each case, we have specified a width of 10 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output generated by this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We are now going to provide three examples of how strings representing numbers
    can be printed. The first demonstrates the formatting of individual numbers in
    integer, hexadecimal, binary, and real forms. The second example shows how we
    can take a list of registers, join them as a single string, and print their values.
    This is very useful in displaying data when stepping through instructions during
    a simulation. The third example demonstrates the successive steps in processing
    a hexadecimal value into the desired format.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – Formatting numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following demonstrates this formatting mechanism, where we print several
    variables and a string. This uses a format specifier such as `%05d`, which means
    five decimal digits with leading zeros, and a placeholder such as `%x`, which
    means print the value of `x` in the format specified by %05d:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This `print` statement displays the following (note hexadecimal appears in
    lowercase):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Example 2 – Printing a list of register values in hexadecimal form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following expression with an 8-register array filled with data
    in various formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression prints the string ‘`Registers =`’`,` followed by a second string
    that contains eight four-character hexadecimal values. To create the second string,
    we use the string `join()` method. The string comprehension iterates over the
    registers applying the formatting structure to each element. That is, it reads
    `r[0]`, converts it into a string format, and then joins it to its left-hand neighbor
    (which is initially an empty string). This is repeated eight times and then that
    string is printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Example 3 – Successively processing a decimal value into the desired hex format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following sequence where we successively process the decimal value
    44,350 until it is displayed in hexadecimal format in uppercase without the `0x`
    indicator prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We have described, briefly, how numbers can be formatted. Formatting is necessary
    if the printed output is to be read by humans, especially if you are simulating
    a computer where patterns of 1s and 0s are important. There are several ways of
    formatting data, and this section provided only an introduction to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Input validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I will introduce the notion of data validation. Historically,
    some of the major errors involving computers have been caused by a failure to
    check input data. TC1 doesn’t perform source data checking; you can write `ADDL
    R1,R2,10` or `ADDL z1,z2,10` with the same result. Why? Because when the assembler
    sees `ADDL`, it looks for three parameters. It takes the first parameter, let’s
    call this `p1`, and reads the register number by `regnum = int(`p1[1:]`)`. Only
    the second and successive characters of `p1` are recorded, and the “R” is ignored.
    You can write `R1` or even `?1`. This makes programming in assembly language easier;
    you can use any letter you want to represent a register. On the other hand, it
    encourages poor programming techniques and increases the dangers associated with
    mistyped input.
  prefs: []
  type: TYPE_NORMAL
- en: Validating data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the TC1 assembler doesn’t perform error-checking on the input, if you
    make an error, it’s likely that the program will crash, leaving you to do your
    own debugging. Good software performs error-checking, which ranges from the simple
    detection of invalid instructions to the exact pinpointing of all errors.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we demonstrate how you can read a line of code and check for several types
    of common errors – for example, invalid opcodes, invalid instruction formats (too
    many or two few operands), typos (typing `T6` instead of `R6`), and registers
    out of range (entering `R9`).
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this section is to show how you can add your own modifications
    to TC1\. A formal way of dealing with the problem would be to construct a grammar
    for the assembly language and then build a parser to determine whether the input
    conforms to that grammar. We are going to take a simpler and more ad hoc approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the current instruction is `x =` ''`ADD r1 r2 r3`'', the `y = x.split(`''
    ''`)` operation converts it into a list of tokens: `y = [`''`ADD`''`,` ''`R1`''`,`
    ''`R2`''`,` ''`R3`''`]`. We can extract the first token with `jj = y[0]`, which
    should be a valid mnemonic (in this example, we are forgetting about any labels).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test to perform is on the validity of the instruction. Assume that
    all mnemonics have been defined in a list or directory called `codes`. All we
    have to do is to look it up in the `codes` directory using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Python keywords are shaded. This expression sets the `error` variable to `1`
    if this instruction is not in the dictionary. Then, we can test `error` and take
    whatever action is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to use the name of the instruction to look up its details,
    and then check whether that instruction requires parameters. Remember that our
    dictionary entries have a two-component tuple, with the first component being
    the instruction’s format (i.e., the number of operands required) and the second
    being the actual operation code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks up the instruction (i.e., `y[0]`) in the dictionary and returns its
    value, which is a tuple, such as `(8:12)`. The first element of the tuple, `form[0]`,
    describes the instruction’s operands and the second is the opcode (which is not
    of interest here). The parameters required by the instruction are determined by
    `form[0]`. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The four bits of the format code represent `rD`, `rS1`, `rs2`, and a literal.
    TC1 instructions have several valid formats; for example, if `opType = 0b`1`00`1
    `= 9`, then the format defines an instruction with a destination register and
    a literal such as `LDRL` R3 25\. We’ve used bold and shading to demonstrate the
    relationship between the bits of the format code and the actual instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code uses an `if…else` to get the length (the number of tokens
    including the opcode) of each instruction. All we then have to do is to count
    the number of tokens in the current instruction and see whether it’s the same
    as the expected value (i.e., the total length). The following code performs this
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We set the error number to `2` or `3` if the number of tokens doesn’t match
    the expected value. After both tests, there is a `continue` statement. The effect
    of `continue` is to drop to the end of the current block and abandon further error-testing
    (because we know this current instruction is in error).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have established a valid instruction and the correct number of operands,
    the next step is to check each operand. An operand must be of the form `R0` to
    `R7` (or a literal).
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the format information to test for each operand in turn. Here, we just
    deal with the first operand, `rD` (the destination register):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this code tests whether the leftmost bit of `format` is 1
    or 0 by ANDing the format code with `0b1000` and testing for `0b1000`. If the
    result is `true`, then we need to check for the first register operand, which
    is the second token – that is, `y[1]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are going to test for three operands, we have created a `syntaxText`
    function that takes the token as a parameter and returns two parameters: `error`
    and `q`. The value of `error` is the error code returned (`0` for no error, and
    `q` is the number of the register). The Python code for the `syntaxTest` function
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Three tests are performed, one for each type of error that we are looking for.
    The first test is to check whether the first character of the token is `'R'` .
    If it is not `'R'` , a return is made with the error code `4`, and the dummy or
    default register number is set to `0`. The second test looks for a numeric value
    for the register (the characters following the `'R'`, which is `token[1:]`). The
    third test checks whether the number is greater than `7` and returns an error
    code if it is. Finally, when the last line is reached, a return is made with the
    error code `0` and the appropriate register number. Note that we don’t need to
    use an `elif` because if an `if` yields `True`, the code is exited via `return()`.
  prefs: []
  type: TYPE_NORMAL
- en: This routine is called up to three times in the event of an instruction having
    a format code of `0b1110` corresponding to a register-to-register operation such
    as `ADD R1 R2 R3`. In this exercise, we do not check the literal. If you wish
    to add that check, it would be necessary to check for an integer in the range
    0 to 65,535 or -32,766 to 32,755 (plus a number beginning with `%` if it’s binary
    or `0x` if it’s hexadecimal).
  prefs: []
  type: TYPE_NORMAL
- en: Using the `continue` statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When testing for errors, do you test for each error in a statement or do you
    stop once you have found an error?
  prefs: []
  type: TYPE_NORMAL
- en: 'The code uses a `continue` statement whenever an error is found to bypass further
    testing. An unfortunate side effect is that `continue` takes you past the end
    of the loop and begins the next iteration; that is, you can’t print the nature
    of the error. The solution is to print any errors found in the previous iteration
    at the start of the loop. Of course, this causes a problem on the first iteration
    because there is no previous error value. That is easily fixed by setting `error`
    to zero before beginning the loop. The following code demonstrates this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this fragment of code, `error` is tested to determine whether an error occurred
    in the previous cycle. If `error` is not `0`, the `printError` function is called
    to print the error number and type. Using a function code to do the printing enhances
    the readability of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for an error-testing routine is given next. This is not intended to
    be a complete program, but a demonstration of the way in which you can extend
    a program to include error-testing on the input data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Checking parameters – using dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next example provides another look at parameter checking. It examines the
    mnemonic and predicate of each instruction and checks whether it represents a
    valid operation. It stops after finding an error. In other words, it will detect
    only one error in `INC R9,R2` even though there are two errors (i.e., too many
    operands and the first operand is out of range).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also expand the use of the Python dictionary. Previously, we tested for
    a valid register operand by checking that the initial character was ‘R’ and that
    this was followed by a number in the range of 0 to 7\. Since there are only eight
    register names (R0 to R7), it’s easy to employ a dictionary in error checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The dictionary, `regSet`, contains the register names (the keys) and the corresponding
    value. Because we do so much register checking, it’s convenient to create a function,
    `regTest`, to perform the check. This function takes two parameters. The first
    is a string, `tokNam`, that gives the register a name, and the second parameter
    is the token being tested – for example, `regTest('rD',predicate[0])`. The reason
    for passing a name to the function is so that the function can print the name
    of the operand in error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function returns two values: an error code and the number of the register.
    If an error is detected, the register value of `0` is returned as a default. The
    function is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Testing for validity is easy. The `if token in regSet:` condition checks whether
    this parameter is in the register set. If it is, we read the value of the register
    from the dictionary and return its value. If the token is not in the register
    set, an error message is printed (using `tokNam` to display the faulty value),
    and an error message number `4` is reported back.
  prefs: []
  type: TYPE_NORMAL
- en: Using `regSet.get(token)` is a little heavy-handed. We do not actually need
    to read the register value. If it is in the set of valid registers, we can use
    `int(token[1])` to extract the register number from the name. The advantage of
    using the dictionary mechanism is that we can amend the code to add new registers
    such as `SP`, `PC`, and so on if we want. We can rename registers or even use
    aliases; for example, if we use the `R7` register as a temporary register, we
    could enter `, {. . . 'R6':6, 'R7':7,` 'T':7`}` and then write either `INC R7`
    or `INC T`.
  prefs: []
  type: TYPE_NORMAL
- en: We have also experimented with a new instruction dictionary. Some of the information
    in the dictionary is redundant because it can be derived from other information
    (e.g., the length can be derived from the format). However, we adopted the following
    system because we may change the program at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous version of the assembler, we used a dictionary in which each
    entry had a key that was a mnemonic and a two-element tuple – for example, `'INC':(8,12)`.
    The first element of the tuple was a format code that expressed the operands required
    by the mnemonic, and the second element was the instruction’s opcode.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are using a four-element tuple to provide the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rD, rS1, rS2, literal` (as before).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Style**: The style describes the class of instruction – for example, mnemonic
    only, mnemonic plus literal, mnemonic plus register plus literal, and so on. There
    is a direct relationship between format and style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Length**: The length gives the number of tokens in the instruction – that
    is, the mnemonic plus its operands. This is equivalent to the number of 1s in
    the format plus 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instruction’s opcode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial processing of an instruction is given by the following code. In
    section 1 (light shading), the mnemonic is read from the input token string (i.e.,
    the first element). That may or may not be followed by additional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The mnemonic is used to access the `codes` dictionary to check whether it’s
    valid. The error code is set to `1` (invalid operation) and a `continue` statement
    forces a drop to the end of the loop (further input testing is not necessary as
    the instruction is not valid).
  prefs: []
  type: TYPE_NORMAL
- en: The code with the light gray background reads the tuple with the four data elements
    associated with the mnemonic and extracts the individual parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three lines beginning with “`if opCode == 1:`” read the operation to determine
    whether the instruction was “`STOP`”. If it was `STOP`, the `sys.exit()` operation
    terminates the program. Note that we have to use `import sys` at the start of
    the program to import the library of system functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The final two blocks in the preceding code fragment with a dark gray background
    perform error-detecting operations. They both get the number of tokens from the
    instruction and then compare that number to the value for this instruction. In
    the first case, an error of `2` indicates too few tokens, and in the second case,
    an error of `3` indicates too many tokens.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have determined that the instruction is valid and has the
    correct number of operands. The next stage is to check the operands. The check
    is performed according to the style of the instruction. There are seven styles.
    Style 1 has no further checking because there is no operand (e.g., for `NOP`).
    We will just look at the checking for style 6, which corresponds to instructions
    with a mnemonic, `rD1`, `rS1`, and a literal such as `ADD R1,R2,25`.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `regTest` function first with the ‘`rD`’ parameter to tell it we
    are testing for the destination register and the `predicate[0]` token, which is
    the first parameter. This returns an error flag and the value of the register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we perform two tests (register `rD` and `rS1`), we must use two error
    names: `e1` for the first and `e2` for the second test. If we used `error` as
    the variable in both cases, a non-error second result would clear the first error.
    The line `if (e1 != 0) or (e2 != 0): error = 4` returns `error` with the appropriate
    error status independent of which register was in error. `continue` at the end
    of this block skips further error checking for this instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the main loop. An instruction is input and then checked for errors.
    As in earlier examples, the instruction is processed for validity first and the
    mnemonic is checked to see whether it is in codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Having looked at input validation, we now look at how we can control the display
    of *useful* information during a simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing and breakpoints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you simulate a computer, you have to show what is happening during the
    simulation. Consequently, you have to answer the following three questions:'
  prefs: []
  type: TYPE_NORMAL
- en: When do you display data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you display the data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do you display?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have completed this section, you will be able to construct your own
    instruction tracing facilities.
  prefs: []
  type: TYPE_NORMAL
- en: CPU simulators execute one instruction at a time. At the end of an instruction,
    the state of the computer (i.e., its registers, status flags, and memory) can
    be displayed. This mode is called *single-stepping*. Every time you hit *Enter*,
    an instruction is executed and the machine’s status is displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping through instructions sequentially, one by one, has limitations. What
    if there’s a 3-instruction loop that clears, say, 1,000 locations in an array?
    Do you expect someone to hit the *Enter* key 3,000 times to trace past this operation?
    We need a means of stepping past the boring bits of a program and jumping to the
    interesting bits – that is, a mechanism that lets us execute some instructions
    as a batch, without having to hit *return* after each instruction has been executed
    or printing the results of that execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we create a variable, `trace`, and then, at the end of the `execute`
    loop, print the appropriate data if `trace` is `1` and jump to the next instruction
    without printing data if `trace =` `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The CPU state is printed after each instruction only if `trace = 1`. How do
    we turn `trace` on and off? Turning `trace` off is easy; all you need do is read
    the keyboard input when single-stepping, and turn `trace` off if a particular
    character or string is entered. However, once `trace` is `0`, we’ve lost control,
    and instructions are executed until the program is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to set up a trace count, with the number of instructions to
    be executed before `trace` is turned on again; for example, entering `T 10`, would
    turn off tracing, execute 10 instructions without displaying anything, and then
    turn tracing on again. Defining a fixed number of instructions to execute is not
    always helpful, as it requires the programmer to count the number of instructions
    to be executed before a point of interest is reached. The programmer may not always
    know that.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution is to turn tracing on when a specific point in the assembly
    language program, called a *breakpoint,* is reached. A breakpoint can be the value
    of the program counter, a label, or a specific instruction. Typically, the value
    of the program counter at which you wish to display machine status is stored in
    a table of breakpoints. Execution continues (without any display) until a breakpoint
    is encountered and the CPU state is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following fragment of Python demonstrates this approach. It is not a computer
    simulator and has only three instructions (`nop`, `test`, and `test1`), which
    do nothing, plus `stop`. The program is intended to demonstrate a possible approach
    to the implementation of single-stepping and breakpoints. At the end of each instruction
    cycle, several choices are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Show the machine status after the execution of this instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait for keyboard input before executing the next cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the machine status at a specific breakpoint (address or instruction)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following code uses different fonts and background shading to highlight
    the various functional parts of the code. The first two sections are the setting
    up and initialization of variables, and (shaded) the main program execution loop.
    This loop does nothing other than step through instructions that are `nop` (no
    operation); `test` and `test1` are just used as markers. The `stop` instruction
    serves to terminate execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, when tracing, we require a second program counter, `pcOld`, because
    `pc` gets incremented during the `fetch` cycle and we need to display it before
    it was modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, `trace` is set to `1`, indicating that we are in a *single-step*
    mode. After displaying the program counter and instruction, the program waits
    for keyboard input. The code that does this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If the input is a return (i.e., `enter`), the loop is terminated by `continue`
    and the next instruction cycle is executed. If you enter `t` followed by an integer
    (e.g., `t 13`), the integer is transferred to the `count` variable and `t` is
    set to `0`. Setting `t` to `0` turns off the single-step mechanism, and instructions
    are executed without printing the machine status or waiting for a keyboard input
    at the end of each cycle. At the end of each cycle, the `count` variable is decremented.
    When `count` becomes `0`, `trace` is set to `1` and the single-step mode is re-entered.
  prefs: []
  type: TYPE_NORMAL
- en: If you enter `b` followed by an integer (e.g., `b 21`), a breakpoint at address
    `21` is recorded in the breakpoint table (a dictionary). You can enter more than
    one breakpoint and it will be saved in the dictionary. Each breakpoint is an address
    in the program being executed. When the program counter reaches that address,
    the system status is displayed. For example, if you were to enter the sequence
    `b 12`, `b 30`, `t 50` (each on a separate line), the simulator would set breakpoints
    at addresses `12` and `30`, and then execute 50 cycles without displaying any
    data. However, if the program counter becomes either `12` or `30` during this
    period, the machine status will be printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can enter an instruction that will be loaded into the `traceCodes`
    table. This behaves exactly like the PC breakpoint. When an instruction that’s
    in the `traceCodes` table is encountered, the machine status is displayed. Thus,
    the simulator provides four modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute instruction step by step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute *n* instructions without displaying system status (the silent mode)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute instructions in silent mode but stop and display if a breakpoint address
    is encountered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute instructions in silent mode but stop and display if a specific opcode
    is encountered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, the program can be extended to more exotic forms of breakpoints
    that take account of register data, memory data, or any combination of events.
    For example, you could permit breakpoints of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Some simulators let you set a breakpoint on a change of instruction flow – that
    is, after any jump, branch, or subroutine call. That’s very useful for tracing
    the execution of a complex program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of a short session with this fragment program.
    Remember that it is intended to be a demonstration of the principles involved,
    rather than an actual working system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to demonstrate how the simulated computer can be extended by
    adding new instructions. We demonstrate what parts of the code have to be modified
    and how you can create new instructions of arbitrary complexity. For example,
    if you were developing a computer to be used primarily for playing chess, you
    could create an instruction, `ROOK R1,R2`, that takes the position of a rook in
    register `R2` and calculates the legal positions it could move to and put them
    in `R1`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have provided a modest set of instructions for TC1\. In this section,
    we show how to add a new instruction to the TC1’s repertoire in order to see what’s
    involved in extending an instruction set. In fact, this is a remarkably straightforward
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to choose a mnemonic and unique opcode and insert them into
    the table of code. We’ve arranged the instruction set to leave some unallocated
    code (e.g., code beginning with `11`). The second step is to write the code to
    interpret the new instruction.
  prefs: []
  type: TYPE_NORMAL
- en: First example – putting two memory locations in ascending order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create an instruction that takes the contents of two consecutive locations
    in memory and puts the largest number in the first location at the lower address
    (i.e., it orders them). This instruction takes a single parameter, a pointer register,
    and reads the numeric value pointed at by the register. We’ll assume that the
    register is `r[i]`. The instruction compares this number with the value stored
    at address `r[i] + 1`, and swaps them if the second number is higher than the
    one at the `r[i]` location. In pseudocode, this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We will call the instruction `ORD` (order numbers) and write it as `ORD r0`.
    The binary code is `1110000 rrr 00…0` (where `rrr` is the 3-bit register field)
    and is assigned to this instruction. `'ORD':(8,112)` is entered in the Python
    dictionary of instructions. The opcode is `112` and the parameter allocation code
    in binary is `1000` (i.e., 8), because the only parameter required is `Rd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new instruction is detected in the execution part of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by the Python version of the preceding pseudocode. We can
    write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'What could be simpler? The following code provides a testbed for the instruction.
    We fill memory with random numbers and then request a memory address. The data
    at that address is exchanged with the data at the next address to create an ordered
    pair. Note that this example does not use global variables: the registers and
    memory are passed to the function as parameters. To simplify testing, it is assumed
    that the memory address is in the `r[0]` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Second example – adding a bit-reversal instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s add a more complicated instruction to the TC1 instruction set. Suppose
    you want to reverse the order of bits in a register so that the binary code `1100111000101001`
    in `r0` becomes `1001010001110011`. Assume that the new instruction is `REV r0`,
    which reverses the 16 bits in `r0` and returns the result in r0.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we reverse bits? Consider the four bits 1101 and assume they are in
    T1 (*see Fig 7.1*). Suppose we shift the bits one place left so that the bit that
    leaves the left-hand end of T1 goes into the right-hand end of T2, and then we
    shift T2 one place to the right. We repeat that operation four times. *Figure
    7**.1* shows what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Shifting one register’s output into a second register’s input
    to reverse a string](img/Figure_7.1_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Shifting one register’s output into a second register’s input to
    reverse a string
  prefs: []
  type: TYPE_NORMAL
- en: 'We have reversed the order of the bits. If the register to be shifted is `op1`,
    then we can write the Python code as follows. This code is in the form of a function
    that can be called from the instruction interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now change the code of TC1 to incorporate this. There are three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''REV'':(8,113)`, into the `codes` dictionary. 8 indicates `1000` in binary
    and informs the computer that the reverse instruction requires the destination
    `rD` register to be specified by the instruction. 113 is the opcode, which is
    `0b1110001` in binary.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 2**: In the opcode interpretation list, insert the new entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This checks whether the current instruction is `0b1110001` (i.e., 161 decimal)
    and calls the r`everseBits()` function to perform the required operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`reverseBits` function into the Python code. This instruction replaces the
    data in the `rD` register with the bits reversed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose that we wanted a non-destructive instruction that did not overwrite
    the register containing the bits to be reversed – that is `REV r0,r1`. What changes
    would we need?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we would need a new instruction format code. We have to specify two
    registers: the source and destination register. The code in the directory would
    now be `''REV'': (12,113)` because the opcode parameter value would be `1100`
    in binary or `12` in decimal. The other change would be to the instruction interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have changed the instruction format for minimal changes to the
    code (in this case, it’s just the change of source register from `op0` to `op1`).
  prefs: []
  type: TYPE_NORMAL
- en: A new comparison operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you are performing an operation on a string where you have to find
    the *middle* of the string. You can do this by stepping in from both ends until
    you get to the middle. But there are *two* types of middle. A string with an odd
    number of characters has a character in its middle. A string with an even number
    of characters has no middle character; it has two characters next to each other.
    Consider these two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String 1: 12`34`567`Odd number of characters'
  prefs: []
  type: TYPE_NORMAL
- en: '`String 2: 123`45`678`Even number of characters'
  prefs: []
  type: TYPE_NORMAL
- en: String 1 has an odd number of characters and 4 is the center. String 2 has an
    even number of characters, and 4 and 5 are on either side of the middle.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we are stepping through a string using two pointers, one at each end.
    As we step in from both sides, one pointer goes up and the other goes down. When
    we get to the middle, either the pointers are the same (odd length) or the pointers
    differ by one (even length).
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be nice to have a compare operation that compares two values and returns
    equality if either they are the same or if the second one differs from the first
    by +1\. The new instruction, `CMPT` (*compare together*), does this. For example,
    `CMPT` `r4,r6` sets the `z` bit to `1` if the contents of `r4` and `r6` are the
    same, or if the contents of `r4` are one less than the contents of `r6`. The code
    to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this performs two tests on the pointers, one for equality and
    one for higher by 1, and combines the test results using a Boolean `or` operator;
    that is, if the pointers are `x` and `y`, then the test is true `if x = y` is
    true or if `x + 1 = y` is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction is not implemented in a real processor. Why not if it’s a
    great idea? Well, first, it would be used in only a small number of programs requiring
    this particular operation. It takes up silicon real estate on the chip that is
    hardly ever used. That’s a waste of precious resources. Second, machine code is
    mostly generated by compilers, and it’s not easy to design compilers that use
    special-purpose operations such as this effectively. Third, this instruction performs
    three operations: comparing `p` and `q`, adding 1 to `q`, comparing `p` and `q+1`.
    Consequently, it takes longer to execute than single-operation instructions. That
    reduces the efficiency of the computer.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will be introduced to the notion of instructions with
    fields that have variable lengths. Real machines do not have this facility. The
    reason for including this section is to demonstrate instruction decoding and bit
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: Variable-length instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This short section provides ideas for experimentation with instructions and
    their formats and extends your understanding of instructions, their structure,
    and the trade-off involved in creating instruction sets. It is not designed to
    illustrate a real computer.
  prefs: []
  type: TYPE_NORMAL
- en: Like many computers, TC1 has *fixed-length fields* in its opcode; that is, the
    number of bits dedicated to each field is fixed and does not vary from instruction
    to instruction. There are always 16 bits in the literal field, even if the current
    instruction does not require a literal. Wasteful indeed. Since the purpose of
    TC1 is experimentation, we demonstrate how you might make the number of registers
    variable (i.e., user-definable). Adding more registers speeds up computation by
    requiring fewer memory accesses. However, there is a price; where do you get the
    extra bits that would be needed to specify the registers? Do you take the extra
    register bits from the opcode field (reducing the number of different instructions),
    or do you take them from the literal field (reducing the maximum size of a literal
    that can be loaded in a single instruction)? Or do you implement multiple banks
    of registers and switch in a new set of registers (called *windowing*) as a temporary
    measure?
  prefs: []
  type: TYPE_NORMAL
- en: Here, we provide some code that we used to experiment with variable register
    sizes. This is not a complete program. All it does is let you enter the size of
    register fields and then run a test by creating a *dummy* instruction. It’s a
    dummy instruction because the opcode is set to `1111110` and the literal field
    is all zeros. It just tests the ability to place the register fields at appropriate
    points in an instruction and automatically adjust the length of the literal field.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.2* provides the output of a single run of this program. The inputs
    are in bold. You can see that the register fields have been selected as 3, 3,
    and 5 bits wide. The instruction is `ADD R7,R2,R31` (note that the only data extracted
    is `7`, `2`, and `31`, as we are not interested in the actual instruction):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Demonstration of variable-length fields](img/Figure_7.2_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Demonstration of variable-length fields
  prefs: []
  type: TYPE_NORMAL
- en: The final binary instruction is given with each of its fields in a different
    style for clarity. You can see that the register fields have been placed in the
    correct positions in the instruction and the remaining bits (the literal field)
    are padded with zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may seem strange to have register fields of different widths. That means
    that some parameters in an instruction can access more registers than others.
    Such a facility can be useful; for example, you could use some of the registers
    as special-purpose registers (e.g., a stack pointer), or they could be used to
    hold frequently accessed constants (such as `0`, `1`, or `2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code with some sample values gives the following output (*Figure
    7**.3*). As you can see, the register files have been inserted into the opcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.3 – Demonstration of variable-length operand fields](img/Figure_7.3_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Demonstration of variable-length operand fields
  prefs: []
  type: TYPE_NORMAL
- en: A variable-length instruction machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this text, we have demonstrated machines with fixed-length instruction
    words. Computers based on this paradigm frequently fall into the RISC category.
    However, classic CISC machines (from the humble 8080 and 6800 to the less humble
    8086 and 68000 microprocessors) had variable-length instructions, as we’ve already
    pointed out. Consider the following example of a stream of variable-length instructions,
    where `1` represents a 1-word instruction, `2` represents a 2-word instruction,
    and so on (*Figure 7**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Instruction stream with variable-length opcodes](img/Figure_7.4_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Instruction stream with variable-length opcodes
  prefs: []
  type: TYPE_NORMAL
- en: As instructions are executed, they must be decoded and the appropriate number
    of bytes appended to the current instruction. A problem with this approach is
    that it makes look-ahead processing difficult because you do not know where future
    instructions begin and end until you’ve decoded the current instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’re going to demonstrate a very simple variable-length machine that
    uses 8-bit words and an instruction can be 8, 16, 24, or 32 bits long. An operation
    like `nop` is 8 bits, `branch` is 16 bits, `move` is 24 bits, and `add` is 32
    bits. The instruction itself is 8 bits (in the demonstration, we use only 5 bits
    for simplicity). An instruction is read and the two most-significant bits determine
    the total number of bytes required by this instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The number of registers used by this machine is … none! For the sake of simplicity,
    and fun, we decided to make all instructions memory-based.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, we need two counters: one that counts the instructions and one
    that counts the bytes. For example, the instruction sequence in *Table 7.1* demonstrates
    the *instruction address* (sequential) and the *memory address* of the first byte
    of an instruction. Here, instructions vary from 1 byte (`stop`) to 4 bytes (`add`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Instruction address** | **Memory address** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ld``28,7` | `0` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `ld``27,2` | `1` | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `ld``26,1` | `2` | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| `add 28,28,26` | `3` | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| `dec 26` | `4` | 13 |'
  prefs: []
  type: TYPE_TB
- en: '| `bne 3` | `5` | 15 |'
  prefs: []
  type: TYPE_TB
- en: '| `stop` | `6` | 17 |'
  prefs: []
  type: TYPE_TB
- en: '| Next free space | `7` | `18` |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – Instruction and memory addresses for variable-length code
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have used simple numeric addresses. Some addresses are literal bytes;
    for example, `ld 28,7` means load memory location `28` with the number `7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code provides a program to implement such a computer. Note that
    the actual program is supplied as a list. This program does not have the textual
    flexibility of TC1; it’s a simple demonstration. An instruction is entered in
    lowercase text with commas separating the parameters. All values are in decimal.
    However, limited symbolic names are permitted; for example, `abc: equ 12` binds
    the number `12` to the symbolic name `abc:`. Note the need for a colon after the
    name.'
  prefs: []
  type: TYPE_NORMAL
- en: All data is either a number or a memory address; for example, `add 12,13,20`
    adds the contents of memory location `13` to the contents of memory location `20`
    and puts the sum in memory location `12`.
  prefs: []
  type: TYPE_NORMAL
- en: A branch requires an actual address. Branching is absolute (direct) and not
    program counter-relative. To branch to the instruction beginning at address `16`,
    you write `bra 16`. However, symbolic names are supported and you can write `bra
    abc:`, provided that the target is labeled with `abc:`.
  prefs: []
  type: TYPE_NORMAL
- en: In this simulator, the instruction counter is incremented by one every time
    a new instruction is read. However, the memory counter is incremented every time
    a new byte is added to this instruction. The added bytes may be 1, 2, 3, or 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you have to give a byte branch address, you not only have to count the
    number of instructions branched but also the number of bytes branched. To do this,
    we create a mapping table that maps the instruction address to the byte address.
    This table is called `map[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lookUp{}` dictionary describes each instruction with a binary key and
    a value consisting of a mnemonic. The `allOps{}` dictionary consists of a key
    (the mnemonic) and a tuple containing the instruction length and opcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step after removing equates is to clean up the source code and deal
    with labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We now go through the code, but not in execution mode. We create a memory counter,
    mc, that acts rather like a program counter but serves to keep track of the instructions
    in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can execute the code by stepping through the instructions in memory
    using a program counter. However, the program counter is incremented by the length
    of each instruction after the current instruction has been read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'After looking up the opcode, we use an `if...elif` construct to examine successive
    mnemonics to determine the current operation. Note the dummy no-operation is implemented
    by Python’s pass, which does nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cmp` compare operation subtracts two operands and sets the z-bit to `1`
    if the result is zero. Otherwise, `z` is set to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `execute` loop, we get input from the keyboard. This simply
    introduces a wait until the *Enter*/*return* key is hit before the next instruction
    is executed. The remaining Python code formats the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: We have only briefly touched on the topic of variable-length instructions. In
    principle, it’s a very simple idea. An instruction is read, decoded, and executed.
    As each instruction is fetched into the computer, it has to be decoded and the
    program counter advanced by the number of words taken up by the current instruction.
    In practice, this creates problems because branch addresses are no longer just
    the number of instructions from the branch but also the number of memory locations
    taken up by those instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter introduced TC1, a Python-based computer simulator that
    could be used to develop and test instruction set architectures. In this chapter,
    we explored aspects of simulator design in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how you can create new instructions and add them to TC1’s instruction
    set. Advanced instructions that perform a lot of special-purpose computation were
    once the province of the classic CISC processor, such as the Motorola 68K family.
    Then, with the rise of the RISC architecture and its stress on simplicity and
    single-cycle instructions, the CISC processor seemed about to go out of fashion.
    However, many modern computers have incorporated complex instructions for special
    applications such as data encoding, image processing, and AI applications.
  prefs: []
  type: TYPE_NORMAL
- en: We looked a little more deeply at how you can check the input of a simulator
    and ensure that errors in data and instructions can be detected.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at various topics in Python programming, such as data formatting.
    In principle, printing data the way you want it to look is easy. In practice,
    it is a little more complicated (not least because there are several methods of
    formatting data).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter expanded on the notion of tracing a program while it is being executed
    and demonstrated some of the techniques involved in printing the data you want
    to see during a simulator run.
  prefs: []
  type: TYPE_NORMAL
- en: As well as looking at new instructions, we explored the concept of variable-length
    instructions. We started with a demonstration of how you could change the number
    of bits in each register address field at runtime to change the number of addressable
    registers. This is not a realistic factor in instruction set design (at the moment),
    but there was a period when register windows became popular and you could, indeed,
    expand the number of registers.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced the notion of variable-length instructions when each instruction
    can be an integer number of multiples of the computer’s word length. This approach
    allows instructions with an unlimited level of complexity at the price of more
    complicated decoding mechanisms. We demonstrated the design of a primitive variable
    instruction length machine that could easily be expanded to a simulator with the
    full complexity of TC1.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter returns to the simulator and looks at several simulators for
    different types of architecture.
  prefs: []
  type: TYPE_NORMAL
