["```py\n>>> from __future__ import braces \n```", "```py\n# Simple formatting\n>>> name = 'Rick'\n\n>>> 'Hi %s' % name\n'Hi Rick'\n\n>>> 'Hi {}'.format(name)\n'Hi Rick' \n```", "```py\n>>> value = 1 / 3\n\n>>> '%.2f' % value\n'0.33'\n\n>>> '{:.2f}'.format(value)\n'0.33' \n```", "```py\n>>> name = 'Rick'\n>>> value = 1 / 3\n\n>>> 'Hi {0}, value: {1:.3f}. Bye {0}'.format(name, value)\n'Hi Rick, value: 0.333\\. Bye Rick' \n```", "```py\n>>> name = 'Rick'\n\n>>> 'Hi %(name)s' % dict(name=name)\n'Hi Rick'\n\n>>> 'Hi {name}'.format(name=name)\n'Hi Rick'\n\n>>> f'Hi {name}'\n'Hi Rick' \n```", "```py\n>>> 'Hi {name}'.format(**globals())\n'Hi Rick' \n```", "```py\n## Accessing dict items\n>>> username = 'wolph'\n>>> a = 123\n>>> b = 456\n>>> some_dict = dict(a=a, b=b)\n\n>>> f'''a: {some_dict['a']}'''\n'a: 123'\n\n>>> f'''sum: {some_dict['a'] + some_dict['b']}'''\n'sum: 579'\n\n## Python expressions, specifically an inline if statement\n>>> f'if statement: {a if a > b else b}'\n'if statement: 456'\n\n## Function calls\n>>> f'min: {min(a, b)}'\n'min: 123'\n\n>>> f'Hi {username}. And in uppercase: {username.upper()}'\n'Hi wolph. And in uppercase: WOLPH'\n\n## Loops\n>>> f'Squares: {[x ** 2 for x in range(5)]}'\n'Squares: [0, 1, 4, 9, 16]' \n```", "```py\n>>> import this\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those! \n```", "```py\n>>> filter_modulo = lambda i, m: (i[j] for j in \\\n...                               range(len(i)) if i[j] % m)\n>>> list(filter_modulo(range(10), 2))\n[1, 3, 5, 7, 9] \n```", "```py\n>>> def filter_modulo(items, modulo):\n...     for item in items:\n...         if item % modulo:\n...             yield item\n...\n\n>>> list(filter_modulo(range(10), 2))\n[1, 3, 5, 7, 9] \n```", "```py\n>>> from os import *\n>>> from asyncio import *\n\n>>> assert wait \n```", "```py\n>>> from os import path\n>>> from asyncio import wait\n\n>>> assert wait \n```", "```py\n>>> import os\n>>> import asyncio\n\n>>> assert asyncio.wait\n>>> assert os.path \n```", "```py\n>>> def spam(eggs, *args, **kwargs):\n...     for arg in args:\n...         eggs += arg\n...     for extra_egg in kwargs.get('extra_eggs', []):\n...         eggs += extra_egg\n...     return eggs\n\n>>> spam(1, 2, 3, extra_eggs=[4, 5])\n15 \n```", "```py\n>>> def sum_ints(*args):\n...     total = 0\n...     for arg in args:\n...         total += arg\n...     return total\n\n>>> sum_ints(1, 2, 3, 4, 5)\n15 \n```", "```py\n>>> import math\n>>> import itertools\n\n>>> def primes_complicated():\n...     sieved = dict()\n...     i = 2\n...     \n...     while True:\n...         if i not in sieved:\n...             yield i\n...             sieved[i * i] = [i]\n...         else:\n...             for j in sieved[i]:\n...                 sieved.setdefault(i + j, []).append(j)\n...             del sieved[i]\n...         \n...         i += 1\n\n>>> list(itertools.islice(primes_complicated(), 10))\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29] \n```", "```py\n>>> def primes_complex():\n...     numbers = itertools.count(2)\n...     while True:\n...         yield (prime := next(numbers))\n...         numbers = filter(prime.__rmod__, numbers)\n\n>>> list(itertools.islice(primes_complex(), 10))\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29] \n```", "```py\n>>> def is_prime(number):\n...     if number == 0 or number == 1:\n...         return False\n...     for modulo in range(2, number):\n...         if not number % modulo:\n...             return False\n...     else:\n...         return True\n\n>>> def primes_simple():\n...     for i in itertools.count():\n...         if is_prime(i):\n...             yield i\n\n>>> list(itertools.islice(primes_simple(), 10))\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29] \n```", "```py\n>>> def between_and_modulo(value, a, b, modulo):\n...     if value >= a:\n...         if value <= b:\n...             if value % modulo:\n...                 return True\n...     return False\n\n>>> for i in range(10):\n...     if between_and_modulo(i, 2, 9, 2):\n...         print(i, end=' ')\n3 5 7 9 \n```", "```py\n>>> def between_and_modulo(value, a, b, modulo):\n...     if value < a:\n...         return False\n...     elif value > b:\n...         return False\n...     elif not value % modulo:\n...         return False\n...     else:\n...         return True\n\n>>> for i in range(10):\n...     if between_and_modulo(i, 2, 9, 2):\n...         print(i, end=' ')\n3 5 7 9 \n```", "```py\n>>> f=lambda x:0**x or x*f(x-1)\n>>> f(40)\n815915283247897734345611269596115894272000000000 \n```", "```py\n>>> def factorial(x):\n...     if 0 ** x:\n...         return 1\n...     else:\n...         return x * factorial(x - 1)\n\n>>> factorial(40)\n815915283247897734345611269596115894272000000000 \n```", "```py\n>>> from functools import reduce\n\n>>> fib=lambda n:n if n<2 else fib(n-1)+fib(n-2)\n>>> fib(10)\n55\n\n>>> fib=lambda n:reduce(lambda x,y:(x[0]+x[1],x[0]),[(1,1)]*(n-1))[0]\n>>> fib(10)\n55 \n```", "```py\n>>> def fib(n):\n...     if n < 2:\n...         return n\n...     else:\n...         return fib(n - 1) + fib(n - 2)\n\n>>> fib(10)\n55\n\n>>> def fib(n):\n...     a = 0\n...     b = 1\n...     for _ in range(n):\n...         a, b = b, a + b\n...\n...     return a\n\n>>> fib(10)\n55 \n```", "```py\n>>> from concurrent.futures import ProcessPoolExecutor, \\\n...     CancelledError, TimeoutError \n```", "```py\n>>> from concurrent.futures import (\n...     ProcessPoolExecutor, CancelledError, TimeoutError) \n```", "```py\n>>> from concurrent import futures \n```", "```py\n>>> from concurrent.futures.process import \\\n...     ProcessPoolExecutor \n```", "```py\n>>> from concurrent.futures.process import (\n...     ProcessPoolExecutor\n... )\n\n>>> from concurrent.futures import (\n...     ProcessPoolExecutor,\n...     CancelledError,\n...     TimeoutError,\n... ) \n```", "```py\n>>> some_user_input = '123abc'\n\n>>> try:\n...     value = int(some_user_input)\n... except:\n...     pass \n```", "```py\n>>> some_user_input = '123abc'\n\n>>> try:\n...     value = int(some_user_input)\n... except ValueError:\n...     pass \n```", "```py\n>>> import logging\n\n>>> some_user_input = '123abc'\n\n>>> try:\n...     value = int(some_user_input)\n... except Exception as exception:\n...     logging.exception('Uncaught: {exception!r}') \n```", "```py\n>>> some_user_input_a = '123'\n>>> some_user_input_b = 'abc'\n\n>>> try:\n...     value = int(some_user_input_a)\n...     value += int(some_user_input_b)\n... except:\n...     value = 0 \n```", "```py\n>>> try:\n...     1 / 0  # Raises ZeroDivisionError\n... except ZeroDivisionError:\n...     print('Got zero division error')\n... except Exception as exception:\n...     print(f'Got unexpected exception: {exception}')\n... except BaseException as exception:\n...     # Base exceptions are a special case for keyboard\n...     # interrupts and a few other exceptions that are not\n...     # technically errors.\n...     print(f'Got base exception: {exception}')\n... else:\n...     print('No exceptions happened, we can continue')\n... finally:\n...     # Useful cleanup functions such as closing a file\n...     print('This code is _always_ executed')\nGot zero division error\nThis code is _always_ executed \n```", "```py\n>>> fh_a = open('spam', 'w', -1, None, None, '\\n')\n>>> fh_b = open(file='spam', mode='w', buffering=-1, newline='\\n') \n```", "```py\n>>> filename = 'spam'\n>>> mode = 'w'\n>>> buffers = -1\n\n>>> fh_b = open(filename, mode, buffers, newline='\\n') \n```", "```py\n>>> import warnings\n\n>>> warnings.warn('Something deprecated', DeprecationWarning) \n```", "```py\n>>> from json import loads\n\n>>> loads('{}')\n{} \n```", "```py\n>>> import json\n\n>>> json.loads('{}')\n{} \n```", "```py\nfrom django.contrib.auth.models import User\n# Use it as: User \n```", "```py\nfrom django.contrib.auth import models\n# Use it as: models.User \n```", "```py\nfrom django.contrib.auth import models as auth_models\n# Use it as auth_models.User \n```", "```py\nimport django.contrib.auth.models as auth_models\n# Use it as auth_models.User \n```", "```py\n>>> timestamp = 12345\n\n>>> filename = f'{timestamp}.csv' \n```", "```py\n>>> import datetime\n\n>>> timestamp = 12345\n\n>>> if isinstance(timestamp, datetime.datetime):\n...     filename = f'{timestamp}.csv'\n... else:\n...     raise TypeError(f'{timestamp} is not a valid datetime')\nTraceback (most recent call last):\n...\nTypeError: 12345 is not a valid datetime \n```", "```py\n>>> import datetime\n\n>>> timestamp = datetime.date(2000, 10, 5)\n>>> filename = f'{timestamp}.csv'\n>>> print(f'Filename from date: {filename}')\nFilename from date: 2000-10-05.csv \n```", "```py\n>>> timestamp = '2000-10-05'\n>>> filename = f'{timestamp}.csv'\n>>> print(f'Filename from str: {filename}')\nFilename from str: 2000-10-05.csv \n```", "```py\n>>> a = 1\n>>> a == True\nTrue\n>>> a is True\nFalse\n\n>>> b = 0\n>>> b == False\nTrue\n>>> b is False\nFalse \n```", "```py\n>>> def some_unsafe_function(arg=None):\n...     if not arg:\n...         arg = 123\n...\n...     return arg\n\n>>> some_unsafe_function(0)\n123\n>>> some_unsafe_function(None)\n123 \n```", "```py\n>>> def some_safe_function(arg=None):\n...     if arg is None:\n...         arg = 123\n...\n...     return arg\n\n>>> some_safe_function(0)\n0\n>>> some_safe_function(None)\n123 \n```", "```py\n>>> a = 200 + 56\n>>> b = 256\n>>> c = 200 + 57\n>>> d = 257\n\n>>> a == b\nTrue\n>>> a is b\nTrue\n>>> c == d\nTrue\n>>> c is d\nFalse \n```", "```py\n>>> my_range = range(5)\n>>> i = 0\n>>> while i < len(my_range ):\n...     item = my_range [i]\n...     print(i, item, end=', ')\n...     i += 1\n0 0, 1 1, 2 2, 3 3, 4 4, \n```", "```py\n>>> my_range  = range(5)\n>>> for item in my_range :\n...     print(item, end=', ')\n0, 1, 2, 3, 4,\n\n>>> for i, item in enumerate(my_range ):\n...     print(i, item, end=', ')\n0 0, 1 1, 2 2, 3 3, 4 4, \n```", "```py\n>>> my_range  = range(5)\n>>> [(i, item) for i, item in enumerate(my_range)]\n[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)] \n```", "```py\nwith open('/path/to/some/file/you/want/to/read') as file_1, \\\n        open('/path/to/some/file/being/written', 'w') as file_2:\n    file_2.write(file_1.read()) \n```", "```py\nfilename_1 = '/path/to/some/file/you/want/to/read'\nfilename_2 = '/path/to/some/file/being/written'\nwith open(filename_1) as file_1, open(filename_2, 'w') as file_2:\n    file_2.write(file_1.read()) \n```", "```py\nimport pathlib\nfilename_1 = pathlib.Path('/path/to/some/file/you/want/to/read')\nfilename_2 = pathlib.Path('/path/to/some/file/being/written')\nwith filename_1.open() as file_1, filename_2.open('w') as file_2:\n    file_2.write(file_1.read()) \n```", "```py\ndef noop():\n    pass\n\ndef yield_cube_points(matrix):\n    for x in matrix:\n        for y in x:\n            for z in y:\n                yield (x, y, z)\n\ndef print_cube(matrix):\n    for x in matrix:\n        for y in x:\n            for z in y:\n                print(z, end='')\n            print()\n        print() \n```", "```py\n$ pip3 install mccabe\n...\n$ python3 -m mccabe T_16_mccabe.py\n1:0: 'noop' 1\n5:0: 'yield_cube_points' 4\n12:0: 'print_cube' 4 \n```", "```py\nsome_number: int\nsome_number = 'test' \n```", "```py\n$ mypy T_17_mypy.py\nT_17_mypy.py:2: error: Incompatible types in assignment (expression has type \"str\", variable has type \"int\")\nFound 1 error in 1 file (checked 1 source file) \n```", "```py\nsome_number = 'test'  # type: int \n```", "```py\ndef spam(a,b,c):print(a,b+c)\ndef eggs():pass \n```", "```py\n$ pip3 install flake8\n...\n$ flake8 T_18_flake8.py\nT_18_flake8.py:1:11: E231 missing whitespace after ','\nT_18_flake8.py:1:13: E231 missing whitespace after ','\nT_18_flake8.py:1:16: E231 missing whitespace after ':'\nT_18_flake8.py:1:24: E231 missing whitespace after ','\nT_18_flake8.py:2:11: E231 missing whitespace after ':' \n```", "```py\nif((fh = fopen(\"filename.txt\", \"w\")) == NULL) \n```", "```py\nfh = fopen(\"filename.txt\", \"w\")\nif fh == NULL: \n```", "```py\nif (fh := fopen(\"filename.txt\", \"w\")) == NULL: \n```", "```py\n while (line := input('Please enter a line: ')) != '':\n        # Process the line here\n    # The last line was empty, continue the script \n```", "```py\n>>> some_variable = 123\n\n>>> match some_variable:\n...     case 1:\n...         print('Got 1')\n...     case 2:\n...         print('Got 2')\n...     case _:\n...         print('Got something else')\nGot something else\n\n>>> if some_variable == 1:\n...     print('Got 1')\n... elif some_variable == 1:\n...     print('Got 2')\n... else:\n...     print('Got something else')\nGot something else \n```", "```py\n>>> some_variable = 123\n\n>>> match some_variable:\n...     case 1:\n...         print('Got 1')\n...     case other:\n...         print('Got something else:', other)\nGot something else: 123 \n```", "```py\nif some_variable == some_value: \n```", "```py\n>>> class Direction:\n...     LEFT = -1\n...     RIGHT = 1\n\n>>> some_variable = Direction.LEFT\n\n>>> match some_variable:\n...     case Direction.LEFT:\n...         print('Going left')\n...     case Direction.RIGHT:\n...         print('Going right')\nGoing left \n```", "```py\nswitch(variable){\n    case Direction::LEFT:\n    case Direction::RIGHT:\n        cout << \"Going horizontal\" << endl;\n        break;\n    case Direction::UP:\n    case Direction::DOWN:\n        cout << \"Going vertical\" << endl;\n} \n```", "```py\n>>> class Direction:\n...     LEFT = -1\n...     UP = 0\n...     RIGHT = 1\n...     DOWN = 2\n\n>>> some_variable = Direction.LEFT\n\n>>> match some_variable:\n...     case Direction.LEFT | Direction.RIGHT:\n...         print('Going horizontal')\n...     case Direction.UP | Direction.DOWN:\n...         print('Going vertical')\nGoing horizontal \n```", "```py\n>>> values = -1, 0, 1\n\n>>> for value in values:\n...     print('matching', value, end=': ')\n...     match value:\n...         case negative if negative < 0:\n...             print(f'{negative} is smaller than 0')\n...         case positive if positive > 0:\n...             print(f'{positive} is greater than 0')\n...         case _:\n...             print('no match')\nmatching -1: -1 is smaller than 0\nmatching 0: no match\nmatching 1: 1 is greater than 0 \n```", "```py\n>>> values = (0, 1), (0, 2), (1, 2)\n\n>>> for value in values:\n...     print('matching', value, end=': ')\n...     match value:\n...         case 0, 1:\n...             print('exactly matched 0, 1')\n...         case 0, y:\n...             print(f'matched 0, y with y: {y}')\n...         case x, y:\n...             print(f'matched x, y with x, y: {x}, {y}')\nmatching (0, 1): exactly matched 0, 1\nmatching (0, 2): matched 0, y with y: 2\nmatching (1, 2): matched x, y with x, y: 1, 2 \n```", "```py\n>>> def get_uri(*args):\n...     # Set defaults so we only have to store changed variables\n...     protocol, port, paths = 'https', 443, ()\n...     match args:\n...         case (hostname,):\n...             pass\n...         case (hostname, port):\n...             pass\n...         case (hostname, port, protocol, *paths):\n...             pass\n...         case _:\n...             raise RuntimeError(f'Invalid arguments {args}')\n...\n...     path = '/'.join(paths)\n...     return f'{protocol}://{hostname}:{port}/{path}'\n\n>>> get_uri('localhost')\n'https://localhost:443/'\n>>> get_uri('localhost', 12345)\n'https://localhost:12345/'\n>>> get_uri('localhost', 80, 'http')\n'http://localhost:80/'\n>>> get_uri('localhost', 80, 'http', 'some', 'paths')\n'http://localhost:80/some/paths' \n```", "```py\n>>> values = (0, 1), (0, 2), (1, 2)\n\n>>> for value in values:\n...     print('matching', value, end=': ')\n...     match value:\n...         case 0 as x, (1 | 2) as y:\n...             print(f'matched x, y with x, y: {x}, {y}')\n...         case _:\n...             print('no match')\nmatching (0, 1): matched x, y with x, y: 0, 1\nmatching (0, 2): matched x, y with x, y: 0, 2\nmatching (1, 2): no match \n```", "```py\n>>> values = dict(a=0, b=0), dict(a=0, b=1), dict(a=1, b=1)\n\n>>> for value in values:\n...     print('matching', value, end=': ')\n...     match value:\n...         case {'a': 0}:\n...             print('matched a=0:', value)\n...         case {'a': 0, 'b': 0}:\n...             print('matched a=0, b=0:', value)\n...         case _:\n...             print('no match')\nmatching {'a': 0, 'b': 0}: matched a=0: {'a': 0, 'b': 0}\nmatching {'a': 0, 'b': 1}: matched a=0: {'a': 0, 'b': 1}\nmatching {'a': 1, 'b': 1}: no match \n```", "```py\n>>> class Person:\n...     def __init__(self, name):\n...         self.name = name\n\n>>> values = Person('Rick'), Person('Guido')\n\n>>> for value in values:\n...     match value:\n...         case Person(name='Rick'):\n...             print('I found Rick')\n...         case Person(occupation='Programmer'):\n...             print('I found a programmer')\n...         case Person() as person:\n...             print('I found a person:', person.name)\nI found Rick\nI found a person: Guido \n```", "```py\n>>> class Person:\n...     def __init__(self, name):\n...         self.name = name\n\n>>> value = Person(123)\n>>> match value:\n...     case Person(name=str() as name):\n...         print('Found person with str name:', name)\n...     case Person(name=int() as name):\n...         print('Found person with int name:', name)\nFound person with int name: 123 \n```", "```py\n>>> g = 1\n\n>>> def print_global():\n...     print(f'Value: {g}')\n\n>>> print_global()\nValue: 1 \n```", "```py\n>>> g = 1\n\n>>> def print_global():\n...     g += 1\n...     print(f'Value: {g}')\n\n>>> print_global()\nTraceback (most recent call last):\n    ...\nUnboundLocalError: local variable 'g' referenced before assignment \n```", "```py\n>>> x = []\n>>> y = x\n>>> z = x.copy()\n\n>>> x.append('x')\n>>> y.append('y')\n>>> z.append('z')\n\n>>> x\n['x', 'y']\n>>> y\n['x', 'y']\n>>> z\n['z'] \n```", "```py\n>>> import copy\n\n>>> x = [[1], [2, 3]]\n>>> y = x.copy()\n>>> z = copy.deepcopy(x)\n\n>>> x.append('a')\n>>> x[0].append(x)\n\n>>> x\n[[1, [...]], [2, 3], 'a']\n>>> y\n[[1, [...]], [2, 3]]\n>>> z\n[[1], [2, 3]] \n```", "```py\n>>> def append(list_=[], value='value'):\n...    list_.append(value)\n...    return list_\n\n>>> append(value='a')\n['a']\n>>> append(value='b')\n['a', 'b'] \n```", "```py\n>>> def append(list_=None, value='value'):\n...    if list_ is None:\n...        list_ = []\n...    list_.append(value)\n...    return list_\n\n>>> append(value='a')\n['a']\n>>> append(value='b')\n['b'] \n```", "```py\n>>> class SomeClass:\n...     class_list = []\n...\n...     def __init__(self):\n...         self.instance_list = []\n\n>>> SomeClass.class_list.append('from class')\n>>> instance = SomeClass()\n>>> instance.class_list.append('from instance')\n>>> instance.instance_list.append('from instance')\n\n>>> SomeClass.class_list\n['from class', 'from instance']\n>>> SomeClass.instance_list\nTraceback (most recent call last):\n...\nAttributeError: ... 'SomeClass' has no attribute 'instance_list'\n\n>>> instance.class_list\n['from class', 'from instance']\n>>> instance.instance_list\n['from instance'] \n```", "```py\n>>> class Parent:\n...     pass\n\n>>> class Child(Parent):\n...     pass\n\n>>> Parent.parent_property = 'parent'\n>>> Child.parent_property\n'parent'\n\n>>> Child.parent_property = 'child'\n>>> Parent.parent_property\n'parent'\n>>> Child.parent_property\n'child'\n\n>>> Child.child_property = 'child'\n>>> Parent.child_property\nTraceback (most recent call last):\n...\nAttributeError: ... 'Parent' has no attribute 'child_property' \n```", "```py\nlist = [1, 2, 3] \n```", "```py\nlist_ = [1, 2, 3] \n```", "```py\n>>> list = list((1, 2, 3))\n>>> list\n[1, 2, 3]\n\n>>> list((4, 5, 6))\nTraceback (most recent call last):\n    ...\nTypeError: 'list' object is not callable\n\n>>> import = 'Some import'\nTraceback (most recent call last):\n    ...\nSyntaxError: invalid syntax \n```", "```py\nimport builtins\nimport inspect\nimport pprint\nimport re\n\ndef pp(*args, **kwargs):\n    '''PrettyPrint function that prints the variable name when\n    available and pprints the data'''\n    name = None\n    # Fetch the current frame from the stack\n    frame = inspect.currentframe().f_back\n    # Prepare the frame info\n    frame_info = inspect.getframeinfo(frame)\n\n    # Walk through the lines of the function\n    for line in frame_info[3]:\n        # Search for the pp() function call with a fancy regexp\n        m = re.search(r'\\bpp\\s*\\(\\s*([^)]*)\\s*\\)', line)\n        if m:\n            print('# %s:' % m.group(1), end=' ')\n            break\n\n    pprint.pprint(*args, **kwargs)\n\nbuiltins.pf = pprint.pformat\nbuiltins.pp = pp \n```", "```py\nx = 10\npp(x) \n```", "```py\n# x: 10 \n```", "```py\n>>> dict_ = dict(a=123)\n>>> set_ = set((456,))\n\n>>> for key in dict_:\n...     del dict_[key]\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nRuntimeError: dictionary changed size during iteration\n\n>>> for item in set_:\n...     set_.remove(item)\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nRuntimeError: Set changed size during iteration \n```", "```py\n>>> list_ = list(range(10))\n>>> list_\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> for item in list_:\n...     print(list_.pop(0), end=', ')\n0, 1, 2, 3, 4,\n\n>>> list_\n[5, 6, 7, 8, 9] \n```", "```py\n>>> list_ = list(range(10))\n\n>>> for item in list(list_):\n...     print(list_.pop(0), end=', ')\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \n```", "```py\n>>> exception = None\n\n>>> try:\n...     1 / 0\n... except ZeroDivisionError as exception:\n...     pass\n\n>>> exception\nTraceback (most recent call last):\n    ...\nNameError: name 'exception' is not defined \n```", "```py\n>>> try:\n...     1 / 0\n... except ZeroDivisionError as exception:\n...     new_exception = exception\n\n>>> new_exception\nZeroDivisionError('division by zero') \n```", "```py\n>>> functions = [lambda: i for i in range(3)]\n\n>>> for function in functions:\n...     print(function(), end=', ')\n2, 2, 2, \n```", "```py\n>>> from functools import partial\n\n>>> functions = [partial(lambda x: x, i) for i in range(3)]\n\n>>> for function in functions:\n...     print(function(), end=', ')\n0, 1, 2, \n```", "```py\nimport T_28_circular_imports_b\n\nclass FileA:\n    pass\n\nclass FileC(T_28_circular_imports_b.FileB):\n    pass \n```", "```py\nimport T_28_circular_imports_a\n\nclass FileB(T_28_circular_imports_a.FileA):\n    pass \n```", "```py\nTraceback (most recent call last):\n  File \"T_28_circular_imports_a.py\", line 1, in <module>\n    import T_28_circular_imports_b\n  File \"T_28_circular_imports_b.py\", line 1, in <module>\n    import T_28_circular_imports_a\n  File \"T_28_circular_imports_a.py\", line 8, in <module>\n    class FileC(T_28_circular_imports_b.FileB):\nAttributeError: partially initialized module 'T_28_circular_imports_b' has no attribute 'FileB' (most likely due to a circular import) \n```", "```py\nclass FileA:\n    pass \n```", "```py\nimport T_29_circular_imports_a\n\nclass FileB(T_29_circular_imports_a.FileA):\n    pass \n```", "```py\nimport T_29_circular_imports_b\n\nclass FileC(T_29_circular_imports_b.FileB):\n    pass \n```", "```py\n>>> import importlib\n\n>>> module_name = 'sys'\n>>> attribute = 'version_info'\n\n>>> module = importlib.import_module(module_name)\n>>> module\n<module 'sys' (built-in)>\n>>> getattr(module, attribute).major\n3 \n```"]