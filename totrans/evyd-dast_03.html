<html><head></head><body>
<div class="book" title="Chapter&#xA0;3.&#xA0;Lists: Linear Collections" id="KVCC1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Lists: Linear Collections</h1></div></div></div><p class="calibre7">In our last chapter, we introduced the array data structure upon which many of the structures we will examine in this text are based. Although arrays provide good performance for static collections of data, our coding examples proved that they are inflexible and inefficient for many applications--so much so that even something as simple as adding or deleting an element from a collection is an extremely complex and costly operation.</p><p class="calibre7">Lists are, in some ways, an evolution of the array. A list can be defined as a finite, ordered series of objects or values called <span class="strong"><strong class="calibre16">elements</strong></span>. An empty list is a list with no elements, while the length of a list is the total number of elements in the collection. The first item in a list is called the <span class="strong"><strong class="calibre16">head</strong></span>, while the last item is called the <span class="strong"><strong class="calibre16">tail</strong></span>. In a list with a length of 1, the head and tail are the same object.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note16" class="calibre1"/>Note</h3><p class="calibre7">While arrays are a <span class="strong"><em class="calibre20">concrete</em></span> data structure, a list is an abstract concept of a data structure that many languages provide a concrete implementation of. We will examine this distinction in more detail with one of the Java examples later in this chapter.</p></div><p class="calibre7">Ordered lists should not be confused with sorted lists because lists can be either <span class="strong"><strong class="calibre16">sorted</strong></span> or <span class="strong"><strong class="calibre16">unsorted</strong></span>. Ordered simply means that each element has a defined position in the list. Objects in a sorted list have some type of relationship between them, while objects in an unsorted list have no notable relationship. For example, when my wife creates a shopping list, she sits down and carefully organizes the groceries in relation to how she knows the supermarket is arranged. Items on her list are types of groceries and they are arranged according to their relative positions in the supermarket so they have a <span class="strong"><em class="calibre20">spatial relationship</em></span>. This is a sorted list. I, on the other hand, create a shopping list by slapping a piece of paper on the fridge and scribbling items on the paper as I notice shelves are empty or containers are missing. Although the items on my list are all types of groceries, they are not arranged in any particular way so they have <span class="strong"><em class="calibre20">no notable relationship</em></span> to one another. This is an example of an unsorted list.</p><p class="calibre7">In this chapter we will cover the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Definition of a list data structure</li><li class="listitem">Initializing lists</li><li class="listitem">Example applications for lists</li><li class="listitem">List implementations</li><li class="listitem">Append, insert, and remove operations</li><li class="listitem">Array-based lists</li><li class="listitem">Linked lists</li><li class="listitem">Doubly linked lists</li><li class="listitem">Searching</li></ul></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Lists: Linear Collections" id="KVCC1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="List implementations"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec14" class="calibre1"/>List implementations</h1></div></div></div><p class="calibre7">One of the most common implementations of the list data structure is the <span class="strong"><em class="calibre20">array-based</em></span> list. Generally speaking, an array-based list is simply a contiguous list of array positions, each holding a <span class="strong"><em class="calibre20">pointer</em></span> to a list element. Since the list is based on an array, its functionality and performance are very similar to that of an array.</p><p class="calibre7">As seen in the previous examples, another common implementation is the <span class="strong"><strong class="calibre16">linked list</strong></span>. A linked list is also a sequence of elements, except most implementations refer to the elements as <span class="strong"><strong class="calibre16">nodes</strong></span>. In a linked list, the pointers to the elements are not contained in an array structure, but rather a pointer exists in memory to identify the first node. Then each node contains a link to the subsequent node in the list.</p><p class="calibre7">Finally, there is the <span class="strong"><strong class="calibre16">doubly linked list</strong></span>. In a doubly linked list, each node contains a link to both the subsequent node in the list and the previous node in the list. A doubly linked list makes traversing the list bidirectionally a much simpler process. The previous link in the head node and the next link in the tail node are both null. An alternative to this is to have the previous link in the head node point to the tail and the next link in the tail node point to the head, which changes the doubly linked list to a <span class="strong"><strong class="calibre16">circular linked list</strong></span>.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note17" class="calibre1"/>Note</h3><p class="calibre7">The term doubly linked list is not used very often, but if you work with the <code class="literal">LinkedList</code> classes in Java or C#, you are in fact working with a doubly linked list. C# and Java do not provide a <span class="strong"><strong class="calibre16">singly linked list</strong></span> type, and the doubly linked list provides you with the same functionality and more, so you should never need one. However, you could easily implement one of your own if you really wanted to for academic purposes.</p></div><p class="calibre7">Typically, each of the concrete implementations of this structure provides you with convenience methods allowing you to append, insert, and remove elements from the list. Both array-based and link-based lists provide access to the basic append, insert, and remove operations. However, the way in which these operations are implemented and their associated cost vary slightly between the two implementations. Where existing methods for this functionality are not baked in, it is typically a trivial exercise to create that functionality.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note18" class="calibre1"/>Note</h3><p class="calibre7">As with other implementations of abstract data structures, when given a choice between using methods we create ourselves and any methods provided by the framework, choose the latter as they will typically be more robust and reliable.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Lists: Linear Collections" id="KVCC1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="List implementations">
<div class="book" title="Array-based lists"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch03lvl2sec19" class="calibre1"/>Array-based lists</h2></div></div></div><p class="calibre7">The append operation in an array-based list costs <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>), as we can always determine the new element's position by simply incrementing the index of the tail position:</p><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00003.jpeg" alt="Array-based lists" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><p class="calibre7">Whenever we insert an element into an array-based list, we need to also manage the position of the existing objects in the array to accommodate the new nodes. Inserting an element into the list at index <span class="strong"><em class="calibre20">i</em></span> requires us to shift all of the elements in positions greater than <span class="strong"><em class="calibre20">i</em></span> one position toward the tail, meaning that we will need to perform <span class="strong"><em class="calibre20">n</em></span> - <span class="strong"><em class="calibre20">i</em></span> operations where there are <span class="strong"><em class="calibre20">n</em></span> elements already in the list. Inserting at the head position is a worst-case operation, costing <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>). Since we always count the cost of the worst case when evaluating an algorithm's efficiency, inserting an element costs <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>).</p><p class="calibre7">Removing an element from the list at index <span class="strong"><em class="calibre20">i</em></span> requires us to shift all of the elements in positions greater than <span class="strong"><em class="calibre20">i</em></span> one position toward the head, meaning that we will need to perform <span class="strong"><em class="calibre20">n</em></span> - <span class="strong"><em class="calibre20">i</em></span>- 1 operations where there are <span class="strong"><em class="calibre20">n</em></span> elements in the list. Removing from the head position is a worst-case operation, costing <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>). Therefore, removing an element costs <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>), as depicted in the following diagram:</p><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Array-based lists" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Lists: Linear Collections" id="KVCC1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="List implementations">
<div class="book" title="Linked list"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch03lvl2sec20" class="calibre1"/>Linked list</h2></div></div></div><p class="calibre7">As with an array-based list, the append operation costs <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>). However, the insert and remove operations also cost <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>). One of the key advantages of the linked list over the array-based list is mutability. Unlike an array, a linked list is a series of discrete objects related to one another by memory pointers, so inserting or removing elements is simply a matter of adding or modifying those pointers. In other words, a linked list is capable of growing and shrinking to accommodate additions to and deletions from the collection in a very efficient manner.</p><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Linked list" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><p class="calibre7">If we wish to insert an element at position <span class="strong"><em class="calibre20">i</em></span>, we need to change the original pointer <span class="strong"><em class="calibre20">i</em></span> - 1 -&gt; <span class="strong"><em class="calibre20">i</em></span> to point to our new element at <span class="strong"><em class="calibre20">i</em></span>, and insert a new pointer for <span class="strong"><em class="calibre20">i</em></span> -&gt; <span class="strong"><em class="calibre20">i</em></span> + 1. Similarly, removing an element at <span class="strong"><em class="calibre20">i</em></span> requires adjusting the pointer from <span class="strong"><em class="calibre20">i</em></span> - 1 -&gt; <span class="strong"><em class="calibre20">i</em></span> and making it <span class="strong"><em class="calibre20">i</em></span> - 1 -&gt; <span class="strong"><em class="calibre20">i</em></span> + 1.</p></div></div></div>
<div class="book" title="Instantiating lists" id="LTSU1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec15" class="calibre1"/>Instantiating lists</h1></div></div></div><p class="calibre7">Like other data structures, lists must be defined and instantiated prior to being used. Each of the four languages that we will examine in this text has varying support for, and unique implementations of, the list data structure. Let's briefly examine how to instantiate a list in each language.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">Instantiating lists in C# requires the use of the <code class="literal">new</code> keyword:</p><pre class="programlisting">    //Array backed lists 
    ArrayList myArrayList = new ArrayList(); 
    List&lt;string&gt; myOtherArrayList = new List&lt;string&gt;(); 
 
    //Linked lists 
    LinkedList&lt;string&gt; myLinkedList = new LinkedList&lt;string&gt;(); 
</pre><p class="calibre7">The C# <code class="literal">ArrayList</code> class originated in .NET 1.0, and it is not used very often anymore. Most developers prefer to use the generic concrete implementation, <code class="literal">List&lt;of T&gt;</code>, for an array-based list. This is also true for the generic concrete linked list implementation, <code class="literal">LinkedList&lt;of T&gt;</code>. There is no non-generic linked list data structure in C#.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">Like C#, initializing a list in Java requires the use of the <code class="literal">new</code> keyword:</p><pre class="programlisting">    //Array backed lists 
    List&lt;string&gt; myArrayList = new ArrayList&lt;string&gt;(); 
 
    //Linked lists 
    LinkedList&lt;string&gt; myLinkedList = new LinkedList&lt;string&gt;(); 
</pre><p class="calibre7">Java developers will create an array-based list using a concrete implementation of the generic abstract <code class="literal">List&lt;E&gt;</code> class. This is also true of the concrete linked list implementation, <code class="literal">LinkedList&lt;E&gt;</code>. There is no non-generic linked list data structure in Java.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">The process of creating a list in Objective-C is as follows:</p><pre class="programlisting">    //Array backed lists 
    NSArray *myArrayList = [NSArray array]; 
 
    //Linked lists 
    NSMutableArray *myLinkedList = [NSMutableArray array]; 
</pre><p class="calibre7">If you read the chapter on arrays, this example has probably caught your attention. In fact, this is not a mistake. The closest implementation for an array-based list in Objective-C is found in the <code class="literal">NSArray</code> class, while the closest implementation of a linked list is found in the <code class="literal">NSMutableArray</code> class. That's because <code class="literal">NSArray</code> and <code class="literal">NSMutableArray</code> are known as <span class="strong"><strong class="calibre16">class clusters</strong></span>. Class clusters provide public APIs that are really abstract classes. When you initialize one of these classes you get back the concrete implementation of a data structure, which is custom tailored for the data you provided. These implementations can even change at runtime if the nature of the data set changes, making array classes extremely flexible. This means that many of the data structures we will discuss in this text will be implemented in Objective-C (and Swift) by only three abstract classes.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note19" class="calibre1"/>Note</h3><p class="calibre7"><span class="strong"><strong class="calibre16">Class clusters in Objective-C</strong></span></p><p class="calibre7">Class clusters are a design pattern based on the <span class="strong"><strong class="calibre16">Abstract Factory</strong></span> pattern, which returns a type adhering to a certain interface (C#/Java) or protocol (Objective-C/Swift). They are leveraged heavily in the <span class="strong"><strong class="calibre16">Foundation</strong></span> framework and this is a good thing.</p><p class="calibre7">Class clusters group private, concrete subclasses under an abstract superclass or API. This public API is much simpler to work with than working with each subclass directly. <code class="literal">NSNumber</code>, <code class="literal">NSString</code>, <code class="literal">NSArray</code>, and <code class="literal">NSDictionary</code> are all examples of class clusters in Foundation.</p></div><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Finally, here's how to instantiate a list in Swift:</p><pre class="programlisting">    //Lists 
    var myArray = [string]() 
    var myOtherArray: Array&lt;string&gt; = [String]() 
</pre><p class="calibre7">Swift also uses class clusters for many different abstract collections. For lists, we use the <code class="literal">Array</code> class, which is both generic and mutable by default. There is a shorthand and an explicit declaration for arrays in Swift. Although more verbose, the explicit definition more clearly demonstrates the generic nature of the API.</p></div>

<div class="book" title="Revisiting users logged in to a service"><div class="book" id="MSDG2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec16" class="calibre1"/>Revisiting users logged in to a service</h1></div></div></div><p class="calibre7">In <a class="calibre1" title="Chapter 2.  Arrays: Foundational Collections" href="part0019_split_000.html#I3QM2-77f2b5b248f04368a6f723b0e9357ef3">Chapter 2</a>, <span class="strong"><em class="calibre20">Arrays: Foundational Structures</em></span>, we created an app to keep track of users logged into a web service, using an array as the underlying data structure containing the <code class="literal">User</code> objects. However, this design can be greatly improved upon by using a list data structure. Let's revisit the users logged into a service problem here, and by replacing the class array with a list, we will see that our original code is both abbreviated and more readable in most cases.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">In this example, we have replaced the <code class="literal">User[]</code> object with a <code class="literal">List&lt;User&gt;</code> object. Much of this refactor is obvious, but three lines of code should be noted. First, in the <code class="literal">CanAddUser()</code> method, we have replaced 15 lines of code with 2 lines of code by leveraging the <code class="literal">List&lt;T&gt;.Contains()</code> method and condensing our logic loop. Next, in the <code class="literal">UserAuthenticated()</code> method, we have leveraged the <code class="literal">List&lt;T&gt;.Add()</code> method, which replaced the call to <code class="literal">Array.Resize()</code> and the error-prone approach to assigning an object using the subscription operator. Finally, we replaced nearly 20 lines of complex and ugly code using the <code class="literal">List&lt;T&gt;.Remove()</code> method. The convenience and power afforded by this wrapper class should be obvious based solely on the abbreviated code:</p><pre class="programlisting">    List&lt;User&gt; _users; 
    public LoggedInUserList() 
    { 
        _users = new List&lt;User&gt;(); 
    } 
 
    bool CanAddUser(User user) 
    { 
        if (_users.Contains(user) || _users.Count &gt;= 30) 
        { 
            return false; 
        } else { 
            return true; 
        } 
    } 
 
    public void UserAuthenticated(User user) 
    { 
        if (this.CanAddUser(user)) 
        { 
            _users.Add(user); 
        } 
    } 
 
    public void UserLoggedOut(User user) 
    { 
        _users.Remove(user); 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">In this example, we have replaced the <code class="literal">User[]</code> object with a <code class="literal">List&lt;User&gt;</code> object. Much of this refactor is obvious, but three lines of code should be noted. First, in the <code class="literal">CanAddUser()</code> method, we have replaced 15 lines of code with 2 lines of code by leveraging the <code class="literal">List&lt;E&gt;.contains()</code> method and condensing our logic loop. Next, in the <code class="literal">UserAuthenticated()</code> method, we are leveraging the <code class="literal">List&lt;E&gt;.add()</code> method, which replaced the call to <code class="literal">Array.copyOf()</code> and the error-prone approach to assigning an object using the subscription operator. Finally, we replaced nearly 20 lines of complex and ugly code using the <code class="literal">List&lt;E&gt;.remove()</code> method:</p><pre class="programlisting">    List&lt;User&gt; _users; 
    public LoggedInUserList() 
    { 
        _users = new LinkedList&lt;User&gt;; 
    } 
 
    boolean CanAddUser(User user) 
    { 
        if (_users.contains(user) || _users.size() &gt;= 30) 
        { 
            return false; 
        } else { 
            return true; 
        } 
    } 
 
    public void UserAuthenticated(User user) 
    { 
        if (this.CanAddUser(user)) 
        { 
            _users.add(user); 
        } 
    } 
 
    public void UserLoggedOut(User user) 
    { 
        _users.remove(user); 
    } 
</pre><p class="calibre7">The following screenshot demonstrates another benefit of using generic classes when available. As you can see, our code  completion, or <span class="strong"><strong class="calibre16">Intellisense</strong></span>, suggests potential completion options including the proper type to be included in the collection. This can save you from having to check back repeatedly to make sure that you are using the correct object and collection, which is both time-consuming and annoying.</p><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="Revisiting users logged in to a service" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">In this example, we have replaced the <code class="literal">NSArray _users</code> object with an <code class="literal">NSMutableArray _users</code> object. In this example, besides some consolidation and code cleanup, there is really only one refactor. In <code class="literal">userLoggedOut:</code>, we replaced nearly 20 lines of complex and ugly code using the <code class="literal">NSMutableArray removeObject:</code> method instead of checking indices, looping, and merging objects:</p><pre class="programlisting">    @interface EDSLoggedInUserList() 
    { 
        NSMutableArray *_users; 
    } 
    -(instancetype)init 
    { 
        if (self = [super init]) 
        { 
            _users = [NSMutableArray array]; 
        }   
        return self; 
    } 
 
    -(BOOL)canAddUser:(EDSUser *)user 
    { 
        if ([_users containsObject:user] || [_users count] &gt;= 30) 
        { 
            return false; 
        } else { 
            return true; 
        } 
    } 
 
    -(void)userAuthenticated:(EDSUser *)user 
    { 
        if ([self canAddUser:user]) 
        { 
            [_users addObject:user]; 
        } 
    } 
 
    -(void)userLoggedOut:(EDSUser *)user 
    { 
        [_users removeObject:user]; 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">If you look carefully at this code in comparison to the original, you'll see that effectively they are the same! That's because Swift <code class="literal">Arrays</code> are already mutable and they already support generic types, so our original <code class="literal">LoggedInUserArray</code> class was already functioning as much like a linked, as Swift is capable of producing output with out-of-the-box code. We could create our own implementation of a linked list in Swift but that would only be necessary in very specific use cases:</p><pre class="programlisting">    var _users: Array = [User]() 
    init() { } 
 
    func canAddUser(user: User) -&gt; Bool 
    { 
        if (_users.contains(user) || _users.count &gt;= 30) 
        { 
            return false; 
        } else { 
            return true; 
        } 
    } 
 
    public func userAuthenticated(user: User) 
    { 
        if (self.canAddUser(user)) 
        { 
            _users.append(user) 
        } 
    } 
 
    public func userLoggedOut(user: User) 
    { 
        if let index = _users.indexOf(user) 
        { 
            _users.removeAtIndex(index) 
        } 
    } 
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note20" class="calibre1"/>Note</h3><p class="calibre7">These refactored examples using some varieties of the list data structure are not only streamlined, they are also more performant than their array counterparts. For both of these reasons, the list structure is proven as the superior choice for this application.</p></div></div>

<div class="book" title="Revisiting users logged in to a service">
<div class="book" title="Generics"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch03lvl2sec21" class="calibre1"/>Generics
</h2></div></div></div><p class="calibre7">You may have noticed the <code class="literal">List&lt;T&gt;.Contains()</code> method in our C# example or the <code class="literal">List&lt;E&gt;.Add()</code> method in our Java example. These methods are part of classes that have been defined as generic. In computer science, generics allow you to define a class or method without specifying the data type until the class is declared or the method is called.
For example, suppose you have a method that adds two number values together. In order to work directly with the individual types, you could create multiple overloads of an <code class="literal">Add()</code> method:</p><pre class="programlisting">    //C# 
    public int Add(int a, int b) 
    public double Add(double a, double b) 
    public float Add(float a, float b) 
</pre><p class="calibre7">Generics allow you to create a single method that is customized for the type that invokes it, greatly simplifying your code. In this example, <code class="literal">T</code> can be substituted for whatever type the caller needs:</p><pre class="programlisting">    public T Add&lt;T&gt;(T a, T b) 
</pre><p class="calibre7">Generics are an incredibly powerful tool, which we will discuss in greater detail in <a class="calibre1" title="Chapter 12. Sorting: Bringing Order Out Of Chaos" href="part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3">Chapter 12</a>, <span class="strong"><em class="calibre20">Sorting: Bringing Order Out Of Chaos</em></span>.</p></div></div>

<div class="book" title="Revisiting users logged in to a service">
<div class="book" title="Case study: bike route"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch03lvl2sec22" class="calibre1"/>Case study: bike route</h2></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre16">Business problem</strong></span>: A mobile app is to be written for biking enthusiasts who like to travel off-road. One of the key business requirements is the ability to store waypoints in a route. The route has to have a beginning and an end, and it needs to be traversable in both directions. The app also needs the ability to modify the biker's route in real time to allow for detours around hazards, visiting rest areas, or adding points of interest.</p><p class="calibre7">Due to the nature of the app and its requirements, the class that represents the route will need several basic pieces of functionality. First, it will require the ability to add, remove, and insert waypoints. Next, it will require the ability to start the route and traverse it to route forward and backward. Finally, the class should be able to easily identify the start and finish lines as well as the currently focused waypoint.</p><p class="calibre7">Since the nature of this data is such that all waypoints have a spatial relationship to one another, and the app must traverse from point to point utilizing that relationship, an array would be a poor selection as a data structure. However, since a List inherently provides a mechanism for both defining and traversing relationships between objects in the collection, the developer has chosen to use a linked list structure to build this component.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">C# conveniently exposes a linked list structure through the <code class="literal">LinkedList&lt;T&gt;</code> class and list nodes through the <code class="literal">LinkedListNode&lt;T&gt;</code> class. Therefore, building this class in C# should be a fairly straightforward procedure. Here's an example of what a simple implementation in C# looks like:</p><pre class="programlisting">    LinkedList&lt;Waypoint&gt; route; 
    LinkedListNode&lt;Waypoint&gt; current; 
    public WaypointList() 
    { 
        this.route = new LinkedList&lt;Waypoint&gt;(); 
    } 
</pre><p class="calibre7">First, we declare two properties. The first is the <code class="literal">route</code> property, which is <code class="literal">LinkedList&lt;Waypoint&gt;</code>. The next object is the <code class="literal">current</code> node. We have declared both objects without explicitly defining their scope, so they default to <code class="literal">private</code>. We want these fields to be private because we only permit the methods in this class to modify their values. Our constructor only instantiates the <code class="literal">route</code> property because the <code class="literal">current</code> node will be assigned on an as-needed basis:</p><pre class="programlisting">    public void AddWaypoints(List&lt;Waypoint&gt; waypoints) 
    { 
        foreach (Waypoint w in waypoints) 
        { 
            this.route.AddLast(w); 
        } 
    } 
 
    public bool RemoveWaypoint(Waypoint waypoint) 
    { 
        return this.route.Remove(waypoint); 
    } 
</pre><p class="calibre7">The <code class="literal">AddWaypoints(List&lt;Waypoint&gt;)</code> method allows us to add <span class="strong"><em class="calibre20">1...n</em></span> new waypoints to the existing route. C# does not provide a mechanism for merging <code class="literal">List&lt;T&gt;</code> with a <code class="literal">LinkedList&lt;T&gt;</code>, so we must resort to looping through <code class="literal">waypoints</code> and adding the new nodes individually using <code class="literal">LinkedList&lt;T&gt;.AddLast()</code>, meaning this operation costs <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">i</em></span>), where <span class="strong"><em class="calibre20">i</em></span> is the number of elements in the <code class="literal">waypoints</code> list.</p><p class="calibre7">The <code class="literal">RemoveWaypoint(Waypoint)</code> method simply calls <code class="literal">LinkedList&lt;T&gt;.Remove()</code> on the route, passing <code class="literal">waypoint</code> as a parameter. As this is technically a search operation, it also costs <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>):</p><pre class="programlisting">    public void InsertWaypointsBefore(List&lt;Waypoint&gt; waypoints, Waypoint before) 
    { 
        LinkedListNode&lt;Waypoint&gt; node = this.route.Find(before); 
        if (node != null) 
        { 
            foreach (Waypoint w in waypoints) 
            { 
                this.route.AddBefore(node, w); 
            } 
        } else { 
                this.AddWaypoints(waypoints); 
        }  
    } 
</pre><p class="calibre7">The <code class="literal">InsertWaypointsBefore(List&lt;Waypoint&gt;, Waypoint)</code> method gives our class the ability to create alternate routes and add intermediate destinations on-the-fly. First, we attempt to locate the <code class="literal">before</code> node. If we find it, we begin inserting the list of new waypoints sequentially before the <code class="literal">before</code> node. Otherwise, we immediately call <code class="literal">AddWaypoints(List&lt;Waypoint&gt;)</code> to append the new list of waypoints onto the route. Although the functionality of this loop may seem quirky, by adding each item sequentially just prior to the <code class="literal">before</code> node, we shift <code class="literal">before</code> one node closer to the tail with each operation, ensuring that each new node is inserted in the correct order.</p><p class="calibre7">This is the most expensive operation in this class as it is a combination of a search and an insert. This means its operational cost is <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>+<span class="strong"><em class="calibre20">i</em></span>) where <span class="strong"><em class="calibre20">n</em></span> is the number of elements in the existing <code class="literal">route</code> collection and <span class="strong"><em class="calibre20">i</em></span> is the number of elements in the <code class="literal">waypoints</code> list:</p><pre class="programlisting">    public bool StartRoute() 
    { 
        if (this.route.Count &gt; 1) 
        { 
            this.current = this.StartingLine(); 
            return this.MoveToNextWaypoint(); 
        } 
        return false; 
    } 
</pre><p class="calibre7">The <code class="literal">StartRoute()</code> method is used to set our initial current position and denote that it has been deactivated. Since our overall class represents a route, which is by definition a 2-dimensional object at the very least, the <code class="literal">StartRoute()</code> method immediately validates that <code class="literal">route</code> has at least two waypoints. If not, we return <code class="literal">false</code> because the route is not yet ready to be traversed. If we do have two or more waypoints, we set the <code class="literal">current</code> waypoint to the starting line and move to the next point. The <code class="literal">StartRoute()</code> method has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) operational cost.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note21" class="calibre1"/>Note</h3><p class="calibre7">We could have easily duplicated the critical code from the <code class="literal">StartingLine()</code> method and the <code class="literal">MoveToNextWaypoint()</code> method locally in <code class="literal">StartRoute()</code>. Doing so would mean that if we ever wanted to change how we identify the starting line or how we navigate the route, we would need to maintain that code in multiple locations. By following this pattern of code reuse, we minimize the amount of work and number of potential new bugs such a refactor could introduce.</p></div><p class="calibre7">Next we'll look at the methods that alter the object's position.</p><pre class="programlisting">    public bool MoveToNextWaypoint() 
    { 
        if (this.current != null) 
        { 
            this.current.Value.DeactivateWaypoint(); 
            if (this.current != this.FinishLine()) 
            { 
                this.current = this.current.Next; 
                return true; 
            } 
            return false; 
        } 
        return false; 
    } 
 
    public bool MoveToPreviousWaypoint() 
    { 
        if (this.current != null &amp;&amp; this.current != this.StartingLine()) 
        { 
            this.current = this.current.Previous; 
            this.current.Value.ReactivateWaypoint(); 
            return true; 
        } 
        return false; 
    } 
</pre><p class="calibre7">The <code class="literal">MoveToNextWayPoint()</code> and <code class="literal">MoveToPreviousWaypoint()</code> methods introduce our route traversal functionality. In <code class="literal">MoveToNextWaypoint()</code>, we check that the current waypoint is not <code class="literal">null</code>, and then we deactivate it. Next, we check whether we are at the finish line, and if not, we set <code class="literal">current</code> to the next node in <code class="literal">route</code> and return <code class="literal">true</code>. The <code class="literal">MoveToPreviousWaypoint()</code> method verifies that <code class="literal">current</code> is not <code class="literal">null</code> and makes sure that we are not at the starting line. If so, we move <code class="literal">current</code> to the previous waypoint and reactivate it. If any of our checks in these two methods fail, we return <code class="literal">false</code>. Each of these methods has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) operational cost.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note22" class="calibre1"/>Note</h3><p class="calibre7">This dual <code class="literal">false</code> return seen in <code class="literal">MoveToNextWaypoint()</code> may seem like a design flaw, but remember that our class is not responsible for the overall functionality of the app, only the functionality of the route. It is the responsibility of the <span class="strong"><em class="calibre20">caller</em></span> to check whether the route is ready to traverse before calling <code class="literal">MoveToNextWaypoint()</code>. Our return value is only signaling the success or failure of the operation.</p></div><p class="calibre7">Lastly, we'll look at the methods that indicate position:</p><pre class="programlisting">    public LinkedListNode&lt;Waypoint&gt; StartingLine() 
    { 
        return this.route.First; 
    } 
 
    public LinkedListNode&lt;Waypoint&gt; FinishLine() 
    { 
        return this.route.Last; 
    } 
 
    public LinkedListNode&lt;Waypoint&gt; CurrentPosition() 
    { 
        return this.current; 
    } 
</pre><p class="calibre7">We add the <code class="literal">StartingLine()</code> and <code class="literal">FinishLine()</code> methods to expose the head and tail nodes of the route collection. Finally, we add the <code class="literal">CurrentPosition()</code> method to expose which node in the route is our next immediate destination. Each of these methods has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) operational cost.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">Java also exposes a linked list data structure through the <code class="literal">LinkedList&lt;E&gt;</code> class. However, Java does not provide an implementation of the list node structure. This is because, in Java, you generally do not work with the nodes directly but through a list iterator. The <code class="literal">ListIterator&lt;E&gt;</code> class provides the necessary functionality to implement a linked list structure in the basic sense. If we needed our own node class, it would be easy to implement one. Here's an example of what a simple implementation of our <code class="literal">WaypointList</code> class might look like in Java:</p><pre class="programlisting">    LinkedList&lt;Waypoint&gt; route; 
    Waypoint current; 
    public WaypointList() 
    { 
        this.route = new LinkedList&lt;Waypoint&gt;(); 
    } 
</pre><p class="calibre7">First, we declare two properties. The first is the <code class="literal">route</code>, which is an abstract <code class="literal">List&lt;Waypoint&gt;</code>, and the next object is the <code class="literal">current</code> node. We have declared both objects without explicitly defining their scope, so they default to <code class="literal">package-private</code>, which is fine for our case. We want these fields to be private because we only permit the methods in this class to modify their values. Our constructor only instantiates the <code class="literal">route</code> because the <code class="literal">current</code> node will be assigned on an as-needed basis:</p><pre class="programlisting">    public void AddWaypoints(List&lt;Waypoint&gt; waypoints) 
    { 
        this.route.addAll(waypoints); 
    } 
 
    public boolean RemoveWaypoint(Waypoint waypoint) 
    { 
        return this.route.remove(waypoint); 
    } 
</pre><p class="calibre7">The <code class="literal">AddWaypoints(List&lt;Waypoint&gt;)</code> method allows us to add <span class="strong"><em class="calibre20">1..</em></span>.<span class="strong"><em class="calibre20">n</em></span> new waypoints to the existing route. We append objects to our list using the <code class="literal">LinkedList&lt;E&gt;.addAll()</code> method. This operation is quite simple and costs <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>). The <code class="literal">RemoveWaypoint(Waypoint)</code> method simply calls <code class="literal">LinkedList&lt;E&gt;.remove()</code> on the route, passing <code class="literal">waypoint</code> as a parameter. As this is technically a search operation, it costs <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>):</p><pre class="programlisting">    public void InsertWaypointsBefore(List&lt;Waypoint&gt; waypoints, Waypoint before) 
    { 
        int index = this.route.indexOf(before); 
        if (index &gt;= 0) 
        { 
            this.route.addAll(index, waypoints); 
        } else { 
            this.AddWaypoints(waypoints); 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">InsertWaypointsBefore(List&lt;Waypoint&gt;, Waypoint)</code> method gives our class the ability to create alternate routes and add intermediate destinations on the fly. First, we attempt to locate the <code class="literal">before</code> node using <code class="literal">LinkedList&lt;E&gt;.indexOf()</code>. The <code class="literal">indexOf()</code> method returns <code class="literal">-1</code> if it cannot find the object, so we confirm that the value is greater than <code class="literal">-1</code>; otherwise we immediately call <code class="literal">AddWaypoints(List&lt;Waypoint&gt;)</code> to append the new list of waypoints onto the route. If the <code class="literal">before</code> node is valid, we add the list of new waypoints before the <code class="literal">before</code> node.</p><p class="calibre7">This is the most expensive method operation in this class as it is a combination of a search and an insert. This means its operational cost is <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>+<span class="strong"><em class="calibre20">i</em></span>), where <span class="strong"><em class="calibre20">n</em></span> is the number of elements in the existing <code class="literal">route</code> and <span class="strong"><em class="calibre20">i</em></span> is the number of elements in the waypoints list:</p><pre class="programlisting">    public boolean StartRoute() 
    { 
        if (this.route.size() &gt; 1) 
        { 
            this.current = this.StartingLine(); 
            return this.MoveToNextWaypoint(); 
        } 
        return false; 
    } 
</pre><p class="calibre7">The <code class="literal">StartRoute()</code> method is used to set our initial current position and denote that it has been deactivated. Since our overall class represents a route, which is by definition a 2-dimensional object at the very least, the <code class="literal">StartRoute()</code> method immediately validates that <code class="literal">route</code> has at least two waypoints, and if not, we return <code class="literal">false</code> because <code class="literal">route</code> is not yet ready to be traversed. If we do have two or more waypoints, we set the <code class="literal">current</code> waypoint to the starting line and move to the next point. <code class="literal">StartRoute()</code> has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost:</p><pre class="programlisting">    public boolean MoveToNextWaypoint() 
    { 
        if (this.current != null) 
        { 
            this.current.DeactivateWaypoint(); 
            if (this.current != this.FinishLine()) 
            { 
                int index = this.route.indexOf(this.current); 
                this.current = this.route.listIterator(index).next(); 
                return true; 
            } 
            return false; 
        } 
        return false; 
    } 
 
    public boolean MoveToPreviousWaypoint() 
    { 
        if (this.current != null &amp;&amp; this.current != this.StartingLine()) 
        { 
            int index = this.route.indexOf(this.current); 
            this.current = this.route.listIterator(index).previous(); 
            this.current.ReactivateWaypoint(); 
            return true; 
        } 
        return false; 
    } 
</pre><p class="calibre7">The <code class="literal">MoveToNextWayPoint()</code> and <code class="literal">MoveToPreviousWaypoint()</code> methods introduce our route traversal functionality. In the <code class="literal">MoveToNextWaypoint()</code> method, we check whether the current waypoint is not <code class="literal">null</code>, and then we deactivate it. Next, we check whether we are not at the finish line, and if not, we set <code class="literal">current</code> to the next by assigning it to the <code class="literal">listIterator</code> property and the <code class="literal">next()</code> method of <code class="literal">route</code>, and then return <code class="literal">true</code>. The <code class="literal">MoveToPreviousWaypoint()</code> method verifies that <code class="literal">current</code> is not <code class="literal">null</code> and makes sure that we are not at the starting line. If so, we set <code class="literal">current</code> to the previous waypoint and reactivate it. If any of our checks in these two methods fail, we return <code class="literal">false</code>. Due to the need to search for a match for <code class="literal">current</code>, each of these methods has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>+1) operational cost:</p><pre class="programlisting">    public Waypoint StartingLine() 
    { 
        return this.route.getFirst(); 
    } 
 
    public Waypoint FinishLine() 
    { 
        return this.route.getLast(); 
    } 
 
    public Waypoint CurrentWaypoint() 
    { 
        return this.current; 
    } 
</pre><p class="calibre7">We add the <code class="literal">StartingLine()</code> and <code class="literal">FinishLine()</code> methods to expose the head and tail nodes of the route collection. Finally, we add the <code class="literal">CurrentPosition()</code> method to expose which node in the route is our next immediate destination. Each of these methods has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">Objective-C does not expose any implementation of a linked list out-of-the-box. Although we could create our own implementation, the purpose of this text is to demonstrate the best approach given the tools available. For this scenario, we will once again use the class cluster, <code class="literal">NSMutableArray</code>. Here's a simple example of how the <code class="literal">EDSWaypointList</code> class might be implemented in Objective-C:</p><pre class="programlisting">    @interface EDSWaypointList() 
    { 
        NSMutableArray *_route; 
        EDSWaypoint *_current; 
    } 
    -(instancetype)init 
    { 
        if (self = [super init]) 
        { 
            _route = [NSMutableArray array]; 
        } 
        return self; 
    } 
</pre><p class="calibre7">First, we declare two <code class="literal">ivar</code> properties. The first is <code class="literal">_route</code>, which is an <code class="literal">NSMutableArray</code> array. The next object is the <code class="literal">_current</code> node. Again, we have declared these as ivars because we only permit the methods in this class to modify their values. Our initializer only instantiates the <code class="literal">_route</code> because the <code class="literal">_current</code> node will be assigned on an as-needed basis:</p><pre class="programlisting">    -(void)addWaypoints:(NSArray*)waypoints 
    { 
        [_route addObjectsFromArray:waypoints]; 
    } 
 
    -(BOOL)removeWaypoint:(EDSWaypoint*)waypoint 
    { 
        if ([_route containsObject:waypoint]) 
        { 
            [_route removeObject:waypoint]; 
            return YES; 
        } 
        return NO; 
    } 
</pre><p class="calibre7">The <code class="literal">addWaypoints:</code> method allows us to add <span class="strong"><em class="calibre20">1...n</em></span> new waypoints to the existing route. <code class="literal">NSMutableArray</code> allows us to merge the new array with the existing route by calling <code class="literal">addObjectsFromArray:</code>. This operation is quite simple and costs <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>).</p><p class="calibre7">The <code class="literal">removeWaypoint:</code> method confirms that <code class="literal">_route</code> contains <code class="literal">waypoint</code> using <code class="literal">containsObject:</code>, then calls <code class="literal">removeObject:</code>. If we were not concerned with the success or failure of this operation, we could have simply called <code class="literal">removeObject:</code> and moved on. Note that, since our <code class="literal">_route</code> object is an array-backed list, it allows for <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) search operations. Since we do not know the index of waypoint in advance, the <code class="literal">removeObject:</code> operation still costs <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>):</p><pre class="programlisting">    -(void)insertWaypoints:(NSArray*)waypoints beforeWaypoint:(EDSWaypoint*)before 
    { 
        NSUInteger index = [_route indexOfObject:before]; 
        if (index == NSNotFound) 
        { 
            [self addWaypoints:waypoints]; 
        } else { 
            NSRange range = NSMakeRange(index, [waypoints count]); 
            NSIndexSet *indexSet = [NSIndexSetindexSetWithIndexesInRange:range]; 
            [_route insertObjects:waypoints atIndexes:indexSet]; 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">insertWaypoints:beforeWaypoint:</code> method gives our class the ability to create alternate routes and add intermediate destinations on the fly. First, we attempt to locate the <code class="literal">before</code> node using <code class="literal">indexOfObject:</code>. If we cannot find it, we immediately call <code class="literal">addWaypoints:</code> to append the new list of waypoints onto the route. Otherwise, we create some ugly code to define an <code class="literal">NSRange</code> object and an <code class="literal">NSIndexSet</code> object, and use these with <code class="literal">insertObjects:atIndexes:</code>. Since this method represents a search and an insert, its operational cost is <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>+1), where <span class="strong"><em class="calibre20">n</em></span> is the number of elements in the existing <code class="literal">_route</code> object:</p><pre class="programlisting">    -(BOOL)startRoute 
    { 
        if ([_route count] &gt; 1) 
        { 
            _current = [self startingLine]; 
            return [self moveToNextWaypoint]; 
        } 
        return NO; 
    } 
</pre><p class="calibre7">The <code class="literal">startRoute:</code> method is used to set our initial current position and denote that it has been deactivated. Since our overall class represents a route, which is by definition a 2-dimensional object at the very least, the <code class="literal">startRoute:</code> method immediately validates that <code class="literal">_route</code> has at least two waypoints; if not we return <code class="literal">NO</code> because the route is not yet ready to be traversed. If we do have two or more waypoints, we set the <code class="literal">_current</code> waypoint to the starting line and move to the next point. <code class="literal">startRoute:</code> has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</p><pre class="programlisting">    -(BOOL)moveToNextWaypoint 
    { 
        if (_current) 
        { 
            [_current deactivateWaypoint]; 
            if (_current != [self finishLine]) 
            { 
                NSUInteger index = [_route indexOfObject:_current]; 
                _current = [_route objectAtIndex:index+1]; 
                return YES; 
            } 
            return NO; 
        } 
        return NO; 
    } 
 
    -(BOOL)moveToPreviousWaypoint 
    { 
        if (_current &amp;&amp; _current != [self startingLine]) 
        { 
            NSUInteger index = [_route indexOfObject:_current]; 
            _current = [_route objectAtIndex:index-1]; 
            [_current reactivateWaypoint]; 
            return YES; 
        } 
        return NO; 
    } 
</pre><p class="calibre7">In <code class="literal">moveToNextWaypoint:</code>, we check whether the current waypoint is not <code class="literal">nil</code>, and then we deactivate it. Next, we verify that we are not at the finish line, and if not, we get the index of <code class="literal">_current</code> in the list and assign the next highest index object to the property, then return <code class="literal">YES</code>. The <code class="literal">moveToPreviousWaypoint:</code> method verifies that <code class="literal">_current</code> is not <code class="literal">nil</code>, and makes sure that we are not at the starting line. If so, we set <code class="literal">_current</code> to the previous waypoint and reactivate it, and then we return <code class="literal">YES</code>. If any of our checks in these two methods fail, we return <code class="literal">NO</code>. Due to the need to search for a match for <code class="literal">_current</code>, each of these methods has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>+1) operational cost:</p><pre class="programlisting">    -(EDSWaypoint*)startingLine 
    { 
        return [_route firstObject]; 
    } 
 
    -(EDSWaypoint*)finishLine 
    { 
        return [_route lastObject]; 
    } 
 
    -(EDSWaypoint*)currentWaypoint 
    { 
        return _current; 
    } 
</pre><p class="calibre7">We add the <code class="literal">startingLine:</code> and <code class="literal">finishLine:</code> methods to expose the head and tail nodes of the route collection. Finally, we add the <code class="literal">currentPosition:</code> method to expose which node in the route is our next immediate destination. Each of these methods has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Similar to Objective-C, Swift does not expose any implementation of a linked list data structure. Therefore, we will use the Swift <code class="literal">Array</code> class to create our data structure. Here's a simple example of how this class might be implemented using Swift:</p><pre class="programlisting">    var _route: Array = [Waypoint]() 
    var _current: Waypoint?  
    init() { } 
</pre><p class="calibre7">First, we declare two properties. The first is <code class="literal">_route</code>, which is an array. The next object is the <code class="literal">_current</code> node, which is a <code class="literal">Waypoint</code> object, flagged as <code class="literal">optional</code>. Again, we have declared these as private because we only permit the methods in this class to modify their values. Our initializer does not need to instantiate either object because the declaration instantiates <code class="literal">_route</code>, and <code class="literal">_current</code> is flagged as <code class="literal">optional</code> and will only be assigned on an as-needed basis:</p><pre class="programlisting">    public func addWaypoints(waypoints: Array&lt;Waypoint&gt;) 
    { 
        _route.appendContentsOf(waypoints) 
    } 
 
    public func removeWaypoint(waypoint: Waypoint) -&gt; Bool 
    { 
        if let index = _route.indexOf(waypoint) 
        { 
            _route.removeAtIndex(index) 
            return true 
        } 
        return false 
    } 
</pre><p class="calibre7">The <code class="literal">addWaypoints(Array&lt;Waypoint&gt;)</code> method allows us to add <span class="strong"><em class="calibre20">1..</em></span>.<span class="strong"><em class="calibre20">n</em></span> new waypoints to the existing route. <code class="literal">Array</code> allows us to merge the new array with the existing route by calling <code class="literal">appendContentsOf(Array)</code>. This operation is quite simple and costs <span class="strong"><strong class="calibre16">O</strong></span>(1).</p><p class="calibre7">The <code class="literal">removeWaypoint(Waypoint)</code> method confirms that <code class="literal">_route</code> contains <code class="literal">waypoint</code> and gets its index in one operation by calling <code class="literal">if .. indexOf()</code>. If we do not retrieve an index, we return <code class="literal">false</code>, otherwise we call <code class="literal">removeAtIndex()</code> and return <code class="literal">true</code>. Note that, since our <code class="literal">_route</code> object is an array-backed list, the <code class="literal">removeAtIndex()</code> operation only costs <span class="strong"><strong class="calibre16">O</strong></span>(1):</p><pre class="programlisting">    public func insertWaypoints(waypoints: Array&lt;Waypoint&gt;, before: Waypoint) 
    { 
        if let index = _route.indexOf(before) 
        { 
            _route.insertContentsOf(waypoints, at:index) 
        } else { 
            addWaypoints(waypoints) 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">insertWaypoints(Array&lt;Waypoint&gt;, Waypoint)</code> method first attempts to locate the <code class="literal">before</code> node using <code class="literal">if..indexOf()</code>. If we cannot find it, we immediately call <code class="literal">addWaypoints()</code> to append the new list of waypoints onto the route. Otherwise, we call <code class="literal">insertContentOf()</code>. Since this method represents a search and an insert, its operational cost is <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>+1), where <span class="strong"><em class="calibre20">n</em></span> is the number of elements in the existing _<code class="literal">route</code>:</p><pre class="programlisting">    public func startRoute() -&gt; Bool 
    { 
        if _route.count &gt; 1 
        { 
            _current = startingLine() 
            return moveToNextWaypoint() 
        } 
        return false 
    } 
</pre><p class="calibre7">The <code class="literal">startRoute:</code> object is used to set our initial current position and denote that it has been deactivated. If we have two or more waypoints, we set the <code class="literal">_current</code> waypoint to the starting line and move to the next point. The <code class="literal">startRoute()</code> object has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost:</p><pre class="programlisting">    public func moveToNextWaypoint() -&gt; Bool 
    { 
        if (_current != nil) 
        { 
            _current!.DeactivateWaypoint() 
            if _current != self.finishLine() 
            { 
                let index = _route.indexOf(_current!) 
                _current = _route[index!+1] 
                return true 
            } 
            return false; 
        } 
        return false 
    } 
 
    public func moveToPreviousWaypoint() -&gt; Bool 
    { 
        if (_current != nil &amp;&amp; _current != self.startingLine()) 
        { 
            let index = _route.indexOf(_current!) 
            _current = _route[index!-1] 
            _current!.ReactivateWaypoint() 
            return true 
        } 
    return false 
} 
</pre><p class="calibre7">In <code class="literal">moveToNextWaypoint()</code>, we verify that the current waypoint is not <code class="literal">nil</code>, and then we deactivate it. Next, we confirm that we are not at the finish line; and if not, we get the index of <code class="literal">_current</code> in the list, and assign the next highest index object to <code class="literal">_current</code>, and then we return <code class="literal">true</code>. The <code class="literal">moveToPreviousWaypoint()</code> method verifies that <code class="literal">_current</code> is not <code class="literal">nil</code> and makes sure that we are not at the starting line. If so, we set <code class="literal">_current</code> to the previous waypoint, reactivate it, and return <code class="literal">YES</code>. If any of our checks in these two methods fail, we return <code class="literal">NO</code>. Due to the need to search for a match for <code class="literal">_current</code>, each of these methods has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>+1) operational cost:</p><pre class="programlisting">    public func startingLine() -&gt; Waypoint 
    { 
        return _route.first! 
    } 
 
    public func finishLine() -&gt; Waypoint 
    { 
        return _route.last! 
    } 
 
    public func currentWaypoint() -&gt; Waypoint 
    { 
        return _current!; 
    } 
</pre><p class="calibre7">We add the <code class="literal">startingLine()</code> and <code class="literal">finishLine()</code> methods to expose the head and tail nodes of the route collection. Finally, we add the <code class="literal">currentPosition()</code> method to expose which node in the route is our next immediate destination. Each of these methods has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</p></div></div>
<div class="book" title="Doubly linked list" id="NQU21-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec17" class="calibre1"/>Doubly linked list</h1></div></div></div><p class="calibre7">A doubly linked list has the added overhead of <span class="strong"><em class="calibre20">n</em></span> additional pointers where <span class="strong"><em class="calibre20">n</em></span> is the length of the list. This additional pointer provides for simple reverse-traversal of the list. The added overhead is somewhat negligible and can typically be ignored except in very special cases. The append, insert, and remove operations still only cost <span class="strong"><strong class="calibre16">O</strong></span>(1).
</p></div>
<div class="book" title="Searching" id="OPEK1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec18" class="calibre1"/>Searching</h1></div></div></div><p class="calibre7">Array backed lists provides a <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost for searches if the index of the object is known in advance. Otherwise, all searches in lists cost <span class="strong"><strong class="calibre16">O</strong></span>(n) for unsorted lists and <span class="strong"><strong class="calibre16">O</strong></span>(log <span class="strong"><em class="calibre20">n</em></span>) for sorted lists where a binary search pattern is applied. Binary search algorithms will be discussed in much greater detail in <a class="calibre1" title="Chapter 13. Searching: Finding What You Need" href="part0076_split_000.html#28FAO1-77f2b5b248f04368a6f723b0e9357ef3">Chapter 13</a>, <span class="strong"><em class="calibre20">Searching: Finding What You Need</em></span>.</p></div>
<div class="book" title="A few pointers" id="PNV61-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec19" class="calibre1"/>A few pointers</h1></div></div></div><p class="calibre7">Many languages view memory as a series of successive cells, each a certain number of bytes in size and each with a unique address. Pointers are memory management tools, which are really objects that reference, or point to, a memory cell's address. By utilizing pointers, a program can store objects in memory that are themselves larger than a single memory block. Some languages use the <code class="literal">*</code> operator to denote the assignment of a pointer. If you use Objective-C, or if you have worked with C/C++, you will already be very familiar with this operator. C#, Java, and Swift developers won't have had too much experience with this operator, but you should be familiarize yourself with how pointers work anyway, and here's why:</p><p class="calibre7">When an object in memory no longer has a pointer referencing its memory address, it should be de-allocated or removed from memory. Removing unused objects to prevent them from filling up memory is known as <span class="strong"><strong class="calibre16">memory management</strong></span>. In some older languages, managing memory pointers is a tedious and often bug-prone task for the uninitiated. Most modern languages spare us from this drudgery through the use of some form of memory management device. C#, Java, and Swift use what's known as <span class="strong"><strong class="calibre16">Garbage Collection</strong></span> (<span class="strong"><strong class="calibre16">GC</strong></span>), while modern Objective-C provides <span class="strong"><strong class="calibre16">Automatic Reference Counting</strong></span> (<span class="strong"><strong class="calibre16">ARC</strong></span>) for automatic memory management.</p><p class="calibre7">Although these tools are great, you should not rely too completely on GC or ARC to manage your memory. GC and ARC are not perfect to start with, but both can be thwarted by a poor implementation. What will separate programmers from engineers is the ability to diagnose and repair memory management issues. Understanding pointers and their use will better equip you to catch what GC or ARC can very often miss.</p><p class="calibre7">A deeper discussion on pointers is beyond the scope of this book, but you should definitely take the time to research and familiarize yourself with this topic. Better still, spend some time writing code in a language that utilizes manual memory management like C or C++. Your career will thank you.</p></div>
<div class="book" title="Summary" id="QMFO1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec20" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, you learned the basic definition of the list structure, including the difference between sorted and unsorted list and array-backed versus linked lists. We discussed how to initialize lists or pseudo lists in each of the four languages we utilize in this text. We revisited the logged-in users class to see if we could improve its performance using lists instead of arrays and learned about interesting differences between the four languages including their use of generics and class clusters in the process. Next, we created a class to represent a route for biking enthusiasts, taking advantage of the properties of linked lists to manipulate and dynamically alter our collection of waypoints on the fly.</p><p class="calibre7">In our advanced topics section, we examined different implementations of list structures in more detail, including array-based lists, (singly) linked lists, and doubly linked lists. Finally, for each implementation, we evaluated the performance of basic operations including appending, inserting, removing, and searching nodes.</p></div></body></html>