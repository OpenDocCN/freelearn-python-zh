- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have worked on various aspects of network automation with Python, Ansible,
    and many other tools. In the examples you have been following along with in the
    first 13 chapters of this book, we have used over 150 files containing over 5,300
    lines of code. That’s pretty good for network engineers who may have been working
    primarily with the command-line interface before reading this book! With our new
    scripts and tools, we are ready to go out and conquer our network tasks, right?
    Well, not so fast, my fellow network ninjas.
  prefs: []
  type: TYPE_NORMAL
- en: There are several things we need to consider before we get into the meat of
    the tasks. We’ll run through these considerations and talk about how the version-control
    (or source-control) system Git can help us out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Content management considerations and Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git usage examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating configuration backup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborating with Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let’s talk about what exactly are these considerations and the role Git
    can play in helping us to manage them.
  prefs: []
  type: TYPE_NORMAL
- en: Content management considerations and Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that we must consider when creating code files is how to keep
    them in a location where they can be retrieved and used by us and others. Ideally,
    this location would be the only central place where the file is kept but also
    have backup copies available if needed. After the initial release of the code,
    we might add features and fix bugs in the future, so we would like a way to track
    these changes and keep the latest ones available for download. If the new changes
    do not work, we would like ways to roll back the changes and reflect the differences
    in the history of the file. This would give us a good idea of the evolution of
    the code files.
  prefs: []
  type: TYPE_NORMAL
- en: The second question is about the collaborative process between our team members.
    If we work with other network engineers, we will most likely need to work collectively
    on the files. These can be Python scripts, Ansible Playbooks, Jinja2 templates,
    INI-style configuration files, and many others. The point is that any kind of
    text-based file should be tracked with multiple inputs that everybody on the team
    should be able to see.
  prefs: []
  type: TYPE_NORMAL
- en: The third question is accountability. Once we have a system that allows for
    multiple inputs and changes, we need to mark these changes with an appropriate
    track record to reflect the owner of the change. The track record should also
    include a brief reason for the change so that the person reviewing the history
    can get an understanding of why the change was made.
  prefs: []
  type: TYPE_NORMAL
- en: These are some of the main challenges a version-control (or source-control)
    system, such as Git, tries to solve. To be fair, the process of version control
    can exist in forms other than a dedicated software system. For example, if I open
    my Microsoft Word program, the file constantly saves itself, and I can go back
    in time to revisit the changes or roll back to a previous version. That is one
    form of version control; however, the Word doc is hard to scale beyond my laptop.
    The version-control system we are focused on in this chapter is a standalone software
    tool with the primary purpose of tracking software changes.
  prefs: []
  type: TYPE_NORMAL
- en: There is no shortage of different source-control tools in software engineering,
    both proprietary and open-source. Some popular open-source version-control systems
    are CVS, SVN, Mercurial, and Git. In this chapter, we will focus on the source-control
    system Git. Many of the software we have used in this book use the same version
    control system to track changes, collaborate on features, and communicate with
    its users. We will be taking a more in-depth look at the tool. Git is the de facto
    version-control system for many large, open-source projects, including Python
    and the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of February 2017, the CPython development process has moved to GitHub. It
    has been a work in progress since January 2015\. For more information, check out
    PEP 512 at: [https://www.python.org/dev/peps/pep-0512](https://www.python.org/dev/peps/pep-0512).'
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the working examples of Git, let’s look at the history and
    advantages of the Git system.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git was created by Linus Torvalds, the creator of the Linux kernel, in April
    2005\. With his dry wit, he has affectionately called the tool “the information
    manager from hell.” In an interview with the Linux Foundation, Linus mentioned
    that he felt source-control management was just about the least interesting thing
    in the computing world ([https://www.linuxfoundation.org/blog/2015/04/10-years-of-git-an-interview-with-git-creator-linus-torvalds/](https://web.archive.org/web/20210419173925/https://www.linuxfoundation.org/blog/2015/04/10-years-of-git-an-interview-with-git-creator-linus-torvalds/)).
    Nevertheless, he created the tool after a disagreement between the Linux kernel
    developer community and BitKeeper, the proprietary system they were using at the
    time.
  prefs: []
  type: TYPE_NORMAL
- en: What does the name Git stand for? In British English slang, a git is an insult
    denoting an unpleasant, annoying, childish person. With his dry humor, Linus said
    he is an egotistical bastard and that he named all of his projects after himself.
    First Linux, now Git. However, some suggested that the name is short for **Global
    Information Tracker** (**GIT**). You can be the judge of which explanation you
    like better.
  prefs: []
  type: TYPE_NORMAL
- en: The project came together quickly. About 10 days after its creation (yeah, you
    read that right), Linus felt the basic ideas for Git were right and started to
    commit the first Linux kernel code with Git. The rest, as they say, is history.
    More than ten years after its creation, it is still meeting all the expectations
    of the Linux kernel project. It took over as the version-control system for many
    other open-source projects despite many developers’ inherent inertia in switching
    source-control systems. For the Python code base, after many years of hosting
    the code at Mercurial ([https://hg.python.org/](https://hg.python.org/)), the
    project was switched to Git on GitHub in February 2017.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve been through the history of Git let’s take a look at some of
    its benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The success of hosting large and distributed open-source projects, such as the
    Linux kernel and Python, speaks to the advantages of Git. I mean, if this tool
    is good enough for the software development for the most popular operating system
    (in my opinion) and the most popular programming language (again, my opinion only)
    in the world, it is probably good enough for my hobby project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The popularity of Git is especially significant given that it is a relatively
    new source-control tool, and people do not tend to switch to a new tool unless
    it offers significant advantages over the old tool. Let’s look at some of the
    benefits of Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed development**: Git supports parallel, independent, and simultaneous
    development in private repositories offline. Many other version control systems
    require constant synchronization with a central repository. The distributed and
    offline nature of Git allows significantly greater flexibility for the developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale to handle thousands of developers**: The number of developers working
    on different parts of some open-source projects is in the thousands. Git supports
    the integration of their work reliably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Linus was determined to make sure Git was fast and efficient.
    To save space and transfer time for the sheer volume of updates for the Linux
    kernel code alone, compression and a delta check were used to make Git fast and
    efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accountability and immutability**: Git enforces a change log on every commit
    that changes a file, so there is a trail for all the changes and the reason behind
    them. The data objects in Git cannot be modified after they are created and placed
    in the database, making them immutable. This further enforces accountability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atomic transactions**: The integrity of the repository is ensured as the
    different but related change is performed either altogether or not at all. This
    will ensure the repository is not left in a partially changed or corrupted state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complete repositories**: Each repository has a complete copy of all historical
    revisions of every file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Free, as in freedom**: The origin of the Git tool was born out of the disagreement
    between Linux and BitKeeper VCS as to whether software should be free and whether
    one should reject commercial software on principle, so it makes sense that the
    tool has a very liberal usage license.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at some of the terms used in Git before we go deeper into it.
  prefs: []
  type: TYPE_NORMAL
- en: Git Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some Git terms we should be familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ref**: The name that begins with `refs` and points to an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository**: This is a database that contains all of a project’s information,
    files, metadata, and history. It contains a collection of refs for all the collections
    of objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branch**: This is an active line of development. The most recent commit is
    the `tip` or the `HEAD` of that branch. A repository can have multiple branches,
    but your `working tree` or `working directory` can only be associated with one
    branch. This is sometimes referred to as the current or `checked out` branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checkout**: This is the action of updating all or part of the working tree
    to a particular point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commit**: This is a point in time in Git history, or it can mean storing
    a new snapshot in the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Merge**: This is the action to bring the content of another branch into the
    current branch. For example, I am merging the `development` branch with the `master`
    branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fetch**: This is the action of getting the content from a remote repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pull**: Fetching and merging a repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tag**: This is a mark at a point in time in a repository that is significant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not a complete list; please refer to the Git glossary, [https://git-scm.com/docs/gitglossary](https://git-scm.com/docs/gitglossary),
    for more terms and their definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, before getting into the actual setup and uses of Git, let’s talk about
    the important distinction between Git and GitHub; one that is easily overlooked
    by engineers unfamiliar with the two.
  prefs: []
  type: TYPE_NORMAL
- en: Git and GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git and GitHub are not the same things. Sometimes, for engineers who are new
    to version-control systems, this is confusing. Git is a revision-control system,
    while GitHub, [https://github.com/](https://github.com/), is a centralized hosting
    service for Git repositories. The company, GitHub, was launched in 2008 and was
    acquired by Microsoft in 2018 but continued to operate independently.
  prefs: []
  type: TYPE_NORMAL
- en: Because Git is a decentralized system, GitHub stores a copy of our project’s
    repository, just like any other distributed offline copies. We often designate
    the GitHub repository as the project’s central repository, and all other developers
    push and pull their changes to and from that repository.
  prefs: []
  type: TYPE_NORMAL
- en: After GitHub was acquired by Microsoft in 2018, [https://blogs.microsoft.com/blog/2018/10/26/microsoft-completes-github-acquisition/](https://blogs.microsoft.com/blog/2018/10/26/microsoft-completes-github-acquisition/),
    many in the developer community worried about the independence of GitHub. As described
    in the press release, “GitHub will retain its developer-first ethos, operate independently,
    and remain an open-source platform.” GitHub takes this idea of being the centralized
    repository in a distributed system further by using the `fork` and `pull` `requests`
    mechanisms. For projects hosted on GitHub, the project maintainers typically encourage
    other developers to `fork` the repository, or make a copy of the repository, and
    work on it as their copied repository.
  prefs: []
  type: TYPE_NORMAL
- en: After making changes, they can send a `pull` `request` to the main project,
    and the project maintainers can review the changes and `commit` the changes if
    they see fit. GitHub also adds the web interface to the repositories beside the
    command line; this makes Git more user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve differentiated Git and GitHub, we can start properly! First,
    let’s talk about setting up Git.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using Git just to download files from GitHub. In this section,
    we will go a bit further by setting up Git locally so we can start committing
    our files. I will use the same Ubuntu 22.04 LTS management host in the example.
    If you are using a different version of Linux or other operating systems, a quick
    search of the installation process should land you in the right set of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not done so already, install Git via the `apt` package-management
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `git` is installed, we need to configure a few things so that our commit
    messages can contain the correct information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can modify the information in the `~/.gitconfig` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many options in Git that we can change, but the name and email are
    the ones that allow us to commit the change without getting a warning. Personally,
    I like to use the Vim text editor, instead of the default Emac, for typing commit
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Before we move on to using Git, let’s go over the idea of a `gitignore` file.
  prefs: []
  type: TYPE_NORMAL
- en: Gitignore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are files you do not want Git to check into GitHub or other repositories,
    such as files with passwords, API keys, or other sensitive information. The easiest
    way to prevent files from being accidentally checked into a repository is to create
    a .`gitignore` file in the repository’s top-level folder. Git will use the `gitignore`
    file to determine which files and directories should be ignored before committing.
    The `gitignore` file should be committed to the repository as early as possible
    and be shared with other users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the panic you would feel if you accidentally checked your group API
    key into a public Git repository. It is usually helpful to create the `gitignore`
    file when creating a new repository. In fact, GitHub provides an option to do
    just that when you create a repository on its platform. This file can include
    language-specific files. For example, let’s exclude the Python `Byte-compiled`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also include files that are specific to your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can learn more about `.gitignore` on GitHub’s help page: [https://help.github.com/articles/ignoring-files/](https://help.github.com/articles/ignoring-files/).
    Here are some other references:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gitignore manual: [https://git-scm.com/docs/gitignore](https://git-scm.com/docs/gitignore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub’s collection of `.gitignore` templates: [https://github.com/github/gitignore](https://github.com/github/gitignore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python language `.gitignore` example: [https://github.com/github/gitignore/blob/master/Python.gitignore](https://github.com/github/gitignore/blob/master/Python.gitignore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `.gitignore` file for this book’s repository: [https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition/blob/main/.gitignore](https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition/blob/main/.gitignore).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I see the `.gitignore` file as a file that should be created simultaneously
    with any new repository. That is why this concept is introduced as early as possible.
    We will look at some of the Git usage examples in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Git Usage Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In my experience, when we work with Git, we will likely use the command line
    and the various options. The graphical tools are useful when we need to trace
    back changes, look at logs, and compare commit differences, but we rarely use
    them for normal branching and commits. We can look at Git’s command-line option
    by using the `help` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a `repository` and create a file inside the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the repository was initialized with Git, a new hidden folder of `.git`
    was added to the directory. It contains all the Git-related files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several locations where Git receives its configurations in a hierarchical
    format. The files are read from the `system`, `global`, and `repository` by default.
    The more specific the repository’s location, the higher the override preference.
    For example, the repository configuration will override the global configuration.
    You can use the `git config -l` command to see the aggregated configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create a file in the repository, it is not tracked. For `git` to be
    aware of the file, we need to add the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you add the file, it is in a staged status. To make the changes official,
    we will need to commit the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the last example, we provided the `commit` message with the `-m` option when
    we issued the `commit` statement. If we did not use the option, we would have
    been taken to a page to provide the commit message. In our scenario, we configured
    the text editor to be Vim, so we can use it to edit the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make some changes to the file and `commit` it again. Notice that after
    the file has been changed, Git knows the file has been modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `git commit` number is an `SHA-1 hash`, which is an important feature. If
    we had followed the same step on another computer, our `SHA-1 hash` value would
    be the same. This is how Git knows the two repositories are identical even when
    they are worked on in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have ever wondered about the `SHA-1 hash` value being accidentally or
    purposely modified to overlap, there is an interesting article on the GitHub blog
    about detecting this `SHA-1 hash` collision: [https://github.blog/2017-03-20-sha-1-collision-detection-on-github-com/](https://github.blog/2017-03-20-sha-1-collision-detection-on-github-com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can show the history of the commits with `git log`. The entries are shown
    in reverse chronological order; each commit shows the author’s name and email
    address, the date, the log message, as well as the internal identification number
    of the commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also show more details about the change using the commit ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to revert the changes you have made, you can choose between `revert`
    and `reset`. The former changes all the files for a specific commit back to their
    state before the commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `revert` command will keep the `commit` you reverted and make a new `commit`.
    You will be able to see all the changes up to that point, including the revert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reset` option will reset the status of your repository to an older version
    and discard all the changes in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I like to keep all the history, including any rollbacks I have done. Therefore,
    when I need to roll back a change, I usually pick `revert` instead of `reset`.
    In this section, we have seen how we can work with individual files. In the next
    section, let’s look at how we can work with a collection of files that is grouped
    into a particular `bundle`, called `branch`.
  prefs: []
  type: TYPE_NORMAL
- en: Git Branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `branch` in `git` is a line of development within a repository. Git allows
    many branches and thus different lines of development within a repository. By
    default, we have the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few years back, the default branch for GitHub was renamed “main”: [https://github.com/github/renaming](https://github.com/github/renaming).
    We will see both in the field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many reasons for branching; there are no hard-set rules about when
    to branch or work on the master/main branch directly. Most of the time, we create
    a branch when there is a bug fix, a customer software release, or a development
    phase. In our example, let us create a branch that represents development, appropriately
    named the `dev` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we need to specifically move into the `dev branch` after creation. We
    do that with `checkout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add a second file to the `dev` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can go back to the `master` branch and verify that the two lines of development
    are separate. Note that when we switch to the master branch, there is only one
    file in the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To have the contents in the `dev` branch be written into the `master` branch,
    we will need to `merge` them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `git rm` to remove a file. To see how it works, let’s create a third
    file and remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be able to see the last two changes in the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have gone through most of the basic operations we would use for Git. Let’s
    look at how to use GitHub to share our repository.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will use GitHub as the centralized location to synchronize
    our local repository and share it with other users.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a repository on GitHub. GitHub has always been free for creating
    public open-source repositories. Starting in January 2019, it also offers unlimited
    free private repositories. In this case, we will create a private repository and
    add the license and `.gitignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Creating a private repository in GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the repository is created, we can find the URL for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_14_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: GitHub repository URL'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use this URL to create a remote target, which we will use as a “source
    of truth” for our project. We will name the remote target `gitHubRepo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since we chose to create `README.md` and `LICENSE` files during creation, the
    remote repository and local repository are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub switched to a **Personal Access Token** (**PAT**) as the term to be
    entered as a password a few years ago: [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).
    To generate a token, click on the profile logo **-> Settings -> Developer settings
    -> Personal Access Tokens**. We need to use this token as our password when prompted
    in the command line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to push local changes to the new GitHub repository, we would receive
    the following error (remember to change the branch name to main if that is your
    default branch):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will go ahead and use `git pull` to get the new files from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will be able to `push` the contents over to GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the content of the GitHub repository on the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_14_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: GitHub repository'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now another user can simply make a copy, or `clone`, of the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This copied repository will be the exact copy of my original repository, including
    all the commit history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'I can also invite another person as a collaborator for the project under the
    repository settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_14_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Repository invite'
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we will see how we can fork a repository and perform a
    pull request for a repository we do not maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborating with Pull Requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned, Git supports collaboration between developers for a single project.
    We will look at how it is done when the code is hosted on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will use the GitHub repository for the second edition of this
    book from Packt’s GitHub public repository. I will use a different GitHub handle,
    so I appear as a non-administrative user. I will click on the **Fork** button
    to make a copy of the repository in my account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18403_14_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: Git Fork button'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will take a few seconds to make a copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, website  Description automatically generated](img/B18403_14_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: Git Fork in progress'
  prefs: []
  type: TYPE_NORMAL
- en: 'After it is forked, we will have a copy of the repository in our account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_14_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: Git Fork'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can follow the same steps we used to modify the files. In this case, I will
    make some changes to the `README.md` file. After the change is made, I can click
    on the **New pull request** button to create a pull request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_14_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Pull request'
  prefs: []
  type: TYPE_NORMAL
- en: 'When making a pull request, we should fill in as much information as possible
    to provide justifications for making the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_14_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Pull request details'
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository maintainer will receive a notification of the pull request;
    if accepted, the change will make its way to the original repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_14_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: Pull request record'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub provides an excellent platform for collaboration with other developers;
    this is quickly becoming the de facto development choice for many large, open-source
    projects. Since Git and GitHub are used extensively in many projects, a natural
    next step would be to automate the processes we have seen in this section. In
    the following section, let’s look at how we can use Git with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Git with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some Python packages that we can use with Git and GitHub. In this
    section, we will look at the GitPython and PyGitHub libraries.
  prefs: []
  type: TYPE_NORMAL
- en: GitPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the GitPython package, [https://gitpython.readthedocs.io/en/stable/index.html](https://gitpython.readthedocs.io/en/stable/index.html),
    to work with our Git repository. We will install the package and use the Python
    shell to construct a `Repo` object. From there, we can list all the commits in
    the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also look at the index entries in the `repo` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: GitPython offers good integration with all the Git functions. However, it might
    not be the easiest library to work with for beginners. We need to understand the
    terms and structure of Git to take full advantage of GitPython, and it is always
    good to keep it in mind if we need it for other projects.
  prefs: []
  type: TYPE_NORMAL
- en: PyGitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at using the PyGithub library, [http://pygithub.readthedocs.io/en/latest/](http://pygithub.readthedocs.io/en/latest/),
    to interact with GitHub reappearing around GitHub API v3, [https://developer.github.com/v3/](https://developer.github.com/v3/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use the Python shell to print out the user’s current repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For more programmatic access, we can also create more granular control using
    an access token. GitHub allows a token to be associated with the selected rights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B18403_14_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: GitHub token generation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is a bit different if you use the access token as the authentication
    mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are familiar with Git, GitHub, and some Python packages, we can
    use them to work with the technology. We will look at some practical examples
    in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Configuration Backup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will use PyGithub to back up a directory containing our
    router configurations. We have seen how we can retrieve the information from our
    devices with Python or Ansible; we can now check them into GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a subdirectory, named `config`, with our router configs in text format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following script, `Chapter14_1.py`, to retrieve the latest index
    from our GitHub repository, build the content that we need to commit, and automatically
    commit the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the `configs` directory in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_14_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: Conﬁgs directory'
  prefs: []
  type: TYPE_NORMAL
- en: 'The commit history shows the commit from our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_14_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: Commit history'
  prefs: []
  type: TYPE_NORMAL
- en: In the GitHub example section, we saw how we could collaborate with other developers
    by forking the repository and making pull requests. Let’s look at how we can further
    collaborate with Git.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborating with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is an awesome collaboration technology, and GitHub is an incredibly effective
    way to develop projects together. GitHub provides a place for anyone in the world
    with internet access to share their thoughts and code for free. We know how to
    use Git and some basic collaboration steps using GitHub, but how do we join and
    contribute to a project?
  prefs: []
  type: TYPE_NORMAL
- en: Sure, we would like to give back to these open-source projects that have given
    us so much, but how do we get started?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at some of the things to know about software development
    collaboration using Git and GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start small**: One of the most important things to understand is the role
    we can play within a team. We might be awesome at network engineering, but mediocre
    at Python development. There are plenty of things we can do that don’t involve
    being a highly skilled developer. Don’t be afraid to start small; documentation
    and testing are two good ways to get your foot in the door as a contributor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learn the ecosystem**: With any project, large or small, there is a set of
    conventions and a culture that has been established. We are all drawn to Python
    for its easy-to-read syntax and beginner-friendly culture; it also has a development
    guide centered around that ideology ([https://devguide.python.org/](https://devguide.python.org/)).
    The Ansible project, on the other hand, also has an extensive community guide
    ([https://docs.ansible.com/ansible/latest/community/index.html](https://docs.ansible.com/ansible/latest/community/index.html)).
    It includes the code of conduct, the pull request process, how to report bugs,
    and the release process. Read these guides and learn the ecosystem for the project
    of interest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make a branch**: I made the mistake of forking a project and making a pull
    request for the main branch. The main branch should be left alone for the core
    contributors to make changes. We should create a separate branch for our contribution
    and allow the branch to be merged later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep the forked repository synchronized**: Once you have forked a project,
    no rule forces the cloned repository to sync with the main repository. We should
    make a point to regularly do `git pull` (get the code and merge locally) or `git`
    `fetch` (get the code with any change locally) to ensure we have the latest copy
    of the main repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be friendly**: Just as in the real world, the virtual world has no place
    for hostility. When discussing an issue, be civil and friendly, even in disagreements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git and GitHub provide a way for any motivated individual to make a difference
    by making it easy to collaborate on projects. We are all empowered to contribute
    to any open source or private projects that interest us.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the version-control system known as Git and its
    close sibling, GitHub. Git was developed by Linus Torvolds in 2005 to help develop
    the Linux kernel and was later adopted by other open-source projects as their
    source-control system. Git is a fast, distributed, and scalable system. GitHub
    provides a centralized location to host Git repositories on the internet that
    allows anybody with an internet connection to collaborate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We looked at how to use Git in the command line and its various operations
    and how they are applied in GitHub. We also studied two popular Python libraries
    for working with Git: GitPython and PyGithub. We ended this chapter with a configuration
    backup example and notes about project collaboration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 15*,*Continuous Integration with GitLab*, we will look at another
    popular open-source tool used for continuous integration and deployment: GitLab.'
  prefs: []
  type: TYPE_NORMAL
- en: Join our book community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2903617220506617062.png)'
  prefs: []
  type: TYPE_IMG
