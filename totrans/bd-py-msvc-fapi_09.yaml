- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Utilizing Other Advanced Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用其他高级功能
- en: The previous chapters have already showcased several essential core features
    of the FastAPI framework. However, there are features not truly inherent to the
    framework that can help fine-tune performance and patch missing links in our implementations.
    These include session handling, managing **Cross-Origin Resource Sharing** (**CORS**)-related
    issues, and selecting the appropriate rendition types for an application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章已经展示了 FastAPI 框架的一些基本核心功能。然而，有一些功能并非真正固有的框架功能，可以帮助我们微调性能和修补实现中的缺失环节。这些包括会话处理、管理
    **跨源资源共享**（**CORS**）相关问题和为应用程序选择合适的渲染类型。
- en: Aside from the built-in features, there are workaround solutions proven to work
    with FastAPI when applied to the application, such as its session handling mechanism,
    which can function well using a `SessionMiddleware`. Concerning middleware, this
    chapter will also explore ways of customizing request and response filters other
    than applying the `@app.middleware` decorator. Other issues such as using custom
    `APIRoute` and `Request` will be covered in this chapter to guide us on managing
    incoming *byte* *body*, *form*, or *JSON* data. Moreover, this chapter will highlight
    how to test FastAPI components using the `pytest` framework and the `fastapi.testclient`
    library and how we can document the endpoint using the *OpenAPI 3.x* specification.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置功能外，还有一些经过验证的解决方案可以在应用到应用程序时与 FastAPI 一起使用，例如其会话处理机制，它可以使用 `SessionMiddleware`
    运行良好。关于中间件，本章还将探讨除了应用 `@app.middleware` 装饰器之外自定义请求和响应过滤器的方法。本章还将涵盖其他问题，例如使用自定义
    `APIRoute` 和 `Request`，以指导我们管理传入的 *字节* *正文*、*表单* 或 *JSON* 数据。此外，本章将强调如何使用 `pytest`
    框架和 `fastapi.testclient` 库测试 FastAPI 组件，以及如何使用 *OpenAPI 3.x* 规范来记录端点。
- en: 'Overall, the main objective of this chapter is to provide us with other solutions
    that can help us complete our microservice applications. In this chapter, the
    following topics are included:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本章的主要目标是提供其他解决方案，帮助我们完成我们的微服务应用程序。在本章中，包括以下主题：
- en: Applying session management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用会话管理
- en: Managing the CORS mechanism
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理CORS机制
- en: Customizing `APIRoute` and `Request`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 `APIRoute` 和 `Request`
- en: Choosing appropriate responses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的响应
- en: Applying the OpenAPI 3.x specification
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用 OpenAPI 3.x 规范
- en: Testing the API endpoints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 API 端点
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Although not data analysis-related, our application prototype for this chapter
    is the `ch09` project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与数据分析无关，但本章的应用原型是 `ch09` 项目。
- en: Applying session management
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用会话管理
- en: Session management is a feature used for managing requests and responses created
    by a user’s access to an application. It is also about creating and sharing data
    across a user session. Many frameworks usually include session handling features
    in their security plugins but not FastAPI. Creating user sessions and storing
    session data are two separate programming concerns in FastAPI. We use a JWT to
    establish a user session and Starlette’s `SessionMiddleware` to create and retrieve
    session data. Creating user sessions and storing session data are two entirely
    different programming solutions in FastAPI. We use JWT to establish a user session
    and Starlette’s `SessionMiddleware` to create and retrieve session data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 会话管理是一种用于管理由用户访问应用程序创建的请求和响应的功能。它还涉及在用户会话中创建和共享数据。许多框架通常在它们的插件中包含会话处理功能，但 FastAPI
    除外。在 FastAPI 中，创建用户会话和存储会话数据是两个独立的编程问题。我们使用 JWT 来建立用户会话，并使用 Starlette 的 `SessionMiddleware`
    来创建和检索会话数据。在 FastAPI 中，创建用户会话和存储会话数据是两种完全不同的编程解决方案。我们使用 JWT 来建立用户会话，并使用 Starlette
    的 `SessionMiddleware` 来创建和检索会话数据。
- en: Creating user sessions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户会话
- en: 'We have already proven the importance of JWT when it comes to securing FastAPI
    microservice applications in [*Chapter 7*](B17975_07.xhtml#_idTextAnchor190)*,*
    *Securing the REST APIs*. However, here, the JWT is applied to create a session
    based on user credentials. In the `api/login.py` router, an `authenticate()` API
    service is implemented to create a user session for an authenticated user. It
    is inherent for FastAPI to generate user sessions utilizing the browser cookies.
    The following snippet shows the authentication process that uses the cookie values:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经证明了 JWT 在确保 FastAPI 微服务应用程序安全方面的重要性，见 [*第 7 章*](B17975_07.xhtml#_idTextAnchor190)*，*
    “保护 REST API”。然而，在这里，JWT 被应用于根据用户凭证创建会话。在 `api/login.py` 路由器中，实现了 `authenticate()`
    API 服务以创建认证用户的用户会话。FastAPI 生成用户会话利用浏览器 cookie 是固有的。以下代码片段显示了使用 cookie 值的认证过程：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The service will verify through `LoginRepository` whether the user is a valid
    account using its `username` and `password` credentials. If the user is a certified
    one, it will use a JWT to create a token derived from a certain `secret_key` generated
    using the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务将通过 `LoginRepository` 使用其 `username` 和 `password` 凭证验证用户是否是有效账户。如果用户是认证的，它将使用
    JWT 创建一个基于以下命令生成的 `secret_key` 生成的令牌：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The token key will serve as the session ID of the cookie-based session. With
    the `username` credential as its payload, the JWT will be stored as a browser
    cookie named `session`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '令牌密钥将作为基于 cookie 的会话的会话 ID。JWT 将以 `username` 凭证作为有效载荷存储为名为 `session` 的浏览器 cookie。 '
- en: 'To ensure that `session` has been applied, all subsequent requests must undergo
    authentication by the cookie-based session through the `APIKeyCookie` class, an
    API class of the `fastapi.security` module that implements cookie-based authentication.
    The `APIKeyCookie` class fetches the session before it is injected into a dependable
    function for the JWT decoding through the `secret_key` value used to generate
    the session ID. The following dependable function in `util/auth_session.py` will
    verify every access to each endpoint of the application:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保会话已被应用，所有后续请求都必须通过 `APIKeyCookie` 类（`fastapi.security` 模块的基于 cookie 的认证
    API 类）进行基于 cookie 的会话认证。`APIKeyCookie` 类在将其注入到用于 JWT 解码的可靠函数之前，会通过用于生成会话 ID 的
    `secret_key` 值获取会话。`util/auth_session.py` 中的以下可靠函数将验证对应用程序每个端点的每次访问：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding function is injected into every API endpoint to impose user session
    verification. When an endpoint is requested, this function will decode the token
    and extract the `username` credential for account validation. Then, it will issue
    *Status Code 403 (Forbidden)* if the user is an *unauthenticated* one or the *session
    is not valid*. An example of an authenticated service can be found in the following
    implementation:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数被注入到每个 API 端点以强制进行用户会话验证。当请求端点时，此函数将解码令牌并提取 `username` 凭证以进行账户验证。然后，如果用户是未认证的或会话无效，它将发出
    *状态码 403 (禁止)*。一个认证服务的示例可以在以下实现中找到：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `add_restaurant()` service is an endpoint that adds a restaurant `Document`
    to the MongoDB collection. But before the transaction proceeds, it checks first
    whether there is a cookie-based session through the injected `get_current_user()`
    dependable function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_restaurant()` 服务是一个端点，它将一个 `Document` 类型的餐厅添加到 MongoDB 集合中。但在事务进行之前，它首先通过注入的
    `get_current_user()` 可靠函数检查是否存在基于 cookie 的会话。'
- en: Managing session data
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理会话数据
- en: Unfortunately, adding and retrieving session data is not part of `APIKeyCookie`-based
    session authentication. The JWT payload must only include the username but not
    all credentials and body of data. To manage session data, we need to create a
    separate session using Starlette’s `SessionMiddleware`. Although FastAPI has its
    `fastapi.middleware` module, it still supports Starlette’s built-in middleware.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，在基于 `APIKeyCookie` 的会话认证中，添加和检索会话数据并不是其功能的一部分。JWT 负载必须仅包含用户名，但不能包含所有凭证和数据主体。为了管理会话数据，我们需要使用
    Starlette 的 `SessionMiddleware` 创建一个单独的会话。尽管 FastAPI 有其 `fastapi.middleware` 模块，但它仍然支持
    Starlette 内置的中间件。
- en: We mentioned middleware in [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033)*,*
    *Exploring the Core Features*, and showed its implementation using the `@app.middleware`
    decorator. And we have proven that it acts as a filter for all incoming requests
    and outgoing responses to the services. This time, we will not custom implement
    a middleware but built-in middleware classes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B17975_02.xhtml#_idTextAnchor033)*，*探索核心功能*中提到了中间件，并展示了使用`@app.middleware`装饰器来实现它的方法。我们已经证明它作为所有传入请求和传出响应到服务的过滤器。这次，我们不会自定义实现中间件，而是使用内置的中间件类。
- en: 'Middleware is implemented, configured, and activated in the `main.py` module
    where the instance of `FastAPI` is located because `APIRouter` cannot add middleware.
    We enable the `middleware` parameter of the FastAPI constructor and add to that
    List-type parameter the built-in `SessionMiddleware` with its `secret_key` and
    the name of the new session as constructor parameters using the injectable class,
    `Middleware`. The following code snippet of `main.py` shows you how to configure
    this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件在`main.py`模块中实现、配置和激活，因为`APIRouter`无法添加中间件。我们启用`FastAPI`构造函数的`middleware`参数，并将内置的`SessionMiddleware`及其`secret_key`和新的会话名称作为构造参数添加到该List-type参数中，使用可注入的类`Middleware`。以下`main.py`的代码片段显示了如何配置它：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another way of adding middleware is to utilize the `add_middleware()` function
    of the `FastAPI` decorator. Initially, adding `SessionMiddleware` will create
    another cookie-based session that will handle *session-scoped data*. It is the
    only way since there is no direct support from FastAPI regarding session handling
    mechanisms where a user session is created not only for security but also for
    handling session objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 添加中间件的另一种方式是利用`FastAPI`装饰器的`add_middleware()`函数。最初，添加`SessionMiddleware`将创建另一个基于cookie的会话，该会话将处理*会话范围内的数据*。这是唯一的方法，因为FastAPI没有直接支持会话处理机制，其中用户会话不仅用于安全，还用于处理会话对象。
- en: 'To add session data to our newly created session, `session_vars`, we need to
    inject `Request` into each endpoint service and utilize its session dictionary
    to store the session-scoped objects. The following `list_restaurants()` service
    retrieves the list of restaurants from the database, extracts all the restaurant
    names, and shares the list of names across the session through `request.session[]`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要将会话数据添加到我们新创建的会话`session_vars`中，我们需要将`Request`注入到每个端点服务中，并利用其会话字典来存储会话范围内的对象。以下`list_restaurants()`服务从数据库中检索餐厅列表，提取所有餐厅名称，并通过`request.session[]`在会话中共享名称列表：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On the other hand, the `list_restaurant_names()` service retrieves the `resto_names`
    session data through `request.session[]` and returns it as its response. By the
    way, it is due to `SessionMiddleware` that `session[]` exists. Otherwise, the
    use of this dictionary will raise an change to - exception.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`list_restaurant_names()`服务通过`request.session[]`检索`resto_names`会话数据，并将其作为其响应返回。顺便说一句，正是由于`SessionMiddleware`的存在，`session[]`才存在。否则，使用此字典将引发异常。
- en: Removing the sessions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除会话
- en: 'It is always mandatory to log out from the application when done with the transactions
    to remove all the sessions created. Since the easiest and most direct way of creating
    sessions is through browser cookies, removing all the sessions protects the application
    from any compromise. The following `/ch09/logout` endpoint removes our sessions,
    `session` and `session_vars`, which technically logs out the user from the application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完成事务后，始终必须从应用程序中注销以移除所有创建的会话。由于创建会话最简单和最直接的方式是通过浏览器cookie，移除所有会话可以保护应用程序免受任何妥协。以下`/ch09/logout`端点移除了我们的会话，`session`和`session_vars`，这在技术上意味着用户从应用程序中注销：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `delete_cookie()` method of the `Response` class removes any existing browser
    session utilized by the application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response`类的`delete_cookie()`方法移除了应用程序使用的任何现有浏览器会话。'
- en: Customizing BaseHTTPMiddleware
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 BaseHTTPMiddleware
- en: 'The default approach in managing FastAPI sessions is through cookies, and it
    does not offer any other options such as database-backed, cached, and file-based
    sessions. The best way to implement non-cookie-based strategies for managing user
    sessions and session data is to customize `BaseHTTPMiddleware`. The following
    custom middleware is a prototype that creates user sessions for authenticated
    users:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 管理FastAPI会话的默认方法是通过cookie，并且它不提供其他选项，如数据库支持、缓存和基于文件的会话。实现基于非cookie策略来管理用户会话和会话数据的最佳方法是自定义`BaseHTTPMiddleware`。以下自定义中间件是一个原型，为认证用户创建会话：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As discussed in [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033)*,* *Exploring
    the Core Features*, `SessionDbMiddleware` will filter our `/ch09/login/authenticate`
    endpoint for the `username` and `password` query parameters, check whether the
    user is a registered one, and generate a database-backed session from the JWT.
    Afterward, endpoints can validate all their requests from the session stored in
    the database. The `/ch09/logout` endpoint will not include the deletion of the
    session from the database using its repository transactions, as shown in the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第 [*第2章*](B17975_02.xhtml#_idTextAnchor033)* *探索核心功能* 中所述，`SessionDbMiddleware`
    将过滤我们的 `/ch09/login/authenticate` 端点上的 `username` 和 `password` 查询参数，检查用户是否是已注册用户，并从
    JWT 生成数据库支持的会话。之后，端点可以验证存储在数据库中的会话的所有请求。`/ch09/logout` 端点将不会包括使用其仓库事务从数据库中删除会话，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `DbSessionRepository` is a custom repository implementation for our
    prototype, and it has a `delete_session()` method that will remove the session
    through its name from the `db_session` collection of our MongoDB database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`DbSessionRepository` 是我们原型的一个自定义仓库实现，它有一个 `delete_session()` 方法，可以通过其名称从我们的
    MongoDB 数据库的 `db_session` 集合中删除会话。
- en: Another type of middleware that can help FastAPI applications resolve issues
    regarding the CORS browser mechanism is `CORSMiddleware`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以帮助FastAPI应用程序解决与CORS浏览器机制相关问题的中间件是 `CORSMiddleware`。
- en: Managing the CORS mechanism
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理CORS机制
- en: When integrating API endpoints with various frontend frameworks, we often encounter
    the "*no ‘access-control-allow-origin’ header present*" error from our browser.
    Nowadays, this setup is an HTTP-header-based mechanism of any browser, which requires
    the backend server to provide the browser with the "origin" details of the server-side
    application, which includes the server domain, scheme, and port. This mechanism
    is called CORS, which happens when the frontend application and its web resources
    belong to a different domain area than the backend app. Nowadays, browsers prohibit
    cross-origin requests between the server-side and frontend applications for security
    reasons.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当将API端点与各种前端框架集成时，我们经常遇到浏览器返回的 "*没有‘access-control-allow-origin’头存在*" 错误。如今，这已成为任何浏览器的基于HTTP头的机制，它要求后端服务器向浏览器提供服务器端应用程序的
    "origin" 细节，包括服务器域名、方案和端口。这种机制称为CORS，当前端应用程序及其网络资源属于与后端应用程序不同的域区域时发生。如今，出于安全原因，浏览器禁止服务器端和前端应用程序之间的跨域请求。
- en: 'To resolve this issue, we need our `main.py` module to place all the origins
    of our application and other integrated resources used by the prototype inside
    a `List`. Then, we import the built-in `CORSMiddleware` from the `fastapi.middleware.cors`
    module and add that to the `FastAPI` constructor with the list of origins, which
    should not be too long to avoid overhead from validating each URL. The following
    code snippet shows the injection of `CORSMiddleware` into the `FastAPI` constructor:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要在 `main.py` 模块中将我们应用程序的所有来源以及原型使用的其他集成资源放在一个 `List` 中。然后，我们从 `fastapi.middleware.cors`
    模块导入内置的 `CORSMiddleware`，并将其添加到 `FastAPI` 构造函数中，与来源列表一起，这个列表不应太长，以避免验证每个 URL 时的开销。以下代码片段显示了将
    `CORSMiddleware` 注入到 `FastAPI` 构造函数中：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This time, we used FastAPI’s `add_middleware()` function to add CORS support
    to our application. Aside from `allow_origins`, we also need to add into `CORSMiddleware`
    the `allow_credentials` parameter, which adds `Access-Control-Allow-Credentials:
    true` to the response header for the browser to recognize the domain origin matches
    and send an `Authorization` cookie to allow the request. Also, we must include
    the `allow_headers` parameter, which registers a list of acceptable header keys
    during browser interaction. Aside from `Accept`, `Accept-Language`, `Content-Language`,
    and `Content-Type`, which are included by default, we need to register `Access-Control-Allow-Origin`,
    `Access-Control-Allow-Credentials`, `Access-Control-Allow-Headers`, and `Access-Control-Max-Age`
    explicitly instead of using the asterisk (`*`). The `allow_headers` parameter
    must also be part of the middleware to specify other HTTP methods that need to
    be supported by the browser. And lastly, the `max_age` parameter must also be
    in the configuration because we need to tell the browser the amount of time it
    will cache all the resources loaded into the browser.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '这次，我们使用了FastAPI的`add_middleware()`函数来为我们的应用程序添加CORS支持。除了`allow_origins`之外，我们还需要将`allow_credentials`参数添加到`CORSMiddleware`中，该参数将`Access-Control-Allow-Credentials:
    true`添加到响应头，以便浏览器识别域名来源匹配并发送一个`Authorization` cookie以允许请求。此外，我们还必须包括`allow_headers`参数，该参数在浏览器交互期间注册一组可接受的头键。除了默认包含的`Accept`、`Accept-Language`、`Content-Language`和`Content-Type`之外，我们还需要显式注册`Access-Control-Allow-Origin`、`Access-Control-Allow-Credentials`、`Access-Control-Allow-Headers`和`Access-Control-Max-Age`而不是使用通配符（`*`）。`allow_headers`参数还必须是中间件的一部分，以指定浏览器需要支持的其他HTTP方法。最后，`max_age`参数也必须在配置中，因为我们需要告诉浏览器它将缓存加载到浏览器中的所有资源的时间。'
- en: If the application needs additional CORS support features, customizing the `CORSMiddleware`
    to extend some built-in utilities and features to manage CORS is a better solution.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序需要额外的CORS支持功能，自定义`CORSMiddleware`以扩展一些内置实用程序和功能来管理CORS是一个更好的解决方案。
- en: By the way, it is not only the middleware that we can subclass and use to create
    custom implementations of but also the `Request` data and API routes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们不仅可以对中间件进行子类化并用于创建自定义实现，还可以对`Request`数据和API路由进行自定义。
- en: Customizing APIRoute and Request
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义APIRoute和Request
- en: Middleware can process incoming `Request` data and outgoing `Response` objects
    of all API methods in a FastAPI application, except that it cannot manipulate
    the message body, attach state objects from the `Request` data, or modify the
    response object before the client consumes it. Only `APIRoute` and `Request` customization
    can give us a full grasp of how to control the request and response transaction.
    The control might include determining whether the incoming data is a byte body,
    form, or JSON and providing an effective logging mechanism, exception handling,
    content transformation, and extraction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以处理FastAPI应用程序中所有API方法的传入`Request`数据和传出`Response`对象，但无法操作消息正文，从`Request`数据中附加状态对象，或修改客户端消费之前的响应对象。只有`APIRoute`和`Request`的自定义才能让我们全面掌握如何控制请求和响应事务。控制可能包括确定传入数据是字节正文、表单还是JSON，并提供有效的日志记录机制、异常处理、内容转换和提取。
- en: Managing body, form, or JSON data
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理正文、表单或JSON数据
- en: 'Unlike in middleware, customizing `APIRoute` does not apply to all the API
    endpoints. Implementing `APIRoute` for some `APIRouter` will only impose new routing
    rules to those affected endpoints, while the other services can pursue the default
    request and response process. For instance, the following customization is responsible
    for data extraction that only applies to the endpoints of `api.route_extract.router`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与中间件不同，自定义`APIRoute`不适用于所有API端点。为某些`APIRouter`实现`APIRoute`只会为受影响的端点施加新的路由规则，而其他服务可以继续使用默认的请求和响应过程。例如，以下自定义仅适用于`api.route_extract.router`端点的数据提取：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Customizing `APIRoute` requires the creation of a Python `Request` and `Response`
    flow from `APIRoute`’s `original_route_handler`. On the other hand, our `ExtractContentRoute`
    filter uses a custom `ExtractionRequest` that identifies and processes each type
    of incoming request data separately. The following is the implementation of `ExtractionRequest`
    that will replace the default `Request` object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义`APIRoute`需要从`APIRoute`的`original_route_handler`创建一个Python `Request`和`Response`流程。另一方面，我们的`ExtractContentRoute`过滤器使用一个自定义的`ExtractionRequest`，该请求识别并分别处理每种传入请求数据。以下是将替换默认`Request`对象的`ExtractionRequest`的实现：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To activate this `ExtractionRequest`, we need to set the `route_class` of the
    `APIRouter` of the endpoints to `ExtractContentRoute`, as shown in the following
    snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活此`ExtractionRequest`，我们需要将端点的`APIRouter`的`route_class`设置为`ExtractContentRoute`，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are three methods of choice to override when managing various request
    bodies:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理各种请求体时，有三个方法可以选择覆盖：
- en: '`body()`: This manages incoming request data that is in bytes'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body()`: 这管理传入的字节数据请求'
- en: '`form()`: This processes incoming form data'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form()`: 这处理传入的表单数据'
- en: '`json()`: This manages incoming parsed JSON data'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json()`: 这管理传入的解析JSON数据'
- en: '`stream()`: This accesses the body via a chunk of bytes using the `async for`
    construct'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream()`: 这通过使用`async for`构造访问字节块中的消息体'
- en: All of these methods return the original request body in bytes back to the service.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都将原始请求数据以字节形式返回给服务。
- en: In `ExtractionRequest`, we have implemented three interface methods from the
    given choices to filter and process all incoming requests of the API endpoints
    defined in the `/api/route_extract.py` module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ExtractionRequest`中，我们从给定的选项中实现了三个接口方法来过滤和处理所有来自`/api/route_extract.py`模块中定义的API端点的传入请求。
- en: 'The following `create_profile()` service accepts profile data from the client
    and implements the `ExtractContentRoute` filter, which will store all of this
    profile data in the dictionary using session handling:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`create_profile()`服务从客户端接收配置文件数据并实现`ExtractContentRoute`过滤器，该过滤器将使用会话处理将所有这些配置文件数据存储在字典中：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The overridden `form()` method of `ExtractionRequest` is responsible for the
    `user_details` attribute containing all the user details.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 被覆盖的`form()`方法`ExtractionRequest`负责包含所有用户详情的`user_details`属性。
- en: 'On the other hand, the given `set_ratings()` method has an incoming dictionary
    of various ratings in which the `json()` override will derive some basic statistics.
    All the results will be returned as `Request`’s state objects or request attributes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，给定的`set_ratings()`方法有一个包含各种评分的传入字典，其中`json()`覆盖将推导出一些基本统计信息。所有结果都将作为`Request`的状态对象或请求属性返回：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And lastly, the preceding `compute_data()` service will have an incoming list
    of ratings as a source of some basic statistics like in the previous service.
    The `body()` method override of `ExtractionRequest` will process the computation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，前面的`compute_data()`服务将有一个包含评分的传入列表作为一些基本统计信息（如前一个服务中所示）的来源。`ExtractionRequest`的`body()`方法覆盖将处理计算：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Encrypting and decrypting the message body
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密和解密消息体
- en: 'Another scenario where we need to customize the routing of the endpoints is
    when we must secure the message body through encryption. The following custom
    request decrypts an encrypted body using Python’s `cryptography` module and the
    key of the encrypted body:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要自定义端点路由的场景是我们必须通过加密来保护消息体。以下自定义请求使用Python的`cryptography`模块和加密消息体的密钥解密加密的消息体：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Important note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `cryptography` module requires the installation of the `itsdangerous` extension
    for the encryption/decryption procedure used in this project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`cryptography`模块需要安装`itsdangerous`扩展来执行本项目中的加密/解密过程。'
- en: '`DecryptRequest` will decrypt the message and return the list of login records
    as a request `state` object. The following service provides the encrypted message
    body and key and returns the decrypted list of login records from `DecryptRequest`
    as a response:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`DecryptRequest`将解密消息并返回登录记录列表作为请求`state`对象。以下服务提供加密的消息体和密钥，并从`DecryptRequest`返回解密后的登录记录列表作为响应：'
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `send_decrypt_login()` has an `EncLoginReq` request model that contains
    the encrypted message body and the encryption key from the client.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`send_decrypt_login()`有一个包含加密消息体和加密密钥的`EncLoginReq`请求模型。
- en: Customizing the routes and their `Request` objects can help optimize and streamline
    microservice transactions, especially those API endpoints that require heavy loads
    on message body conversions, transformations, and computations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义路由及其`Request`对象可以帮助优化和简化微服务事务，特别是那些需要大量负载在消息体转换、转换和计算上的API端点。
- en: Now, our next discussion will focus on applying different `Response` types for
    the API services.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的下一次讨论将集中在为API服务应用不同的`Response`类型。
- en: Choosing the appropriate responses
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择合适的响应
- en: 'The FastAPI framework offers other options for rendering API endpoint responses
    other than the most common `JsonResponse` option. Here is a list of some of the
    response types supported by FastAPI and their corresponding samples from our application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 框架除了最常见的 `JsonResponse` 选项外，还提供了其他用于渲染 API 端点响应的选项。以下是我们应用程序支持的响应类型列表及其示例：
- en: 'The API endpoints can utilize the `PlainTextResponse` type if their response
    is text-based only. The following `intro_list_restaurants()` service returns a
    text-based message to the client:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 API 端点的响应仅基于文本，则可以利用 `PlainTextResponse` 类型。以下 `intro_list_restaurants()`
    服务向客户端返回一个基于文本的消息：
- en: '[PRE18]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Services can use `RedirectResponse` if they need to pursue navigation to another
    entirely different application or another endpoint of the same application. The
    following endpoint jumps to a hypertext reference about some known Michelin-starred
    restaurants:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务需要导航到另一个完全不同的应用程序或同一应用程序的另一个端点，可以使用 `RedirectResponse`。以下端点跳转到一个关于一些知名米其林星级餐厅的超文本引用：
- en: '[PRE19]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A `FileResponse` type can help services render some content of a file, preferably
    text-based files. The following `load_questions()` service shows the list of questions
    saved in the `questions.txt` file placed inside the `/file` folder of the application:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileResponse` 类型可以帮助服务渲染文件的一些内容，最好是文本文件。以下 `load_questions()` 服务显示了保存在应用程序
    `/file` 文件夹中的 `questions.txt` 文件中的问题列表：'
- en: '[PRE20]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`StreamingResponse` is another response type that can provide us with another
    approach to the `EventSourceResponse` type:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamingResponse` 是另一种响应类型，它为我们提供了对 `EventSourceResponse` 类型的另一种方法：'
- en: '[PRE21]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Services that render images can also use the `StreamingResponse` type. The
    following `logo_upload_png()` service uploads any **JPEG** or **PNG** file and
    renders it in the browser:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以渲染图像的服务也可以使用 `StreamingResponse` 类型。以下 `logo_upload_png()` 服务上传任何 **JPEG**
    或 **PNG** 文件并在浏览器中渲染：
- en: '[PRE22]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `StreamingResponse` type is also effective in rendering videos in various
    formats such as `sample.mp4` and publishes it to the browser:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamingResponse` 类型在渲染各种格式的视频（如 `sample.mp4`）并将其发布到浏览器方面也非常有效：'
- en: '[PRE23]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the service wants to publish a simple HTML markup page without making references
    to static CSS or JavaScript files, then `HTMLResponse` is the right choice. The
    following service renders an HTML page with a Bootstrap framework provided by
    some CDN libraries:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务想要发布一个简单的 HTML 标记页面，而不引用静态 CSS 或 JavaScript 文件，那么 `HTMLResponse` 就是正确的选择。以下服务渲染了一个由某些
    CDN 库提供的 Bootstrap 框架的 HTML 页面：
- en: '[PRE24]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the API endpoints have other rendition types needed to be published, the
    `Response` class can customize them through its `media_type` property. The following
    is a service that converts JSON data into XML content by setting the `media_type`
    property of `Response` to the `application/xml` MIME type:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 API 端点需要发布其他渲染类型，可以通过 `Response` 类的 `media_type` 属性进行自定义。以下是一个将 JSON 数据转换为
    XML 内容的服务，通过将 `Response` 的 `media_type` 属性设置为 `application/xml` MIME 类型：
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although FastAPI is not a web framework, it can support Jinja2 templating for
    rare cases where API services require rendering their response as an HTML page.
    Let us highlight how API services utilize Jinja2 templates as part of the response.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FastAPI 不是一个 Web 框架，但它可以支持 Jinja2 模板，在 API 服务需要将响应渲染为 HTML 页面的罕见情况下。让我们突出
    API 服务如何将 Jinja2 模板作为响应的一部分来使用。
- en: Setting up the Jinja2 template engine
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Jinja2 模板引擎
- en: 'First, we need to install the `jinja2` module using `pip`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 `pip` 安装 `jinja2` 模块：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we need to create a folder that will hold all the Jinja2 templates. Jinja2
    must define this folder, usually named `templates`, by creating the `Jinja2Templates`
    instance in `FastAPI` or any `APIRouter`. The following snippet is part of the
    `/api/login.py` router that shows the setup and configuration of the Jinja2 templating
    engine:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个文件夹来存放所有的 Jinja2 模板。Jinja2 必须通过在 `FastAPI` 或任何 `APIRouter` 中创建 `Jinja2Templates`
    实例来定义这个文件夹，通常命名为 `templates`。以下代码片段是 `/api/login.py` 路由的一部分，展示了 Jinja2 模板引擎的设置和配置：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Setting up the static resources
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置静态资源
- en: 'After the `templates` folder, the Jinja2 engine requires the application to
    have a folder named `static` in the project directory to hold the CSS, JavaScript,
    images, and other static files for the Jinja2 templates. Then, we need to instantiate
    the `StaticFiles` instance to define the `static` folder and map it with a virtual
    name. Additionally, the `StaticFiles` instance must be mounted to a specific path
    through `FastAPI`’s `mount()` method. We also need to set the `html` property
    of the `StaticFiles` instance to `True` to set the folder in HTML mode. The following
    configuration shows how to set up the static resource folder in the `main.py`
    module:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `templates` 文件夹之后，Jinja2 引擎要求应用程序在项目目录中有一个名为 `static` 的文件夹来存放 Jinja2 模板的 CSS、JavaScript、图像和其他静态文件。然后，我们需要实例化
    `StaticFiles` 实例来定义 `static` 文件夹并将其映射到一个虚拟名称。此外，必须通过 `FastAPI` 的 `mount()` 方法将
    `StaticFiles` 实例挂载到特定的路径。我们还需要将 `StaticFiles` 实例的 `html` 属性设置为 `True` 以将文件夹设置为
    HTML 模式。以下配置展示了如何在 `main.py` 模块中设置静态资源文件夹：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For the FastAPI components to access these static files, the engine needs the
    `aiofiles` extension installed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 FastAPI 组件访问这些静态文件，引擎需要安装 `aiofiles` 扩展：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Creating the template layout
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模板布局
- en: 'The following template is the `static` folder due to the template engine and
    `aiofiles` module:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模板是 `static` 文件夹，由于模板引擎和 `aiofiles` 模块：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Other templates can inherit the structure and design of this `layout.html`
    using the `{% extends %}` tags. The Jinja2 base template, like our `layout.html`,
    has these Jinja2 tags, namely the `{% block content %}` and `{% endblock %}` tags,
    which indicate where child templates can insert their content during the translation
    phase. But for all these templates to work, they must be saved in the `/templates`
    directory. The following is a sample child template named `users.html` that generates
    a table of profiles from the context data:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模板可以使用 `{% extends %}` 标签继承此 `layout.html` 的结构和设计。与我们的 `layout.html` 一样，Jinja2
    基础模板具有这些 Jinja2 标签，即 `{% block content %}` 和 `{% endblock %}` 标签，它们指示子模板在翻译阶段可以插入其内容。但是，为了使所有这些模板都能正常工作，它们必须保存在
    `/templates` 目录中。以下是一个名为 `users.html` 的示例子模板，它从上下文数据生成一个配置文件表：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Observe that the child Jinja2 template also has the "block" tags to mark the
    content to be merged into the parent template.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，子 Jinja2 模板也有 "block" 标签来标记要合并到父模板中的内容。
- en: 'For the API to render the templates, the service must use the Jinja2 engine’s
    `TemplateResponse` type as the response type. `TemplateResponse` needs the filename
    of the template, the `Request` object, and the context data if there is any. The
    following is the API service that renders the previous `users.html` template:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 API 渲染模板，服务必须使用 Jinja2 引擎的 `TemplateResponse` 类型作为响应类型。`TemplateResponse`
    需要模板的文件名、`Request` 对象以及如果有任何上下文数据，还需要上下文数据。以下是一个渲染之前 `users.html` 模板的 API 服务：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using ORJSONResponse and UJSONResponse
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ORJSONResponse 和 UJSONResponse
- en: When it comes to yielding numerous dictionaries or JSON-able-components, it
    is appropriate to use either `ORJSONResponse` or `UJSONResponse`. `ORJSONResponse`
    uses `orjson` to serialize a humongous listing of dictionary objects into a JSON
    string as a response. So, first, we need to install `orjson` using the `pip` command
    before using `ORJSONResponse`. `ORJSONResponse` serializes UUID, `numpy`, data
    classes, and datetime objects faster than the common `JSONResponse`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要返回大量字典或可 JSON 化的组件时，使用 `ORJSONResponse` 或 `UJSONResponse` 都很合适。`ORJSONResponse`
    使用 `orjson` 将大量的字典对象序列化为 JSON 字符串作为响应。因此，在使用 `ORJSONResponse` 之前，我们需要使用 `pip`
    命令安装 `orjson`。`ORJSONResponse` 比常见的 `JSONResponse` 更快地序列化 UUID、`numpy`、数据类和 datetime
    对象。
- en: However, `UJSONResponse` is relatively faster than `ORJSONResponse` because
    it uses the `ujson` serializer. The `ujson` serializer must first be installed
    before using `UJSONResponse`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`UJSONResponse` 相比于 `ORJSONResponse` 要快一些，因为它使用了 `ujson` 序列化器。在使用 `UJSONResponse`
    之前，必须首先安装 `ujson` 序列化器。
- en: 'The following are the two API services that use these two fast alternatives
    for a JSON serializer:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个 API 服务使用了这两个快速的 JSON 序列化器替代方案：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We still need to apply the `jsonable_encoder()` component to convert `BSON`’s
    `ObjectId` of the result into `str` before the two responses pursue their serialization
    processes. Now, let us focus on how we provide internal API documentation using
    the OpenAPI 3.0 specification.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要在两个响应继续其序列化过程之前，将结果的 `BSON` 的 `ObjectId` 转换为 `str`，应用 `jsonable_encoder()`
    组件。现在，让我们关注我们如何使用 OpenAPI 3.0 规范提供内部 API 文档。
- en: Applying the OpenAPI 3.x specification
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用 OpenAPI 3.x 规范
- en: The OpenAPI 3.0 specification is a standard API documentation and language-agnostic
    specification that can describe the API services without knowing its sources,
    reading its documentation, and understanding its business logic. Additionally,
    FastAPI supports OpenAPI, and it can even automatically generate the default internal
    documentation of the API based on OpenAPI standards.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 3.0 规范是一种标准的 API 文档和语言无关的规范，可以描述 API 服务，而无需了解其来源、阅读其文档或理解其业务逻辑。此外，FastAPI
    支持 OpenAPI，甚至可以根据 OpenAPI 标准自动生成 API 的默认内部文档。
- en: 'There are three ways to document our API services using the specification:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用规范文档我们的 API 服务有三种方式：
- en: By extending the OpenAPI schema definition
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过扩展 OpenAPI 架构定义
- en: By using the internal code base properties
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用内部代码库属性
- en: By using the `Query`, `Body`, `Form`, and `Path` functions
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `Query`、`Body`、`Form` 和 `Path` 函数
- en: Extending the OpenAPI schema definition
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展 OpenAPI 架构定义
- en: FastAPI has a `get_openapi()` method from its `fastapi.openapi.utils` extension
    that can override some schema descriptions. We can modify the `info`, `servers`,
    and `paths` details of the schema definition through the `get_openapi()` function.
    The function returns a `dict` of all details of the OpenAPI schema definition
    of the application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 从其 `fastapi.openapi.utils` 扩展中有一个 `get_openapi()` 方法，可以覆盖一些架构描述。我们可以通过
    `get_openapi()` 函数修改架构定义的 `info`、`servers` 和 `paths` 细节。该函数返回一个包含应用程序 OpenAPI
    架构定义所有详细信息的 `dict`。
- en: 'The default OpenAPI schema documentation is always set up in the `main.py`
    module because it is consistently associated with the FastAPI instance. For the
    function to generate the `dict` of schema details, it must accept at least the
    `title`, `version`, and `routes` parameter values. The following custom function
    extracts the default *OpenAPI* schema for updating:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 OpenAPI 架构文档始终设置在 `main.py` 模块中，因为它始终与 FastAPI 实例相关联。为了生成包含架构详细信息的 `dict`
    函数，它必须接受至少 `title`、`version` 和 `routes` 参数值。以下自定义函数提取默认的 *OpenAPI* 架构以进行更新：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `title` parameter value is the document title, the `version` parameter
    value is the version of the API implementation, and `routes` contains a list of
    registered API services. Observe that the last line before the `return` statement
    updates FastAPI’s built-in `openapi_schema` defaults. Now, to update the general
    information details, we use the `info` key of the schema definition to change
    some values, as shown in the following sample:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`title` 参数值是文档标题，`version` 参数值是 API 实现的版本，`routes` 包含注册的 API 服务列表。注意，在 `return`
    语句之前的最后一行更新了 FastAPI 内置的 `openapi_schema` 默认值。现在，为了更新一般信息细节，我们使用架构定义的 `info` 键来更改一些值，如下面的示例所示：'
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding info schema update must also be part of the `update_api_schema()`
    function together with the update on the documentation of each registered API
    service. These details can includeAPI service''s description and summary, the
    POST endpoint''s description of its `requestBody` and GET endpoint''s details
    about its parameters, and the API tags. Add the following `paths` updates:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的信息架构更新也必须是 `update_api_schema()` 函数的一部分，包括对每个注册的 API 服务文档的更新。这些细节可以包括 API
    服务的描述和摘要、POST 端点的 `requestBody` 描述和 GET 端点的参数细节，以及 API 标签。添加以下 `paths` 更新：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding will give us a new OpenAPI document dashboard, as shown in *Figure
    9.1*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作将为我们提供一个新的 OpenAPI 文档仪表板，如图 *9.1* 所示：
- en: '![Figure 9.1 – A customized OpenAPI dashboard](img/Figure_9.01_B17975.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 定制的 OpenAPI 仪表板](img/Figure_9.01_B17975.jpg)'
- en: Figure 9.1 – A customized OpenAPI dashboard
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 定制的 OpenAPI 仪表板
- en: Tags are essential variables of the OpenAPI documentation because they organize
    the API endpoints according to the routers, business processes, requirements,
    and modules. It is a best practice to use tags.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是 OpenAPI 文档的关键变量，因为它们根据路由器、业务流程、需求和模块组织 API 端点。使用标签是一种最佳实践。
- en: Once all the updates have been set, replace FastAPI’s `openapi()` function with
    the new `update_api_schema()` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有更新都设置完毕，将 FastAPI 的 `openapi()` 函数替换为新的 `update_api_schema()` 函数。
- en: Using the internal code base properties
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内部代码库属性
- en: 'FastAPI’s constructor has parameters that can replace the default info document
    details without using the `get_openapi()` function. The following snippet showcases
    a sample documentation update on the `title`, `description`, `version`, and `servers`
    details of the OpenAPI documentation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 的构造函数有参数可以替换默认的 info 文档细节，而不使用 `get_openapi()` 函数。以下代码片段展示了 OpenAPI
    文档的 `title`、`description`、`version` 和 `servers` 细节的示例文档更新：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When adding documentation to the API endpoints, the path operators of `FastAPI`
    and `APIRouter` also have parameters that allow changes to the default OpenAPI
    variables attributed to each endpoint. The following is a sample service that
    updates its `summary`, `description`, `response_description`, and other response
    details through the `post()` path operator:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在向 API 端点添加文档时，`FastAPI` 和 `APIRouter` 的路径操作符也有参数允许更改分配给每个端点的默认 OpenAPI 变量。以下是一个示例服务，它通过
    `post()` 路径操作符更新其 `summary`、`description`、`response_description` 和其他响应细节：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using the Query, Form, Body, and Path functions
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Query、Form、Body 和 Path 函数
- en: 'Aside from the declaration and additional validations, the `Query`, `Path`,
    `Form`, and `Body` parameter functions can also be used to add some metadata to
    the API endpoints. The following `authenticate()` endpoint has added descriptions
    and validations through the `Query()` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了声明和额外的验证之外，`Query`、`Path`、`Form` 和 `Body` 参数函数也可以用来向 API 端点添加一些元数据。以下 `authenticate()`
    端点通过 `Query()` 函数添加了描述和验证：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following `get_login()` uses the `Path()` directive to insert a description
    of the `id` parameter:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `get_login()` 使用 `Path()` 指令插入 `id` 参数的描述：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `description` and `max_length` metadata of the `Query()` function will
    become part of the OpenAPI documentation for `authenticate()`, as shown in *Figure
    9.2*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query()` 函数的 `description` 和 `max_length` 元数据将成为 `authenticate()` 的 OpenAPI
    文档的一部分，如图 *9.2* 所示：'
- en: '![Figure 9.2 – The Query metadata](img/Figure_9.02_B17975.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 *9.2* – 查询元数据](img/Figure_9.02_B17975.jpg)'
- en: Figure 9.2 – The Query metadata
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 *9.2* – 查询元数据
- en: 'Additionally, the `description` metadata of the `Path()` directive will also
    appear in the `get_login()` documentation, as presented in *Figure 9.3*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Path()` 指令的 `description` 元数据也将出现在 `get_login()` 文档中，如图 *9.3* 所示：
- en: '![Figure 9.3 – The Path metadata'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 *9.3* – 路径元数据'
- en: '](img/Figure_9.03_B17975.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B17975.jpg)'
- en: Figure 9.3 – The Path metadata
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 *9.3* – 路径元数据
- en: 'Likewise, we can add descriptions to form parameters using the `Form` directive.
    The following service shows you how to insert documentation through the `Form`
    directive:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `Form` 指令为表单参数添加描述。以下服务展示了如何通过 `Form` 指令插入文档：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Moreover, it is also possible to document all types of HTTP responses or status
    codes that the API service can throw through the path operator’s `responses` parameter.
    The following `video_presentation()` service provides metadata regarding the nature
    of its response when it encounters no errors (*HTTP Status Code 200*) and with
    runtime errors (*HTTP Status Code 500*):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以通过路径操作符的 `responses` 参数记录 API 服务可能抛出的所有类型的 HTTP 响应或状态码。以下 `video_presentation()`
    服务提供了在遇到无错误（*HTTP 状态码 200*）和运行时错误（*HTTP 状态码 500*）时其响应性质的元数据：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`Error500Model` is a `BaseModel` class that will give you a clear picture of
    the response once the application encounters an *HTTP Status Code 500* error and
    will only be used in the OpenAPI documentation. It contains metadata such as the
    message that holds a hardcoded error message. *Figure 9.4* shows the resulting
    OpenAPI documentation for `video_presentation()` after adding the metadata for
    its responses:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error500Model` 是一个 `BaseModel` 类，当应用程序遇到 *HTTP 状态码 500* 错误时，它将给出清晰的响应图景，并且只会在
    OpenAPI 文档中使用。它包含诸如包含硬编码错误消息的消息等元数据。*图 *9.4* 显示了在为 `video_presentation()` 的响应添加元数据后，其
    OpenAPI 文档的结果：'
- en: '![Figure 9.4 – The documentation for API responses'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 *9.4* – API 响应的文档'
- en: '](img/Figure_9.04_B17975.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.04_B17975.jpg)'
- en: Figure 9.4 – The documentation for API responses
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 *9.4* – API 响应的文档
- en: And now, for our last discussion, let us explore how we can perform unit testing
    in FastAPI, which could lead to a test-driven development setup.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们的最后一次讨论，让我们探讨如何在 FastAPI 中执行单元测试，这可能导致测试驱动开发环境。
- en: Testing the API endpoints
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 API 端点
- en: 'FastAPI uses the `pytest` framework to run its test classes. So, before we
    create our test classes, first, we need to install the `pytest` framework using
    the `pip` command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 使用 `pytest` 框架来运行其测试类。因此，在我们创建测试类之前，首先需要使用 `pip` 命令安装 `pytest` 框架：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: FastAPI has a module called `fastapi.testclient` where all components are `Request`-based,
    including the `TestClient` class. To access all the API endpoints, we need the
    `TestClient` object. But first, we need to create a folder such as `test`, which
    will contain test modules where we implement our test methods. We place our test
    methods outside `main.py` or the router modules to maintain clean code and organization.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 有一个名为 `fastapi.testclient` 的模块，其中所有组件都是基于 `Request` 的，包括 `TestClient`
    类。为了访问所有 API 端点，我们需要 `TestClient` 对象。但是，首先我们需要创建一个如 `test` 的文件夹，它将包含实现我们的测试方法的测试模块。我们将测试方法放在
    `main.py` 或路由器模块之外，以保持代码的整洁和组织。
- en: Writing the unit test cases
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单元测试用例
- en: It is a best practice to write one test module per router component, except
    for cases where there is a tight connection between these routers. We place these
    test modules inside the `test` directory. To pursue the automated testing, we
    need to import the `APIRouter` instance or the `FastAPI` instance into the test
    module to set up `TestClient`. `TestClient` is almost like Python’s client module,
    `requests`, when it comes to the helper methods used to consume APIs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是每个路由器组件写一个测试模块，除非这些路由器之间存在紧密的联系。我们将这些测试模块放在 `test` 目录中。为了追求自动化测试，我们需要将
    `APIRouter` 实例或 `FastAPI` 实例导入到测试模块中，以设置 `TestClient`。当涉及到用于消费 API 的辅助方法时，`TestClient`
    几乎就像 Python 的客户端模块 `requests`。
- en: 'The method names of the test cases must start with a `test_` prefix, which
    is a `pytest` requirement. Test methods are all standard Python methods and should
    not be asynchronous. The following is a test method in `test/test_restaurants.py`
    that checks whether the endpoint returns the proper text-based response:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例的方法名必须以 `test_` 前缀开头，这是 `pytest` 的要求。测试方法都是标准的 Python 方法，不应是异步的。以下是在 `test/test_restaurants.py`
    中的一个测试方法，它检查端点是否返回正确的基于文本的响应：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`TestClient` supports assert statements that check the response of its helper
    methods, like `get()`, `post()`, `put()`, and `delete()` the status code and response
    body of the API. The `test_restaurant_index()`, for instance, uses the `get()`
    method of the TestClient API to run `/restaurant/index` GET service and extract
    its response. The assert statements are used if the `statuc_code` and `response.text`
    are correct. The endpoint has no imposed dependencies, so the test module is *router-based*.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestClient` 支持断言语句来检查其辅助方法（如 `get()`、`post()`、`put()` 和 `delete()`）的响应，包括
    API 的状态码和响应体。例如，`test_restaurant_index()` 方法使用 TestClient API 的 `get()` 方法来运行
    `/restaurant/index` GET 服务并提取其响应。如果 `statuc_code` 和 `response.text` 正确，则使用断言语句。端点没有强加依赖，因此测试模块是基于路由器的。'
- en: Mocking the dependencies
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟依赖项
- en: 'Testing API endpoints with dependencies is not as straightforward as the previous
    example. Our endpoints have session-based security through the JWT and the `APIKeyCookie`
    class, so we cannot just run `pytest` to test them. First, we need to apply *mocking*
    to these dependencies by adding them to the `dependency_overrides` of the `FastAPI`
    instance. Since `APIRouter` cannot mock dependencies, we need to use the `FastAPI`
    instance to set up `TestClient`. All endpoints can be unit tested if the routers
    are part of the FastAPI configuration through `include_router()`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 测试具有依赖关系的 API 端点不如上一个例子直接。我们的端点通过 JWT 和 `APIKeyCookie` 类实现基于会话的安全，因此不能仅通过运行
    `pytest` 来测试它们。首先，我们需要通过将这些依赖项添加到 `FastAPI` 实例的 `dependency_overrides` 中来对这些依赖项进行模拟。由于
    `APIRouter` 不能模拟依赖项，我们需要使用 `FastAPI` 实例来设置 `TestClient`。如果路由器是 FastAPI 配置的一部分，通过
    `include_router()`，则所有端点都可以进行单元测试：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `/rating/top/three` API from the `/api/route_extract.py` router requires
    a `dict` of ratings to derive a JSON result containing `average` and `sum`. `TestClient`’s
    path operators have JSON and data parameters, where we can pass test data to the
    API. Likewise, `TestClient`’s response has methods that can derive the expected
    response body, such as, in this example, the `json()` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`/rating/top/three` API 来自 `/api/route_extract.py` 路由器，需要 `dict` 类型的评分来生成包含
    `average` 和 `sum` 的 JSON 结果。`TestClient` 的路径操作符具有 JSON 和数据参数，我们可以通过它们向 API 传递测试数据。同样，`TestClient`
    的响应具有可以推导出预期响应体的方法，例如，在这个例子中，`json()` 函数。'
- en: Running the test method will result in some `APIKeyCookie` exceptions due to
    the dependency on session-based security. To bypass this issue, we need to create
    a fake `get_current_user()` dependable function to proceed with the testing. We
    add the `get_current_user()` dependable function into the roster of overrides
    and map it with the fake ones, such as our `get_user()` function, to replace its
    execution. This process is what we call **mocking** in the FastAPI context.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from security, we can also mock the database connection by creating a
    mock database object or database engine, depending on whether it is a relational
    database or a NoSQL database. In the following test case, we are performing a
    unit test in `/ch09/login/list/all`, which needs MongoDB connectivity to access
    the list of login profiles. For the test to work, we need to create a mock `AsyncIOMotorClient`
    object with a dummy test database called `orrs_test`. Here is the `test_list_login()`
    test, which implements this database mocking:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Running test methods
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the `pytest` command on the command line to execute all unit tests. The
    `pytest` engine will compile and run all `TestClient` apps in the `test` folder,
    thus running all the test methods. *Figure 9.5* shows a snapshot of the test result:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The test result'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.05_B17975.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – The test result
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about the `pytest` framework offers a heads-up in understanding
    the automation of test cases in FastAPI. Organizing all test methods through modules
    is essential in the testing phase of the application since we run all of them
    in bulk.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showcased some essential features that were not part of the previous
    chapters but can help fill some gaps during microservice development. One involves
    choosing better and more appropriate JSON serializers and de-serializers when
    converting a huge amount of data into JSON. Also, the advanced customizations,
    session handling, message body encryption and decryption, and testing API endpoints
    gave us a clear understanding of the potential of FastAPI to create cutting-edge
    and progressive microservice solutions. Also, this chapter introduced different
    API responses supported by FastAPI, including Jinja2’s `TemplateResponse`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show us the strength of FastAPI in cracking numerical
    and symbolic computations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
