- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing Other Advanced Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters have already showcased several essential core features
    of the FastAPI framework. However, there are features not truly inherent to the
    framework that can help fine-tune performance and patch missing links in our implementations.
    These include session handling, managing **Cross-Origin Resource Sharing** (**CORS**)-related
    issues, and selecting the appropriate rendition types for an application.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the built-in features, there are workaround solutions proven to work
    with FastAPI when applied to the application, such as its session handling mechanism,
    which can function well using a `SessionMiddleware`. Concerning middleware, this
    chapter will also explore ways of customizing request and response filters other
    than applying the `@app.middleware` decorator. Other issues such as using custom
    `APIRoute` and `Request` will be covered in this chapter to guide us on managing
    incoming *byte* *body*, *form*, or *JSON* data. Moreover, this chapter will highlight
    how to test FastAPI components using the `pytest` framework and the `fastapi.testclient`
    library and how we can document the endpoint using the *OpenAPI 3.x* specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, the main objective of this chapter is to provide us with other solutions
    that can help us complete our microservice applications. In this chapter, the
    following topics are included:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying session management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the CORS mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing `APIRoute` and `Request`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing appropriate responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the OpenAPI 3.x specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the API endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although not data analysis-related, our application prototype for this chapter
    is the `ch09` project.
  prefs: []
  type: TYPE_NORMAL
- en: Applying session management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session management is a feature used for managing requests and responses created
    by a user’s access to an application. It is also about creating and sharing data
    across a user session. Many frameworks usually include session handling features
    in their security plugins but not FastAPI. Creating user sessions and storing
    session data are two separate programming concerns in FastAPI. We use a JWT to
    establish a user session and Starlette’s `SessionMiddleware` to create and retrieve
    session data. Creating user sessions and storing session data are two entirely
    different programming solutions in FastAPI. We use JWT to establish a user session
    and Starlette’s `SessionMiddleware` to create and retrieve session data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating user sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already proven the importance of JWT when it comes to securing FastAPI
    microservice applications in [*Chapter 7*](B17975_07.xhtml#_idTextAnchor190)*,*
    *Securing the REST APIs*. However, here, the JWT is applied to create a session
    based on user credentials. In the `api/login.py` router, an `authenticate()` API
    service is implemented to create a user session for an authenticated user. It
    is inherent for FastAPI to generate user sessions utilizing the browser cookies.
    The following snippet shows the authentication process that uses the cookie values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The service will verify through `LoginRepository` whether the user is a valid
    account using its `username` and `password` credentials. If the user is a certified
    one, it will use a JWT to create a token derived from a certain `secret_key` generated
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The token key will serve as the session ID of the cookie-based session. With
    the `username` credential as its payload, the JWT will be stored as a browser
    cookie named `session`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that `session` has been applied, all subsequent requests must undergo
    authentication by the cookie-based session through the `APIKeyCookie` class, an
    API class of the `fastapi.security` module that implements cookie-based authentication.
    The `APIKeyCookie` class fetches the session before it is injected into a dependable
    function for the JWT decoding through the `secret_key` value used to generate
    the session ID. The following dependable function in `util/auth_session.py` will
    verify every access to each endpoint of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function is injected into every API endpoint to impose user session
    verification. When an endpoint is requested, this function will decode the token
    and extract the `username` credential for account validation. Then, it will issue
    *Status Code 403 (Forbidden)* if the user is an *unauthenticated* one or the *session
    is not valid*. An example of an authenticated service can be found in the following
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `add_restaurant()` service is an endpoint that adds a restaurant `Document`
    to the MongoDB collection. But before the transaction proceeds, it checks first
    whether there is a cookie-based session through the injected `get_current_user()`
    dependable function.
  prefs: []
  type: TYPE_NORMAL
- en: Managing session data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, adding and retrieving session data is not part of `APIKeyCookie`-based
    session authentication. The JWT payload must only include the username but not
    all credentials and body of data. To manage session data, we need to create a
    separate session using Starlette’s `SessionMiddleware`. Although FastAPI has its
    `fastapi.middleware` module, it still supports Starlette’s built-in middleware.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned middleware in [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033)*,*
    *Exploring the Core Features*, and showed its implementation using the `@app.middleware`
    decorator. And we have proven that it acts as a filter for all incoming requests
    and outgoing responses to the services. This time, we will not custom implement
    a middleware but built-in middleware classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Middleware is implemented, configured, and activated in the `main.py` module
    where the instance of `FastAPI` is located because `APIRouter` cannot add middleware.
    We enable the `middleware` parameter of the FastAPI constructor and add to that
    List-type parameter the built-in `SessionMiddleware` with its `secret_key` and
    the name of the new session as constructor parameters using the injectable class,
    `Middleware`. The following code snippet of `main.py` shows you how to configure
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another way of adding middleware is to utilize the `add_middleware()` function
    of the `FastAPI` decorator. Initially, adding `SessionMiddleware` will create
    another cookie-based session that will handle *session-scoped data*. It is the
    only way since there is no direct support from FastAPI regarding session handling
    mechanisms where a user session is created not only for security but also for
    handling session objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add session data to our newly created session, `session_vars`, we need to
    inject `Request` into each endpoint service and utilize its session dictionary
    to store the session-scoped objects. The following `list_restaurants()` service
    retrieves the list of restaurants from the database, extracts all the restaurant
    names, and shares the list of names across the session through `request.session[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, the `list_restaurant_names()` service retrieves the `resto_names`
    session data through `request.session[]` and returns it as its response. By the
    way, it is due to `SessionMiddleware` that `session[]` exists. Otherwise, the
    use of this dictionary will raise an change to - exception.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is always mandatory to log out from the application when done with the transactions
    to remove all the sessions created. Since the easiest and most direct way of creating
    sessions is through browser cookies, removing all the sessions protects the application
    from any compromise. The following `/ch09/logout` endpoint removes our sessions,
    `session` and `session_vars`, which technically logs out the user from the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `delete_cookie()` method of the `Response` class removes any existing browser
    session utilized by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing BaseHTTPMiddleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default approach in managing FastAPI sessions is through cookies, and it
    does not offer any other options such as database-backed, cached, and file-based
    sessions. The best way to implement non-cookie-based strategies for managing user
    sessions and session data is to customize `BaseHTTPMiddleware`. The following
    custom middleware is a prototype that creates user sessions for authenticated
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed in [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033)*,* *Exploring
    the Core Features*, `SessionDbMiddleware` will filter our `/ch09/login/authenticate`
    endpoint for the `username` and `password` query parameters, check whether the
    user is a registered one, and generate a database-backed session from the JWT.
    Afterward, endpoints can validate all their requests from the session stored in
    the database. The `/ch09/logout` endpoint will not include the deletion of the
    session from the database using its repository transactions, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that `DbSessionRepository` is a custom repository implementation for our
    prototype, and it has a `delete_session()` method that will remove the session
    through its name from the `db_session` collection of our MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: Another type of middleware that can help FastAPI applications resolve issues
    regarding the CORS browser mechanism is `CORSMiddleware`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the CORS mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When integrating API endpoints with various frontend frameworks, we often encounter
    the "*no ‘access-control-allow-origin’ header present*" error from our browser.
    Nowadays, this setup is an HTTP-header-based mechanism of any browser, which requires
    the backend server to provide the browser with the "origin" details of the server-side
    application, which includes the server domain, scheme, and port. This mechanism
    is called CORS, which happens when the frontend application and its web resources
    belong to a different domain area than the backend app. Nowadays, browsers prohibit
    cross-origin requests between the server-side and frontend applications for security
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this issue, we need our `main.py` module to place all the origins
    of our application and other integrated resources used by the prototype inside
    a `List`. Then, we import the built-in `CORSMiddleware` from the `fastapi.middleware.cors`
    module and add that to the `FastAPI` constructor with the list of origins, which
    should not be too long to avoid overhead from validating each URL. The following
    code snippet shows the injection of `CORSMiddleware` into the `FastAPI` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we used FastAPI’s `add_middleware()` function to add CORS support
    to our application. Aside from `allow_origins`, we also need to add into `CORSMiddleware`
    the `allow_credentials` parameter, which adds `Access-Control-Allow-Credentials:
    true` to the response header for the browser to recognize the domain origin matches
    and send an `Authorization` cookie to allow the request. Also, we must include
    the `allow_headers` parameter, which registers a list of acceptable header keys
    during browser interaction. Aside from `Accept`, `Accept-Language`, `Content-Language`,
    and `Content-Type`, which are included by default, we need to register `Access-Control-Allow-Origin`,
    `Access-Control-Allow-Credentials`, `Access-Control-Allow-Headers`, and `Access-Control-Max-Age`
    explicitly instead of using the asterisk (`*`). The `allow_headers` parameter
    must also be part of the middleware to specify other HTTP methods that need to
    be supported by the browser. And lastly, the `max_age` parameter must also be
    in the configuration because we need to tell the browser the amount of time it
    will cache all the resources loaded into the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: If the application needs additional CORS support features, customizing the `CORSMiddleware`
    to extend some built-in utilities and features to manage CORS is a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, it is not only the middleware that we can subclass and use to create
    custom implementations of but also the `Request` data and API routes.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing APIRoute and Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Middleware can process incoming `Request` data and outgoing `Response` objects
    of all API methods in a FastAPI application, except that it cannot manipulate
    the message body, attach state objects from the `Request` data, or modify the
    response object before the client consumes it. Only `APIRoute` and `Request` customization
    can give us a full grasp of how to control the request and response transaction.
    The control might include determining whether the incoming data is a byte body,
    form, or JSON and providing an effective logging mechanism, exception handling,
    content transformation, and extraction.
  prefs: []
  type: TYPE_NORMAL
- en: Managing body, form, or JSON data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike in middleware, customizing `APIRoute` does not apply to all the API
    endpoints. Implementing `APIRoute` for some `APIRouter` will only impose new routing
    rules to those affected endpoints, while the other services can pursue the default
    request and response process. For instance, the following customization is responsible
    for data extraction that only applies to the endpoints of `api.route_extract.router`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Customizing `APIRoute` requires the creation of a Python `Request` and `Response`
    flow from `APIRoute`’s `original_route_handler`. On the other hand, our `ExtractContentRoute`
    filter uses a custom `ExtractionRequest` that identifies and processes each type
    of incoming request data separately. The following is the implementation of `ExtractionRequest`
    that will replace the default `Request` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To activate this `ExtractionRequest`, we need to set the `route_class` of the
    `APIRouter` of the endpoints to `ExtractContentRoute`, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three methods of choice to override when managing various request
    bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`body()`: This manages incoming request data that is in bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form()`: This processes incoming form data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json()`: This manages incoming parsed JSON data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream()`: This accesses the body via a chunk of bytes using the `async for`
    construct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these methods return the original request body in bytes back to the service.
  prefs: []
  type: TYPE_NORMAL
- en: In `ExtractionRequest`, we have implemented three interface methods from the
    given choices to filter and process all incoming requests of the API endpoints
    defined in the `/api/route_extract.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `create_profile()` service accepts profile data from the client
    and implements the `ExtractContentRoute` filter, which will store all of this
    profile data in the dictionary using session handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The overridden `form()` method of `ExtractionRequest` is responsible for the
    `user_details` attribute containing all the user details.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the given `set_ratings()` method has an incoming dictionary
    of various ratings in which the `json()` override will derive some basic statistics.
    All the results will be returned as `Request`’s state objects or request attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, the preceding `compute_data()` service will have an incoming list
    of ratings as a source of some basic statistics like in the previous service.
    The `body()` method override of `ExtractionRequest` will process the computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Encrypting and decrypting the message body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another scenario where we need to customize the routing of the endpoints is
    when we must secure the message body through encryption. The following custom
    request decrypts an encrypted body using Python’s `cryptography` module and the
    key of the encrypted body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `cryptography` module requires the installation of the `itsdangerous` extension
    for the encryption/decryption procedure used in this project.
  prefs: []
  type: TYPE_NORMAL
- en: '`DecryptRequest` will decrypt the message and return the list of login records
    as a request `state` object. The following service provides the encrypted message
    body and key and returns the decrypted list of login records from `DecryptRequest`
    as a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that `send_decrypt_login()` has an `EncLoginReq` request model that contains
    the encrypted message body and the encryption key from the client.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the routes and their `Request` objects can help optimize and streamline
    microservice transactions, especially those API endpoints that require heavy loads
    on message body conversions, transformations, and computations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our next discussion will focus on applying different `Response` types for
    the API services.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the appropriate responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The FastAPI framework offers other options for rendering API endpoint responses
    other than the most common `JsonResponse` option. Here is a list of some of the
    response types supported by FastAPI and their corresponding samples from our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The API endpoints can utilize the `PlainTextResponse` type if their response
    is text-based only. The following `intro_list_restaurants()` service returns a
    text-based message to the client:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Services can use `RedirectResponse` if they need to pursue navigation to another
    entirely different application or another endpoint of the same application. The
    following endpoint jumps to a hypertext reference about some known Michelin-starred
    restaurants:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A `FileResponse` type can help services render some content of a file, preferably
    text-based files. The following `load_questions()` service shows the list of questions
    saved in the `questions.txt` file placed inside the `/file` folder of the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`StreamingResponse` is another response type that can provide us with another
    approach to the `EventSourceResponse` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Services that render images can also use the `StreamingResponse` type. The
    following `logo_upload_png()` service uploads any **JPEG** or **PNG** file and
    renders it in the browser:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `StreamingResponse` type is also effective in rendering videos in various
    formats such as `sample.mp4` and publishes it to the browser:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the service wants to publish a simple HTML markup page without making references
    to static CSS or JavaScript files, then `HTMLResponse` is the right choice. The
    following service renders an HTML page with a Bootstrap framework provided by
    some CDN libraries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the API endpoints have other rendition types needed to be published, the
    `Response` class can customize them through its `media_type` property. The following
    is a service that converts JSON data into XML content by setting the `media_type`
    property of `Response` to the `application/xml` MIME type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although FastAPI is not a web framework, it can support Jinja2 templating for
    rare cases where API services require rendering their response as an HTML page.
    Let us highlight how API services utilize Jinja2 templates as part of the response.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Jinja2 template engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to install the `jinja2` module using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create a folder that will hold all the Jinja2 templates. Jinja2
    must define this folder, usually named `templates`, by creating the `Jinja2Templates`
    instance in `FastAPI` or any `APIRouter`. The following snippet is part of the
    `/api/login.py` router that shows the setup and configuration of the Jinja2 templating
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the static resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the `templates` folder, the Jinja2 engine requires the application to
    have a folder named `static` in the project directory to hold the CSS, JavaScript,
    images, and other static files for the Jinja2 templates. Then, we need to instantiate
    the `StaticFiles` instance to define the `static` folder and map it with a virtual
    name. Additionally, the `StaticFiles` instance must be mounted to a specific path
    through `FastAPI`’s `mount()` method. We also need to set the `html` property
    of the `StaticFiles` instance to `True` to set the folder in HTML mode. The following
    configuration shows how to set up the static resource folder in the `main.py`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For the FastAPI components to access these static files, the engine needs the
    `aiofiles` extension installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Creating the template layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following template is the `static` folder due to the template engine and
    `aiofiles` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Other templates can inherit the structure and design of this `layout.html`
    using the `{% extends %}` tags. The Jinja2 base template, like our `layout.html`,
    has these Jinja2 tags, namely the `{% block content %}` and `{% endblock %}` tags,
    which indicate where child templates can insert their content during the translation
    phase. But for all these templates to work, they must be saved in the `/templates`
    directory. The following is a sample child template named `users.html` that generates
    a table of profiles from the context data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the child Jinja2 template also has the "block" tags to mark the
    content to be merged into the parent template.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the API to render the templates, the service must use the Jinja2 engine’s
    `TemplateResponse` type as the response type. `TemplateResponse` needs the filename
    of the template, the `Request` object, and the context data if there is any. The
    following is the API service that renders the previous `users.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using ORJSONResponse and UJSONResponse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to yielding numerous dictionaries or JSON-able-components, it
    is appropriate to use either `ORJSONResponse` or `UJSONResponse`. `ORJSONResponse`
    uses `orjson` to serialize a humongous listing of dictionary objects into a JSON
    string as a response. So, first, we need to install `orjson` using the `pip` command
    before using `ORJSONResponse`. `ORJSONResponse` serializes UUID, `numpy`, data
    classes, and datetime objects faster than the common `JSONResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: However, `UJSONResponse` is relatively faster than `ORJSONResponse` because
    it uses the `ujson` serializer. The `ujson` serializer must first be installed
    before using `UJSONResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two API services that use these two fast alternatives
    for a JSON serializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We still need to apply the `jsonable_encoder()` component to convert `BSON`’s
    `ObjectId` of the result into `str` before the two responses pursue their serialization
    processes. Now, let us focus on how we provide internal API documentation using
    the OpenAPI 3.0 specification.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the OpenAPI 3.x specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenAPI 3.0 specification is a standard API documentation and language-agnostic
    specification that can describe the API services without knowing its sources,
    reading its documentation, and understanding its business logic. Additionally,
    FastAPI supports OpenAPI, and it can even automatically generate the default internal
    documentation of the API based on OpenAPI standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to document our API services using the specification:'
  prefs: []
  type: TYPE_NORMAL
- en: By extending the OpenAPI schema definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the internal code base properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the `Query`, `Body`, `Form`, and `Path` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the OpenAPI schema definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FastAPI has a `get_openapi()` method from its `fastapi.openapi.utils` extension
    that can override some schema descriptions. We can modify the `info`, `servers`,
    and `paths` details of the schema definition through the `get_openapi()` function.
    The function returns a `dict` of all details of the OpenAPI schema definition
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default OpenAPI schema documentation is always set up in the `main.py`
    module because it is consistently associated with the FastAPI instance. For the
    function to generate the `dict` of schema details, it must accept at least the
    `title`, `version`, and `routes` parameter values. The following custom function
    extracts the default *OpenAPI* schema for updating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `title` parameter value is the document title, the `version` parameter
    value is the version of the API implementation, and `routes` contains a list of
    registered API services. Observe that the last line before the `return` statement
    updates FastAPI’s built-in `openapi_schema` defaults. Now, to update the general
    information details, we use the `info` key of the schema definition to change
    some values, as shown in the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding info schema update must also be part of the `update_api_schema()`
    function together with the update on the documentation of each registered API
    service. These details can includeAPI service''s description and summary, the
    POST endpoint''s description of its `requestBody` and GET endpoint''s details
    about its parameters, and the API tags. Add the following `paths` updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding will give us a new OpenAPI document dashboard, as shown in *Figure
    9.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – A customized OpenAPI dashboard](img/Figure_9.01_B17975.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – A customized OpenAPI dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Tags are essential variables of the OpenAPI documentation because they organize
    the API endpoints according to the routers, business processes, requirements,
    and modules. It is a best practice to use tags.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the updates have been set, replace FastAPI’s `openapi()` function with
    the new `update_api_schema()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the internal code base properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FastAPI’s constructor has parameters that can replace the default info document
    details without using the `get_openapi()` function. The following snippet showcases
    a sample documentation update on the `title`, `description`, `version`, and `servers`
    details of the OpenAPI documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding documentation to the API endpoints, the path operators of `FastAPI`
    and `APIRouter` also have parameters that allow changes to the default OpenAPI
    variables attributed to each endpoint. The following is a sample service that
    updates its `summary`, `description`, `response_description`, and other response
    details through the `post()` path operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using the Query, Form, Body, and Path functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aside from the declaration and additional validations, the `Query`, `Path`,
    `Form`, and `Body` parameter functions can also be used to add some metadata to
    the API endpoints. The following `authenticate()` endpoint has added descriptions
    and validations through the `Query()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `get_login()` uses the `Path()` directive to insert a description
    of the `id` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `description` and `max_length` metadata of the `Query()` function will
    become part of the OpenAPI documentation for `authenticate()`, as shown in *Figure
    9.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The Query metadata](img/Figure_9.02_B17975.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The Query metadata
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the `description` metadata of the `Path()` directive will also
    appear in the `get_login()` documentation, as presented in *Figure 9.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The Path metadata'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.03_B17975.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – The Path metadata
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, we can add descriptions to form parameters using the `Form` directive.
    The following service shows you how to insert documentation through the `Form`
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, it is also possible to document all types of HTTP responses or status
    codes that the API service can throw through the path operator’s `responses` parameter.
    The following `video_presentation()` service provides metadata regarding the nature
    of its response when it encounters no errors (*HTTP Status Code 200*) and with
    runtime errors (*HTTP Status Code 500*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`Error500Model` is a `BaseModel` class that will give you a clear picture of
    the response once the application encounters an *HTTP Status Code 500* error and
    will only be used in the OpenAPI documentation. It contains metadata such as the
    message that holds a hardcoded error message. *Figure 9.4* shows the resulting
    OpenAPI documentation for `video_presentation()` after adding the metadata for
    its responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The documentation for API responses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.04_B17975.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – The documentation for API responses
  prefs: []
  type: TYPE_NORMAL
- en: And now, for our last discussion, let us explore how we can perform unit testing
    in FastAPI, which could lead to a test-driven development setup.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FastAPI uses the `pytest` framework to run its test classes. So, before we
    create our test classes, first, we need to install the `pytest` framework using
    the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: FastAPI has a module called `fastapi.testclient` where all components are `Request`-based,
    including the `TestClient` class. To access all the API endpoints, we need the
    `TestClient` object. But first, we need to create a folder such as `test`, which
    will contain test modules where we implement our test methods. We place our test
    methods outside `main.py` or the router modules to maintain clean code and organization.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the unit test cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a best practice to write one test module per router component, except
    for cases where there is a tight connection between these routers. We place these
    test modules inside the `test` directory. To pursue the automated testing, we
    need to import the `APIRouter` instance or the `FastAPI` instance into the test
    module to set up `TestClient`. `TestClient` is almost like Python’s client module,
    `requests`, when it comes to the helper methods used to consume APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method names of the test cases must start with a `test_` prefix, which
    is a `pytest` requirement. Test methods are all standard Python methods and should
    not be asynchronous. The following is a test method in `test/test_restaurants.py`
    that checks whether the endpoint returns the proper text-based response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`TestClient` supports assert statements that check the response of its helper
    methods, like `get()`, `post()`, `put()`, and `delete()` the status code and response
    body of the API. The `test_restaurant_index()`, for instance, uses the `get()`
    method of the TestClient API to run `/restaurant/index` GET service and extract
    its response. The assert statements are used if the `statuc_code` and `response.text`
    are correct. The endpoint has no imposed dependencies, so the test module is *router-based*.'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing API endpoints with dependencies is not as straightforward as the previous
    example. Our endpoints have session-based security through the JWT and the `APIKeyCookie`
    class, so we cannot just run `pytest` to test them. First, we need to apply *mocking*
    to these dependencies by adding them to the `dependency_overrides` of the `FastAPI`
    instance. Since `APIRouter` cannot mock dependencies, we need to use the `FastAPI`
    instance to set up `TestClient`. All endpoints can be unit tested if the routers
    are part of the FastAPI configuration through `include_router()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `/rating/top/three` API from the `/api/route_extract.py` router requires
    a `dict` of ratings to derive a JSON result containing `average` and `sum`. `TestClient`’s
    path operators have JSON and data parameters, where we can pass test data to the
    API. Likewise, `TestClient`’s response has methods that can derive the expected
    response body, such as, in this example, the `json()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test method will result in some `APIKeyCookie` exceptions due to
    the dependency on session-based security. To bypass this issue, we need to create
    a fake `get_current_user()` dependable function to proceed with the testing. We
    add the `get_current_user()` dependable function into the roster of overrides
    and map it with the fake ones, such as our `get_user()` function, to replace its
    execution. This process is what we call **mocking** in the FastAPI context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from security, we can also mock the database connection by creating a
    mock database object or database engine, depending on whether it is a relational
    database or a NoSQL database. In the following test case, we are performing a
    unit test in `/ch09/login/list/all`, which needs MongoDB connectivity to access
    the list of login profiles. For the test to work, we need to create a mock `AsyncIOMotorClient`
    object with a dummy test database called `orrs_test`. Here is the `test_list_login()`
    test, which implements this database mocking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Running test methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the `pytest` command on the command line to execute all unit tests. The
    `pytest` engine will compile and run all `TestClient` apps in the `test` folder,
    thus running all the test methods. *Figure 9.5* shows a snapshot of the test result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The test result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.05_B17975.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – The test result
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about the `pytest` framework offers a heads-up in understanding
    the automation of test cases in FastAPI. Organizing all test methods through modules
    is essential in the testing phase of the application since we run all of them
    in bulk.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showcased some essential features that were not part of the previous
    chapters but can help fill some gaps during microservice development. One involves
    choosing better and more appropriate JSON serializers and de-serializers when
    converting a huge amount of data into JSON. Also, the advanced customizations,
    session handling, message body encryption and decryption, and testing API endpoints
    gave us a clear understanding of the potential of FastAPI to create cutting-edge
    and progressive microservice solutions. Also, this chapter introduced different
    API responses supported by FastAPI, including Jinja2’s `TemplateResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show us the strength of FastAPI in cracking numerical
    and symbolic computations.
  prefs: []
  type: TYPE_NORMAL
