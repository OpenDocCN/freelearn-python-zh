["```py\nfrom Blender import Node\n\nclass MyNode(Node.Scripted):\n\n   def __init__(self, sockets):\n      sockets.input = [Node.Socket('Coords', val= 3*[1.0])]\n\t  sockets.output = [Node.Socket('Color', val = 4*[1.0])]\n\n   def __call__(self):\n      x,y,z = self.input.Coords\n      self.output.Color = [abs(x),abs(y),abs(z),1.0]\n```", "```py\nfrom Blender import Node,Noise,Scene\nfrom math import sqrt,sin,cos,pi,exp,floor\nfrom Blender.Mathutils import Vector as vec\n\n# create regular tilings to be used as a color map\n\nclass Tilings(Node.Scripted):\n   def __init__(self, sockets):\n      sockets.input = [Node.Socket('type' , val= 2.0, min = 1.0, max = 3.0),\n                       Node.Socket('scale' , val= 2.0, min = 0.1, max = 10.0),\n                       Node.Socket('color1', val= [1.0,0.0,0.0,1.0]),\n                       Node.Socket('color2', val= [0.0,1.0,0.0,1.0]),\n                       Node.Socket('color3', val= [0.0,0.0,1.0,1.0]),\n                       Node.Socket('Coords', val= 3*[1.0])]\n\n      sockets.output = [Node.Socket('Color', val = 4*[1.0])]\n```", "```py\n      self.cos45 = cos(pi/4)\n      self.sin45 = sin(pi/4)\n      self.stretch = 1/sqrt(3.0)\n      self.cmap = { (0,0):None,(0,1):2,   (0,2):0,(1,0):0,   (1,1):1,   (1,2):None,(2,0):2,   (2,1):None,(2,2):1 }\n```", "```py\n   def __call__(self):\n\n      tex_coord = self.input.Coords\n      # we disregard any z coordinate\n      x = tex_coord[0]*self.input.scale \n      y = tex_coord[1]*self.input.scale\n\n      c1 = self.input.color1\n      c2 = self.input.color2\n      c3 = self.input.color3\n\n      col= c1\n```", "```py\n      if self.input.type<= 1.0:\n         col = self.triangle(x,y,c1,c2)\n      elif self.input.type <= 2.0:\n         col = self.checker(x,y,c1,c2)\n      else:\n         col = self.hexagon(x,y,c1,c2,c3)\n\n      self.output.Color = col\n```", "```py\n   def checker(self,x,y,c1,c2):\n      if int(floor(x%2)) ^ int(floor(y%2)):\n         return c1\n      return c2\n```", "```py\n   def triangle(self,x,y,c1,c2):\n      y *= self.stretch\n      x,y = self.cos45*x - self.sin45*y, self.sin45*x + self.cos45*y\n      if int(floor(x%2)) ^ int(floor(y%2)) ^ int(y%2>x%2) : return c1\n      return c2\n```", "```py\n   def hexagon(self,x,y,c1,c2,c3):\n      y *= self.stretch\n      x,y = self.cos45*x - self.sin45*y, self.sin45*x + self.cos45*y\n      xf = int(floor(x%3))\n      yf = int(floor(y%3))\n      top = int((y%1)>(x%1))\n\t  c = self.cmap[(xf,yf)]\n      if c == None:\n         if top :\n            c = self.cmap[(xf,(yf+1)%3)]\n         else :\n            c = self.cmap[(xf,(yf+2)%3)]\n      return (c1,c2,c3)[c]\n```", "```py\n__node__ = Tilings\n```", "```py\ndef triangle(self,x,y):\n      y *= self.stretch\n      x,y = self.cos45*x - self.sin45*y, self.sin45*x + self.cos45*y\n\n      if int(floor(x%2)) ^ int(floor(y%2)) ^ int(y%2>x%2) :\n\t     return [floor(x),floor(y),0.0]\n      return [floor(x)+0.5,floor(y),0.0]\n```", "```py\nfrom Blender import Node\nfrom math import cos\nfrom Blender.Mathutils import Vector as vec\n\nclass Ripples(Node.Scripted):\n   def __init__(self, sockets):\n      sockets.input = [Node.Socket('amplitude' , val= 1.0, min = 0.001, max = 1.0),\n                       Node.Socket('wavelength', val= 1.0, min = 0.01, max = 1000.0),\n                       Node.Socket('direction' , val= [1.0,0.0,0.0]),\n                       Node.Socket('Coords'    , val= 3*[1.0])]\n\n      sockets.output = [Node.Socket('Normal', val = [0.0,0.0,1.0])]\n\n   def __call__(self):\n\n      norm = vec(0.0,0.0,1.0)\n\n      p = vec(self.input.Coords)\n      d = vec(self.input.direction)\n      x = p.dot(d)*self.input.wavelength\n      norm.x=-self.input.amplitude*cos(x)\n\n      n = norm.normalize()\n\n      self.output.Normal = n*.01\n\n__node__ = Ripples\n```", "```py\nscn               = Scene.GetCurrent()\ncontext           = scn.getRenderingContext()\ncurrent_frame     = context.currentFrame()\nstart_frame       = context.startFrame()\nend_frame         = context.endFrame()\nframes_per_second = context.fps\n```", "```py\nabsolute_time = current_frame/float(frames_per_second)\nrelative_time = (current_frame-start_frame)/float(frames_per_second)\n```", "```py\nposition_of_maximum=speed*time\ndamping = 1.0/(1.0+dampf*position_of_maximum)\ndistance = sqrt((x-dropx)**2+(y-dropy)**2)\nheight = damping*a*exp(-(distance-position_of_maximum)**2/c)* \\cos(freq*(distance-position_of_maximum))\n```", "```py\nclass MyNode(Node.Scripted):\n\n   def __init__(self, sockets):\n      sockets.input   = [Node.Socket('InputParam', val = 1.0)]\n      sockets.output  = [Node.Socket('OutputVal' , val = 1.0)]\n      self.InputParam = None\n      self.Result     = None\n\n   def __call__(self):\n      if self.InputParam == None or \\\n         self.InputParam != self.input.InputParam :\n         self.InputParam = self.input.InputParam\n         self.Result     = expensive_calculation ...\n      self.output.OutputVal = other_calculations_using_Result …\n```", "```py\nclass Raindrops(Node.Scripted):\n   def __init__(self, sockets):\n      sockets.input = [Node.Socket('Drops_per_second'  , val = 5.0,min = 0.01, max = 100.0),\n                       Node.Socket('a',val=5.0,min=0.01,max=100.0),\n                       Node.Socket('c',val=0.04,min=0.001,max=10.0),\n                       Node.Socket('speed',val=1.0,min=0.001,max=10.0),\n                       Node.Socket('freq',val=25.0,min=0.1,max=100.0),\n                       Node.Socket('dampf',val=1.0,min=0.01,max=100.0),\n                       Node.Socket('Coords', val = 3*[1.0])]\n\n      sockets.output = [Node.Socket('Height', val = 1.0),\n                        Node.Socket('Normal', val = 3 *[0.0])]\n\n      self.drops_per_second = None\n      self.ndrops = None\n```", "```py\n   def __call__(self):\n\n      twopi = 2*pi\n\n      col = [0,0,0,1]\n      nor = [0,0,1]\n      tex_coord = self.input.Coords\n      x = tex_coord[0] \n      y = tex_coord[1]\n\n      a = self.input.a\n      c = self.input.c\n\n\t  Noise.setRandomSeed(42)\n\n      scn               = Scene.GetCurrent()\n      context           = scn.getRenderingContext()\n      current_frame     = context.currentFrame()\n      start_frame       = context.startFrame()\n      end_frame         = context.endFrame()\n      frames_per_second = context.fps\n      time              = current_frame/float(frames_per_second)\n```", "```py\n      drops_per_second = self.input.Drops_per_second\n      # calculate the number of drops to generate\n      # in the animated timeframe\n      ndrops = 1 + int(drops_per_second * (float(end_frame) –\n               start_frame+1)/frames_per_second )\n\n\t  if self.drops_per_second != drops_per_second\n\t  or self.ndrops != ndrops:\n         self.drop = [ (Noise.random(), Noise.random(),\n                       Noise.random() + 0.5) for i in range(ndrops)]\n         self.drops_per_second = drops_per_second\n         self.ndrops = ndrops\n```", "```py\n      speed=self.input.speed\n      freq=self.input.freq\n      dampf=self.input.dampf\n\n      height = 0.0\n      height_dx = 0.0\n      height_dy = 0.0\n      nabla = 0.01\n\t  for i in range(1+int(drops_per_second*time)):\n         dropx,dropy,dropsize = self.drop[i]\n         position_of_maximum=speed*time-i/float(drops_per_second)\n         damping = 1.0/(1.0+dampf*position_of_maximum)\n         distance = sqrt((x-dropx)**2+(y-dropy)**2)\n         height += damping*a*dropsize*\n            exp(-(distance-position_of_maximum)**2/c)*\n         cos(freq*(distance-position_of_maximum))\n         distance_dx = sqrt((x+nabla-dropx)**2+(y-dropy)**2)\n         height_dx += damping*a*dropsize*\nexp(-(distance_dx-position_of_maximum)**2/c)*\ncos(freq*(distance_dx-position_of_maximum))\n         distance_dy = sqrt((x-dropx)**2+(y+nabla-dropy)**2)\n         height_dy += damping*a*dropsize*\nexp(-(distance_dy-position_of_maximum)**2/c)*\ncos(freq*(distance_dy-position_of_maximum))\n```", "```py\n      nor[0]=height-height_dx\n      nor[1]=height-height_dy\n\n\t  height /= ndrops * a\n      self.output.Height = height\n\n      N = (vec(self.shi.surfaceNormal)+0.2*vec(nor)).normalize()\n      self.output.Normal= N\n\n__node__ = Raindrops\n```", "```py\nclass Slope(Node.Scripted):\n   def __init__(self, sockets):\n      sockets.output = [Node.Socket('SlopeX', val = 1.0),Node.Socket('SlopeY', val = 1.0),Node.Socket('SlopeZ', val = 1.0),]\n      self.offset =  vec([1,1,1])\n      self.scale =  0.5\n```", "```py\n   def __call__(self):\n\n      scn=Scene.GetCurrent()\n      cam=scn.objects.camera\n      rot=cam.getMatrix('worldspace').rotationPart().resize4x4();\n\n      N = vec(self.shi.surfaceNormal).normalize().resize4D() * rot\n      N = (N + self.offset ) * self.scale\n      self.output.SlopeX=N[0]\n      self.output.SlopeY=N[1]\n      self.output.SlopeZ=N[2]\n\n__node__ = Slope\n```", "```py\nclass Iridescence(Node.Scripted):\n   def __init__(self, sockets):\n      sockets.input = [ Node.Socket('Coords', val= 3*[1.0]),Node.Socket('Thickness', val=275.0,min=100.0, max=1000.0),Node.Socket('Variation', val=0.5, min=0.0,max=1.0)]\n\n      sockets.output = [Node.Socket('Distance', val=0.5, min=0.0,max=1.0)]\n```", "```py\n   def __call__(self):\n\n      P = vec(self.input.Coords)\n      scn=Scene.GetCurrent()\n      lamps = [ob for ob in scn.objects if ob.type == 'Lamp']\n\n      lamp = lamps[0]\n\n      cam=scn.objects.camera\n      rot=cam.getMatrix('worldspace').rotationPart().resize4x4();\n\t  N = vec(self.shi.surfaceNormal).normalize().resize4D() * rot\n\n      N = N.negate().resize3D()\n      L = vec(lamp.getLocation('worldspace'))\n      I = (P – L).normalize()\n```", "```py\n      angle = VecT(I,N)\n\n      angle_in = pi*angle/180\n      sin_in = sin(angle_in)\n      sin_out = sin_in/1.31\n      angle_out = asin(sin_out)\n\n      thickness = self.input.Thickness + self.input.Variation\n distance = 2.0 * (thickness / cos (angle_out))\n\n```", "```py\n      self.output.Distance = distance\n```"]