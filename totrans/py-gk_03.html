<html><head></head><body>
		<div id="_idContainer027">
			<h1 id="_idParaDest-50"><em class="italic"><a id="_idTextAnchor086"/>Chapter 2</em>: Using Modularization to Handle Complex Projects</h1>
			<p>When you start programming in Python, it is very tempting to put all your program code in a single file. There is no problem in defining functions and classes in the same file where your main program is. This option is attractive to beginners because of the ease of execution of the program and to avoid managing code in multiple files. But a single-file program approach is not scalable for medium- to large-size projects. It becomes challenging to keep track of all the various functions and classes that you define.</p>
			<p>To overcome the situation, modular programming is the way to go for medium to large projects. Modularity is a key tool to reduce the complexity of a project. Modularization also facilitates efficient programming, easy debugging and management, collaboration, and reusability. In this chapter, we will discuss how to build and consume modules and packages in Python.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introduction to modules and packages</li>
				<li>Importing modules</li>
				<li>Loading and initializing a module</li>
				<li>Writing reusable modules</li>
				<li>Building packages</li>
				<li>Accessing packages from any location</li>
				<li>Sharing a package</li>
			</ul>
			<p>This chapter will help you understand the concepts of modules and packages in Python.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor087"/>Technical requirements</h1>
			<p>The following are the technical requirements for this chapter:</p>
			<ul>
				<li>You need to have Python 3.7 or later installed on your computer.</li>
				<li>You need to register an account with Test PyPI and create an API token under your account.</li>
			</ul>
			<p>Sample code for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter02">https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter02</a>.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor088"/>Introduction to modules and packages</h1>
			<p>Modules in<a id="_idIndexMarker164"/> Python are Python files with a <strong class="source-inline">.py</strong> extension. In reality, they are a way to organize functions, classes, and variables using one or more Python files such that they are<a id="_idIndexMarker165"/> easy to manage, reuse across the different modules, and extend as the programs become complex.</p>
			<p>A Python package is the next level of modular programming. A package is like a folder for organizing multiple modules or sub-packages, which is fundamental for sharing the modules for reusability.</p>
			<p>Python source files that use only the standard libraries are easy to share and easy to distribute using email, GitHub, and shared drives, with the only caveat being that there should be Python version compatibility. But this sharing approach will not scale for projects that have a decent number of files and have dependencies on third-party libraries and may be developed for a specific version of Python. To rescue the situation, building and sharing packages is a must for efficient sharing and reusability of Python programs. </p>
			<p>Next, we will discuss how to import modules and the different types of import techniques supported in Python.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor089"/>Importing modules</h1>
			<p>Python code in one module <a id="_idIndexMarker166"/>can get access to the Python code in another module by a process called importing modules. </p>
			<p>To elaborate on the different module and package concepts, we will build two modules and one main script that will use those two modules. These two modules will be updated or reused throughout this chapter.</p>
			<p>To create a new module, we will create a <strong class="source-inline">.py</strong> file with the name of the module. We will create a <strong class="source-inline">mycalculator.py</strong> file with two functions: <strong class="source-inline">add</strong> and <strong class="source-inline">subtract</strong>. The <strong class="source-inline">add</strong> function computes the sum of the two numbers provided to the function as arguments and returns the <a id="_idIndexMarker167"/>computed value. The <strong class="source-inline">subtract</strong> function computes the difference between the two numbers provided to the function as arguments and returns the computed value.</p>
			<p>A code snippet of <strong class="source-inline">mycalculator.py</strong> is shown next:</p>
			<p class="source-code"># <strong class="bold">mycalculator.py</strong> with add and subtract functions</p>
			<p class="source-code">def add(x, y):</p>
			<p class="source-code">    """This function adds two numbers"""</p>
			<p class="source-code">    return x + y</p>
			<p class="source-code">def subtract(x, y):</p>
			<p class="source-code">    """This function subtracts two numbers"""</p>
			<p class="source-code">    return x - y</p>
			<p>Note that the name of the module is the name of the file.</p>
			<p>We will create a second module by adding a new file with the name <strong class="source-inline">myrandom.py</strong>. This module has two functions: <strong class="source-inline">random_1d</strong> and <strong class="source-inline">random_2d</strong>. The <strong class="source-inline">random_1d</strong> function is for generating a random number between 1 and 9 and the <strong class="source-inline">random_2d</strong> function is for generating a random number between 10 and 99. Note that this module is also using the <strong class="source-inline">random</strong> library, which is a built-in module from Python.</p>
			<p>The code snippet of <strong class="source-inline">myrandom.py</strong> is shown next:</p>
			<p class="source-code"># <strong class="bold">myrandom.py</strong> with default and custom random functions</p>
			<p class="source-code">import random</p>
			<p class="source-code">def random_1d():</p>
			<p class="source-code">   """This function generates a random number between 0 \</p>
			<p class="source-code">    and 9"""</p>
			<p class="source-code">   return random.randint (0,9)</p>
			<p class="source-code">def random_2d():</p>
			<p class="source-code">   """This function generates a random number between 10 \</p>
			<p class="source-code">    and 99"""</p>
			<p class="source-code">   return random.randint (10,99)</p>
			<p>To consume these two modules, we also created the main Python script (<strong class="source-inline">calcmain1.py</strong>), which<a id="_idIndexMarker168"/> imports the two modules and uses them to achieve these two calculator functions. The <strong class="source-inline">import</strong> statement is the most common way to import built-in or custom modules.</p>
			<p>A code snippet of <strong class="source-inline">calcmain1.py</strong> is shown next:</p>
			<p class="source-code"># <strong class="bold">calcmain1.py</strong> with a main function</p>
			<p class="source-code">import mycalculator</p>
			<p class="source-code">import myrandom</p>
			<p class="source-code">def my_main( ):</p>
			<p class="source-code">    """ This is a main function which generates two random\     numbers and then apply calculator functions on them """</p>
			<p class="source-code">    x = myrandom.random_2d( )</p>
			<p class="source-code">    y = myrandom.random_1d( )</p>
			<p class="source-code">    sum = mycalculator.add(x, y)</p>
			<p class="source-code">    diff = mycalculator.subtract(x, y)</p>
			<p class="source-code">    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x, y))</p>
			<p class="source-code">    print(<strong class="bold">"sum is {}"</strong>.format(sum))</p>
			<p class="source-code">    print(<strong class="bold">"diff is {}"</strong>.format(diff))</p>
			<p class="source-code"> <strong class="bold">""" This is executed only if the special variable '__name__'  is set as main"""</strong></p>
			<p class="source-code">if __name__ == <strong class="bold">"__main__"</strong>:</p>
			<p class="source-code">    my_main()</p>
			<p>In this main script (another module), we<a id="_idIndexMarker169"/> import the two modules using the <strong class="source-inline">import</strong> statement. We defined the main function (<strong class="source-inline">my_main</strong>), which will be executed only if this script or the <strong class="source-inline">calcmain1</strong> module is executed as the main program. The details of executing the main function from the main program will be covered later in the <em class="italic">Setting special variables</em> section. In the <strong class="source-inline">my_main</strong> function, we are generating two random numbers using the <strong class="source-inline">myrandom</strong> module and then calculating the sum and difference of the two random numbers using the <strong class="source-inline">mycalculator</strong> module. In the end, we are sending the results to the console using the <strong class="source-inline">print</strong> statement.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">A module is loaded only once. If a module is imported by another module or by the main Python script, the module will be initialized by executing the code in the module. If another module in your program imports the same module again, it will not be loaded twice but only once. This means if there are any local variables inside the module, they will act as a Singleton (initialized only once).</p>
			<p>There are other options available to import a module, such as <strong class="source-inline">importlib.import_module()</strong> and the built-in <strong class="source-inline">__import__()</strong> function. Let's discuss how <strong class="source-inline">import</strong> and other alternative options works.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor090"/>Using the import statement</h2>
			<p>As mentioned <a id="_idIndexMarker170"/>already, the <strong class="source-inline">import</strong> statement is a common<a id="_idIndexMarker171"/> way to import a module. The next code snippet is an example of using an <strong class="source-inline">import</strong> statement:</p>
			<p class="source-code">import math</p>
			<p>The <strong class="source-inline">import</strong> statement is responsible for two operations: first, it searches for the module given after the <strong class="source-inline">import</strong> keyword, and then it binds the results of that search to a variable name (which is the same as the module name) in the local scope of the execution. In the next two subsections, we will discuss how <strong class="source-inline">import</strong> works and also how to import specific elements from a module or a package.</p>
			<h3>Learning how import works</h3>
			<p>Next, we need to<a id="_idIndexMarker172"/> understand how the <strong class="source-inline">import</strong> statement works. First, we need to remind ourselves that all global variables and functions are added to the global namespace by the Python interpreter at the start of an execution. To illustrate the concept, we can write a small Python program to spit out of the contents of the <strong class="source-inline">globals</strong> namespace, as shown next: </p>
			<p class="source-code"># <strong class="bold">globalmain.py</strong> with globals() function</p>
			<p class="source-code">def print_globals():</p>
			<p class="source-code">    print (globals())</p>
			<p class="source-code">def hello():</p>
			<p class="source-code">    print (<strong class="bold">"Hello"</strong>)</p>
			<p class="source-code">if __name__ == <strong class="bold">"__main__"</strong>:</p>
			<p class="source-code">    print_globals()</p>
			<p>This program has two functions: <strong class="source-inline">print_globals</strong> and <strong class="source-inline">hello</strong>. The <strong class="source-inline">print_globals</strong> function will spit out the contents of the global namespace. The <strong class="source-inline">hello</strong> function will not be executed and is added here to show its reference in the console output of the global namespace. The console output after executing this Python code will be similar to the<a id="_idIndexMarker173"/> following:</p>
			<p class="source-code">{</p>
			<p class="source-code">   "__name__":"__main__",</p>
			<p class="source-code">   "__doc__":"None",</p>
			<p class="source-code">   "__package__":"None",</p>
			<p class="source-code">   "__loader__":"&lt;_frozen_importlib_external.\</p>
			<p class="source-code">    SourceFileLoader object at 0x101670208&gt;",</p>
			<p class="source-code">   "__spec__":"None",</p>
			<p class="source-code">   "__annotations__":{</p>
			<p class="source-code">   },</p>
			<p class="source-code">   "__builtins__":"&lt;module 'builtins' (built-in)&gt;",</p>
			<p class="source-code">   "__file__":"/ PythonForGeeks/source_code/chapter2/\</p>
			<p class="source-code">     modules/globalmain.py",</p>
			<p class="source-code">   "__cached__":"None",</p>
			<p class="source-code">   "print_globals":"&lt;function print_globals at \</p>
			<p class="source-code">     0x1016c4378&gt;",</p>
			<p class="source-code">   "hello":"&lt;function hello at 0x1016c4400&gt;"</p>
			<p class="source-code">}</p>
			<p>The key points to be noticed in this console output are as follows:</p>
			<ul>
				<li>The <strong class="source-inline">__name__</strong> variable is set to the <strong class="source-inline">__main__</strong> value. This will be discussed in more detail in the <em class="italic">Loading and initializing a module</em> section.</li>
				<li>The <strong class="source-inline">__file__</strong> variable is set to the file path of the main module here.</li>
				<li>A reference to each function is added at the end.</li>
			</ul>
			<p>If we add <strong class="source-inline">print(globals())</strong> to our <strong class="source-inline">calcmain1.py</strong> script, the console output after adding this statement will be similar to the following:</p>
			<p class="source-code">{</p>
			<p class="source-code">   "__name__":"__main__",</p>
			<p class="source-code">   "__doc__":"None",</p>
			<p class="source-code">   "__package__":"None",</p>
			<p class="source-code">   "__loader__":"&lt;_frozen_importlib_external.\</p>
			<p class="source-code">    SourceFileLoader object at 0x100de1208&gt;",</p>
			<p class="source-code">   "__spec__":"None",</p>
			<p class="source-code">   "__annotations__":{},</p>
			<p class="source-code">   "__builtins__":"&lt;module 'builtins' (built-in)&gt;",</p>
			<p class="source-code">   "__file__":"/PythonForGeeks/source_code/chapter2/module1/     main.py",</p>
			<p class="source-code">   "__cached__":"None",</p>
			<p class="source-code">   "mycalculator":"&lt;module 'mycalculator' from \</p>
			<p class="source-code">    '/PythonForGeeks/source_code/chapter2/modules/\</p>
			<p class="source-code">    mycalculator.py'&gt;",</p>
			<p class="source-code">   "myrandom":"&lt;module 'myrandom' from '/PythonForGeeks/source_     code/chapter2/modules/myrandom.py'&gt;",</p>
			<p class="source-code">   "my_main":"&lt;function my_main at 0x100e351e0&gt;"</p>
			<p class="source-code">}</p>
			<p>An important point to note<a id="_idIndexMarker174"/> is that there are two additional variables (<strong class="source-inline">mycalculator</strong> and <strong class="source-inline">myrandom</strong>) added to the global namespace corresponding to each <strong class="source-inline">import</strong> statement used to import these modules. Every time we import a library, a variable with the same name is created, which holds a reference to the module just like a variable for the global functions (<strong class="source-inline">my_main</strong> in this case).</p>
			<p>We will see, in other approaches of importing modules, that we can explicitly define some of these variables for each module. The <strong class="source-inline">import</strong> statement does this automatically for us.</p>
			<h3>Specific import</h3>
			<p>We can also import<a id="_idIndexMarker175"/> something specific (variable or function or class) from a module instead of importing the whole module. This is achieved using the <strong class="source-inline">from</strong> statement, such as the following:</p>
			<p class="source-code">from math import pi</p>
			<p>Another best practice is to use a different name for an imported module for convenience or sometimes when the same names are being used for different resources in two different libraries. To illustrate this idea, we will be updating our <strong class="source-inline">calcmain1.py</strong> file (the updated program is <strong class="source-inline">calcmain2.py</strong>) from the earlier example by using the <strong class="source-inline">calc</strong> and <strong class="source-inline">rand</strong> aliases for the <strong class="source-inline">mycalculator</strong> and <strong class="source-inline">myrandom</strong> modules, respectively. This change will make use of the modules in the main script much simpler, as shown next:</p>
			<p class="source-code"># <strong class="bold">calcmain2.py</strong> with alias for modules</p>
			<p class="source-code">import mycalculator <strong class="bold">as calc</strong></p>
			<p class="source-code">import myrandom <strong class="bold">as rand</strong></p>
			<p class="source-code">def my_main():</p>
			<p class="source-code">    """ This is a main function which generates two random\</p>
			<p class="source-code">     numbers and then apply calculator functions on them """</p>
			<p class="source-code">    x = rand.random_2d()</p>
			<p class="source-code">    y = rand.random_1d()</p>
			<p class="source-code">    sum = calc.add(x,y)</p>
			<p class="source-code">    diff = calc.subtract(x,y)</p>
			<p class="source-code">    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x,y))</p>
			<p class="source-code">    print(<strong class="bold">"sum is {}"</strong>.format(sum))</p>
			<p class="source-code">    print(<strong class="bold">"diff is {}"</strong>.format(diff))</p>
			<p class="source-code"><strong class="bold">""" This is executed only if the special variable '__name__' is set as main"""</strong></p>
			<p class="source-code">if __name__ == <strong class="bold">"__main__"</strong>:</p>
			<p class="source-code">    my_main()</p>
			<p>As a next step, we will combine<a id="_idIndexMarker176"/> the two concepts discussed earlier in the next iteration of the <strong class="source-inline">calcmain1.py</strong> program (the updated program is <strong class="source-inline">calcmain3.py</strong>). In this update, we will use the <strong class="source-inline">from</strong> statement with the module names and then import the individual functions from each module. In the case of the <strong class="source-inline">add</strong> and <strong class="source-inline">subtract</strong> functions, we used the <strong class="source-inline">as</strong> statement to define a different local definition of the module resource for illustration purposes.</p>
			<p>A code snippet of <strong class="source-inline">calcmain3.py</strong> is as follows:</p>
			<p class="source-code"># <strong class="bold">calcmain3.py</strong> with from and alias combined</p>
			<p class="source-code">from mycalculator import <strong class="bold">add as my_add</strong></p>
			<p class="source-code">from mycalculator import <strong class="bold">subtract as my_subtract</strong></p>
			<p class="source-code">from myrandom import random_2d, random_1d</p>
			<p class="source-code">def my_main():</p>
			<p class="source-code">    """ This is a main function which generates two random</p>
			<p class="source-code">     numbers and then apply calculator functions on them """</p>
			<p class="source-code">    x = random_2d()</p>
			<p class="source-code">    y = random_1d()</p>
			<p class="source-code">    sum =  my_add(x,y)</p>
			<p class="source-code">    diff = my_subtract(x,y)</p>
			<p class="source-code">    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x,y))</p>
			<p class="source-code">    print(<strong class="bold">"sum is {}"</strong>.format(sum))</p>
			<p class="source-code">    print(<strong class="bold">"diff is {}"</strong>.format(diff))</p>
			<p class="source-code">    print (globals())</p>
			<p class="source-code"><strong class="bold">""" This is executed only if the special variable '__name__' is set as main"""</strong></p>
			<p class="source-code">if __name__ == <strong class="bold">"__main__"</strong>:</p>
			<p class="source-code">    my_main()</p>
			<p>As we used the <strong class="source-inline">print (globals())</strong> statement with this program, the console output of this program will<a id="_idIndexMarker177"/> show that the variables corresponding to each function are created as per our alias. The sample console output is as follows:</p>
			<p class="source-code">{</p>
			<p class="source-code">   "__name__":"__main__",</p>
			<p class="source-code">   "__doc__":"None",</p>
			<p class="source-code">   "__package__":"None",</p>
			<p class="source-code">   "__loader__":"&lt;_frozen_importlib_external.\</p>
			<p class="source-code">    SourceFileLoader object at 0x1095f1208&gt;",</p>
			<p class="source-code">   "__spec__":"None",</p>
			<p class="source-code">   "__annotations__":{},</p>
			<p class="source-code">   "__builtins__":"&lt;module 'builtins' (built-in)&gt;", "__    file__":"/PythonForGeeks/source_code/chapter2/module1/     main_2.py",</p>
			<p class="source-code">   "__cached__":"None",</p>
			<p class="source-code">   "<strong class="bold">my_add</strong>":"&lt;function add at 0x109645400&gt;",</p>
			<p class="source-code">   "<strong class="bold">my_subtract</strong>":"&lt;function subtract at 0x109645598&gt;",</p>
			<p class="source-code">   "<strong class="bold">random_2d</strong>":"&lt;function random_2d at 0x10967a840&gt;",</p>
			<p class="source-code">   "<strong class="bold">random_1d</strong>":"&lt;function random_1d at 0x1096456a8&gt;",</p>
			<p class="source-code">   "my_main":"&lt;function my_main at 0x109645378&gt;"</p>
			<p class="source-code">}</p>
			<p>Note that the variables in bold correspond <a id="_idIndexMarker178"/>to the changes we made in the <strong class="source-inline">import</strong> statements in the <strong class="source-inline">calcmain3.py</strong> file.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor091"/>Using the __import__ statement</h2>
			<p>The <strong class="source-inline">__import__</strong> statement is a low-level function in Python that takes a string as input and triggers the actual import operation. Low-level functions are part of the core Python language and are<a id="_idIndexMarker179"/> typically meant to be used for library development or for accessing operating system resources, and are not commonly used for application development. We can use this keyword to import the <strong class="source-inline">random</strong> library in our <strong class="source-inline">myrandom.py</strong> module as follows:</p>
			<p class="source-code">#import random</p>
			<p class="source-code">random = __import__(<strong class="bold">'random'</strong>)</p>
			<p>The rest of the code in <strong class="source-inline">myrandom.py</strong> can be used as it is without any change.</p>
			<p>We illustrated a simple case of using the <strong class="source-inline">__import__</strong> method for academic reasons and we will skip the advanced details for those of you who are interested in exploring as further reading. The reason for this is that the <strong class="source-inline">__import__</strong> method is not recommended to be used for user applications; it is designed more for interpreters.</p>
			<p>The <strong class="source-inline">importlib.import_module</strong> statement is the one to be used other than the regular import for advanced functionality.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor092"/>Using the importlib.import_module statement</h2>
			<p>We can import any module using the <strong class="source-inline">importlib</strong> library. The <strong class="source-inline">importlib</strong> library offers a variety of <a id="_idIndexMarker180"/>functions, including <strong class="source-inline">__import__</strong>, related to importing modules in a more flexible way. Here is a simple example of how to import a <strong class="source-inline">random</strong> module in our <strong class="source-inline">myrandom.py</strong> module using <strong class="source-inline">importlib</strong>:</p>
			<p class="source-code">import importlib</p>
			<p class="source-code">random = importlib.import_module('random')</p>
			<p>The rest of the code in <strong class="source-inline">myrandom.py</strong> can be used as it is without any change.</p>
			<p>The <strong class="source-inline">importlib</strong> module is best known for importing modules dynamically and is very useful in cases where the name of the module is not known in advance and we need to import the modules at runtime. This is a common requirement for the development of plugins and extensions.</p>
			<p>Commonly used functions available in the <strong class="source-inline">importlib</strong> module are as follows:</p>
			<ul>
				<li><strong class="source-inline">__import__</strong>: This is the implementation of the <strong class="source-inline">__import__</strong> function, as already discussed.</li>
				<li><strong class="source-inline">import_module</strong>: This is used to import a module and is most commonly used to load a module dynamically. In this method, you can specify whether you want to import a module using an absolute or relative path. The <strong class="source-inline">import_module</strong> function is a wrapper around <strong class="source-inline">importlib.__import__</strong>. Note that the former function brings back the package or module (for example, <strong class="source-inline">packageA.module1</strong>), which is specified with the function, while the latter function always returns the top-level package or module (for example, <strong class="source-inline">packageA</strong>).</li>
				<li><strong class="source-inline">importlib.util.find_spec</strong>: This is a replaced method for the <strong class="source-inline">find_loader</strong> method, which is deprecated since Python release 3.4. This method can be used to validate whether the module exists and it is valid.</li>
				<li><strong class="source-inline">invalidate_caches</strong>: This method can be used to invalidate the internal caches of finders stored at <strong class="source-inline">sys.meta_path</strong>. The internal cache is useful to load the module faster without triggering the finder methods again. But if we are dynamically importing a module, especially if it is created after the interpreter began execution, it is a<a id="_idIndexMarker181"/> best practice to call the <strong class="source-inline">invalidate_caches</strong> method. This function will clear all modules or libraries from the cache to make sure the requested module is loaded from the system path by the <strong class="source-inline">import</strong> system.</li>
				<li><strong class="source-inline">reload</strong>: As the name suggests, this function is used to reload a previously imported module. We need to provide the module object as an input parameter for this function. This means the <strong class="source-inline">import</strong> function has to be done successfully. This function is very helpful when module source code is expected to be edited or changed and you want to load the new version without restarting the program.</li>
			</ul>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor093"/>Absolute versus relative import</h2>
			<p>We <a id="_idIndexMarker182"/>have fairly a good idea of how to use <strong class="source-inline">import</strong> statements. Now it is time to understand <strong class="bold">absolute</strong> and <strong class="bold">relative</strong> imports, especially when we are importing custom or project-specific modules. To illustrate the two<a id="_idIndexMarker183"/> concepts, let's take an example of <a id="_idIndexMarker184"/>a project with different packages, sub-packages, and modules, as shown next:</p>
			<p class="source-code">project</p>
			<p class="source-code">  ├── pkg1</p>
			<p class="source-code">  │   ├── module1.py</p>
			<p class="source-code">  │   └── module2.py (contains a function called func1 ())</p>
			<p class="source-code">  └── pkg2</p>
			<p class="source-code">      ├── __init__.py</p>
			<p class="source-code">      ├── module3.py</p>
			<p class="source-code">      └── sub_pkg1</p>
			<p class="source-code">          └── module6.py (contains a function called func2 ())</p>
			<p class="source-code">  ├── pkg3</p>
			<p class="source-code">  │   ├── module4.py</p>
			<p class="source-code">  │   ├── module5.py</p>
			<p class="source-code">      └── sub_pkg2</p>
			<p class="source-code">          └── module7.py</p>
			<p>Using this project structure, we will <a id="_idIndexMarker185"/>discuss how to use absolute <a id="_idIndexMarker186"/>and relative imports.</p>
			<h3>Absolute import</h3>
			<p>We can use absolute paths starting <a id="_idIndexMarker187"/>from the top-level package and drilling down to the sub-package and module level. A few examples of importing different modules are shown here:</p>
			<p class="source-code">from pkg1 import module1</p>
			<p class="source-code">from <strong class="bold">pkg1.module2</strong> import func1</p>
			<p class="source-code">from pkg2 import module3</p>
			<p class="source-code">from <strong class="bold">pkg2.sub_pkg1.module6</strong> import func2</p>
			<p class="source-code">from pkg3 import module4, module5</p>
			<p class="source-code">from <strong class="bold">pkg3.sub_pkg2</strong> import module7</p>
			<p>For absolute import statements, we must give a detailed path for each package or file, from the top-level package folder, which is similar to a file path.</p>
			<p>Absolute imports are recommended because they are easy to read and easy to follow the exact location of imported resources. Absolute imports are least impacted by project sharing and changes in the current location of <strong class="source-inline">import</strong> statements. In fact, PEP 8 explicitly recommends the use of absolute imports.</p>
			<p>Sometimes, however, absolute imports are quite long statements depending on the size of the project folder structure, which is not convenient to maintain.</p>
			<h3>Relative import</h3>
			<p>A relative import specifies the resource to be imported relative to the current location, which is mainly the current<a id="_idIndexMarker188"/> location of the Python code file where the <strong class="source-inline">import</strong> statement is used.</p>
			<p>For the project examples discussed earlier, here are a few scenarios of relative import. The equivalent relative import statements are as follows:</p>
			<ul>
				<li><strong class="bold">Scenario 1</strong>: Importing <strong class="source-inline">funct1</strong> inside <strong class="source-inline">module1.py</strong>:<p class="source-code"> from <strong class="bold">.</strong>module2 import func1</p><p>We used one dot (<strong class="source-inline">.</strong>) only because <strong class="source-inline">module2.py</strong> is in the same folder as <strong class="source-inline">module1.py</strong>.</p></li>
				<li><strong class="bold">Scenario 2</strong>: Importing <strong class="source-inline">module4</strong> inside <strong class="source-inline">module1.py</strong>:<p class="source-code">from <strong class="bold">..</strong>pkg3 import module4</p><p>In this case, we used two dots (<strong class="source-inline">..</strong>) because <strong class="source-inline">module4.py</strong> is in the sibling folder of <strong class="source-inline">module1.py</strong>.</p></li>
				<li><strong class="bold">Scenario 3</strong>: Importing <strong class="source-inline">Func2</strong> inside <strong class="source-inline">module1.py</strong>:<p class="source-code">from <strong class="bold">..</strong>pkg2.sub_pkg_1.module2 import Func2</p><p>For this scenario, we used two dots (<strong class="source-inline">..</strong>) because the target module (<strong class="source-inline">module2.py</strong>) is inside a folder that is in the sibling folder of <strong class="source-inline">module1.py</strong>. We used one dot to access the <strong class="source-inline">sub_pkg_1</strong> package and another dot to access <strong class="source-inline">module2</strong>.</p></li>
			</ul>
			<p>One advantage of relative imports is that they are simple and can significantly reduce long <strong class="source-inline">import</strong> statements. But relative <strong class="source-inline">import</strong> statements can be messy and difficult to maintain when projects are shared across teams and organizations. Relative imports are not easy to read and manage.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor094"/>Loading and initializing a module</h1>
			<p>Whenever the Python interpreter interacts with an <strong class="source-inline">import</strong> or equivalent statement, it does three operations, which are described in the next sections.</p>
			<h3>Loading a module</h3>
			<p>The Python<a id="_idIndexMarker189"/> interpreter searches for the specified module on a <strong class="source-inline">sys.path</strong> (to be discussed in the <em class="italic">Accessing packages from any location</em> section) and loads the source code. This has been explained in the <em class="italic">Learning how import works</em> section.</p>
			<h3>Setting special variables</h3>
			<p>In this step, the Python<a id="_idIndexMarker190"/> interpreter defines a few special variables, such as <strong class="source-inline">__name__</strong>, which basically defines the namespace that a Python module is running in. The <strong class="source-inline">__name__</strong> variable is one of the most important variables.</p>
			<p>In the case of our example of the <strong class="source-inline">calcmain1.py</strong>, <strong class="source-inline">mycalculator.py</strong>, and <strong class="source-inline">myrandom.py</strong> modules, the <strong class="source-inline">__name__</strong> variable will be set for each module as follows:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/table.jpg" alt="Table 2.1 – The __name__ attribute value for different modules"/>
				</div>
			</div>
			<p class="figure-caption">Table 2.1 – The __name__ attribute value for different modules</p>
			<p>There are two cases of setting the <strong class="source-inline">__name__</strong> variable, which are described next.</p>
			<h4>Case A – module as the main program</h4>
			<p>If you are running your <a id="_idIndexMarker191"/>module as the main program, the <strong class="source-inline">__name__</strong> variable will be set to the <strong class="source-inline">__main__</strong> value regardless of whatever the name of the Python file or module is. For example, when <strong class="source-inline">calcmain1.py</strong> is executed, the interpreter will assign the hardcoded <strong class="source-inline">__main__</strong> string to the <strong class="source-inline">__name__</strong> variable. If we run <strong class="source-inline">myrandom.py</strong> or <strong class="source-inline">mycalculator.py</strong> as the main program, the <strong class="source-inline">__name__</strong> variable will automatically get the value of <strong class="source-inline">__main__</strong>.</p>
			<p>Therefore, we added an <strong class="source-inline">if __name__ == '__main__'</strong> line to all main scripts to check whether this is the main execution program.</p>
			<h4>Case B – module is imported by another module</h4>
			<p>In this case, your module<a id="_idIndexMarker192"/> is not the main program, but it is imported by another module. In our example, <strong class="source-inline">myrandom</strong> and <strong class="source-inline">mycalculator</strong> are imported in <strong class="source-inline">calcmain1.py</strong>. As soon as the Python interpreter finds the <strong class="source-inline">myrandom.py</strong> and <strong class="source-inline">mycalculator.py</strong> files, it will assign the <strong class="source-inline">myrandom</strong> and <strong class="source-inline">mycalculator</strong> names from the <strong class="source-inline">import</strong> statement to the <strong class="source-inline">__name__</strong> variable for each module. This assignment is done prior to executing the code inside these modules. This is reflected in <em class="italic">Table 2.1</em>.</p>
			<p>Some of the other noticeable special variables are as follows:</p>
			<ul>
				<li><strong class="source-inline">__file__</strong>: This variable contains the path to the module that is currently being imported.</li>
				<li><strong class="source-inline">__doc__</strong>: This variable will output the docstring that is added in a class or a method. As discussed in <a href="B17189_01_Final_PG_ePub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Optimal Python Development Life Cycle</em>, a docstring is a comment line added right after the class or method definition.</li>
				<li><strong class="source-inline">__package__</strong>: This is used to indicate whether the module is a package or not. Its value can be a package name, an empty string, or <strong class="source-inline">none</strong>.</li>
				<li><strong class="source-inline">__dict__</strong>: This will return all attributes of a class instance as a dictionary.</li>
				<li><strong class="source-inline">dir</strong>: This is actually a method that returns every associated method or attribute as a list.</li>
				<li><strong class="source-inline">Locals</strong> and <strong class="source-inline">globals</strong>: These are <a id="_idIndexMarker193"/>also used as methods that display the local and global variables as dictionary entries.</li>
			</ul>
			<h3>Executing the code</h3>
			<p>After the special variables <a id="_idIndexMarker194"/>are set, the Python interpreter executes the code in the file line by line. It is important to know that functions (and the code under the classes) are not executed unless they are not called by other lines of code. Here is a quick analysis of the three modules from the execution point of view when <strong class="source-inline">calcmain1.py</strong> is run:</p>
			<ul>
				<li><strong class="source-inline">mycalculator.py</strong>: After setting the special variables, there is no code to be executed in this module at the initialization time.</li>
				<li><strong class="source-inline">myrandom.py</strong>: After setting the special variables and the <strong class="source-inline">import</strong> statement, there is no further code to be executed in this module at initialization time.</li>
				<li><strong class="source-inline">calcmain1.py</strong>: After setting the special variables and executing the <strong class="source-inline">import</strong> statements, it executes the following <strong class="source-inline">if</strong> statement: <strong class="source-inline">if __name__ == "__main__":</strong>. This will return <strong class="source-inline">true</strong> because we launched the <strong class="source-inline">calcmain1.py</strong> file. Inside the <strong class="source-inline">if</strong> statement, the <strong class="source-inline">my_main ()</strong> function will be called, which in fact then calls methods from the <strong class="source-inline">myrandom.py</strong> and <strong class="source-inline">mycalculator.py</strong> modules.</li>
			</ul>
			<p>We can add an <strong class="source-inline">if __name__ == "__main__"</strong> statement to any module regardless of whether it is the main program or not. The advantage of using this approach is that the module can be used both as a module or as a main program. There is also another application of using this approach, which is to add unit tests within the module.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor095"/>Standard modules</h2>
			<p>Python comes with <a id="_idIndexMarker195"/>a library of over 200 standard modules. The exact number varies from one distribution to the other. These modules can be imported into your <a id="_idIndexMarker196"/>program. The list of these modules is very extensive but only a few commonly used modules are mentioned here as an example of standard modules:</p>
			<ul>
				<li><strong class="source-inline">math</strong>: This module provides mathematical functions for arithmetic operations.</li>
				<li><strong class="source-inline">random</strong>: This module is helpful to generate pseudo-random numbers using different types of distributions.</li>
				<li><strong class="source-inline">statistics</strong>: This module offers statistics functions such as <strong class="source-inline">mean</strong>, <strong class="source-inline">median</strong>, and <strong class="source-inline">variance</strong>.</li>
				<li><strong class="source-inline">base64</strong>: This module provides functions to encode and decode data.</li>
				<li><strong class="source-inline">calendar</strong>: This module offers functions related to the calendar, which is helpful for calendar-based computations.</li>
				<li><strong class="source-inline">collections</strong>: This module contains specialized container data types other than the general-purpose built-in containers (such as <strong class="source-inline">dict</strong>, <strong class="source-inline">list</strong>, or <strong class="source-inline">set</strong>). These specialized data types include <strong class="source-inline">deque</strong>, <strong class="source-inline">Counter</strong>, and <strong class="source-inline">ChainMap</strong>. </li>
				<li><strong class="source-inline">csv</strong>: This module helps in reading from and writing to comma-based delimited files.</li>
				<li><strong class="source-inline">datetime</strong>: This module offers general-purpose data and time functions.</li>
				<li><strong class="source-inline">decimal</strong>: This module is specific for decimal-based arithmetic operations.</li>
				<li><strong class="source-inline">logging</strong>: This module is used to facilitate logging into your application.</li>
				<li><strong class="source-inline">os</strong> and <strong class="source-inline">os.path</strong>: These modules are used to access operating system-related functions. </li>
				<li><strong class="source-inline">socket</strong>: This module provides low-level functions for socket-based network communication.</li>
				<li><strong class="source-inline">sys</strong>: This module provides access to a Python interpreter for low-level variables and functions.</li>
				<li><strong class="source-inline">time</strong>: This module <a id="_idIndexMarker197"/>offers time-related functions such as<a id="_idIndexMarker198"/> converting to different time units. </li>
			</ul>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor096"/>Writing reusable modules</h1>
			<p>For a module to be<a id="_idIndexMarker199"/> declared reusable, it has to have the following characteristics:</p>
			<ul>
				<li>Independent functionality</li>
				<li>General-purpose functionality</li>
				<li>Conventional coding style</li>
				<li>Well-defined documentation</li>
			</ul>
			<p>If a module or package does not have these characteristics, it would be very hard, if not impossible, to reuse it in other programs. We will discuss each characteristic one by one.</p>
			<h3>Independent functionality</h3>
			<p>The functions in a<a id="_idIndexMarker200"/> module should offer functionality independent of other modules and independent of any local or global variables. The more independent the functions are, the more reusable the module is. If it has to use other modules, it has to be minimal.</p>
			<p>In our example of <strong class="source-inline">mycalculator.py</strong>, the two functions are completely independent and can be reused by other programs:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B17189_02_01.jpg" alt="Figure 2.1 – The mycalculator module with add and subtract functions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – The mycalculator module with add and subtract functions</p>
			<p>In the case of <strong class="source-inline">myrandom.py</strong>, we are using the <strong class="source-inline">random</strong> system library to provide the functionality of generating random numbers. This is still a very reusable module because the <strong class="source-inline">random</strong> library is one<a id="_idIndexMarker201"/> of the built-in modules in Python:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B17189_02_02.jpg" alt="Figure 2.2 – The myrandom module with function dependency on the random library&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The myrandom module with function dependency on the random library</p>
			<p>In cases where we have to use third-party libraries in our modules, we can get into problems when sharing our modules with others if the target environment does not have the third-party libraries already installed.</p>
			<p>To elaborate this problem further, we'll introduce a new module, <strong class="source-inline">mypandas.py</strong>, which will leverage the basic functionality of the famous <strong class="source-inline">pandas</strong> library. For simplicity, we added only one function to it, which is to print the DataFrame as per the dictionary that is provided as an input variable to the function.</p>
			<p>The code snippet of <strong class="source-inline">mypandas.py</strong> is as follows:</p>
			<p class="source-code">#<strong class="bold">mypandas.py</strong></p>
			<p class="source-code">import pandas</p>
			<p class="source-code">def print_dataframe(dict):</p>
			<p class="source-code">   """This function output a dictionary as a data frame """</p>
			<p class="source-code">   brics = pandas.DataFrame(dict)</p>
			<p class="source-code">   print(brics)</p>
			<p>Our <strong class="source-inline">mypandas.py</strong> module will be using the <strong class="source-inline">pandas</strong> library to create a <strong class="source-inline">dataframe</strong> object from the dictionary. This dependency is shown in the next block diagram as well:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B17189_02_03.jpg" alt="Figure 2.3 – The mypandas module with dependency on a third-party pandas library&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – The mypandas module with dependency on a third-party pandas library</p>
			<p>Note that the <strong class="source-inline">pandas</strong> library is not <a id="_idIndexMarker202"/>a built-in or system library. When we try to share this module with others without defining a clear dependency on a third-party library (<strong class="source-inline">pandas</strong> in this case), the program that will try to use this module will give the following error message:</p>
			<p class="source-code">ImportError: No module named pandas'</p>
			<p>This is why it is important that the module is as independent as possible. If we have to use third-party libraries, we need to define clear dependencies and use an appropriate packaging approach. This will be discussed in the <em class="italic">Sharing a package</em> section.</p>
			<h3>Generalization functionality</h3>
			<p>An ideal reusable module <a id="_idIndexMarker203"/>should focus on solving a general problem rather than a very specific problem. For example, we have a requirement of converting inches to centimeters. We can easily write a function that converts inches into centimeters by applying a conversion formula. What about writing a function that converts any value in the imperial system to a value in the metric system? We can have one function for different conversions that may handle inches to centimeters, feet to meters, or miles to kilometers, or separate functions for each type of these conversions. What about the reverse functions (centimeters to inches)? This may not be required now but may be required later on or by someone who is reusing this module. This generalization will make the module functionality not only comprehensive but also more reusable without extending it.</p>
			<p>To illustrate the generalization concept, we will revise the design of the <strong class="source-inline">myrandom</strong> module to make it more general and thus more reusable. In the current design, we define separate functions for one-digit and two-digit numbers. What if we need to generate a three-digit random number or to generate a random number between 20 and 30? To generalize the<a id="_idIndexMarker204"/> requirement, we introduce a new function, <strong class="source-inline">get_random</strong>, in the same module, which takes user input for lower and upper limits of the random numbers. This newly added function is a generalization of the two random functions we already defined. With this new function in the module, the two existing functions can be removed, or they can stay in the module for convenience of use. Note that the newly added function is also offered by the <strong class="source-inline">random</strong> library out of the box; the reason for providing the function in our module is purely for illustration of the generalized function (<strong class="source-inline">get_random</strong> in this case) versus the specific functions (<strong class="source-inline">random_1d</strong> and <strong class="source-inline">random_2d</strong> in this case).</p>
			<p>The updated version of the <strong class="source-inline">myrandom.py</strong> module (<strong class="source-inline">myrandomv2.py</strong>) is as follows:</p>
			<p class="source-code"># myrandomv2.py with default and custom random functions</p>
			<p class="source-code">import random</p>
			<p class="source-code">def random_1d():</p>
			<p class="source-code">   """This function get a random number between 0 and 9"""</p>
			<p class="source-code">   return random.randint(0,9)</p>
			<p class="source-code">def random_2d():</p>
			<p class="source-code">   """This function get a random number between 10 and 99"""</p>
			<p class="source-code">   return random.randint(10,99)</p>
			<p class="source-code">def get_random(lower, upper):</p>
			<p class="source-code">   """This function get a random number between lower and\</p>
			<p class="source-code">    upper"""</p>
			<p class="source-code">   return random.randint(lower,upper)</p>
			<h3>Conventional coding style</h3>
			<p>This primarily focuses on how we write function names, variable names, and module names. Python has a coding system<a id="_idIndexMarker205"/> and naming conventions, which were discussed in the previous chapter of this book. It is important to follow the coding and naming conventions, especially when building reusable modules and packages. Otherwise, we will be discussing such modules as bad examples of reusable modules.</p>
			<p>To illustrate this point, we will show the following code snippet with function and parameter names using camel case:</p>
			<p class="source-code">def addNumbers(numParam1, numParam2)</p>
			<p class="source-code">  #function code is omitted</p>
			<p class="source-code">Def featureCount(moduleName)</p>
			<p class="source-code">  #function code is omitted </p>
			<p>If you are coming from a Java background, this code style will seem fine. But it is considered bad practice in Python. The use of the non-Pythonic style of coding makes the reusability of such modules very difficult.</p>
			<p>Here is another snippet of a module with appropriate coding style for function names:</p>
			<p class="source-code">def add_numbers(num_param1, num_param2)</p>
			<p class="source-code">  #function code is omitted</p>
			<p class="source-code">Def feature_count(module_name)</p>
			<p class="source-code">  #function code is omitted </p>
			<p>Another example of a good reusable coding style is illustrated in the next screenshot, which is taken from the PyCharm IDE for the <strong class="source-inline">pandas</strong> library:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B17189_02_04.jpg" alt="Figure 2.4 – The pandas library view in the PyCharm IDE&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – The pandas library view in the PyCharm IDE</p>
			<p>The functions and the variable names are easy to follow even without reading any documentation. Following a <a id="_idIndexMarker206"/>standard coding style makes the reusability more convenient.</p>
			<h3>Well-defined documentation</h3>
			<p>Well-defined and clear <a id="_idIndexMarker207"/>documentation is as important as writing a generalized and independent module with the Python coding guidelines. Without clear documentation, the module will not increase the interest of developers to reuse with convenience. But as programmers, we put more focus on the code than the documentation. Writing a few lines of documentation can make 100 lines of our code more usable and maintainable.</p>
			<p>We will provide a couple of good examples of documentation from a module point of view by using our <strong class="source-inline">mycalculator.py</strong> module example:</p>
			<p class="source-code"> """<strong class="bold">mycalculator.py</strong> </p>
			<p class="source-code"> This module provides functions for add and subtract of two   numbers"""</p>
			<p class="source-code">def add(x,  y):</p>
			<p class="source-code">   """ This function adds two numbers. </p>
			<p class="source-code">   usage: add (3, 4) """</p>
			<p class="source-code">   return x + y</p>
			<p class="source-code">def subtract(x, y):</p>
			<p class="source-code">   """ This function subtracts two numbers</p>
			<p class="source-code">   usage: subtract (17, 8) """</p>
			<p class="source-code">   return x - y</p>
			<p>In Python, it is important to <a id="_idIndexMarker208"/>remember the following:</p>
			<ul>
				<li>We can use three quote characters to mark a string that goes across more than one line of the Python source file.</li>
				<li>Triple-quoted strings are used at the start of a module, and then this string is used as the documentation for the module as a whole.</li>
				<li>If any function starts with a triple-quoted string, then this string is used as documentation for that function.</li>
			</ul>
			<p>As a general conclusion, we can make as many modules as we want by writing hundreds of lines of code, but it takes more than writing code to make a reusable module, including generalization, coding style, and most importantly, documentation.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor097"/>Building packages</h1>
			<p>There are a number <a id="_idIndexMarker209"/>of techniques and tools available for creating and distributing packages. The truth is that Python does not have a great history of standardizing the packaging process. There have been multiple projects started in the first decade of the 21<span class="superscript">st</span> century to streamline this process but not with a lot of success. In the last decade, we <a id="_idIndexMarker210"/>have had some success, thanks to the initiatives of the <strong class="bold">Python Packaging Authority</strong> (<strong class="bold">PyPA</strong>).</p>
			<p>In this section, we will be covering techniques of building packages, accessing the packages in our program, and publishing and sharing the packages as per the guidelines provided by PyPA.</p>
			<p>We will start with package names, followed by the use of an initialization file, and then jump into building a sample package.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor098"/>Naming</h2>
			<p>Package names <a id="_idIndexMarker211"/>should follow the same rule for naming as for modules, which is lowercase with no underscores. Packages act like structured modules.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor099"/>Package initialization file</h2>
			<p>A package can have an optional <a id="_idIndexMarker212"/>source file named <strong class="source-inline">__init__.py</strong> (or simply an <strong class="source-inline">init</strong> file). The presence of the <strong class="source-inline">init</strong> file (even a blank one) is recommended to mark folders as packages. Since Python release 3.3 or later, the use of an <strong class="source-inline">init</strong> file is optional (PEP 420: Implicit Namespace Packages). There can be multiple purposes of using this <strong class="source-inline">init</strong> file and there is always a debate about what can go inside an <strong class="source-inline">init</strong> file versus what cannot go in. A few uses of the <strong class="source-inline">init</strong> file are discussed here:</p>
			<ul>
				<li><strong class="bold">Empty __init__.py</strong>: This will force<a id="_idIndexMarker213"/> developers to use explicit imports and manage the namespaces as they like. As expected, developers have to import separate modules, which can be tedious for a large package.</li>
				<li><strong class="bold">Full import in __init__.py</strong>: In this case, developers can import the package and then refer to the modules directly in their code using the package name or its alias name. This provides more convenience but at the expense of maintaining the list of all imports in the <strong class="source-inline">__init__</strong> file.</li>
				<li><strong class="bold">Limited import</strong>: This is another approach in which the module developers can import only key functions in the <strong class="source-inline">init</strong> file from different modules and manage them under the package namespace. This provides the additional benefit of providing a wrapper around the underlying module's functionality. If by any chance we have to refactor the underlying modules, we have an option to keep the namespace the same, especially for API consumers. The only drawback of this approach is that it requires extra effort to manage and maintain such <strong class="source-inline">init</strong> files.</li>
			</ul>
			<p>Sometimes, developers add code to the <strong class="source-inline">init</strong> file that is executed when a module is imported from a package. An example of such code is to create a session for remote systems such as a<a id="_idIndexMarker214"/> database or remote SSH server.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor100"/>Building a package</h2>
			<p>Now we will discuss how to build a <a id="_idIndexMarker215"/>package with one sample package example. We will build a <strong class="source-inline">masifutil</strong> package using the following modules and a sub-package:</p>
			<ul>
				<li>The <strong class="source-inline">mycalculator.py</strong> module: We already built this module for the <em class="italic">Importing modules</em> section.</li>
				<li>The <strong class="source-inline">myrandom.py</strong> module: This module was also built for the <em class="italic">Importing modules</em> section.</li>
				<li>The <strong class="source-inline">advcalc</strong> sub-package: This will be a sub-package and will contain one module in it (<strong class="source-inline">advcalculator.py</strong>). We will define an <strong class="source-inline">init</strong> file for this sub-package but it will be empty.</li>
			</ul>
			<p>The <strong class="source-inline">advcalculator.py</strong> module has additional functions for calculating the square root and log using base 10 and base 2. The source code for this module is shown next:</p>
			<p class="source-code"># advcalculator.py with sqrt, log and ln functions</p>
			<p class="source-code">import math</p>
			<p class="source-code">def sqrt(x):</p>
			<p class="source-code">   """This function takes square root of a number"""</p>
			<p class="source-code">   return math.sqrt(x)</p>
			<p class="source-code">def log(x):</p>
			<p class="source-code">   """This function returns log of base 10"""</p>
			<p class="source-code">   return math.log(x,10)</p>
			<p class="source-code">def ln(x):</p>
			<p class="source-code">   """This function returns log of base 2"""</p>
			<p class="source-code">   return math.log(x,2)</p>
			<p>The file structure<a id="_idIndexMarker216"/> of the <strong class="source-inline">masifutil</strong> package with <strong class="source-inline">init</strong> files will look like this:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B17189_02_05.jpg" alt="Figure 2.5 – Folder structure of the masifutil package with modules and sub-packages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – Folder structure of the masifutil package with modules and sub-packages</p>
			<p>In the next step, we will build a new main script (<strong class="source-inline">pkgmain1.py</strong>) to consume the modules from the package or <strong class="source-inline">masifutil</strong> subfolder. In this script, we will import the modules from the main package and sub-package using the folder structure, and then use the module functions to compute two random numbers, the sum and difference of the two numbers, and the square root and logarithmic values of the first random numbers. The source code for <strong class="source-inline">pkgmain1.py</strong> is as follows:</p>
			<p class="source-code"># <strong class="bold">pkgmain0.py</strong> with direct import </p>
			<p class="source-code">import <strong class="bold">masifutil.mycalculator</strong> as calc</p>
			<p class="source-code">import <strong class="bold">masifutil.myrandom</strong> as rand</p>
			<p class="source-code">import <strong class="bold">masifutil.advcalc.advcalculator</strong> as acalc</p>
			<p class="source-code">def my_main():</p>
			<p class="source-code">    """ This is a main function which generates two random\</p>
			<p class="source-code">     numbers and then apply calculator functions on them """</p>
			<p class="source-code">    x = rand.random_2d()</p>
			<p class="source-code">    y = rand.random_1d()</p>
			<p class="source-code">    sum = calc.add(x,y)</p>
			<p class="source-code">    diff = calc.subtract(x,y)</p>
			<p class="source-code">    sroot = acalc.sqrt(x)</p>
			<p class="source-code">    log10x = acalc.log(x)</p>
			<p class="source-code">    log2x = acalc.ln(x)</p>
			<p class="source-code">    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x, y))</p>
			<p class="source-code">    print(<strong class="bold">"sum is {}"</strong>.format(sum))</p>
			<p class="source-code">    print(<strong class="bold">"diff is {}"</strong>.format(diff))</p>
			<p class="source-code">    print(<strong class="bold">"square root is {}"</strong>.format(sroot))</p>
			<p class="source-code">    print(<strong class="bold">"log base of 10 is {}"</strong>.format(log10x))</p>
			<p class="source-code">    print(<strong class="bold">"log base of 2 is {}"</strong>.format(log2x))</p>
			<p class="source-code"><strong class="bold">""" This is executed only if the special variable '__name__' is set as main"""</strong></p>
			<p class="source-code">if __name__ == <strong class="bold">"__main__"</strong>:</p>
			<p class="source-code">    my_main()</p>
			<p>Here, we will be using the package<a id="_idIndexMarker217"/> name and module name to import the modules, which is cumbersome especially when we need to import the sub-packages. We can also use the following statements with the same results:</p>
			<p class="source-code"># mypkgmain1.py with from statements</p>
			<p class="source-code">from masifutil import mycalculator as calc</p>
			<p class="source-code">from masifutil import myrandom as rand</p>
			<p class="source-code">from masifutil.advcalc import advcalculator as acalc</p>
			<p class="source-code">#rest of the code is the same as in mypkgmain1.py</p>
			<p>As mentioned earlier, the use of the empty <strong class="source-inline">__init__.py</strong> file is optional. But we have added it in this case for illustration purposes.</p>
			<p>Next, we will explore how to add some <strong class="source-inline">import</strong> statements to the <strong class="source-inline">init</strong> file. Let's start with importing the modules<a id="_idIndexMarker218"/> inside the <strong class="source-inline">init</strong> file. In this top-level <strong class="source-inline">init</strong> file, we will import all functions as shown next:</p>
			<p class="source-code">#<strong class="bold">__init__ </strong>file for package 'masifutil'</p>
			<p class="source-code">from .mycalculator import add, subtract</p>
			<p class="source-code">from .myrandom import random_1d, random_2d</p>
			<p class="source-code">from .advcalc.advcalculator import sqrt, log, ln</p>
			<p>Note the use of <strong class="source-inline">.</strong> before the module name. This is required for Python for the strict use of relative imports.</p>
			<p>As a result of these three lines inside the <strong class="source-inline">init</strong> file, the new main script will become simple and the sample code is shown next:</p>
			<p class="source-code"># <strong class="bold">pkgmain2.py</strong> with main function</p>
			<p class="source-code">import masifutil</p>
			<p class="source-code">def my_main():</p>
			<p class="source-code">    """ This is a main function which generates two random\</p>
			<p class="source-code">     numbers and then apply calculator functions on them """</p>
			<p class="source-code">    x = masifutil.random_2d()</p>
			<p class="source-code">    y = masifutil.random_1d()</p>
			<p class="source-code">    sum = masifutil.add(x,y)</p>
			<p class="source-code">    diff = masifutil.subtract(x,y)</p>
			<p class="source-code">    sroot = masifutil.sqrt(x)</p>
			<p class="source-code">    log10x = masifutil.log(x)</p>
			<p class="source-code">    log2x = masifutil.ln(x)</p>
			<p class="source-code">    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x, y))</p>
			<p class="source-code">    print(<strong class="bold">"sum is {}"</strong>.format(sum))</p>
			<p class="source-code">    print(<strong class="bold">"diff is {}"</strong>.format(diff))</p>
			<p class="source-code">    print(<strong class="bold">"square root is {}"</strong>.format(sroot))</p>
			<p class="source-code">    print(<strong class="bold">"log base of 10 is {}"</strong>.format(log10x))</p>
			<p class="source-code">    print(<strong class="bold">"log base of 2 is {}"</strong>.format(log2x))</p>
			<p class="source-code"><strong class="bold">""" This is executed only if the special variable '__name__' is set as main"""</strong></p>
			<p class="source-code">if __name__ == <strong class="bold">"__main__"</strong>:</p>
			<p class="source-code">    my_main()</p>
			<p>The functions of the two main modules and the sub-package module are available at the main package level and the developers do not need to know the underlying hierarchy and structure of the<a id="_idIndexMarker219"/> modules within the package. This is the convenience we discussed earlier of using <strong class="source-inline">import</strong> statements inside the <strong class="source-inline">init</strong> file.</p>
			<p>We build the package by keeping the package source code in the same folder where the main program or script resides. This works only to share the modules within a project. Next, we will discuss how to access the package from other projects and from any program from anywhere.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor101"/>Accessing packages from any location</h1>
			<p>The package we<a id="_idIndexMarker220"/> built in the previous subsection is accessible only if the program calling the modules is at the same level as the package location. This requirement is not practical for code reusability and code sharing.</p>
			<p>In this section, we will discuss<a id="_idIndexMarker221"/> a few techniques to make packages available and usable from any program on any location in our system.</p>
			<h3>Appending sys.path</h3>
			<p>This is a <a id="_idIndexMarker222"/>useful option for setting <strong class="source-inline">sys.path</strong> dynamically. Note that <strong class="source-inline">sys.path</strong> is a list of directories on which a Python interpreter searches every time it executes an <strong class="source-inline">import</strong> statement in a source program. By using this approach, we are appending (adding) paths of directories or folders containing our packages to <strong class="source-inline">sys.path</strong>.</p>
			<p>For the <strong class="source-inline">masifutil</strong> package, we will build a new program, <strong class="source-inline">pkgmain3.py</strong>, which is a copy of <strong class="source-inline">pkgmain2.py</strong> (to be updated later) but is kept outside the folder where our <strong class="source-inline">masifutil</strong> package is residing. <strong class="source-inline">pkgmain3.py</strong> can be in any folder other than the <strong class="source-inline">mypackages</strong> folder. Here is the folder structure with a new main script (<strong class="source-inline">pkgmain3.py</strong>) and the <strong class="source-inline">masifutil</strong> package for reference:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B17189_02_06.jpg" alt="Figure 2.6 – Folder structure of the masifutil package and a new main script, pkgmain3.py&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Folder structure of the masifutil package and a new main script, pkgmain3.py</p>
			<p>When we execute the <strong class="source-inline">pkgmain3.py</strong> program, it returns an error: <strong class="source-inline">ModuleNotFoundError: No module named 'masifutil'</strong>. This is expected as the path of the <strong class="source-inline">masifutil</strong> package is not added to <strong class="source-inline">sys.path</strong>. To add the package folder to <strong class="source-inline">sys.path</strong>, we will update the main program; let's name it <strong class="source-inline">pkgmain4.py</strong>, with additional statements for appending <strong class="source-inline">sys.path</strong>, which is shown next:</p>
			<p class="source-code"># <strong class="bold">pkgmain4.py</strong> with sys.path append code</p>
			<p class="source-code">import sys</p>
			<p class="source-code">sys.path.append(<strong class="bold">'/Users/muasif/Google Drive/PythonForGeeks/source_code/chapter2/mypackages'</strong>)</p>
			<p class="source-code">import masifutil</p>
			<p class="source-code">def my_main():</p>
			<p class="source-code">    """ This is a main function which generates two random\</p>
			<p class="source-code">     numbers and then apply calculator functions on them """</p>
			<p class="source-code">    x = masifutil.random_2d()</p>
			<p class="source-code">    y = masifutil.random_1d()</p>
			<p class="source-code">    sum = masifutil.add(x,y)</p>
			<p class="source-code">    diff = masifutil.subtract(x,y)</p>
			<p class="source-code">    sroot = masifutil.sqrt(x)</p>
			<p class="source-code">    log10x = masifutil.log(x)</p>
			<p class="source-code">    log2x = masifutil.ln(x)</p>
			<p class="source-code">    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x, y))</p>
			<p class="source-code">    print(<strong class="bold">"sum is {}"</strong>.format(sum))</p>
			<p class="source-code">    print(<strong class="bold">"diff is {}"</strong>.format(diff))</p>
			<p class="source-code">    print(<strong class="bold">"square root is {}"</strong>.format(sroot))</p>
			<p class="source-code">    print(<strong class="bold">"log base of 10 is {}"</strong>.format(log10x))</p>
			<p class="source-code">    print(<strong class="bold">"log base of 2 is {}"</strong>.format(log2x))</p>
			<p class="source-code"><strong class="bold">""" This is executed only if the special variable '__name__' is set as main"""</strong></p>
			<p class="source-code">if __name__ == <strong class="bold">"__main__"</strong>:</p>
			<p class="source-code">    my_main()</p>
			<p>After adding the additional lines <a id="_idIndexMarker223"/>of appending <strong class="source-inline">sys.path</strong>, we executed the main script without any error and with the expected console output. This is because our <strong class="source-inline">masifutil</strong> package is now available on a path where the Python interpreter can load it when we are importing it in our main script.</p>
			<p>Alternative to appending <strong class="source-inline">sys.path</strong>, we can also use the <strong class="source-inline">site.addsitedir</strong> function from the site module. The only advantage of using this approach is that this function also looks for <strong class="source-inline">.pth</strong> files within the included folders, which is helpful for adding additional folders such as sub-packages. A snippet of a sample main script (<strong class="source-inline">pktpamin5.py</strong>) with the <strong class="source-inline">addsitedir</strong> function is shown next:</p>
			<p class="source-code"># <strong class="bold">pkgmain5.py</strong></p>
			<p class="source-code">import site</p>
			<p class="source-code">site.addsitedir(<strong class="bold">'/Users/muasif/Google Drive/PythonForGeeks/source_code/chapter2/mypackages'</strong>)</p>
			<p class="source-code">import masifutil</p>
			<p class="source-code">#rest of the code is the same as in pkymain4.py</p>
			<p>Note that the directories we append or add using this approach are available only during the program execution. To set <strong class="source-inline">sys.path</strong> permanently (at the session or system level), the approaches that we will discuss next are more helpful.</p>
			<h4>Using the PYTHONPATH environment variable</h4>
			<p>This is a convenient way to <a id="_idIndexMarker224"/>add our package folder to <strong class="source-inline">sys.path</strong>, which the Python interpreter will use to search for the package and modules if not present in the built-in library. Depending on the operating system we are using, we can define this variable as follows.</p>
			<p>In Windows, the environment variable can be defined using either of the following options:</p>
			<ul>
				<li><strong class="bold">The command line</strong>: Set <strong class="source-inline">PYTHONPATH = "C:\pythonpath1;C:\pythonpath2"</strong>. This is good for one active session.</li>
				<li><strong class="bold">The graphical user interface</strong>: Go to <strong class="bold">My Computer</strong> | <strong class="bold">Properties</strong> | <strong class="bold">Advanced System Settings</strong> | <strong class="bold">Environment Variables</strong>. This is a permanent setting.</li>
			</ul>
			<p>In Linux and macOS, it can be set using <strong class="source-inline">export PYTHONPATH= `/some/path/`</strong>. If set using Bash or an equivalent terminal, the environment variable will be effective for the terminal session only. To set it permanently, it is recommended to add the environment variable at the end of a profile file, such as <strong class="source-inline">~/bash_profile</strong>.</p>
			<p>If we execute the <strong class="source-inline">pkgmain3.py</strong> program without setting <strong class="source-inline">PYTHONPATH</strong>, it returns an error: <strong class="source-inline">ModuleNotFoundError: No module named 'masifutil'</strong>. This is again expected as the path of the <strong class="source-inline">masifutil</strong> package is not added to <strong class="source-inline">PYTHONPATH</strong>.</p>
			<p>In the next step, we will add the folder path containing <strong class="source-inline">masifutil</strong> to the <strong class="source-inline">PYTHONPATH</strong> variable and rerun the <strong class="source-inline">pkgmain3</strong> program. This time, it works without any error and with the expected console output.</p>
			<h4>Using the .pth file under the Python site package</h4>
			<p>This is another convenient<a id="_idIndexMarker225"/> way of adding packages to <strong class="source-inline">sys.path</strong>. This is achieved by defining a <strong class="source-inline">.pth</strong> file under the Python site packages. The file can hold all the folders we want to add to <strong class="source-inline">sys.path</strong>.</p>
			<p>For illustration purposes, we created a <strong class="source-inline">my.pth</strong> file under <strong class="source-inline">venv/lib/Python3.7/site-packages</strong>. As we can see in <em class="italic">Figure 2.7</em>, we added a folder that contains our <strong class="source-inline">masifutil</strong> package. With this simple <strong class="source-inline">.pth</strong> file, our main script <strong class="source-inline">pkymain3.py</strong> program works fine without any error and with expected console output:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B17189_02_07.jpg" alt="Figure 2.7 – A view of a virtual environment with the my.pth file"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – A view of a virtual environment with the my.pth file</p>
			<p>The approaches we <a id="_idIndexMarker226"/>discussed to access custom packages are effective to reuse the packages and modules on the same system with any program. In the next section, we will explore how to share packages with other developers and communities.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor102"/>Sharing a package</h1>
			<p>To distribute Python<a id="_idIndexMarker227"/> packages and projects across communities, there are many tools available. We will focus only on the tools that are recommended as per the guidelines provided by PyPA.</p>
			<p>In this section, we will be covering installing and distributing packaging techniques. A few tools that we will<a id="_idIndexMarker228"/> use or are at least worth mentioning in this section as a reference are as follows:</p>
			<ul>
				<li><strong class="bold">distutils</strong>: This comes with Python <a id="_idIndexMarker229"/>with base functionality. It is not easy to extend for complex and custom package distribution.</li>
				<li><strong class="bold">setuputils</strong>: This is a<a id="_idIndexMarker230"/> third-party tool and an extension of distutils and is recommended for building packages.</li>
				<li><strong class="bold">wheel</strong>: This is for the <a id="_idIndexMarker231"/>Python packaging format and it makes installations faster and easier as compared to its predecessors.</li>
				<li><strong class="bold">pip</strong>: pip is a package manager for<a id="_idIndexMarker232"/> Python packages and modules, and it comes as part of Python if you are installing Python version 3.4 or later. It is easy to use pip to install a new module by using a command such as <strong class="source-inline">pip install &lt;module name&gt;</strong>.</li>
				<li><strong class="bold">The Python Package Index (PyPI)</strong>: This is a<a id="_idIndexMarker233"/> repository of software for the Python programming language. PyPI is used to find and install software developed and shared by the Python community.</li>
				<li><strong class="bold">Twine</strong>: This is a utility for <a id="_idIndexMarker234"/>publishing Python packages to PyPI.</li>
			</ul>
			<p>In the next subsections, we will update the <strong class="source-inline">masifutil</strong> package to include additional components as per the guidelines provided by PyPA. This will be followed by installing the updated <strong class="source-inline">masifutil</strong> package system-wide using pip. In the end, we will publish the updated <strong class="source-inline">masifutil</strong> package to <strong class="bold">Test PyPI</strong> and install it from Test PyPI.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor103"/>Building a package as per the PyPA guidelines</h2>
			<p>PyPA recommends <a id="_idIndexMarker235"/>using a sample project for building reusable packages and it is available at <a href="https://github.com/pypa/sampleproject">https://github.com/pypa/sampleproject</a>. A snippet of the sample project from the GitHub location is as shown:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B17189_02_08.jpg" alt="Figure 2.8 – A view of the sample project on GitHub by PyPA&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – A view of the sample project on GitHub by PyPA</p>
			<p>We will introduce<a id="_idIndexMarker236"/> key files and folders, which are important to understand before we use them for updating our <strong class="source-inline">masifutil</strong> package:</p>
			<ul>
				<li><strong class="source-inline">setup.py</strong>: This is the most important file, which has to exist at the root of the project or package. It is a script for building and installing the package. This file contains a global <strong class="source-inline">setup()</strong> function. The setup file also provides a command-line interface for running various commands.</li>
				<li><strong class="source-inline">setup.cfg</strong>: This is an <strong class="source-inline">ini</strong> file that can be used by <strong class="source-inline">setup.py</strong> to define defaults.</li>
				<li><strong class="source-inline">setup()</strong> args: The key arguments that can be passed to the setup function are as follows:<p>a) Name</p><p>b) Version</p><p>c) Description</p><p>d) URL</p><p>e) Author</p><p>f) License</p></li>
				<li><strong class="source-inline">README.rst</strong>/<strong class="source-inline">README.md</strong>: This file (either reStructured or Markdown format) can contain information about the package or project.</li>
				<li><strong class="source-inline">license.txt</strong>: The <strong class="source-inline">license.txt</strong> file should be included with every package with details of the terms and conditions of distribution. The license file is important<a id="_idIndexMarker237"/>, especially in countries where it is illegal to distribute packages without the appropriate license. </li>
				<li><strong class="source-inline">MANIFEST.in</strong>: This file can be used to specify a list of additional files to include in the package. This list of files doesn't include the source code files (which are automatically included). </li>
				<li><strong class="source-inline">&lt;package&gt;</strong>: This is the top-level package containing all the modules and packages inside it. It is not mandatory to use, but it is a recommended approach.</li>
				<li><strong class="source-inline">data</strong>: This is a place to add data files if needed.</li>
				<li><strong class="source-inline">tests</strong>: This is a placeholder to add unit tests for the modules.</li>
			</ul>
			<p>As a next step, we will update our previous <strong class="source-inline">masifutil</strong> package as per the PyPA guidelines. Here is the new folder and file structure of the updated <strong class="source-inline">masifutilv2</strong> package:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B17189_02_09.jpg" alt="Figure 2.9 – A view of the updated masifutilv2 file structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – A view of the updated masifutilv2 file structure</p>
			<p>We have added <strong class="source-inline">data</strong> and <strong class="source-inline">tests</strong> directories, but they are actually empty for now. We will evaluate the unit tests in a later chapter to complete this topic.</p>
			<p>The contents of most<a id="_idIndexMarker238"/> of the additional files are covered in the sample project and thus will not be discussed here, except the <strong class="source-inline">setup.py</strong> file.</p>
			<p>We updated <strong class="source-inline">setup.py</strong> with basic arguments as per our package project. The details of the rest of the arguments are available in the sample <strong class="source-inline">setup.py</strong> file provided with the sample project by PyPA. Here is a snippet of our <strong class="source-inline">setup.py</strong> file:</p>
			<p class="source-code">from setuptools import setup</p>
			<p class="source-code">setup(</p>
			<p class="source-code">   name=<strong class="bold">'masifutilv2'</strong>,</p>
			<p class="source-code">   version=<strong class="bold">'0.1.0'</strong>,</p>
			<p class="source-code">   author=<strong class="bold">'Muhammad Asif'</strong>,</p>
			<p class="source-code">   author_email=<strong class="bold">'ma@example.com'</strong>,</p>
			<p class="source-code">   packages=[<strong class="bold">'masifutil'</strong>, <strong class="bold">'masifutil/advcalc'</strong>],</p>
			<p class="source-code">   python_requires=<strong class="bold">'&gt;=3.5, &lt;4'</strong>,</p>
			<p class="source-code">   url=<strong class="bold">'http://pypi.python.org/pypi/PackageName/'</strong>,</p>
			<p class="source-code">   license=<strong class="bold">'LICENSE.txt'</strong>,</p>
			<p class="source-code">   description=<strong class="bold">'A sample package for illustration purposes'</strong>,</p>
			<p class="source-code">   long_description=open(<strong class="bold">'README.md'</strong>).read(),</p>
			<p class="source-code">   install_requires=[</p>
			<p class="source-code">   ],</p>
			<p class="source-code">)</p>
			<p>With this <strong class="source-inline">setup.py</strong> file, we are ready to share our <strong class="source-inline">masifutilv2</strong> package locally as well as remotely, which we <a id="_idIndexMarker239"/>will discuss in the next subsections.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor104"/>Installing from the local source code using pip</h2>
			<p>Once we have updated the package <a id="_idIndexMarker240"/>with new files, we are ready to install it using the pip utility. The simplest way to install it is by executing the following command with the path to the <strong class="source-inline">masifutilv2</strong> folder:</p>
			<p class="source-code">&gt; pip install &lt;path to masifutilv2&gt;</p>
			<p>The following is the console output of the command when run without installing the wheel package:</p>
			<p class="source-code">Processing ./masifutilv2</p>
			<p class="source-code">Using legacy 'setup.py install' for masifutilv2, since package 'wheel' is not installed.</p>
			<p class="source-code">Installing collected packages: masifutilv2</p>
			<p class="source-code">    Running setup.py install for masifutilv2 ... done</p>
			<p class="source-code">Successfully installed masifutilv2-0.1.0 </p>
			<p>The pip utility installed the package successfully but using the egg format since the <strong class="source-inline">wheel</strong> package was not installed. Here is a view of our virtual environment after the installation:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B17189_02_10.jpg" alt="Figure 2.10 – A view of the virtual environment after installing masifutilv2 using pip&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – A view of the virtual environment after installing masifutilv2 using pip</p>
			<p>After installing the package<a id="_idIndexMarker241"/> under the virtual environment, we tested it with our <strong class="source-inline">pkgmain3.py</strong> program, which worked as expected.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To uninstall the package, we can use <strong class="source-inline">pip uninstall masifutilv2</strong>.</p>
			<p>As a next step, we will install the <strong class="source-inline">wheel</strong> package and then reinstall the same package again. Here is the installation command:</p>
			<p class="source-code">&gt; pip install &lt;path to masifutilv2&gt;</p>
			<p>The console output will be similar to the following:</p>
			<p class="source-code">Processing ./masifutilv2</p>
			<p class="source-code">Building wheels for collected packages: masifutilv2</p>
			<p class="source-code">  Building wheel for masifutilv2 (setup.py) ... done</p>
			<p class="source-code">  Created wheel for masifutilv2: filename=masi futilv2-0.1.0-py3-none-any.whl size=3497 sha256=038712975b7d7eb1f3fefa799da9e294b34 e79caea24abb444dd81f4cc44b36e</p>
			<p class="source-code">  Stored in folder: /private/var/folders/xp/g88fvmgs0k90w0rc_qq4xkzxpsx11v/T/pip-ephem-wheel-cache-l2eyp_wq/wheels/de/14/12/71b4d696301fd1052adf287191fdd054cc17ef6c9b59066277</p>
			<p class="source-code">Successfully built masifutilv2</p>
			<p class="source-code">Installing collected packages: masifutilv2</p>
			<p class="source-code">Successfully installed masifutilv2-0.1.0</p>
			<p>The package is installed<a id="_idIndexMarker242"/> successfully using <strong class="source-inline">wheel</strong> this time and we can see it appears in our virtual environment as follows:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B17189_02_11.jpg" alt="Figure 2.11 – A view of the virtual environment after installing masifutilv2 with wheel and using pip &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – A view of the virtual environment after installing masifutilv2 with wheel and using pip </p>
			<p>In this section, we have installed a package using the pip utility from the local source code. In the next section, we will publish the package to a centralized repository (Test PyPI).</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor105"/>Publishing a package to Test PyPI</h2>
			<p>As a next step, we<a id="_idIndexMarker243"/> will add our sample package to the PyPI repository. Before executing any command for publishing our package, we will need to create an <a id="_idIndexMarker244"/>account on Test PyPI. Note that Test PyPI is a separate instance of the package index specifically for testing. In addition to the account with Test PyPI, we also need to add an <strong class="bold">API token</strong> to the account. We will leave the details of creating an account and adding an API token to the account for you by following the instructions available on the Test PyPI website (<a href="https://test.pypi.org/">https://test.pypi.org/</a>).</p>
			<p>To push the package to Test PyPI, we will need the Twine utility. We assume Twine is installed using the pip utility. To upload the <strong class="source-inline">masifutilv2</strong> package, we will execute the following steps:</p>
			<ol>
				<li>Create a distribution using the following command. This <strong class="source-inline">sdist</strong> utility will create a TAR ZIP file under a <strong class="source-inline">dist</strong> folder:<p class="source-code">&gt; python setup.py sdist</p></li>
				<li>Upload the distribution file to Test PyPI. When prompted for a username and password, provide <strong class="source-inline">__token__</strong> as the username and the API token as the password:<p class="source-code">&gt; twine upload --repository testpypi dist/masifutilv2-0.1.0.tar.gz </p><p>This command will push the package TAR ZIP file to the Test PyPI repository and the console output will be similar to the following:</p><p class="source-code"><strong class="bold">Uploading distributions to https://test.pypi.org/legacy/</strong></p><p class="source-code"><strong class="bold">Enter your username: __token__</strong></p><p class="source-code"><strong class="bold">Enter your password: </strong></p><p class="source-code"><strong class="bold">Uploading masifutilv2-0.1.0.tar.gz</strong></p><p class="source-code"><strong class="bold">100%|█████████████████████| </strong></p><p class="source-code"><strong class="bold">5.15k/5.15k [00:02&lt;00:00, 2.21kB/s]</strong></p></li>
			</ol>
			<p>We can view the uploaded file at <a href="https://test.pypi.org/project/masifutilv2/0.1.0/">https://test.pypi.org/project/masifutilv2/0.1.0/</a> after a successful upload.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor106"/>Installing the package from PyPI</h2>
			<p>Installing the package from Test PyPI is the same <a id="_idIndexMarker245"/>as installing from a regular repository, except<a id="_idIndexMarker246"/> that we need to provide the repository URL by using the <strong class="source-inline">index-url</strong> arguments. The command and the console output will be similar to the following:</p>
			<p class="source-code">&gt; pip install --index-url https://test.pypi.org/simple/ --no-deps masifutilv2</p>
			<p>This command will present console output similar to the following:</p>
			<p class="source-code">Looking in indexes: https://test.pypi.org/simple/</p>
			<p class="source-code">Collecting masifutilv2</p>
			<p class="source-code">  Downloading https://test-files.pythonhosted.org/  packages/b7/e9/7afe390b4ec1e5842e8e62a6084505cbc6b9   f6adf0e37ac695cd23156844/masifutilv2-0.1.0.tar.gz (2.3 kB)</p>
			<p class="source-code">Building wheels for collected packages: masifutilv2</p>
			<p class="source-code">  Building wheel for masifutilv2 (setup.py) ... done</p>
			<p class="source-code">  Created wheel for masifutilv2: filename=masifutilv2-  0.1.0-py3-none-any.whl size=3497   sha256=a3db8f04b118e16ae291bad9642483874   f5c9f447dbee57c0961b5f8fbf99501</p>
			<p class="source-code">  Stored in folder: /Users/muasif/Library/Caches/pip/  wheels/1c/47/29/95b9edfe28f02a605757c1   f1735660a6f79807ece430f5b836</p>
			<p class="source-code">Successfully built masifutilv2</p>
			<p class="source-code">Installing collected packages: masifutilv2</p>
			<p class="source-code">Successfully installed masifutilv2-0.1.0</p>
			<p>As we can see in the console output, pip is searching for the module in Test PyPI. Once it finds the package with the name <strong class="source-inline">masifutilv2</strong>, it starts downloading and then installing it in the virtual environment.</p>
			<p>In short, we have <a id="_idIndexMarker247"/>observed that once we create a package using the <a id="_idIndexMarker248"/>recommended format and style, then publishing and accessing the package is just a matter of using Python utilities and following the standard steps.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor107"/>Summary</h1>
			<p>In this chapter, we introduced the concept of modules and packages in Python. We discussed how to build reusable modules and how they can be imported by other modules and programs. We also covered the loading and initializing of modules when included (by an import process) by other programs. In the later part of this chapter, we discussed building simple and advanced packages. We also provided a lot of code examples to access the packages, as well as installing and publishing the package for efficient reusability.</p>
			<p>After going through this chapter, you have learned how to build modules and packages and how to share and publish the packages (and modules). These skills are important if you are working on a project as a team in an organization or you are building Python libraries for a larger community.</p>
			<p>In the next chapter, we will discuss the next level of modularization using object-oriented programming in Python. This will encompass encapsulation, inheritance, polymorphism, and abstraction, which are key tools to build and manage complex projects in the real world. </p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor108"/>Questions</h1>
			<ol>
				<li value="1">What is the difference between a module and a package?</li>
				<li>What are absolute and relative imports in Python?</li>
				<li>What is PyPA?</li>
				<li>What is Test PyPI and why do we need it?</li>
				<li>Is an <strong class="source-inline">init</strong> file a requirement to build a package?</li>
			</ol>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor109"/>Further reading</h1>
			<ul>
				<li><em class="italic">Modular Programming with Python</em> by Erik Westra</li>
				<li><em class="italic">Expert Python Programming</em> by Michał Jaworski and Tarek Ziadé</li>
				<li>Python Packaging User Guide (<a href="https://packaging.python.org/">https://packaging.python.org/</a>)</li>
				<li>PEP 420: Implicit Namespace Packages (<a href="https://www.python.org/dev/peps/pep-0420/">https://www.python.org/dev/peps/pep-0420/</a>)</li>
			</ul>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor110"/>Answers</h1>
			<ol>
				<li value="1">A module is meant to organize functions, variables, and classes into separate Python code files. A Python package is like a folder to organize multiple modules or sub-packages.</li>
				<li>Absolute import requires the use of the absolute path of a package starting from the top level, whereas relative import is based on the relative path of the package as per the current location of the program in which the <strong class="source-inline">import</strong> statement is to be used.</li>
				<li>The <strong class="bold">Python Packaging Authority</strong> (<strong class="bold">PyPA</strong>) is a working group that maintains a core set of software projects used in Python packaging.</li>
				<li>Test PyPI is a repository of software for the Python programming language for testing purposes.</li>
				<li>The <strong class="source-inline">init</strong> file is optional since Python version 3.3.</li>
			</ol>
		</div>
	</body></html>