<html><head></head><body>
		<div><h1 id="_idParaDest-50"><em class="italic"><a id="_idTextAnchor086"/>Chapter 2</em>: Using Modularization to Handle Complex Projects</h1>
			<p>When you start programming in Python, it is very tempting to put all your program code in a single file. There is no problem in defining functions and classes in the same file where your main program is. This option is attractive to beginners because of the ease of execution of the program and to avoid managing code in multiple files. But a single-file program approach is not scalable for medium- to large-size projects. It becomes challenging to keep track of all the various functions and classes that you define.</p>
			<p>To overcome the situation, modular programming is the way to go for medium to large projects. Modularity is a key tool to reduce the complexity of a project. Modularization also facilitates efficient programming, easy debugging and management, collaboration, and reusability. In this chapter, we will discuss how to build and consume modules and packages in Python.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introduction to modules and packages</li>
				<li>Importing modules</li>
				<li>Loading and initializing a module</li>
				<li>Writing reusable modules</li>
				<li>Building packages</li>
				<li>Accessing packages from any location</li>
				<li>Sharing a package</li>
			</ul>
			<p>This chapter will help you understand the concepts of modules and packages in Python.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor087"/>Technical requirements</h1>
			<p>The following are the technical requirements for this chapter:</p>
			<ul>
				<li>You need to have Python 3.7 or later installed on your computer.</li>
				<li>You need to register an account with Test PyPI and create an API token under your account.</li>
			</ul>
			<p>Sample code for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter02">https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter02</a>.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor088"/>Introduction to modules and packages</h1>
			<p>Modules in<a id="_idIndexMarker164"/> Python are Python files with a <code>.py</code> extension. In reality, they are a way to organize functions, classes, and variables using one or more Python files such that they are<a id="_idIndexMarker165"/> easy to manage, reuse across the different modules, and extend as the programs become complex.</p>
			<p>A Python package is the next level of modular programming. A package is like a folder for organizing multiple modules or sub-packages, which is fundamental for sharing the modules for reusability.</p>
			<p>Python source files that use only the standard libraries are easy to share and easy to distribute using email, GitHub, and shared drives, with the only caveat being that there should be Python version compatibility. But this sharing approach will not scale for projects that have a decent number of files and have dependencies on third-party libraries and may be developed for a specific version of Python. To rescue the situation, building and sharing packages is a must for efficient sharing and reusability of Python programs. </p>
			<p>Next, we will discuss how to import modules and the different types of import techniques supported in Python.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor089"/>Importing modules</h1>
			<p>Python code in one module <a id="_idIndexMarker166"/>can get access to the Python code in another module by a process called importing modules. </p>
			<p>To elaborate on the different module and package concepts, we will build two modules and one main script that will use those two modules. These two modules will be updated or reused throughout this chapter.</p>
			<p>To create a new module, we will create a <code>.py</code> file with the name of the module. We will create a <code>mycalculator.py</code> file with two functions: <code>add</code> and <code>subtract</code>. The <code>add</code> function computes the sum of the two numbers provided to the function as arguments and returns the <a id="_idIndexMarker167"/>computed value. The <code>subtract</code> function computes the difference between the two numbers provided to the function as arguments and returns the computed value.</p>
			<p>A code snippet of <code>mycalculator.py</code> is shown next:</p>
			<pre># <strong class="bold">mycalculator.py</strong> with add and subtract functions
def add(x, y):
    """This function adds two numbers"""
    return x + y
def subtract(x, y):
    """This function subtracts two numbers"""
    return x - y</pre>
			<p>Note that the name of the module is the name of the file.</p>
			<p>We will create a second module by adding a new file with the name <code>myrandom.py</code>. This module has two functions: <code>random_1d</code> and <code>random_2d</code>. The <code>random_1d</code> function is for generating a random number between 1 and 9 and the <code>random_2d</code> function is for generating a random number between 10 and 99. Note that this module is also using the <code>random</code> library, which is a built-in module from Python.</p>
			<p>The code snippet of <code>myrandom.py</code> is shown next:</p>
			<pre># <strong class="bold">myrandom.py</strong> with default and custom random functions
import random
def random_1d():
   """This function generates a random number between 0 \
    and 9"""
   return random.randint (0,9)
def random_2d():
   """This function generates a random number between 10 \
    and 99"""
   return random.randint (10,99)</pre>
			<p>To consume these two modules, we also created the main Python script (<code>calcmain1.py</code>), which<a id="_idIndexMarker168"/> imports the two modules and uses them to achieve these two calculator functions. The <code>import</code> statement is the most common way to import built-in or custom modules.</p>
			<p>A code snippet of <code>calcmain1.py</code> is shown next:</p>
			<pre># <strong class="bold">calcmain1.py</strong> with a main function
import mycalculator
import myrandom
def my_main( ):
    """ This is a main function which generates two random\     numbers and then apply calculator functions on them """
    x = myrandom.random_2d( )
    y = myrandom.random_1d( )
    sum = mycalculator.add(x, y)
    diff = mycalculator.subtract(x, y)
    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x, y))
    print(<strong class="bold">"sum is {}"</strong>.format(sum))
    print(<strong class="bold">"diff is {}"</strong>.format(diff))
 <strong class="bold">""" This is executed only if the special variable '__name__'  is set as main"""</strong>
if __name__ == <strong class="bold">"__main__"</strong>:
    my_main()</pre>
			<p>In this main script (another module), we<a id="_idIndexMarker169"/> import the two modules using the <code>import</code> statement. We defined the main function (<code>my_main</code>), which will be executed only if this script or the <code>calcmain1</code> module is executed as the main program. The details of executing the main function from the main program will be covered later in the <em class="italic">Setting special variables</em> section. In the <code>my_main</code> function, we are generating two random numbers using the <code>myrandom</code> module and then calculating the sum and difference of the two random numbers using the <code>mycalculator</code> module. In the end, we are sending the results to the console using the <code>print</code> statement.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">A module is loaded only once. If a module is imported by another module or by the main Python script, the module will be initialized by executing the code in the module. If another module in your program imports the same module again, it will not be loaded twice but only once. This means if there are any local variables inside the module, they will act as a Singleton (initialized only once).</p>
			<p>There are other options available to import a module, such as <code>importlib.import_module()</code> and the built-in <code>__import__()</code> function. Let's discuss how <code>import</code> and other alternative options works.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor090"/>Using the import statement</h2>
			<p>As mentioned <a id="_idIndexMarker170"/>already, the <code>import</code> statement is a common<a id="_idIndexMarker171"/> way to import a module. The next code snippet is an example of using an <code>import</code> statement:</p>
			<pre>import math</pre>
			<p>The <code>import</code> statement is responsible for two operations: first, it searches for the module given after the <code>import</code> keyword, and then it binds the results of that search to a variable name (which is the same as the module name) in the local scope of the execution. In the next two subsections, we will discuss how <code>import</code> works and also how to import specific elements from a module or a package.</p>
			<h3>Learning how import works</h3>
			<p>Next, we need to<a id="_idIndexMarker172"/> understand how the <code>import</code> statement works. First, we need to remind ourselves that all global variables and functions are added to the global namespace by the Python interpreter at the start of an execution. To illustrate the concept, we can write a small Python program to spit out of the contents of the <code>globals</code> namespace, as shown next: </p>
			<pre># <strong class="bold">globalmain.py</strong> with globals() function
def print_globals():
    print (globals())
def hello():
    print (<strong class="bold">"Hello"</strong>)
if __name__ == <strong class="bold">"__main__"</strong>:
    print_globals()</pre>
			<p>This program has two functions: <code>print_globals</code> and <code>hello</code>. The <code>print_globals</code> function will spit out the contents of the global namespace. The <code>hello</code> function will not be executed and is added here to show its reference in the console output of the global namespace. The console output after executing this Python code will be similar to the<a id="_idIndexMarker173"/> following:</p>
			<pre>{
   "__name__":"__main__",
   "__doc__":"None",
   "__package__":"None",
   "__loader__":"&lt;_frozen_importlib_external.\
    SourceFileLoader object at 0x101670208&gt;",
   "__spec__":"None",
   "__annotations__":{
   },
   "__builtins__":"&lt;module 'builtins' (built-in)&gt;",
   "__file__":"/ PythonForGeeks/source_code/chapter2/\
     modules/globalmain.py",
   "__cached__":"None",
   "print_globals":"&lt;function print_globals at \
     0x1016c4378&gt;",
   "hello":"&lt;function hello at 0x1016c4400&gt;"
}</pre>
			<p>The key points to be noticed in this console output are as follows:</p>
			<ul>
				<li>The <code>__name__</code> variable is set to the <code>__main__</code> value. This will be discussed in more detail in the <em class="italic">Loading and initializing a module</em> section.</li>
				<li>The <code>__file__</code> variable is set to the file path of the main module here.</li>
				<li>A reference to each function is added at the end.</li>
			</ul>
			<p>If we add <code>print(globals())</code> to our <code>calcmain1.py</code> script, the console output after adding this statement will be similar to the following:</p>
			<pre>{
   "__name__":"__main__",
   "__doc__":"None",
   "__package__":"None",
   "__loader__":"&lt;_frozen_importlib_external.\
    SourceFileLoader object at 0x100de1208&gt;",
   "__spec__":"None",
   "__annotations__":{},
   "__builtins__":"&lt;module 'builtins' (built-in)&gt;",
   "__file__":"/PythonForGeeks/source_code/chapter2/module1/     main.py",
   "__cached__":"None",
   "mycalculator":"&lt;module 'mycalculator' from \
    '/PythonForGeeks/source_code/chapter2/modules/\
    mycalculator.py'&gt;",
   "myrandom":"&lt;module 'myrandom' from '/PythonForGeeks/source_     code/chapter2/modules/myrandom.py'&gt;",
   "my_main":"&lt;function my_main at 0x100e351e0&gt;"
}</pre>
			<p>An important point to note<a id="_idIndexMarker174"/> is that there are two additional variables (<code>mycalculator</code> and <code>myrandom</code>) added to the global namespace corresponding to each <code>import</code> statement used to import these modules. Every time we import a library, a variable with the same name is created, which holds a reference to the module just like a variable for the global functions (<code>my_main</code> in this case).</p>
			<p>We will see, in other approaches of importing modules, that we can explicitly define some of these variables for each module. The <code>import</code> statement does this automatically for us.</p>
			<h3>Specific import</h3>
			<p>We can also import<a id="_idIndexMarker175"/> something specific (variable or function or class) from a module instead of importing the whole module. This is achieved using the <code>from</code> statement, such as the following:</p>
			<pre>from math import pi</pre>
			<p>Another best practice is to use a different name for an imported module for convenience or sometimes when the same names are being used for different resources in two different libraries. To illustrate this idea, we will be updating our <code>calcmain1.py</code> file (the updated program is <code>calcmain2.py</code>) from the earlier example by using the <code>calc</code> and <code>rand</code> aliases for the <code>mycalculator</code> and <code>myrandom</code> modules, respectively. This change will make use of the modules in the main script much simpler, as shown next:</p>
			<pre># <strong class="bold">calcmain2.py</strong> with alias for modules
import mycalculator <strong class="bold">as calc</strong>
import myrandom <strong class="bold">as rand</strong>
def my_main():
    """ This is a main function which generates two random\
     numbers and then apply calculator functions on them """
    x = rand.random_2d()
    y = rand.random_1d()
    sum = calc.add(x,y)
    diff = calc.subtract(x,y)
    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x,y))
    print(<strong class="bold">"sum is {}"</strong>.format(sum))
    print(<strong class="bold">"diff is {}"</strong>.format(diff))
<strong class="bold">""" This is executed only if the special variable '__name__' is set as main"""</strong>
if __name__ == <strong class="bold">"__main__"</strong>:
    my_main()</pre>
			<p>As a next step, we will combine<a id="_idIndexMarker176"/> the two concepts discussed earlier in the next iteration of the <code>calcmain1.py</code> program (the updated program is <code>calcmain3.py</code>). In this update, we will use the <code>from</code> statement with the module names and then import the individual functions from each module. In the case of the <code>add</code> and <code>subtract</code> functions, we used the <code>as</code> statement to define a different local definition of the module resource for illustration purposes.</p>
			<p>A code snippet of <code>calcmain3.py</code> is as follows:</p>
			<pre># <strong class="bold">calcmain3.py</strong> with from and alias combined
from mycalculator import <strong class="bold">add as my_add</strong>
from mycalculator import <strong class="bold">subtract as my_subtract</strong>
from myrandom import random_2d, random_1d
def my_main():
    """ This is a main function which generates two random
     numbers and then apply calculator functions on them """
    x = random_2d()
    y = random_1d()
    sum =  my_add(x,y)
    diff = my_subtract(x,y)
    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x,y))
    print(<strong class="bold">"sum is {}"</strong>.format(sum))
    print(<strong class="bold">"diff is {}"</strong>.format(diff))
    print (globals())
<strong class="bold">""" This is executed only if the special variable '__name__' is set as main"""</strong>
if __name__ == <strong class="bold">"__main__"</strong>:
    my_main()</pre>
			<p>As we used the <code>print (globals())</code> statement with this program, the console output of this program will<a id="_idIndexMarker177"/> show that the variables corresponding to each function are created as per our alias. The sample console output is as follows:</p>
			<pre>{
   "__name__":"__main__",
   "__doc__":"None",
   "__package__":"None",
   "__loader__":"&lt;_frozen_importlib_external.\
    SourceFileLoader object at 0x1095f1208&gt;",
   "__spec__":"None",
   "__annotations__":{},
   "__builtins__":"&lt;module 'builtins' (built-in)&gt;", "__    file__":"/PythonForGeeks/source_code/chapter2/module1/     main_2.py",
   "__cached__":"None",
   "<strong class="bold">my_add</strong>":"&lt;function add at 0x109645400&gt;",
   "<strong class="bold">my_subtract</strong>":"&lt;function subtract at 0x109645598&gt;",
   "<strong class="bold">random_2d</strong>":"&lt;function random_2d at 0x10967a840&gt;",
   "<strong class="bold">random_1d</strong>":"&lt;function random_1d at 0x1096456a8&gt;",
   "my_main":"&lt;function my_main at 0x109645378&gt;"
}</pre>
			<p>Note that the variables in bold correspond <a id="_idIndexMarker178"/>to the changes we made in the <code>import</code> statements in the <code>calcmain3.py</code> file.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor091"/>Using the __import__ statement</h2>
			<p>The <code>__import__</code> statement is a low-level function in Python that takes a string as input and triggers the actual import operation. Low-level functions are part of the core Python language and are<a id="_idIndexMarker179"/> typically meant to be used for library development or for accessing operating system resources, and are not commonly used for application development. We can use this keyword to import the <code>random</code> library in our <code>myrandom.py</code> module as follows:</p>
			<pre>#import random
random = __import__(<strong class="bold">'random'</strong>)</pre>
			<p>The rest of the code in <code>myrandom.py</code> can be used as it is without any change.</p>
			<p>We illustrated a simple case of using the <code>__import__</code> method for academic reasons and we will skip the advanced details for those of you who are interested in exploring as further reading. The reason for this is that the <code>__import__</code> method is not recommended to be used for user applications; it is designed more for interpreters.</p>
			<p>The <code>importlib.import_module</code> statement is the one to be used other than the regular import for advanced functionality.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor092"/>Using the importlib.import_module statement</h2>
			<p>We can import any module using the <code>importlib</code> library. The <code>importlib</code> library offers a variety of <a id="_idIndexMarker180"/>functions, including <code>__import__</code>, related to importing modules in a more flexible way. Here is a simple example of how to import a <code>random</code> module in our <code>myrandom.py</code> module using <code>importlib</code>:</p>
			<pre>import importlib
random = importlib.import_module('random')</pre>
			<p>The rest of the code in <code>myrandom.py</code> can be used as it is without any change.</p>
			<p>The <code>importlib</code> module is best known for importing modules dynamically and is very useful in cases where the name of the module is not known in advance and we need to import the modules at runtime. This is a common requirement for the development of plugins and extensions.</p>
			<p>Commonly used functions available in the <code>importlib</code> module are as follows:</p>
			<ul>
				<li><code>__import__</code>: This is the implementation of the <code>__import__</code> function, as already discussed.</li>
				<li><code>import_module</code>: This is used to import a module and is most commonly used to load a module dynamically. In this method, you can specify whether you want to import a module using an absolute or relative path. The <code>import_module</code> function is a wrapper around <code>importlib.__import__</code>. Note that the former function brings back the package or module (for example, <code>packageA.module1</code>), which is specified with the function, while the latter function always returns the top-level package or module (for example, <code>packageA</code>).</li>
				<li><code>importlib.util.find_spec</code>: This is a replaced method for the <code>find_loader</code> method, which is deprecated since Python release 3.4. This method can be used to validate whether the module exists and it is valid.</li>
				<li><code>invalidate_caches</code>: This method can be used to invalidate the internal caches of finders stored at <code>sys.meta_path</code>. The internal cache is useful to load the module faster without triggering the finder methods again. But if we are dynamically importing a module, especially if it is created after the interpreter began execution, it is a<a id="_idIndexMarker181"/> best practice to call the <code>invalidate_caches</code> method. This function will clear all modules or libraries from the cache to make sure the requested module is loaded from the system path by the <code>import</code> system.</li>
				<li><code>reload</code>: As the name suggests, this function is used to reload a previously imported module. We need to provide the module object as an input parameter for this function. This means the <code>import</code> function has to be done successfully. This function is very helpful when module source code is expected to be edited or changed and you want to load the new version without restarting the program.</li>
			</ul>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor093"/>Absolute versus relative import</h2>
			<p>We <a id="_idIndexMarker182"/>have fairly a good idea of how to use <code>import</code> statements. Now it is time to understand <strong class="bold">absolute</strong> and <strong class="bold">relative</strong> imports, especially when we are importing custom or project-specific modules. To illustrate the two<a id="_idIndexMarker183"/> concepts, let's take an example of <a id="_idIndexMarker184"/>a project with different packages, sub-packages, and modules, as shown next:</p>
			<pre>project
  ├── pkg1
  │   ├── module1.py
  │   └── module2.py (contains a function called func1 ())
  └── pkg2
      ├── __init__.py
      ├── module3.py
      └── sub_pkg1
          └── module6.py (contains a function called func2 ())
  ├── pkg3
  │   ├── module4.py
  │   ├── module5.py
      └── sub_pkg2
          └── module7.py</pre>
			<p>Using this project structure, we will <a id="_idIndexMarker185"/>discuss how to use absolute <a id="_idIndexMarker186"/>and relative imports.</p>
			<h3>Absolute import</h3>
			<p>We can use absolute paths starting <a id="_idIndexMarker187"/>from the top-level package and drilling down to the sub-package and module level. A few examples of importing different modules are shown here:</p>
			<pre>from pkg1 import module1
from <strong class="bold">pkg1.module2</strong> import func1
from pkg2 import module3
from <strong class="bold">pkg2.sub_pkg1.module6</strong> import func2
from pkg3 import module4, module5
from <strong class="bold">pkg3.sub_pkg2</strong> import module7</pre>
			<p>For absolute import statements, we must give a detailed path for each package or file, from the top-level package folder, which is similar to a file path.</p>
			<p>Absolute imports are recommended because they are easy to read and easy to follow the exact location of imported resources. Absolute imports are least impacted by project sharing and changes in the current location of <code>import</code> statements. In fact, PEP 8 explicitly recommends the use of absolute imports.</p>
			<p>Sometimes, however, absolute imports are quite long statements depending on the size of the project folder structure, which is not convenient to maintain.</p>
			<h3>Relative import</h3>
			<p>A relative import specifies the resource to be imported relative to the current location, which is mainly the current<a id="_idIndexMarker188"/> location of the Python code file where the <code>import</code> statement is used.</p>
			<p>For the project examples discussed earlier, here are a few scenarios of relative import. The equivalent relative import statements are as follows:</p>
			<ul>
				<li><code>funct1</code> inside <code>module1.py</code>:<pre> from <code>.</code>) only because <code>module2.py</code> is in the same folder as <code>module1.py</code>.</p></li>
				<li><code>module4</code> inside <code>module1.py</code>:<pre>from <code>..</code>) because <code>module4.py</code> is in the sibling folder of <code>module1.py</code>.</p></li>
				<li><code>Func2</code> inside <code>module1.py</code>:<pre>from <code>..</code>) because the target module (<code>module2.py</code>) is inside a folder that is in the sibling folder of <code>module1.py</code>. We used one dot to access the <code>sub_pkg_1</code> package and another dot to access <code>module2</code>.</p></li>
			</ul>
			<p>One advantage of relative imports is that they are simple and can significantly reduce long <code>import</code> statements. But relative <code>import</code> statements can be messy and difficult to maintain when projects are shared across teams and organizations. Relative imports are not easy to read and manage.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor094"/>Loading and initializing a module</h1>
			<p>Whenever the Python interpreter interacts with an <code>import</code> or equivalent statement, it does three operations, which are described in the next sections.</p>
			<h3>Loading a module</h3>
			<p>The Python<a id="_idIndexMarker189"/> interpreter searches for the specified module on a <code>sys.path</code> (to be discussed in the <em class="italic">Accessing packages from any location</em> section) and loads the source code. This has been explained in the <em class="italic">Learning how import works</em> section.</p>
			<h3>Setting special variables</h3>
			<p>In this step, the Python<a id="_idIndexMarker190"/> interpreter defines a few special variables, such as <code>__name__</code>, which basically defines the namespace that a Python module is running in. The <code>__name__</code> variable is one of the most important variables.</p>
			<p>In the case of our example of the <code>calcmain1.py</code>, <code>mycalculator.py</code>, and <code>myrandom.py</code> modules, the <code>__name__</code> variable will be set for each module as follows:</p>
			<div><div><img src="img/table.jpg" alt="Table 2.1 – The __name__ attribute value for different modules"/>
				</div>
			</div>
			<p class="figure-caption">Table 2.1 – The __name__ attribute value for different modules</p>
			<p>There are two cases of setting the <code>__name__</code> variable, which are described next.</p>
			<h4>Case A – module as the main program</h4>
			<p>If you are running your <a id="_idIndexMarker191"/>module as the main program, the <code>__name__</code> variable will be set to the <code>__main__</code> value regardless of whatever the name of the Python file or module is. For example, when <code>calcmain1.py</code> is executed, the interpreter will assign the hardcoded <code>__main__</code> string to the <code>__name__</code> variable. If we run <code>myrandom.py</code> or <code>mycalculator.py</code> as the main program, the <code>__name__</code> variable will automatically get the value of <code>__main__</code>.</p>
			<p>Therefore, we added an <code>if __name__ == '__main__'</code> line to all main scripts to check whether this is the main execution program.</p>
			<h4>Case B – module is imported by another module</h4>
			<p>In this case, your module<a id="_idIndexMarker192"/> is not the main program, but it is imported by another module. In our example, <code>myrandom</code> and <code>mycalculator</code> are imported in <code>calcmain1.py</code>. As soon as the Python interpreter finds the <code>myrandom.py</code> and <code>mycalculator.py</code> files, it will assign the <code>myrandom</code> and <code>mycalculator</code> names from the <code>import</code> statement to the <code>__name__</code> variable for each module. This assignment is done prior to executing the code inside these modules. This is reflected in <em class="italic">Table 2.1</em>.</p>
			<p>Some of the other noticeable special variables are as follows:</p>
			<ul>
				<li><code>__file__</code>: This variable contains the path to the module that is currently being imported.</li>
				<li><code>__doc__</code>: This variable will output the docstring that is added in a class or a method. As discussed in <a href="B17189_01_Final_PG_ePub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Optimal Python Development Life Cycle</em>, a docstring is a comment line added right after the class or method definition.</li>
				<li><code>__package__</code>: This is used to indicate whether the module is a package or not. Its value can be a package name, an empty string, or <code>none</code>.</li>
				<li><code>__dict__</code>: This will return all attributes of a class instance as a dictionary.</li>
				<li><code>dir</code>: This is actually a method that returns every associated method or attribute as a list.</li>
				<li><code>Locals</code> and <code>globals</code>: These are <a id="_idIndexMarker193"/>also used as methods that display the local and global variables as dictionary entries.</li>
			</ul>
			<h3>Executing the code</h3>
			<p>After the special variables <a id="_idIndexMarker194"/>are set, the Python interpreter executes the code in the file line by line. It is important to know that functions (and the code under the classes) are not executed unless they are not called by other lines of code. Here is a quick analysis of the three modules from the execution point of view when <code>calcmain1.py</code> is run:</p>
			<ul>
				<li><code>mycalculator.py</code>: After setting the special variables, there is no code to be executed in this module at the initialization time.</li>
				<li><code>myrandom.py</code>: After setting the special variables and the <code>import</code> statement, there is no further code to be executed in this module at initialization time.</li>
				<li><code>calcmain1.py</code>: After setting the special variables and executing the <code>import</code> statements, it executes the following <code>if</code> statement: <code>if __name__ == "__main__":</code>. This will return <code>true</code> because we launched the <code>calcmain1.py</code> file. Inside the <code>if</code> statement, the <code>my_main ()</code> function will be called, which in fact then calls methods from the <code>myrandom.py</code> and <code>mycalculator.py</code> modules.</li>
			</ul>
			<p>We can add an <code>if __name__ == "__main__"</code> statement to any module regardless of whether it is the main program or not. The advantage of using this approach is that the module can be used both as a module or as a main program. There is also another application of using this approach, which is to add unit tests within the module.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor095"/>Standard modules</h2>
			<p>Python comes with <a id="_idIndexMarker195"/>a library of over 200 standard modules. The exact number varies from one distribution to the other. These modules can be imported into your <a id="_idIndexMarker196"/>program. The list of these modules is very extensive but only a few commonly used modules are mentioned here as an example of standard modules:</p>
			<ul>
				<li><code>math</code>: This module provides mathematical functions for arithmetic operations.</li>
				<li><code>random</code>: This module is helpful to generate pseudo-random numbers using different types of distributions.</li>
				<li><code>statistics</code>: This module offers statistics functions such as <code>mean</code>, <code>median</code>, and <code>variance</code>.</li>
				<li><code>base64</code>: This module provides functions to encode and decode data.</li>
				<li><code>calendar</code>: This module offers functions related to the calendar, which is helpful for calendar-based computations.</li>
				<li><code>collections</code>: This module contains specialized container data types other than the general-purpose built-in containers (such as <code>dict</code>, <code>list</code>, or <code>set</code>). These specialized data types include <code>deque</code>, <code>Counter</code>, and <code>ChainMap</code>. </li>
				<li><code>csv</code>: This module helps in reading from and writing to comma-based delimited files.</li>
				<li><code>datetime</code>: This module offers general-purpose data and time functions.</li>
				<li><code>decimal</code>: This module is specific for decimal-based arithmetic operations.</li>
				<li><code>logging</code>: This module is used to facilitate logging into your application.</li>
				<li><code>os</code> and <code>os.path</code>: These modules are used to access operating system-related functions. </li>
				<li><code>socket</code>: This module provides low-level functions for socket-based network communication.</li>
				<li><code>sys</code>: This module provides access to a Python interpreter for low-level variables and functions.</li>
				<li><code>time</code>: This module <a id="_idIndexMarker197"/>offers time-related functions such as<a id="_idIndexMarker198"/> converting to different time units. </li>
			</ul>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor096"/>Writing reusable modules</h1>
			<p>For a module to be<a id="_idIndexMarker199"/> declared reusable, it has to have the following characteristics:</p>
			<ul>
				<li>Independent functionality</li>
				<li>General-purpose functionality</li>
				<li>Conventional coding style</li>
				<li>Well-defined documentation</li>
			</ul>
			<p>If a module or package does not have these characteristics, it would be very hard, if not impossible, to reuse it in other programs. We will discuss each characteristic one by one.</p>
			<h3>Independent functionality</h3>
			<p>The functions in a<a id="_idIndexMarker200"/> module should offer functionality independent of other modules and independent of any local or global variables. The more independent the functions are, the more reusable the module is. If it has to use other modules, it has to be minimal.</p>
			<p>In our example of <code>mycalculator.py</code>, the two functions are completely independent and can be reused by other programs:</p>
			<div><div><img src="img/B17189_02_01.jpg" alt="Figure 2.1 – The mycalculator module with add and subtract functions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – The mycalculator module with add and subtract functions</p>
			<p>In the case of <code>myrandom.py</code>, we are using the <code>random</code> system library to provide the functionality of generating random numbers. This is still a very reusable module because the <code>random</code> library is one<a id="_idIndexMarker201"/> of the built-in modules in Python:</p>
			<div><div><img src="img/B17189_02_02.jpg" alt="Figure 2.2 – The myrandom module with function dependency on the random library&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The myrandom module with function dependency on the random library</p>
			<p>In cases where we have to use third-party libraries in our modules, we can get into problems when sharing our modules with others if the target environment does not have the third-party libraries already installed.</p>
			<p>To elaborate this problem further, we'll introduce a new module, <code>mypandas.py</code>, which will leverage the basic functionality of the famous <code>pandas</code> library. For simplicity, we added only one function to it, which is to print the DataFrame as per the dictionary that is provided as an input variable to the function.</p>
			<p>The code snippet of <code>mypandas.py</code> is as follows:</p>
			<pre>#<strong class="bold">mypandas.py</strong>
import pandas
def print_dataframe(dict):
   """This function output a dictionary as a data frame """
   brics = pandas.DataFrame(dict)
   print(brics)</pre>
			<p>Our <code>mypandas.py</code> module will be using the <code>pandas</code> library to create a <code>dataframe</code> object from the dictionary. This dependency is shown in the next block diagram as well:</p>
			<div><div><img src="img/B17189_02_03.jpg" alt="Figure 2.3 – The mypandas module with dependency on a third-party pandas library&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – The mypandas module with dependency on a third-party pandas library</p>
			<p>Note that the <code>pandas</code> library is not <a id="_idIndexMarker202"/>a built-in or system library. When we try to share this module with others without defining a clear dependency on a third-party library (<code>pandas</code> in this case), the program that will try to use this module will give the following error message:</p>
			<pre>ImportError: No module named pandas'</pre>
			<p>This is why it is important that the module is as independent as possible. If we have to use third-party libraries, we need to define clear dependencies and use an appropriate packaging approach. This will be discussed in the <em class="italic">Sharing a package</em> section.</p>
			<h3>Generalization functionality</h3>
			<p>An ideal reusable module <a id="_idIndexMarker203"/>should focus on solving a general problem rather than a very specific problem. For example, we have a requirement of converting inches to centimeters. We can easily write a function that converts inches into centimeters by applying a conversion formula. What about writing a function that converts any value in the imperial system to a value in the metric system? We can have one function for different conversions that may handle inches to centimeters, feet to meters, or miles to kilometers, or separate functions for each type of these conversions. What about the reverse functions (centimeters to inches)? This may not be required now but may be required later on or by someone who is reusing this module. This generalization will make the module functionality not only comprehensive but also more reusable without extending it.</p>
			<p>To illustrate the generalization concept, we will revise the design of the <code>myrandom</code> module to make it more general and thus more reusable. In the current design, we define separate functions for one-digit and two-digit numbers. What if we need to generate a three-digit random number or to generate a random number between 20 and 30? To generalize the<a id="_idIndexMarker204"/> requirement, we introduce a new function, <code>get_random</code>, in the same module, which takes user input for lower and upper limits of the random numbers. This newly added function is a generalization of the two random functions we already defined. With this new function in the module, the two existing functions can be removed, or they can stay in the module for convenience of use. Note that the newly added function is also offered by the <code>random</code> library out of the box; the reason for providing the function in our module is purely for illustration of the generalized function (<code>get_random</code> in this case) versus the specific functions (<code>random_1d</code> and <code>random_2d</code> in this case).</p>
			<p>The updated version of the <code>myrandom.py</code> module (<code>myrandomv2.py</code>) is as follows:</p>
			<pre># myrandomv2.py with default and custom random functions
import random
def random_1d():
   """This function get a random number between 0 and 9"""
   return random.randint(0,9)
def random_2d():
   """This function get a random number between 10 and 99"""
   return random.randint(10,99)
def get_random(lower, upper):
   """This function get a random number between lower and\
    upper"""
   return random.randint(lower,upper)</pre>
			<h3>Conventional coding style</h3>
			<p>This primarily focuses on how we write function names, variable names, and module names. Python has a coding system<a id="_idIndexMarker205"/> and naming conventions, which were discussed in the previous chapter of this book. It is important to follow the coding and naming conventions, especially when building reusable modules and packages. Otherwise, we will be discussing such modules as bad examples of reusable modules.</p>
			<p>To illustrate this point, we will show the following code snippet with function and parameter names using camel case:</p>
			<pre>def addNumbers(numParam1, numParam2)
  #function code is omitted
Def featureCount(moduleName)
  #function code is omitted </pre>
			<p>If you are coming from a Java background, this code style will seem fine. But it is considered bad practice in Python. The use of the non-Pythonic style of coding makes the reusability of such modules very difficult.</p>
			<p>Here is another snippet of a module with appropriate coding style for function names:</p>
			<pre>def add_numbers(num_param1, num_param2)
  #function code is omitted
Def feature_count(module_name)
  #function code is omitted </pre>
			<p>Another example of a good reusable coding style is illustrated in the next screenshot, which is taken from the PyCharm IDE for the <code>pandas</code> library:</p>
			<div><div><img src="img/B17189_02_04.jpg" alt="Figure 2.4 – The pandas library view in the PyCharm IDE&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – The pandas library view in the PyCharm IDE</p>
			<p>The functions and the variable names are easy to follow even without reading any documentation. Following a <a id="_idIndexMarker206"/>standard coding style makes the reusability more convenient.</p>
			<h3>Well-defined documentation</h3>
			<p>Well-defined and clear <a id="_idIndexMarker207"/>documentation is as important as writing a generalized and independent module with the Python coding guidelines. Without clear documentation, the module will not increase the interest of developers to reuse with convenience. But as programmers, we put more focus on the code than the documentation. Writing a few lines of documentation can make 100 lines of our code more usable and maintainable.</p>
			<p>We will provide a couple of good examples of documentation from a module point of view by using our <code>mycalculator.py</code> module example:</p>
			<pre> """<strong class="bold">mycalculator.py</strong> 
 This module provides functions for add and subtract of two   numbers"""
def add(x,  y):
   """ This function adds two numbers. 
   usage: add (3, 4) """
   return x + y
def subtract(x, y):
   """ This function subtracts two numbers
   usage: subtract (17, 8) """
   return x - y</pre>
			<p>In Python, it is important to <a id="_idIndexMarker208"/>remember the following:</p>
			<ul>
				<li>We can use three quote characters to mark a string that goes across more than one line of the Python source file.</li>
				<li>Triple-quoted strings are used at the start of a module, and then this string is used as the documentation for the module as a whole.</li>
				<li>If any function starts with a triple-quoted string, then this string is used as documentation for that function.</li>
			</ul>
			<p>As a general conclusion, we can make as many modules as we want by writing hundreds of lines of code, but it takes more than writing code to make a reusable module, including generalization, coding style, and most importantly, documentation.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor097"/>Building packages</h1>
			<p>There are a number <a id="_idIndexMarker209"/>of techniques and tools available for creating and distributing packages. The truth is that Python does not have a great history of standardizing the packaging process. There have been multiple projects started in the first decade of the 21st century to streamline this process but not with a lot of success. In the last decade, we <a id="_idIndexMarker210"/>have had some success, thanks to the initiatives of the <strong class="bold">Python Packaging Authority</strong> (<strong class="bold">PyPA</strong>).</p>
			<p>In this section, we will be covering techniques of building packages, accessing the packages in our program, and publishing and sharing the packages as per the guidelines provided by PyPA.</p>
			<p>We will start with package names, followed by the use of an initialization file, and then jump into building a sample package.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor098"/>Naming</h2>
			<p>Package names <a id="_idIndexMarker211"/>should follow the same rule for naming as for modules, which is lowercase with no underscores. Packages act like structured modules.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor099"/>Package initialization file</h2>
			<p>A package can have an optional <a id="_idIndexMarker212"/>source file named <code>__init__.py</code> (or simply an <code>init</code> file). The presence of the <code>init</code> file (even a blank one) is recommended to mark folders as packages. Since Python release 3.3 or later, the use of an <code>init</code> file is optional (PEP 420: Implicit Namespace Packages). There can be multiple purposes of using this <code>init</code> file and there is always a debate about what can go inside an <code>init</code> file versus what cannot go in. A few uses of the <code>init</code> file are discussed here:</p>
			<ul>
				<li><strong class="bold">Empty __init__.py</strong>: This will force<a id="_idIndexMarker213"/> developers to use explicit imports and manage the namespaces as they like. As expected, developers have to import separate modules, which can be tedious for a large package.</li>
				<li><code>__init__</code> file.</li>
				<li><code>init</code> file from different modules and manage them under the package namespace. This provides the additional benefit of providing a wrapper around the underlying module's functionality. If by any chance we have to refactor the underlying modules, we have an option to keep the namespace the same, especially for API consumers. The only drawback of this approach is that it requires extra effort to manage and maintain such <code>init</code> files.</li>
			</ul>
			<p>Sometimes, developers add code to the <code>init</code> file that is executed when a module is imported from a package. An example of such code is to create a session for remote systems such as a<a id="_idIndexMarker214"/> database or remote SSH server.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor100"/>Building a package</h2>
			<p>Now we will discuss how to build a <a id="_idIndexMarker215"/>package with one sample package example. We will build a <code>masifutil</code> package using the following modules and a sub-package:</p>
			<ul>
				<li>The <code>mycalculator.py</code> module: We already built this module for the <em class="italic">Importing modules</em> section.</li>
				<li>The <code>myrandom.py</code> module: This module was also built for the <em class="italic">Importing modules</em> section.</li>
				<li>The <code>advcalc</code> sub-package: This will be a sub-package and will contain one module in it (<code>advcalculator.py</code>). We will define an <code>init</code> file for this sub-package but it will be empty.</li>
			</ul>
			<p>The <code>advcalculator.py</code> module has additional functions for calculating the square root and log using base 10 and base 2. The source code for this module is shown next:</p>
			<pre># advcalculator.py with sqrt, log and ln functions
import math
def sqrt(x):
   """This function takes square root of a number"""
   return math.sqrt(x)
def log(x):
   """This function returns log of base 10"""
   return math.log(x,10)
def ln(x):
   """This function returns log of base 2"""
   return math.log(x,2)</pre>
			<p>The file structure<a id="_idIndexMarker216"/> of the <code>masifutil</code> package with <code>init</code> files will look like this:</p>
			<div><div><img src="img/B17189_02_05.jpg" alt="Figure 2.5 – Folder structure of the masifutil package with modules and sub-packages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – Folder structure of the masifutil package with modules and sub-packages</p>
			<p>In the next step, we will build a new main script (<code>pkgmain1.py</code>) to consume the modules from the package or <code>masifutil</code> subfolder. In this script, we will import the modules from the main package and sub-package using the folder structure, and then use the module functions to compute two random numbers, the sum and difference of the two numbers, and the square root and logarithmic values of the first random numbers. The source code for <code>pkgmain1.py</code> is as follows:</p>
			<pre># <strong class="bold">pkgmain0.py</strong> with direct import 
import <strong class="bold">masifutil.mycalculator</strong> as calc
import <strong class="bold">masifutil.myrandom</strong> as rand
import <strong class="bold">masifutil.advcalc.advcalculator</strong> as acalc
def my_main():
    """ This is a main function which generates two random\
     numbers and then apply calculator functions on them """
    x = rand.random_2d()
    y = rand.random_1d()
    sum = calc.add(x,y)
    diff = calc.subtract(x,y)
    sroot = acalc.sqrt(x)
    log10x = acalc.log(x)
    log2x = acalc.ln(x)
    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x, y))
    print(<strong class="bold">"sum is {}"</strong>.format(sum))
    print(<strong class="bold">"diff is {}"</strong>.format(diff))
    print(<strong class="bold">"square root is {}"</strong>.format(sroot))
    print(<strong class="bold">"log base of 10 is {}"</strong>.format(log10x))
    print(<strong class="bold">"log base of 2 is {}"</strong>.format(log2x))
<strong class="bold">""" This is executed only if the special variable '__name__' is set as main"""</strong>
if __name__ == <strong class="bold">"__main__"</strong>:
    my_main()</pre>
			<p>Here, we will be using the package<a id="_idIndexMarker217"/> name and module name to import the modules, which is cumbersome especially when we need to import the sub-packages. We can also use the following statements with the same results:</p>
			<pre># mypkgmain1.py with from statements
from masifutil import mycalculator as calc
from masifutil import myrandom as rand
from masifutil.advcalc import advcalculator as acalc
#rest of the code is the same as in mypkgmain1.py</pre>
			<p>As mentioned earlier, the use of the empty <code>__init__.py</code> file is optional. But we have added it in this case for illustration purposes.</p>
			<p>Next, we will explore how to add some <code>import</code> statements to the <code>init</code> file. Let's start with importing the modules<a id="_idIndexMarker218"/> inside the <code>init</code> file. In this top-level <code>init</code> file, we will import all functions as shown next:</p>
			<pre>#<strong class="bold">__init__ </strong>file for package 'masifutil'
from .mycalculator import add, subtract
from .myrandom import random_1d, random_2d
from .advcalc.advcalculator import sqrt, log, ln</pre>
			<p>Note the use of <code>.</code> before the module name. This is required for Python for the strict use of relative imports.</p>
			<p>As a result of these three lines inside the <code>init</code> file, the new main script will become simple and the sample code is shown next:</p>
			<pre># <strong class="bold">pkgmain2.py</strong> with main function
import masifutil
def my_main():
    """ This is a main function which generates two random\
     numbers and then apply calculator functions on them """
    x = masifutil.random_2d()
    y = masifutil.random_1d()
    sum = masifutil.add(x,y)
    diff = masifutil.subtract(x,y)
    sroot = masifutil.sqrt(x)
    log10x = masifutil.log(x)
    log2x = masifutil.ln(x)
    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x, y))
    print(<strong class="bold">"sum is {}"</strong>.format(sum))
    print(<strong class="bold">"diff is {}"</strong>.format(diff))
    print(<strong class="bold">"square root is {}"</strong>.format(sroot))
    print(<strong class="bold">"log base of 10 is {}"</strong>.format(log10x))
    print(<strong class="bold">"log base of 2 is {}"</strong>.format(log2x))
<strong class="bold">""" This is executed only if the special variable '__name__' is set as main"""</strong>
if __name__ == <strong class="bold">"__main__"</strong>:
    my_main()</pre>
			<p>The functions of the two main modules and the sub-package module are available at the main package level and the developers do not need to know the underlying hierarchy and structure of the<a id="_idIndexMarker219"/> modules within the package. This is the convenience we discussed earlier of using <code>import</code> statements inside the <code>init</code> file.</p>
			<p>We build the package by keeping the package source code in the same folder where the main program or script resides. This works only to share the modules within a project. Next, we will discuss how to access the package from other projects and from any program from anywhere.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor101"/>Accessing packages from any location</h1>
			<p>The package we<a id="_idIndexMarker220"/> built in the previous subsection is accessible only if the program calling the modules is at the same level as the package location. This requirement is not practical for code reusability and code sharing.</p>
			<p>In this section, we will discuss<a id="_idIndexMarker221"/> a few techniques to make packages available and usable from any program on any location in our system.</p>
			<h3>Appending sys.path</h3>
			<p>This is a <a id="_idIndexMarker222"/>useful option for setting <code>sys.path</code> dynamically. Note that <code>sys.path</code> is a list of directories on which a Python interpreter searches every time it executes an <code>import</code> statement in a source program. By using this approach, we are appending (adding) paths of directories or folders containing our packages to <code>sys.path</code>.</p>
			<p>For the <code>masifutil</code> package, we will build a new program, <code>pkgmain3.py</code>, which is a copy of <code>pkgmain2.py</code> (to be updated later) but is kept outside the folder where our <code>masifutil</code> package is residing. <code>pkgmain3.py</code> can be in any folder other than the <code>mypackages</code> folder. Here is the folder structure with a new main script (<code>pkgmain3.py</code>) and the <code>masifutil</code> package for reference:</p>
			<div><div><img src="img/B17189_02_06.jpg" alt="Figure 2.6 – Folder structure of the masifutil package and a new main script, pkgmain3.py&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Folder structure of the masifutil package and a new main script, pkgmain3.py</p>
			<p>When we execute the <code>pkgmain3.py</code> program, it returns an error: <code>ModuleNotFoundError: No module named 'masifutil'</code>. This is expected as the path of the <code>masifutil</code> package is not added to <code>sys.path</code>. To add the package folder to <code>sys.path</code>, we will update the main program; let's name it <code>pkgmain4.py</code>, with additional statements for appending <code>sys.path</code>, which is shown next:</p>
			<pre># <strong class="bold">pkgmain4.py</strong> with sys.path append code
import sys
sys.path.append(<strong class="bold">'/Users/muasif/Google Drive/PythonForGeeks/source_code/chapter2/mypackages'</strong>)
import masifutil
def my_main():
    """ This is a main function which generates two random\
     numbers and then apply calculator functions on them """
    x = masifutil.random_2d()
    y = masifutil.random_1d()
    sum = masifutil.add(x,y)
    diff = masifutil.subtract(x,y)
    sroot = masifutil.sqrt(x)
    log10x = masifutil.log(x)
    log2x = masifutil.ln(x)
    print(<strong class="bold">"x = {}, y = {}"</strong>.format(x, y))
    print(<strong class="bold">"sum is {}"</strong>.format(sum))
    print(<strong class="bold">"diff is {}"</strong>.format(diff))
    print(<strong class="bold">"square root is {}"</strong>.format(sroot))
    print(<strong class="bold">"log base of 10 is {}"</strong>.format(log10x))
    print(<strong class="bold">"log base of 2 is {}"</strong>.format(log2x))
<strong class="bold">""" This is executed only if the special variable '__name__' is set as main"""</strong>
if __name__ == <strong class="bold">"__main__"</strong>:
    my_main()</pre>
			<p>After adding the additional lines <a id="_idIndexMarker223"/>of appending <code>sys.path</code>, we executed the main script without any error and with the expected console output. This is because our <code>masifutil</code> package is now available on a path where the Python interpreter can load it when we are importing it in our main script.</p>
			<p>Alternative to appending <code>sys.path</code>, we can also use the <code>site.addsitedir</code> function from the site module. The only advantage of using this approach is that this function also looks for <code>.pth</code> files within the included folders, which is helpful for adding additional folders such as sub-packages. A snippet of a sample main script (<code>pktpamin5.py</code>) with the <code>addsitedir</code> function is shown next:</p>
			<pre># <strong class="bold">pkgmain5.py</strong>
import site
site.addsitedir(<strong class="bold">'/Users/muasif/Google Drive/PythonForGeeks/source_code/chapter2/mypackages'</strong>)
import masifutil
#rest of the code is the same as in pkymain4.py</pre>
			<p>Note that the directories we append or add using this approach are available only during the program execution. To set <code>sys.path</code> permanently (at the session or system level), the approaches that we will discuss next are more helpful.</p>
			<h4>Using the PYTHONPATH environment variable</h4>
			<p>This is a convenient way to <a id="_idIndexMarker224"/>add our package folder to <code>sys.path</code>, which the Python interpreter will use to search for the package and modules if not present in the built-in library. Depending on the operating system we are using, we can define this variable as follows.</p>
			<p>In Windows, the environment variable can be defined using either of the following options:</p>
			<ul>
				<li><code>PYTHONPATH = "C:\pythonpath1;C:\pythonpath2"</code>. This is good for one active session.</li>
				<li><strong class="bold">The graphical user interface</strong>: Go to <strong class="bold">My Computer</strong> | <strong class="bold">Properties</strong> | <strong class="bold">Advanced System Settings</strong> | <strong class="bold">Environment Variables</strong>. This is a permanent setting.</li>
			</ul>
			<p>In Linux and macOS, it can be set using <code>export PYTHONPATH= `/some/path/`</code>. If set using Bash or an equivalent terminal, the environment variable will be effective for the terminal session only. To set it permanently, it is recommended to add the environment variable at the end of a profile file, such as <code>~/bash_profile</code>.</p>
			<p>If we execute the <code>pkgmain3.py</code> program without setting <code>PYTHONPATH</code>, it returns an error: <code>ModuleNotFoundError: No module named 'masifutil'</code>. This is again expected as the path of the <code>masifutil</code> package is not added to <code>PYTHONPATH</code>.</p>
			<p>In the next step, we will add the folder path containing <code>masifutil</code> to the <code>PYTHONPATH</code> variable and rerun the <code>pkgmain3</code> program. This time, it works without any error and with the expected console output.</p>
			<h4>Using the .pth file under the Python site package</h4>
			<p>This is another convenient<a id="_idIndexMarker225"/> way of adding packages to <code>sys.path</code>. This is achieved by defining a <code>.pth</code> file under the Python site packages. The file can hold all the folders we want to add to <code>sys.path</code>.</p>
			<p>For illustration purposes, we created a <code>my.pth</code> file under <code>venv/lib/Python3.7/site-packages</code>. As we can see in <em class="italic">Figure 2.7</em>, we added a folder that contains our <code>masifutil</code> package. With this simple <code>.pth</code> file, our main script <code>pkymain3.py</code> program works fine without any error and with expected console output:</p>
			<div><div><img src="img/B17189_02_07.jpg" alt="Figure 2.7 – A view of a virtual environment with the my.pth file"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – A view of a virtual environment with the my.pth file</p>
			<p>The approaches we <a id="_idIndexMarker226"/>discussed to access custom packages are effective to reuse the packages and modules on the same system with any program. In the next section, we will explore how to share packages with other developers and communities.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor102"/>Sharing a package</h1>
			<p>To distribute Python<a id="_idIndexMarker227"/> packages and projects across communities, there are many tools available. We will focus only on the tools that are recommended as per the guidelines provided by PyPA.</p>
			<p>In this section, we will be covering installing and distributing packaging techniques. A few tools that we will<a id="_idIndexMarker228"/> use or are at least worth mentioning in this section as a reference are as follows:</p>
			<ul>
				<li><strong class="bold">distutils</strong>: This comes with Python <a id="_idIndexMarker229"/>with base functionality. It is not easy to extend for complex and custom package distribution.</li>
				<li><strong class="bold">setuputils</strong>: This is a<a id="_idIndexMarker230"/> third-party tool and an extension of distutils and is recommended for building packages.</li>
				<li><strong class="bold">wheel</strong>: This is for the <a id="_idIndexMarker231"/>Python packaging format and it makes installations faster and easier as compared to its predecessors.</li>
				<li><code>pip install &lt;module name&gt;</code>.</li>
				<li><strong class="bold">The Python Package Index (PyPI)</strong>: This is a<a id="_idIndexMarker233"/> repository of software for the Python programming language. PyPI is used to find and install software developed and shared by the Python community.</li>
				<li><strong class="bold">Twine</strong>: This is a utility for <a id="_idIndexMarker234"/>publishing Python packages to PyPI.</li>
			</ul>
			<p>In the next subsections, we will update the <code>masifutil</code> package to include additional components as per the guidelines provided by PyPA. This will be followed by installing the updated <code>masifutil</code> package system-wide using pip. In the end, we will publish the updated <code>masifutil</code> package to <strong class="bold">Test PyPI</strong> and install it from Test PyPI.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor103"/>Building a package as per the PyPA guidelines</h2>
			<p>PyPA recommends <a id="_idIndexMarker235"/>using a sample project for building reusable packages and it is available at <a href="https://github.com/pypa/sampleproject">https://github.com/pypa/sampleproject</a>. A snippet of the sample project from the GitHub location is as shown:</p>
			<div><div><img src="img/B17189_02_08.jpg" alt="Figure 2.8 – A view of the sample project on GitHub by PyPA&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – A view of the sample project on GitHub by PyPA</p>
			<p>We will introduce<a id="_idIndexMarker236"/> key files and folders, which are important to understand before we use them for updating our <code>masifutil</code> package:</p>
			<ul>
				<li><code>setup.py</code>: This is the most important file, which has to exist at the root of the project or package. It is a script for building and installing the package. This file contains a global <code>setup()</code> function. The setup file also provides a command-line interface for running various commands.</li>
				<li><code>setup.cfg</code>: This is an <code>ini</code> file that can be used by <code>setup.py</code> to define defaults.</li>
				<li><code>setup()</code> args: The key arguments that can be passed to the setup function are as follows:<p>a) Name</p><p>b) Version</p><p>c) Description</p><p>d) URL</p><p>e) Author</p><p>f) License</p></li>
				<li><code>README.rst</code>/<code>README.md</code>: This file (either reStructured or Markdown format) can contain information about the package or project.</li>
				<li><code>license.txt</code>: The <code>license.txt</code> file should be included with every package with details of the terms and conditions of distribution. The license file is important<a id="_idIndexMarker237"/>, especially in countries where it is illegal to distribute packages without the appropriate license. </li>
				<li><code>MANIFEST.in</code>: This file can be used to specify a list of additional files to include in the package. This list of files doesn't include the source code files (which are automatically included). </li>
				<li><code>&lt;package&gt;</code>: This is the top-level package containing all the modules and packages inside it. It is not mandatory to use, but it is a recommended approach.</li>
				<li><code>data</code>: This is a place to add data files if needed.</li>
				<li><code>tests</code>: This is a placeholder to add unit tests for the modules.</li>
			</ul>
			<p>As a next step, we will update our previous <code>masifutil</code> package as per the PyPA guidelines. Here is the new folder and file structure of the updated <code>masifutilv2</code> package:</p>
			<div><div><img src="img/B17189_02_09.jpg" alt="Figure 2.9 – A view of the updated masifutilv2 file structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – A view of the updated masifutilv2 file structure</p>
			<p>We have added <code>data</code> and <code>tests</code> directories, but they are actually empty for now. We will evaluate the unit tests in a later chapter to complete this topic.</p>
			<p>The contents of most<a id="_idIndexMarker238"/> of the additional files are covered in the sample project and thus will not be discussed here, except the <code>setup.py</code> file.</p>
			<p>We updated <code>setup.py</code> with basic arguments as per our package project. The details of the rest of the arguments are available in the sample <code>setup.py</code> file provided with the sample project by PyPA. Here is a snippet of our <code>setup.py</code> file:</p>
			<pre>from setuptools import setup
setup(
   name=<strong class="bold">'masifutilv2'</strong>,
   version=<strong class="bold">'0.1.0'</strong>,
   author=<strong class="bold">'Muhammad Asif'</strong>,
   author_email=<strong class="bold">'ma@example.com'</strong>,
   packages=[<strong class="bold">'masifutil'</strong>, <strong class="bold">'masifutil/advcalc'</strong>],
   python_requires=<strong class="bold">'&gt;=3.5, &lt;4'</strong>,
   url=<strong class="bold">'http://pypi.python.org/pypi/PackageName/'</strong>,
   license=<strong class="bold">'LICENSE.txt'</strong>,
   description=<strong class="bold">'A sample package for illustration purposes'</strong>,
   long_description=open(<strong class="bold">'README.md'</strong>).read(),
   install_requires=[
   ],
)</pre>
			<p>With this <code>setup.py</code> file, we are ready to share our <code>masifutilv2</code> package locally as well as remotely, which we <a id="_idIndexMarker239"/>will discuss in the next subsections.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor104"/>Installing from the local source code using pip</h2>
			<p>Once we have updated the package <a id="_idIndexMarker240"/>with new files, we are ready to install it using the pip utility. The simplest way to install it is by executing the following command with the path to the <code>masifutilv2</code> folder:</p>
			<pre>&gt; pip install &lt;path to masifutilv2&gt;</pre>
			<p>The following is the console output of the command when run without installing the wheel package:</p>
			<pre>Processing ./masifutilv2
Using legacy 'setup.py install' for masifutilv2, since package 'wheel' is not installed.
Installing collected packages: masifutilv2
    Running setup.py install for masifutilv2 ... done
Successfully installed masifutilv2-0.1.0 </pre>
			<p>The pip utility installed the package successfully but using the egg format since the <code>wheel</code> package was not installed. Here is a view of our virtual environment after the installation:</p>
			<div><div><img src="img/B17189_02_10.jpg" alt="Figure 2.10 – A view of the virtual environment after installing masifutilv2 using pip&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – A view of the virtual environment after installing masifutilv2 using pip</p>
			<p>After installing the package<a id="_idIndexMarker241"/> under the virtual environment, we tested it with our <code>pkgmain3.py</code> program, which worked as expected.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To uninstall the package, we can use <code>pip uninstall masifutilv2</code>.</p>
			<p>As a next step, we will install the <code>wheel</code> package and then reinstall the same package again. Here is the installation command:</p>
			<pre>&gt; pip install &lt;path to masifutilv2&gt;</pre>
			<p>The console output will be similar to the following:</p>
			<pre>Processing ./masifutilv2
Building wheels for collected packages: masifutilv2
  Building wheel for masifutilv2 (setup.py) ... done
  Created wheel for masifutilv2: filename=masi futilv2-0.1.0-py3-none-any.whl size=3497 sha256=038712975b7d7eb1f3fefa799da9e294b34 e79caea24abb444dd81f4cc44b36e
  Stored in folder: /private/var/folders/xp/g88fvmgs0k90w0rc_qq4xkzxpsx11v/T/pip-ephem-wheel-cache-l2eyp_wq/wheels/de/14/12/71b4d696301fd1052adf287191fdd054cc17ef6c9b59066277
Successfully built masifutilv2
Installing collected packages: masifutilv2
Successfully installed masifutilv2-0.1.0</pre>
			<p>The package is installed<a id="_idIndexMarker242"/> successfully using <code>wheel</code> this time and we can see it appears in our virtual environment as follows:</p>
			<div><div><img src="img/B17189_02_11.jpg" alt="Figure 2.11 – A view of the virtual environment after installing masifutilv2 with wheel and using pip &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – A view of the virtual environment after installing masifutilv2 with wheel and using pip </p>
			<p>In this section, we have installed a package using the pip utility from the local source code. In the next section, we will publish the package to a centralized repository (Test PyPI).</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor105"/>Publishing a package to Test PyPI</h2>
			<p>As a next step, we<a id="_idIndexMarker243"/> will add our sample package to the PyPI repository. Before executing any command for publishing our package, we will need to create an <a id="_idIndexMarker244"/>account on Test PyPI. Note that Test PyPI is a separate instance of the package index specifically for testing. In addition to the account with Test PyPI, we also need to add an <strong class="bold">API token</strong> to the account. We will leave the details of creating an account and adding an API token to the account for you by following the instructions available on the Test PyPI website (<a href="https://test.pypi.org/">https://test.pypi.org/</a>).</p>
			<p>To push the package to Test PyPI, we will need the Twine utility. We assume Twine is installed using the pip utility. To upload the <code>masifutilv2</code> package, we will execute the following steps:</p>
			<ol>
				<li>Create a distribution using the following command. This <code>sdist</code> utility will create a TAR ZIP file under a <code>dist</code> folder:<pre>&gt; python setup.py sdist</pre></li>
				<li>Upload the distribution file to Test PyPI. When prompted for a username and password, provide <code>__token__</code> as the username and the API token as the password:<pre>&gt; twine upload --repository testpypi dist/masifutilv2-0.1.0.tar.gz </pre><p>This command will push the package TAR ZIP file to the Test PyPI repository and the console output will be similar to the following:</p><pre><strong class="bold">Uploading distributions to https://test.pypi.org/legacy/</strong>
<strong class="bold">Enter your username: __token__</strong>
<strong class="bold">Enter your password: </strong>
<strong class="bold">Uploading masifutilv2-0.1.0.tar.gz</strong>
<strong class="bold">100%|█████████████████████| </strong>
<strong class="bold">5.15k/5.15k [00:02&lt;00:00, 2.21kB/s]</strong></pre></li>
			</ol>
			<p>We can view the uploaded file at <a href="https://test.pypi.org/project/masifutilv2/0.1.0/">https://test.pypi.org/project/masifutilv2/0.1.0/</a> after a successful upload.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor106"/>Installing the package from PyPI</h2>
			<p>Installing the package from Test PyPI is the same <a id="_idIndexMarker245"/>as installing from a regular repository, except<a id="_idIndexMarker246"/> that we need to provide the repository URL by using the <code>index-url</code> arguments. The command and the console output will be similar to the following:</p>
			<pre>&gt; pip install --index-url https://test.pypi.org/simple/ --no-deps masifutilv2</pre>
			<p>This command will present console output similar to the following:</p>
			<pre>Looking in indexes: https://test.pypi.org/simple/
Collecting masifutilv2
  Downloading https://test-files.pythonhosted.org/  packages/b7/e9/7afe390b4ec1e5842e8e62a6084505cbc6b9   f6adf0e37ac695cd23156844/masifutilv2-0.1.0.tar.gz (2.3 kB)
Building wheels for collected packages: masifutilv2
  Building wheel for masifutilv2 (setup.py) ... done
  Created wheel for masifutilv2: filename=masifutilv2-  0.1.0-py3-none-any.whl size=3497   sha256=a3db8f04b118e16ae291bad9642483874   f5c9f447dbee57c0961b5f8fbf99501
  Stored in folder: /Users/muasif/Library/Caches/pip/  wheels/1c/47/29/95b9edfe28f02a605757c1   f1735660a6f79807ece430f5b836
Successfully built masifutilv2
Installing collected packages: masifutilv2
Successfully installed masifutilv2-0.1.0</pre>
			<p>As we can see in the console output, pip is searching for the module in Test PyPI. Once it finds the package with the name <code>masifutilv2</code>, it starts downloading and then installing it in the virtual environment.</p>
			<p>In short, we have <a id="_idIndexMarker247"/>observed that once we create a package using the <a id="_idIndexMarker248"/>recommended format and style, then publishing and accessing the package is just a matter of using Python utilities and following the standard steps.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor107"/>Summary</h1>
			<p>In this chapter, we introduced the concept of modules and packages in Python. We discussed how to build reusable modules and how they can be imported by other modules and programs. We also covered the loading and initializing of modules when included (by an import process) by other programs. In the later part of this chapter, we discussed building simple and advanced packages. We also provided a lot of code examples to access the packages, as well as installing and publishing the package for efficient reusability.</p>
			<p>After going through this chapter, you have learned how to build modules and packages and how to share and publish the packages (and modules). These skills are important if you are working on a project as a team in an organization or you are building Python libraries for a larger community.</p>
			<p>In the next chapter, we will discuss the next level of modularization using object-oriented programming in Python. This will encompass encapsulation, inheritance, polymorphism, and abstraction, which are key tools to build and manage complex projects in the real world. </p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor108"/>Questions</h1>
			<ol>
				<li value="1">What is the difference between a module and a package?</li>
				<li>What are absolute and relative imports in Python?</li>
				<li>What is PyPA?</li>
				<li>What is Test PyPI and why do we need it?</li>
				<li>Is an <code>init</code> file a requirement to build a package?</li>
			</ol>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor109"/>Further reading</h1>
			<ul>
				<li><em class="italic">Modular Programming with Python</em> by Erik Westra</li>
				<li><em class="italic">Expert Python Programming</em> by Michał Jaworski and Tarek Ziadé</li>
				<li>Python Packaging User Guide (<a href="https://packaging.python.org/">https://packaging.python.org/</a>)</li>
				<li>PEP 420: Implicit Namespace Packages (<a href="https://www.python.org/dev/peps/pep-0420/">https://www.python.org/dev/peps/pep-0420/</a>)</li>
			</ul>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor110"/>Answers</h1>
			<ol>
				<li value="1">A module is meant to organize functions, variables, and classes into separate Python code files. A Python package is like a folder to organize multiple modules or sub-packages.</li>
				<li>Absolute import requires the use of the absolute path of a package starting from the top level, whereas relative import is based on the relative path of the package as per the current location of the program in which the <code>import</code> statement is to be used.</li>
				<li>The <strong class="bold">Python Packaging Authority</strong> (<strong class="bold">PyPA</strong>) is a working group that maintains a core set of software projects used in Python packaging.</li>
				<li>Test PyPI is a repository of software for the Python programming language for testing purposes.</li>
				<li>The <code>init</code> file is optional since Python version 3.3.</li>
			</ol>
		</div>
	</body></html>